In archive Build/libwolfssl.a:

wolf_main.o:     file format elf32-littlearm


Disassembly of section .text.my_time:

00000000 <my_time>:
static int gTimeMs;
static int hw_get_time_sec(void)
{
    #warning Must implement your own time source if validating certificates

	return ++gTimeMs;
   0:	4b02      	ldr	r3, [pc, #8]	; (c <my_time+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
   4:	3001      	adds	r0, #1
   6:	6018      	str	r0, [r3, #0]
/* This is used by wolfCrypt asn.c for cert time checking */
unsigned long my_time(unsigned long* timer)
{
    (void)timer;
    return hw_get_time_sec();
}
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	00000000 	.word	0x00000000

Disassembly of section .text.LowResTimer:

00000000 <LowResTimer>:
	return ++gTimeMs;
   0:	4b02      	ldr	r3, [pc, #8]	; (c <LowResTimer+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
   4:	3001      	adds	r0, #1
   6:	6018      	str	r0, [r3, #0]
#ifndef WOLFCRYPT_ONLY
/* This is used by TLS only */
unsigned int LowResTimer(void)
{
    return hw_get_time_sec();
}
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	00000000 	.word	0x00000000

Disassembly of section .text.current_time:

00000000 <current_time>:
#ifndef NO_CRYPT_BENCHMARK
/* This is used by wolfCrypt benchmark tool only */
double current_time(int reset)
{
    double timeNow;
    int timeMs = gTimeMs;
   0:	4b0d      	ldr	r3, [pc, #52]	; (38 <current_time+0x38>)
{
   2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int timeMs = gTimeMs;
   6:	f8d3 8000 	ldr.w	r8, [r3]
    (void)reset;
    timeNow = (timeMs / 1000); // sec
   a:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
   e:	fb98 f6f7 	sdiv	r6, r8, r7
  12:	4630      	mov	r0, r6
  14:	f7ff fffe 	bl	0 <__aeabi_i2d>
  18:	4604      	mov	r4, r0
    timeNow += (double)(timeMs % 1000) / 1000; // ms
  1a:	fb07 8016 	mls	r0, r7, r6, r8
    timeNow = (timeMs / 1000); // sec
  1e:	460d      	mov	r5, r1
    timeNow += (double)(timeMs % 1000) / 1000; // ms
  20:	f7ff fffe 	bl	0 <__aeabi_i2d>
  24:	4b05      	ldr	r3, [pc, #20]	; (3c <current_time+0x3c>)
  26:	2200      	movs	r2, #0
  28:	f7ff fffe 	bl	0 <__aeabi_ddiv>
  2c:	4622      	mov	r2, r4
  2e:	462b      	mov	r3, r5
  30:	f7ff fffe 	bl	0 <__aeabi_dadd>
    return timeNow;
}
  34:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  38:	00000000 	.word	0x00000000
  3c:	408f4000 	.word	0x408f4000

Disassembly of section .text.hw_rand:

00000000 <hw_rand>:
static unsigned int gCounter;
unsigned int hw_rand(void)
{
    #warning Must implement your own random source

    return ++gCounter;
   0:	4b02      	ldr	r3, [pc, #8]	; (c <hw_rand+0xc>)
   2:	6818      	ldr	r0, [r3, #0]
   4:	3001      	adds	r0, #1
   6:	6018      	str	r0, [r3, #0]
}
   8:	4770      	bx	lr
   a:	bf00      	nop
   c:	00000000 	.word	0x00000000

Disassembly of section .text.my_rng_seed_gen:

00000000 <my_rng_seed_gen>:

unsigned int my_rng_seed_gen(void)
{
    return hw_rand();
   0:	f7ff bffe 	b.w	0 <my_rng_seed_gen>

Disassembly of section .text.my_rng_gen_block:

00000000 <my_rng_gen_block>:
}

int my_rng_gen_block(unsigned char* output, unsigned int sz)
{
   0:	b570      	push	{r4, r5, r6, lr}
    uint32_t i = 0;
   2:	2200      	movs	r2, #0
{
   4:	4604      	mov	r4, r0

    while (i < sz)
   6:	428a      	cmp	r2, r1
   8:	d301      	bcc.n	e <my_rng_gen_block+0xe>
            i += sizeof(CUSTOM_RAND_TYPE);
        }
    }

    return 0;
}
   a:	2000      	movs	r0, #0
   c:	bd70      	pop	{r4, r5, r6, pc}
        if( (i + sizeof(CUSTOM_RAND_TYPE)) > sz ||
   e:	1d15      	adds	r5, r2, #4
  10:	428d      	cmp	r5, r1
            ((uint32_t)&output[i] % sizeof(CUSTOM_RAND_TYPE)) != 0
  12:	eb04 0602 	add.w	r6, r4, r2
        if( (i + sizeof(CUSTOM_RAND_TYPE)) > sz ||
  16:	d801      	bhi.n	1c <my_rng_gen_block+0x1c>
  18:	07b3      	lsls	r3, r6, #30
  1a:	d005      	beq.n	28 <my_rng_gen_block+0x28>
    return hw_rand();
  1c:	f7ff fffe 	bl	0 <my_rng_gen_block>
            output[i++] = (unsigned char)my_rng_seed_gen();
  20:	1c55      	adds	r5, r2, #1
  22:	7030      	strb	r0, [r6, #0]
{
  24:	462a      	mov	r2, r5
  26:	e7ee      	b.n	6 <my_rng_gen_block+0x6>
    return hw_rand();
  28:	f7ff fffe 	bl	0 <my_rng_gen_block>
            *((CUSTOM_RAND_TYPE*)&output[i]) = my_rng_seed_gen();
  2c:	6030      	str	r0, [r6, #0]
            i += sizeof(CUSTOM_RAND_TYPE);
  2e:	e7f9      	b.n	24 <my_rng_gen_block+0x24>

armtarget.o:     file format elf32-littlearm


Disassembly of section .text.Default_Handler:

00000000 <Default_Handler>:
#ifdef USE_WOLF_ARM_STARTUP
// Vector Exception/Interrupt Handlers
static void Default_Handler(void)
{
    /* If we get here then need to implement real IRQ handler */
    while(1);
   0:	e7fe      	b.n	0 <Default_Handler>

Disassembly of section .sys:

00000000 <HardFault_Handler>:
}

__attribute__((section(".sys")))  __attribute__( ( naked ) )
void HardFault_Handler(void)
{
    __asm volatile
   0:	2004      	movs	r0, #4
   2:	4671      	mov	r1, lr
   4:	4208      	tst	r0, r1
   6:	d002      	beq.n	e <_MSP>
   8:	f3ef 8009 	mrs	r0, PSP
   c:	e001      	b.n	12 <_GetPC>

0000000e <_MSP>:
   e:	f3ef 8008 	mrs	r0, MSP

00000012 <_GetPC>:
  12:	6941      	ldr	r1, [r0, #20]
  14:	4a42      	ldr	r2, [pc, #264]	; (120 <HardFault_HandlerC+0x106>)
  16:	4710      	bx	r2
  18:	4770      	bx	lr

0000001a <HardFault_HandlerC>:
{
  1a:	b500      	push	{lr}
  1c:	b08f      	sub	sp, #60	; 0x3c
    stacked_r0 = ((uint32_t)hardfault_args[0]);
  1e:	6803      	ldr	r3, [r0, #0]
  20:	9300      	str	r3, [sp, #0]
    stacked_r1 = ((uint32_t)hardfault_args[1]);
  22:	6843      	ldr	r3, [r0, #4]
  24:	9301      	str	r3, [sp, #4]
    stacked_r2 = ((uint32_t)hardfault_args[2]);
  26:	6883      	ldr	r3, [r0, #8]
  28:	9302      	str	r3, [sp, #8]
    stacked_r3 = ((uint32_t)hardfault_args[3]);
  2a:	68c3      	ldr	r3, [r0, #12]
  2c:	9303      	str	r3, [sp, #12]
    stacked_r12 = ((uint32_t)hardfault_args[4]);
  2e:	6903      	ldr	r3, [r0, #16]
  30:	9304      	str	r3, [sp, #16]
    stacked_lr = ((uint32_t)hardfault_args[5]);
  32:	6943      	ldr	r3, [r0, #20]
  34:	9305      	str	r3, [sp, #20]
    stacked_pc = ((uint32_t)hardfault_args[6]);
  36:	6983      	ldr	r3, [r0, #24]
  38:	9306      	str	r3, [sp, #24]
    stacked_psr = ((uint32_t)hardfault_args[7]);
  3a:	69c3      	ldr	r3, [r0, #28]
  3c:	9307      	str	r3, [sp, #28]
    _CFSR = (*((volatile uint32_t *)(0xE000ED28)));
  3e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    printf ("\n\nHard fault handler (all numbers in hex):\n");
  42:	4828      	ldr	r0, [pc, #160]	; (e4 <HardFault_HandlerC+0xca>)
    _CFSR = (*((volatile uint32_t *)(0xE000ED28)));
  44:	f8d3 2d28 	ldr.w	r2, [r3, #3368]	; 0xd28
  48:	9208      	str	r2, [sp, #32]
    _HFSR = (*((volatile uint32_t *)(0xE000ED2C)));
  4a:	f8d3 2d2c 	ldr.w	r2, [r3, #3372]	; 0xd2c
  4e:	9209      	str	r2, [sp, #36]	; 0x24
    _DFSR = (*((volatile uint32_t *)(0xE000ED30)));
  50:	f8d3 2d30 	ldr.w	r2, [r3, #3376]	; 0xd30
  54:	920a      	str	r2, [sp, #40]	; 0x28
    _AFSR = (*((volatile uint32_t *)(0xE000ED3C)));
  56:	f8d3 2d3c 	ldr.w	r2, [r3, #3388]	; 0xd3c
  5a:	920b      	str	r2, [sp, #44]	; 0x2c
    _MMAR = (*((volatile uint32_t *)(0xE000ED34)));
  5c:	f8d3 2d34 	ldr.w	r2, [r3, #3380]	; 0xd34
  60:	920d      	str	r2, [sp, #52]	; 0x34
    _BFAR = (*((volatile uint32_t *)(0xE000ED38)));
  62:	f8d3 3d38 	ldr.w	r3, [r3, #3384]	; 0xd38
  66:	930c      	str	r3, [sp, #48]	; 0x30
    printf ("\n\nHard fault handler (all numbers in hex):\n");
  68:	f7ff fffe 	bl	0 <printf>
    printf ("R0 = %lx\n", stacked_r0);
  6c:	9900      	ldr	r1, [sp, #0]
  6e:	481e      	ldr	r0, [pc, #120]	; (e8 <HardFault_HandlerC+0xce>)
  70:	f7ff fffe 	bl	0 <printf>
    printf ("R1 = %lx\n", stacked_r1);
  74:	9901      	ldr	r1, [sp, #4]
  76:	481d      	ldr	r0, [pc, #116]	; (ec <HardFault_HandlerC+0xd2>)
  78:	f7ff fffe 	bl	0 <printf>
    printf ("R2 = %lx\n", stacked_r2);
  7c:	9902      	ldr	r1, [sp, #8]
  7e:	481c      	ldr	r0, [pc, #112]	; (f0 <HardFault_HandlerC+0xd6>)
  80:	f7ff fffe 	bl	0 <printf>
    printf ("R3 = %lx\n", stacked_r3);
  84:	9903      	ldr	r1, [sp, #12]
  86:	481b      	ldr	r0, [pc, #108]	; (f4 <HardFault_HandlerC+0xda>)
  88:	f7ff fffe 	bl	0 <printf>
    printf ("R12 = %lx\n", stacked_r12);
  8c:	9904      	ldr	r1, [sp, #16]
  8e:	481a      	ldr	r0, [pc, #104]	; (f8 <HardFault_HandlerC+0xde>)
  90:	f7ff fffe 	bl	0 <printf>
    printf ("LR [R14] = %lx  subroutine call return address\n", stacked_lr);
  94:	9905      	ldr	r1, [sp, #20]
  96:	4819      	ldr	r0, [pc, #100]	; (fc <HardFault_HandlerC+0xe2>)
  98:	f7ff fffe 	bl	0 <printf>
    printf ("PC [R15] = %lx  program counter\n", stacked_pc);
  9c:	9906      	ldr	r1, [sp, #24]
  9e:	4818      	ldr	r0, [pc, #96]	; (100 <HardFault_HandlerC+0xe6>)
  a0:	f7ff fffe 	bl	0 <printf>
    printf ("PSR = %lx\n", stacked_psr);
  a4:	9907      	ldr	r1, [sp, #28]
  a6:	4817      	ldr	r0, [pc, #92]	; (104 <HardFault_HandlerC+0xea>)
  a8:	f7ff fffe 	bl	0 <printf>
    printf ("CFSR = %lx\n", _CFSR);
  ac:	9908      	ldr	r1, [sp, #32]
  ae:	4816      	ldr	r0, [pc, #88]	; (108 <HardFault_HandlerC+0xee>)
  b0:	f7ff fffe 	bl	0 <printf>
    printf ("HFSR = %lx\n", _HFSR);
  b4:	9909      	ldr	r1, [sp, #36]	; 0x24
  b6:	4815      	ldr	r0, [pc, #84]	; (10c <HardFault_HandlerC+0xf2>)
  b8:	f7ff fffe 	bl	0 <printf>
    printf ("DFSR = %lx\n", _DFSR);
  bc:	990a      	ldr	r1, [sp, #40]	; 0x28
  be:	4814      	ldr	r0, [pc, #80]	; (110 <HardFault_HandlerC+0xf6>)
  c0:	f7ff fffe 	bl	0 <printf>
    printf ("AFSR = %lx\n", _AFSR);
  c4:	990b      	ldr	r1, [sp, #44]	; 0x2c
  c6:	4813      	ldr	r0, [pc, #76]	; (114 <HardFault_HandlerC+0xfa>)
  c8:	f7ff fffe 	bl	0 <printf>
    printf ("MMAR = %lx\n", _MMAR);
  cc:	990d      	ldr	r1, [sp, #52]	; 0x34
  ce:	4812      	ldr	r0, [pc, #72]	; (118 <HardFault_HandlerC+0xfe>)
  d0:	f7ff fffe 	bl	0 <printf>
    printf ("BFAR = %lx\n", _BFAR);
  d4:	990c      	ldr	r1, [sp, #48]	; 0x30
  d6:	4811      	ldr	r0, [pc, #68]	; (11c <HardFault_HandlerC+0x102>)
  d8:	f7ff fffe 	bl	0 <printf>
    __asm("BKPT #0\n");
  dc:	be00      	bkpt	0x0000
}
  de:	b00f      	add	sp, #60	; 0x3c
  e0:	f85d fb04 	ldr.w	pc, [sp], #4
  e4:	00000000 	.word	0x00000000
  e8:	0000002c 	.word	0x0000002c
  ec:	00000036 	.word	0x00000036
  f0:	00000040 	.word	0x00000040
  f4:	0000004a 	.word	0x0000004a
  f8:	00000054 	.word	0x00000054
  fc:	0000005f 	.word	0x0000005f
 100:	0000008f 	.word	0x0000008f
 104:	000000b0 	.word	0x000000b0
 108:	000000bb 	.word	0x000000bb
 10c:	000000c7 	.word	0x000000c7
 110:	000000d3 	.word	0x000000d3
 114:	000000df 	.word	0x000000df
 118:	000000eb 	.word	0x000000eb
 11c:	000000f7 	.word	0x000000f7
 120:	00000000 	.word	0x00000000

Disassembly of section .text.memcpy32:

00000000 <memcpy32>:
    while (dst_beg < dst_end) {
   0:	428a      	cmp	r2, r1
   2:	d800      	bhi.n	6 <memcpy32+0x6>
}
   4:	4770      	bx	lr
        *dst_beg++ = *src++;
   6:	f850 3b04 	ldr.w	r3, [r0], #4
   a:	f841 3b04 	str.w	r3, [r1], #4
   e:	e7f7      	b.n	0 <memcpy32>

Disassembly of section .text.meminit32:

00000000 <meminit32>:
        *start++ = 0;
   0:	2300      	movs	r3, #0
    while (start < end) {
   2:	4288      	cmp	r0, r1
   4:	d300      	bcc.n	8 <meminit32+0x8>
}
   6:	4770      	bx	lr
        *start++ = 0;
   8:	f840 3b04 	str.w	r3, [r0], #4
   c:	e7f9      	b.n	2 <meminit32+0x2>

Disassembly of section .text.reset_handler:

00000000 <reset_handler>:
{
   0:	b508      	push	{r3, lr}
    memcpy32(__data_load_start__, __data_start__, __data_end__);
   2:	4a09      	ldr	r2, [pc, #36]	; (28 <reset_handler+0x28>)
   4:	4909      	ldr	r1, [pc, #36]	; (2c <reset_handler+0x2c>)
   6:	480a      	ldr	r0, [pc, #40]	; (30 <reset_handler+0x30>)
   8:	f7ff fffe 	bl	0 <reset_handler>
    meminit32(__bss_start__, __bss_end__);
   c:	4909      	ldr	r1, [pc, #36]	; (34 <reset_handler+0x34>)
   e:	480a      	ldr	r0, [pc, #40]	; (38 <reset_handler+0x38>)
  10:	f7ff fffe 	bl	0 <reset_handler>
    __heap_start__[0] = 0;
  14:	4b09      	ldr	r3, [pc, #36]	; (3c <reset_handler+0x3c>)
  16:	2200      	movs	r2, #0
  18:	601a      	str	r2, [r3, #0]
    __heap_start__[1] = ((uintptr_t)__heap_end__ - (uintptr_t)__heap_start__);
  1a:	4a09      	ldr	r2, [pc, #36]	; (40 <reset_handler+0x40>)
  1c:	1ad2      	subs	r2, r2, r3
  1e:	605a      	str	r2, [r3, #4]
    main();
  20:	f7ff fffe 	bl	0 <main>
    while(1);
  24:	e7fe      	b.n	24 <reset_handler+0x24>
  26:	bf00      	nop
	...

test.o:     file format elf32-littlearm


Disassembly of section .text.time_cb:

00000000 <time_cb>:
#endif /* WOLFSSL_CERT_PIV */

#if !defined(NO_ASN) && !defined(NO_ASN_TIME)
static time_t time_cb(time_t* t)
{
    if (t != NULL) {
   0:	b118      	cbz	r0, a <time_cb+0xa>
        *t = 99;
   2:	2263      	movs	r2, #99	; 0x63
   4:	2300      	movs	r3, #0
   6:	e9c0 2300 	strd	r2, r3, [r0]
    }

    return 99;
}
   a:	2063      	movs	r0, #99	; 0x63
   c:	2100      	movs	r1, #0
   e:	4770      	bx	lr

Disassembly of section .text.print_fiducials:

00000000 <print_fiducials>:
static const int fiducial4 = WC_TEST_RET_LN;

/* print the fiducial line numbers assigned above, allowing confirmation of
 * source code version match when in doubt.
 */
static void print_fiducials(void) {
   0:	b507      	push	{r0, r1, r2, lr}
    printf(" [fiducial line numbers: %d %d %d %d]\n",
   2:	f64b 6368 	movw	r3, #48744	; 0xbe68
   6:	9300      	str	r3, [sp, #0]
   8:	f645 72a8 	movw	r2, #24488	; 0x5fa8
   c:	f648 63d5 	movw	r3, #36565	; 0x8ed5
  10:	f641 61f1 	movw	r1, #7921	; 0x1ef1
  14:	4805      	ldr	r0, [pc, #20]	; (2c <print_fiducials+0x2c>)
  16:	f7ff fffe 	bl	0 <printf>
  1a:	4b05      	ldr	r3, [pc, #20]	; (30 <print_fiducials+0x30>)
  1c:	681b      	ldr	r3, [r3, #0]
  1e:	6898      	ldr	r0, [r3, #8]
           fiducial1, fiducial2, fiducial3, fiducial4);
}
  20:	b003      	add	sp, #12
  22:	f85d eb04 	ldr.w	lr, [sp], #4
    printf(" [fiducial line numbers: %d %d %d %d]\n",
  26:	f7ff bffe 	b.w	0 <fflush>
  2a:	bf00      	nop
	...

Disassembly of section .text.render_error_message:

00000000 <render_error_message>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    switch (WC_TEST_RET_DEC_TAG(es)) {
   2:	424c      	negs	r4, r1
   4:	1762      	asrs	r2, r4, #29
{
   6:	4605      	mov	r5, r0
    switch (WC_TEST_RET_DEC_TAG(es)) {
   8:	2a03      	cmp	r2, #3
   a:	d83e      	bhi.n	8a <render_error_message+0x8a>
   c:	e8df f002 	tbb	[pc, r2]
  10:	33271302 	.word	0x33271302
        err_sys_printf("%s error L=%d\n", msg, WC_TEST_RET_DEC_LN(es));
  14:	4a1e      	ldr	r2, [pc, #120]	; (90 <render_error_message+0x90>)
  16:	fb94 f1f2 	sdiv	r1, r4, r2
  1a:	fb02 4211 	mls	r2, r2, r1, r4
  1e:	4601      	mov	r1, r0
  20:	481c      	ldr	r0, [pc, #112]	; (94 <render_error_message+0x94>)
  22:	f7ff fffe 	bl	0 <printf>
        err_sys_printf("%s error L=%d i=%d\n", msg,
  26:	4b1c      	ldr	r3, [pc, #112]	; (98 <render_error_message+0x98>)
  28:	681b      	ldr	r3, [r3, #0]
  2a:	6898      	ldr	r0, [r3, #8]
}
  2c:	b002      	add	sp, #8
  2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        err_sys_printf("%s error L=%d i=%d\n", msg,
  32:	f7ff bffe 	b.w	0 <fflush>
        err_sys_printf("%s error L=%d code=%d (%s)\n", msg,
  36:	f024 44c0 	bic.w	r4, r4, #1610612736	; 0x60000000
  3a:	4e18      	ldr	r6, [pc, #96]	; (9c <render_error_message+0x9c>)
  3c:	fb94 f6f6 	sdiv	r6, r4, r6
  40:	4630      	mov	r0, r6
  42:	f7ff fffe 	bl	0 <wc_GetErrorString>
  46:	4a12      	ldr	r2, [pc, #72]	; (90 <render_error_message+0x90>)
  48:	9000      	str	r0, [sp, #0]
  4a:	fbb4 f1f2 	udiv	r1, r4, r2
  4e:	4633      	mov	r3, r6
  50:	fb02 4211 	mls	r2, r2, r1, r4
  54:	4812      	ldr	r0, [pc, #72]	; (a0 <render_error_message+0xa0>)
  56:	4629      	mov	r1, r5
  58:	f7ff fffe 	bl	0 <printf>
  5c:	e7e3      	b.n	26 <render_error_message+0x26>
        err_sys_printf("%s error L=%d errno=%d\n", msg,
  5e:	490c      	ldr	r1, [pc, #48]	; (90 <render_error_message+0x90>)
  60:	f024 42c0 	bic.w	r2, r4, #1610612736	; 0x60000000
  64:	fbb2 f3f1 	udiv	r3, r2, r1
  68:	fb01 2213 	mls	r2, r1, r3, r2
  6c:	4601      	mov	r1, r0
  6e:	480d      	ldr	r0, [pc, #52]	; (a4 <render_error_message+0xa4>)
        err_sys_printf("%s error L=%d i=%d\n", msg,
  70:	f7ff fffe 	bl	0 <printf>
  74:	e7d7      	b.n	26 <render_error_message+0x26>
  76:	4906      	ldr	r1, [pc, #24]	; (90 <render_error_message+0x90>)
  78:	f024 42c0 	bic.w	r2, r4, #1610612736	; 0x60000000
  7c:	fbb2 f3f1 	udiv	r3, r2, r1
  80:	fb01 2213 	mls	r2, r1, r3, r2
  84:	4601      	mov	r1, r0
  86:	4808      	ldr	r0, [pc, #32]	; (a8 <render_error_message+0xa8>)
  88:	e7f2      	b.n	70 <render_error_message+0x70>
}
  8a:	b002      	add	sp, #8
  8c:	bd70      	pop	{r4, r5, r6, pc}
  8e:	bf00      	nop
  90:	000186a0 	.word	0x000186a0
	...
  9c:	fffe7960 	.word	0xfffe7960
  a0:	0000000f 	.word	0x0000000f
  a4:	0000002b 	.word	0x0000002b
  a8:	00000043 	.word	0x00000043

Disassembly of section .text._rng_test:

00000000 <_rng_test>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	b089      	sub	sp, #36	; 0x24
   4:	4605      	mov	r5, r0
    XMEMSET(block, 0, sizeof(block));
   6:	2220      	movs	r2, #32
{
   8:	460f      	mov	r7, r1
    XMEMSET(block, 0, sizeof(block));
   a:	4668      	mov	r0, sp
   c:	2100      	movs	r1, #0
   e:	f7ff fffe 	bl	0 <memset>
    ret = wc_RNG_GenerateBlock(rng, block, sizeof(block));
  12:	2220      	movs	r2, #32
  14:	4669      	mov	r1, sp
  16:	4628      	mov	r0, r5
  18:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
    if (ret != 0) {
  1c:	bb80      	cbnz	r0, 80 <_rng_test+0x80>
  1e:	466b      	mov	r3, sp
    for (i=0; i<(int)sizeof(block); i++) {
  20:	4606      	mov	r6, r0
        if (block[i] == 0) {
  22:	f813 2b01 	ldrb.w	r2, [r3], #1
  26:	b902      	cbnz	r2, 2a <_rng_test+0x2a>
            ret++;
  28:	3001      	adds	r0, #1
    for (i=0; i<(int)sizeof(block); i++) {
  2a:	3601      	adds	r6, #1
  2c:	2e20      	cmp	r6, #32
  2e:	d1f8      	bne.n	22 <_rng_test+0x22>
    if (ret >= (int)sizeof(block)) {
  30:	281f      	cmp	r0, #31
  32:	dc27      	bgt.n	84 <_rng_test+0x84>
    ret = wc_RNG_GenerateByte(rng, block);
  34:	4669      	mov	r1, sp
  36:	4628      	mov	r0, r5
  38:	f7ff fffe 	bl	0 <wc_RNG_GenerateByte>
    if (ret != 0) {
  3c:	4604      	mov	r4, r0
  3e:	bb18      	cbnz	r0, 88 <_rng_test+0x88>
    ret = wc_RNG_GenerateBlock(NULL, block, sizeof(block));
  40:	4632      	mov	r2, r6
  42:	4669      	mov	r1, sp
  44:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
    if (ret != BAD_FUNC_ARG) {
  48:	30ad      	adds	r0, #173	; 0xad
  4a:	d11f      	bne.n	8c <_rng_test+0x8c>
    ret = wc_RNG_GenerateBlock(rng, NULL, sizeof(block));
  4c:	4632      	mov	r2, r6
  4e:	4621      	mov	r1, r4
  50:	4628      	mov	r0, r5
  52:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
    if (ret != BAD_FUNC_ARG) {
  56:	30ad      	adds	r0, #173	; 0xad
  58:	d11a      	bne.n	90 <_rng_test+0x90>
    ret = wc_RNG_GenerateByte(NULL, block);
  5a:	4669      	mov	r1, sp
  5c:	4620      	mov	r0, r4
  5e:	f7ff fffe 	bl	0 <wc_RNG_GenerateByte>
    if (ret != BAD_FUNC_ARG) {
  62:	30ad      	adds	r0, #173	; 0xad
  64:	d116      	bne.n	94 <_rng_test+0x94>
    ret = wc_RNG_GenerateByte(rng, NULL);
  66:	4621      	mov	r1, r4
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <wc_RNG_GenerateByte>
    if (ret != BAD_FUNC_ARG) {
  6e:	30ad      	adds	r0, #173	; 0xad
  70:	d003      	beq.n	7a <_rng_test+0x7a>
        ret = 7;
  72:	2007      	movs	r0, #7
        ret = errorOffset - (ret * 1000000);
  74:	4c08      	ldr	r4, [pc, #32]	; (98 <_rng_test+0x98>)
  76:	fb04 7400 	mla	r4, r4, r0, r7
}
  7a:	4620      	mov	r0, r4
  7c:	b009      	add	sp, #36	; 0x24
  7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = 1;
  80:	2001      	movs	r0, #1
  82:	e7f7      	b.n	74 <_rng_test+0x74>
        ret = 2;
  84:	2002      	movs	r0, #2
  86:	e7f5      	b.n	74 <_rng_test+0x74>
        ret = 3;
  88:	2003      	movs	r0, #3
  8a:	e7f3      	b.n	74 <_rng_test+0x74>
        ret = 4;
  8c:	2004      	movs	r0, #4
  8e:	e7f1      	b.n	74 <_rng_test+0x74>
        ret = 5;
  90:	2005      	movs	r0, #5
  92:	e7ef      	b.n	74 <_rng_test+0x74>
        ret = 6;
  94:	2006      	movs	r0, #6
  96:	e7ed      	b.n	74 <_rng_test+0x74>
  98:	fff0bdc0 	.word	0xfff0bdc0

Disassembly of section .text.random_rng_test:

00000000 <random_rng_test>:
{
   0:	b530      	push	{r4, r5, lr}
   2:	b085      	sub	sp, #20
    ret = wc_InitRng_ex(rng, HEAP_HINT, devId);
   4:	f06f 0201 	mvn.w	r2, #1
   8:	2100      	movs	r1, #0
   a:	4668      	mov	r0, sp
   c:	f7ff fffe 	bl	0 <wc_InitRng_ex>
    if (ret != 0)
  10:	b148      	cbz	r0, 26 <random_rng_test+0x26>
        return WC_TEST_RET_ENC_EC(ret);
  12:	4a14      	ldr	r2, [pc, #80]	; (64 <random_rng_test+0x64>)
  14:	4c14      	ldr	r4, [pc, #80]	; (68 <random_rng_test+0x68>)
  16:	4240      	negs	r0, r0
  18:	f3c0 000a 	ubfx	r0, r0, #0, #11
  1c:	fb02 4400 	mla	r4, r2, r0, r4
}
  20:	4620      	mov	r0, r4
  22:	b005      	add	sp, #20
  24:	bd30      	pop	{r4, r5, pc}
    ret = _rng_test(rng, WC_TEST_RET_ENC_NC);
  26:	f46f 5165 	mvn.w	r1, #14656	; 0x3940
  2a:	4668      	mov	r0, sp
  2c:	f7ff fffe 	bl	0 <random_rng_test>
  30:	4604      	mov	r4, r0
    wc_FreeRng(rng);
  32:	4668      	mov	r0, sp
  34:	f7ff fffe 	bl	0 <wc_FreeRng>
    if (ret != 0)
  38:	2c00      	cmp	r4, #0
  3a:	d1f1      	bne.n	20 <random_rng_test+0x20>
        rng = wc_rng_new(nonce, (word32)sizeof(nonce), HEAP_HINT);
  3c:	2108      	movs	r1, #8
  3e:	4622      	mov	r2, r4
  40:	eb0d 0001 	add.w	r0, sp, r1
        byte nonce[8] = { 0 };
  44:	e9cd 4402 	strd	r4, r4, [sp, #8]
        rng = wc_rng_new(nonce, (word32)sizeof(nonce), HEAP_HINT);
  48:	f7ff fffe 	bl	0 <wc_rng_new>
        if (rng == NULL)
  4c:	4605      	mov	r5, r0
  4e:	b908      	cbnz	r0, 54 <random_rng_test+0x54>
            return WC_TEST_RET_ENC_ERRNO;
  50:	4c06      	ldr	r4, [pc, #24]	; (6c <random_rng_test+0x6c>)
  52:	e7e5      	b.n	20 <random_rng_test+0x20>
        ret = _rng_test(rng, WC_TEST_RET_ENC_NC);
  54:	4906      	ldr	r1, [pc, #24]	; (70 <random_rng_test+0x70>)
  56:	f7ff fffe 	bl	0 <random_rng_test>
  5a:	4604      	mov	r4, r0
        wc_rng_free(rng);
  5c:	4628      	mov	r0, r5
  5e:	f7ff fffe 	bl	0 <wc_rng_free>
    return ret;
  62:	e7dd      	b.n	20 <random_rng_test+0x20>
  64:	fffe7960 	.word	0xfffe7960
  68:	dfffc6c1 	.word	0xdfffc6c1
  6c:	ffffc6b1 	.word	0xffffc6b1
  70:	ffffc6af 	.word	0xffffc6af

Disassembly of section .text.ecc_exp_imp_test:

00000000 <ecc_exp_imp_test>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4606      	mov	r6, r0
   6:	b0e4      	sub	sp, #400	; 0x190
    ecc_key    *keyImp = (ecc_key *)XMALLOC(sizeof *keyImp, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
   8:	f44f 70de 	mov.w	r0, #444	; 0x1bc
   c:	f7ff fffe 	bl	0 <malloc>
    const char qx[] = "7a4e287890a1a47ad3457e52f2f76a83"
  10:	497b      	ldr	r1, [pc, #492]	; (200 <ecc_exp_imp_test+0x200>)
    ecc_key    *keyImp = (ecc_key *)XMALLOC(sizeof *keyImp, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
  12:	4605      	mov	r5, r0
    const char qx[] = "7a4e287890a1a47ad3457e52f2f76a83"
  14:	2241      	movs	r2, #65	; 0x41
  16:	a810      	add	r0, sp, #64	; 0x40
  18:	f7ff fffe 	bl	0 <memcpy>
    const char qy[] = "eec4084f5b29ebf29c44cce3b3059610"
  1c:	4979      	ldr	r1, [pc, #484]	; (204 <ecc_exp_imp_test+0x204>)
  1e:	2241      	movs	r2, #65	; 0x41
  20:	a821      	add	r0, sp, #132	; 0x84
  22:	f7ff fffe 	bl	0 <memcpy>
    const char d[]  = "8c14b793cb19137e323a6d2e2a870bca"
  26:	4978      	ldr	r1, [pc, #480]	; (208 <ecc_exp_imp_test+0x208>)
  28:	2241      	movs	r2, #65	; 0x41
  2a:	a832      	add	r0, sp, #200	; 0xc8
  2c:	f7ff fffe 	bl	0 <memcpy>
    if (keyImp == NULL)
  30:	2d00      	cmp	r5, #0
  32:	f000 80df 	beq.w	1f4 <ecc_exp_imp_test+0x1f4>
    privLen = sizeof(priv);
  36:	f04f 0820 	mov.w	r8, #32
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
  3a:	f06f 0201 	mvn.w	r2, #1
  3e:	2100      	movs	r1, #0
    privLen = sizeof(priv);
  40:	af04      	add	r7, sp, #16
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
  42:	4628      	mov	r0, r5
    ret = wc_ecc_export_private_only(key, priv, &privLen);
  44:	eb0d 0908 	add.w	r9, sp, r8
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
  48:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    ret = wc_ecc_export_private_only(key, priv, &privLen);
  4c:	463a      	mov	r2, r7
  4e:	4649      	mov	r1, r9
  50:	4630      	mov	r0, r6
    privLen = sizeof(priv);
  52:	f8c7 8000 	str.w	r8, [r7]
    ret = wc_ecc_export_private_only(key, priv, &privLen);
  56:	f7ff fffe 	bl	0 <wc_ecc_export_private_only>
    if (ret != 0) {
  5a:	b138      	cbz	r0, 6c <ecc_exp_imp_test+0x6c>
        ret = WC_TEST_RET_ENC_EC(ret);
  5c:	4240      	negs	r0, r0
  5e:	496b      	ldr	r1, [pc, #428]	; (20c <ecc_exp_imp_test+0x20c>)
  60:	4c6b      	ldr	r4, [pc, #428]	; (210 <ecc_exp_imp_test+0x210>)
  62:	f3c0 000a 	ubfx	r0, r0, #0, #11
        ret = WC_TEST_RET_ENC_EC(ret);
  66:	fb01 4400 	mla	r4, r1, r0, r4
        goto done;
  6a:	e07b      	b.n	164 <ecc_exp_imp_test+0x164>
    pubLen = sizeof(pub);
  6c:	2382      	movs	r3, #130	; 0x82
  6e:	9305      	str	r3, [sp, #20]
    ret = wc_ecc_export_point_der(key->idx, &key->pubkey, pub, &pubLen);
  70:	6870      	ldr	r0, [r6, #4]
  72:	ab05      	add	r3, sp, #20
  74:	aa43      	add	r2, sp, #268	; 0x10c
  76:	f106 0118 	add.w	r1, r6, #24
  7a:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
    if (ret != 0) {
  7e:	b128      	cbz	r0, 8c <ecc_exp_imp_test+0x8c>
        ret = WC_TEST_RET_ENC_EC(ret);
  80:	4240      	negs	r0, r0
  82:	4962      	ldr	r1, [pc, #392]	; (20c <ecc_exp_imp_test+0x20c>)
  84:	4c63      	ldr	r4, [pc, #396]	; (214 <ecc_exp_imp_test+0x214>)
  86:	f3c0 000a 	ubfx	r0, r0, #0, #11
  8a:	e7ec      	b.n	66 <ecc_exp_imp_test+0x66>
    ret = wc_ecc_import_private_key(priv, privLen, pub, pubLen, keyImp);
  8c:	9500      	str	r5, [sp, #0]
  8e:	9b05      	ldr	r3, [sp, #20]
  90:	6839      	ldr	r1, [r7, #0]
  92:	aa43      	add	r2, sp, #268	; 0x10c
  94:	4648      	mov	r0, r9
  96:	f7ff fffe 	bl	0 <wc_ecc_import_private_key>
    if (ret != 0) {
  9a:	4604      	mov	r4, r0
  9c:	b128      	cbz	r0, aa <ecc_exp_imp_test+0xaa>
        ret = WC_TEST_RET_ENC_EC(ret);
  9e:	4244      	negs	r4, r0
  a0:	f3c4 000a 	ubfx	r0, r4, #0, #11
  a4:	4959      	ldr	r1, [pc, #356]	; (20c <ecc_exp_imp_test+0x20c>)
  a6:	4c5c      	ldr	r4, [pc, #368]	; (218 <ecc_exp_imp_test+0x218>)
  a8:	e7dd      	b.n	66 <ecc_exp_imp_test+0x66>
    wc_ecc_free(keyImp);
  aa:	4628      	mov	r0, r5
  ac:	f7ff fffe 	bl	0 <wc_ecc_free>
    ret = wc_ecc_import_raw_ex(keyImp, qx, qy, d, ECC_SECP256R1);
  b0:	f04f 0a07 	mov.w	sl, #7
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
  b4:	4621      	mov	r1, r4
  b6:	f06f 0201 	mvn.w	r2, #1
  ba:	4628      	mov	r0, r5
  bc:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    ret = wc_ecc_import_raw_ex(keyImp, qx, qy, d, ECC_SECP256R1);
  c0:	f8cd a000 	str.w	sl, [sp]
  c4:	ab32      	add	r3, sp, #200	; 0xc8
  c6:	aa21      	add	r2, sp, #132	; 0x84
  c8:	a910      	add	r1, sp, #64	; 0x40
  ca:	4628      	mov	r0, r5
  cc:	f7ff fffe 	bl	0 <wc_ecc_import_raw_ex>
    if (ret != 0) {
  d0:	4604      	mov	r4, r0
  d2:	b128      	cbz	r0, e0 <ecc_exp_imp_test+0xe0>
        ret = WC_TEST_RET_ENC_EC(ret);
  d4:	4244      	negs	r4, r0
  d6:	f3c4 000a 	ubfx	r0, r4, #0, #11
  da:	494c      	ldr	r1, [pc, #304]	; (20c <ecc_exp_imp_test+0x20c>)
  dc:	4c4f      	ldr	r4, [pc, #316]	; (21c <ecc_exp_imp_test+0x21c>)
  de:	e7c2      	b.n	66 <ecc_exp_imp_test+0x66>
    wc_ecc_free(keyImp);
  e0:	4628      	mov	r0, r5
  e2:	f7ff fffe 	bl	0 <wc_ecc_free>
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
  e6:	f06f 0201 	mvn.w	r2, #1
  ea:	4621      	mov	r1, r4
  ec:	4628      	mov	r0, r5
  ee:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    curve_id = wc_ecc_get_curve_id(key->idx);
  f2:	6870      	ldr	r0, [r6, #4]
  f4:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id>
    if (curve_id < 0) {
  f8:	2800      	cmp	r0, #0
  fa:	da05      	bge.n	108 <ecc_exp_imp_test+0x108>
        ret = WC_TEST_RET_ENC_EC(curve_id);
  fc:	4240      	negs	r0, r0
  fe:	4943      	ldr	r1, [pc, #268]	; (20c <ecc_exp_imp_test+0x20c>)
 100:	4c47      	ldr	r4, [pc, #284]	; (220 <ecc_exp_imp_test+0x220>)
 102:	f3c0 000a 	ubfx	r0, r0, #0, #11
 106:	e7ae      	b.n	66 <ecc_exp_imp_test+0x66>
    ret = wc_ecc_import_private_key_ex(priv, privLen, NULL, 0, keyImp,
 108:	e9cd 5000 	strd	r5, r0, [sp]
 10c:	4623      	mov	r3, r4
 10e:	4622      	mov	r2, r4
 110:	6839      	ldr	r1, [r7, #0]
 112:	4648      	mov	r0, r9
 114:	f7ff fffe 	bl	0 <wc_ecc_import_private_key_ex>
    if (ret != 0) {
 118:	4604      	mov	r4, r0
 11a:	b128      	cbz	r0, 128 <ecc_exp_imp_test+0x128>
        ret = WC_TEST_RET_ENC_EC(ret);
 11c:	4244      	negs	r4, r0
 11e:	f3c4 000a 	ubfx	r0, r4, #0, #11
 122:	493a      	ldr	r1, [pc, #232]	; (20c <ecc_exp_imp_test+0x20c>)
 124:	4c3f      	ldr	r4, [pc, #252]	; (224 <ecc_exp_imp_test+0x224>)
 126:	e79e      	b.n	66 <ecc_exp_imp_test+0x66>
    wc_ecc_free(keyImp);
 128:	4628      	mov	r0, r5
 12a:	f7ff fffe 	bl	0 <wc_ecc_free>
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
 12e:	4621      	mov	r1, r4
    pubLenX = pubLenY = 32;
 130:	ac07      	add	r4, sp, #28
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
 132:	f06f 0201 	mvn.w	r2, #1
 136:	4628      	mov	r0, r5
 138:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    pubLenX = pubLenY = 32;
 13c:	f8c4 8000 	str.w	r8, [r4]
    ret = wc_ecc_export_public_raw(key, pub, &pubLenX, &pub[32], &pubLenY);
 140:	ab4b      	add	r3, sp, #300	; 0x12c
 142:	9400      	str	r4, [sp, #0]
 144:	aa06      	add	r2, sp, #24
 146:	a943      	add	r1, sp, #268	; 0x10c
 148:	4630      	mov	r0, r6
    pubLenX = pubLenY = 32;
 14a:	f8cd 8018 	str.w	r8, [sp, #24]
    ret = wc_ecc_export_public_raw(key, pub, &pubLenX, &pub[32], &pubLenY);
 14e:	f7ff fffe 	bl	0 <wc_ecc_export_public_raw>
    if (ret != 0) {
 152:	4603      	mov	r3, r0
 154:	b168      	cbz	r0, 172 <ecc_exp_imp_test+0x172>
        ret = WC_TEST_RET_ENC_EC(ret);
 156:	4243      	negs	r3, r0
 158:	4c33      	ldr	r4, [pc, #204]	; (228 <ecc_exp_imp_test+0x228>)
 15a:	482c      	ldr	r0, [pc, #176]	; (20c <ecc_exp_imp_test+0x20c>)
 15c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 160:	fb00 4403 	mla	r4, r0, r3, r4
        wc_ecc_free(keyImp);
 164:	4628      	mov	r0, r5
 166:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(keyImp, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 16a:	4628      	mov	r0, r5
 16c:	f7ff fffe 	bl	0 <free>
 170:	e041      	b.n	1f6 <ecc_exp_imp_test+0x1f6>
    ret = wc_ecc_import_unsigned(keyImp, pub, &pub[32], NULL, ECC_SECP256R1);
 172:	f8cd a000 	str.w	sl, [sp]
 176:	aa4b      	add	r2, sp, #300	; 0x12c
 178:	a943      	add	r1, sp, #268	; 0x10c
 17a:	4628      	mov	r0, r5
 17c:	f7ff fffe 	bl	0 <wc_ecc_import_unsigned>
    if (ret != 0) {
 180:	4682      	mov	sl, r0
 182:	b128      	cbz	r0, 190 <ecc_exp_imp_test+0x190>
        ret = WC_TEST_RET_ENC_EC(ret);
 184:	4240      	negs	r0, r0
 186:	4921      	ldr	r1, [pc, #132]	; (20c <ecc_exp_imp_test+0x20c>)
 188:	4c28      	ldr	r4, [pc, #160]	; (22c <ecc_exp_imp_test+0x22c>)
 18a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 18e:	e76a      	b.n	66 <ecc_exp_imp_test+0x66>
    wc_ecc_free(keyImp);
 190:	4628      	mov	r0, r5
 192:	f7ff fffe 	bl	0 <wc_ecc_free>
    wc_ecc_init_ex(keyImp, HEAP_HINT, devId);
 196:	f06f 0201 	mvn.w	r2, #1
 19a:	4651      	mov	r1, sl
 19c:	4628      	mov	r0, r5
 19e:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    pubLenX = pubLenY = privLen = 32;
 1a2:	f8c7 8000 	str.w	r8, [r7]
 1a6:	f8c4 8000 	str.w	r8, [r4]
    ret = wc_ecc_export_private_raw(key, pub, &pubLenX, &pub[32], &pubLenY,
 1aa:	ab4b      	add	r3, sp, #300	; 0x12c
 1ac:	e9cd 9701 	strd	r9, r7, [sp, #4]
 1b0:	9400      	str	r4, [sp, #0]
 1b2:	aa06      	add	r2, sp, #24
 1b4:	a943      	add	r1, sp, #268	; 0x10c
 1b6:	4630      	mov	r0, r6
    pubLenX = pubLenY = privLen = 32;
 1b8:	f8cd 8018 	str.w	r8, [sp, #24]
    ret = wc_ecc_export_private_raw(key, pub, &pubLenX, &pub[32], &pubLenY,
 1bc:	f7ff fffe 	bl	0 <wc_ecc_export_private_raw>
    if (ret != 0) {
 1c0:	b128      	cbz	r0, 1ce <ecc_exp_imp_test+0x1ce>
        ret = WC_TEST_RET_ENC_EC(ret);
 1c2:	4240      	negs	r0, r0
 1c4:	4911      	ldr	r1, [pc, #68]	; (20c <ecc_exp_imp_test+0x20c>)
 1c6:	4c1a      	ldr	r4, [pc, #104]	; (230 <ecc_exp_imp_test+0x230>)
 1c8:	f3c0 000a 	ubfx	r0, r0, #0, #11
 1cc:	e74b      	b.n	66 <ecc_exp_imp_test+0x66>
    ret = wc_ecc_import_unsigned(keyImp, pub, &pub[32], priv, ECC_SECP256R1);
 1ce:	2307      	movs	r3, #7
 1d0:	9300      	str	r3, [sp, #0]
 1d2:	aa4b      	add	r2, sp, #300	; 0x12c
 1d4:	ab08      	add	r3, sp, #32
 1d6:	a943      	add	r1, sp, #268	; 0x10c
 1d8:	4628      	mov	r0, r5
 1da:	f7ff fffe 	bl	0 <wc_ecc_import_unsigned>
    if (ret != 0) {
 1de:	4604      	mov	r4, r0
 1e0:	2800      	cmp	r0, #0
 1e2:	d0bf      	beq.n	164 <ecc_exp_imp_test+0x164>
        ret = WC_TEST_RET_ENC_EC(ret);
 1e4:	4244      	negs	r4, r0
 1e6:	4909      	ldr	r1, [pc, #36]	; (20c <ecc_exp_imp_test+0x20c>)
 1e8:	4812      	ldr	r0, [pc, #72]	; (234 <ecc_exp_imp_test+0x234>)
 1ea:	f3c4 040a 	ubfx	r4, r4, #0, #11
 1ee:	fb01 0404 	mla	r4, r1, r4, r0
        goto done;
 1f2:	e7b7      	b.n	164 <ecc_exp_imp_test+0x164>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, done);
 1f4:	4c10      	ldr	r4, [pc, #64]	; (238 <ecc_exp_imp_test+0x238>)
}
 1f6:	4620      	mov	r0, r4
 1f8:	b064      	add	sp, #400	; 0x190
 1fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1fe:	bf00      	nop
 200:	00000000 	.word	0x00000000
 204:	00000041 	.word	0x00000041
 208:	00000082 	.word	0x00000082
 20c:	fffe7960 	.word	0xfffe7960
 210:	dfff9644 	.word	0xdfff9644
 214:	dfff963e 	.word	0xdfff963e
 218:	dfff9638 	.word	0xdfff9638
 21c:	dfff962f 	.word	0xdfff962f
 220:	dfff9626 	.word	0xdfff9626
 224:	dfff961e 	.word	0xdfff961e
 228:	dfff9613 	.word	0xdfff9613
 22c:	dfff960b 	.word	0xdfff960b
 230:	dfff95fe 	.word	0xdfff95fe
 234:	dfff95f6 	.word	0xdfff95f6
 238:	ffff964c 	.word	0xffff964c

Disassembly of section .text.aesgcm_default_test_helper.constprop.0:

00000000 <aesgcm_default_test_helper.constprop.0>:
static wc_test_ret_t aesgcm_default_test_helper(byte* key, int keySz, byte* iv, int ivSz,
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4681      	mov	r9, r0
   6:	b0a3      	sub	sp, #140	; 0x8c
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   8:	f44f 709c 	mov.w	r0, #312	; 0x138
static wc_test_ret_t aesgcm_default_test_helper(byte* key, int keySz, byte* iv, int ivSz,
   c:	4688      	mov	r8, r1
   e:	4616      	mov	r6, r2
  10:	461f      	mov	r7, r3
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
  12:	f7ff fffe 	bl	0 <malloc>
  16:	4605      	mov	r5, r0
  18:	2800      	cmp	r0, #0
  1a:	f000 80c7 	beq.w	1ac <aesgcm_default_test_helper.constprop.0+0x1ac>
    if ((dec = (Aes *)XMALLOC(sizeof *dec, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
  1e:	f44f 709c 	mov.w	r0, #312	; 0x138
  22:	f7ff fffe 	bl	0 <malloc>
  26:	4604      	mov	r4, r0
  28:	2800      	cmp	r0, #0
  2a:	f000 80c2 	beq.w	1b2 <aesgcm_default_test_helper.constprop.0+0x1b2>
    XMEMSET(resultT, 0, sizeof(resultT));
  2e:	f10d 0b18 	add.w	fp, sp, #24
  32:	2210      	movs	r2, #16
  34:	2100      	movs	r1, #0
  36:	4658      	mov	r0, fp
  38:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultC, 0, sizeof(resultC));
  3c:	2230      	movs	r2, #48	; 0x30
  3e:	2100      	movs	r1, #0
  40:	a816      	add	r0, sp, #88	; 0x58
  42:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultP, 0, sizeof(resultP));
  46:	2230      	movs	r2, #48	; 0x30
  48:	2100      	movs	r1, #0
  4a:	a80a      	add	r0, sp, #40	; 0x28
  4c:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesInit(enc, HEAP_HINT, devId);
  50:	f06f 0201 	mvn.w	r2, #1
  54:	2100      	movs	r1, #0
  56:	4628      	mov	r0, r5
  58:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  5c:	4682      	mov	sl, r0
  5e:	b150      	cbz	r0, 76 <aesgcm_default_test_helper.constprop.0+0x76>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  60:	f1c0 0800 	rsb	r8, r0, #0
  64:	4b54      	ldr	r3, [pc, #336]	; (1b8 <aesgcm_default_test_helper.constprop.0+0x1b8>)
  66:	4855      	ldr	r0, [pc, #340]	; (1bc <aesgcm_default_test_helper.constprop.0+0x1bc>)
  68:	f3c8 080a 	ubfx	r8, r8, #0, #11
  6c:	fb03 0808 	mla	r8, r3, r8, r0
static wc_test_ret_t aesgcm_default_test_helper(byte* key, int keySz, byte* iv, int ivSz,
  70:	f04f 0a00 	mov.w	sl, #0
  74:	e011      	b.n	9a <aesgcm_default_test_helper.constprop.0+0x9a>
    ret = wc_AesInit(dec, HEAP_HINT, devId);
  76:	4601      	mov	r1, r0
  78:	f06f 0201 	mvn.w	r2, #1
  7c:	4620      	mov	r0, r4
  7e:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  82:	b1d8      	cbz	r0, bc <aesgcm_default_test_helper.constprop.0+0xbc>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  84:	f1c0 0800 	rsb	r8, r0, #0
  88:	4b4b      	ldr	r3, [pc, #300]	; (1b8 <aesgcm_default_test_helper.constprop.0+0x1b8>)
  8a:	484d      	ldr	r0, [pc, #308]	; (1c0 <aesgcm_default_test_helper.constprop.0+0x1c0>)
  8c:	f3c8 080a 	ubfx	r8, r8, #0, #11
  90:	fb03 0808 	mla	r8, r3, r8, r0
            wc_AesFree(enc);
  94:	4628      	mov	r0, r5
  96:	f7ff fffe 	bl	0 <wc_AesFree>
        XFREE(enc, HEAP_HINT, DYNAMIC_TYPE_AES);
  9a:	4628      	mov	r0, r5
  9c:	f7ff fffe 	bl	0 <free>
    if (dec) {
  a0:	b144      	cbz	r4, b4 <aesgcm_default_test_helper.constprop.0+0xb4>
        if (dec_inited)
  a2:	f1ba 0f00 	cmp.w	sl, #0
  a6:	d002      	beq.n	ae <aesgcm_default_test_helper.constprop.0+0xae>
            wc_AesFree(dec);
  a8:	4620      	mov	r0, r4
  aa:	f7ff fffe 	bl	0 <wc_AesFree>
        XFREE(dec, HEAP_HINT, DYNAMIC_TYPE_AES);
  ae:	4620      	mov	r0, r4
  b0:	f7ff fffe 	bl	0 <free>
}
  b4:	4640      	mov	r0, r8
  b6:	b023      	add	sp, #140	; 0x8c
  b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = wc_AesGcmSetKey(enc, key, keySz);
  bc:	2210      	movs	r2, #16
  be:	4649      	mov	r1, r9
  c0:	4628      	mov	r0, r5
  c2:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    if (ret != 0)
  c6:	b150      	cbz	r0, de <aesgcm_default_test_helper.constprop.0+0xde>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  c8:	f1c0 0800 	rsb	r8, r0, #0
  cc:	4b3a      	ldr	r3, [pc, #232]	; (1b8 <aesgcm_default_test_helper.constprop.0+0x1b8>)
  ce:	483d      	ldr	r0, [pc, #244]	; (1c4 <aesgcm_default_test_helper.constprop.0+0x1c4>)
  d0:	f3c8 080a 	ubfx	r8, r8, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  d4:	fb03 0808 	mla	r8, r3, r8, r0
        dec_inited = 1;
  d8:	f04f 0a01 	mov.w	sl, #1
  dc:	e7da      	b.n	94 <aesgcm_default_test_helper.constprop.0+0x94>
    ret = wc_AesGcmEncrypt(enc, resultC, plain, plainSz, iv, ivSz,
  de:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
  e0:	9305      	str	r3, [sp, #20]
  e2:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
  e4:	9304      	str	r3, [sp, #16]
  e6:	9b31      	ldr	r3, [sp, #196]	; 0xc4
  e8:	e9cd b302 	strd	fp, r3, [sp, #8]
  ec:	230c      	movs	r3, #12
  ee:	e9cd 8300 	strd	r8, r3, [sp]
  f2:	4632      	mov	r2, r6
  f4:	463b      	mov	r3, r7
  f6:	a916      	add	r1, sp, #88	; 0x58
  f8:	4628      	mov	r0, r5
  fa:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
    if (ret != 0)
  fe:	b130      	cbz	r0, 10e <aesgcm_default_test_helper.constprop.0+0x10e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 100:	f1c0 0800 	rsb	r8, r0, #0
 104:	4b2c      	ldr	r3, [pc, #176]	; (1b8 <aesgcm_default_test_helper.constprop.0+0x1b8>)
 106:	4830      	ldr	r0, [pc, #192]	; (1c8 <aesgcm_default_test_helper.constprop.0+0x1c8>)
 108:	f3c8 080a 	ubfx	r8, r8, #0, #11
 10c:	e7e2      	b.n	d4 <aesgcm_default_test_helper.constprop.0+0xd4>
    if (cipher != NULL) {
 10e:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 110:	b963      	cbnz	r3, 12c <aesgcm_default_test_helper.constprop.0+0x12c>
    if (XMEMCMP(tag, resultT, tagSz))
 112:	f10d 0b18 	add.w	fp, sp, #24
 116:	9a31      	ldr	r2, [sp, #196]	; 0xc4
 118:	9830      	ldr	r0, [sp, #192]	; 0xc0
 11a:	4659      	mov	r1, fp
 11c:	f7ff fffe 	bl	0 <memcmp>
 120:	b180      	cbz	r0, 144 <aesgcm_default_test_helper.constprop.0+0x144>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 122:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 1cc <aesgcm_default_test_helper.constprop.0+0x1cc>
        dec_inited = 1;
 126:	f04f 0a01 	mov.w	sl, #1
 12a:	e7b3      	b.n	94 <aesgcm_default_test_helper.constprop.0+0x94>
        if (XMEMCMP(cipher, resultC, cipherSz))
 12c:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
 12e:	982c      	ldr	r0, [sp, #176]	; 0xb0
 130:	a916      	add	r1, sp, #88	; 0x58
 132:	f7ff fffe 	bl	0 <memcmp>
 136:	2800      	cmp	r0, #0
 138:	d0eb      	beq.n	112 <aesgcm_default_test_helper.constprop.0+0x112>
            ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 13a:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1d0 <aesgcm_default_test_helper.constprop.0+0x1d0>
        dec_inited = 1;
 13e:	f04f 0a01 	mov.w	sl, #1
 142:	e7a7      	b.n	94 <aesgcm_default_test_helper.constprop.0+0x94>
    ret = wc_AesGcmSetKey(dec, key, keySz);
 144:	2210      	movs	r2, #16
 146:	4649      	mov	r1, r9
 148:	4620      	mov	r0, r4
 14a:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    if (ret != 0)
 14e:	b130      	cbz	r0, 15e <aesgcm_default_test_helper.constprop.0+0x15e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 150:	f1c0 0800 	rsb	r8, r0, #0
 154:	4b18      	ldr	r3, [pc, #96]	; (1b8 <aesgcm_default_test_helper.constprop.0+0x1b8>)
 156:	481f      	ldr	r0, [pc, #124]	; (1d4 <aesgcm_default_test_helper.constprop.0+0x1d4>)
 158:	f3c8 080a 	ubfx	r8, r8, #0, #11
 15c:	e7ba      	b.n	d4 <aesgcm_default_test_helper.constprop.0+0xd4>
    ret = wc_AesGcmDecrypt(dec, resultP, resultC, cipherSz,
 15e:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 160:	9305      	str	r3, [sp, #20]
 162:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
 164:	9304      	str	r3, [sp, #16]
 166:	9b31      	ldr	r3, [sp, #196]	; 0xc4
 168:	e9cd b302 	strd	fp, r3, [sp, #8]
 16c:	230c      	movs	r3, #12
 16e:	e9cd 8300 	strd	r8, r3, [sp]
 172:	aa16      	add	r2, sp, #88	; 0x58
 174:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
 176:	a90a      	add	r1, sp, #40	; 0x28
 178:	4620      	mov	r0, r4
 17a:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
    if (ret != 0)
 17e:	4680      	mov	r8, r0
 180:	b130      	cbz	r0, 190 <aesgcm_default_test_helper.constprop.0+0x190>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 182:	f1c0 0800 	rsb	r8, r0, #0
 186:	4b0c      	ldr	r3, [pc, #48]	; (1b8 <aesgcm_default_test_helper.constprop.0+0x1b8>)
 188:	4813      	ldr	r0, [pc, #76]	; (1d8 <aesgcm_default_test_helper.constprop.0+0x1d8>)
 18a:	f3c8 080a 	ubfx	r8, r8, #0, #11
 18e:	e7a1      	b.n	d4 <aesgcm_default_test_helper.constprop.0+0xd4>
    if (plain != NULL) {
 190:	2e00      	cmp	r6, #0
 192:	d0a1      	beq.n	d8 <aesgcm_default_test_helper.constprop.0+0xd8>
        if (XMEMCMP(plain, resultP, plainSz))
 194:	463a      	mov	r2, r7
 196:	a90a      	add	r1, sp, #40	; 0x28
 198:	4630      	mov	r0, r6
 19a:	f7ff fffe 	bl	0 <memcmp>
 19e:	2800      	cmp	r0, #0
 1a0:	d09a      	beq.n	d8 <aesgcm_default_test_helper.constprop.0+0xd8>
            ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 1a2:	f8df 8038 	ldr.w	r8, [pc, #56]	; 1dc <aesgcm_default_test_helper.constprop.0+0x1dc>
        dec_inited = 1;
 1a6:	f04f 0a01 	mov.w	sl, #1
 1aa:	e773      	b.n	94 <aesgcm_default_test_helper.constprop.0+0x94>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 1ac:	f8df 8030 	ldr.w	r8, [pc, #48]	; 1e0 <aesgcm_default_test_helper.constprop.0+0x1e0>
    return ret;
 1b0:	e780      	b.n	b4 <aesgcm_default_test_helper.constprop.0+0xb4>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 1b2:	f8df 8030 	ldr.w	r8, [pc, #48]	; 1e4 <aesgcm_default_test_helper.constprop.0+0x1e4>
 1b6:	e75b      	b.n	70 <aesgcm_default_test_helper.constprop.0+0x70>
 1b8:	fffe7960 	.word	0xfffe7960
 1bc:	dfffd226 	.word	0xdfffd226
 1c0:	dfffd221 	.word	0xdfffd221
 1c4:	dfffd21b 	.word	0xdfffd21b
 1c8:	dfffd211 	.word	0xdfffd211
 1cc:	ffffd20b 	.word	0xffffd20b
 1d0:	ffffd20e 	.word	0xffffd20e
 1d4:	dfffd205 	.word	0xdfffd205
 1d8:	dfffd1fd 	.word	0xdfffd1fd
 1dc:	ffffd1fa 	.word	0xffffd1fa
 1e0:	ffffd231 	.word	0xffffd231
 1e4:	ffffd22f 	.word	0xffffd22f

Disassembly of section .text.error_test:

00000000 <error_test>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char* unknownStr = wc_GetErrorString(0);
   2:	2000      	movs	r0, #0
{
   4:	b0a3      	sub	sp, #140	; 0x8c
    const char* unknownStr = wc_GetErrorString(0);
   6:	f7ff fffe 	bl	0 <wc_GetErrorString>
    int missing[] = { -123, -124, -128, -129, -159, -163, -164,
   a:	4d33      	ldr	r5, [pc, #204]	; (d8 <error_test+0xd8>)
    const char* unknownStr = wc_GetErrorString(0);
   c:	4606      	mov	r6, r0
    int missing[] = { -123, -124, -128, -129, -159, -163, -164,
   e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  10:	466c      	mov	r4, sp
  12:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  14:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  16:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  18:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  1a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1c:	e895 0003 	ldmia.w	r5, {r0, r1}
    int j = 0;
  20:	2700      	movs	r7, #0
    int missing[] = { -123, -124, -128, -129, -159, -163, -164,
  22:	e884 0003 	stmia.w	r4, {r0, r1}
    for (i = MAX_CODE_E-1; i >= WC_LAST_E; i--) {
  26:	f06f 0464 	mvn.w	r4, #100	; 0x64
        errStr = wc_GetErrorString(i);
  2a:	4620      	mov	r0, r4
  2c:	f7ff fffe 	bl	0 <wc_GetErrorString>
        wc_ErrorString(i, out);
  30:	a90e      	add	r1, sp, #56	; 0x38
        errStr = wc_GetErrorString(i);
  32:	4605      	mov	r5, r0
        wc_ErrorString(i, out);
  34:	4620      	mov	r0, r4
  36:	f7ff fffe 	bl	0 <wc_ErrorString>
        if (i != missing[j]) {
  3a:	ab22      	add	r3, sp, #136	; 0x88
  3c:	eb03 0387 	add.w	r3, r3, r7, lsl #2
  40:	f853 3c88 	ldr.w	r3, [r3, #-136]
  44:	42a3      	cmp	r3, r4
  46:	d015      	beq.n	74 <error_test+0x74>
            if (XSTRCMP(errStr, unknownStr) == 0)
  48:	4631      	mov	r1, r6
  4a:	4628      	mov	r0, r5
  4c:	f7ff fffe 	bl	0 <strcmp>
  50:	b3b0      	cbz	r0, c0 <error_test+0xc0>
            if (XSTRCMP(out, unknownStr) == 0)
  52:	4631      	mov	r1, r6
  54:	a80e      	add	r0, sp, #56	; 0x38
  56:	f7ff fffe 	bl	0 <strcmp>
  5a:	b398      	cbz	r0, c4 <error_test+0xc4>
            if (XSTRCMP(errStr, out) != 0)
  5c:	a90e      	add	r1, sp, #56	; 0x38
  5e:	4628      	mov	r0, r5
  60:	f7ff fffe 	bl	0 <strcmp>
  64:	bb80      	cbnz	r0, c8 <error_test+0xc8>
            if (XSTRLEN(errStr) >= WOLFSSL_MAX_ERROR_SZ)
  66:	4628      	mov	r0, r5
  68:	f7ff fffe 	bl	0 <strlen>
  6c:	284f      	cmp	r0, #79	; 0x4f
  6e:	d90c      	bls.n	8a <error_test+0x8a>
                return WC_TEST_RET_ENC_NC;
  70:	481a      	ldr	r0, [pc, #104]	; (dc <error_test+0xdc>)
  72:	e023      	b.n	bc <error_test+0xbc>
            if (XSTRCMP(errStr, unknownStr) != 0)
  74:	4631      	mov	r1, r6
  76:	4628      	mov	r0, r5
            j++;
  78:	3701      	adds	r7, #1
            if (XSTRCMP(errStr, unknownStr) != 0)
  7a:	f7ff fffe 	bl	0 <strcmp>
  7e:	bb28      	cbnz	r0, cc <error_test+0xcc>
            if (XSTRCMP(out, unknownStr) != 0)
  80:	4631      	mov	r1, r6
  82:	a80e      	add	r0, sp, #56	; 0x38
  84:	f7ff fffe 	bl	0 <strcmp>
  88:	bb10      	cbnz	r0, d0 <error_test+0xd0>
    for (i = MAX_CODE_E-1; i >= WC_LAST_E; i--) {
  8a:	3c01      	subs	r4, #1
  8c:	f514 7f96 	cmn.w	r4, #300	; 0x12c
  90:	d1cb      	bne.n	2a <error_test+0x2a>
    errStr = wc_GetErrorString(i);
  92:	4620      	mov	r0, r4
  94:	f7ff fffe 	bl	0 <wc_GetErrorString>
    wc_ErrorString(i, out);
  98:	a90e      	add	r1, sp, #56	; 0x38
    errStr = wc_GetErrorString(i);
  9a:	4605      	mov	r5, r0
    wc_ErrorString(i, out);
  9c:	4620      	mov	r0, r4
  9e:	f7ff fffe 	bl	0 <wc_ErrorString>
    if (XSTRCMP(errStr, unknownStr) != 0)
  a2:	4631      	mov	r1, r6
  a4:	4628      	mov	r0, r5
  a6:	f7ff fffe 	bl	0 <strcmp>
  aa:	b998      	cbnz	r0, d4 <error_test+0xd4>
    if (XSTRCMP(out, unknownStr) != 0)
  ac:	4631      	mov	r1, r6
  ae:	a80e      	add	r0, sp, #56	; 0x38
  b0:	f7ff fffe 	bl	0 <strcmp>
        return WC_TEST_RET_ENC_NC;
  b4:	4b0a      	ldr	r3, [pc, #40]	; (e0 <error_test+0xe0>)
  b6:	2800      	cmp	r0, #0
  b8:	bf18      	it	ne
  ba:	4618      	movne	r0, r3
}
  bc:	b023      	add	sp, #140	; 0x8c
  be:	bdf0      	pop	{r4, r5, r6, r7, pc}
                return WC_TEST_RET_ENC_NC;
  c0:	4808      	ldr	r0, [pc, #32]	; (e4 <error_test+0xe4>)
  c2:	e7fb      	b.n	bc <error_test+0xbc>
                return WC_TEST_RET_ENC_NC;
  c4:	4808      	ldr	r0, [pc, #32]	; (e8 <error_test+0xe8>)
  c6:	e7f9      	b.n	bc <error_test+0xbc>
                return WC_TEST_RET_ENC_NC;
  c8:	4808      	ldr	r0, [pc, #32]	; (ec <error_test+0xec>)
  ca:	e7f7      	b.n	bc <error_test+0xbc>
                return WC_TEST_RET_ENC_NC;
  cc:	4808      	ldr	r0, [pc, #32]	; (f0 <error_test+0xf0>)
  ce:	e7f5      	b.n	bc <error_test+0xbc>
                return WC_TEST_RET_ENC_NC;
  d0:	4808      	ldr	r0, [pc, #32]	; (f4 <error_test+0xf4>)
  d2:	e7f3      	b.n	bc <error_test+0xbc>
        return WC_TEST_RET_ENC_NC;
  d4:	4808      	ldr	r0, [pc, #32]	; (f8 <error_test+0xf8>)
  d6:	e7f1      	b.n	bc <error_test+0xbc>
  d8:	00000000 	.word	0x00000000
  dc:	fffff7aa 	.word	0xfffff7aa
  e0:	fffff799 	.word	0xfffff799
  e4:	fffff7b0 	.word	0xfffff7b0
  e8:	fffff7ae 	.word	0xfffff7ae
  ec:	fffff7ac 	.word	0xfffff7ac
  f0:	fffff7a5 	.word	0xfffff7a5
  f4:	fffff7a3 	.word	0xfffff7a3
  f8:	fffff79b 	.word	0xfffff79b

Disassembly of section .text.base64_test:

00000000 <base64_test>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b0ca      	sub	sp, #296	; 0x128
    byte       longData[79] = { 0 };
   6:	2100      	movs	r1, #0
   8:	224b      	movs	r2, #75	; 0x4b
   a:	a817      	add	r0, sp, #92	; 0x5c
    byte goodChar[] =
   c:	2542      	movs	r5, #66	; 0x42
    byte       longData[79] = { 0 };
   e:	9116      	str	r1, [sp, #88]	; 0x58
  10:	f7ff fffe 	bl	0 <memset>
    byte goodChar[] =
  14:	49ab      	ldr	r1, [pc, #684]	; (2c4 <base64_test+0x2c4>)
  16:	462a      	mov	r2, r5
  18:	a805      	add	r0, sp, #20
  1a:	f7ff fffe 	bl	0 <memcpy>
    byte charTest[] = "A+Gd\0\0\0";
  1e:	4aaa      	ldr	r2, [pc, #680]	; (2c8 <base64_test+0x2c8>)
  20:	6b90      	ldr	r0, [r2, #56]	; 0x38
  22:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
  24:	ab03      	add	r3, sp, #12
  26:	c303      	stmia	r3!, {r0, r1}
    outLen = sizeof(out);
  28:	2480      	movs	r4, #128	; 0x80
    ret = Base64_Decode(good, sizeof(good), out, &outLen);
  2a:	48a8      	ldr	r0, [pc, #672]	; (2cc <base64_test+0x2cc>)
    outLen = sizeof(out);
  2c:	9401      	str	r4, [sp, #4]
    ret = Base64_Decode(good, sizeof(good), out, &outLen);
  2e:	ab01      	add	r3, sp, #4
  30:	aa2a      	add	r2, sp, #168	; 0xa8
  32:	2108      	movs	r1, #8
  34:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != 0)
  38:	b158      	cbz	r0, 52 <base64_test+0x52>
        return WC_TEST_RET_ENC_EC(ret);
  3a:	4ba5      	ldr	r3, [pc, #660]	; (2d0 <base64_test+0x2d0>)
  3c:	4240      	negs	r0, r0
  3e:	f3c0 000a 	ubfx	r0, r0, #0, #11
  42:	4358      	muls	r0, r3
  44:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  48:	f6a0 008d 	subw	r0, r0, #2189	; 0x88d
}
  4c:	b04a      	add	sp, #296	; 0x128
  4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = Base64_Decode(goodEnd, sizeof(goodEnd), out, &outLen);
  52:	48a0      	ldr	r0, [pc, #640]	; (2d4 <base64_test+0x2d4>)
    outLen = sizeof(out);
  54:	9401      	str	r4, [sp, #4]
    ret = Base64_Decode(goodEnd, sizeof(goodEnd), out, &outLen);
  56:	ab01      	add	r3, sp, #4
  58:	aa2a      	add	r2, sp, #168	; 0xa8
  5a:	2108      	movs	r1, #8
  5c:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != 0)
  60:	b150      	cbz	r0, 78 <base64_test+0x78>
        return WC_TEST_RET_ENC_EC(ret);
  62:	4b9b      	ldr	r3, [pc, #620]	; (2d0 <base64_test+0x2d0>)
  64:	4240      	negs	r0, r0
  66:	f3c0 000a 	ubfx	r0, r0, #0, #11
  6a:	4358      	muls	r0, r3
  6c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  70:	f46f 6209 	mvn.w	r2, #2192	; 0x890
  74:	4410      	add	r0, r2
  76:	e7e9      	b.n	4c <base64_test+0x4c>
    ret = Base64_Decode(goodChar, sizeof(goodChar), goodChar, &outLen);
  78:	aa05      	add	r2, sp, #20
  7a:	ab01      	add	r3, sp, #4
  7c:	4629      	mov	r1, r5
  7e:	4610      	mov	r0, r2
    outLen = sizeof(goodChar);
  80:	9501      	str	r5, [sp, #4]
    ret = Base64_Decode(goodChar, sizeof(goodChar), goodChar, &outLen);
  82:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != 0)
  86:	b148      	cbz	r0, 9c <base64_test+0x9c>
        return WC_TEST_RET_ENC_EC(ret);
  88:	4b91      	ldr	r3, [pc, #580]	; (2d0 <base64_test+0x2d0>)
  8a:	4240      	negs	r0, r0
  8c:	f3c0 000a 	ubfx	r0, r0, #0, #11
  90:	4358      	muls	r0, r3
  92:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  96:	f6a0 0095 	subw	r0, r0, #2197	; 0x895
  9a:	e7d7      	b.n	4c <base64_test+0x4c>
    if (outLen != 64 / 4 * 3)
  9c:	9b01      	ldr	r3, [sp, #4]
  9e:	2b30      	cmp	r3, #48	; 0x30
  a0:	f040 819a 	bne.w	3d8 <base64_test+0x3d8>
    ret = Base64_Decode(good_spaces, sizeof(good_spaces), out, &outLen);
  a4:	488c      	ldr	r0, [pc, #560]	; (2d8 <base64_test+0x2d8>)
    outLen = sizeof(out);
  a6:	9401      	str	r4, [sp, #4]
    ret = Base64_Decode(good_spaces, sizeof(good_spaces), out, &outLen);
  a8:	ab01      	add	r3, sp, #4
  aa:	aa2a      	add	r2, sp, #168	; 0xa8
  ac:	210b      	movs	r1, #11
  ae:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != 0)
  b2:	4605      	mov	r5, r0
  b4:	b148      	cbz	r0, ca <base64_test+0xca>
        return WC_TEST_RET_ENC_EC(ret);
  b6:	4d86      	ldr	r5, [pc, #536]	; (2d0 <base64_test+0x2d0>)
  b8:	4240      	negs	r0, r0
  ba:	f3c0 000a 	ubfx	r0, r0, #0, #11
  be:	4368      	muls	r0, r5
  c0:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  c4:	f6a0 009b 	subw	r0, r0, #2203	; 0x89b
  c8:	e7c0      	b.n	4c <base64_test+0x4c>
    outLen = 1;
  ca:	2301      	movs	r3, #1
  cc:	9301      	str	r3, [sp, #4]
    ret = Base64_Decode(good, sizeof(good), out, &outLen);
  ce:	487f      	ldr	r0, [pc, #508]	; (2cc <base64_test+0x2cc>)
  d0:	ab01      	add	r3, sp, #4
  d2:	aa2a      	add	r2, sp, #168	; 0xa8
  d4:	2108      	movs	r1, #8
  d6:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != BAD_FUNC_ARG)
  da:	f110 0fad 	cmn.w	r0, #173	; 0xad
  de:	d00a      	beq.n	f6 <base64_test+0xf6>
        return WC_TEST_RET_ENC_EC(ret);
  e0:	4b7b      	ldr	r3, [pc, #492]	; (2d0 <base64_test+0x2d0>)
  e2:	4240      	negs	r0, r0
  e4:	f3c0 000a 	ubfx	r0, r0, #0, #11
  e8:	4358      	muls	r0, r3
  ea:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  ee:	f46f 630a 	mvn.w	r3, #2208	; 0x8a0
  f2:	4418      	add	r0, r3
  f4:	e7aa      	b.n	4c <base64_test+0x4c>
    ret = Base64_Decode(badEOL, sizeof(badEOL), out, &outLen);
  f6:	4879      	ldr	r0, [pc, #484]	; (2dc <base64_test+0x2dc>)
    outLen = sizeof(out);
  f8:	9401      	str	r4, [sp, #4]
    ret = Base64_Decode(badEOL, sizeof(badEOL), out, &outLen);
  fa:	ab01      	add	r3, sp, #4
  fc:	aa2a      	add	r2, sp, #168	; 0xa8
  fe:	2108      	movs	r1, #8
 100:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != ASN_INPUT_E)
 104:	f110 0f9a 	cmn.w	r0, #154	; 0x9a
 108:	d009      	beq.n	11e <base64_test+0x11e>
        return WC_TEST_RET_ENC_EC(ret);
 10a:	4b71      	ldr	r3, [pc, #452]	; (2d0 <base64_test+0x2d0>)
 10c:	4240      	negs	r0, r0
 10e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 112:	4358      	muls	r0, r3
 114:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 118:	f6a0 00a6 	subw	r0, r0, #2214	; 0x8a6
 11c:	e796      	b.n	4c <base64_test+0x4c>
    ret = Base64_Decode(badPadding, sizeof(badPadding), out, &outLen);
 11e:	4870      	ldr	r0, [pc, #448]	; (2e0 <base64_test+0x2e0>)
    outLen = sizeof(out);
 120:	9401      	str	r4, [sp, #4]
    ret = Base64_Decode(badPadding, sizeof(badPadding), out, &outLen);
 122:	ab01      	add	r3, sp, #4
 124:	aa2a      	add	r2, sp, #168	; 0xa8
 126:	2105      	movs	r1, #5
 128:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != ASN_INPUT_E)
 12c:	f110 0f9a 	cmn.w	r0, #154	; 0x9a
 130:	d009      	beq.n	146 <base64_test+0x146>
        return WC_TEST_RET_ENC_EC(ret);
 132:	4b67      	ldr	r3, [pc, #412]	; (2d0 <base64_test+0x2d0>)
 134:	4240      	negs	r0, r0
 136:	f3c0 000a 	ubfx	r0, r0, #0, #11
 13a:	4358      	muls	r0, r3
 13c:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 140:	f6a0 00aa 	subw	r0, r0, #2218	; 0x8aa
 144:	e782      	b.n	4c <base64_test+0x4c>
        ret = Base64_Decode(badSmall + i, 4, out, &outLen);
 146:	4f67      	ldr	r7, [pc, #412]	; (2e4 <base64_test+0x2e4>)
        ret = Base64_Decode(badLarge + i, 4, out, &outLen);
 148:	f8df 819c 	ldr.w	r8, [pc, #412]	; 2e8 <base64_test+0x2e8>
    for (i = 0; i < 4; i++) {
 14c:	462e      	mov	r6, r5
        ret = Base64_Decode(badSmall + i, 4, out, &outLen);
 14e:	ab01      	add	r3, sp, #4
 150:	aa2a      	add	r2, sp, #168	; 0xa8
 152:	2104      	movs	r1, #4
 154:	19b8      	adds	r0, r7, r6
        outLen = sizeof(out);
 156:	9401      	str	r4, [sp, #4]
        ret = Base64_Decode(badSmall + i, 4, out, &outLen);
 158:	f7ff fffe 	bl	0 <Base64_Decode>
        if (ret != ASN_INPUT_E)
 15c:	309a      	adds	r0, #154	; 0x9a
 15e:	d006      	beq.n	16e <base64_test+0x16e>
            return WC_TEST_RET_ENC_I(i);
 160:	485b      	ldr	r0, [pc, #364]	; (2d0 <base64_test+0x2d0>)
 162:	4370      	muls	r0, r6
 164:	f100 4020 	add.w	r0, r0, #2684354560	; 0xa0000000
 168:	f5a0 600b 	sub.w	r0, r0, #2224	; 0x8b0
 16c:	e76e      	b.n	4c <base64_test+0x4c>
        ret = Base64_Decode(badLarge + i, 4, out, &outLen);
 16e:	ab01      	add	r3, sp, #4
 170:	aa2a      	add	r2, sp, #168	; 0xa8
 172:	2104      	movs	r1, #4
 174:	eb08 0006 	add.w	r0, r8, r6
 178:	f7ff fffe 	bl	0 <Base64_Decode>
        if (ret != ASN_INPUT_E)
 17c:	309a      	adds	r0, #154	; 0x9a
 17e:	d006      	beq.n	18e <base64_test+0x18e>
            return WC_TEST_RET_ENC_I(i);
 180:	4853      	ldr	r0, [pc, #332]	; (2d0 <base64_test+0x2d0>)
 182:	4370      	muls	r0, r6
 184:	f100 4020 	add.w	r0, r0, #2684354560	; 0xa0000000
 188:	f6a0 00b3 	subw	r0, r0, #2227	; 0x8b3
 18c:	e75e      	b.n	4c <base64_test+0x4c>
    for (i = 0; i < 4; i++) {
 18e:	3601      	adds	r6, #1
 190:	2e04      	cmp	r6, #4
 192:	d1dc      	bne.n	14e <base64_test+0x14e>
    for (i = 1; i < 0x2b; i++) {
 194:	2401      	movs	r4, #1
        outLen = sizeof(out);
 196:	2680      	movs	r6, #128	; 0x80
        ret = Base64_Decode(charTest, sizeof(charTest), out, &outLen);
 198:	ab01      	add	r3, sp, #4
 19a:	aa2a      	add	r2, sp, #168	; 0xa8
 19c:	2108      	movs	r1, #8
 19e:	a803      	add	r0, sp, #12
        outLen = sizeof(out);
 1a0:	9601      	str	r6, [sp, #4]
        charTest[0] = (byte)i;
 1a2:	f88d 400c 	strb.w	r4, [sp, #12]
        ret = Base64_Decode(charTest, sizeof(charTest), out, &outLen);
 1a6:	f7ff fffe 	bl	0 <Base64_Decode>
        if (ret != ASN_INPUT_E)
 1aa:	309a      	adds	r0, #154	; 0x9a
 1ac:	d006      	beq.n	1bc <base64_test+0x1bc>
            return WC_TEST_RET_ENC_I(i);
 1ae:	4848      	ldr	r0, [pc, #288]	; (2d0 <base64_test+0x2d0>)
 1b0:	4360      	muls	r0, r4
 1b2:	f100 4020 	add.w	r0, r0, #2684354560	; 0xa0000000
 1b6:	f6a0 00bb 	subw	r0, r0, #2235	; 0x8bb
 1ba:	e747      	b.n	4c <base64_test+0x4c>
    for (i = 1; i < 0x2b; i++) {
 1bc:	3401      	adds	r4, #1
 1be:	2c2b      	cmp	r4, #43	; 0x2b
 1c0:	d1ea      	bne.n	198 <base64_test+0x198>
 1c2:	4c4a      	ldr	r4, [pc, #296]	; (2ec <base64_test+0x2ec>)
        outLen = sizeof(out);
 1c4:	2680      	movs	r6, #128	; 0x80
        charTest[0] = badChar[i];
 1c6:	f814 3b01 	ldrb.w	r3, [r4], #1
 1ca:	f88d 300c 	strb.w	r3, [sp, #12]
        ret = Base64_Decode(charTest, sizeof(charTest), out, &outLen);
 1ce:	aa2a      	add	r2, sp, #168	; 0xa8
 1d0:	ab01      	add	r3, sp, #4
 1d2:	2108      	movs	r1, #8
 1d4:	a803      	add	r0, sp, #12
        outLen = sizeof(out);
 1d6:	9601      	str	r6, [sp, #4]
        ret = Base64_Decode(charTest, sizeof(charTest), out, &outLen);
 1d8:	f7ff fffe 	bl	0 <Base64_Decode>
        if (ret != ASN_INPUT_E)
 1dc:	309a      	adds	r0, #154	; 0x9a
 1de:	d006      	beq.n	1ee <base64_test+0x1ee>
            return WC_TEST_RET_ENC_I(i);
 1e0:	483b      	ldr	r0, [pc, #236]	; (2d0 <base64_test+0x2d0>)
 1e2:	4368      	muls	r0, r5
 1e4:	f100 4020 	add.w	r0, r0, #2684354560	; 0xa0000000
 1e8:	f6a0 00c3 	subw	r0, r0, #2243	; 0x8c3
 1ec:	e72e      	b.n	4c <base64_test+0x4c>
    for (i = 0; i < (int)sizeof(badChar) - 1; i++) {
 1ee:	3501      	adds	r5, #1
 1f0:	2d10      	cmp	r5, #16
 1f2:	d1e8      	bne.n	1c6 <base64_test+0x1c6>
    for (i = 0x7b; i < 0x100; i++) {
 1f4:	247b      	movs	r4, #123	; 0x7b
        outLen = sizeof(out);
 1f6:	2580      	movs	r5, #128	; 0x80
        ret = Base64_Decode(charTest, sizeof(charTest), out, &outLen);
 1f8:	ab01      	add	r3, sp, #4
 1fa:	aa2a      	add	r2, sp, #168	; 0xa8
 1fc:	2108      	movs	r1, #8
 1fe:	a803      	add	r0, sp, #12
        outLen = sizeof(out);
 200:	9501      	str	r5, [sp, #4]
        charTest[0] = (byte)i;
 202:	f88d 400c 	strb.w	r4, [sp, #12]
        ret = Base64_Decode(charTest, sizeof(charTest), out, &outLen);
 206:	f7ff fffe 	bl	0 <Base64_Decode>
        if (ret != ASN_INPUT_E)
 20a:	309a      	adds	r0, #154	; 0x9a
 20c:	d006      	beq.n	21c <base64_test+0x21c>
            return WC_TEST_RET_ENC_I(i);
 20e:	4830      	ldr	r0, [pc, #192]	; (2d0 <base64_test+0x2d0>)
 210:	4360      	muls	r0, r4
 212:	f100 4020 	add.w	r0, r0, #2684354560	; 0xa0000000
 216:	f6a0 00cb 	subw	r0, r0, #2251	; 0x8cb
 21a:	e717      	b.n	4c <base64_test+0x4c>
    for (i = 0x7b; i < 0x100; i++) {
 21c:	3401      	adds	r4, #1
 21e:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
 222:	d1e9      	bne.n	1f8 <base64_test+0x1f8>
    dataLen = sizeof(data);
 224:	2303      	movs	r3, #3
 226:	9302      	str	r3, [sp, #8]
    ret = Base64_Decode(symbols, sizeof(symbols), data, &dataLen);
 228:	466a      	mov	r2, sp
 22a:	4831      	ldr	r0, [pc, #196]	; (2f0 <base64_test+0x2f0>)
 22c:	ab02      	add	r3, sp, #8
 22e:	2105      	movs	r1, #5
 230:	f7ff fffe 	bl	0 <Base64_Decode>
    if (ret != 0)
 234:	4602      	mov	r2, r0
 236:	b148      	cbz	r0, 24c <base64_test+0x24c>
        return WC_TEST_RET_ENC_EC(ret);
 238:	4a25      	ldr	r2, [pc, #148]	; (2d0 <base64_test+0x2d0>)
 23a:	4240      	negs	r0, r0
 23c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 240:	4350      	muls	r0, r2
 242:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 246:	f6a0 00d4 	subw	r0, r0, #2260	; 0x8d4
 24a:	e6ff      	b.n	4c <base64_test+0x4c>
    ret = Base64_Encode(data, dataLen, NULL, &outLen);
 24c:	9902      	ldr	r1, [sp, #8]
    outLen = sizeof(out);
 24e:	9501      	str	r5, [sp, #4]
    ret = Base64_Encode(data, dataLen, NULL, &outLen);
 250:	ab01      	add	r3, sp, #4
 252:	4668      	mov	r0, sp
 254:	f7ff fffe 	bl	0 <Base64_Encode>
    if (ret != LENGTH_ONLY_E)
 258:	f110 0fca 	cmn.w	r0, #202	; 0xca
 25c:	d009      	beq.n	272 <base64_test+0x272>
        return WC_TEST_RET_ENC_EC(ret);
 25e:	4b1c      	ldr	r3, [pc, #112]	; (2d0 <base64_test+0x2d0>)
 260:	4240      	negs	r0, r0
 262:	f3c0 000a 	ubfx	r0, r0, #0, #11
 266:	4358      	muls	r0, r3
 268:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 26c:	f6a0 00d8 	subw	r0, r0, #2264	; 0x8d8
 270:	e6ec      	b.n	4c <base64_test+0x4c>
    ret = Base64_Encode(data, dataLen, out, &outLen);
 272:	9902      	ldr	r1, [sp, #8]
    outLen = sizeof(out);
 274:	9501      	str	r5, [sp, #4]
    ret = Base64_Encode(data, dataLen, out, &outLen);
 276:	ab01      	add	r3, sp, #4
 278:	aa2a      	add	r2, sp, #168	; 0xa8
 27a:	4668      	mov	r0, sp
 27c:	f7ff fffe 	bl	0 <Base64_Encode>
    if (ret != 0)
 280:	4604      	mov	r4, r0
 282:	b148      	cbz	r0, 298 <base64_test+0x298>
        return WC_TEST_RET_ENC_EC(ret);
 284:	4c12      	ldr	r4, [pc, #72]	; (2d0 <base64_test+0x2d0>)
 286:	4240      	negs	r0, r0
 288:	f3c0 000a 	ubfx	r0, r0, #0, #11
 28c:	4360      	muls	r0, r4
 28e:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 292:	f6a0 00dc 	subw	r0, r0, #2268	; 0x8dc
 296:	e6d9      	b.n	4c <base64_test+0x4c>
    outLen = 7;
 298:	2307      	movs	r3, #7
 29a:	9301      	str	r3, [sp, #4]
    ret = Base64_EncodeEsc(data, dataLen, out, &outLen);
 29c:	9902      	ldr	r1, [sp, #8]
 29e:	ab01      	add	r3, sp, #4
 2a0:	aa2a      	add	r2, sp, #168	; 0xa8
 2a2:	4668      	mov	r0, sp
 2a4:	f7ff fffe 	bl	0 <Base64_EncodeEsc>
    if (ret != BUFFER_E)
 2a8:	f110 0f84 	cmn.w	r0, #132	; 0x84
 2ac:	d022      	beq.n	2f4 <base64_test+0x2f4>
        return WC_TEST_RET_ENC_EC(ret);
 2ae:	4b08      	ldr	r3, [pc, #32]	; (2d0 <base64_test+0x2d0>)
 2b0:	4240      	negs	r0, r0
 2b2:	f3c0 000a 	ubfx	r0, r0, #0, #11
 2b6:	4358      	muls	r0, r3
 2b8:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 2bc:	f5a0 600e 	sub.w	r0, r0, #2272	; 0x8e0
 2c0:	e6c4      	b.n	4c <base64_test+0x4c>
 2c2:	bf00      	nop
	...
 2d0:	fffe7960 	.word	0xfffe7960
	...
    ret = Base64_EncodeEsc(data, dataLen, NULL, &outLen);
 2f4:	9902      	ldr	r1, [sp, #8]
    outLen = sizeof(out);
 2f6:	9501      	str	r5, [sp, #4]
    ret = Base64_EncodeEsc(data, dataLen, NULL, &outLen);
 2f8:	ab01      	add	r3, sp, #4
 2fa:	4622      	mov	r2, r4
 2fc:	4668      	mov	r0, sp
 2fe:	f7ff fffe 	bl	0 <Base64_EncodeEsc>
    if (ret != LENGTH_ONLY_E)
 302:	f110 0fca 	cmn.w	r0, #202	; 0xca
 306:	d009      	beq.n	31c <base64_test+0x31c>
        return WC_TEST_RET_ENC_EC(ret);
 308:	4b34      	ldr	r3, [pc, #208]	; (3dc <base64_test+0x3dc>)
 30a:	4240      	negs	r0, r0
 30c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 310:	4358      	muls	r0, r3
 312:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 316:	f6a0 00e4 	subw	r0, r0, #2276	; 0x8e4
 31a:	e697      	b.n	4c <base64_test+0x4c>
    ret = Base64_EncodeEsc(data, dataLen, out, &outLen);
 31c:	9902      	ldr	r1, [sp, #8]
    outLen = sizeof(out);
 31e:	9501      	str	r5, [sp, #4]
    ret = Base64_EncodeEsc(data, dataLen, out, &outLen);
 320:	ab01      	add	r3, sp, #4
 322:	aa2a      	add	r2, sp, #168	; 0xa8
 324:	4668      	mov	r0, sp
 326:	f7ff fffe 	bl	0 <Base64_EncodeEsc>
    if (ret != 0)
 32a:	b148      	cbz	r0, 340 <base64_test+0x340>
        return WC_TEST_RET_ENC_EC(ret);
 32c:	4b2b      	ldr	r3, [pc, #172]	; (3dc <base64_test+0x3dc>)
 32e:	4240      	negs	r0, r0
 330:	f3c0 000a 	ubfx	r0, r0, #0, #11
 334:	4358      	muls	r0, r3
 336:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 33a:	f6a0 00e8 	subw	r0, r0, #2280	; 0x8e8
 33e:	e685      	b.n	4c <base64_test+0x4c>
    ret = Base64_Encode_NoNl(data, dataLen, out, &outLen);
 340:	9902      	ldr	r1, [sp, #8]
    outLen = sizeof(out);
 342:	9501      	str	r5, [sp, #4]
    ret = Base64_Encode_NoNl(data, dataLen, out, &outLen);
 344:	ab01      	add	r3, sp, #4
 346:	aa2a      	add	r2, sp, #168	; 0xa8
 348:	4668      	mov	r0, sp
 34a:	f7ff fffe 	bl	0 <Base64_Encode_NoNl>
    if (ret != 0)
 34e:	b148      	cbz	r0, 364 <base64_test+0x364>
        return WC_TEST_RET_ENC_EC(ret);
 350:	4b22      	ldr	r3, [pc, #136]	; (3dc <base64_test+0x3dc>)
 352:	4240      	negs	r0, r0
 354:	f3c0 000a 	ubfx	r0, r0, #0, #11
 358:	4358      	muls	r0, r3
 35a:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 35e:	f6a0 00ec 	subw	r0, r0, #2284	; 0x8ec
 362:	e673      	b.n	4c <base64_test+0x4c>
    dataLen = sizeof(longData);
 364:	214f      	movs	r1, #79	; 0x4f
    ret = Base64_Encode(longData, dataLen, out, &outLen);
 366:	ab01      	add	r3, sp, #4
 368:	aa2a      	add	r2, sp, #168	; 0xa8
 36a:	a816      	add	r0, sp, #88	; 0x58
    outLen = sizeof(out);
 36c:	9501      	str	r5, [sp, #4]
    dataLen = sizeof(longData);
 36e:	9102      	str	r1, [sp, #8]
    ret = Base64_Encode(longData, dataLen, out, &outLen);
 370:	f7ff fffe 	bl	0 <Base64_Encode>
    if (ret != 0)
 374:	b148      	cbz	r0, 38a <base64_test+0x38a>
        return WC_TEST_RET_ENC_EC(ret);
 376:	4b19      	ldr	r3, [pc, #100]	; (3dc <base64_test+0x3dc>)
 378:	4240      	negs	r0, r0
 37a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 37e:	4358      	muls	r0, r3
 380:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 384:	f6a0 00f3 	subw	r0, r0, #2291	; 0x8f3
 388:	e660      	b.n	4c <base64_test+0x4c>
    outLen = sizeof(out);
 38a:	2480      	movs	r4, #128	; 0x80
    ret = Base64_EncodeEsc(longData, dataLen, out, &outLen);
 38c:	9902      	ldr	r1, [sp, #8]
    outLen = sizeof(out);
 38e:	9401      	str	r4, [sp, #4]
    ret = Base64_EncodeEsc(longData, dataLen, out, &outLen);
 390:	ab01      	add	r3, sp, #4
 392:	aa2a      	add	r2, sp, #168	; 0xa8
 394:	a816      	add	r0, sp, #88	; 0x58
 396:	f7ff fffe 	bl	0 <Base64_EncodeEsc>
    if (ret != 0)
 39a:	b148      	cbz	r0, 3b0 <base64_test+0x3b0>
        return WC_TEST_RET_ENC_EC(ret);
 39c:	4b0f      	ldr	r3, [pc, #60]	; (3dc <base64_test+0x3dc>)
 39e:	4240      	negs	r0, r0
 3a0:	f3c0 000a 	ubfx	r0, r0, #0, #11
 3a4:	4358      	muls	r0, r3
 3a6:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 3aa:	f6a0 00f7 	subw	r0, r0, #2295	; 0x8f7
 3ae:	e64d      	b.n	4c <base64_test+0x4c>
    ret = Base64_Encode_NoNl(longData, dataLen, out, &outLen);
 3b0:	9902      	ldr	r1, [sp, #8]
    outLen = sizeof(out);
 3b2:	9401      	str	r4, [sp, #4]
    ret = Base64_Encode_NoNl(longData, dataLen, out, &outLen);
 3b4:	ab01      	add	r3, sp, #4
 3b6:	aa2a      	add	r2, sp, #168	; 0xa8
 3b8:	a816      	add	r0, sp, #88	; 0x58
 3ba:	f7ff fffe 	bl	0 <Base64_Encode_NoNl>
    if (ret != 0)
 3be:	2800      	cmp	r0, #0
 3c0:	f43f ae44 	beq.w	4c <base64_test+0x4c>
        return WC_TEST_RET_ENC_EC(ret);
 3c4:	4b05      	ldr	r3, [pc, #20]	; (3dc <base64_test+0x3dc>)
 3c6:	4240      	negs	r0, r0
 3c8:	f3c0 000a 	ubfx	r0, r0, #0, #11
 3cc:	4358      	muls	r0, r3
 3ce:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 3d2:	f6a0 00fb 	subw	r0, r0, #2299	; 0x8fb
 3d6:	e639      	b.n	4c <base64_test+0x4c>
        return WC_TEST_RET_ENC_NC;
 3d8:	4801      	ldr	r0, [pc, #4]	; (3e0 <base64_test+0x3e0>)
 3da:	e637      	b.n	4c <base64_test+0x4c>
 3dc:	fffe7960 	.word	0xfffe7960
 3e0:	fffff769 	.word	0xfffff769

Disassembly of section .text.asn_test:

00000000 <asn_test>:
{
   0:	b510      	push	{r4, lr}
   2:	b092      	sub	sp, #72	; 0x48
    ret = wc_GetDateInfo(dateBuf, (int)sizeof(dateBuf), &datePart, &format,
   4:	ab04      	add	r3, sp, #16
   6:	9300      	str	r3, [sp, #0]
   8:	4834      	ldr	r0, [pc, #208]	; (dc <asn_test+0xdc>)
   a:	f10d 030f 	add.w	r3, sp, #15
   e:	aa05      	add	r2, sp, #20
  10:	210f      	movs	r1, #15
  12:	f7ff fffe 	bl	0 <wc_GetDateInfo>
    if (ret != 0)
  16:	4604      	mov	r4, r0
  18:	b150      	cbz	r0, 30 <asn_test+0x30>
        return WC_TEST_RET_ENC_EC(ret);
  1a:	4c31      	ldr	r4, [pc, #196]	; (e0 <asn_test+0xe0>)
  1c:	4240      	negs	r0, r0
  1e:	f3c0 000a 	ubfx	r0, r0, #0, #11
  22:	4360      	muls	r0, r4
  24:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  28:	f6a0 103a 	subw	r0, r0, #2362	; 0x93a
}
  2c:	b012      	add	sp, #72	; 0x48
  2e:	bd10      	pop	{r4, pc}
    if ((ret = wc_GetTime(NULL, sizeof(now))) != BAD_FUNC_ARG)
  30:	2108      	movs	r1, #8
  32:	f7ff fffe 	bl	0 <wc_GetTime>
  36:	f110 0fad 	cmn.w	r0, #173	; 0xad
  3a:	d009      	beq.n	50 <asn_test+0x50>
        return WC_TEST_RET_ENC_EC(ret);
  3c:	4b28      	ldr	r3, [pc, #160]	; (e0 <asn_test+0xe0>)
  3e:	4240      	negs	r0, r0
  40:	f3c0 000a 	ubfx	r0, r0, #0, #11
  44:	4358      	muls	r0, r3
  46:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  4a:	f6a0 103f 	subw	r0, r0, #2367	; 0x93f
  4e:	e7ed      	b.n	2c <asn_test+0x2c>
    if ((ret = wc_GetTime(&now, 0)) != BUFFER_E)
  50:	4621      	mov	r1, r4
  52:	a806      	add	r0, sp, #24
  54:	f7ff fffe 	bl	0 <wc_GetTime>
  58:	f110 0f84 	cmn.w	r0, #132	; 0x84
  5c:	d00a      	beq.n	74 <asn_test+0x74>
        return WC_TEST_RET_ENC_EC(ret);
  5e:	4b20      	ldr	r3, [pc, #128]	; (e0 <asn_test+0xe0>)
  60:	4240      	negs	r0, r0
  62:	f3c0 000a 	ubfx	r0, r0, #0, #11
  66:	4358      	muls	r0, r3
  68:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  6c:	f46f 6314 	mvn.w	r3, #2368	; 0x940
  70:	4418      	add	r0, r3
  72:	e7db      	b.n	2c <asn_test+0x2c>
    now = 0;
  74:	2200      	movs	r2, #0
  76:	2300      	movs	r3, #0
    if ((ret = wc_GetTime(&now, sizeof(now))) != 0) {
  78:	2108      	movs	r1, #8
  7a:	a806      	add	r0, sp, #24
    now = 0;
  7c:	e9cd 2306 	strd	r2, r3, [sp, #24]
    if ((ret = wc_GetTime(&now, sizeof(now))) != 0) {
  80:	f7ff fffe 	bl	0 <wc_GetTime>
  84:	b148      	cbz	r0, 9a <asn_test+0x9a>
        return WC_TEST_RET_ENC_EC(ret);
  86:	4b16      	ldr	r3, [pc, #88]	; (e0 <asn_test+0xe0>)
  88:	4240      	negs	r0, r0
  8a:	f3c0 000a 	ubfx	r0, r0, #0, #11
  8e:	4358      	muls	r0, r3
  90:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  94:	f6a0 1045 	subw	r0, r0, #2373	; 0x945
  98:	e7c8      	b.n	2c <asn_test+0x2c>
    if (now == 0) {
  9a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  9e:	4313      	orrs	r3, r2
  a0:	d109      	bne.n	b6 <asn_test+0xb6>
        printf("RTC/Time not set!\n");
  a2:	4810      	ldr	r0, [pc, #64]	; (e4 <asn_test+0xe4>)
  a4:	f7ff fffe 	bl	0 <printf>
  a8:	4b0f      	ldr	r3, [pc, #60]	; (e8 <asn_test+0xe8>)
  aa:	681b      	ldr	r3, [r3, #0]
  ac:	6898      	ldr	r0, [r3, #8]
  ae:	f7ff fffe 	bl	0 <fflush>
        return WC_TEST_RET_ENC_NC;
  b2:	480e      	ldr	r0, [pc, #56]	; (ec <asn_test+0xec>)
  b4:	e7ba      	b.n	2c <asn_test+0x2c>
    ret = wc_GetDateAsCalendarTime(datePart, length, format, &timearg);
  b6:	e9dd 1004 	ldrd	r1, r0, [sp, #16]
  ba:	f89d 200f 	ldrb.w	r2, [sp, #15]
  be:	ab09      	add	r3, sp, #36	; 0x24
  c0:	f7ff fffe 	bl	0 <wc_GetDateAsCalendarTime>
    if (ret != 0)
  c4:	2800      	cmp	r0, #0
  c6:	d0b1      	beq.n	2c <asn_test+0x2c>
        return WC_TEST_RET_ENC_EC(ret);
  c8:	4b05      	ldr	r3, [pc, #20]	; (e0 <asn_test+0xe0>)
  ca:	4240      	negs	r0, r0
  cc:	f3c0 000a 	ubfx	r0, r0, #0, #11
  d0:	4358      	muls	r0, r3
  d2:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
  d6:	f6a0 104e 	subw	r0, r0, #2382	; 0x94e
  da:	e7a7      	b.n	2c <asn_test+0x2c>
  dc:	00000000 	.word	0x00000000
  e0:	fffe7960 	.word	0xfffe7960
	...
  ec:	fffff6b7 	.word	0xfffff6b7

Disassembly of section .text.sha_test:

00000000 <sha_test>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a.inLen  = XSTRLEN(a.input);
   4:	4b78      	ldr	r3, [pc, #480]	; (1e8 <sha_test+0x1e8>)
    b.inLen  = XSTRLEN(b.input);
   6:	f8df b1e4 	ldr.w	fp, [pc, #484]	; 1ec <sha_test+0x1ec>
    c.inLen  = XSTRLEN(c.input);
   a:	f8df a1e4 	ldr.w	sl, [pc, #484]	; 1f0 <sha_test+0x1f0>
    d.inLen  = XSTRLEN(d.input);
   e:	f8df 91e4 	ldr.w	r9, [pc, #484]	; 1f4 <sha_test+0x1f4>
    e.inLen  = XSTRLEN(e.input);
  12:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 1f8 <sha_test+0x1f8>
{
  16:	f2ad 5d44 	subw	sp, sp, #1348	; 0x544
    a.inLen  = XSTRLEN(a.input);
  1a:	4618      	mov	r0, r3
  1c:	f7ff fffe 	bl	0 <strlen>
  20:	4607      	mov	r7, r0
    b.inLen  = XSTRLEN(b.input);
  22:	4658      	mov	r0, fp
  24:	f7ff fffe 	bl	0 <strlen>
  28:	4606      	mov	r6, r0
    c.inLen  = XSTRLEN(c.input);
  2a:	4650      	mov	r0, sl
  2c:	f7ff fffe 	bl	0 <strlen>
  30:	4605      	mov	r5, r0
    d.inLen  = XSTRLEN(d.input);
  32:	4648      	mov	r0, r9
  34:	f7ff fffe 	bl	0 <strlen>
  38:	4604      	mov	r4, r0
    e.inLen  = XSTRLEN(e.input);
  3a:	4640      	mov	r0, r8
  3c:	f7ff fffe 	bl	0 <strlen>
    test_sha[0] = a;
  40:	4b69      	ldr	r3, [pc, #420]	; (1e8 <sha_test+0x1e8>)
  42:	930a      	str	r3, [sp, #40]	; 0x28
  44:	4b6d      	ldr	r3, [pc, #436]	; (1fc <sha_test+0x1fc>)
    test_sha[1] = b;
  46:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
    test_sha[0] = a;
  4a:	e9cd 370b 	strd	r3, r7, [sp, #44]	; 0x2c
    test_sha[1] = b;
  4e:	4b6c      	ldr	r3, [pc, #432]	; (200 <sha_test+0x200>)
    test_sha[2] = c;
  50:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
    test_sha[1] = b;
  54:	e9cd 360f 	strd	r3, r6, [sp, #60]	; 0x3c
    test_sha[2] = c;
  58:	4b6a      	ldr	r3, [pc, #424]	; (204 <sha_test+0x204>)
    test_sha[3] = d;
  5a:	f8cd 9058 	str.w	r9, [sp, #88]	; 0x58
    test_sha[2] = c;
  5e:	e9cd 3513 	strd	r3, r5, [sp, #76]	; 0x4c
    test_sha[3] = d;
  62:	4b69      	ldr	r3, [pc, #420]	; (208 <sha_test+0x208>)
    test_sha[4] = e;
  64:	f8cd 8068 	str.w	r8, [sp, #104]	; 0x68
    test_sha[3] = d;
  68:	e9cd 3417 	strd	r3, r4, [sp, #92]	; 0x5c
    test_sha[4] = e;
  6c:	4b67      	ldr	r3, [pc, #412]	; (20c <sha_test+0x20c>)
    ret = wc_InitSha_ex(&sha, HEAP_HINT, devId);
  6e:	2100      	movs	r1, #0
    test_sha[4] = e;
  70:	e9cd 301b 	strd	r3, r0, [sp, #108]	; 0x6c
    ret = wc_InitSha_ex(&sha, HEAP_HINT, devId);
  74:	f06f 0201 	mvn.w	r2, #1
  78:	a81e      	add	r0, sp, #120	; 0x78
  7a:	f7ff fffe 	bl	0 <wc_InitSha_ex>
    if (ret != 0)
  7e:	4601      	mov	r1, r0
  80:	b170      	cbz	r0, a0 <sha_test+0xa0>
        return WC_TEST_RET_ENC_EC(ret);
  82:	4963      	ldr	r1, [pc, #396]	; (210 <sha_test+0x210>)
  84:	4244      	negs	r4, r0
  86:	f3c4 040a 	ubfx	r4, r4, #0, #11
  8a:	434c      	muls	r4, r1
  8c:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  90:	f46f 632b 	mvn.w	r3, #2736	; 0xab0
  94:	441c      	add	r4, r3
}
  96:	4620      	mov	r0, r4
  98:	f20d 5d44 	addw	sp, sp, #1348	; 0x544
  9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = wc_InitSha_ex(&shaCopy, HEAP_HINT, devId);
  a0:	f06f 0201 	mvn.w	r2, #1
  a4:	a837      	add	r0, sp, #220	; 0xdc
  a6:	f7ff fffe 	bl	0 <wc_InitSha_ex>
    if (ret != 0) {
  aa:	4606      	mov	r6, r0
  ac:	b160      	cbz	r0, c8 <sha_test+0xc8>
        wc_ShaFree(&sha);
  ae:	a81e      	add	r0, sp, #120	; 0x78
  b0:	f7ff fffe 	bl	0 <wc_ShaFree>
        return WC_TEST_RET_ENC_EC(ret);
  b4:	4274      	negs	r4, r6
  b6:	4856      	ldr	r0, [pc, #344]	; (210 <sha_test+0x210>)
  b8:	f3c4 040a 	ubfx	r4, r4, #0, #11
  bc:	4344      	muls	r4, r0
  be:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  c2:	f6a4 24b5 	subw	r4, r4, #2741	; 0xab5
  c6:	e7e6      	b.n	96 <sha_test+0x96>
  c8:	ad0a      	add	r5, sp, #40	; 0x28
        ret = wc_ShaUpdate(&sha, (byte*)test_sha[i].input,
  ca:	68aa      	ldr	r2, [r5, #8]
  cc:	6829      	ldr	r1, [r5, #0]
  ce:	a81e      	add	r0, sp, #120	; 0x78
  d0:	f7ff fffe 	bl	0 <wc_ShaUpdate>
        if (ret != 0)
  d4:	b160      	cbz	r0, f0 <sha_test+0xf0>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  d6:	4c4e      	ldr	r4, [pc, #312]	; (210 <sha_test+0x210>)
  d8:	4374      	muls	r4, r6
  da:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  de:	f6a4 24bc 	subw	r4, r4, #2748	; 0xabc
    wc_ShaFree(&sha);
  e2:	a81e      	add	r0, sp, #120	; 0x78
  e4:	f7ff fffe 	bl	0 <wc_ShaFree>
    wc_ShaFree(&shaCopy);
  e8:	a837      	add	r0, sp, #220	; 0xdc
  ea:	f7ff fffe 	bl	0 <wc_ShaFree>
    return ret;
  ee:	e7d2      	b.n	96 <sha_test+0x96>
        ret = wc_ShaGetHash(&sha, hashcopy);
  f0:	a905      	add	r1, sp, #20
  f2:	a81e      	add	r0, sp, #120	; 0x78
  f4:	f7ff fffe 	bl	0 <wc_ShaGetHash>
        if (ret != 0)
  f8:	b130      	cbz	r0, 108 <sha_test+0x108>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  fa:	4c45      	ldr	r4, [pc, #276]	; (210 <sha_test+0x210>)
  fc:	4374      	muls	r4, r6
  fe:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 102:	f6a4 24bf 	subw	r4, r4, #2751	; 0xabf
 106:	e7ec      	b.n	e2 <sha_test+0xe2>
        ret = wc_ShaCopy(&sha, &shaCopy);
 108:	a937      	add	r1, sp, #220	; 0xdc
 10a:	a81e      	add	r0, sp, #120	; 0x78
 10c:	f7ff fffe 	bl	0 <wc_ShaCopy>
        if (ret != 0)
 110:	b130      	cbz	r0, 120 <sha_test+0x120>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 112:	4c3f      	ldr	r4, [pc, #252]	; (210 <sha_test+0x210>)
 114:	4374      	muls	r4, r6
 116:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 11a:	f6a4 24c2 	subw	r4, r4, #2754	; 0xac2
 11e:	e7e0      	b.n	e2 <sha_test+0xe2>
        ret = wc_ShaFinal(&sha, hash);
 120:	4669      	mov	r1, sp
 122:	a81e      	add	r0, sp, #120	; 0x78
 124:	f7ff fffe 	bl	0 <wc_ShaFinal>
        if (ret != 0)
 128:	b130      	cbz	r0, 138 <sha_test+0x138>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 12a:	4c39      	ldr	r4, [pc, #228]	; (210 <sha_test+0x210>)
 12c:	4374      	muls	r4, r6
 12e:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 132:	f6a4 24c5 	subw	r4, r4, #2757	; 0xac5
 136:	e7d4      	b.n	e2 <sha_test+0xe2>
        wc_ShaFree(&shaCopy);
 138:	a837      	add	r0, sp, #220	; 0xdc
 13a:	f7ff fffe 	bl	0 <wc_ShaFree>
        if (XMEMCMP(hash, test_sha[i].output, WC_SHA_DIGEST_SIZE) != 0)
 13e:	6869      	ldr	r1, [r5, #4]
 140:	2214      	movs	r2, #20
 142:	4668      	mov	r0, sp
 144:	f7ff fffe 	bl	0 <memcmp>
 148:	b130      	cbz	r0, 158 <sha_test+0x158>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 14a:	4c31      	ldr	r4, [pc, #196]	; (210 <sha_test+0x210>)
 14c:	4374      	muls	r4, r6
 14e:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 152:	f6a4 24c9 	subw	r4, r4, #2761	; 0xac9
 156:	e7c4      	b.n	e2 <sha_test+0xe2>
        if (XMEMCMP(hash, hashcopy, WC_SHA_DIGEST_SIZE) != 0)
 158:	2214      	movs	r2, #20
 15a:	eb0d 0102 	add.w	r1, sp, r2
 15e:	4668      	mov	r0, sp
 160:	f7ff fffe 	bl	0 <memcmp>
 164:	b130      	cbz	r0, 174 <sha_test+0x174>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 166:	4c2a      	ldr	r4, [pc, #168]	; (210 <sha_test+0x210>)
 168:	4374      	muls	r4, r6
 16a:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 16e:	f6a4 24cb 	subw	r4, r4, #2763	; 0xacb
 172:	e7b6      	b.n	e2 <sha_test+0xe2>
    for (i = 0; i < times; ++i) {
 174:	3601      	adds	r6, #1
 176:	2e05      	cmp	r6, #5
 178:	f105 0510 	add.w	r5, r5, #16
 17c:	d1a5      	bne.n	ca <sha_test+0xca>
 17e:	ab50      	add	r3, sp, #320	; 0x140
 180:	461d      	mov	r5, r3
        large_input[i] = (byte)(i & 0xFF);
 182:	f803 0b01 	strb.w	r0, [r3], #1
    for (i = 0; i < (int)sizeof(large_input); i++) {
 186:	3001      	adds	r0, #1
 188:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 18c:	d1f9      	bne.n	182 <sha_test+0x182>
 18e:	2464      	movs	r4, #100	; 0x64
        ret = wc_ShaUpdate(&sha, (byte*)large_input,
 190:	f44f 6280 	mov.w	r2, #1024	; 0x400
 194:	4629      	mov	r1, r5
 196:	a81e      	add	r0, sp, #120	; 0x78
 198:	f7ff fffe 	bl	0 <wc_ShaUpdate>
        if (ret != 0)
 19c:	b148      	cbz	r0, 1b2 <sha_test+0x1b2>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 19e:	4244      	negs	r4, r0
 1a0:	481b      	ldr	r0, [pc, #108]	; (210 <sha_test+0x210>)
 1a2:	f3c4 040a 	ubfx	r4, r4, #0, #11
 1a6:	4344      	muls	r4, r0
 1a8:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 1ac:	f6a4 24eb 	subw	r4, r4, #2795	; 0xaeb
 1b0:	e797      	b.n	e2 <sha_test+0xe2>
    for (i = 0; i < times; ++i) {
 1b2:	3c01      	subs	r4, #1
 1b4:	d1ec      	bne.n	190 <sha_test+0x190>
    ret = wc_ShaFinal(&sha, hash);
 1b6:	4669      	mov	r1, sp
 1b8:	a81e      	add	r0, sp, #120	; 0x78
 1ba:	f7ff fffe 	bl	0 <wc_ShaFinal>
    if (ret != 0)
 1be:	b148      	cbz	r0, 1d4 <sha_test+0x1d4>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 1c0:	4244      	negs	r4, r0
 1c2:	4813      	ldr	r0, [pc, #76]	; (210 <sha_test+0x210>)
 1c4:	f3c4 040a 	ubfx	r4, r4, #0, #11
 1c8:	4344      	muls	r4, r0
 1ca:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 1ce:	f6a4 24ef 	subw	r4, r4, #2799	; 0xaef
 1d2:	e786      	b.n	e2 <sha_test+0xe2>
    if (XMEMCMP(hash, large_digest, WC_SHA_DIGEST_SIZE) != 0)
 1d4:	490f      	ldr	r1, [pc, #60]	; (214 <sha_test+0x214>)
 1d6:	2214      	movs	r2, #20
 1d8:	4668      	mov	r0, sp
 1da:	f7ff fffe 	bl	0 <memcmp>
        ERROR_OUT(WC_TEST_RET_ENC_NC, exit);
 1de:	1e04      	subs	r4, r0, #0
 1e0:	bf18      	it	ne
 1e2:	f46f 642f 	mvnne.w	r4, #2800	; 0xaf0
 1e6:	e77c      	b.n	e2 <sha_test+0xe2>
 1e8:	00000000 	.word	0x00000000
 1ec:	00000001 	.word	0x00000001
 1f0:	00000005 	.word	0x00000005
 1f4:	0000003e 	.word	0x0000003e
 1f8:	0000007f 	.word	0x0000007f
 1fc:	00000100 	.word	0x00000100
 200:	00000115 	.word	0x00000115
 204:	0000012a 	.word	0x0000012a
 208:	00000040 	.word	0x00000040
 20c:	0000013f 	.word	0x0000013f
 210:	fffe7960 	.word	0xfffe7960
 214:	00000154 	.word	0x00000154

Disassembly of section .text.sha256_test:

00000000 <sha256_test>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a.inLen  = XSTRLEN(a.input);
   4:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 1b4 <sha256_test+0x1b4>
    b.inLen  = XSTRLEN(b.input);
   8:	4f6b      	ldr	r7, [pc, #428]	; (1b8 <sha256_test+0x1b8>)
    c.inLen  = XSTRLEN(c.input);
   a:	4e6c      	ldr	r6, [pc, #432]	; (1bc <sha256_test+0x1bc>)
{
   c:	f5ad 6daa 	sub.w	sp, sp, #1360	; 0x550
    a.inLen  = XSTRLEN(a.input);
  10:	4640      	mov	r0, r8
  12:	f7ff fffe 	bl	0 <strlen>
  16:	4605      	mov	r5, r0
    b.inLen  = XSTRLEN(b.input);
  18:	4638      	mov	r0, r7
  1a:	f7ff fffe 	bl	0 <strlen>
  1e:	4604      	mov	r4, r0
    c.inLen  = XSTRLEN(c.input);
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <strlen>
    test_sha[0] = a;
  26:	4b66      	ldr	r3, [pc, #408]	; (1c0 <sha256_test+0x1c0>)
  28:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
  2c:	e9cd 3511 	strd	r3, r5, [sp, #68]	; 0x44
    test_sha[1] = b;
  30:	4b64      	ldr	r3, [pc, #400]	; (1c4 <sha256_test+0x1c4>)
  32:	9714      	str	r7, [sp, #80]	; 0x50
  34:	e9cd 3415 	strd	r3, r4, [sp, #84]	; 0x54
    test_sha[2] = c;
  38:	4b63      	ldr	r3, [pc, #396]	; (1c8 <sha256_test+0x1c8>)
  3a:	9618      	str	r6, [sp, #96]	; 0x60
  3c:	e9cd 3019 	strd	r3, r0, [sp, #100]	; 0x64
    ret = wc_InitSha256_ex(&sha, HEAP_HINT, devId);
  40:	2100      	movs	r1, #0
  42:	f06f 0201 	mvn.w	r2, #1
  46:	a81c      	add	r0, sp, #112	; 0x70
  48:	f7ff fffe 	bl	0 <wc_InitSha256_ex>
    if (ret != 0)
  4c:	4601      	mov	r1, r0
  4e:	b168      	cbz	r0, 6c <sha256_test+0x6c>
        return WC_TEST_RET_ENC_EC(ret);
  50:	495e      	ldr	r1, [pc, #376]	; (1cc <sha256_test+0x1cc>)
  52:	4244      	negs	r4, r0
  54:	f3c4 040a 	ubfx	r4, r4, #0, #11
  58:	434c      	muls	r4, r1
  5a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  5e:	f6a4 443a 	subw	r4, r4, #3130	; 0xc3a
}
  62:	4620      	mov	r0, r4
  64:	f50d 6daa 	add.w	sp, sp, #1360	; 0x550
  68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = wc_InitSha256_ex(&shaCopy, HEAP_HINT, devId);
  6c:	f06f 0201 	mvn.w	r2, #1
  70:	a838      	add	r0, sp, #224	; 0xe0
  72:	f7ff fffe 	bl	0 <wc_InitSha256_ex>
    if (ret != 0) {
  76:	4606      	mov	r6, r0
  78:	b160      	cbz	r0, 94 <sha256_test+0x94>
        wc_Sha256Free(&sha);
  7a:	a81c      	add	r0, sp, #112	; 0x70
  7c:	f7ff fffe 	bl	0 <wc_Sha256Free>
        return WC_TEST_RET_ENC_EC(ret);
  80:	4274      	negs	r4, r6
  82:	4852      	ldr	r0, [pc, #328]	; (1cc <sha256_test+0x1cc>)
  84:	f3c4 040a 	ubfx	r4, r4, #0, #11
  88:	4344      	muls	r4, r0
  8a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  8e:	f6a4 443e 	subw	r4, r4, #3134	; 0xc3e
  92:	e7e6      	b.n	62 <sha256_test+0x62>
  94:	ad10      	add	r5, sp, #64	; 0x40
        ret = wc_Sha256Update(&sha, (byte*)test_sha[i].input,
  96:	68aa      	ldr	r2, [r5, #8]
  98:	6829      	ldr	r1, [r5, #0]
  9a:	a81c      	add	r0, sp, #112	; 0x70
  9c:	f7ff fffe 	bl	0 <wc_Sha256Update>
        if (ret != 0) {
  a0:	b160      	cbz	r0, bc <sha256_test+0xbc>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  a2:	4c4a      	ldr	r4, [pc, #296]	; (1cc <sha256_test+0x1cc>)
  a4:	4374      	muls	r4, r6
  a6:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  aa:	f6a4 4445 	subw	r4, r4, #3141	; 0xc45
    wc_Sha256Free(&sha);
  ae:	a81c      	add	r0, sp, #112	; 0x70
  b0:	f7ff fffe 	bl	0 <wc_Sha256Free>
    wc_Sha256Free(&shaCopy);
  b4:	a838      	add	r0, sp, #224	; 0xe0
  b6:	f7ff fffe 	bl	0 <wc_Sha256Free>
    return ret;
  ba:	e7d2      	b.n	62 <sha256_test+0x62>
        ret = wc_Sha256GetHash(&sha, hashcopy);
  bc:	a908      	add	r1, sp, #32
  be:	a81c      	add	r0, sp, #112	; 0x70
  c0:	f7ff fffe 	bl	0 <wc_Sha256GetHash>
        if (ret != 0)
  c4:	b130      	cbz	r0, d4 <sha256_test+0xd4>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  c6:	4c41      	ldr	r4, [pc, #260]	; (1cc <sha256_test+0x1cc>)
  c8:	4374      	muls	r4, r6
  ca:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  ce:	f6a4 4449 	subw	r4, r4, #3145	; 0xc49
  d2:	e7ec      	b.n	ae <sha256_test+0xae>
        ret = wc_Sha256Copy(&sha, &shaCopy);
  d4:	a938      	add	r1, sp, #224	; 0xe0
  d6:	a81c      	add	r0, sp, #112	; 0x70
  d8:	f7ff fffe 	bl	0 <wc_Sha256Copy>
        if (ret != 0)
  dc:	b130      	cbz	r0, ec <sha256_test+0xec>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  de:	4c3b      	ldr	r4, [pc, #236]	; (1cc <sha256_test+0x1cc>)
  e0:	4374      	muls	r4, r6
  e2:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  e6:	f6a4 444c 	subw	r4, r4, #3148	; 0xc4c
  ea:	e7e0      	b.n	ae <sha256_test+0xae>
        ret = wc_Sha256Final(&sha, hash);
  ec:	4669      	mov	r1, sp
  ee:	a81c      	add	r0, sp, #112	; 0x70
  f0:	f7ff fffe 	bl	0 <wc_Sha256Final>
        if (ret != 0)
  f4:	b130      	cbz	r0, 104 <sha256_test+0x104>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  f6:	4c35      	ldr	r4, [pc, #212]	; (1cc <sha256_test+0x1cc>)
  f8:	4374      	muls	r4, r6
  fa:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  fe:	f6a4 444f 	subw	r4, r4, #3151	; 0xc4f
 102:	e7d4      	b.n	ae <sha256_test+0xae>
        wc_Sha256Free(&shaCopy);
 104:	a838      	add	r0, sp, #224	; 0xe0
 106:	f7ff fffe 	bl	0 <wc_Sha256Free>
        if (XMEMCMP(hash, test_sha[i].output, WC_SHA256_DIGEST_SIZE) != 0)
 10a:	6869      	ldr	r1, [r5, #4]
 10c:	2220      	movs	r2, #32
 10e:	4668      	mov	r0, sp
 110:	f7ff fffe 	bl	0 <memcmp>
 114:	b130      	cbz	r0, 124 <sha256_test+0x124>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 116:	4c2d      	ldr	r4, [pc, #180]	; (1cc <sha256_test+0x1cc>)
 118:	4374      	muls	r4, r6
 11a:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 11e:	f6a4 4453 	subw	r4, r4, #3155	; 0xc53
 122:	e7c4      	b.n	ae <sha256_test+0xae>
        if (XMEMCMP(hash, hashcopy, WC_SHA256_DIGEST_SIZE) != 0)
 124:	2220      	movs	r2, #32
 126:	eb0d 0102 	add.w	r1, sp, r2
 12a:	4668      	mov	r0, sp
 12c:	f7ff fffe 	bl	0 <memcmp>
 130:	b130      	cbz	r0, 140 <sha256_test+0x140>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 132:	4c26      	ldr	r4, [pc, #152]	; (1cc <sha256_test+0x1cc>)
 134:	4374      	muls	r4, r6
 136:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 13a:	f6a4 4455 	subw	r4, r4, #3157	; 0xc55
 13e:	e7b6      	b.n	ae <sha256_test+0xae>
    for (i = 0; i < times; ++i) {
 140:	3601      	adds	r6, #1
 142:	2e03      	cmp	r6, #3
 144:	f105 0510 	add.w	r5, r5, #16
 148:	d1a5      	bne.n	96 <sha256_test+0x96>
 14a:	ab54      	add	r3, sp, #336	; 0x150
 14c:	461d      	mov	r5, r3
        large_input[i] = (byte)(i & 0xFF);
 14e:	f803 0b01 	strb.w	r0, [r3], #1
    for (i = 0; i < (int)sizeof(large_input); i++) {
 152:	3001      	adds	r0, #1
 154:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 158:	d1f9      	bne.n	14e <sha256_test+0x14e>
 15a:	2464      	movs	r4, #100	; 0x64
        ret = wc_Sha256Update(&sha, (byte*)large_input,
 15c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 160:	4629      	mov	r1, r5
 162:	a81c      	add	r0, sp, #112	; 0x70
 164:	f7ff fffe 	bl	0 <wc_Sha256Update>
        if (ret != 0)
 168:	b148      	cbz	r0, 17e <sha256_test+0x17e>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 16a:	4244      	negs	r4, r0
 16c:	4817      	ldr	r0, [pc, #92]	; (1cc <sha256_test+0x1cc>)
 16e:	f3c4 040a 	ubfx	r4, r4, #0, #11
 172:	4344      	muls	r4, r0
 174:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 178:	f6a4 4473 	subw	r4, r4, #3187	; 0xc73
 17c:	e797      	b.n	ae <sha256_test+0xae>
    for (i = 0; i < times; ++i) {
 17e:	3c01      	subs	r4, #1
 180:	d1ec      	bne.n	15c <sha256_test+0x15c>
    ret = wc_Sha256Final(&sha, hash);
 182:	4669      	mov	r1, sp
 184:	a81c      	add	r0, sp, #112	; 0x70
 186:	f7ff fffe 	bl	0 <wc_Sha256Final>
    if (ret != 0)
 18a:	b148      	cbz	r0, 1a0 <sha256_test+0x1a0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 18c:	4244      	negs	r4, r0
 18e:	480f      	ldr	r0, [pc, #60]	; (1cc <sha256_test+0x1cc>)
 190:	f3c4 040a 	ubfx	r4, r4, #0, #11
 194:	4344      	muls	r4, r0
 196:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 19a:	f6a4 4477 	subw	r4, r4, #3191	; 0xc77
 19e:	e786      	b.n	ae <sha256_test+0xae>
    if (XMEMCMP(hash, large_digest, WC_SHA256_DIGEST_SIZE) != 0)
 1a0:	490b      	ldr	r1, [pc, #44]	; (1d0 <sha256_test+0x1d0>)
 1a2:	2220      	movs	r2, #32
 1a4:	4668      	mov	r0, sp
 1a6:	f7ff fffe 	bl	0 <memcmp>
        ERROR_OUT(WC_TEST_RET_ENC_NC, exit);
 1aa:	4b0a      	ldr	r3, [pc, #40]	; (1d4 <sha256_test+0x1d4>)
 1ac:	1e04      	subs	r4, r0, #0
 1ae:	bf18      	it	ne
 1b0:	461c      	movne	r4, r3
 1b2:	e77c      	b.n	ae <sha256_test+0xae>
 1b4:	00000000 	.word	0x00000000
 1b8:	00000001 	.word	0x00000001
 1bc:	00000005 	.word	0x00000005
 1c0:	00000000 	.word	0x00000000
 1c4:	00000055 	.word	0x00000055
 1c8:	00000021 	.word	0x00000021
 1cc:	fffe7960 	.word	0xfffe7960
 1d0:	00000042 	.word	0x00000042
 1d4:	fffff387 	.word	0xfffff387

Disassembly of section .text.sha512_test:

00000000 <sha512_test>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a.inLen  = XSTRLEN(a.input);
   4:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 1e4 <sha512_test+0x1e4>
    b.inLen  = XSTRLEN(b.input);
   8:	4f77      	ldr	r7, [pc, #476]	; (1e8 <sha512_test+0x1e8>)
    c.inLen  = XSTRLEN(c.input);
   a:	4e78      	ldr	r6, [pc, #480]	; (1ec <sha512_test+0x1ec>)
{
   c:	f5ad 6dce 	sub.w	sp, sp, #1648	; 0x670
    a.inLen  = XSTRLEN(a.input);
  10:	4640      	mov	r0, r8
  12:	f7ff fffe 	bl	0 <strlen>
  16:	4605      	mov	r5, r0
    b.inLen  = XSTRLEN(b.input);
  18:	4638      	mov	r0, r7
  1a:	f7ff fffe 	bl	0 <strlen>
  1e:	4604      	mov	r4, r0
    c.inLen  = XSTRLEN(c.input);
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <strlen>
    test_sha[0] = a;
  26:	4b72      	ldr	r3, [pc, #456]	; (1f0 <sha512_test+0x1f0>)
  28:	f8cd 8000 	str.w	r8, [sp]
  2c:	e9cd 3501 	strd	r3, r5, [sp, #4]
    test_sha[1] = b;
  30:	4b70      	ldr	r3, [pc, #448]	; (1f4 <sha512_test+0x1f4>)
  32:	9704      	str	r7, [sp, #16]
  34:	e9cd 3405 	strd	r3, r4, [sp, #20]
    test_sha[2] = c;
  38:	4b6f      	ldr	r3, [pc, #444]	; (1f8 <sha512_test+0x1f8>)
  3a:	9608      	str	r6, [sp, #32]
  3c:	e9cd 3009 	strd	r3, r0, [sp, #36]	; 0x24
    ret = wc_InitSha512_ex(&sha, HEAP_HINT, devId);
  40:	2100      	movs	r1, #0
  42:	f06f 0201 	mvn.w	r2, #1
  46:	a82c      	add	r0, sp, #176	; 0xb0
  48:	f7ff fffe 	bl	0 <wc_InitSha512_ex>
    if (ret != 0)
  4c:	4601      	mov	r1, r0
  4e:	b168      	cbz	r0, 6c <sha512_test+0x6c>
        return WC_TEST_RET_ENC_EC(ret);
  50:	496a      	ldr	r1, [pc, #424]	; (1fc <sha512_test+0x1fc>)
  52:	4244      	negs	r4, r0
  54:	f3c4 040a 	ubfx	r4, r4, #0, #11
  58:	434c      	muls	r4, r1
  5a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  5e:	f6a4 44b8 	subw	r4, r4, #3256	; 0xcb8
}
  62:	4620      	mov	r0, r4
  64:	f50d 6dce 	add.w	sp, sp, #1648	; 0x670
  68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = wc_InitSha512_ex(&shaCopy, HEAP_HINT, devId);
  6c:	f06f 0201 	mvn.w	r2, #1
  70:	a864      	add	r0, sp, #400	; 0x190
  72:	f7ff fffe 	bl	0 <wc_InitSha512_ex>
    if (ret != 0) {
  76:	4606      	mov	r6, r0
  78:	b160      	cbz	r0, 94 <sha512_test+0x94>
        wc_Sha512Free(&sha);
  7a:	a82c      	add	r0, sp, #176	; 0xb0
  7c:	f7ff fffe 	bl	0 <wc_Sha512Free>
        return WC_TEST_RET_ENC_EC(ret);
  80:	4274      	negs	r4, r6
  82:	485e      	ldr	r0, [pc, #376]	; (1fc <sha512_test+0x1fc>)
  84:	f3c4 040a 	ubfx	r4, r4, #0, #11
  88:	4344      	muls	r4, r0
  8a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  8e:	f6a4 44bc 	subw	r4, r4, #3260	; 0xcbc
  92:	e7e6      	b.n	62 <sha512_test+0x62>
  94:	466d      	mov	r5, sp
        ret = wc_Sha512Update(&sha, (byte*)test_sha[i].input,
  96:	68aa      	ldr	r2, [r5, #8]
  98:	6829      	ldr	r1, [r5, #0]
  9a:	a82c      	add	r0, sp, #176	; 0xb0
  9c:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret != 0)
  a0:	b160      	cbz	r0, bc <sha512_test+0xbc>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  a2:	4c56      	ldr	r4, [pc, #344]	; (1fc <sha512_test+0x1fc>)
  a4:	4374      	muls	r4, r6
  a6:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  aa:	f6a4 44c3 	subw	r4, r4, #3267	; 0xcc3
    wc_Sha512Free(&sha);
  ae:	a82c      	add	r0, sp, #176	; 0xb0
  b0:	f7ff fffe 	bl	0 <wc_Sha512Free>
    wc_Sha512Free(&shaCopy);
  b4:	a864      	add	r0, sp, #400	; 0x190
  b6:	f7ff fffe 	bl	0 <wc_Sha512Free>
    return ret;
  ba:	e7d2      	b.n	62 <sha512_test+0x62>
        ret = wc_Sha512GetHash(&sha, hashcopy);
  bc:	a91c      	add	r1, sp, #112	; 0x70
  be:	a82c      	add	r0, sp, #176	; 0xb0
  c0:	f7ff fffe 	bl	0 <wc_Sha512GetHash>
        if (ret != 0)
  c4:	b130      	cbz	r0, d4 <sha512_test+0xd4>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  c6:	4c4d      	ldr	r4, [pc, #308]	; (1fc <sha512_test+0x1fc>)
  c8:	4374      	muls	r4, r6
  ca:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  ce:	f6a4 44c6 	subw	r4, r4, #3270	; 0xcc6
  d2:	e7ec      	b.n	ae <sha512_test+0xae>
        ret = wc_Sha512Copy(&sha, &shaCopy);
  d4:	a964      	add	r1, sp, #400	; 0x190
  d6:	a82c      	add	r0, sp, #176	; 0xb0
  d8:	f7ff fffe 	bl	0 <wc_Sha512Copy>
        if (ret != 0)
  dc:	b130      	cbz	r0, ec <sha512_test+0xec>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  de:	4c47      	ldr	r4, [pc, #284]	; (1fc <sha512_test+0x1fc>)
  e0:	4374      	muls	r4, r6
  e2:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  e6:	f6a4 44c9 	subw	r4, r4, #3273	; 0xcc9
  ea:	e7e0      	b.n	ae <sha512_test+0xae>
        ret = wc_Sha512Final(&sha, hash);
  ec:	a90c      	add	r1, sp, #48	; 0x30
  ee:	a82c      	add	r0, sp, #176	; 0xb0
  f0:	f7ff fffe 	bl	0 <wc_Sha512Final>
        if (ret != 0)
  f4:	b130      	cbz	r0, 104 <sha512_test+0x104>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  f6:	4c41      	ldr	r4, [pc, #260]	; (1fc <sha512_test+0x1fc>)
  f8:	4374      	muls	r4, r6
  fa:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  fe:	f6a4 44cc 	subw	r4, r4, #3276	; 0xccc
 102:	e7d4      	b.n	ae <sha512_test+0xae>
        wc_Sha512Free(&shaCopy);
 104:	a864      	add	r0, sp, #400	; 0x190
 106:	f7ff fffe 	bl	0 <wc_Sha512Free>
        if (XMEMCMP(hash, test_sha[i].output, WC_SHA512_DIGEST_SIZE) != 0)
 10a:	6869      	ldr	r1, [r5, #4]
 10c:	2240      	movs	r2, #64	; 0x40
 10e:	a80c      	add	r0, sp, #48	; 0x30
 110:	f7ff fffe 	bl	0 <memcmp>
 114:	b130      	cbz	r0, 124 <sha512_test+0x124>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 116:	4c39      	ldr	r4, [pc, #228]	; (1fc <sha512_test+0x1fc>)
 118:	4374      	muls	r4, r6
 11a:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 11e:	f5a4 644d 	sub.w	r4, r4, #3280	; 0xcd0
 122:	e7c4      	b.n	ae <sha512_test+0xae>
        if (XMEMCMP(hash, hashcopy, WC_SHA512_DIGEST_SIZE) != 0)
 124:	2240      	movs	r2, #64	; 0x40
 126:	a91c      	add	r1, sp, #112	; 0x70
 128:	a80c      	add	r0, sp, #48	; 0x30
 12a:	f7ff fffe 	bl	0 <memcmp>
 12e:	b130      	cbz	r0, 13e <sha512_test+0x13e>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 130:	4c32      	ldr	r4, [pc, #200]	; (1fc <sha512_test+0x1fc>)
 132:	4374      	muls	r4, r6
 134:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 138:	f6a4 44d2 	subw	r4, r4, #3282	; 0xcd2
 13c:	e7b7      	b.n	ae <sha512_test+0xae>
    for (i = 0; i < times; ++i) {
 13e:	3601      	adds	r6, #1
 140:	2e03      	cmp	r6, #3
 142:	f105 0510 	add.w	r5, r5, #16
 146:	d1a6      	bne.n	96 <sha512_test+0x96>
 148:	ab9c      	add	r3, sp, #624	; 0x270
        large_input[i] = (byte)(i & 0xFF);
 14a:	f803 0b01 	strb.w	r0, [r3], #1
    for (i = 0; i < (int)sizeof(large_input); i++) {
 14e:	3001      	adds	r0, #1
 150:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 154:	d1f9      	bne.n	14a <sha512_test+0x14a>
 156:	2464      	movs	r4, #100	; 0x64
        ret = wc_Sha512Update(&sha, (byte*)large_input,
 158:	f44f 6280 	mov.w	r2, #1024	; 0x400
 15c:	a99c      	add	r1, sp, #624	; 0x270
 15e:	a82c      	add	r0, sp, #176	; 0xb0
 160:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret != 0)
 164:	b148      	cbz	r0, 17a <sha512_test+0x17a>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 166:	4244      	negs	r4, r0
 168:	4824      	ldr	r0, [pc, #144]	; (1fc <sha512_test+0x1fc>)
 16a:	f3c4 040a 	ubfx	r4, r4, #0, #11
 16e:	4344      	muls	r4, r0
 170:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 174:	f6a4 44f2 	subw	r4, r4, #3314	; 0xcf2
 178:	e799      	b.n	ae <sha512_test+0xae>
    for (i = 0; i < times; ++i) {
 17a:	3c01      	subs	r4, #1
 17c:	d1ec      	bne.n	158 <sha512_test+0x158>
    ret = wc_Sha512Final(&sha, hash);
 17e:	a90c      	add	r1, sp, #48	; 0x30
 180:	a82c      	add	r0, sp, #176	; 0xb0
 182:	f7ff fffe 	bl	0 <wc_Sha512Final>
    if (ret != 0)
 186:	b148      	cbz	r0, 19c <sha512_test+0x19c>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 188:	4244      	negs	r4, r0
 18a:	481c      	ldr	r0, [pc, #112]	; (1fc <sha512_test+0x1fc>)
 18c:	f3c4 040a 	ubfx	r4, r4, #0, #11
 190:	4344      	muls	r4, r0
 192:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 196:	f6a4 44f6 	subw	r4, r4, #3318	; 0xcf6
 19a:	e788      	b.n	ae <sha512_test+0xae>
    if (XMEMCMP(hash, large_digest, WC_SHA512_DIGEST_SIZE) != 0)
 19c:	4918      	ldr	r1, [pc, #96]	; (200 <sha512_test+0x200>)
 19e:	2240      	movs	r2, #64	; 0x40
 1a0:	a80c      	add	r0, sp, #48	; 0x30
 1a2:	f7ff fffe 	bl	0 <memcmp>
 1a6:	b9d8      	cbnz	r0, 1e0 <sha512_test+0x1e0>
    for (i = 1; i < 16; i++) {
 1a8:	2501      	movs	r5, #1
        ret = wc_Sha512Update(&sha, (byte*)large_input + i,
 1aa:	ab9c      	add	r3, sp, #624	; 0x270
 1ac:	f5c5 6280 	rsb	r2, r5, #1024	; 0x400
 1b0:	1959      	adds	r1, r3, r5
 1b2:	a82c      	add	r0, sp, #176	; 0xb0
 1b4:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret != 0)
 1b8:	b148      	cbz	r0, 1ce <sha512_test+0x1ce>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 1ba:	4244      	negs	r4, r0
 1bc:	480f      	ldr	r0, [pc, #60]	; (1fc <sha512_test+0x1fc>)
 1be:	f3c4 040a 	ubfx	r4, r4, #0, #11
 1c2:	4344      	muls	r4, r0
 1c4:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 1c8:	f5a4 6450 	sub.w	r4, r4, #3328	; 0xd00
 1cc:	e76f      	b.n	ae <sha512_test+0xae>
        ret = wc_Sha512Final(&sha, hash);
 1ce:	a90c      	add	r1, sp, #48	; 0x30
 1d0:	a82c      	add	r0, sp, #176	; 0xb0
 1d2:	f7ff fffe 	bl	0 <wc_Sha512Final>
    for (i = 1; i < 16; i++) {
 1d6:	3501      	adds	r5, #1
 1d8:	2d10      	cmp	r5, #16
        ret = wc_Sha512Final(&sha, hash);
 1da:	4604      	mov	r4, r0
    for (i = 1; i < 16; i++) {
 1dc:	d1e5      	bne.n	1aa <sha512_test+0x1aa>
 1de:	e766      	b.n	ae <sha512_test+0xae>
        ERROR_OUT(WC_TEST_RET_ENC_NC, exit);
 1e0:	4c08      	ldr	r4, [pc, #32]	; (204 <sha512_test+0x204>)
 1e2:	e764      	b.n	ae <sha512_test+0xae>
 1e4:	00000000 	.word	0x00000000
 1e8:	00000001 	.word	0x00000001
 1ec:	00000000 	.word	0x00000000
 1f0:	00000071 	.word	0x00000071
 1f4:	000000b2 	.word	0x000000b2
 1f8:	00000076 	.word	0x00000076
 1fc:	fffe7960 	.word	0xfffe7960
 200:	000000f3 	.word	0x000000f3
 204:	fffff308 	.word	0xfffff308

Disassembly of section .text.sha512_224_test:

00000000 <sha512_224_test>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a.inLen  = XSTRLEN(a.input);
   4:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 1e8 <sha512_224_test+0x1e8>
    b.inLen  = XSTRLEN(b.input);
   8:	4f78      	ldr	r7, [pc, #480]	; (1ec <sha512_224_test+0x1ec>)
    c.inLen  = XSTRLEN(c.input);
   a:	4e79      	ldr	r6, [pc, #484]	; (1f0 <sha512_224_test+0x1f0>)
{
   c:	f5ad 6dc5 	sub.w	sp, sp, #1576	; 0x628
    a.inLen  = XSTRLEN(a.input);
  10:	4640      	mov	r0, r8
  12:	f7ff fffe 	bl	0 <strlen>
  16:	4605      	mov	r5, r0
    b.inLen  = XSTRLEN(b.input);
  18:	4638      	mov	r0, r7
  1a:	f7ff fffe 	bl	0 <strlen>
  1e:	4604      	mov	r4, r0
    c.inLen  = XSTRLEN(c.input);
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <strlen>
    test_sha[0] = a;
  26:	4b73      	ldr	r3, [pc, #460]	; (1f4 <sha512_224_test+0x1f4>)
  28:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
  2c:	e9cd 350f 	strd	r3, r5, [sp, #60]	; 0x3c
    test_sha[1] = b;
  30:	4b71      	ldr	r3, [pc, #452]	; (1f8 <sha512_224_test+0x1f8>)
  32:	9712      	str	r7, [sp, #72]	; 0x48
  34:	e9cd 3413 	strd	r3, r4, [sp, #76]	; 0x4c
    test_sha[2] = c;
  38:	4b70      	ldr	r3, [pc, #448]	; (1fc <sha512_224_test+0x1fc>)
  3a:	9616      	str	r6, [sp, #88]	; 0x58
  3c:	e9cd 3017 	strd	r3, r0, [sp, #92]	; 0x5c
    ret = wc_InitSha512_224_ex(&sha, HEAP_HINT, devId);
  40:	2100      	movs	r1, #0
  42:	f06f 0201 	mvn.w	r2, #1
  46:	a81a      	add	r0, sp, #104	; 0x68
  48:	f7ff fffe 	bl	0 <wc_InitSha512_224_ex>
    if (ret != 0)
  4c:	4601      	mov	r1, r0
  4e:	b168      	cbz	r0, 6c <sha512_224_test+0x6c>
        return WC_TEST_RET_ENC_EC(ret);
  50:	496b      	ldr	r1, [pc, #428]	; (200 <sha512_224_test+0x200>)
  52:	4244      	negs	r4, r0
  54:	f3c4 040a 	ubfx	r4, r4, #0, #11
  58:	434c      	muls	r4, r1
  5a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  5e:	f6a4 544b 	subw	r4, r4, #3403	; 0xd4b
} /* sha512_224_test */
  62:	4620      	mov	r0, r4
  64:	f50d 6dc5 	add.w	sp, sp, #1576	; 0x628
  68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = wc_InitSha512_224_ex(&shaCopy, HEAP_HINT, devId);
  6c:	f06f 0201 	mvn.w	r2, #1
  70:	a852      	add	r0, sp, #328	; 0x148
  72:	f7ff fffe 	bl	0 <wc_InitSha512_224_ex>
    if (ret != 0) {
  76:	4606      	mov	r6, r0
  78:	b160      	cbz	r0, 94 <sha512_224_test+0x94>
        wc_Sha512_224Free(&sha);
  7a:	a81a      	add	r0, sp, #104	; 0x68
  7c:	f7ff fffe 	bl	0 <wc_Sha512_224Free>
        return WC_TEST_RET_ENC_EC(ret);
  80:	4274      	negs	r4, r6
  82:	485f      	ldr	r0, [pc, #380]	; (200 <sha512_224_test+0x200>)
  84:	f3c4 040a 	ubfx	r4, r4, #0, #11
  88:	4344      	muls	r4, r0
  8a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  8e:	f6a4 544f 	subw	r4, r4, #3407	; 0xd4f
  92:	e7e6      	b.n	62 <sha512_224_test+0x62>
  94:	ad0e      	add	r5, sp, #56	; 0x38
        ret = wc_Sha512_224Update(&sha, (byte*)test_sha[i].input,
  96:	68aa      	ldr	r2, [r5, #8]
  98:	6829      	ldr	r1, [r5, #0]
  9a:	a81a      	add	r0, sp, #104	; 0x68
  9c:	f7ff fffe 	bl	0 <wc_Sha512_224Update>
        if (ret != 0)
  a0:	b160      	cbz	r0, bc <sha512_224_test+0xbc>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  a2:	4c57      	ldr	r4, [pc, #348]	; (200 <sha512_224_test+0x200>)
  a4:	4374      	muls	r4, r6
  a6:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  aa:	f6a4 5456 	subw	r4, r4, #3414	; 0xd56
    wc_Sha512_224Free(&sha);
  ae:	a81a      	add	r0, sp, #104	; 0x68
  b0:	f7ff fffe 	bl	0 <wc_Sha512_224Free>
    wc_Sha512_224Free(&shaCopy);
  b4:	a852      	add	r0, sp, #328	; 0x148
  b6:	f7ff fffe 	bl	0 <wc_Sha512_224Free>
    return ret;
  ba:	e7d2      	b.n	62 <sha512_224_test+0x62>
        ret = wc_Sha512_224GetHash(&sha, hashcopy);
  bc:	a907      	add	r1, sp, #28
  be:	a81a      	add	r0, sp, #104	; 0x68
  c0:	f7ff fffe 	bl	0 <wc_Sha512_224GetHash>
        if (ret != 0)
  c4:	b130      	cbz	r0, d4 <sha512_224_test+0xd4>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  c6:	4c4e      	ldr	r4, [pc, #312]	; (200 <sha512_224_test+0x200>)
  c8:	4374      	muls	r4, r6
  ca:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  ce:	f6a4 5459 	subw	r4, r4, #3417	; 0xd59
  d2:	e7ec      	b.n	ae <sha512_224_test+0xae>
        ret = wc_Sha512_224Copy(&sha, &shaCopy);
  d4:	a952      	add	r1, sp, #328	; 0x148
  d6:	a81a      	add	r0, sp, #104	; 0x68
  d8:	f7ff fffe 	bl	0 <wc_Sha512_224Copy>
        if (ret != 0)
  dc:	b130      	cbz	r0, ec <sha512_224_test+0xec>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  de:	4c48      	ldr	r4, [pc, #288]	; (200 <sha512_224_test+0x200>)
  e0:	4374      	muls	r4, r6
  e2:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  e6:	f6a4 545c 	subw	r4, r4, #3420	; 0xd5c
  ea:	e7e0      	b.n	ae <sha512_224_test+0xae>
        ret = wc_Sha512_224Final(&sha, hash);
  ec:	4669      	mov	r1, sp
  ee:	a81a      	add	r0, sp, #104	; 0x68
  f0:	f7ff fffe 	bl	0 <wc_Sha512_224Final>
        if (ret != 0)
  f4:	b130      	cbz	r0, 104 <sha512_224_test+0x104>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  f6:	4c42      	ldr	r4, [pc, #264]	; (200 <sha512_224_test+0x200>)
  f8:	4374      	muls	r4, r6
  fa:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  fe:	f6a4 545f 	subw	r4, r4, #3423	; 0xd5f
 102:	e7d4      	b.n	ae <sha512_224_test+0xae>
        wc_Sha512_224Free(&shaCopy);
 104:	a852      	add	r0, sp, #328	; 0x148
 106:	f7ff fffe 	bl	0 <wc_Sha512_224Free>
        if (XMEMCMP(hash, test_sha[i].output, WC_SHA512_224_DIGEST_SIZE) != 0)
 10a:	6869      	ldr	r1, [r5, #4]
 10c:	221c      	movs	r2, #28
 10e:	4668      	mov	r0, sp
 110:	f7ff fffe 	bl	0 <memcmp>
 114:	b130      	cbz	r0, 124 <sha512_224_test+0x124>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 116:	4c3a      	ldr	r4, [pc, #232]	; (200 <sha512_224_test+0x200>)
 118:	4374      	muls	r4, r6
 11a:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 11e:	f6a4 5463 	subw	r4, r4, #3427	; 0xd63
 122:	e7c4      	b.n	ae <sha512_224_test+0xae>
        if (XMEMCMP(hash, hashcopy, WC_SHA512_224_DIGEST_SIZE) != 0)
 124:	221c      	movs	r2, #28
 126:	eb0d 0102 	add.w	r1, sp, r2
 12a:	4668      	mov	r0, sp
 12c:	f7ff fffe 	bl	0 <memcmp>
 130:	b130      	cbz	r0, 140 <sha512_224_test+0x140>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 132:	4c33      	ldr	r4, [pc, #204]	; (200 <sha512_224_test+0x200>)
 134:	4374      	muls	r4, r6
 136:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 13a:	f6a4 5467 	subw	r4, r4, #3431	; 0xd67
 13e:	e7b6      	b.n	ae <sha512_224_test+0xae>
    for (i = 0; i < times; ++i) {
 140:	3601      	adds	r6, #1
 142:	2e03      	cmp	r6, #3
 144:	f105 0510 	add.w	r5, r5, #16
 148:	d1a5      	bne.n	96 <sha512_224_test+0x96>
 14a:	ab8a      	add	r3, sp, #552	; 0x228
        large_input[i] = (byte)(i & 0xFF);
 14c:	f803 0b01 	strb.w	r0, [r3], #1
    for (i = 0; i < (int)sizeof(large_input); i++) {
 150:	3001      	adds	r0, #1
 152:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 156:	d1f9      	bne.n	14c <sha512_224_test+0x14c>
 158:	2464      	movs	r4, #100	; 0x64
        ret = wc_Sha512_224Update(&sha, (byte*)large_input,
 15a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 15e:	a98a      	add	r1, sp, #552	; 0x228
 160:	a81a      	add	r0, sp, #104	; 0x68
 162:	f7ff fffe 	bl	0 <wc_Sha512_224Update>
        if (ret != 0)
 166:	b148      	cbz	r0, 17c <sha512_224_test+0x17c>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 168:	4244      	negs	r4, r0
 16a:	4825      	ldr	r0, [pc, #148]	; (200 <sha512_224_test+0x200>)
 16c:	f3c4 040a 	ubfx	r4, r4, #0, #11
 170:	4344      	muls	r4, r0
 172:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 176:	f6a4 5487 	subw	r4, r4, #3463	; 0xd87
 17a:	e798      	b.n	ae <sha512_224_test+0xae>
    for (i = 0; i < times; ++i) {
 17c:	3c01      	subs	r4, #1
 17e:	d1ec      	bne.n	15a <sha512_224_test+0x15a>
    ret = wc_Sha512_224Final(&sha, hash);
 180:	4669      	mov	r1, sp
 182:	a81a      	add	r0, sp, #104	; 0x68
 184:	f7ff fffe 	bl	0 <wc_Sha512_224Final>
    if (ret != 0)
 188:	b148      	cbz	r0, 19e <sha512_224_test+0x19e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 18a:	4244      	negs	r4, r0
 18c:	481c      	ldr	r0, [pc, #112]	; (200 <sha512_224_test+0x200>)
 18e:	f3c4 040a 	ubfx	r4, r4, #0, #11
 192:	4344      	muls	r4, r0
 194:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 198:	f6a4 548b 	subw	r4, r4, #3467	; 0xd8b
 19c:	e787      	b.n	ae <sha512_224_test+0xae>
    if (XMEMCMP(hash, large_digest, WC_SHA512_224_DIGEST_SIZE) != 0)
 19e:	4919      	ldr	r1, [pc, #100]	; (204 <sha512_224_test+0x204>)
 1a0:	221c      	movs	r2, #28
 1a2:	4668      	mov	r0, sp
 1a4:	f7ff fffe 	bl	0 <memcmp>
 1a8:	b9d8      	cbnz	r0, 1e2 <sha512_224_test+0x1e2>
    for (i = 1; i < 16; i++) {
 1aa:	2501      	movs	r5, #1
        ret = wc_Sha512_224Update(&sha, (byte*)large_input + i,
 1ac:	ab8a      	add	r3, sp, #552	; 0x228
 1ae:	f5c5 6280 	rsb	r2, r5, #1024	; 0x400
 1b2:	1959      	adds	r1, r3, r5
 1b4:	a81a      	add	r0, sp, #104	; 0x68
 1b6:	f7ff fffe 	bl	0 <wc_Sha512_224Update>
        if (ret != 0)
 1ba:	b148      	cbz	r0, 1d0 <sha512_224_test+0x1d0>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 1bc:	4244      	negs	r4, r0
 1be:	4810      	ldr	r0, [pc, #64]	; (200 <sha512_224_test+0x200>)
 1c0:	f3c4 040a 	ubfx	r4, r4, #0, #11
 1c4:	4344      	muls	r4, r0
 1c6:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 1ca:	f6a4 5495 	subw	r4, r4, #3477	; 0xd95
 1ce:	e76e      	b.n	ae <sha512_224_test+0xae>
        ret = wc_Sha512_224Final(&sha, hash);
 1d0:	4669      	mov	r1, sp
 1d2:	a81a      	add	r0, sp, #104	; 0x68
 1d4:	f7ff fffe 	bl	0 <wc_Sha512_224Final>
    for (i = 1; i < 16; i++) {
 1d8:	3501      	adds	r5, #1
 1da:	2d10      	cmp	r5, #16
        ret = wc_Sha512_224Final(&sha, hash);
 1dc:	4604      	mov	r4, r0
    for (i = 1; i < 16; i++) {
 1de:	d1e5      	bne.n	1ac <sha512_224_test+0x1ac>
 1e0:	e765      	b.n	ae <sha512_224_test+0xae>
        ERROR_OUT(WC_TEST_RET_ENC_NC, exit);
 1e2:	4c09      	ldr	r4, [pc, #36]	; (208 <sha512_224_test+0x208>)
 1e4:	e763      	b.n	ae <sha512_224_test+0xae>
 1e6:	bf00      	nop
 1e8:	00000000 	.word	0x00000000
 1ec:	00000001 	.word	0x00000001
	...
 1f8:	0000001d 	.word	0x0000001d
 1fc:	0000003a 	.word	0x0000003a
 200:	fffe7960 	.word	0xfffe7960
 204:	00000057 	.word	0x00000057
 208:	fffff273 	.word	0xfffff273

Disassembly of section .text.sha512_256_test:

00000000 <sha512_256_test>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    a.inLen  = XSTRLEN(a.input);
   4:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 1e8 <sha512_256_test+0x1e8>
    b.inLen  = XSTRLEN(b.input);
   8:	4f78      	ldr	r7, [pc, #480]	; (1ec <sha512_256_test+0x1ec>)
    c.inLen  = XSTRLEN(c.input);
   a:	4e79      	ldr	r6, [pc, #484]	; (1f0 <sha512_256_test+0x1f0>)
{
   c:	f5ad 6dc6 	sub.w	sp, sp, #1584	; 0x630
    a.inLen  = XSTRLEN(a.input);
  10:	4640      	mov	r0, r8
  12:	f7ff fffe 	bl	0 <strlen>
  16:	4605      	mov	r5, r0
    b.inLen  = XSTRLEN(b.input);
  18:	4638      	mov	r0, r7
  1a:	f7ff fffe 	bl	0 <strlen>
  1e:	4604      	mov	r4, r0
    c.inLen  = XSTRLEN(c.input);
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <strlen>
    test_sha[0] = a;
  26:	4b73      	ldr	r3, [pc, #460]	; (1f4 <sha512_256_test+0x1f4>)
  28:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
  2c:	e9cd 3511 	strd	r3, r5, [sp, #68]	; 0x44
    test_sha[1] = b;
  30:	4b71      	ldr	r3, [pc, #452]	; (1f8 <sha512_256_test+0x1f8>)
  32:	9714      	str	r7, [sp, #80]	; 0x50
  34:	e9cd 3415 	strd	r3, r4, [sp, #84]	; 0x54
    test_sha[2] = c;
  38:	4b70      	ldr	r3, [pc, #448]	; (1fc <sha512_256_test+0x1fc>)
  3a:	9618      	str	r6, [sp, #96]	; 0x60
  3c:	e9cd 3019 	strd	r3, r0, [sp, #100]	; 0x64
    ret = wc_InitSha512_256_ex(&sha, HEAP_HINT, devId);
  40:	2100      	movs	r1, #0
  42:	f06f 0201 	mvn.w	r2, #1
  46:	a81c      	add	r0, sp, #112	; 0x70
  48:	f7ff fffe 	bl	0 <wc_InitSha512_256_ex>
    if (ret != 0)
  4c:	4601      	mov	r1, r0
  4e:	b168      	cbz	r0, 6c <sha512_256_test+0x6c>
        return WC_TEST_RET_ENC_EC(ret);
  50:	496b      	ldr	r1, [pc, #428]	; (200 <sha512_256_test+0x200>)
  52:	4244      	negs	r4, r0
  54:	f3c4 040a 	ubfx	r4, r4, #0, #11
  58:	434c      	muls	r4, r1
  5a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  5e:	f6a4 54e3 	subw	r4, r4, #3555	; 0xde3
} /* sha512_256_test */
  62:	4620      	mov	r0, r4
  64:	f50d 6dc6 	add.w	sp, sp, #1584	; 0x630
  68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = wc_InitSha512_256_ex(&shaCopy, HEAP_HINT, devId);
  6c:	f06f 0201 	mvn.w	r2, #1
  70:	a854      	add	r0, sp, #336	; 0x150
  72:	f7ff fffe 	bl	0 <wc_InitSha512_256_ex>
    if (ret != 0) {
  76:	4606      	mov	r6, r0
  78:	b160      	cbz	r0, 94 <sha512_256_test+0x94>
        wc_Sha512_256Free(&sha);
  7a:	a81c      	add	r0, sp, #112	; 0x70
  7c:	f7ff fffe 	bl	0 <wc_Sha512_256Free>
        return WC_TEST_RET_ENC_EC(ret);
  80:	4274      	negs	r4, r6
  82:	485f      	ldr	r0, [pc, #380]	; (200 <sha512_256_test+0x200>)
  84:	f3c4 040a 	ubfx	r4, r4, #0, #11
  88:	4344      	muls	r4, r0
  8a:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  8e:	f6a4 54e7 	subw	r4, r4, #3559	; 0xde7
  92:	e7e6      	b.n	62 <sha512_256_test+0x62>
  94:	ad10      	add	r5, sp, #64	; 0x40
        ret = wc_Sha512_256Update(&sha, (byte*)test_sha[i].input,
  96:	68aa      	ldr	r2, [r5, #8]
  98:	6829      	ldr	r1, [r5, #0]
  9a:	a81c      	add	r0, sp, #112	; 0x70
  9c:	f7ff fffe 	bl	0 <wc_Sha512_256Update>
        if (ret != 0)
  a0:	b160      	cbz	r0, bc <sha512_256_test+0xbc>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  a2:	4c57      	ldr	r4, [pc, #348]	; (200 <sha512_256_test+0x200>)
  a4:	4374      	muls	r4, r6
  a6:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  aa:	f6a4 54ee 	subw	r4, r4, #3566	; 0xdee
    wc_Sha512_256Free(&sha);
  ae:	a81c      	add	r0, sp, #112	; 0x70
  b0:	f7ff fffe 	bl	0 <wc_Sha512_256Free>
    wc_Sha512_256Free(&shaCopy);
  b4:	a854      	add	r0, sp, #336	; 0x150
  b6:	f7ff fffe 	bl	0 <wc_Sha512_256Free>
    return ret;
  ba:	e7d2      	b.n	62 <sha512_256_test+0x62>
        ret = wc_Sha512_256GetHash(&sha, hashcopy);
  bc:	a908      	add	r1, sp, #32
  be:	a81c      	add	r0, sp, #112	; 0x70
  c0:	f7ff fffe 	bl	0 <wc_Sha512_256GetHash>
        if (ret != 0)
  c4:	b138      	cbz	r0, d6 <sha512_256_test+0xd6>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  c6:	4c4e      	ldr	r4, [pc, #312]	; (200 <sha512_256_test+0x200>)
  c8:	4374      	muls	r4, r6
  ca:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  ce:	f46f 635f 	mvn.w	r3, #3568	; 0xdf0
  d2:	441c      	add	r4, r3
  d4:	e7eb      	b.n	ae <sha512_256_test+0xae>
        ret = wc_Sha512_256Copy(&sha, &shaCopy);
  d6:	a954      	add	r1, sp, #336	; 0x150
  d8:	a81c      	add	r0, sp, #112	; 0x70
  da:	f7ff fffe 	bl	0 <wc_Sha512_256Copy>
        if (ret != 0)
  de:	b130      	cbz	r0, ee <sha512_256_test+0xee>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  e0:	4c47      	ldr	r4, [pc, #284]	; (200 <sha512_256_test+0x200>)
  e2:	4374      	muls	r4, r6
  e4:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
  e8:	f6a4 54f4 	subw	r4, r4, #3572	; 0xdf4
  ec:	e7df      	b.n	ae <sha512_256_test+0xae>
        ret = wc_Sha512_256Final(&sha, hash);
  ee:	4669      	mov	r1, sp
  f0:	a81c      	add	r0, sp, #112	; 0x70
  f2:	f7ff fffe 	bl	0 <wc_Sha512_256Final>
        if (ret != 0)
  f6:	b130      	cbz	r0, 106 <sha512_256_test+0x106>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
  f8:	4c41      	ldr	r4, [pc, #260]	; (200 <sha512_256_test+0x200>)
  fa:	4374      	muls	r4, r6
  fc:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 100:	f6a4 54f7 	subw	r4, r4, #3575	; 0xdf7
 104:	e7d3      	b.n	ae <sha512_256_test+0xae>
        wc_Sha512_256Free(&shaCopy);
 106:	a854      	add	r0, sp, #336	; 0x150
 108:	f7ff fffe 	bl	0 <wc_Sha512_256Free>
        if (XMEMCMP(hash, test_sha[i].output, WC_SHA512_256_DIGEST_SIZE) != 0)
 10c:	6869      	ldr	r1, [r5, #4]
 10e:	2220      	movs	r2, #32
 110:	4668      	mov	r0, sp
 112:	f7ff fffe 	bl	0 <memcmp>
 116:	b130      	cbz	r0, 126 <sha512_256_test+0x126>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 118:	4c39      	ldr	r4, [pc, #228]	; (200 <sha512_256_test+0x200>)
 11a:	4374      	muls	r4, r6
 11c:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 120:	f6a4 54fb 	subw	r4, r4, #3579	; 0xdfb
 124:	e7c3      	b.n	ae <sha512_256_test+0xae>
        if (XMEMCMP(hash, hashcopy, WC_SHA512_256_DIGEST_SIZE) != 0)
 126:	2220      	movs	r2, #32
 128:	eb0d 0102 	add.w	r1, sp, r2
 12c:	4668      	mov	r0, sp
 12e:	f7ff fffe 	bl	0 <memcmp>
 132:	b130      	cbz	r0, 142 <sha512_256_test+0x142>
            ERROR_OUT(WC_TEST_RET_ENC_I(i), exit);
 134:	4c32      	ldr	r4, [pc, #200]	; (200 <sha512_256_test+0x200>)
 136:	4374      	muls	r4, r6
 138:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
 13c:	f6a4 54ff 	subw	r4, r4, #3583	; 0xdff
 140:	e7b5      	b.n	ae <sha512_256_test+0xae>
    for (i = 0; i < times; ++i) {
 142:	3601      	adds	r6, #1
 144:	2e03      	cmp	r6, #3
 146:	f105 0510 	add.w	r5, r5, #16
 14a:	d1a4      	bne.n	96 <sha512_256_test+0x96>
 14c:	ab8c      	add	r3, sp, #560	; 0x230
        large_input[i] = (byte)(i & 0xFF);
 14e:	f803 0b01 	strb.w	r0, [r3], #1
    for (i = 0; i < (int)sizeof(large_input); i++) {
 152:	3001      	adds	r0, #1
 154:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 158:	d1f9      	bne.n	14e <sha512_256_test+0x14e>
 15a:	2464      	movs	r4, #100	; 0x64
        ret = wc_Sha512_256Update(&sha, (byte*)large_input,
 15c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 160:	a98c      	add	r1, sp, #560	; 0x230
 162:	a81c      	add	r0, sp, #112	; 0x70
 164:	f7ff fffe 	bl	0 <wc_Sha512_256Update>
        if (ret != 0)
 168:	b148      	cbz	r0, 17e <sha512_256_test+0x17e>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 16a:	4244      	negs	r4, r0
 16c:	4824      	ldr	r0, [pc, #144]	; (200 <sha512_256_test+0x200>)
 16e:	f3c4 040a 	ubfx	r4, r4, #0, #11
 172:	4344      	muls	r4, r0
 174:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 178:	f6a4 641f 	subw	r4, r4, #3615	; 0xe1f
 17c:	e797      	b.n	ae <sha512_256_test+0xae>
    for (i = 0; i < times; ++i) {
 17e:	3c01      	subs	r4, #1
 180:	d1ec      	bne.n	15c <sha512_256_test+0x15c>
    ret = wc_Sha512_256Final(&sha, hash);
 182:	4669      	mov	r1, sp
 184:	a81c      	add	r0, sp, #112	; 0x70
 186:	f7ff fffe 	bl	0 <wc_Sha512_256Final>
    if (ret != 0)
 18a:	b148      	cbz	r0, 1a0 <sha512_256_test+0x1a0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 18c:	4244      	negs	r4, r0
 18e:	481c      	ldr	r0, [pc, #112]	; (200 <sha512_256_test+0x200>)
 190:	f3c4 040a 	ubfx	r4, r4, #0, #11
 194:	4344      	muls	r4, r0
 196:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 19a:	f6a4 6423 	subw	r4, r4, #3619	; 0xe23
 19e:	e786      	b.n	ae <sha512_256_test+0xae>
    if (XMEMCMP(hash, large_digest, WC_SHA512_256_DIGEST_SIZE) != 0)
 1a0:	4918      	ldr	r1, [pc, #96]	; (204 <sha512_256_test+0x204>)
 1a2:	2220      	movs	r2, #32
 1a4:	4668      	mov	r0, sp
 1a6:	f7ff fffe 	bl	0 <memcmp>
 1aa:	b9d8      	cbnz	r0, 1e4 <sha512_256_test+0x1e4>
    for (i = 1; i < 16; i++) {
 1ac:	2501      	movs	r5, #1
        ret = wc_Sha512_256Update(&sha, (byte*)large_input + i,
 1ae:	ab8c      	add	r3, sp, #560	; 0x230
 1b0:	f5c5 6280 	rsb	r2, r5, #1024	; 0x400
 1b4:	1959      	adds	r1, r3, r5
 1b6:	a81c      	add	r0, sp, #112	; 0x70
 1b8:	f7ff fffe 	bl	0 <wc_Sha512_256Update>
        if (ret != 0)
 1bc:	b148      	cbz	r0, 1d2 <sha512_256_test+0x1d2>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
 1be:	4244      	negs	r4, r0
 1c0:	480f      	ldr	r0, [pc, #60]	; (200 <sha512_256_test+0x200>)
 1c2:	f3c4 040a 	ubfx	r4, r4, #0, #11
 1c6:	4344      	muls	r4, r0
 1c8:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 1cc:	f6a4 642d 	subw	r4, r4, #3629	; 0xe2d
 1d0:	e76d      	b.n	ae <sha512_256_test+0xae>
        ret = wc_Sha512_256Final(&sha, hash);
 1d2:	4669      	mov	r1, sp
 1d4:	a81c      	add	r0, sp, #112	; 0x70
 1d6:	f7ff fffe 	bl	0 <wc_Sha512_256Final>
    for (i = 1; i < 16; i++) {
 1da:	3501      	adds	r5, #1
 1dc:	2d10      	cmp	r5, #16
        ret = wc_Sha512_256Final(&sha, hash);
 1de:	4604      	mov	r4, r0
    for (i = 1; i < 16; i++) {
 1e0:	d1e5      	bne.n	1ae <sha512_256_test+0x1ae>
 1e2:	e764      	b.n	ae <sha512_256_test+0xae>
        ERROR_OUT(WC_TEST_RET_ENC_NC, exit);
 1e4:	4c08      	ldr	r4, [pc, #32]	; (208 <sha512_256_test+0x208>)
 1e6:	e762      	b.n	ae <sha512_256_test+0xae>
 1e8:	00000000 	.word	0x00000000
 1ec:	00000001 	.word	0x00000001
	...
 1f8:	00000021 	.word	0x00000021
 1fc:	00000042 	.word	0x00000042
 200:	fffe7960 	.word	0xfffe7960
 204:	00000063 	.word	0x00000063
 208:	fffff1db 	.word	0xfffff1db

Disassembly of section .text.hash_test:

00000000 <hash_test>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    byte             data[] = "0123456789abcdef0123456789abcdef0123456";
   4:	4bab      	ldr	r3, [pc, #684]	; (2b4 <hash_test+0x2b4>)
{
   6:	b0ed      	sub	sp, #436	; 0x1b4
    byte             data[] = "0123456789abcdef0123456789abcdef0123456";
   8:	ac0a      	add	r4, sp, #40	; 0x28
   a:	f103 0528 	add.w	r5, r3, #40	; 0x28
   e:	6818      	ldr	r0, [r3, #0]
  10:	6859      	ldr	r1, [r3, #4]
  12:	4622      	mov	r2, r4
  14:	c203      	stmia	r2!, {r0, r1}
  16:	3308      	adds	r3, #8
  18:	42ab      	cmp	r3, r5
  1a:	4614      	mov	r4, r2
  1c:	d1f7      	bne.n	e <hash_test+0xe>
    enum wc_HashType typesGood[] = { WC_HASH_TYPE_MD5, WC_HASH_TYPE_SHA,
  1e:	4aa6      	ldr	r2, [pc, #664]	; (2b8 <hash_test+0x2b8>)
  20:	f8d2 00b7 	ldr.w	r0, [r2, #183]	; 0xb7
  24:	f8d2 10bb 	ldr.w	r1, [r2, #187]	; 0xbb
  28:	f8b2 20bf 	ldrh.w	r2, [r2, #191]	; 0xbf
  2c:	ab07      	add	r3, sp, #28
  2e:	c303      	stmia	r3!, {r0, r1}
    enum wc_HashType typesNoImpl[] = {
  30:	af05      	add	r7, sp, #20
    enum wc_HashType typesGood[] = { WC_HASH_TYPE_MD5, WC_HASH_TYPE_SHA,
  32:	801a      	strh	r2, [r3, #0]
    enum wc_HashType typesNoImpl[] = {
  34:	2303      	movs	r3, #3
  36:	703b      	strb	r3, [r7, #0]
  38:	2305      	movs	r3, #5
  3a:	707b      	strb	r3, [r7, #1]
  3c:	2307      	movs	r3, #7
  3e:	70bb      	strb	r3, [r7, #2]
  40:	230a      	movs	r3, #10
  42:	70fb      	strb	r3, [r7, #3]
  44:	230b      	movs	r3, #11
  46:	713b      	strb	r3, [r7, #4]
  48:	230c      	movs	r3, #12
  4a:	717b      	strb	r3, [r7, #5]
  4c:	230d      	movs	r3, #13
  4e:	71bb      	strb	r3, [r7, #6]
    enum wc_HashType typesBad[]  = { WC_HASH_TYPE_NONE, WC_HASH_TYPE_MD5_SHA,
  50:	2309      	movs	r3, #9
    enum wc_HashType typesNoImpl[] = {
  52:	2400      	movs	r4, #0
    enum wc_HashType typesBad[]  = { WC_HASH_TYPE_NONE, WC_HASH_TYPE_MD5_SHA,
  54:	f88d 300d 	strb.w	r3, [sp, #13]
  58:	2302      	movs	r3, #2
  5a:	2201      	movs	r2, #1
  5c:	f88d 300f 	strb.w	r3, [sp, #15]
    enum wc_HashType typesHashBad[] = { WC_HASH_TYPE_MD2, WC_HASH_TYPE_MD4,
  60:	f88d 3011 	strb.w	r3, [sp, #17]
    ret = wc_HashInit(NULL, WC_HASH_TYPE_SHA256);
  64:	2106      	movs	r1, #6
    enum wc_HashType typesHashBad[] = { WC_HASH_TYPE_MD2, WC_HASH_TYPE_MD4,
  66:	230e      	movs	r3, #14
    ret = wc_HashInit(NULL, WC_HASH_TYPE_SHA256);
  68:	4620      	mov	r0, r4
    enum wc_HashType typesNoImpl[] = {
  6a:	71fc      	strb	r4, [r7, #7]
    enum wc_HashType typesBad[]  = { WC_HASH_TYPE_NONE, WC_HASH_TYPE_MD5_SHA,
  6c:	f88d 400c 	strb.w	r4, [sp, #12]
  70:	f88d 200e 	strb.w	r2, [sp, #14]
    enum wc_HashType typesHashBad[] = { WC_HASH_TYPE_MD2, WC_HASH_TYPE_MD4,
  74:	f88d 2010 	strb.w	r2, [sp, #16]
  78:	f88d 3012 	strb.w	r3, [sp, #18]
  7c:	f88d 4013 	strb.w	r4, [sp, #19]
    ret = wc_HashInit(NULL, WC_HASH_TYPE_SHA256);
  80:	f7ff fffe 	bl	0 <wc_HashInit>
    if (ret != BAD_FUNC_ARG)
  84:	f110 0fad 	cmn.w	r0, #173	; 0xad
  88:	d009      	beq.n	9e <hash_test+0x9e>
        return WC_TEST_RET_ENC_EC(ret);
  8a:	4240      	negs	r0, r0
  8c:	f3c0 030a 	ubfx	r3, r0, #0, #11
  90:	4a8a      	ldr	r2, [pc, #552]	; (2bc <hash_test+0x2bc>)
  92:	488b      	ldr	r0, [pc, #556]	; (2c0 <hash_test+0x2c0>)
        return WC_TEST_RET_ENC_EC(ret);
  94:	fb02 0003 	mla	r0, r2, r3, r0
}
  98:	b06d      	add	sp, #436	; 0x1b4
  9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = wc_HashUpdate(NULL, WC_HASH_TYPE_SHA256, NULL, sizeof(data));
  9e:	2328      	movs	r3, #40	; 0x28
  a0:	4622      	mov	r2, r4
  a2:	2106      	movs	r1, #6
  a4:	4620      	mov	r0, r4
  a6:	f7ff fffe 	bl	0 <wc_HashUpdate>
    if (ret != BAD_FUNC_ARG)
  aa:	f110 0fad 	cmn.w	r0, #173	; 0xad
  ae:	d005      	beq.n	bc <hash_test+0xbc>
        return WC_TEST_RET_ENC_EC(ret);
  b0:	4240      	negs	r0, r0
  b2:	f3c0 030a 	ubfx	r3, r0, #0, #11
  b6:	4a81      	ldr	r2, [pc, #516]	; (2bc <hash_test+0x2bc>)
  b8:	4882      	ldr	r0, [pc, #520]	; (2c4 <hash_test+0x2c4>)
  ba:	e7eb      	b.n	94 <hash_test+0x94>
    ret = wc_HashUpdate(&hash, WC_HASH_TYPE_SHA256, NULL, sizeof(data));
  bc:	f10d 0bd0 	add.w	fp, sp, #208	; 0xd0
  c0:	2328      	movs	r3, #40	; 0x28
  c2:	4622      	mov	r2, r4
  c4:	2106      	movs	r1, #6
  c6:	4658      	mov	r0, fp
  c8:	f7ff fffe 	bl	0 <wc_HashUpdate>
    if (ret != BAD_FUNC_ARG)
  cc:	f110 0fad 	cmn.w	r0, #173	; 0xad
  d0:	d005      	beq.n	de <hash_test+0xde>
        return WC_TEST_RET_ENC_EC(ret);
  d2:	4240      	negs	r0, r0
  d4:	f3c0 030a 	ubfx	r3, r0, #0, #11
  d8:	4a78      	ldr	r2, [pc, #480]	; (2bc <hash_test+0x2bc>)
  da:	487b      	ldr	r0, [pc, #492]	; (2c8 <hash_test+0x2c8>)
  dc:	e7da      	b.n	94 <hash_test+0x94>
    ret = wc_HashUpdate(NULL, WC_HASH_TYPE_SHA256, data, sizeof(data));
  de:	2328      	movs	r3, #40	; 0x28
  e0:	eb0d 0203 	add.w	r2, sp, r3
  e4:	2106      	movs	r1, #6
  e6:	4620      	mov	r0, r4
  e8:	f7ff fffe 	bl	0 <wc_HashUpdate>
    if (ret != BAD_FUNC_ARG)
  ec:	f110 0fad 	cmn.w	r0, #173	; 0xad
  f0:	d009      	beq.n	106 <hash_test+0x106>
        return WC_TEST_RET_ENC_EC(ret);
  f2:	4b72      	ldr	r3, [pc, #456]	; (2bc <hash_test+0x2bc>)
  f4:	4240      	negs	r0, r0
  f6:	f3c0 000a 	ubfx	r0, r0, #0, #11
  fa:	4358      	muls	r0, r3
  fc:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 100:	f5a0 50a1 	sub.w	r0, r0, #5152	; 0x1420
 104:	e7c8      	b.n	98 <hash_test+0x98>
    ret = wc_HashFinal(NULL, WC_HASH_TYPE_SHA256, NULL);
 106:	4622      	mov	r2, r4
 108:	2106      	movs	r1, #6
 10a:	4620      	mov	r0, r4
 10c:	f7ff fffe 	bl	0 <wc_HashFinal>
    if (ret != BAD_FUNC_ARG)
 110:	f110 0fad 	cmn.w	r0, #173	; 0xad
 114:	d005      	beq.n	122 <hash_test+0x122>
        return WC_TEST_RET_ENC_EC(ret);
 116:	4240      	negs	r0, r0
 118:	f3c0 030a 	ubfx	r3, r0, #0, #11
 11c:	4a67      	ldr	r2, [pc, #412]	; (2bc <hash_test+0x2bc>)
 11e:	486b      	ldr	r0, [pc, #428]	; (2cc <hash_test+0x2cc>)
 120:	e7b8      	b.n	94 <hash_test+0x94>
    ret = wc_HashFinal(&hash, WC_HASH_TYPE_SHA256, NULL);
 122:	4622      	mov	r2, r4
 124:	2106      	movs	r1, #6
 126:	4658      	mov	r0, fp
 128:	f7ff fffe 	bl	0 <wc_HashFinal>
    if (ret != BAD_FUNC_ARG)
 12c:	f110 0fad 	cmn.w	r0, #173	; 0xad
 130:	d005      	beq.n	13e <hash_test+0x13e>
        return WC_TEST_RET_ENC_EC(ret);
 132:	4240      	negs	r0, r0
 134:	f3c0 030a 	ubfx	r3, r0, #0, #11
 138:	4a60      	ldr	r2, [pc, #384]	; (2bc <hash_test+0x2bc>)
 13a:	4865      	ldr	r0, [pc, #404]	; (2d0 <hash_test+0x2d0>)
 13c:	e7aa      	b.n	94 <hash_test+0x94>
    ret = wc_HashFinal(NULL, WC_HASH_TYPE_SHA256, out);
 13e:	aa14      	add	r2, sp, #80	; 0x50
 140:	2106      	movs	r1, #6
 142:	4620      	mov	r0, r4
 144:	f7ff fffe 	bl	0 <wc_HashFinal>
    if (ret != BAD_FUNC_ARG)
 148:	f110 0fad 	cmn.w	r0, #173	; 0xad
 14c:	d005      	beq.n	15a <hash_test+0x15a>
        return WC_TEST_RET_ENC_EC(ret);
 14e:	4240      	negs	r0, r0
 150:	f3c0 030a 	ubfx	r3, r0, #0, #11
 154:	4a59      	ldr	r2, [pc, #356]	; (2bc <hash_test+0x2bc>)
 156:	485f      	ldr	r0, [pc, #380]	; (2d4 <hash_test+0x2d4>)
 158:	e79c      	b.n	94 <hash_test+0x94>
 15a:	ae03      	add	r6, sp, #12
        ret = wc_HashInit(&hash, typesBad[i]);
 15c:	f816 8b01 	ldrb.w	r8, [r6], #1
 160:	4658      	mov	r0, fp
 162:	4641      	mov	r1, r8
 164:	f7ff fffe 	bl	0 <wc_HashInit>
        if (ret != BAD_FUNC_ARG)
 168:	30ad      	adds	r0, #173	; 0xad
 16a:	d004      	beq.n	176 <hash_test+0x176>
            return WC_TEST_RET_ENC_I(i);
 16c:	4b53      	ldr	r3, [pc, #332]	; (2bc <hash_test+0x2bc>)
 16e:	485a      	ldr	r0, [pc, #360]	; (2d8 <hash_test+0x2d8>)
            return WC_TEST_RET_ENC_I(i);
 170:	fb03 0004 	mla	r0, r3, r4, r0
 174:	e790      	b.n	98 <hash_test+0x98>
        ret = wc_HashUpdate(&hash, typesBad[i], data, sizeof(data));
 176:	2328      	movs	r3, #40	; 0x28
 178:	eb0d 0203 	add.w	r2, sp, r3
 17c:	4641      	mov	r1, r8
 17e:	4658      	mov	r0, fp
 180:	f7ff fffe 	bl	0 <wc_HashUpdate>
        if (ret != BAD_FUNC_ARG)
 184:	30ad      	adds	r0, #173	; 0xad
 186:	d002      	beq.n	18e <hash_test+0x18e>
            return WC_TEST_RET_ENC_I(i);
 188:	4b4c      	ldr	r3, [pc, #304]	; (2bc <hash_test+0x2bc>)
 18a:	4854      	ldr	r0, [pc, #336]	; (2dc <hash_test+0x2dc>)
 18c:	e7f0      	b.n	170 <hash_test+0x170>
        ret = wc_HashFinal(&hash, typesBad[i], out);
 18e:	aa14      	add	r2, sp, #80	; 0x50
 190:	4641      	mov	r1, r8
 192:	4658      	mov	r0, fp
 194:	f7ff fffe 	bl	0 <wc_HashFinal>
        if (ret != BAD_FUNC_ARG)
 198:	30ad      	adds	r0, #173	; 0xad
 19a:	d002      	beq.n	1a2 <hash_test+0x1a2>
            return WC_TEST_RET_ENC_I(i);
 19c:	4b47      	ldr	r3, [pc, #284]	; (2bc <hash_test+0x2bc>)
 19e:	4850      	ldr	r0, [pc, #320]	; (2e0 <hash_test+0x2e0>)
 1a0:	e7e6      	b.n	170 <hash_test+0x170>
        wc_HashFree(&hash, typesBad[i]);
 1a2:	4641      	mov	r1, r8
 1a4:	4658      	mov	r0, fp
    for (i = 0; i < (int)(sizeof(typesBad)/sizeof(*typesBad)); i++) {
 1a6:	3401      	adds	r4, #1
        wc_HashFree(&hash, typesBad[i]);
 1a8:	f7ff fffe 	bl	0 <wc_HashFree>
    for (i = 0; i < (int)(sizeof(typesBad)/sizeof(*typesBad)); i++) {
 1ac:	2c04      	cmp	r4, #4
 1ae:	d1d5      	bne.n	15c <hash_test+0x15c>
    for (i = 0, j = 0; i < (int)(sizeof(typesGood)/sizeof(*typesGood)); i++) {
 1b0:	f04f 0a00 	mov.w	sl, #0
 1b4:	f10d 091c 	add.w	r9, sp, #28
 1b8:	4654      	mov	r4, sl
        if (typesGood[i] == typesNoImpl[j]) {
 1ba:	f819 8b01 	ldrb.w	r8, [r9], #1
 1be:	f817 300a 	ldrb.w	r3, [r7, sl]
        ret = wc_HashInit(&hash, typesGood[i]);
 1c2:	4641      	mov	r1, r8
        if (typesGood[i] == typesNoImpl[j]) {
 1c4:	4543      	cmp	r3, r8
        ret = wc_HashInit(&hash, typesGood[i]);
 1c6:	4658      	mov	r0, fp
            j++;
 1c8:	bf06      	itte	eq
 1ca:	f10a 0a01 	addeq.w	sl, sl, #1
            exp_ret = HASH_TYPE_E;
 1ce:	f06f 06e7 	mvneq.w	r6, #231	; 0xe7
        exp_ret = 0;
 1d2:	2600      	movne	r6, #0
        ret = wc_HashInit(&hash, typesGood[i]);
 1d4:	f7ff fffe 	bl	0 <wc_HashInit>
        if (ret != exp_ret)
 1d8:	4286      	cmp	r6, r0
 1da:	d002      	beq.n	1e2 <hash_test+0x1e2>
            return WC_TEST_RET_ENC_I(i);
 1dc:	4b37      	ldr	r3, [pc, #220]	; (2bc <hash_test+0x2bc>)
 1de:	4841      	ldr	r0, [pc, #260]	; (2e4 <hash_test+0x2e4>)
 1e0:	e7c6      	b.n	170 <hash_test+0x170>
        ret = wc_HashUpdate(&hash, typesGood[i], data, sizeof(data));
 1e2:	2328      	movs	r3, #40	; 0x28
 1e4:	eb0d 0203 	add.w	r2, sp, r3
 1e8:	4641      	mov	r1, r8
 1ea:	4658      	mov	r0, fp
 1ec:	f7ff fffe 	bl	0 <wc_HashUpdate>
        if (ret != exp_ret)
 1f0:	4286      	cmp	r6, r0
 1f2:	d002      	beq.n	1fa <hash_test+0x1fa>
            return WC_TEST_RET_ENC_I(i);
 1f4:	4b31      	ldr	r3, [pc, #196]	; (2bc <hash_test+0x2bc>)
 1f6:	483c      	ldr	r0, [pc, #240]	; (2e8 <hash_test+0x2e8>)
 1f8:	e7ba      	b.n	170 <hash_test+0x170>
        ret = wc_HashFinal(&hash, typesGood[i], out);
 1fa:	aa14      	add	r2, sp, #80	; 0x50
 1fc:	4641      	mov	r1, r8
 1fe:	4658      	mov	r0, fp
 200:	f7ff fffe 	bl	0 <wc_HashFinal>
        if (ret != exp_ret)
 204:	4286      	cmp	r6, r0
 206:	d002      	beq.n	20e <hash_test+0x20e>
            return WC_TEST_RET_ENC_I(i);
 208:	4b2c      	ldr	r3, [pc, #176]	; (2bc <hash_test+0x2bc>)
 20a:	4838      	ldr	r0, [pc, #224]	; (2ec <hash_test+0x2ec>)
 20c:	e7b0      	b.n	170 <hash_test+0x170>
        wc_HashFree(&hash, typesGood[i]);
 20e:	4641      	mov	r1, r8
 210:	4658      	mov	r0, fp
 212:	f7ff fffe 	bl	0 <wc_HashFree>
        digestSz = wc_HashGetDigestSize(typesGood[i]);
 216:	4640      	mov	r0, r8
 218:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
 21c:	4605      	mov	r5, r0
        if (exp_ret < 0 && digestSz != exp_ret)
 21e:	b126      	cbz	r6, 22a <hash_test+0x22a>
 220:	4286      	cmp	r6, r0
 222:	d015      	beq.n	250 <hash_test+0x250>
            return WC_TEST_RET_ENC_I(i);
 224:	4b25      	ldr	r3, [pc, #148]	; (2bc <hash_test+0x2bc>)
 226:	4832      	ldr	r0, [pc, #200]	; (2f0 <hash_test+0x2f0>)
 228:	e7a2      	b.n	170 <hash_test+0x170>
        if (exp_ret == 0 && digestSz < 0)
 22a:	2800      	cmp	r0, #0
 22c:	da02      	bge.n	234 <hash_test+0x234>
            return WC_TEST_RET_ENC_I(i);
 22e:	4b23      	ldr	r3, [pc, #140]	; (2bc <hash_test+0x2bc>)
 230:	4830      	ldr	r0, [pc, #192]	; (2f4 <hash_test+0x2f4>)
 232:	e79d      	b.n	170 <hash_test+0x170>
                                                                  digestSz - 1);
 234:	1e43      	subs	r3, r0, #1
            ret = wc_Hash(typesGood[i], data, sizeof(data), hashOut,
 236:	2228      	movs	r2, #40	; 0x28
 238:	9300      	str	r3, [sp, #0]
 23a:	eb0d 0102 	add.w	r1, sp, r2
 23e:	ab24      	add	r3, sp, #144	; 0x90
 240:	4640      	mov	r0, r8
 242:	f7ff fffe 	bl	0 <wc_Hash>
            if (ret != BUFFER_E)
 246:	3084      	adds	r0, #132	; 0x84
 248:	d002      	beq.n	250 <hash_test+0x250>
                return WC_TEST_RET_ENC_I(i);
 24a:	4b1c      	ldr	r3, [pc, #112]	; (2bc <hash_test+0x2bc>)
 24c:	482a      	ldr	r0, [pc, #168]	; (2f8 <hash_test+0x2f8>)
 24e:	e78f      	b.n	170 <hash_test+0x170>
        ret = wc_Hash(typesGood[i], data, sizeof(data), hashOut, digestSz);
 250:	2228      	movs	r2, #40	; 0x28
 252:	9500      	str	r5, [sp, #0]
 254:	ab24      	add	r3, sp, #144	; 0x90
 256:	eb0d 0102 	add.w	r1, sp, r2
 25a:	4640      	mov	r0, r8
 25c:	f7ff fffe 	bl	0 <wc_Hash>
        if (ret != exp_ret)
 260:	4286      	cmp	r6, r0
 262:	d002      	beq.n	26a <hash_test+0x26a>
            return WC_TEST_RET_ENC_I(i);
 264:	4b15      	ldr	r3, [pc, #84]	; (2bc <hash_test+0x2bc>)
 266:	4825      	ldr	r0, [pc, #148]	; (2fc <hash_test+0x2fc>)
 268:	e782      	b.n	170 <hash_test+0x170>
        if (exp_ret == 0 && XMEMCMP(out, hashOut, digestSz) != 0)
 26a:	b946      	cbnz	r6, 27e <hash_test+0x27e>
 26c:	462a      	mov	r2, r5
 26e:	a924      	add	r1, sp, #144	; 0x90
 270:	a814      	add	r0, sp, #80	; 0x50
 272:	f7ff fffe 	bl	0 <memcmp>
 276:	b110      	cbz	r0, 27e <hash_test+0x27e>
            return WC_TEST_RET_ENC_I(i);
 278:	4b10      	ldr	r3, [pc, #64]	; (2bc <hash_test+0x2bc>)
 27a:	4821      	ldr	r0, [pc, #132]	; (300 <hash_test+0x300>)
 27c:	e778      	b.n	170 <hash_test+0x170>
        ret = wc_HashGetBlockSize(typesGood[i]);
 27e:	4640      	mov	r0, r8
 280:	f7ff fffe 	bl	0 <wc_HashGetBlockSize>
        if (exp_ret < 0 && ret != exp_ret)
 284:	b126      	cbz	r6, 290 <hash_test+0x290>
 286:	4286      	cmp	r6, r0
 288:	d007      	beq.n	29a <hash_test+0x29a>
            return WC_TEST_RET_ENC_I(i);
 28a:	4b0c      	ldr	r3, [pc, #48]	; (2bc <hash_test+0x2bc>)
 28c:	481d      	ldr	r0, [pc, #116]	; (304 <hash_test+0x304>)
 28e:	e76f      	b.n	170 <hash_test+0x170>
        if (exp_ret == 0 && ret < 0)
 290:	2800      	cmp	r0, #0
 292:	da02      	bge.n	29a <hash_test+0x29a>
            return WC_TEST_RET_ENC_I(i);
 294:	4b09      	ldr	r3, [pc, #36]	; (2bc <hash_test+0x2bc>)
 296:	481c      	ldr	r0, [pc, #112]	; (308 <hash_test+0x308>)
 298:	e76a      	b.n	170 <hash_test+0x170>
        ret = wc_HashGetOID(typesGood[i]);
 29a:	4640      	mov	r0, r8
 29c:	f7ff fffe 	bl	0 <wc_HashGetOID>
        if (ret == BAD_FUNC_ARG ||
 2a0:	f110 0fad 	cmn.w	r0, #173	; 0xad
 2a4:	d003      	beq.n	2ae <hash_test+0x2ae>
 2a6:	bb9e      	cbnz	r6, 310 <hash_test+0x310>
                (exp_ret == 0 && ret == HASH_TYPE_E) ||
 2a8:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 2ac:	d133      	bne.n	316 <hash_test+0x316>
            return WC_TEST_RET_ENC_I(i);
 2ae:	4b03      	ldr	r3, [pc, #12]	; (2bc <hash_test+0x2bc>)
 2b0:	4816      	ldr	r0, [pc, #88]	; (30c <hash_test+0x30c>)
 2b2:	e75d      	b.n	170 <hash_test+0x170>
	...
 2bc:	fffe7960 	.word	0xfffe7960
 2c0:	dfffebe9 	.word	0xdfffebe9
 2c4:	dfffebe6 	.word	0xdfffebe6
 2c8:	dfffebe3 	.word	0xdfffebe3
 2cc:	dfffebdd 	.word	0xdfffebdd
 2d0:	dfffebda 	.word	0xdfffebda
 2d4:	dfffebd7 	.word	0xdfffebd7
 2d8:	9fffebd1 	.word	0x9fffebd1
 2dc:	9fffebce 	.word	0x9fffebce
 2e0:	9fffebcb 	.word	0x9fffebcb
 2e4:	9fffebbd 	.word	0x9fffebbd
 2e8:	9fffebba 	.word	0x9fffebba
 2ec:	9fffebb7 	.word	0x9fffebb7
 2f0:	9fffebb2 	.word	0x9fffebb2
 2f4:	9fffebb0 	.word	0x9fffebb0
 2f8:	9fffebab 	.word	0x9fffebab
 2fc:	9fffeba7 	.word	0x9fffeba7
 300:	9fffeba5 	.word	0x9fffeba5
 304:	9fffeba1 	.word	0x9fffeba1
 308:	9fffeb9f 	.word	0x9fffeb9f
 30c:	9fffeb98 	.word	0x9fffeb98
                (exp_ret != 0 && ret != HASH_TYPE_E)) {
 310:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 314:	d1cb      	bne.n	2ae <hash_test+0x2ae>
        hashType = wc_OidGetHash(ret);
 316:	f7ff fffe 	bl	0 <wc_OidGetHash>
        if (exp_ret == 0 && hashType != typesGood[i])
 31a:	b926      	cbnz	r6, 326 <hash_test+0x326>
 31c:	4580      	cmp	r8, r0
 31e:	d002      	beq.n	326 <hash_test+0x326>
            return WC_TEST_RET_ENC_I(i);
 320:	4b78      	ldr	r3, [pc, #480]	; (504 <hash_test+0x504>)
 322:	4879      	ldr	r0, [pc, #484]	; (508 <hash_test+0x508>)
 324:	e724      	b.n	170 <hash_test+0x170>
    for (i = 0, j = 0; i < (int)(sizeof(typesGood)/sizeof(*typesGood)); i++) {
 326:	3401      	adds	r4, #1
 328:	2c0a      	cmp	r4, #10
 32a:	f47f af46 	bne.w	1ba <hash_test+0x1ba>
 32e:	ac04      	add	r4, sp, #16
    for (i = 0; i < (int)(sizeof(typesHashBad)/sizeof(*typesHashBad)); i++) {
 330:	2500      	movs	r5, #0
        ret = wc_Hash(typesHashBad[i], data, sizeof(data), out, sizeof(out));
 332:	2640      	movs	r6, #64	; 0x40
 334:	9600      	str	r6, [sp, #0]
 336:	2228      	movs	r2, #40	; 0x28
 338:	f814 0b01 	ldrb.w	r0, [r4], #1
 33c:	ab14      	add	r3, sp, #80	; 0x50
 33e:	eb0d 0102 	add.w	r1, sp, r2
 342:	f7ff fffe 	bl	0 <wc_Hash>
        if ((ret != BAD_FUNC_ARG) && (ret != BUFFER_E) && (ret != HASH_TYPE_E))
 346:	f110 0fad 	cmn.w	r0, #173	; 0xad
 34a:	d009      	beq.n	360 <hash_test+0x360>
 34c:	f110 0f84 	cmn.w	r0, #132	; 0x84
 350:	d006      	beq.n	360 <hash_test+0x360>
 352:	30e8      	adds	r0, #232	; 0xe8
 354:	d004      	beq.n	360 <hash_test+0x360>
            return WC_TEST_RET_ENC_I(i);
 356:	4b6b      	ldr	r3, [pc, #428]	; (504 <hash_test+0x504>)
 358:	486c      	ldr	r0, [pc, #432]	; (50c <hash_test+0x50c>)
 35a:	fb03 0005 	mla	r0, r3, r5, r0
 35e:	e69b      	b.n	98 <hash_test+0x98>
    for (i = 0; i < (int)(sizeof(typesHashBad)/sizeof(*typesHashBad)); i++) {
 360:	3501      	adds	r5, #1
 362:	2d04      	cmp	r5, #4
 364:	d1e6      	bne.n	334 <hash_test+0x334>
    ret = wc_HashGetOID(WC_HASH_TYPE_MD2);
 366:	2001      	movs	r0, #1
 368:	f7ff fffe 	bl	0 <wc_HashGetOID>
    if (ret != HASH_TYPE_E)
 36c:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 370:	d005      	beq.n	37e <hash_test+0x37e>
        return WC_TEST_RET_ENC_EC(ret);
 372:	4240      	negs	r0, r0
 374:	f3c0 030a 	ubfx	r3, r0, #0, #11
 378:	4a62      	ldr	r2, [pc, #392]	; (504 <hash_test+0x504>)
 37a:	4865      	ldr	r0, [pc, #404]	; (510 <hash_test+0x510>)
 37c:	e68a      	b.n	94 <hash_test+0x94>
    hashType = wc_OidGetHash(646); /* Md2h */
 37e:	f240 2086 	movw	r0, #646	; 0x286
 382:	f7ff fffe 	bl	0 <wc_OidGetHash>
    if (hashType != WC_HASH_TYPE_NONE)
 386:	4604      	mov	r4, r0
 388:	2800      	cmp	r0, #0
 38a:	f040 80b1 	bne.w	4f0 <hash_test+0x4f0>
    ret = wc_HashGetOID(WC_HASH_TYPE_MD5_SHA);
 38e:	2009      	movs	r0, #9
 390:	f7ff fffe 	bl	0 <wc_HashGetOID>
    if (ret != HASH_TYPE_E)
 394:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 398:	d005      	beq.n	3a6 <hash_test+0x3a6>
        return WC_TEST_RET_ENC_EC(ret);
 39a:	4240      	negs	r0, r0
 39c:	f3c0 030a 	ubfx	r3, r0, #0, #11
 3a0:	4a58      	ldr	r2, [pc, #352]	; (504 <hash_test+0x504>)
 3a2:	485c      	ldr	r0, [pc, #368]	; (514 <hash_test+0x514>)
 3a4:	e676      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetOID(WC_HASH_TYPE_MD4);
 3a6:	2002      	movs	r0, #2
 3a8:	f7ff fffe 	bl	0 <wc_HashGetOID>
    if (ret != BAD_FUNC_ARG)
 3ac:	f110 0fad 	cmn.w	r0, #173	; 0xad
 3b0:	d005      	beq.n	3be <hash_test+0x3be>
        return WC_TEST_RET_ENC_EC(ret);
 3b2:	4240      	negs	r0, r0
 3b4:	f3c0 030a 	ubfx	r3, r0, #0, #11
 3b8:	4a52      	ldr	r2, [pc, #328]	; (504 <hash_test+0x504>)
 3ba:	4857      	ldr	r0, [pc, #348]	; (518 <hash_test+0x518>)
 3bc:	e66a      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetOID(WC_HASH_TYPE_NONE);
 3be:	4620      	mov	r0, r4
 3c0:	f7ff fffe 	bl	0 <wc_HashGetOID>
    if (ret != BAD_FUNC_ARG)
 3c4:	f110 0fad 	cmn.w	r0, #173	; 0xad
 3c8:	d005      	beq.n	3d6 <hash_test+0x3d6>
        return WC_TEST_RET_ENC_EC(ret);
 3ca:	4240      	negs	r0, r0
 3cc:	f3c0 030a 	ubfx	r3, r0, #0, #11
 3d0:	4a4c      	ldr	r2, [pc, #304]	; (504 <hash_test+0x504>)
 3d2:	4852      	ldr	r0, [pc, #328]	; (51c <hash_test+0x51c>)
 3d4:	e65e      	b.n	94 <hash_test+0x94>
    hashType = wc_OidGetHash(0);
 3d6:	4620      	mov	r0, r4
 3d8:	f7ff fffe 	bl	0 <wc_OidGetHash>
    if (hashType != WC_HASH_TYPE_NONE)
 3dc:	2800      	cmp	r0, #0
 3de:	f040 8089 	bne.w	4f4 <hash_test+0x4f4>
    ret = wc_HashGetBlockSize(WC_HASH_TYPE_MD2);
 3e2:	2001      	movs	r0, #1
 3e4:	f7ff fffe 	bl	0 <wc_HashGetBlockSize>
    if (ret != HASH_TYPE_E)
 3e8:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 3ec:	d005      	beq.n	3fa <hash_test+0x3fa>
        return WC_TEST_RET_ENC_EC(ret);
 3ee:	4240      	negs	r0, r0
 3f0:	f3c0 030a 	ubfx	r3, r0, #0, #11
 3f4:	4a43      	ldr	r2, [pc, #268]	; (504 <hash_test+0x504>)
 3f6:	484a      	ldr	r0, [pc, #296]	; (520 <hash_test+0x520>)
 3f8:	e64c      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetDigestSize(WC_HASH_TYPE_MD2);
 3fa:	2001      	movs	r0, #1
 3fc:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret != HASH_TYPE_E)
 400:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 404:	d005      	beq.n	412 <hash_test+0x412>
        return WC_TEST_RET_ENC_EC(ret);
 406:	4240      	negs	r0, r0
 408:	f3c0 030a 	ubfx	r3, r0, #0, #11
 40c:	4a3d      	ldr	r2, [pc, #244]	; (504 <hash_test+0x504>)
 40e:	4845      	ldr	r0, [pc, #276]	; (524 <hash_test+0x524>)
 410:	e640      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetBlockSize(WC_HASH_TYPE_MD4);
 412:	2002      	movs	r0, #2
 414:	f7ff fffe 	bl	0 <wc_HashGetBlockSize>
    if (ret != HASH_TYPE_E)
 418:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 41c:	d005      	beq.n	42a <hash_test+0x42a>
        return WC_TEST_RET_ENC_EC(ret);
 41e:	4240      	negs	r0, r0
 420:	f3c0 030a 	ubfx	r3, r0, #0, #11
 424:	4a37      	ldr	r2, [pc, #220]	; (504 <hash_test+0x504>)
 426:	4840      	ldr	r0, [pc, #256]	; (528 <hash_test+0x528>)
 428:	e634      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetDigestSize(WC_HASH_TYPE_MD4);
 42a:	2002      	movs	r0, #2
 42c:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret != HASH_TYPE_E)
 430:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 434:	d005      	beq.n	442 <hash_test+0x442>
        return WC_TEST_RET_ENC_EC(ret);
 436:	4240      	negs	r0, r0
 438:	f3c0 030a 	ubfx	r3, r0, #0, #11
 43c:	4a31      	ldr	r2, [pc, #196]	; (504 <hash_test+0x504>)
 43e:	483b      	ldr	r0, [pc, #236]	; (52c <hash_test+0x52c>)
 440:	e628      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetBlockSize(WC_HASH_TYPE_MD5_SHA);
 442:	2009      	movs	r0, #9
 444:	f7ff fffe 	bl	0 <wc_HashGetBlockSize>
    if (ret != HASH_TYPE_E)
 448:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 44c:	d005      	beq.n	45a <hash_test+0x45a>
        return WC_TEST_RET_ENC_EC(ret);
 44e:	4240      	negs	r0, r0
 450:	f3c0 030a 	ubfx	r3, r0, #0, #11
 454:	4a2b      	ldr	r2, [pc, #172]	; (504 <hash_test+0x504>)
 456:	4836      	ldr	r0, [pc, #216]	; (530 <hash_test+0x530>)
 458:	e61c      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetBlockSize(WC_HASH_TYPE_BLAKE2B);
 45a:	200e      	movs	r0, #14
 45c:	f7ff fffe 	bl	0 <wc_HashGetBlockSize>
    if (ret != HASH_TYPE_E)
 460:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 464:	d005      	beq.n	472 <hash_test+0x472>
        return WC_TEST_RET_ENC_EC(ret);
 466:	4240      	negs	r0, r0
 468:	f3c0 030a 	ubfx	r3, r0, #0, #11
 46c:	4a25      	ldr	r2, [pc, #148]	; (504 <hash_test+0x504>)
 46e:	4831      	ldr	r0, [pc, #196]	; (534 <hash_test+0x534>)
 470:	e610      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetDigestSize(WC_HASH_TYPE_BLAKE2B);
 472:	200e      	movs	r0, #14
 474:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret != HASH_TYPE_E)
 478:	f110 0fe8 	cmn.w	r0, #232	; 0xe8
 47c:	d005      	beq.n	48a <hash_test+0x48a>
        return WC_TEST_RET_ENC_EC(ret);
 47e:	4240      	negs	r0, r0
 480:	f3c0 030a 	ubfx	r3, r0, #0, #11
 484:	4a1f      	ldr	r2, [pc, #124]	; (504 <hash_test+0x504>)
 486:	482c      	ldr	r0, [pc, #176]	; (538 <hash_test+0x538>)
 488:	e604      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetBlockSize(WC_HASH_TYPE_NONE);
 48a:	2000      	movs	r0, #0
 48c:	f7ff fffe 	bl	0 <wc_HashGetBlockSize>
    if (ret != BAD_FUNC_ARG)
 490:	f110 0fad 	cmn.w	r0, #173	; 0xad
 494:	d005      	beq.n	4a2 <hash_test+0x4a2>
        return WC_TEST_RET_ENC_EC(ret);
 496:	4240      	negs	r0, r0
 498:	f3c0 030a 	ubfx	r3, r0, #0, #11
 49c:	4a19      	ldr	r2, [pc, #100]	; (504 <hash_test+0x504>)
 49e:	4827      	ldr	r0, [pc, #156]	; (53c <hash_test+0x53c>)
 4a0:	e5f8      	b.n	94 <hash_test+0x94>
    ret = wc_HashGetDigestSize(WC_HASH_TYPE_NONE);
 4a2:	2000      	movs	r0, #0
 4a4:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret != BAD_FUNC_ARG)
 4a8:	f110 0fad 	cmn.w	r0, #173	; 0xad
 4ac:	d005      	beq.n	4ba <hash_test+0x4ba>
        return WC_TEST_RET_ENC_EC(ret);
 4ae:	4240      	negs	r0, r0
 4b0:	f3c0 030a 	ubfx	r3, r0, #0, #11
 4b4:	4a13      	ldr	r2, [pc, #76]	; (504 <hash_test+0x504>)
 4b6:	4822      	ldr	r0, [pc, #136]	; (540 <hash_test+0x540>)
 4b8:	e5ec      	b.n	94 <hash_test+0x94>
    ret = wc_GetCTC_HashOID(WC_SHA);
 4ba:	2004      	movs	r0, #4
 4bc:	f7ff fffe 	bl	0 <wc_GetCTC_HashOID>
    if (ret == 0)
 4c0:	b1d0      	cbz	r0, 4f8 <hash_test+0x4f8>
    ret = wc_GetCTC_HashOID(WC_SHA256);
 4c2:	2006      	movs	r0, #6
 4c4:	f7ff fffe 	bl	0 <wc_GetCTC_HashOID>
    if (ret == 0)
 4c8:	b1c0      	cbz	r0, 4fc <hash_test+0x4fc>
    ret = wc_GetCTC_HashOID(WC_SHA512);
 4ca:	2008      	movs	r0, #8
 4cc:	f7ff fffe 	bl	0 <wc_GetCTC_HashOID>
    if (ret == 0)
 4d0:	b1b0      	cbz	r0, 500 <hash_test+0x500>
    ret = wc_GetCTC_HashOID(-1);
 4d2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 4d6:	f7ff fffe 	bl	0 <wc_GetCTC_HashOID>
    if (ret != 0)
 4da:	2800      	cmp	r0, #0
 4dc:	f43f addc 	beq.w	98 <hash_test+0x98>
        return WC_TEST_RET_ENC_EC(ret);
 4e0:	4a08      	ldr	r2, [pc, #32]	; (504 <hash_test+0x504>)
 4e2:	4b18      	ldr	r3, [pc, #96]	; (544 <hash_test+0x544>)
 4e4:	4240      	negs	r0, r0
 4e6:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4ea:	fb02 3000 	mla	r0, r2, r0, r3
 4ee:	e5d3      	b.n	98 <hash_test+0x98>
        return WC_TEST_RET_ENC_NC;
 4f0:	4815      	ldr	r0, [pc, #84]	; (548 <hash_test+0x548>)
 4f2:	e5d1      	b.n	98 <hash_test+0x98>
        return WC_TEST_RET_ENC_NC;
 4f4:	4815      	ldr	r0, [pc, #84]	; (54c <hash_test+0x54c>)
 4f6:	e5cf      	b.n	98 <hash_test+0x98>
        return WC_TEST_RET_ENC_EC(ret);
 4f8:	4815      	ldr	r0, [pc, #84]	; (550 <hash_test+0x550>)
 4fa:	e5cd      	b.n	98 <hash_test+0x98>
        return WC_TEST_RET_ENC_EC(ret);
 4fc:	4815      	ldr	r0, [pc, #84]	; (554 <hash_test+0x554>)
 4fe:	e5cb      	b.n	98 <hash_test+0x98>
        return WC_TEST_RET_ENC_EC(ret);
 500:	4815      	ldr	r0, [pc, #84]	; (558 <hash_test+0x558>)
 502:	e5c9      	b.n	98 <hash_test+0x98>
 504:	fffe7960 	.word	0xfffe7960
 508:	9fffeb93 	.word	0x9fffeb93
 50c:	9fffeb8c 	.word	0x9fffeb8c
 510:	dfffeb82 	.word	0xdfffeb82
 514:	dfffeb71 	.word	0xdfffeb71
 518:	dfffeb6d 	.word	0xdfffeb6d
 51c:	dfffeb6a 	.word	0xdfffeb6a
 520:	dfffeb5d 	.word	0xdfffeb5d
 524:	dfffeb55 	.word	0xdfffeb55
 528:	dfffeb4c 	.word	0xdfffeb4c
 52c:	dfffeb44 	.word	0xdfffeb44
 530:	dfffeb3c 	.word	0xdfffeb3c
 534:	dfffeb33 	.word	0xdfffeb33
 538:	dfffeb2b 	.word	0xdfffeb2b
 53c:	dfffeb26 	.word	0xdfffeb26
 540:	dfffeb23 	.word	0xdfffeb23
 544:	dfffeafb 	.word	0xdfffeafb
 548:	ffffeb7a 	.word	0xffffeb7a
 54c:	ffffeb66 	.word	0xffffeb66
 550:	dfffeb13 	.word	0xdfffeb13
 554:	dfffeb09 	.word	0xdfffeb09
 558:	dfffeaff 	.word	0xdfffeaff

Disassembly of section .text.hmac_sha_test:

00000000 <hmac_sha_test>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    const char* keys[]=
   4:	4c42      	ldr	r4, [pc, #264]	; (110 <hmac_sha_test+0x110>)
    a.inLen  = XSTRLEN(a.input);
   6:	f8df a10c 	ldr.w	sl, [pc, #268]	; 114 <hmac_sha_test+0x114>
    b.inLen  = XSTRLEN(b.input);
   a:	f8df 910c 	ldr.w	r9, [pc, #268]	; 118 <hmac_sha_test+0x118>
    c.inLen  = XSTRLEN(c.input);
   e:	f8df 810c 	ldr.w	r8, [pc, #268]	; 11c <hmac_sha_test+0x11c>
    const char* keys[]=
  12:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
{
  16:	f5ad 7d1e 	sub.w	sp, sp, #632	; 0x278
    const char* keys[]=
  1a:	466f      	mov	r7, sp
  1c:	e887 0007 	stmia.w	r7, {r0, r1, r2}
    a.inLen  = XSTRLEN(a.input);
  20:	4650      	mov	r0, sl
  22:	f7ff fffe 	bl	0 <strlen>
  26:	4606      	mov	r6, r0
    b.inLen  = XSTRLEN(b.input);
  28:	4648      	mov	r0, r9
  2a:	f7ff fffe 	bl	0 <strlen>
  2e:	4605      	mov	r5, r0
    c.inLen  = XSTRLEN(c.input);
  30:	4640      	mov	r0, r8
  32:	f7ff fffe 	bl	0 <strlen>
    test_hmac[1] = b;
  36:	4b3a      	ldr	r3, [pc, #232]	; (120 <hmac_sha_test+0x120>)
    test_hmac[0] = a;
  38:	f8cd a020 	str.w	sl, [sp, #32]
    test_hmac[1] = b;
  3c:	e9cd 350d 	strd	r3, r5, [sp, #52]	; 0x34
    test_hmac[2] = c;
  40:	4b38      	ldr	r3, [pc, #224]	; (124 <hmac_sha_test+0x124>)
    test_hmac[1] = b;
  42:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
    test_hmac[2] = c;
  46:	e9cd 3011 	strd	r3, r0, [sp, #68]	; 0x44
    test_hmac[0] = a;
  4a:	340c      	adds	r4, #12
  4c:	e9cd 4609 	strd	r4, r6, [sp, #36]	; 0x24
    test_hmac[2] = c;
  50:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
  54:	ad08      	add	r5, sp, #32
    for (i = 0; i < times; ++i) {
  56:	2600      	movs	r6, #0
        if ((ret = wc_HmacInit(&hmac, HEAP_HINT, devId)) != 0)
  58:	f06f 0201 	mvn.w	r2, #1
  5c:	2100      	movs	r1, #0
  5e:	a814      	add	r0, sp, #80	; 0x50
  60:	f7ff fffe 	bl	0 <wc_HmacInit>
  64:	b138      	cbz	r0, 76 <hmac_sha_test+0x76>
            return WC_TEST_RET_ENC_EC(ret);
  66:	4240      	negs	r0, r0
  68:	4b2f      	ldr	r3, [pc, #188]	; (128 <hmac_sha_test+0x128>)
  6a:	4c30      	ldr	r4, [pc, #192]	; (12c <hmac_sha_test+0x12c>)
  6c:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  70:	fb03 4400 	mla	r4, r3, r0, r4
  74:	e033      	b.n	de <hmac_sha_test+0xde>
        ret = wc_HmacSetKey(&hmac, WC_SHA, (byte*)keys[i],
  76:	f857 4b04 	ldr.w	r4, [r7], #4
            (word32)XSTRLEN(keys[i]));
  7a:	4620      	mov	r0, r4
  7c:	f7ff fffe 	bl	0 <strlen>
        ret = wc_HmacSetKey(&hmac, WC_SHA, (byte*)keys[i],
  80:	4622      	mov	r2, r4
            (word32)XSTRLEN(keys[i]));
  82:	4603      	mov	r3, r0
        ret = wc_HmacSetKey(&hmac, WC_SHA, (byte*)keys[i],
  84:	2104      	movs	r1, #4
  86:	a814      	add	r0, sp, #80	; 0x50
  88:	f7ff fffe 	bl	0 <wc_HmacSetKey>
        if (ret != 0)
  8c:	b128      	cbz	r0, 9a <hmac_sha_test+0x9a>
            return WC_TEST_RET_ENC_EC(ret);
  8e:	4240      	negs	r0, r0
  90:	4b25      	ldr	r3, [pc, #148]	; (128 <hmac_sha_test+0x128>)
  92:	4c27      	ldr	r4, [pc, #156]	; (130 <hmac_sha_test+0x130>)
  94:	f3c0 000a 	ubfx	r0, r0, #0, #11
  98:	e7ea      	b.n	70 <hmac_sha_test+0x70>
        ret = wc_HmacUpdate(&hmac, (byte*)test_hmac[i].input,
  9a:	68aa      	ldr	r2, [r5, #8]
  9c:	6829      	ldr	r1, [r5, #0]
  9e:	a814      	add	r0, sp, #80	; 0x50
  a0:	f7ff fffe 	bl	0 <wc_HmacUpdate>
        if (ret != 0)
  a4:	b128      	cbz	r0, b2 <hmac_sha_test+0xb2>
            return WC_TEST_RET_ENC_EC(ret);
  a6:	4240      	negs	r0, r0
  a8:	4b1f      	ldr	r3, [pc, #124]	; (128 <hmac_sha_test+0x128>)
  aa:	4c22      	ldr	r4, [pc, #136]	; (134 <hmac_sha_test+0x134>)
  ac:	f3c0 000a 	ubfx	r0, r0, #0, #11
  b0:	e7de      	b.n	70 <hmac_sha_test+0x70>
        ret = wc_HmacFinal(&hmac, hash);
  b2:	a903      	add	r1, sp, #12
  b4:	a814      	add	r0, sp, #80	; 0x50
  b6:	f7ff fffe 	bl	0 <wc_HmacFinal>
        if (ret != 0)
  ba:	b128      	cbz	r0, c8 <hmac_sha_test+0xc8>
            return WC_TEST_RET_ENC_EC(ret);
  bc:	4240      	negs	r0, r0
  be:	4b1a      	ldr	r3, [pc, #104]	; (128 <hmac_sha_test+0x128>)
  c0:	4c1d      	ldr	r4, [pc, #116]	; (138 <hmac_sha_test+0x138>)
  c2:	f3c0 000a 	ubfx	r0, r0, #0, #11
  c6:	e7d3      	b.n	70 <hmac_sha_test+0x70>
        if (XMEMCMP(hash, test_hmac[i].output, WC_SHA_DIGEST_SIZE) != 0)
  c8:	6869      	ldr	r1, [r5, #4]
  ca:	2214      	movs	r2, #20
  cc:	a803      	add	r0, sp, #12
  ce:	f7ff fffe 	bl	0 <memcmp>
  d2:	4604      	mov	r4, r0
  d4:	b140      	cbz	r0, e8 <hmac_sha_test+0xe8>
            return WC_TEST_RET_ENC_I(i);
  d6:	4814      	ldr	r0, [pc, #80]	; (128 <hmac_sha_test+0x128>)
  d8:	4c18      	ldr	r4, [pc, #96]	; (13c <hmac_sha_test+0x13c>)
  da:	fb00 4406 	mla	r4, r0, r6, r4
}
  de:	4620      	mov	r0, r4
  e0:	f50d 7d1e 	add.w	sp, sp, #632	; 0x278
  e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        wc_HmacFree(&hmac);
  e8:	a814      	add	r0, sp, #80	; 0x50
    for (i = 0; i < times; ++i) {
  ea:	3601      	adds	r6, #1
        wc_HmacFree(&hmac);
  ec:	f7ff fffe 	bl	0 <wc_HmacFree>
    for (i = 0; i < times; ++i) {
  f0:	2e03      	cmp	r6, #3
  f2:	f105 0510 	add.w	r5, r5, #16
  f6:	d1af      	bne.n	58 <hmac_sha_test+0x58>
    if ((ret = wc_HmacSizeByType(WC_SHA)) != WC_SHA_DIGEST_SIZE)
  f8:	2004      	movs	r0, #4
  fa:	f7ff fffe 	bl	0 <wc_HmacSizeByType>
  fe:	2814      	cmp	r0, #20
 100:	d0ed      	beq.n	de <hmac_sha_test+0xde>
        return WC_TEST_RET_ENC_EC(ret);
 102:	4240      	negs	r0, r0
 104:	4b08      	ldr	r3, [pc, #32]	; (128 <hmac_sha_test+0x128>)
 106:	4c0e      	ldr	r4, [pc, #56]	; (140 <hmac_sha_test+0x140>)
 108:	f3c0 000a 	ubfx	r0, r0, #0, #11
 10c:	e7b0      	b.n	70 <hmac_sha_test+0x70>
 10e:	bf00      	nop
 110:	000000c4 	.word	0x000000c4
 114:	00000000 	.word	0x00000000
 118:	00000009 	.word	0x00000009
 11c:	00000026 	.word	0x00000026
 120:	00000059 	.word	0x00000059
 124:	0000006e 	.word	0x0000006e
 128:	fffe7960 	.word	0xfffe7960
 12c:	dfffea6b 	.word	0xdfffea6b
 130:	dfffea66 	.word	0xdfffea66
 134:	dfffea62 	.word	0xdfffea62
 138:	dfffea5f 	.word	0xdfffea5f
 13c:	9fffea5c 	.word	0x9fffea5c
 140:	dfffea55 	.word	0xdfffea55

Disassembly of section .text.hmac_sha256_test:

00000000 <hmac_sha256_test>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    const char* keys[]=
   4:	4d4a      	ldr	r5, [pc, #296]	; (130 <hmac_sha256_test+0x130>)
    a.inLen  = XSTRLEN(a.input);
   6:	f8df a12c 	ldr.w	sl, [pc, #300]	; 134 <hmac_sha256_test+0x134>
    b.inLen  = XSTRLEN(b.input);
   a:	f8df 912c 	ldr.w	r9, [pc, #300]	; 138 <hmac_sha256_test+0x138>
    c.inLen  = XSTRLEN(c.input);
   e:	f8df 812c 	ldr.w	r8, [pc, #300]	; 13c <hmac_sha256_test+0x13c>
    const char* keys[]=
  12:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
{
  16:	f5ad 7d26 	sub.w	sp, sp, #664	; 0x298
    const char* keys[]=
  1a:	466c      	mov	r4, sp
  1c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    a.inLen  = XSTRLEN(a.input);
  20:	4650      	mov	r0, sl
  22:	f7ff fffe 	bl	0 <strlen>
  26:	4607      	mov	r7, r0
    b.inLen  = XSTRLEN(b.input);
  28:	4648      	mov	r0, r9
  2a:	f7ff fffe 	bl	0 <strlen>
  2e:	4606      	mov	r6, r0
    c.inLen  = XSTRLEN(c.input);
  30:	4640      	mov	r0, r8
  32:	f7ff fffe 	bl	0 <strlen>
    test_hmac[0] = a;
  36:	f105 0310 	add.w	r3, r5, #16
  3a:	e9cd 370d 	strd	r3, r7, [sp, #52]	; 0x34
    test_hmac[2] = c;
  3e:	4b40      	ldr	r3, [pc, #256]	; (140 <hmac_sha256_test+0x140>)
    test_hmac[0] = a;
  40:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
    test_hmac[1] = b;
  44:	3531      	adds	r5, #49	; 0x31
    test_hmac[2] = c;
  46:	e9cd 3015 	strd	r3, r0, [sp, #84]	; 0x54
    test_hmac[3] = d;
  4a:	4b3e      	ldr	r3, [pc, #248]	; (144 <hmac_sha256_test+0x144>)
    test_hmac[1] = b;
  4c:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
  50:	e9cd 5611 	strd	r5, r6, [sp, #68]	; 0x44
    test_hmac[3] = d;
  54:	2500      	movs	r5, #0
  56:	e9cd 3519 	strd	r3, r5, [sp, #100]	; 0x64
    test_hmac[2] = c;
  5a:	f8cd 8050 	str.w	r8, [sp, #80]	; 0x50
    test_hmac[3] = d;
  5e:	9518      	str	r5, [sp, #96]	; 0x60
  60:	ae0c      	add	r6, sp, #48	; 0x30
  62:	4627      	mov	r7, r4
        if (wc_HmacInit(&hmac, HEAP_HINT, devId) != 0)
  64:	f06f 0201 	mvn.w	r2, #1
  68:	2100      	movs	r1, #0
  6a:	a81c      	add	r0, sp, #112	; 0x70
  6c:	f7ff fffe 	bl	0 <wc_HmacInit>
  70:	b140      	cbz	r0, 84 <hmac_sha256_test+0x84>
            return WC_TEST_RET_ENC_I(i);
  72:	4835      	ldr	r0, [pc, #212]	; (148 <hmac_sha256_test+0x148>)
  74:	4c35      	ldr	r4, [pc, #212]	; (14c <hmac_sha256_test+0x14c>)
            return WC_TEST_RET_ENC_I(i);
  76:	fb00 4405 	mla	r4, r0, r5, r4
}
  7a:	4620      	mov	r0, r4
  7c:	f50d 7d26 	add.w	sp, sp, #664	; 0x298
  80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ret = wc_HmacSetKey(&hmac, WC_SHA256, (byte*)keys[i],
  84:	f857 4b04 	ldr.w	r4, [r7], #4
            (word32)XSTRLEN(keys[i]));
  88:	4620      	mov	r0, r4
  8a:	f7ff fffe 	bl	0 <strlen>
        ret = wc_HmacSetKey(&hmac, WC_SHA256, (byte*)keys[i],
  8e:	4622      	mov	r2, r4
            (word32)XSTRLEN(keys[i]));
  90:	4603      	mov	r3, r0
        ret = wc_HmacSetKey(&hmac, WC_SHA256, (byte*)keys[i],
  92:	2106      	movs	r1, #6
  94:	a81c      	add	r0, sp, #112	; 0x70
  96:	f7ff fffe 	bl	0 <wc_HmacSetKey>
        if (ret != 0)
  9a:	b110      	cbz	r0, a2 <hmac_sha256_test+0xa2>
            return WC_TEST_RET_ENC_I(i);
  9c:	482a      	ldr	r0, [pc, #168]	; (148 <hmac_sha256_test+0x148>)
  9e:	4c2c      	ldr	r4, [pc, #176]	; (150 <hmac_sha256_test+0x150>)
  a0:	e7e9      	b.n	76 <hmac_sha256_test+0x76>
        if (test_hmac[i].input != NULL) {
  a2:	6831      	ldr	r1, [r6, #0]
  a4:	b139      	cbz	r1, b6 <hmac_sha256_test+0xb6>
            ret = wc_HmacUpdate(&hmac, (byte*)test_hmac[i].input,
  a6:	68b2      	ldr	r2, [r6, #8]
  a8:	a81c      	add	r0, sp, #112	; 0x70
  aa:	f7ff fffe 	bl	0 <wc_HmacUpdate>
            if (ret != 0)
  ae:	b110      	cbz	r0, b6 <hmac_sha256_test+0xb6>
                return WC_TEST_RET_ENC_I(i);
  b0:	4825      	ldr	r0, [pc, #148]	; (148 <hmac_sha256_test+0x148>)
  b2:	4c28      	ldr	r4, [pc, #160]	; (154 <hmac_sha256_test+0x154>)
  b4:	e7df      	b.n	76 <hmac_sha256_test+0x76>
        ret = wc_HmacFinal(&hmac, hash);
  b6:	a904      	add	r1, sp, #16
  b8:	a81c      	add	r0, sp, #112	; 0x70
  ba:	f7ff fffe 	bl	0 <wc_HmacFinal>
        if (ret != 0)
  be:	b110      	cbz	r0, c6 <hmac_sha256_test+0xc6>
            return WC_TEST_RET_ENC_I(i);
  c0:	4821      	ldr	r0, [pc, #132]	; (148 <hmac_sha256_test+0x148>)
  c2:	4c25      	ldr	r4, [pc, #148]	; (158 <hmac_sha256_test+0x158>)
  c4:	e7d7      	b.n	76 <hmac_sha256_test+0x76>
        if (XMEMCMP(hash, test_hmac[i].output, WC_SHA256_DIGEST_SIZE) != 0)
  c6:	6871      	ldr	r1, [r6, #4]
  c8:	2220      	movs	r2, #32
  ca:	a804      	add	r0, sp, #16
  cc:	f7ff fffe 	bl	0 <memcmp>
  d0:	4604      	mov	r4, r0
  d2:	b110      	cbz	r0, da <hmac_sha256_test+0xda>
            return WC_TEST_RET_ENC_I(i);
  d4:	481c      	ldr	r0, [pc, #112]	; (148 <hmac_sha256_test+0x148>)
  d6:	4c21      	ldr	r4, [pc, #132]	; (15c <hmac_sha256_test+0x15c>)
  d8:	e7cd      	b.n	76 <hmac_sha256_test+0x76>
        wc_HmacFree(&hmac);
  da:	a81c      	add	r0, sp, #112	; 0x70
    for (i = 0; i < times; ++i) {
  dc:	3501      	adds	r5, #1
        wc_HmacFree(&hmac);
  de:	f7ff fffe 	bl	0 <wc_HmacFree>
    for (i = 0; i < times; ++i) {
  e2:	2d04      	cmp	r5, #4
  e4:	f106 0610 	add.w	r6, r6, #16
  e8:	d1bc      	bne.n	64 <hmac_sha256_test+0x64>
    if ((ret = wc_HmacSizeByType(WC_SHA256)) != WC_SHA256_DIGEST_SIZE)
  ea:	2006      	movs	r0, #6
  ec:	f7ff fffe 	bl	0 <wc_HmacSizeByType>
  f0:	2820      	cmp	r0, #32
  f2:	d007      	beq.n	104 <hmac_sha256_test+0x104>
        return WC_TEST_RET_ENC_EC(ret);
  f4:	4240      	negs	r0, r0
  f6:	4b14      	ldr	r3, [pc, #80]	; (148 <hmac_sha256_test+0x148>)
  f8:	4c19      	ldr	r4, [pc, #100]	; (160 <hmac_sha256_test+0x160>)
  fa:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  fe:	fb03 4400 	mla	r4, r3, r0, r4
 102:	e7ba      	b.n	7a <hmac_sha256_test+0x7a>
    if ((ret = wc_HmacSizeByType(21)) != BAD_FUNC_ARG)
 104:	2015      	movs	r0, #21
 106:	f7ff fffe 	bl	0 <wc_HmacSizeByType>
 10a:	f110 0fad 	cmn.w	r0, #173	; 0xad
 10e:	d005      	beq.n	11c <hmac_sha256_test+0x11c>
        return WC_TEST_RET_ENC_EC(ret);
 110:	4240      	negs	r0, r0
 112:	4b0d      	ldr	r3, [pc, #52]	; (148 <hmac_sha256_test+0x148>)
 114:	4c13      	ldr	r4, [pc, #76]	; (164 <hmac_sha256_test+0x164>)
 116:	f3c0 000a 	ubfx	r0, r0, #0, #11
 11a:	e7f0      	b.n	fe <hmac_sha256_test+0xfe>
    if ((ret = wolfSSL_GetHmacMaxSize()) != WC_MAX_DIGEST_SIZE)
 11c:	f7ff fffe 	bl	0 <wolfSSL_GetHmacMaxSize>
 120:	2840      	cmp	r0, #64	; 0x40
 122:	d0aa      	beq.n	7a <hmac_sha256_test+0x7a>
        return WC_TEST_RET_ENC_EC(ret);
 124:	4240      	negs	r0, r0
 126:	4b08      	ldr	r3, [pc, #32]	; (148 <hmac_sha256_test+0x148>)
 128:	4c0f      	ldr	r4, [pc, #60]	; (168 <hmac_sha256_test+0x168>)
 12a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 12e:	e7e6      	b.n	fe <hmac_sha256_test+0xfe>
 130:	000000e8 	.word	0x000000e8
 134:	00000000 	.word	0x00000000
 138:	00000009 	.word	0x00000009
 13c:	00000026 	.word	0x00000026
 140:	00000000 	.word	0x00000000
 144:	00000021 	.word	0x00000021
 148:	fffe7960 	.word	0xfffe7960
 14c:	9fffe9a8 	.word	0x9fffe9a8
 150:	9fffe9a3 	.word	0x9fffe9a3
 154:	9fffe99e 	.word	0x9fffe99e
 158:	9fffe99a 	.word	0x9fffe99a
 15c:	9fffe997 	.word	0x9fffe997
 160:	dfffe990 	.word	0xdfffe990
 164:	dfffe98e 	.word	0xdfffe98e
 168:	dfffe98b 	.word	0xdfffe98b

Disassembly of section .text.hmac_sha512_test:

00000000 <hmac_sha512_test>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    const char* keys[]=
   4:	4b47      	ldr	r3, [pc, #284]	; (124 <hmac_sha512_test+0x124>)
    a.inLen  = XSTRLEN(a.input);
   6:	f8df b120 	ldr.w	fp, [pc, #288]	; 128 <hmac_sha512_test+0x128>
    b.inLen  = XSTRLEN(b.input);
   a:	f8df a120 	ldr.w	sl, [pc, #288]	; 12c <hmac_sha512_test+0x12c>
    c.inLen  = XSTRLEN(c.input);
   e:	f8df 9120 	ldr.w	r9, [pc, #288]	; 130 <hmac_sha512_test+0x130>
    d.inLen  = XSTRLEN(d.input);
  12:	f8df 8120 	ldr.w	r8, [pc, #288]	; 134 <hmac_sha512_test+0x134>
    const char* keys[]=
  16:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
{
  18:	f5ad 7d2f 	sub.w	sp, sp, #700	; 0x2bc
    const char* keys[]=
  1c:	466e      	mov	r6, sp
  1e:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    a.inLen  = XSTRLEN(a.input);
  22:	4658      	mov	r0, fp
  24:	f7ff fffe 	bl	0 <strlen>
  28:	4607      	mov	r7, r0
    b.inLen  = XSTRLEN(b.input);
  2a:	4650      	mov	r0, sl
  2c:	f7ff fffe 	bl	0 <strlen>
  30:	4605      	mov	r5, r0
    c.inLen  = XSTRLEN(c.input);
  32:	4648      	mov	r0, r9
  34:	f7ff fffe 	bl	0 <strlen>
  38:	4604      	mov	r4, r0
    d.inLen  = XSTRLEN(d.input);
  3a:	4640      	mov	r0, r8
  3c:	f7ff fffe 	bl	0 <strlen>
    test_hmac[0] = a;
  40:	4b3d      	ldr	r3, [pc, #244]	; (138 <hmac_sha512_test+0x138>)
  42:	f8cd b050 	str.w	fp, [sp, #80]	; 0x50
  46:	e9cd 3715 	strd	r3, r7, [sp, #84]	; 0x54
    test_hmac[1] = b;
  4a:	4b3c      	ldr	r3, [pc, #240]	; (13c <hmac_sha512_test+0x13c>)
  4c:	f8cd a060 	str.w	sl, [sp, #96]	; 0x60
  50:	e9cd 3519 	strd	r3, r5, [sp, #100]	; 0x64
    test_hmac[2] = c;
  54:	4b3a      	ldr	r3, [pc, #232]	; (140 <hmac_sha512_test+0x140>)
  56:	f8cd 9070 	str.w	r9, [sp, #112]	; 0x70
  5a:	e9cd 341d 	strd	r3, r4, [sp, #116]	; 0x74
    test_hmac[3] = d;
  5e:	4b39      	ldr	r3, [pc, #228]	; (144 <hmac_sha512_test+0x144>)
  60:	f8cd 8080 	str.w	r8, [sp, #128]	; 0x80
  64:	e9cd 3021 	strd	r3, r0, [sp, #132]	; 0x84
    for (i = 0; i < times; ++i) {
  68:	ad14      	add	r5, sp, #80	; 0x50
  6a:	2700      	movs	r7, #0
        if ((ret = wc_HmacInit(&hmac, HEAP_HINT, devId)) != 0)
  6c:	f06f 0201 	mvn.w	r2, #1
  70:	2100      	movs	r1, #0
  72:	a824      	add	r0, sp, #144	; 0x90
  74:	f7ff fffe 	bl	0 <wc_HmacInit>
  78:	b138      	cbz	r0, 8a <hmac_sha512_test+0x8a>
            return WC_TEST_RET_ENC_EC(ret);
  7a:	4240      	negs	r0, r0
  7c:	4b32      	ldr	r3, [pc, #200]	; (148 <hmac_sha512_test+0x148>)
  7e:	4c33      	ldr	r4, [pc, #204]	; (14c <hmac_sha512_test+0x14c>)
  80:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  84:	fb03 4400 	mla	r4, r3, r0, r4
  88:	e033      	b.n	f2 <hmac_sha512_test+0xf2>
        ret = wc_HmacSetKey(&hmac, WC_SHA512, (byte*)keys[i],
  8a:	f856 4b04 	ldr.w	r4, [r6], #4
            (word32)XSTRLEN(keys[i]));
  8e:	4620      	mov	r0, r4
  90:	f7ff fffe 	bl	0 <strlen>
        ret = wc_HmacSetKey(&hmac, WC_SHA512, (byte*)keys[i],
  94:	4622      	mov	r2, r4
            (word32)XSTRLEN(keys[i]));
  96:	4603      	mov	r3, r0
        ret = wc_HmacSetKey(&hmac, WC_SHA512, (byte*)keys[i],
  98:	2108      	movs	r1, #8
  9a:	a824      	add	r0, sp, #144	; 0x90
  9c:	f7ff fffe 	bl	0 <wc_HmacSetKey>
        if (ret != 0)
  a0:	b128      	cbz	r0, ae <hmac_sha512_test+0xae>
            return WC_TEST_RET_ENC_EC(ret);
  a2:	4240      	negs	r0, r0
  a4:	4b28      	ldr	r3, [pc, #160]	; (148 <hmac_sha512_test+0x148>)
  a6:	4c2a      	ldr	r4, [pc, #168]	; (150 <hmac_sha512_test+0x150>)
  a8:	f3c0 000a 	ubfx	r0, r0, #0, #11
  ac:	e7ea      	b.n	84 <hmac_sha512_test+0x84>
        ret = wc_HmacUpdate(&hmac, (byte*)test_hmac[i].input,
  ae:	68aa      	ldr	r2, [r5, #8]
  b0:	6829      	ldr	r1, [r5, #0]
  b2:	a824      	add	r0, sp, #144	; 0x90
  b4:	f7ff fffe 	bl	0 <wc_HmacUpdate>
        if (ret != 0)
  b8:	b128      	cbz	r0, c6 <hmac_sha512_test+0xc6>
            return WC_TEST_RET_ENC_EC(ret);
  ba:	4240      	negs	r0, r0
  bc:	4b22      	ldr	r3, [pc, #136]	; (148 <hmac_sha512_test+0x148>)
  be:	4c25      	ldr	r4, [pc, #148]	; (154 <hmac_sha512_test+0x154>)
  c0:	f3c0 000a 	ubfx	r0, r0, #0, #11
  c4:	e7de      	b.n	84 <hmac_sha512_test+0x84>
        ret = wc_HmacFinal(&hmac, hash);
  c6:	a904      	add	r1, sp, #16
  c8:	a824      	add	r0, sp, #144	; 0x90
  ca:	f7ff fffe 	bl	0 <wc_HmacFinal>
        if (ret != 0)
  ce:	b128      	cbz	r0, dc <hmac_sha512_test+0xdc>
            return WC_TEST_RET_ENC_EC(ret);
  d0:	4240      	negs	r0, r0
  d2:	4b1d      	ldr	r3, [pc, #116]	; (148 <hmac_sha512_test+0x148>)
  d4:	4c20      	ldr	r4, [pc, #128]	; (158 <hmac_sha512_test+0x158>)
  d6:	f3c0 000a 	ubfx	r0, r0, #0, #11
  da:	e7d3      	b.n	84 <hmac_sha512_test+0x84>
        if (XMEMCMP(hash, test_hmac[i].output, WC_SHA512_DIGEST_SIZE) != 0)
  dc:	6869      	ldr	r1, [r5, #4]
  de:	2240      	movs	r2, #64	; 0x40
  e0:	a804      	add	r0, sp, #16
  e2:	f7ff fffe 	bl	0 <memcmp>
  e6:	4604      	mov	r4, r0
  e8:	b140      	cbz	r0, fc <hmac_sha512_test+0xfc>
            return WC_TEST_RET_ENC_I(i);
  ea:	4817      	ldr	r0, [pc, #92]	; (148 <hmac_sha512_test+0x148>)
  ec:	4c1b      	ldr	r4, [pc, #108]	; (15c <hmac_sha512_test+0x15c>)
  ee:	fb00 4407 	mla	r4, r0, r7, r4
}
  f2:	4620      	mov	r0, r4
  f4:	f50d 7d2f 	add.w	sp, sp, #700	; 0x2bc
  f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        wc_HmacFree(&hmac);
  fc:	a824      	add	r0, sp, #144	; 0x90
    for (i = 0; i < times; ++i) {
  fe:	3701      	adds	r7, #1
        wc_HmacFree(&hmac);
 100:	f7ff fffe 	bl	0 <wc_HmacFree>
    for (i = 0; i < times; ++i) {
 104:	2f04      	cmp	r7, #4
 106:	f105 0510 	add.w	r5, r5, #16
 10a:	d1af      	bne.n	6c <hmac_sha512_test+0x6c>
    if ((ret = wc_HmacSizeByType(WC_SHA512)) != WC_SHA512_DIGEST_SIZE)
 10c:	2008      	movs	r0, #8
 10e:	f7ff fffe 	bl	0 <wc_HmacSizeByType>
 112:	2840      	cmp	r0, #64	; 0x40
 114:	d0ed      	beq.n	f2 <hmac_sha512_test+0xf2>
        return WC_TEST_RET_ENC_EC(ret);
 116:	4240      	negs	r0, r0
 118:	4b0b      	ldr	r3, [pc, #44]	; (148 <hmac_sha512_test+0x148>)
 11a:	4c11      	ldr	r4, [pc, #68]	; (160 <hmac_sha512_test+0x160>)
 11c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 120:	e7b0      	b.n	84 <hmac_sha512_test+0x84>
 122:	bf00      	nop
 124:	0000013c 	.word	0x0000013c
 128:	00000000 	.word	0x00000000
 12c:	00000009 	.word	0x00000009
 130:	00000026 	.word	0x00000026
 134:	00000000 	.word	0x00000000
 138:	0000000e 	.word	0x0000000e
 13c:	0000004f 	.word	0x0000004f
 140:	00000090 	.word	0x00000090
 144:	000000d1 	.word	0x000000d1
 148:	fffe7960 	.word	0xfffe7960
 14c:	dfffe8c8 	.word	0xdfffe8c8
 150:	dfffe8c3 	.word	0xdfffe8c3
 154:	dfffe8bf 	.word	0xdfffe8bf
 158:	dfffe8bc 	.word	0xdfffe8bc
 15c:	9fffe8b9 	.word	0x9fffe8b9
 160:	dfffe8b2 	.word	0xdfffe8b2

Disassembly of section .text.des_test:

00000000 <des_test>:
{
   0:	b510      	push	{r4, lr}
    ret = wc_Des_SetKey(&enc, key, iv, DES_ENCRYPTION);
   2:	4c2d      	ldr	r4, [pc, #180]	; (b8 <des_test+0xb8>)
   4:	492d      	ldr	r1, [pc, #180]	; (bc <des_test+0xbc>)
{
   6:	b0d6      	sub	sp, #344	; 0x158
    ret = wc_Des_SetKey(&enc, key, iv, DES_ENCRYPTION);
   8:	2300      	movs	r3, #0
   a:	4622      	mov	r2, r4
   c:	a80e      	add	r0, sp, #56	; 0x38
   e:	f7ff fffe 	bl	0 <wc_Des_SetKey>
    if (ret != 0)
  12:	b140      	cbz	r0, 26 <des_test+0x26>
        return WC_TEST_RET_ENC_EC(ret);
  14:	4240      	negs	r0, r0
  16:	f3c0 030a 	ubfx	r3, r0, #0, #11
  1a:	4a29      	ldr	r2, [pc, #164]	; (c0 <des_test+0xc0>)
  1c:	4829      	ldr	r0, [pc, #164]	; (c4 <des_test+0xc4>)
        return WC_TEST_RET_ENC_EC(ret);
  1e:	fb02 0003 	mla	r0, r2, r3, r0
}
  22:	b056      	add	sp, #344	; 0x158
  24:	bd10      	pop	{r4, pc}
    ret = wc_Des_CbcEncrypt(&enc, cipher, vector, sizeof(vector));
  26:	4a28      	ldr	r2, [pc, #160]	; (c8 <des_test+0xc8>)
  28:	2318      	movs	r3, #24
  2a:	a908      	add	r1, sp, #32
  2c:	a80e      	add	r0, sp, #56	; 0x38
  2e:	f7ff fffe 	bl	0 <wc_Des_CbcEncrypt>
    if (ret != 0)
  32:	b128      	cbz	r0, 40 <des_test+0x40>
        return WC_TEST_RET_ENC_EC(ret);
  34:	4240      	negs	r0, r0
  36:	f3c0 030a 	ubfx	r3, r0, #0, #11
  3a:	4a21      	ldr	r2, [pc, #132]	; (c0 <des_test+0xc0>)
  3c:	4823      	ldr	r0, [pc, #140]	; (cc <des_test+0xcc>)
  3e:	e7ee      	b.n	1e <des_test+0x1e>
    ret = wc_Des_SetKey(&dec, key, iv, DES_DECRYPTION);
  40:	491e      	ldr	r1, [pc, #120]	; (bc <des_test+0xbc>)
  42:	2301      	movs	r3, #1
  44:	4622      	mov	r2, r4
  46:	a832      	add	r0, sp, #200	; 0xc8
  48:	f7ff fffe 	bl	0 <wc_Des_SetKey>
    if (ret != 0)
  4c:	b128      	cbz	r0, 5a <des_test+0x5a>
        return WC_TEST_RET_ENC_EC(ret);
  4e:	4240      	negs	r0, r0
  50:	f3c0 030a 	ubfx	r3, r0, #0, #11
  54:	4a1a      	ldr	r2, [pc, #104]	; (c0 <des_test+0xc0>)
  56:	481e      	ldr	r0, [pc, #120]	; (d0 <des_test+0xd0>)
  58:	e7e1      	b.n	1e <des_test+0x1e>
    ret = wc_Des_CbcDecrypt(&dec, plain, cipher, sizeof(cipher));
  5a:	2318      	movs	r3, #24
  5c:	aa08      	add	r2, sp, #32
  5e:	a902      	add	r1, sp, #8
  60:	a832      	add	r0, sp, #200	; 0xc8
  62:	f7ff fffe 	bl	0 <wc_Des_CbcDecrypt>
    if (ret != 0)
  66:	b128      	cbz	r0, 74 <des_test+0x74>
        return WC_TEST_RET_ENC_EC(ret);
  68:	4240      	negs	r0, r0
  6a:	f3c0 030a 	ubfx	r3, r0, #0, #11
  6e:	4a14      	ldr	r2, [pc, #80]	; (c0 <des_test+0xc0>)
  70:	4818      	ldr	r0, [pc, #96]	; (d4 <des_test+0xd4>)
  72:	e7d4      	b.n	1e <des_test+0x1e>
    if (XMEMCMP(plain, vector, sizeof(plain)))
  74:	4914      	ldr	r1, [pc, #80]	; (c8 <des_test+0xc8>)
  76:	2218      	movs	r2, #24
  78:	a802      	add	r0, sp, #8
  7a:	f7ff fffe 	bl	0 <memcmp>
  7e:	b9b0      	cbnz	r0, ae <des_test+0xae>
    if (XMEMCMP(cipher, verify, sizeof(cipher)))
  80:	4915      	ldr	r1, [pc, #84]	; (d8 <des_test+0xd8>)
  82:	2218      	movs	r2, #24
  84:	a808      	add	r0, sp, #32
  86:	f7ff fffe 	bl	0 <memcmp>
  8a:	b990      	cbnz	r0, b2 <des_test+0xb2>
    ret = wc_Des_CbcEncryptWithKey(cipher, vector, sizeof(vector), key, iv);
  8c:	4b0b      	ldr	r3, [pc, #44]	; (bc <des_test+0xbc>)
  8e:	490e      	ldr	r1, [pc, #56]	; (c8 <des_test+0xc8>)
  90:	9400      	str	r4, [sp, #0]
  92:	2218      	movs	r2, #24
  94:	a808      	add	r0, sp, #32
  96:	f7ff fffe 	bl	0 <wc_Des_CbcEncryptWithKey>
    if (ret != 0)
  9a:	2800      	cmp	r0, #0
  9c:	d0c1      	beq.n	22 <des_test+0x22>
        return WC_TEST_RET_ENC_EC(ret);
  9e:	4a08      	ldr	r2, [pc, #32]	; (c0 <des_test+0xc0>)
  a0:	4b0e      	ldr	r3, [pc, #56]	; (dc <des_test+0xdc>)
  a2:	4240      	negs	r0, r0
  a4:	f3c0 000a 	ubfx	r0, r0, #0, #11
  a8:	fb02 3000 	mla	r0, r2, r0, r3
  ac:	e7b9      	b.n	22 <des_test+0x22>
        return WC_TEST_RET_ENC_NC;
  ae:	480c      	ldr	r0, [pc, #48]	; (e0 <des_test+0xe0>)
  b0:	e7b7      	b.n	22 <des_test+0x22>
        return WC_TEST_RET_ENC_NC;
  b2:	480c      	ldr	r0, [pc, #48]	; (e4 <des_test+0xe4>)
  b4:	e7b5      	b.n	22 <des_test+0x22>
  b6:	bf00      	nop
	...
  c0:	fffe7960 	.word	0xfffe7960
  c4:	dfffe1d4 	.word	0xdfffe1d4
  c8:	00000000 	.word	0x00000000
  cc:	dfffe1d0 	.word	0xdfffe1d0
  d0:	dfffe1cc 	.word	0xdfffe1cc
  d4:	dfffe1c8 	.word	0xdfffe1c8
  d8:	00000000 	.word	0x00000000
  dc:	dfffe1be 	.word	0xdfffe1be
  e0:	ffffe1c5 	.word	0xffffe1c5
  e4:	ffffe1c2 	.word	0xffffe1c2

Disassembly of section .text.des3_test:

00000000 <des3_test>:
{
   0:	b510      	push	{r4, lr}
   2:	f5ad 7d56 	sub.w	sp, sp, #856	; 0x358
    ret = wc_Des3Init(&enc, HEAP_HINT, devId);
   6:	2100      	movs	r1, #0
   8:	f06f 0201 	mvn.w	r2, #1
   c:	a80c      	add	r0, sp, #48	; 0x30
   e:	f7ff fffe 	bl	0 <wc_Des3Init>
    if (ret != 0)
  12:	4601      	mov	r1, r0
  14:	b150      	cbz	r0, 2c <des3_test+0x2c>
        return WC_TEST_RET_ENC_EC(ret);
  16:	4241      	negs	r1, r0
  18:	4c33      	ldr	r4, [pc, #204]	; (e8 <des3_test+0xe8>)
  1a:	4834      	ldr	r0, [pc, #208]	; (ec <des3_test+0xec>)
  1c:	f3c1 010a 	ubfx	r1, r1, #0, #11
  20:	fb00 4401 	mla	r4, r0, r1, r4
}
  24:	4620      	mov	r0, r4
  26:	f50d 7d56 	add.w	sp, sp, #856	; 0x358
  2a:	bd10      	pop	{r4, pc}
    ret = wc_Des3Init(&dec, HEAP_HINT, devId);
  2c:	f06f 0201 	mvn.w	r2, #1
  30:	a871      	add	r0, sp, #452	; 0x1c4
  32:	f7ff fffe 	bl	0 <wc_Des3Init>
    if (ret != 0)
  36:	4603      	mov	r3, r0
  38:	b138      	cbz	r0, 4a <des3_test+0x4a>
        return WC_TEST_RET_ENC_EC(ret);
  3a:	4243      	negs	r3, r0
  3c:	4c2c      	ldr	r4, [pc, #176]	; (f0 <des3_test+0xf0>)
  3e:	482b      	ldr	r0, [pc, #172]	; (ec <des3_test+0xec>)
  40:	f3c3 030a 	ubfx	r3, r3, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  44:	fb03 4400 	mla	r4, r3, r0, r4
  48:	e7ec      	b.n	24 <des3_test+0x24>
    ret = wc_Des3_SetKey(&enc, key3, iv3, DES_ENCRYPTION);
  4a:	4a2a      	ldr	r2, [pc, #168]	; (f4 <des3_test+0xf4>)
  4c:	492a      	ldr	r1, [pc, #168]	; (f8 <des3_test+0xf8>)
  4e:	a80c      	add	r0, sp, #48	; 0x30
  50:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
    if (ret != 0)
  54:	b128      	cbz	r0, 62 <des3_test+0x62>
        return WC_TEST_RET_ENC_EC(ret);
  56:	4240      	negs	r0, r0
  58:	4b24      	ldr	r3, [pc, #144]	; (ec <des3_test+0xec>)
  5a:	4c28      	ldr	r4, [pc, #160]	; (fc <des3_test+0xfc>)
  5c:	f3c0 000a 	ubfx	r0, r0, #0, #11
  60:	e7f0      	b.n	44 <des3_test+0x44>
    ret = wc_Des3_SetKey(&dec, key3, iv3, DES_DECRYPTION);
  62:	4a24      	ldr	r2, [pc, #144]	; (f4 <des3_test+0xf4>)
  64:	4924      	ldr	r1, [pc, #144]	; (f8 <des3_test+0xf8>)
  66:	2301      	movs	r3, #1
  68:	a871      	add	r0, sp, #452	; 0x1c4
  6a:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
    if (ret != 0)
  6e:	b128      	cbz	r0, 7c <des3_test+0x7c>
        return WC_TEST_RET_ENC_EC(ret);
  70:	4240      	negs	r0, r0
  72:	4b1e      	ldr	r3, [pc, #120]	; (ec <des3_test+0xec>)
  74:	4c22      	ldr	r4, [pc, #136]	; (100 <des3_test+0x100>)
  76:	f3c0 000a 	ubfx	r0, r0, #0, #11
  7a:	e7e3      	b.n	44 <des3_test+0x44>
    ret = wc_Des3_CbcEncrypt(&enc, cipher, vector, sizeof(vector));
  7c:	2318      	movs	r3, #24
  7e:	4a21      	ldr	r2, [pc, #132]	; (104 <des3_test+0x104>)
  80:	eb0d 0103 	add.w	r1, sp, r3
  84:	a80c      	add	r0, sp, #48	; 0x30
  86:	f7ff fffe 	bl	0 <wc_Des3_CbcEncrypt>
    if (ret != 0)
  8a:	b128      	cbz	r0, 98 <des3_test+0x98>
        return WC_TEST_RET_ENC_EC(ret);
  8c:	4240      	negs	r0, r0
  8e:	4b17      	ldr	r3, [pc, #92]	; (ec <des3_test+0xec>)
  90:	4c1d      	ldr	r4, [pc, #116]	; (108 <des3_test+0x108>)
  92:	f3c0 000a 	ubfx	r0, r0, #0, #11
  96:	e7d5      	b.n	44 <des3_test+0x44>
    ret = wc_Des3_CbcDecrypt(&dec, plain, cipher, sizeof(cipher));
  98:	2318      	movs	r3, #24
  9a:	eb0d 0203 	add.w	r2, sp, r3
  9e:	4669      	mov	r1, sp
  a0:	a871      	add	r0, sp, #452	; 0x1c4
  a2:	f7ff fffe 	bl	0 <wc_Des3_CbcDecrypt>
    if (ret != 0)
  a6:	b128      	cbz	r0, b4 <des3_test+0xb4>
        return WC_TEST_RET_ENC_EC(ret);
  a8:	4240      	negs	r0, r0
  aa:	4b10      	ldr	r3, [pc, #64]	; (ec <des3_test+0xec>)
  ac:	4c17      	ldr	r4, [pc, #92]	; (10c <des3_test+0x10c>)
  ae:	f3c0 000a 	ubfx	r0, r0, #0, #11
  b2:	e7c7      	b.n	44 <des3_test+0x44>
    if (XMEMCMP(plain, vector, sizeof(plain)))
  b4:	4913      	ldr	r1, [pc, #76]	; (104 <des3_test+0x104>)
  b6:	2218      	movs	r2, #24
  b8:	4668      	mov	r0, sp
  ba:	f7ff fffe 	bl	0 <memcmp>
  be:	b970      	cbnz	r0, de <des3_test+0xde>
    if (XMEMCMP(cipher, verify3, sizeof(cipher)))
  c0:	2218      	movs	r2, #24
  c2:	4913      	ldr	r1, [pc, #76]	; (110 <des3_test+0x110>)
  c4:	eb0d 0002 	add.w	r0, sp, r2
  c8:	f7ff fffe 	bl	0 <memcmp>
  cc:	4604      	mov	r4, r0
  ce:	b940      	cbnz	r0, e2 <des3_test+0xe2>
    wc_Des3Free(&enc);
  d0:	a80c      	add	r0, sp, #48	; 0x30
  d2:	f7ff fffe 	bl	0 <wc_Des3Free>
    wc_Des3Free(&dec);
  d6:	a871      	add	r0, sp, #452	; 0x1c4
  d8:	f7ff fffe 	bl	0 <wc_Des3Free>
    return 0;
  dc:	e7a2      	b.n	24 <des3_test+0x24>
        return WC_TEST_RET_ENC_NC;
  de:	4c0d      	ldr	r4, [pc, #52]	; (114 <des3_test+0x114>)
  e0:	e7a0      	b.n	24 <des3_test+0x24>
        return WC_TEST_RET_ENC_NC;
  e2:	4c0d      	ldr	r4, [pc, #52]	; (118 <des3_test+0x118>)
  e4:	e79e      	b.n	24 <des3_test+0x24>
  e6:	bf00      	nop
  e8:	dfffe16d 	.word	0xdfffe16d
  ec:	fffe7960 	.word	0xfffe7960
  f0:	dfffe16a 	.word	0xdfffe16a
	...
  fc:	dfffe166 	.word	0xdfffe166
 100:	dfffe163 	.word	0xdfffe163
 104:	00000000 	.word	0x00000000
 108:	dfffe15d 	.word	0xdfffe15d
 10c:	dfffe157 	.word	0xdfffe157
 110:	00000000 	.word	0x00000000
 114:	ffffe154 	.word	0xffffe154
 118:	ffffe151 	.word	0xffffe151

Disassembly of section .text.aes_test:

00000000 <aes_test>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    Aes *enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES);
   4:	f44f 709c 	mov.w	r0, #312	; 0x138
{
   8:	b0bb      	sub	sp, #236	; 0xec
    Aes *enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES);
   a:	f7ff fffe 	bl	0 <malloc>
   e:	4606      	mov	r6, r0
    Aes *dec = (Aes *)XMALLOC(sizeof *dec, HEAP_HINT, DYNAMIC_TYPE_AES);
  10:	f44f 709c 	mov.w	r0, #312	; 0x138
  14:	f7ff fffe 	bl	0 <malloc>
  18:	4605      	mov	r5, r0
    if (enc == NULL)
  1a:	2e00      	cmp	r6, #0
  1c:	f000 82d4 	beq.w	5c8 <aes_test+0x5c8>
    if (dec == NULL)
  20:	2800      	cmp	r0, #0
  22:	f000 8321 	beq.w	668 <aes_test+0x668>
    ret = wc_AesInit(enc, HEAP_HINT, devId);
  26:	f06f 0201 	mvn.w	r2, #1
  2a:	2100      	movs	r1, #0
  2c:	4630      	mov	r0, r6
  2e:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  32:	4607      	mov	r7, r0
  34:	b140      	cbz	r0, 48 <aes_test+0x48>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  36:	499c      	ldr	r1, [pc, #624]	; (2a8 <aes_test+0x2a8>)
  38:	4c9c      	ldr	r4, [pc, #624]	; (2ac <aes_test+0x2ac>)
  3a:	4240      	negs	r0, r0
  3c:	f3c0 000a 	ubfx	r0, r0, #0, #11
  40:	fb01 4400 	mla	r4, r1, r0, r4
        return WC_TEST_RET_ENC_NC;
  44:	2700      	movs	r7, #0
  46:	e010      	b.n	6a <aes_test+0x6a>
    ret = wc_AesInit(dec, HEAP_HINT, devId);
  48:	4601      	mov	r1, r0
  4a:	f06f 0201 	mvn.w	r2, #1
  4e:	4628      	mov	r0, r5
  50:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  54:	b1c0      	cbz	r0, 88 <aes_test+0x88>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  56:	4240      	negs	r0, r0
  58:	4993      	ldr	r1, [pc, #588]	; (2a8 <aes_test+0x2a8>)
  5a:	4c95      	ldr	r4, [pc, #596]	; (2b0 <aes_test+0x2b0>)
  5c:	f3c0 000a 	ubfx	r0, r0, #0, #11
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  60:	fb01 4400 	mla	r4, r1, r0, r4
            wc_AesFree(enc);
  64:	4630      	mov	r0, r6
  66:	f7ff fffe 	bl	0 <wc_AesFree>
        XFREE(enc, HEAP_HINT, DYNAMIC_TYPE_AES);
  6a:	4630      	mov	r0, r6
  6c:	f7ff fffe 	bl	0 <free>
    if (dec) {
  70:	b135      	cbz	r5, 80 <aes_test+0x80>
        if (dec_inited)
  72:	b117      	cbz	r7, 7a <aes_test+0x7a>
            wc_AesFree(dec);
  74:	4628      	mov	r0, r5
  76:	f7ff fffe 	bl	0 <wc_AesFree>
        XFREE(dec, HEAP_HINT, DYNAMIC_TYPE_AES);
  7a:	4628      	mov	r0, r5
  7c:	f7ff fffe 	bl	0 <free>
}
  80:	4620      	mov	r0, r4
  82:	b03b      	add	sp, #236	; 0xec
  84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ret = wc_AesSetKey(enc, key, AES_BLOCK_SIZE, iv, AES_ENCRYPTION);
  88:	4b8a      	ldr	r3, [pc, #552]	; (2b4 <aes_test+0x2b4>)
  8a:	498b      	ldr	r1, [pc, #556]	; (2b8 <aes_test+0x2b8>)
  8c:	9700      	str	r7, [sp, #0]
  8e:	2210      	movs	r2, #16
  90:	4630      	mov	r0, r6
  92:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
  96:	b138      	cbz	r0, a8 <aes_test+0xa8>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  98:	4240      	negs	r0, r0
  9a:	4983      	ldr	r1, [pc, #524]	; (2a8 <aes_test+0x2a8>)
  9c:	4c87      	ldr	r4, [pc, #540]	; (2bc <aes_test+0x2bc>)
  9e:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  a2:	fb01 4400 	mla	r4, r1, r0, r4
  a6:	e0fd      	b.n	2a4 <aes_test+0x2a4>
    ret = wc_AesSetKey(dec, key, AES_BLOCK_SIZE, iv, AES_DECRYPTION);
  a8:	f04f 0801 	mov.w	r8, #1
  ac:	4b81      	ldr	r3, [pc, #516]	; (2b4 <aes_test+0x2b4>)
  ae:	4982      	ldr	r1, [pc, #520]	; (2b8 <aes_test+0x2b8>)
  b0:	f8cd 8000 	str.w	r8, [sp]
  b4:	2210      	movs	r2, #16
  b6:	4628      	mov	r0, r5
  b8:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
  bc:	b128      	cbz	r0, ca <aes_test+0xca>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  be:	4240      	negs	r0, r0
  c0:	4979      	ldr	r1, [pc, #484]	; (2a8 <aes_test+0x2a8>)
  c2:	4c7f      	ldr	r4, [pc, #508]	; (2c0 <aes_test+0x2c0>)
  c4:	f3c0 000a 	ubfx	r0, r0, #0, #11
  c8:	e7eb      	b.n	a2 <aes_test+0xa2>
    XMEMSET(cipher, 0, AES_BLOCK_SIZE * 4);
  ca:	2240      	movs	r2, #64	; 0x40
  cc:	4639      	mov	r1, r7
  ce:	a81a      	add	r0, sp, #104	; 0x68
  d0:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcEncrypt(enc, cipher, msg, AES_BLOCK_SIZE);
  d4:	4a7b      	ldr	r2, [pc, #492]	; (2c4 <aes_test+0x2c4>)
  d6:	2310      	movs	r3, #16
  d8:	a91a      	add	r1, sp, #104	; 0x68
  da:	4630      	mov	r0, r6
  dc:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
    if (ret != 0)
  e0:	b128      	cbz	r0, ee <aes_test+0xee>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  e2:	4240      	negs	r0, r0
  e4:	4970      	ldr	r1, [pc, #448]	; (2a8 <aes_test+0x2a8>)
  e6:	4c78      	ldr	r4, [pc, #480]	; (2c8 <aes_test+0x2c8>)
  e8:	f3c0 000a 	ubfx	r0, r0, #0, #11
  ec:	e7d9      	b.n	a2 <aes_test+0xa2>
    XMEMSET(plain, 0, AES_BLOCK_SIZE * 4);
  ee:	2240      	movs	r2, #64	; 0x40
  f0:	4639      	mov	r1, r7
  f2:	a82a      	add	r0, sp, #168	; 0xa8
  f4:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcDecrypt(dec, plain, cipher, AES_BLOCK_SIZE);
  f8:	2310      	movs	r3, #16
  fa:	aa1a      	add	r2, sp, #104	; 0x68
  fc:	a92a      	add	r1, sp, #168	; 0xa8
  fe:	4628      	mov	r0, r5
 100:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
    if (ret != 0)
 104:	b128      	cbz	r0, 112 <aes_test+0x112>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 106:	4240      	negs	r0, r0
 108:	4967      	ldr	r1, [pc, #412]	; (2a8 <aes_test+0x2a8>)
 10a:	4c70      	ldr	r4, [pc, #448]	; (2cc <aes_test+0x2cc>)
 10c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 110:	e7c7      	b.n	a2 <aes_test+0xa2>
    if (XMEMCMP(plain, msg, AES_BLOCK_SIZE))
 112:	496c      	ldr	r1, [pc, #432]	; (2c4 <aes_test+0x2c4>)
 114:	2210      	movs	r2, #16
 116:	a82a      	add	r0, sp, #168	; 0xa8
 118:	f7ff fffe 	bl	0 <memcmp>
 11c:	2800      	cmp	r0, #0
 11e:	f040 8258 	bne.w	5d2 <aes_test+0x5d2>
    if (XMEMCMP(cipher, verify, AES_BLOCK_SIZE))
 122:	496b      	ldr	r1, [pc, #428]	; (2d0 <aes_test+0x2d0>)
 124:	2210      	movs	r2, #16
 126:	a81a      	add	r0, sp, #104	; 0x68
 128:	f7ff fffe 	bl	0 <memcmp>
 12c:	2800      	cmp	r0, #0
 12e:	f040 8252 	bne.w	5d6 <aes_test+0x5d6>
        ret = wc_AesSetKey(enc, key2, sizeof(key2), iv2, AES_ENCRYPTION);
 132:	2300      	movs	r3, #0
 134:	4967      	ldr	r1, [pc, #412]	; (2d4 <aes_test+0x2d4>)
 136:	9300      	str	r3, [sp, #0]
 138:	2210      	movs	r2, #16
 13a:	4b67      	ldr	r3, [pc, #412]	; (2d8 <aes_test+0x2d8>)
 13c:	4630      	mov	r0, r6
 13e:	f7ff fffe 	bl	0 <wc_AesSetKey>
        if (ret != 0)
 142:	4601      	mov	r1, r0
 144:	b128      	cbz	r0, 152 <aes_test+0x152>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 146:	4241      	negs	r1, r0
 148:	f3c1 000a 	ubfx	r0, r1, #0, #11
 14c:	4c63      	ldr	r4, [pc, #396]	; (2dc <aes_test+0x2dc>)
 14e:	4956      	ldr	r1, [pc, #344]	; (2a8 <aes_test+0x2a8>)
 150:	e7a7      	b.n	a2 <aes_test+0xa2>
        XMEMSET(cipher, 0, AES_BLOCK_SIZE * 2);
 152:	2220      	movs	r2, #32
 154:	a81a      	add	r0, sp, #104	; 0x68
 156:	f7ff fffe 	bl	0 <memset>
        ret = wc_AesCbcEncrypt(enc, cipher, msg2, AES_BLOCK_SIZE);
 15a:	4a61      	ldr	r2, [pc, #388]	; (2e0 <aes_test+0x2e0>)
 15c:	2310      	movs	r3, #16
 15e:	a91a      	add	r1, sp, #104	; 0x68
 160:	4630      	mov	r0, r6
 162:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
        if (ret != 0)
 166:	b128      	cbz	r0, 174 <aes_test+0x174>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 168:	4240      	negs	r0, r0
 16a:	494f      	ldr	r1, [pc, #316]	; (2a8 <aes_test+0x2a8>)
 16c:	4c5d      	ldr	r4, [pc, #372]	; (2e4 <aes_test+0x2e4>)
 16e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 172:	e796      	b.n	a2 <aes_test+0xa2>
        if (XMEMCMP(cipher, verify2, AES_BLOCK_SIZE))
 174:	495c      	ldr	r1, [pc, #368]	; (2e8 <aes_test+0x2e8>)
 176:	2210      	movs	r2, #16
 178:	a81a      	add	r0, sp, #104	; 0x68
 17a:	f7ff fffe 	bl	0 <memcmp>
 17e:	2800      	cmp	r0, #0
 180:	f040 822b 	bne.w	5da <aes_test+0x5da>
        ret = wc_AesCbcEncrypt(enc, cipher + AES_BLOCK_SIZE,
 184:	4a59      	ldr	r2, [pc, #356]	; (2ec <aes_test+0x2ec>)
 186:	2310      	movs	r3, #16
 188:	a91e      	add	r1, sp, #120	; 0x78
 18a:	4630      	mov	r0, r6
 18c:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
        if (ret != 0)
 190:	b128      	cbz	r0, 19e <aes_test+0x19e>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 192:	4240      	negs	r0, r0
 194:	4944      	ldr	r1, [pc, #272]	; (2a8 <aes_test+0x2a8>)
 196:	4c56      	ldr	r4, [pc, #344]	; (2f0 <aes_test+0x2f0>)
 198:	f3c0 000a 	ubfx	r0, r0, #0, #11
 19c:	e781      	b.n	a2 <aes_test+0xa2>
        if (XMEMCMP(cipher + AES_BLOCK_SIZE, verify2 + AES_BLOCK_SIZE,
 19e:	4955      	ldr	r1, [pc, #340]	; (2f4 <aes_test+0x2f4>)
 1a0:	2210      	movs	r2, #16
 1a2:	a81e      	add	r0, sp, #120	; 0x78
 1a4:	f7ff fffe 	bl	0 <memcmp>
 1a8:	2701      	movs	r7, #1
 1aa:	2800      	cmp	r0, #0
 1ac:	f040 8217 	bne.w	5de <aes_test+0x5de>
        ret = wc_AesSetKey(dec, key2, sizeof(key2), iv2, AES_DECRYPTION);
 1b0:	4948      	ldr	r1, [pc, #288]	; (2d4 <aes_test+0x2d4>)
 1b2:	4b49      	ldr	r3, [pc, #292]	; (2d8 <aes_test+0x2d8>)
 1b4:	9700      	str	r7, [sp, #0]
 1b6:	2210      	movs	r2, #16
 1b8:	4628      	mov	r0, r5
 1ba:	f7ff fffe 	bl	0 <wc_AesSetKey>
        if (ret != 0)
 1be:	4601      	mov	r1, r0
 1c0:	b128      	cbz	r0, 1ce <aes_test+0x1ce>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 1c2:	4241      	negs	r1, r0
 1c4:	f3c1 000a 	ubfx	r0, r1, #0, #11
 1c8:	4c4b      	ldr	r4, [pc, #300]	; (2f8 <aes_test+0x2f8>)
 1ca:	4937      	ldr	r1, [pc, #220]	; (2a8 <aes_test+0x2a8>)
 1cc:	e748      	b.n	60 <aes_test+0x60>
        XMEMSET(plain, 0, AES_BLOCK_SIZE * 2);
 1ce:	2220      	movs	r2, #32
 1d0:	a82a      	add	r0, sp, #168	; 0xa8
 1d2:	f7ff fffe 	bl	0 <memset>
        ret = wc_AesCbcDecrypt(dec, plain, verify2, AES_BLOCK_SIZE);
 1d6:	4a44      	ldr	r2, [pc, #272]	; (2e8 <aes_test+0x2e8>)
 1d8:	2310      	movs	r3, #16
 1da:	a92a      	add	r1, sp, #168	; 0xa8
 1dc:	4628      	mov	r0, r5
 1de:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
        if (ret != 0)
 1e2:	b128      	cbz	r0, 1f0 <aes_test+0x1f0>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 1e4:	4240      	negs	r0, r0
 1e6:	4930      	ldr	r1, [pc, #192]	; (2a8 <aes_test+0x2a8>)
 1e8:	4c44      	ldr	r4, [pc, #272]	; (2fc <aes_test+0x2fc>)
 1ea:	f3c0 000a 	ubfx	r0, r0, #0, #11
 1ee:	e737      	b.n	60 <aes_test+0x60>
        if (XMEMCMP(plain, msg2, AES_BLOCK_SIZE))
 1f0:	493b      	ldr	r1, [pc, #236]	; (2e0 <aes_test+0x2e0>)
 1f2:	2210      	movs	r2, #16
 1f4:	a82a      	add	r0, sp, #168	; 0xa8
 1f6:	f7ff fffe 	bl	0 <memcmp>
 1fa:	2800      	cmp	r0, #0
 1fc:	f040 81f1 	bne.w	5e2 <aes_test+0x5e2>
        ret = wc_AesCbcDecrypt(dec, plain + AES_BLOCK_SIZE,
 200:	4a3c      	ldr	r2, [pc, #240]	; (2f4 <aes_test+0x2f4>)
 202:	2310      	movs	r3, #16
 204:	a92e      	add	r1, sp, #184	; 0xb8
 206:	4628      	mov	r0, r5
 208:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
        if (ret != 0)
 20c:	b128      	cbz	r0, 21a <aes_test+0x21a>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 20e:	4240      	negs	r0, r0
 210:	4925      	ldr	r1, [pc, #148]	; (2a8 <aes_test+0x2a8>)
 212:	4c3b      	ldr	r4, [pc, #236]	; (300 <aes_test+0x300>)
 214:	f3c0 000a 	ubfx	r0, r0, #0, #11
 218:	e722      	b.n	60 <aes_test+0x60>
        if (XMEMCMP(plain + AES_BLOCK_SIZE, msg2 + AES_BLOCK_SIZE,
 21a:	4934      	ldr	r1, [pc, #208]	; (2ec <aes_test+0x2ec>)
 21c:	2210      	movs	r2, #16
 21e:	a82e      	add	r0, sp, #184	; 0xb8
 220:	f7ff fffe 	bl	0 <memcmp>
 224:	2800      	cmp	r0, #0
 226:	f040 81de 	bne.w	5e6 <aes_test+0x5e6>
    byte   key16[] = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 22a:	4b36      	ldr	r3, [pc, #216]	; (304 <aes_test+0x304>)
 22c:	aa03      	add	r2, sp, #12
 22e:	f103 0710 	add.w	r7, r3, #16
 232:	4690      	mov	r8, r2
 234:	6818      	ldr	r0, [r3, #0]
 236:	6859      	ldr	r1, [r3, #4]
 238:	4614      	mov	r4, r2
 23a:	c403      	stmia	r4!, {r0, r1}
 23c:	3308      	adds	r3, #8
 23e:	42bb      	cmp	r3, r7
 240:	4622      	mov	r2, r4
 242:	d1f7      	bne.n	234 <aes_test+0x234>
    byte   key24[] = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 244:	4b30      	ldr	r3, [pc, #192]	; (308 <aes_test+0x308>)
 246:	aa0c      	add	r2, sp, #48	; 0x30
 248:	f103 0718 	add.w	r7, r3, #24
 24c:	4691      	mov	r9, r2
 24e:	6818      	ldr	r0, [r3, #0]
 250:	6859      	ldr	r1, [r3, #4]
 252:	4614      	mov	r4, r2
 254:	c403      	stmia	r4!, {r0, r1}
 256:	3308      	adds	r3, #8
 258:	42bb      	cmp	r3, r7
 25a:	4622      	mov	r2, r4
 25c:	d1f7      	bne.n	24e <aes_test+0x24e>
    byte   key32[] = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 25e:	4b2b      	ldr	r3, [pc, #172]	; (30c <aes_test+0x30c>)
 260:	aa12      	add	r2, sp, #72	; 0x48
 262:	f103 0720 	add.w	r7, r3, #32
 266:	4692      	mov	sl, r2
 268:	6818      	ldr	r0, [r3, #0]
 26a:	6859      	ldr	r1, [r3, #4]
 26c:	4614      	mov	r4, r2
 26e:	c403      	stmia	r4!, {r0, r1}
 270:	3308      	adds	r3, #8
 272:	42bb      	cmp	r3, r7
 274:	4622      	mov	r2, r4
 276:	d1f7      	bne.n	268 <aes_test+0x268>
    byte   iv[]    = "1234567890abcdef";
 278:	4b25      	ldr	r3, [pc, #148]	; (310 <aes_test+0x310>)
 27a:	aa07      	add	r2, sp, #28
 27c:	f103 0710 	add.w	r7, r3, #16
 280:	4693      	mov	fp, r2
 282:	6818      	ldr	r0, [r3, #0]
 284:	6859      	ldr	r1, [r3, #4]
 286:	4614      	mov	r4, r2
 288:	c403      	stmia	r4!, {r0, r1}
 28a:	3308      	adds	r3, #8
 28c:	42bb      	cmp	r3, r7
 28e:	4622      	mov	r2, r4
 290:	d1f7      	bne.n	282 <aes_test+0x282>
 292:	781b      	ldrb	r3, [r3, #0]
 294:	7023      	strb	r3, [r4, #0]
    if ((aes = (Aes *)XMALLOC(sizeof *aes, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
 296:	f44f 709c 	mov.w	r0, #312	; 0x138
 29a:	f7ff fffe 	bl	0 <malloc>
 29e:	4607      	mov	r7, r0
 2a0:	bbd0      	cbnz	r0, 318 <aes_test+0x318>
        return WC_TEST_RET_ENC_ERRNO;
 2a2:	4c1c      	ldr	r4, [pc, #112]	; (314 <aes_test+0x314>)
    dec_inited = 1;
 2a4:	2701      	movs	r7, #1
 2a6:	e6dd      	b.n	64 <aes_test+0x64>
 2a8:	fffe7960 	.word	0xfffe7960
 2ac:	dfffd4d1 	.word	0xdfffd4d1
 2b0:	dfffd4cc 	.word	0xdfffd4cc
	...
 2bc:	dfffd4c6 	.word	0xdfffd4c6
 2c0:	dfffd4c2 	.word	0xdfffd4c2
 2c4:	00000000 	.word	0x00000000
 2c8:	dfffd4b9 	.word	0xdfffd4b9
 2cc:	dfffd4b1 	.word	0xdfffd4b1
	...
 2dc:	dfffd405 	.word	0xdfffd405
 2e0:	00000000 	.word	0x00000000
 2e4:	dfffd3fe 	.word	0xdfffd3fe
 2e8:	00000000 	.word	0x00000000
 2ec:	00000010 	.word	0x00000010
 2f0:	dfffd3f3 	.word	0xdfffd3f3
 2f4:	00000010 	.word	0x00000010
 2f8:	dfffd3eb 	.word	0xdfffd3eb
 2fc:	dfffd3e4 	.word	0xdfffd3e4
 300:	dfffd3da 	.word	0xdfffd3da
 304:	00000000 	.word	0x00000000
 308:	00000011 	.word	0x00000011
 30c:	0000002a 	.word	0x0000002a
 310:	0000004b 	.word	0x0000004b
 314:	ffffdc0b 	.word	0xffffdc0b
    ret = wc_AesInit(NULL, HEAP_HINT, devId);
 318:	2100      	movs	r1, #0
 31a:	f06f 0201 	mvn.w	r2, #1
 31e:	4608      	mov	r0, r1
 320:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != BAD_FUNC_ARG)
 324:	f110 0fad 	cmn.w	r0, #173	; 0xad
 328:	d048      	beq.n	3bc <aes_test+0x3bc>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 32a:	4240      	negs	r0, r0
 32c:	49af      	ldr	r1, [pc, #700]	; (5ec <aes_test+0x5ec>)
 32e:	4cb0      	ldr	r4, [pc, #704]	; (5f0 <aes_test+0x5f0>)
 330:	f3c0 000a 	ubfx	r0, r0, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 334:	fb01 4400 	mla	r4, r1, r0, r4
    wc_AesFree(aes);
 338:	4638      	mov	r0, r7
 33a:	f7ff fffe 	bl	0 <wc_AesFree>
    XFREE(aes, HEAP_HINT, DYNAMIC_TYPE_AES);
 33e:	4638      	mov	r0, r7
 340:	f7ff fffe 	bl	0 <free>
    if (ret != 0)
 344:	2c00      	cmp	r4, #0
 346:	d1ad      	bne.n	2a4 <aes_test+0x2a4>
    byte key[] = "0123456789abcdef   ";  /* align */
 348:	4baa      	ldr	r3, [pc, #680]	; (5f4 <aes_test+0x5f4>)
 34a:	464a      	mov	r2, r9
 34c:	f103 0710 	add.w	r7, r3, #16
 350:	6818      	ldr	r0, [r3, #0]
 352:	6859      	ldr	r1, [r3, #4]
 354:	4614      	mov	r4, r2
 356:	c403      	stmia	r4!, {r0, r1}
 358:	3308      	adds	r3, #8
 35a:	42bb      	cmp	r3, r7
 35c:	4622      	mov	r2, r4
 35e:	d1f7      	bne.n	350 <aes_test+0x350>
 360:	6818      	ldr	r0, [r3, #0]
    byte iv[]  = "1234567890abcdef   ";  /* align */
 362:	4ba5      	ldr	r3, [pc, #660]	; (5f8 <aes_test+0x5f8>)
    byte key[] = "0123456789abcdef   ";  /* align */
 364:	6020      	str	r0, [r4, #0]
    byte iv[]  = "1234567890abcdef   ";  /* align */
 366:	4652      	mov	r2, sl
 368:	f103 0710 	add.w	r7, r3, #16
 36c:	6818      	ldr	r0, [r3, #0]
 36e:	6859      	ldr	r1, [r3, #4]
 370:	4614      	mov	r4, r2
 372:	c403      	stmia	r4!, {r0, r1}
 374:	3308      	adds	r3, #8
 376:	42bb      	cmp	r3, r7
 378:	4622      	mov	r2, r4
 37a:	d1f7      	bne.n	36c <aes_test+0x36c>
 37c:	6818      	ldr	r0, [r3, #0]
 37e:	6020      	str	r0, [r4, #0]
    XMEMSET(cipher, 0, AES_BLOCK_SIZE);
 380:	2210      	movs	r2, #16
 382:	2100      	movs	r1, #0
 384:	4640      	mov	r0, r8
 386:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcEncryptWithKey(cipher, msg, AES_BLOCK_SIZE, key, 17, NULL);
 38a:	2711      	movs	r7, #17
    XMEMSET(plain, 0, AES_BLOCK_SIZE);
 38c:	2210      	movs	r2, #16
 38e:	2100      	movs	r1, #0
 390:	a807      	add	r0, sp, #28
    ret = wc_AesCbcEncryptWithKey(cipher, msg, AES_BLOCK_SIZE, key, 17, NULL);
 392:	2400      	movs	r4, #0
    XMEMSET(plain, 0, AES_BLOCK_SIZE);
 394:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcEncryptWithKey(cipher, msg, AES_BLOCK_SIZE, key, 17, NULL);
 398:	e9cd 7400 	strd	r7, r4, [sp]
 39c:	4997      	ldr	r1, [pc, #604]	; (5fc <aes_test+0x5fc>)
 39e:	464b      	mov	r3, r9
 3a0:	2210      	movs	r2, #16
 3a2:	4640      	mov	r0, r8
 3a4:	f7ff fffe 	bl	0 <wc_AesCbcEncryptWithKey>
    if (ret != BAD_FUNC_ARG)
 3a8:	f110 0fad 	cmn.w	r0, #173	; 0xad
 3ac:	f000 80d1 	beq.w	552 <aes_test+0x552>
        return WC_TEST_RET_ENC_EC(ret);
 3b0:	4240      	negs	r0, r0
 3b2:	498e      	ldr	r1, [pc, #568]	; (5ec <aes_test+0x5ec>)
 3b4:	4c92      	ldr	r4, [pc, #584]	; (600 <aes_test+0x600>)
 3b6:	f3c0 000a 	ubfx	r0, r0, #0, #11
 3ba:	e672      	b.n	a2 <aes_test+0xa2>
    ret = wc_AesInit(aes, HEAP_HINT, devId);
 3bc:	f06f 0201 	mvn.w	r2, #1
 3c0:	2100      	movs	r1, #0
 3c2:	4638      	mov	r0, r7
 3c4:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
 3c8:	4604      	mov	r4, r0
 3ca:	b128      	cbz	r0, 3d8 <aes_test+0x3d8>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 3cc:	4244      	negs	r4, r0
 3ce:	f3c4 000a 	ubfx	r0, r4, #0, #11
 3d2:	4986      	ldr	r1, [pc, #536]	; (5ec <aes_test+0x5ec>)
 3d4:	4c8b      	ldr	r4, [pc, #556]	; (604 <aes_test+0x604>)
 3d6:	e7ad      	b.n	334 <aes_test+0x334>
    ret = wc_AesGetKeySize(NULL, NULL);
 3d8:	4601      	mov	r1, r0
 3da:	f7ff fffe 	bl	0 <wc_AesGetKeySize>
    if (ret != BAD_FUNC_ARG)
 3de:	f110 0fad 	cmn.w	r0, #173	; 0xad
 3e2:	d005      	beq.n	3f0 <aes_test+0x3f0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 3e4:	4240      	negs	r0, r0
 3e6:	4981      	ldr	r1, [pc, #516]	; (5ec <aes_test+0x5ec>)
 3e8:	4c87      	ldr	r4, [pc, #540]	; (608 <aes_test+0x608>)
 3ea:	f3c0 000a 	ubfx	r0, r0, #0, #11
 3ee:	e7a1      	b.n	334 <aes_test+0x334>
    ret = wc_AesGetKeySize(aes, NULL);
 3f0:	4621      	mov	r1, r4
 3f2:	4638      	mov	r0, r7
 3f4:	f7ff fffe 	bl	0 <wc_AesGetKeySize>
    if (ret != BAD_FUNC_ARG)
 3f8:	f110 0fad 	cmn.w	r0, #173	; 0xad
 3fc:	d005      	beq.n	40a <aes_test+0x40a>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 3fe:	4240      	negs	r0, r0
 400:	497a      	ldr	r1, [pc, #488]	; (5ec <aes_test+0x5ec>)
 402:	4c82      	ldr	r4, [pc, #520]	; (60c <aes_test+0x60c>)
 404:	f3c0 000a 	ubfx	r0, r0, #0, #11
 408:	e794      	b.n	334 <aes_test+0x334>
    ret = wc_AesGetKeySize(NULL, &keySize);
 40a:	a902      	add	r1, sp, #8
 40c:	4620      	mov	r0, r4
 40e:	f7ff fffe 	bl	0 <wc_AesGetKeySize>
    if (ret != BAD_FUNC_ARG)
 412:	f110 0fad 	cmn.w	r0, #173	; 0xad
 416:	d005      	beq.n	424 <aes_test+0x424>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 418:	4240      	negs	r0, r0
 41a:	4974      	ldr	r1, [pc, #464]	; (5ec <aes_test+0x5ec>)
 41c:	4c7c      	ldr	r4, [pc, #496]	; (610 <aes_test+0x610>)
 41e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 422:	e787      	b.n	334 <aes_test+0x334>
    ret = wc_AesSetKey(NULL, key16, sizeof(key16), iv, AES_ENCRYPTION);
 424:	9400      	str	r4, [sp, #0]
 426:	465b      	mov	r3, fp
 428:	2210      	movs	r2, #16
 42a:	4641      	mov	r1, r8
 42c:	4620      	mov	r0, r4
 42e:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != BAD_FUNC_ARG)
 432:	f110 0fad 	cmn.w	r0, #173	; 0xad
 436:	d005      	beq.n	444 <aes_test+0x444>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 438:	4240      	negs	r0, r0
 43a:	496c      	ldr	r1, [pc, #432]	; (5ec <aes_test+0x5ec>)
 43c:	4c75      	ldr	r4, [pc, #468]	; (614 <aes_test+0x614>)
 43e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 442:	e777      	b.n	334 <aes_test+0x334>
    ret = wc_AesSetKey(aes, key16, sizeof(key16), NULL, AES_ENCRYPTION);
 444:	9400      	str	r4, [sp, #0]
 446:	4623      	mov	r3, r4
 448:	2210      	movs	r2, #16
 44a:	4641      	mov	r1, r8
 44c:	4638      	mov	r0, r7
 44e:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
 452:	b128      	cbz	r0, 460 <aes_test+0x460>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 454:	4240      	negs	r0, r0
 456:	4965      	ldr	r1, [pc, #404]	; (5ec <aes_test+0x5ec>)
 458:	4c6f      	ldr	r4, [pc, #444]	; (618 <aes_test+0x618>)
 45a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 45e:	e769      	b.n	334 <aes_test+0x334>
    ret = wc_AesSetKey(aes, key32, sizeof(key32) - 1, iv, AES_ENCRYPTION);
 460:	9000      	str	r0, [sp, #0]
 462:	465b      	mov	r3, fp
 464:	221f      	movs	r2, #31
 466:	4651      	mov	r1, sl
 468:	4638      	mov	r0, r7
 46a:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != BAD_FUNC_ARG)
 46e:	f110 0fad 	cmn.w	r0, #173	; 0xad
 472:	d005      	beq.n	480 <aes_test+0x480>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 474:	4240      	negs	r0, r0
 476:	495d      	ldr	r1, [pc, #372]	; (5ec <aes_test+0x5ec>)
 478:	4c68      	ldr	r4, [pc, #416]	; (61c <aes_test+0x61c>)
 47a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 47e:	e759      	b.n	334 <aes_test+0x334>
    aes->rounds = 16;
 480:	2410      	movs	r4, #16
 482:	f8c7 40f0 	str.w	r4, [r7, #240]	; 0xf0
    ret = wc_AesGetKeySize(aes, &keySize);
 486:	a902      	add	r1, sp, #8
 488:	4638      	mov	r0, r7
 48a:	f7ff fffe 	bl	0 <wc_AesGetKeySize>
    if (ret != BAD_FUNC_ARG)
 48e:	f110 0fad 	cmn.w	r0, #173	; 0xad
 492:	d005      	beq.n	4a0 <aes_test+0x4a0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 494:	4240      	negs	r0, r0
 496:	4955      	ldr	r1, [pc, #340]	; (5ec <aes_test+0x5ec>)
 498:	4c61      	ldr	r4, [pc, #388]	; (620 <aes_test+0x620>)
 49a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 49e:	e749      	b.n	334 <aes_test+0x334>
    ret = wc_AesSetKey(aes, key16, sizeof(key16), iv, AES_ENCRYPTION);
 4a0:	2300      	movs	r3, #0
 4a2:	9300      	str	r3, [sp, #0]
 4a4:	4622      	mov	r2, r4
 4a6:	465b      	mov	r3, fp
 4a8:	4641      	mov	r1, r8
 4aa:	4638      	mov	r0, r7
 4ac:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
 4b0:	b128      	cbz	r0, 4be <aes_test+0x4be>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 4b2:	4240      	negs	r0, r0
 4b4:	494d      	ldr	r1, [pc, #308]	; (5ec <aes_test+0x5ec>)
 4b6:	4c5b      	ldr	r4, [pc, #364]	; (624 <aes_test+0x624>)
 4b8:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4bc:	e73a      	b.n	334 <aes_test+0x334>
    ret = wc_AesGetKeySize(aes, &keySize);
 4be:	a902      	add	r1, sp, #8
 4c0:	4638      	mov	r0, r7
 4c2:	f7ff fffe 	bl	0 <wc_AesGetKeySize>
    if (ret != 0 || keySize != sizeof(key16))
 4c6:	b910      	cbnz	r0, 4ce <aes_test+0x4ce>
 4c8:	9b02      	ldr	r3, [sp, #8]
 4ca:	2b10      	cmp	r3, #16
 4cc:	d005      	beq.n	4da <aes_test+0x4da>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 4ce:	4240      	negs	r0, r0
 4d0:	4946      	ldr	r1, [pc, #280]	; (5ec <aes_test+0x5ec>)
 4d2:	4c55      	ldr	r4, [pc, #340]	; (628 <aes_test+0x628>)
 4d4:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4d8:	e72c      	b.n	334 <aes_test+0x334>
    ret = wc_AesSetKey(aes, key24, sizeof(key24), iv, AES_ENCRYPTION);
 4da:	9000      	str	r0, [sp, #0]
 4dc:	465b      	mov	r3, fp
 4de:	2218      	movs	r2, #24
 4e0:	4649      	mov	r1, r9
 4e2:	4638      	mov	r0, r7
 4e4:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
 4e8:	b128      	cbz	r0, 4f6 <aes_test+0x4f6>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 4ea:	4240      	negs	r0, r0
 4ec:	493f      	ldr	r1, [pc, #252]	; (5ec <aes_test+0x5ec>)
 4ee:	4c4f      	ldr	r4, [pc, #316]	; (62c <aes_test+0x62c>)
 4f0:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4f4:	e71e      	b.n	334 <aes_test+0x334>
    ret = wc_AesGetKeySize(aes, &keySize);
 4f6:	a902      	add	r1, sp, #8
 4f8:	4638      	mov	r0, r7
 4fa:	f7ff fffe 	bl	0 <wc_AesGetKeySize>
    if (ret != 0 || keySize != sizeof(key24))
 4fe:	b910      	cbnz	r0, 506 <aes_test+0x506>
 500:	9b02      	ldr	r3, [sp, #8]
 502:	2b18      	cmp	r3, #24
 504:	d005      	beq.n	512 <aes_test+0x512>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 506:	4240      	negs	r0, r0
 508:	4938      	ldr	r1, [pc, #224]	; (5ec <aes_test+0x5ec>)
 50a:	4c49      	ldr	r4, [pc, #292]	; (630 <aes_test+0x630>)
 50c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 510:	e710      	b.n	334 <aes_test+0x334>
    ret = wc_AesSetKey(aes, key32, sizeof(key32), iv, AES_ENCRYPTION);
 512:	9000      	str	r0, [sp, #0]
 514:	465b      	mov	r3, fp
 516:	2220      	movs	r2, #32
 518:	4651      	mov	r1, sl
 51a:	4638      	mov	r0, r7
 51c:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
 520:	b128      	cbz	r0, 52e <aes_test+0x52e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 522:	4240      	negs	r0, r0
 524:	4931      	ldr	r1, [pc, #196]	; (5ec <aes_test+0x5ec>)
 526:	4c43      	ldr	r4, [pc, #268]	; (634 <aes_test+0x634>)
 528:	f3c0 000a 	ubfx	r0, r0, #0, #11
 52c:	e702      	b.n	334 <aes_test+0x334>
    ret = wc_AesGetKeySize(aes, &keySize);
 52e:	a902      	add	r1, sp, #8
 530:	4638      	mov	r0, r7
 532:	f7ff fffe 	bl	0 <wc_AesGetKeySize>
    if (ret != 0 || keySize != sizeof(key32))
 536:	4604      	mov	r4, r0
 538:	b918      	cbnz	r0, 542 <aes_test+0x542>
 53a:	9b02      	ldr	r3, [sp, #8]
 53c:	2b20      	cmp	r3, #32
 53e:	f43f aefb 	beq.w	338 <aes_test+0x338>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 542:	492a      	ldr	r1, [pc, #168]	; (5ec <aes_test+0x5ec>)
 544:	483c      	ldr	r0, [pc, #240]	; (638 <aes_test+0x638>)
 546:	4264      	negs	r4, r4
 548:	f3c4 040a 	ubfx	r4, r4, #0, #11
 54c:	fb01 0404 	mla	r4, r1, r4, r0
 550:	e6f2      	b.n	338 <aes_test+0x338>
    ret = wc_AesCbcDecryptWithKey(plain, cipher, AES_BLOCK_SIZE, key, 17, NULL);
 552:	e9cd 7400 	strd	r7, r4, [sp]
 556:	464b      	mov	r3, r9
 558:	2210      	movs	r2, #16
 55a:	4641      	mov	r1, r8
 55c:	a807      	add	r0, sp, #28
 55e:	f7ff fffe 	bl	0 <wc_AesCbcDecryptWithKey>
    if (ret != BAD_FUNC_ARG)
 562:	f110 0fad 	cmn.w	r0, #173	; 0xad
 566:	d005      	beq.n	574 <aes_test+0x574>
        return WC_TEST_RET_ENC_EC(ret);
 568:	4240      	negs	r0, r0
 56a:	4920      	ldr	r1, [pc, #128]	; (5ec <aes_test+0x5ec>)
 56c:	4c33      	ldr	r4, [pc, #204]	; (63c <aes_test+0x63c>)
 56e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 572:	e596      	b.n	a2 <aes_test+0xa2>
    ret = wc_AesCbcEncryptWithKey(cipher, msg, AES_BLOCK_SIZE, key,
 574:	2710      	movs	r7, #16
 576:	4921      	ldr	r1, [pc, #132]	; (5fc <aes_test+0x5fc>)
 578:	f8cd a004 	str.w	sl, [sp, #4]
 57c:	9700      	str	r7, [sp, #0]
 57e:	464b      	mov	r3, r9
 580:	463a      	mov	r2, r7
 582:	4640      	mov	r0, r8
 584:	f7ff fffe 	bl	0 <wc_AesCbcEncryptWithKey>
    if (ret != 0)
 588:	b128      	cbz	r0, 596 <aes_test+0x596>
        return WC_TEST_RET_ENC_EC(ret);
 58a:	4240      	negs	r0, r0
 58c:	4917      	ldr	r1, [pc, #92]	; (5ec <aes_test+0x5ec>)
 58e:	4c2c      	ldr	r4, [pc, #176]	; (640 <aes_test+0x640>)
 590:	f3c0 000a 	ubfx	r0, r0, #0, #11
 594:	e585      	b.n	a2 <aes_test+0xa2>
    ret = wc_AesCbcDecryptWithKey(plain, cipher, AES_BLOCK_SIZE, key,
 596:	e9cd 7a00 	strd	r7, sl, [sp]
 59a:	464b      	mov	r3, r9
 59c:	463a      	mov	r2, r7
 59e:	4641      	mov	r1, r8
 5a0:	a807      	add	r0, sp, #28
 5a2:	f7ff fffe 	bl	0 <wc_AesCbcDecryptWithKey>
    if (ret != 0)
 5a6:	b128      	cbz	r0, 5b4 <aes_test+0x5b4>
        return WC_TEST_RET_ENC_EC(ret);
 5a8:	4240      	negs	r0, r0
 5aa:	4910      	ldr	r1, [pc, #64]	; (5ec <aes_test+0x5ec>)
 5ac:	4c25      	ldr	r4, [pc, #148]	; (644 <aes_test+0x644>)
 5ae:	f3c0 000a 	ubfx	r0, r0, #0, #11
 5b2:	e576      	b.n	a2 <aes_test+0xa2>
    if (XMEMCMP(plain, msg, AES_BLOCK_SIZE) != 0)
 5b4:	4911      	ldr	r1, [pc, #68]	; (5fc <aes_test+0x5fc>)
 5b6:	463a      	mov	r2, r7
 5b8:	a807      	add	r0, sp, #28
 5ba:	f7ff fffe 	bl	0 <memcmp>
        return WC_TEST_RET_ENC_NC;
 5be:	4b22      	ldr	r3, [pc, #136]	; (648 <aes_test+0x648>)
 5c0:	1e04      	subs	r4, r0, #0
 5c2:	bf18      	it	ne
 5c4:	461c      	movne	r4, r3
    if (ret != 0)
 5c6:	e66d      	b.n	2a4 <aes_test+0x2a4>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 5c8:	4c20      	ldr	r4, [pc, #128]	; (64c <aes_test+0x64c>)
    if (dec) {
 5ca:	2800      	cmp	r0, #0
 5cc:	f47f ad55 	bne.w	7a <aes_test+0x7a>
 5d0:	e556      	b.n	80 <aes_test+0x80>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 5d2:	4c1f      	ldr	r4, [pc, #124]	; (650 <aes_test+0x650>)
 5d4:	e666      	b.n	2a4 <aes_test+0x2a4>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 5d6:	4c1f      	ldr	r4, [pc, #124]	; (654 <aes_test+0x654>)
 5d8:	e664      	b.n	2a4 <aes_test+0x2a4>
            ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 5da:	4c1f      	ldr	r4, [pc, #124]	; (658 <aes_test+0x658>)
 5dc:	e662      	b.n	2a4 <aes_test+0x2a4>
            ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 5de:	4c1f      	ldr	r4, [pc, #124]	; (65c <aes_test+0x65c>)
 5e0:	e540      	b.n	64 <aes_test+0x64>
            ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 5e2:	4c1f      	ldr	r4, [pc, #124]	; (660 <aes_test+0x660>)
 5e4:	e53e      	b.n	64 <aes_test+0x64>
            ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 5e6:	4c1f      	ldr	r4, [pc, #124]	; (664 <aes_test+0x664>)
 5e8:	e65c      	b.n	2a4 <aes_test+0x2a4>
 5ea:	bf00      	nop
 5ec:	fffe7960 	.word	0xfffe7960
 5f0:	dfffdc02 	.word	0xdfffdc02
 5f4:	0000005c 	.word	0x0000005c
 5f8:	00000070 	.word	0x00000070
 5fc:	00000000 	.word	0x00000000
 600:	dfffd7e9 	.word	0xdfffd7e9
 604:	dfffdbfc 	.word	0xdfffdbfc
 608:	dfffdbf6 	.word	0xdfffdbf6
 60c:	dfffdbf3 	.word	0xdfffdbf3
 610:	dfffdbf0 	.word	0xdfffdbf0
 614:	dfffdbec 	.word	0xdfffdbec
 618:	dfffdbe3 	.word	0xdfffdbe3
 61c:	dfffdbe0 	.word	0xdfffdbe0
 620:	dfffdbd7 	.word	0xdfffdbd7
 624:	dfffdbcd 	.word	0xdfffdbcd
 628:	dfffdbc9 	.word	0xdfffdbc9
 62c:	dfffdbbf 	.word	0xdfffdbbf
 630:	dfffdbbb 	.word	0xdfffdbbb
 634:	dfffdbb2 	.word	0xdfffdbb2
 638:	dfffdbae 	.word	0xdfffdbae
 63c:	dfffd7e5 	.word	0xdfffd7e5
 640:	dfffd7df 	.word	0xdfffd7df
 644:	dfffd7da 	.word	0xdfffd7da
 648:	ffffd7d8 	.word	0xffffd7d8
 64c:	ffffd4db 	.word	0xffffd4db
 650:	ffffd4ae 	.word	0xffffd4ae
 654:	ffffd4a9 	.word	0xffffd4a9
 658:	ffffd3fb 	.word	0xffffd3fb
 65c:	ffffd3f0 	.word	0xffffd3f0
 660:	ffffd3e2 	.word	0xffffd3e2
 664:	ffffd3d7 	.word	0xffffd3d7
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 668:	4c00      	ldr	r4, [pc, #0]	; (66c <aes_test+0x66c>)
 66a:	e4eb      	b.n	44 <aes_test+0x44>
 66c:	ffffd4d7 	.word	0xffffd4d7

Disassembly of section .text.aes192_test:

00000000 <aes192_test>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   2:	f44f 709c 	mov.w	r0, #312	; 0x138
{
   6:	b08a      	sub	sp, #40	; 0x28
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   8:	f7ff fffe 	bl	0 <malloc>
   c:	4606      	mov	r6, r0
   e:	2800      	cmp	r0, #0
  10:	f000 8081 	beq.w	116 <aes192_test+0x116>
    if ((dec = (Aes *)XMALLOC(sizeof *dec, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
  14:	f44f 709c 	mov.w	r0, #312	; 0x138
  18:	f7ff fffe 	bl	0 <malloc>
  1c:	4605      	mov	r5, r0
  1e:	2800      	cmp	r0, #0
  20:	d07b      	beq.n	11a <aes192_test+0x11a>
    ret = wc_AesInit(enc, HEAP_HINT, devId);
  22:	2100      	movs	r1, #0
  24:	f06f 0201 	mvn.w	r2, #1
  28:	4630      	mov	r0, r6
  2a:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  2e:	4601      	mov	r1, r0
  30:	b180      	cbz	r0, 54 <aes192_test+0x54>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  32:	4241      	negs	r1, r0
  34:	4c3c      	ldr	r4, [pc, #240]	; (128 <aes192_test+0x128>)
  36:	483d      	ldr	r0, [pc, #244]	; (12c <aes192_test+0x12c>)
  38:	f3c1 010a 	ubfx	r1, r1, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  3c:	fb01 4400 	mla	r4, r1, r0, r4
        XFREE(enc, HEAP_HINT, DYNAMIC_TYPE_AES);
  40:	4630      	mov	r0, r6
  42:	f7ff fffe 	bl	0 <free>
    if (dec)
  46:	b115      	cbz	r5, 4e <aes192_test+0x4e>
        XFREE(dec, HEAP_HINT, DYNAMIC_TYPE_AES);
  48:	4628      	mov	r0, r5
  4a:	f7ff fffe 	bl	0 <free>
}
  4e:	4620      	mov	r0, r4
  50:	b00a      	add	sp, #40	; 0x28
  52:	bd70      	pop	{r4, r5, r6, pc}
    ret = wc_AesInit(dec, HEAP_HINT, devId);
  54:	f06f 0201 	mvn.w	r2, #1
  58:	4628      	mov	r0, r5
  5a:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  5e:	b128      	cbz	r0, 6c <aes192_test+0x6c>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  60:	4240      	negs	r0, r0
  62:	4932      	ldr	r1, [pc, #200]	; (12c <aes192_test+0x12c>)
  64:	4c32      	ldr	r4, [pc, #200]	; (130 <aes192_test+0x130>)
  66:	f3c0 000a 	ubfx	r0, r0, #0, #11
  6a:	e7e7      	b.n	3c <aes192_test+0x3c>
    ret = wc_AesSetKey(enc, key, (int) sizeof(key), iv, AES_ENCRYPTION);
  6c:	9000      	str	r0, [sp, #0]
  6e:	4b31      	ldr	r3, [pc, #196]	; (134 <aes192_test+0x134>)
  70:	4931      	ldr	r1, [pc, #196]	; (138 <aes192_test+0x138>)
  72:	2218      	movs	r2, #24
  74:	4630      	mov	r0, r6
  76:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
  7a:	b128      	cbz	r0, 88 <aes192_test+0x88>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  7c:	4240      	negs	r0, r0
  7e:	492b      	ldr	r1, [pc, #172]	; (12c <aes192_test+0x12c>)
  80:	4c2e      	ldr	r4, [pc, #184]	; (13c <aes192_test+0x13c>)
  82:	f3c0 000a 	ubfx	r0, r0, #0, #11
  86:	e7d9      	b.n	3c <aes192_test+0x3c>
    ret = wc_AesSetKey(dec, key, (int) sizeof(key), iv, AES_DECRYPTION);
  88:	2301      	movs	r3, #1
  8a:	492b      	ldr	r1, [pc, #172]	; (138 <aes192_test+0x138>)
  8c:	9300      	str	r3, [sp, #0]
  8e:	2218      	movs	r2, #24
  90:	4b28      	ldr	r3, [pc, #160]	; (134 <aes192_test+0x134>)
  92:	4628      	mov	r0, r5
  94:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
  98:	4601      	mov	r1, r0
  9a:	b128      	cbz	r0, a8 <aes192_test+0xa8>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  9c:	4241      	negs	r1, r0
  9e:	4c28      	ldr	r4, [pc, #160]	; (140 <aes192_test+0x140>)
  a0:	4822      	ldr	r0, [pc, #136]	; (12c <aes192_test+0x12c>)
  a2:	f3c1 010a 	ubfx	r1, r1, #0, #11
  a6:	e7c9      	b.n	3c <aes192_test+0x3c>
    XMEMSET(cipher, 0, AES_BLOCK_SIZE);
  a8:	2210      	movs	r2, #16
  aa:	a802      	add	r0, sp, #8
  ac:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));
  b0:	a902      	add	r1, sp, #8
  b2:	4a24      	ldr	r2, [pc, #144]	; (144 <aes192_test+0x144>)
  b4:	2310      	movs	r3, #16
  b6:	4630      	mov	r0, r6
  b8:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
    if (ret != 0)
  bc:	4601      	mov	r1, r0
  be:	b128      	cbz	r0, cc <aes192_test+0xcc>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  c0:	4241      	negs	r1, r0
  c2:	4c21      	ldr	r4, [pc, #132]	; (148 <aes192_test+0x148>)
  c4:	4819      	ldr	r0, [pc, #100]	; (12c <aes192_test+0x12c>)
  c6:	f3c1 010a 	ubfx	r1, r1, #0, #11
  ca:	e7b7      	b.n	3c <aes192_test+0x3c>
    XMEMSET(plain, 0, AES_BLOCK_SIZE);
  cc:	2210      	movs	r2, #16
  ce:	a806      	add	r0, sp, #24
  d0:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));
  d4:	2310      	movs	r3, #16
  d6:	aa02      	add	r2, sp, #8
  d8:	a906      	add	r1, sp, #24
  da:	4628      	mov	r0, r5
  dc:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
    if (ret != 0)
  e0:	b128      	cbz	r0, ee <aes192_test+0xee>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  e2:	4240      	negs	r0, r0
  e4:	4911      	ldr	r1, [pc, #68]	; (12c <aes192_test+0x12c>)
  e6:	4c19      	ldr	r4, [pc, #100]	; (14c <aes192_test+0x14c>)
  e8:	f3c0 000a 	ubfx	r0, r0, #0, #11
  ec:	e7a6      	b.n	3c <aes192_test+0x3c>
    if (XMEMCMP(plain, msg, (int) sizeof(plain))) {
  ee:	4915      	ldr	r1, [pc, #84]	; (144 <aes192_test+0x144>)
  f0:	2210      	movs	r2, #16
  f2:	a806      	add	r0, sp, #24
  f4:	f7ff fffe 	bl	0 <memcmp>
  f8:	b988      	cbnz	r0, 11e <aes192_test+0x11e>
    if (XMEMCMP(cipher, verify, (int) sizeof(cipher)))
  fa:	4915      	ldr	r1, [pc, #84]	; (150 <aes192_test+0x150>)
  fc:	2210      	movs	r2, #16
  fe:	a802      	add	r0, sp, #8
 100:	f7ff fffe 	bl	0 <memcmp>
 104:	4604      	mov	r4, r0
 106:	b960      	cbnz	r0, 122 <aes192_test+0x122>
    wc_AesFree(enc);
 108:	4630      	mov	r0, r6
 10a:	f7ff fffe 	bl	0 <wc_AesFree>
    wc_AesFree(dec);
 10e:	4628      	mov	r0, r5
 110:	f7ff fffe 	bl	0 <wc_AesFree>
 114:	e794      	b.n	40 <aes192_test+0x40>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 116:	4c0f      	ldr	r4, [pc, #60]	; (154 <aes192_test+0x154>)
    return ret;
 118:	e799      	b.n	4e <aes192_test+0x4e>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 11a:	4c0f      	ldr	r4, [pc, #60]	; (158 <aes192_test+0x158>)
 11c:	e790      	b.n	40 <aes192_test+0x40>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 11e:	4c0f      	ldr	r4, [pc, #60]	; (15c <aes192_test+0x15c>)
 120:	e78e      	b.n	40 <aes192_test+0x40>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 122:	4c0f      	ldr	r4, [pc, #60]	; (160 <aes192_test+0x160>)
 124:	e78c      	b.n	40 <aes192_test+0x40>
 126:	bf00      	nop
 128:	dfffd2fe 	.word	0xdfffd2fe
 12c:	fffe7960 	.word	0xfffe7960
 130:	dfffd2fa 	.word	0xdfffd2fa
	...
 13c:	dfffd2f5 	.word	0xdfffd2f5
 140:	dfffd2f1 	.word	0xdfffd2f1
 144:	00000000 	.word	0x00000000
 148:	dfffd2e8 	.word	0xdfffd2e8
 14c:	dfffd2e0 	.word	0xdfffd2e0
 150:	00000000 	.word	0x00000000
 154:	ffffd307 	.word	0xffffd307
 158:	ffffd304 	.word	0xffffd304
 15c:	ffffd2de 	.word	0xffffd2de
 160:	ffffd2d9 	.word	0xffffd2d9

Disassembly of section .text.aes256_test:

00000000 <aes256_test>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   2:	f44f 709c 	mov.w	r0, #312	; 0x138
{
   6:	b08a      	sub	sp, #40	; 0x28
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   8:	f7ff fffe 	bl	0 <malloc>
   c:	4606      	mov	r6, r0
   e:	2800      	cmp	r0, #0
  10:	f000 8085 	beq.w	11e <aes256_test+0x11e>
    if ((dec = (Aes *)XMALLOC(sizeof *dec, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
  14:	f44f 709c 	mov.w	r0, #312	; 0x138
  18:	f7ff fffe 	bl	0 <malloc>
  1c:	4605      	mov	r5, r0
  1e:	2800      	cmp	r0, #0
  20:	d07f      	beq.n	122 <aes256_test+0x122>
    ret = wc_AesInit(enc, HEAP_HINT, devId);
  22:	2100      	movs	r1, #0
  24:	f06f 0201 	mvn.w	r2, #1
  28:	4630      	mov	r0, r6
  2a:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  2e:	4601      	mov	r1, r0
  30:	b138      	cbz	r0, 42 <aes256_test+0x42>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  32:	4241      	negs	r1, r0
  34:	4c3e      	ldr	r4, [pc, #248]	; (130 <aes256_test+0x130>)
  36:	483f      	ldr	r0, [pc, #252]	; (134 <aes256_test+0x134>)
  38:	f3c1 010a 	ubfx	r1, r1, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  3c:	fb01 4400 	mla	r4, r1, r0, r4
  40:	e00e      	b.n	60 <aes256_test+0x60>
    ret = wc_AesInit(dec, HEAP_HINT, devId);
  42:	f06f 0201 	mvn.w	r2, #1
  46:	4628      	mov	r0, r5
  48:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  4c:	b190      	cbz	r0, 74 <aes256_test+0x74>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  4e:	4244      	negs	r4, r0
  50:	4838      	ldr	r0, [pc, #224]	; (134 <aes256_test+0x134>)
  52:	f3c4 040a 	ubfx	r4, r4, #0, #11
  56:	4344      	muls	r4, r0
  58:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
  5c:	f5a4 5436 	sub.w	r4, r4, #11648	; 0x2d80
        XFREE(enc, HEAP_HINT, DYNAMIC_TYPE_AES);
  60:	4630      	mov	r0, r6
  62:	f7ff fffe 	bl	0 <free>
    if (dec)
  66:	b115      	cbz	r5, 6e <aes256_test+0x6e>
        XFREE(dec, HEAP_HINT, DYNAMIC_TYPE_AES);
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <free>
}
  6e:	4620      	mov	r0, r4
  70:	b00a      	add	sp, #40	; 0x28
  72:	bd70      	pop	{r4, r5, r6, pc}
    ret = wc_AesSetKey(enc, key, keySz, iv, AES_ENCRYPTION);
  74:	9000      	str	r0, [sp, #0]
  76:	4b30      	ldr	r3, [pc, #192]	; (138 <aes256_test+0x138>)
  78:	4930      	ldr	r1, [pc, #192]	; (13c <aes256_test+0x13c>)
  7a:	2220      	movs	r2, #32
  7c:	4630      	mov	r0, r6
  7e:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
  82:	b128      	cbz	r0, 90 <aes256_test+0x90>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  84:	4240      	negs	r0, r0
  86:	492b      	ldr	r1, [pc, #172]	; (134 <aes256_test+0x134>)
  88:	4c2d      	ldr	r4, [pc, #180]	; (140 <aes256_test+0x140>)
  8a:	f3c0 000a 	ubfx	r0, r0, #0, #11
  8e:	e7d5      	b.n	3c <aes256_test+0x3c>
    ret = wc_AesSetKey(dec, key, keySz, iv, AES_DECRYPTION);
  90:	2301      	movs	r3, #1
  92:	492a      	ldr	r1, [pc, #168]	; (13c <aes256_test+0x13c>)
  94:	9300      	str	r3, [sp, #0]
  96:	2220      	movs	r2, #32
  98:	4b27      	ldr	r3, [pc, #156]	; (138 <aes256_test+0x138>)
  9a:	4628      	mov	r0, r5
  9c:	f7ff fffe 	bl	0 <wc_AesSetKey>
    if (ret != 0)
  a0:	4601      	mov	r1, r0
  a2:	b128      	cbz	r0, b0 <aes256_test+0xb0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  a4:	4241      	negs	r1, r0
  a6:	4c27      	ldr	r4, [pc, #156]	; (144 <aes256_test+0x144>)
  a8:	4822      	ldr	r0, [pc, #136]	; (134 <aes256_test+0x134>)
  aa:	f3c1 010a 	ubfx	r1, r1, #0, #11
  ae:	e7c5      	b.n	3c <aes256_test+0x3c>
    XMEMSET(cipher, 0, AES_BLOCK_SIZE);
  b0:	2210      	movs	r2, #16
  b2:	a802      	add	r0, sp, #8
  b4:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcEncrypt(enc, cipher, msg, (int) sizeof(msg));
  b8:	a902      	add	r1, sp, #8
  ba:	4a23      	ldr	r2, [pc, #140]	; (148 <aes256_test+0x148>)
  bc:	2310      	movs	r3, #16
  be:	4630      	mov	r0, r6
  c0:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
    if (ret != 0)
  c4:	4601      	mov	r1, r0
  c6:	b128      	cbz	r0, d4 <aes256_test+0xd4>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  c8:	4241      	negs	r1, r0
  ca:	4c20      	ldr	r4, [pc, #128]	; (14c <aes256_test+0x14c>)
  cc:	4819      	ldr	r0, [pc, #100]	; (134 <aes256_test+0x134>)
  ce:	f3c1 010a 	ubfx	r1, r1, #0, #11
  d2:	e7b3      	b.n	3c <aes256_test+0x3c>
    XMEMSET(plain, 0, AES_BLOCK_SIZE);
  d4:	2210      	movs	r2, #16
  d6:	a806      	add	r0, sp, #24
  d8:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesCbcDecrypt(dec, plain, cipher, (int) sizeof(cipher));
  dc:	2310      	movs	r3, #16
  de:	aa02      	add	r2, sp, #8
  e0:	a906      	add	r1, sp, #24
  e2:	4628      	mov	r0, r5
  e4:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
    if (ret != 0)
  e8:	b128      	cbz	r0, f6 <aes256_test+0xf6>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  ea:	4240      	negs	r0, r0
  ec:	4911      	ldr	r1, [pc, #68]	; (134 <aes256_test+0x134>)
  ee:	4c18      	ldr	r4, [pc, #96]	; (150 <aes256_test+0x150>)
  f0:	f3c0 000a 	ubfx	r0, r0, #0, #11
  f4:	e7a2      	b.n	3c <aes256_test+0x3c>
    if (XMEMCMP(plain, msg, (int) sizeof(plain))) {
  f6:	4914      	ldr	r1, [pc, #80]	; (148 <aes256_test+0x148>)
  f8:	2210      	movs	r2, #16
  fa:	a806      	add	r0, sp, #24
  fc:	f7ff fffe 	bl	0 <memcmp>
 100:	b988      	cbnz	r0, 126 <aes256_test+0x126>
    if (XMEMCMP(cipher, verify, (int) sizeof(cipher)))
 102:	4914      	ldr	r1, [pc, #80]	; (154 <aes256_test+0x154>)
 104:	2210      	movs	r2, #16
 106:	a802      	add	r0, sp, #8
 108:	f7ff fffe 	bl	0 <memcmp>
 10c:	4604      	mov	r4, r0
 10e:	b960      	cbnz	r0, 12a <aes256_test+0x12a>
    wc_AesFree(enc);
 110:	4630      	mov	r0, r6
 112:	f7ff fffe 	bl	0 <wc_AesFree>
    wc_AesFree(dec);
 116:	4628      	mov	r0, r5
 118:	f7ff fffe 	bl	0 <wc_AesFree>
 11c:	e7a0      	b.n	60 <aes256_test+0x60>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 11e:	4c0e      	ldr	r4, [pc, #56]	; (158 <aes256_test+0x158>)
    return ret;
 120:	e7a5      	b.n	6e <aes256_test+0x6e>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 122:	4c0e      	ldr	r4, [pc, #56]	; (15c <aes256_test+0x15c>)
 124:	e79c      	b.n	60 <aes256_test+0x60>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 126:	4c0e      	ldr	r4, [pc, #56]	; (160 <aes256_test+0x160>)
 128:	e79a      	b.n	60 <aes256_test+0x60>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 12a:	4c0e      	ldr	r4, [pc, #56]	; (164 <aes256_test+0x164>)
 12c:	e798      	b.n	60 <aes256_test+0x60>
 12e:	bf00      	nop
 130:	dfffd284 	.word	0xdfffd284
 134:	fffe7960 	.word	0xfffe7960
	...
 140:	dfffd27b 	.word	0xdfffd27b
 144:	dfffd277 	.word	0xdfffd277
 148:	00000000 	.word	0x00000000
 14c:	dfffd26e 	.word	0xdfffd26e
 150:	dfffd266 	.word	0xdfffd266
 154:	00000000 	.word	0x00000000
 158:	ffffd28d 	.word	0xffffd28d
 15c:	ffffd28a 	.word	0xffffd28a
 160:	ffffd264 	.word	0xffffd264
 164:	ffffd25f 	.word	0xffffd25f

Disassembly of section .text.aesgcm_default_test:

00000000 <aesgcm_default_test>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    byte key1[] = {
   4:	4b64      	ldr	r3, [pc, #400]	; (198 <aesgcm_default_test+0x198>)
{
   6:	b0c2      	sub	sp, #264	; 0x108
    byte key1[] = {
   8:	aa12      	add	r2, sp, #72	; 0x48
   a:	f103 0510 	add.w	r5, r3, #16
   e:	4617      	mov	r7, r2
  10:	6818      	ldr	r0, [r3, #0]
  12:	6859      	ldr	r1, [r3, #4]
  14:	4614      	mov	r4, r2
  16:	c403      	stmia	r4!, {r0, r1}
  18:	3308      	adds	r3, #8
  1a:	42ab      	cmp	r3, r5
  1c:	4622      	mov	r2, r4
  1e:	d1f7      	bne.n	10 <aesgcm_default_test+0x10>
    byte iv1[] = {
  20:	4a5e      	ldr	r2, [pc, #376]	; (19c <aesgcm_default_test+0x19c>)
  22:	6810      	ldr	r0, [r2, #0]
  24:	6851      	ldr	r1, [r2, #4]
  26:	ab06      	add	r3, sp, #24
  28:	c303      	stmia	r3!, {r0, r1}
  2a:	6890      	ldr	r0, [r2, #8]
  2c:	6018      	str	r0, [r3, #0]
    ALIGN64 byte plain1[] = {
  2e:	4b5c      	ldr	r3, [pc, #368]	; (1a0 <aesgcm_default_test+0x1a0>)
  30:	ac32      	add	r4, sp, #200	; 0xc8
  32:	f103 0620 	add.w	r6, r3, #32
  36:	4622      	mov	r2, r4
  38:	6818      	ldr	r0, [r3, #0]
  3a:	6859      	ldr	r1, [r3, #4]
  3c:	4625      	mov	r5, r4
  3e:	c503      	stmia	r5!, {r0, r1}
  40:	3308      	adds	r3, #8
  42:	42b3      	cmp	r3, r6
  44:	462c      	mov	r4, r5
  46:	d1f7      	bne.n	38 <aesgcm_default_test+0x38>
    byte aad1[] = {
  48:	4b56      	ldr	r3, [pc, #344]	; (1a4 <aesgcm_default_test+0x1a4>)
  4a:	ac16      	add	r4, sp, #88	; 0x58
  4c:	f103 0610 	add.w	r6, r3, #16
  50:	46a6      	mov	lr, r4
  52:	6818      	ldr	r0, [r3, #0]
  54:	6859      	ldr	r1, [r3, #4]
  56:	4625      	mov	r5, r4
  58:	c503      	stmia	r5!, {r0, r1}
  5a:	3308      	adds	r3, #8
  5c:	42b3      	cmp	r3, r6
  5e:	462c      	mov	r4, r5
  60:	d1f7      	bne.n	52 <aesgcm_default_test+0x52>
    ALIGN64 byte cipher1[] = {
  62:	4b51      	ldr	r3, [pc, #324]	; (1a8 <aesgcm_default_test+0x1a8>)
  64:	ac3a      	add	r4, sp, #232	; 0xe8
  66:	f103 0620 	add.w	r6, r3, #32
  6a:	46a4      	mov	ip, r4
  6c:	6818      	ldr	r0, [r3, #0]
  6e:	6859      	ldr	r1, [r3, #4]
  70:	4625      	mov	r5, r4
  72:	c503      	stmia	r5!, {r0, r1}
  74:	3308      	adds	r3, #8
  76:	42b3      	cmp	r3, r6
  78:	462c      	mov	r4, r5
  7a:	d1f7      	bne.n	6c <aesgcm_default_test+0x6c>
    byte tag1[] = {
  7c:	4b4b      	ldr	r3, [pc, #300]	; (1ac <aesgcm_default_test+0x1ac>)
  7e:	ac1a      	add	r4, sp, #104	; 0x68
  80:	f103 0610 	add.w	r6, r3, #16
  84:	46a0      	mov	r8, r4
  86:	6818      	ldr	r0, [r3, #0]
  88:	6859      	ldr	r1, [r3, #4]
  8a:	4625      	mov	r5, r4
  8c:	c503      	stmia	r5!, {r0, r1}
  8e:	3308      	adds	r3, #8
  90:	42b3      	cmp	r3, r6
  92:	462c      	mov	r4, r5
  94:	d1f7      	bne.n	86 <aesgcm_default_test+0x86>
    byte key2[] = {
  96:	4b46      	ldr	r3, [pc, #280]	; (1b0 <aesgcm_default_test+0x1b0>)
  98:	ac1e      	add	r4, sp, #120	; 0x78
  9a:	f103 0910 	add.w	r9, r3, #16
  9e:	4625      	mov	r5, r4
  a0:	6818      	ldr	r0, [r3, #0]
  a2:	6859      	ldr	r1, [r3, #4]
  a4:	4626      	mov	r6, r4
  a6:	c603      	stmia	r6!, {r0, r1}
  a8:	3308      	adds	r3, #8
  aa:	454b      	cmp	r3, r9
  ac:	4634      	mov	r4, r6
  ae:	d1f7      	bne.n	a0 <aesgcm_default_test+0xa0>
    byte iv2[] = {
  b0:	4c40      	ldr	r4, [pc, #256]	; (1b4 <aesgcm_default_test+0x1b4>)
  b2:	6820      	ldr	r0, [r4, #0]
  b4:	6861      	ldr	r1, [r4, #4]
  b6:	ab09      	add	r3, sp, #36	; 0x24
  b8:	c303      	stmia	r3!, {r0, r1}
  ba:	68a0      	ldr	r0, [r4, #8]
  bc:	6018      	str	r0, [r3, #0]
    ALIGN64 byte plain2[] = {
  be:	4b3e      	ldr	r3, [pc, #248]	; (1b8 <aesgcm_default_test+0x1b8>)
  c0:	ae22      	add	r6, sp, #136	; 0x88
  c2:	f103 0910 	add.w	r9, r3, #16
  c6:	6818      	ldr	r0, [r3, #0]
  c8:	6859      	ldr	r1, [r3, #4]
  ca:	4634      	mov	r4, r6
  cc:	c403      	stmia	r4!, {r0, r1}
  ce:	3308      	adds	r3, #8
  d0:	454b      	cmp	r3, r9
  d2:	4626      	mov	r6, r4
  d4:	d1f7      	bne.n	c6 <aesgcm_default_test+0xc6>
    ALIGN64 byte cipher2[] = {
  d6:	4b39      	ldr	r3, [pc, #228]	; (1bc <aesgcm_default_test+0x1bc>)
  d8:	ae26      	add	r6, sp, #152	; 0x98
  da:	f103 0910 	add.w	r9, r3, #16
  de:	6818      	ldr	r0, [r3, #0]
  e0:	6859      	ldr	r1, [r3, #4]
  e2:	4634      	mov	r4, r6
  e4:	c403      	stmia	r4!, {r0, r1}
  e6:	3308      	adds	r3, #8
  e8:	454b      	cmp	r3, r9
  ea:	4626      	mov	r6, r4
  ec:	d1f7      	bne.n	de <aesgcm_default_test+0xde>
    byte tag2[] = {
  ee:	4b34      	ldr	r3, [pc, #208]	; (1c0 <aesgcm_default_test+0x1c0>)
  f0:	ac2a      	add	r4, sp, #168	; 0xa8
  f2:	f103 0a10 	add.w	sl, r3, #16
  f6:	4626      	mov	r6, r4
  f8:	6818      	ldr	r0, [r3, #0]
  fa:	6859      	ldr	r1, [r3, #4]
  fc:	46a1      	mov	r9, r4
  fe:	e8a9 0003 	stmia.w	r9!, {r0, r1}
 102:	3308      	adds	r3, #8
 104:	4553      	cmp	r3, sl
 106:	464c      	mov	r4, r9
 108:	d1f6      	bne.n	f8 <aesgcm_default_test+0xf8>
    byte key3[] = {
 10a:	4b2e      	ldr	r3, [pc, #184]	; (1c4 <aesgcm_default_test+0x1c4>)
 10c:	f10d 09b8 	add.w	r9, sp, #184	; 0xb8
 110:	f103 0a10 	add.w	sl, r3, #16
 114:	6818      	ldr	r0, [r3, #0]
 116:	6859      	ldr	r1, [r3, #4]
 118:	464c      	mov	r4, r9
 11a:	c403      	stmia	r4!, {r0, r1}
 11c:	3308      	adds	r3, #8
 11e:	4553      	cmp	r3, sl
 120:	46a1      	mov	r9, r4
 122:	d1f7      	bne.n	114 <aesgcm_default_test+0x114>
    byte iv3[] = {
 124:	4c28      	ldr	r4, [pc, #160]	; (1c8 <aesgcm_default_test+0x1c8>)
 126:	6820      	ldr	r0, [r4, #0]
 128:	6861      	ldr	r1, [r4, #4]
 12a:	ab0c      	add	r3, sp, #48	; 0x30
 12c:	c303      	stmia	r3!, {r0, r1}
 12e:	68a0      	ldr	r0, [r4, #8]
    byte tag3[] = {
 130:	4c26      	ldr	r4, [pc, #152]	; (1cc <aesgcm_default_test+0x1cc>)
    byte iv3[] = {
 132:	6018      	str	r0, [r3, #0]
    byte tag3[] = {
 134:	6861      	ldr	r1, [r4, #4]
 136:	6820      	ldr	r0, [r4, #0]
 138:	ab0f      	add	r3, sp, #60	; 0x3c
 13a:	c303      	stmia	r3!, {r0, r1}
 13c:	68a0      	ldr	r0, [r4, #8]
 13e:	6018      	str	r0, [r3, #0]
    ret = aesgcm_default_test_helper(key1, sizeof(key1), iv1, sizeof(iv1),
 140:	2410      	movs	r4, #16
 142:	2320      	movs	r3, #32
 144:	e9cd 8404 	strd	r8, r4, [sp, #16]
 148:	e9cd e402 	strd	lr, r4, [sp, #8]
 14c:	e9cd c300 	strd	ip, r3, [sp]
 150:	a906      	add	r1, sp, #24
 152:	4638      	mov	r0, r7
 154:	f7ff fffe 	bl	0 <aesgcm_default_test>
    if (ret != 0) {
 158:	b9d8      	cbnz	r0, 192 <aesgcm_default_test+0x192>
    ret = aesgcm_default_test_helper(key2, sizeof(key2), iv2, sizeof(iv2),
 15a:	ab26      	add	r3, sp, #152	; 0x98
 15c:	e9cd 0002 	strd	r0, r0, [sp, #8]
 160:	9300      	str	r3, [sp, #0]
 162:	e9cd 6404 	strd	r6, r4, [sp, #16]
 166:	9401      	str	r4, [sp, #4]
 168:	4623      	mov	r3, r4
 16a:	aa22      	add	r2, sp, #136	; 0x88
 16c:	a909      	add	r1, sp, #36	; 0x24
 16e:	4628      	mov	r0, r5
 170:	f7ff fffe 	bl	0 <aesgcm_default_test>
    if (ret != 0) {
 174:	b968      	cbnz	r0, 192 <aesgcm_default_test+0x192>
    ret = aesgcm_default_test_helper(key3, sizeof(key3), iv3, sizeof(iv3),
 176:	230c      	movs	r3, #12
 178:	9305      	str	r3, [sp, #20]
 17a:	ab0f      	add	r3, sp, #60	; 0x3c
 17c:	e9cd 0303 	strd	r0, r3, [sp, #12]
 180:	e9cd 0001 	strd	r0, r0, [sp, #4]
 184:	9000      	str	r0, [sp, #0]
 186:	4603      	mov	r3, r0
 188:	4602      	mov	r2, r0
 18a:	a90c      	add	r1, sp, #48	; 0x30
 18c:	a82e      	add	r0, sp, #184	; 0xb8
 18e:	f7ff fffe 	bl	0 <aesgcm_default_test>
}
 192:	b042      	add	sp, #264	; 0x108
 194:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 198:	00000000 	.word	0x00000000
 19c:	00000011 	.word	0x00000011
 1a0:	0000001e 	.word	0x0000001e
 1a4:	0000003f 	.word	0x0000003f
 1a8:	00000050 	.word	0x00000050
 1ac:	00000071 	.word	0x00000071
 1b0:	00000082 	.word	0x00000082
 1b4:	00000093 	.word	0x00000093
 1b8:	000000a0 	.word	0x000000a0
 1bc:	000000b1 	.word	0x000000b1
 1c0:	000000c2 	.word	0x000000c2
 1c4:	000000d3 	.word	0x000000d3
 1c8:	000000e4 	.word	0x000000e4
 1cc:	000000f1 	.word	0x000000f1

Disassembly of section .text.aesgcm_test:

00000000 <aesgcm_test>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   4:	f44f 709c 	mov.w	r0, #312	; 0x138
{
   8:	b0bb      	sub	sp, #236	; 0xec
    if ((enc = (Aes *)XMALLOC(sizeof *enc, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   a:	f7ff fffe 	bl	0 <malloc>
   e:	4604      	mov	r4, r0
  10:	2800      	cmp	r0, #0
  12:	f000 8327 	beq.w	664 <aesgcm_test+0x664>
    if ((dec = (Aes *)XMALLOC(sizeof *dec, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
  16:	f44f 709c 	mov.w	r0, #312	; 0x138
  1a:	f7ff fffe 	bl	0 <malloc>
  1e:	4605      	mov	r5, r0
  20:	2800      	cmp	r0, #0
  22:	f000 8321 	beq.w	668 <aesgcm_test+0x668>
    XMEMSET(resultT, 0, sizeof(resultT));
  26:	2220      	movs	r2, #32
  28:	2100      	movs	r1, #0
  2a:	a80c      	add	r0, sp, #48	; 0x30
  2c:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultC, 0, sizeof(resultC));
  30:	224c      	movs	r2, #76	; 0x4c
  32:	2100      	movs	r1, #0
  34:	a827      	add	r0, sp, #156	; 0x9c
  36:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultP, 0, sizeof(resultP));
  3a:	224c      	movs	r2, #76	; 0x4c
  3c:	2100      	movs	r1, #0
  3e:	a814      	add	r0, sp, #80	; 0x50
  40:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesInit(enc, HEAP_HINT, devId);
  44:	2100      	movs	r1, #0
  46:	f06f 0201 	mvn.w	r2, #1
  4a:	4620      	mov	r0, r4
  4c:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  50:	4601      	mov	r1, r0
  52:	b138      	cbz	r0, 64 <aesgcm_test+0x64>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  54:	4241      	negs	r1, r0
  56:	4eb5      	ldr	r6, [pc, #724]	; (32c <aesgcm_test+0x32c>)
  58:	48b5      	ldr	r0, [pc, #724]	; (330 <aesgcm_test+0x330>)
  5a:	f3c1 010a 	ubfx	r1, r1, #0, #11
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  5e:	fb01 6600 	mla	r6, r1, r0, r6
  62:	e26a      	b.n	53a <aesgcm_test+0x53a>
    ret = wc_AesInit(dec, HEAP_HINT, devId);
  64:	f06f 0201 	mvn.w	r2, #1
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret != 0)
  6e:	b128      	cbz	r0, 7c <aesgcm_test+0x7c>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  70:	4240      	negs	r0, r0
  72:	49af      	ldr	r1, [pc, #700]	; (330 <aesgcm_test+0x330>)
  74:	4eaf      	ldr	r6, [pc, #700]	; (334 <aesgcm_test+0x334>)
  76:	f3c0 000a 	ubfx	r0, r0, #0, #11
  7a:	e7f0      	b.n	5e <aesgcm_test+0x5e>
    ret = wc_AesGcmSetKey(enc, k1, k1Sz);
  7c:	49ae      	ldr	r1, [pc, #696]	; (338 <aesgcm_test+0x338>)
  7e:	2220      	movs	r2, #32
  80:	4620      	mov	r0, r4
  82:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    if (ret != 0)
  86:	b128      	cbz	r0, 94 <aesgcm_test+0x94>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  88:	4240      	negs	r0, r0
  8a:	49a9      	ldr	r1, [pc, #676]	; (330 <aesgcm_test+0x330>)
  8c:	4eab      	ldr	r6, [pc, #684]	; (33c <aesgcm_test+0x33c>)
  8e:	f3c0 000a 	ubfx	r0, r0, #0, #11
  92:	e7e4      	b.n	5e <aesgcm_test+0x5e>
    ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), iv1, sizeof(iv1),
  94:	ab0c      	add	r3, sp, #48	; 0x30
  96:	f8df 92a8 	ldr.w	r9, [pc, #680]	; 340 <aesgcm_test+0x340>
  9a:	4eaa      	ldr	r6, [pc, #680]	; (344 <aesgcm_test+0x344>)
  9c:	9302      	str	r3, [sp, #8]
  9e:	f04f 0a14 	mov.w	sl, #20
  a2:	2710      	movs	r7, #16
  a4:	f04f 080c 	mov.w	r8, #12
  a8:	4aa7      	ldr	r2, [pc, #668]	; (348 <aesgcm_test+0x348>)
  aa:	f8cd a014 	str.w	sl, [sp, #20]
  ae:	f8cd 9010 	str.w	r9, [sp, #16]
  b2:	9703      	str	r7, [sp, #12]
  b4:	f8cd 8004 	str.w	r8, [sp, #4]
  b8:	9600      	str	r6, [sp, #0]
  ba:	233c      	movs	r3, #60	; 0x3c
  bc:	a927      	add	r1, sp, #156	; 0x9c
  be:	4620      	mov	r0, r4
  c0:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
    if (ret != 0)
  c4:	b128      	cbz	r0, d2 <aesgcm_test+0xd2>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  c6:	4240      	negs	r0, r0
  c8:	4999      	ldr	r1, [pc, #612]	; (330 <aesgcm_test+0x330>)
  ca:	4ea0      	ldr	r6, [pc, #640]	; (34c <aesgcm_test+0x34c>)
  cc:	f3c0 000a 	ubfx	r0, r0, #0, #11
  d0:	e7c5      	b.n	5e <aesgcm_test+0x5e>
    if (XMEMCMP(c1, resultC, sizeof(c1)))
  d2:	489f      	ldr	r0, [pc, #636]	; (350 <aesgcm_test+0x350>)
  d4:	223c      	movs	r2, #60	; 0x3c
  d6:	a927      	add	r1, sp, #156	; 0x9c
  d8:	f7ff fffe 	bl	0 <memcmp>
  dc:	2800      	cmp	r0, #0
  de:	f040 82c5 	bne.w	66c <aesgcm_test+0x66c>
    if (XMEMCMP(t1, resultT, sizeof(t1)))
  e2:	489c      	ldr	r0, [pc, #624]	; (354 <aesgcm_test+0x354>)
  e4:	463a      	mov	r2, r7
  e6:	a90c      	add	r1, sp, #48	; 0x30
  e8:	f7ff fffe 	bl	0 <memcmp>
  ec:	2800      	cmp	r0, #0
  ee:	f040 82f3 	bne.w	6d8 <aesgcm_test+0x6d8>
    ret = wc_AesGcmSetKey(dec, k1, k1Sz);
  f2:	4991      	ldr	r1, [pc, #580]	; (338 <aesgcm_test+0x338>)
  f4:	2220      	movs	r2, #32
  f6:	4628      	mov	r0, r5
  f8:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    if (ret != 0)
  fc:	b128      	cbz	r0, 10a <aesgcm_test+0x10a>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  fe:	4240      	negs	r0, r0
 100:	498b      	ldr	r1, [pc, #556]	; (330 <aesgcm_test+0x330>)
 102:	4e95      	ldr	r6, [pc, #596]	; (358 <aesgcm_test+0x358>)
 104:	f3c0 000a 	ubfx	r0, r0, #0, #11
 108:	e7a9      	b.n	5e <aesgcm_test+0x5e>
    ret = wc_AesGcmDecrypt(dec, resultP, resultC, sizeof(c1),
 10a:	ab0c      	add	r3, sp, #48	; 0x30
 10c:	e9cd 8301 	strd	r8, r3, [sp, #4]
 110:	e9cd 9a04 	strd	r9, sl, [sp, #16]
 114:	9703      	str	r7, [sp, #12]
 116:	9600      	str	r6, [sp, #0]
 118:	233c      	movs	r3, #60	; 0x3c
 11a:	aa27      	add	r2, sp, #156	; 0x9c
 11c:	a914      	add	r1, sp, #80	; 0x50
 11e:	4628      	mov	r0, r5
 120:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
    if (ret != 0)
 124:	b128      	cbz	r0, 132 <aesgcm_test+0x132>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 126:	4240      	negs	r0, r0
 128:	4981      	ldr	r1, [pc, #516]	; (330 <aesgcm_test+0x330>)
 12a:	4e8c      	ldr	r6, [pc, #560]	; (35c <aesgcm_test+0x35c>)
 12c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 130:	e795      	b.n	5e <aesgcm_test+0x5e>
    if (XMEMCMP(p, resultP, sizeof(p)))
 132:	4885      	ldr	r0, [pc, #532]	; (348 <aesgcm_test+0x348>)
 134:	223c      	movs	r2, #60	; 0x3c
 136:	a914      	add	r1, sp, #80	; 0x50
 138:	f7ff fffe 	bl	0 <memcmp>
 13c:	2800      	cmp	r0, #0
 13e:	f040 82cd 	bne.w	6dc <aesgcm_test+0x6dc>
         ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), k1,
 142:	f8df 91fc 	ldr.w	r9, [pc, #508]	; 340 <aesgcm_test+0x340>
 146:	f8df a1f0 	ldr.w	sl, [pc, #496]	; 338 <aesgcm_test+0x338>
    for (ivlen=1; ivlen<k1Sz; ivlen++) {
 14a:	2701      	movs	r7, #1
         ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), k1,
 14c:	f04f 0b14 	mov.w	fp, #20
 150:	f04f 0810 	mov.w	r8, #16
 154:	ae0c      	add	r6, sp, #48	; 0x30
 156:	e9cd 9b04 	strd	r9, fp, [sp, #16]
 15a:	e9cd 7601 	strd	r7, r6, [sp, #4]
 15e:	4a7a      	ldr	r2, [pc, #488]	; (348 <aesgcm_test+0x348>)
 160:	f8cd 800c 	str.w	r8, [sp, #12]
 164:	f8cd a000 	str.w	sl, [sp]
 168:	233c      	movs	r3, #60	; 0x3c
 16a:	a927      	add	r1, sp, #156	; 0x9c
 16c:	4620      	mov	r0, r4
 16e:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        if (ret != 0)
 172:	b128      	cbz	r0, 180 <aesgcm_test+0x180>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 174:	4240      	negs	r0, r0
 176:	496e      	ldr	r1, [pc, #440]	; (330 <aesgcm_test+0x330>)
 178:	4e79      	ldr	r6, [pc, #484]	; (360 <aesgcm_test+0x360>)
 17a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 17e:	e76e      	b.n	5e <aesgcm_test+0x5e>
        ret = wc_AesGcmDecrypt(dec, resultP, resultC, sizeof(c1), k1,
 180:	e9cd 6802 	strd	r6, r8, [sp, #8]
 184:	e9cd 9b04 	strd	r9, fp, [sp, #16]
 188:	e9cd a700 	strd	sl, r7, [sp]
 18c:	233c      	movs	r3, #60	; 0x3c
 18e:	aa27      	add	r2, sp, #156	; 0x9c
 190:	a914      	add	r1, sp, #80	; 0x50
 192:	4628      	mov	r0, r5
 194:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        if (ret != 0)
 198:	4606      	mov	r6, r0
 19a:	b128      	cbz	r0, 1a8 <aesgcm_test+0x1a8>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 19c:	4246      	negs	r6, r0
 19e:	f3c6 000a 	ubfx	r0, r6, #0, #11
 1a2:	4963      	ldr	r1, [pc, #396]	; (330 <aesgcm_test+0x330>)
 1a4:	4e6f      	ldr	r6, [pc, #444]	; (364 <aesgcm_test+0x364>)
 1a6:	e75a      	b.n	5e <aesgcm_test+0x5e>
    for (ivlen=1; ivlen<k1Sz; ivlen++) {
 1a8:	3701      	adds	r7, #1
 1aa:	2f20      	cmp	r7, #32
 1ac:	d1ce      	bne.n	14c <aesgcm_test+0x14c>
         ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), iv1,
 1ae:	f8df 9198 	ldr.w	r9, [pc, #408]	; 348 <aesgcm_test+0x348>
 1b2:	f8df a190 	ldr.w	sl, [pc, #400]	; 344 <aesgcm_test+0x344>
 1b6:	4a64      	ldr	r2, [pc, #400]	; (348 <aesgcm_test+0x348>)
 1b8:	f8cd 800c 	str.w	r8, [sp, #12]
 1bc:	af0c      	add	r7, sp, #48	; 0x30
 1be:	f04f 0b0c 	mov.w	fp, #12
 1c2:	e9cd 9604 	strd	r9, r6, [sp, #16]
 1c6:	e9cd ab00 	strd	sl, fp, [sp]
 1ca:	9702      	str	r7, [sp, #8]
 1cc:	233c      	movs	r3, #60	; 0x3c
 1ce:	a927      	add	r1, sp, #156	; 0x9c
 1d0:	4620      	mov	r0, r4
 1d2:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        if (ret != 0)
 1d6:	b128      	cbz	r0, 1e4 <aesgcm_test+0x1e4>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 1d8:	4240      	negs	r0, r0
 1da:	4955      	ldr	r1, [pc, #340]	; (330 <aesgcm_test+0x330>)
 1dc:	4e62      	ldr	r6, [pc, #392]	; (368 <aesgcm_test+0x368>)
 1de:	f3c0 000a 	ubfx	r0, r0, #0, #11
 1e2:	e73c      	b.n	5e <aesgcm_test+0x5e>
        ret = wc_AesGcmDecrypt(dec, resultP, resultC, sizeof(c1), iv1,
 1e4:	e9cd 9604 	strd	r9, r6, [sp, #16]
 1e8:	e9cd 7802 	strd	r7, r8, [sp, #8]
 1ec:	e9cd ab00 	strd	sl, fp, [sp]
 1f0:	233c      	movs	r3, #60	; 0x3c
 1f2:	aa27      	add	r2, sp, #156	; 0x9c
 1f4:	a914      	add	r1, sp, #80	; 0x50
 1f6:	4628      	mov	r0, r5
 1f8:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        if (ret != 0)
 1fc:	b128      	cbz	r0, 20a <aesgcm_test+0x20a>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 1fe:	4240      	negs	r0, r0
 200:	494b      	ldr	r1, [pc, #300]	; (330 <aesgcm_test+0x330>)
 202:	4e5a      	ldr	r6, [pc, #360]	; (36c <aesgcm_test+0x36c>)
 204:	f3c0 000a 	ubfx	r0, r0, #0, #11
 208:	e729      	b.n	5e <aesgcm_test+0x5e>
    for (alen=0; alen<(int)sizeof(p); alen++) {
 20a:	3601      	adds	r6, #1
 20c:	2e3c      	cmp	r6, #60	; 0x3c
 20e:	d1d2      	bne.n	1b6 <aesgcm_test+0x1b6>
         ret = wc_AesGcmEncrypt(enc, resultC, p, (word32)plen, iv1,
 210:	f8df a130 	ldr.w	sl, [pc, #304]	; 344 <aesgcm_test+0x344>
    for (plen=1; plen<(int)sizeof(p); plen++) {
 214:	f04f 0801 	mov.w	r8, #1
         ret = wc_AesGcmEncrypt(enc, resultC, p, (word32)plen, iv1,
 218:	4b49      	ldr	r3, [pc, #292]	; (340 <aesgcm_test+0x340>)
 21a:	9304      	str	r3, [sp, #16]
 21c:	f04f 0914 	mov.w	r9, #20
 220:	2610      	movs	r6, #16
 222:	af0c      	add	r7, sp, #48	; 0x30
 224:	f04f 0b0c 	mov.w	fp, #12
 228:	e9cd ab00 	strd	sl, fp, [sp]
 22c:	4a46      	ldr	r2, [pc, #280]	; (348 <aesgcm_test+0x348>)
 22e:	f8cd 9014 	str.w	r9, [sp, #20]
 232:	9603      	str	r6, [sp, #12]
 234:	9702      	str	r7, [sp, #8]
 236:	4643      	mov	r3, r8
 238:	a927      	add	r1, sp, #156	; 0x9c
 23a:	4620      	mov	r0, r4
 23c:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        if (ret != 0)
 240:	b128      	cbz	r0, 24e <aesgcm_test+0x24e>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 242:	4240      	negs	r0, r0
 244:	493a      	ldr	r1, [pc, #232]	; (330 <aesgcm_test+0x330>)
 246:	4e4a      	ldr	r6, [pc, #296]	; (370 <aesgcm_test+0x370>)
 248:	f3c0 000a 	ubfx	r0, r0, #0, #11
 24c:	e707      	b.n	5e <aesgcm_test+0x5e>
        ret = wc_AesGcmDecrypt(dec, resultP, resultC, (word32)plen, iv1,
 24e:	4b3c      	ldr	r3, [pc, #240]	; (340 <aesgcm_test+0x340>)
 250:	f8cd 9014 	str.w	r9, [sp, #20]
 254:	e9cd 6303 	strd	r6, r3, [sp, #12]
 258:	e9cd b701 	strd	fp, r7, [sp, #4]
 25c:	f8cd a000 	str.w	sl, [sp]
 260:	4643      	mov	r3, r8
 262:	aa27      	add	r2, sp, #156	; 0x9c
 264:	a914      	add	r1, sp, #80	; 0x50
 266:	4628      	mov	r0, r5
 268:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        if (ret != 0)
 26c:	4683      	mov	fp, r0
 26e:	b128      	cbz	r0, 27c <aesgcm_test+0x27c>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 270:	4240      	negs	r0, r0
 272:	492f      	ldr	r1, [pc, #188]	; (330 <aesgcm_test+0x330>)
 274:	4e3f      	ldr	r6, [pc, #252]	; (374 <aesgcm_test+0x374>)
 276:	f3c0 000a 	ubfx	r0, r0, #0, #11
 27a:	e6f0      	b.n	5e <aesgcm_test+0x5e>
    for (plen=1; plen<(int)sizeof(p); plen++) {
 27c:	f108 0801 	add.w	r8, r8, #1
 280:	f1b8 0f3c 	cmp.w	r8, #60	; 0x3c
 284:	d1c8      	bne.n	218 <aesgcm_test+0x218>
    XMEMSET(resultT, 0, sizeof(resultT));
 286:	4601      	mov	r1, r0
 288:	2220      	movs	r2, #32
 28a:	4638      	mov	r0, r7
 28c:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultC, 0, sizeof(resultC));
 290:	224c      	movs	r2, #76	; 0x4c
 292:	4659      	mov	r1, fp
 294:	a827      	add	r0, sp, #156	; 0x9c
 296:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultP, 0, sizeof(resultP));
 29a:	224c      	movs	r2, #76	; 0x4c
 29c:	4659      	mov	r1, fp
 29e:	a814      	add	r0, sp, #80	; 0x50
 2a0:	f7ff fffe 	bl	0 <memset>
    wc_AesGcmSetKey(enc, k2, sizeof(k2));
 2a4:	4934      	ldr	r1, [pc, #208]	; (378 <aesgcm_test+0x378>)
    ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), iv2, sizeof(iv2),
 2a6:	f8df a0d4 	ldr.w	sl, [pc, #212]	; 37c <aesgcm_test+0x37c>
    wc_AesGcmSetKey(enc, k2, sizeof(k2));
 2aa:	2218      	movs	r2, #24
 2ac:	4620      	mov	r0, r4
 2ae:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), iv2, sizeof(iv2),
 2b2:	4b23      	ldr	r3, [pc, #140]	; (340 <aesgcm_test+0x340>)
 2b4:	4a24      	ldr	r2, [pc, #144]	; (348 <aesgcm_test+0x348>)
 2b6:	f8cd 9014 	str.w	r9, [sp, #20]
 2ba:	e9cd 6303 	strd	r6, r3, [sp, #12]
 2be:	e9cd 8701 	strd	r8, r7, [sp, #4]
 2c2:	f8cd a000 	str.w	sl, [sp]
 2c6:	4643      	mov	r3, r8
 2c8:	a927      	add	r1, sp, #156	; 0x9c
 2ca:	4620      	mov	r0, r4
 2cc:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
    if (ret != 0)
 2d0:	b128      	cbz	r0, 2de <aesgcm_test+0x2de>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 2d2:	4240      	negs	r0, r0
 2d4:	4916      	ldr	r1, [pc, #88]	; (330 <aesgcm_test+0x330>)
 2d6:	4e2a      	ldr	r6, [pc, #168]	; (380 <aesgcm_test+0x380>)
 2d8:	f3c0 000a 	ubfx	r0, r0, #0, #11
 2dc:	e6bf      	b.n	5e <aesgcm_test+0x5e>
    if (XMEMCMP(c2, resultC, sizeof(c2)))
 2de:	4829      	ldr	r0, [pc, #164]	; (384 <aesgcm_test+0x384>)
 2e0:	4642      	mov	r2, r8
 2e2:	a927      	add	r1, sp, #156	; 0x9c
 2e4:	f7ff fffe 	bl	0 <memcmp>
 2e8:	2800      	cmp	r0, #0
 2ea:	f040 81f9 	bne.w	6e0 <aesgcm_test+0x6e0>
    if (XMEMCMP(t2, resultT, sizeof(t1)))
 2ee:	4826      	ldr	r0, [pc, #152]	; (388 <aesgcm_test+0x388>)
 2f0:	4632      	mov	r2, r6
 2f2:	4639      	mov	r1, r7
 2f4:	f7ff fffe 	bl	0 <memcmp>
 2f8:	2800      	cmp	r0, #0
 2fa:	f040 81f3 	bne.w	6e4 <aesgcm_test+0x6e4>
    ret = wc_AesGcmDecrypt(enc, resultP, resultC, sizeof(c1),
 2fe:	4b10      	ldr	r3, [pc, #64]	; (340 <aesgcm_test+0x340>)
 300:	f8cd 9014 	str.w	r9, [sp, #20]
 304:	e9cd 6303 	strd	r6, r3, [sp, #12]
 308:	e9cd 8701 	strd	r8, r7, [sp, #4]
 30c:	f8cd a000 	str.w	sl, [sp]
 310:	4643      	mov	r3, r8
 312:	aa27      	add	r2, sp, #156	; 0x9c
 314:	a914      	add	r1, sp, #80	; 0x50
 316:	4620      	mov	r0, r4
 318:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
    if (ret != 0)
 31c:	b3c0      	cbz	r0, 390 <aesgcm_test+0x390>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 31e:	4240      	negs	r0, r0
 320:	4903      	ldr	r1, [pc, #12]	; (330 <aesgcm_test+0x330>)
 322:	4e1a      	ldr	r6, [pc, #104]	; (38c <aesgcm_test+0x38c>)
 324:	f3c0 000a 	ubfx	r0, r0, #0, #11
 328:	e699      	b.n	5e <aesgcm_test+0x5e>
 32a:	bf00      	nop
 32c:	dfffd08b 	.word	0xdfffd08b
 330:	fffe7960 	.word	0xfffe7960
 334:	dfffd088 	.word	0xdfffd088
 338:	00000000 	.word	0x00000000
 33c:	dfffd083 	.word	0xdfffd083
	...
 34c:	dfffd07a 	.word	0xdfffd07a
	...
 358:	dfffd06f 	.word	0xdfffd06f
 35c:	dfffd067 	.word	0xdfffd067
 360:	dfffd03b 	.word	0xdfffd03b
 364:	dfffd033 	.word	0xdfffd033
 368:	dfffd024 	.word	0xdfffd024
 36c:	dfffd01c 	.word	0xdfffd01c
 370:	dfffcfc2 	.word	0xdfffcfc2
 374:	dfffcfba 	.word	0xdfffcfba
	...
 380:	dfffcfa4 	.word	0xdfffcfa4
	...
 38c:	dfffcf97 	.word	0xdfffcf97
    if (XMEMCMP(p, resultP, sizeof(p)))
 390:	4642      	mov	r2, r8
 392:	48b7      	ldr	r0, [pc, #732]	; (670 <aesgcm_test+0x670>)
 394:	a914      	add	r1, sp, #80	; 0x50
 396:	f7ff fffe 	bl	0 <memcmp>
 39a:	4680      	mov	r8, r0
 39c:	2800      	cmp	r0, #0
 39e:	f040 81a3 	bne.w	6e8 <aesgcm_test+0x6e8>
    XMEMSET(resultT, 0, sizeof(resultT));
 3a2:	4601      	mov	r1, r0
 3a4:	2220      	movs	r2, #32
 3a6:	4638      	mov	r0, r7
 3a8:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultC, 0, sizeof(resultC));
 3ac:	4641      	mov	r1, r8
 3ae:	224c      	movs	r2, #76	; 0x4c
 3b0:	a827      	add	r0, sp, #156	; 0x9c
 3b2:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultP, 0, sizeof(resultP));
 3b6:	4641      	mov	r1, r8
 3b8:	224c      	movs	r2, #76	; 0x4c
 3ba:	a814      	add	r0, sp, #80	; 0x50
 3bc:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesGcmEncrypt(enc, resultC, p3, sizeof(p3), iv3, sizeof(iv3),
 3c0:	f8df 82b0 	ldr.w	r8, [pc, #688]	; 674 <aesgcm_test+0x674>
    wc_AesGcmSetKey(enc, k3, k3Sz);
 3c4:	49ac      	ldr	r1, [pc, #688]	; (678 <aesgcm_test+0x678>)
 3c6:	4632      	mov	r2, r6
 3c8:	4620      	mov	r0, r4
 3ca:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    ret = wc_AesGcmEncrypt(enc, resultC, p3, sizeof(p3), iv3, sizeof(iv3),
 3ce:	2301      	movs	r3, #1
 3d0:	9702      	str	r7, [sp, #8]
 3d2:	4faa      	ldr	r7, [pc, #680]	; (67c <aesgcm_test+0x67c>)
 3d4:	9301      	str	r3, [sp, #4]
 3d6:	e9cd 6803 	strd	r6, r8, [sp, #12]
 3da:	4aa9      	ldr	r2, [pc, #676]	; (680 <aesgcm_test+0x680>)
 3dc:	9605      	str	r6, [sp, #20]
 3de:	9700      	str	r7, [sp, #0]
 3e0:	4633      	mov	r3, r6
 3e2:	a927      	add	r1, sp, #156	; 0x9c
 3e4:	4620      	mov	r0, r4
 3e6:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
    if (ret != 0)
 3ea:	b128      	cbz	r0, 3f8 <aesgcm_test+0x3f8>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 3ec:	4240      	negs	r0, r0
 3ee:	49a5      	ldr	r1, [pc, #660]	; (684 <aesgcm_test+0x684>)
 3f0:	4ea5      	ldr	r6, [pc, #660]	; (688 <aesgcm_test+0x688>)
 3f2:	f3c0 000a 	ubfx	r0, r0, #0, #11
 3f6:	e632      	b.n	5e <aesgcm_test+0x5e>
    if (XMEMCMP(c3, resultC, sizeof(c3)))
 3f8:	48a4      	ldr	r0, [pc, #656]	; (68c <aesgcm_test+0x68c>)
 3fa:	4632      	mov	r2, r6
 3fc:	a927      	add	r1, sp, #156	; 0x9c
 3fe:	f7ff fffe 	bl	0 <memcmp>
 402:	2800      	cmp	r0, #0
 404:	f040 8172 	bne.w	6ec <aesgcm_test+0x6ec>
    if (XMEMCMP(t3, resultT, sizeof(t3)))
 408:	f10d 0930 	add.w	r9, sp, #48	; 0x30
 40c:	48a0      	ldr	r0, [pc, #640]	; (690 <aesgcm_test+0x690>)
 40e:	2210      	movs	r2, #16
 410:	4649      	mov	r1, r9
 412:	f7ff fffe 	bl	0 <memcmp>
 416:	2800      	cmp	r0, #0
 418:	f040 816a 	bne.w	6f0 <aesgcm_test+0x6f0>
    ret = wc_AesGcmDecrypt(enc, resultP, resultC, sizeof(c3),
 41c:	2610      	movs	r6, #16
 41e:	2301      	movs	r3, #1
 420:	e9cd 7300 	strd	r7, r3, [sp]
 424:	e9cd 8604 	strd	r8, r6, [sp, #16]
 428:	e9cd 9602 	strd	r9, r6, [sp, #8]
 42c:	4633      	mov	r3, r6
 42e:	aa27      	add	r2, sp, #156	; 0x9c
 430:	a914      	add	r1, sp, #80	; 0x50
 432:	4620      	mov	r0, r4
 434:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
    if (ret != 0)
 438:	b128      	cbz	r0, 446 <aesgcm_test+0x446>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 43a:	4240      	negs	r0, r0
 43c:	4991      	ldr	r1, [pc, #580]	; (684 <aesgcm_test+0x684>)
 43e:	4e95      	ldr	r6, [pc, #596]	; (694 <aesgcm_test+0x694>)
 440:	f3c0 000a 	ubfx	r0, r0, #0, #11
 444:	e60b      	b.n	5e <aesgcm_test+0x5e>
    if (XMEMCMP(p3, resultP, sizeof(p3)))
 446:	4632      	mov	r2, r6
 448:	488d      	ldr	r0, [pc, #564]	; (680 <aesgcm_test+0x680>)
 44a:	a914      	add	r1, sp, #80	; 0x50
 44c:	f7ff fffe 	bl	0 <memcmp>
 450:	4606      	mov	r6, r0
 452:	2800      	cmp	r0, #0
 454:	f040 814e 	bne.w	6f4 <aesgcm_test+0x6f4>
    XMEMSET(resultT, 0, sizeof(resultT));
 458:	4601      	mov	r1, r0
 45a:	2220      	movs	r2, #32
 45c:	4648      	mov	r0, r9
 45e:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultC, 0, sizeof(resultC));
 462:	4631      	mov	r1, r6
 464:	224c      	movs	r2, #76	; 0x4c
 466:	a827      	add	r0, sp, #156	; 0x9c
 468:	f7ff fffe 	bl	0 <memset>
    XMEMSET(resultP, 0, sizeof(resultP));
 46c:	4631      	mov	r1, r6
 46e:	224c      	movs	r2, #76	; 0x4c
 470:	a814      	add	r0, sp, #80	; 0x50
 472:	f7ff fffe 	bl	0 <memset>
    wc_AesGcmSetKey(enc, k1, k1Sz);
 476:	4988      	ldr	r1, [pc, #544]	; (698 <aesgcm_test+0x698>)
    ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), iv1, sizeof(iv1),
 478:	f8df 8220 	ldr.w	r8, [pc, #544]	; 69c <aesgcm_test+0x69c>
    wc_AesGcmSetKey(enc, k1, k1Sz);
 47c:	2220      	movs	r2, #32
 47e:	4620      	mov	r0, r4
 480:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    ret = wc_AesGcmEncrypt(enc, resultC, p, sizeof(p), iv1, sizeof(iv1),
 484:	f04f 0b14 	mov.w	fp, #20
 488:	4b85      	ldr	r3, [pc, #532]	; (6a0 <aesgcm_test+0x6a0>)
 48a:	9300      	str	r3, [sp, #0]
 48c:	f04f 0a0f 	mov.w	sl, #15
 490:	f10d 0631 	add.w	r6, sp, #49	; 0x31
 494:	270c      	movs	r7, #12
 496:	4a76      	ldr	r2, [pc, #472]	; (670 <aesgcm_test+0x670>)
 498:	f8cd b014 	str.w	fp, [sp, #20]
 49c:	f8cd 8010 	str.w	r8, [sp, #16]
 4a0:	f8cd a00c 	str.w	sl, [sp, #12]
 4a4:	9602      	str	r6, [sp, #8]
 4a6:	9701      	str	r7, [sp, #4]
 4a8:	233c      	movs	r3, #60	; 0x3c
 4aa:	a927      	add	r1, sp, #156	; 0x9c
 4ac:	4620      	mov	r0, r4
 4ae:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
    if (ret != 0)
 4b2:	b128      	cbz	r0, 4c0 <aesgcm_test+0x4c0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 4b4:	4240      	negs	r0, r0
 4b6:	4973      	ldr	r1, [pc, #460]	; (684 <aesgcm_test+0x684>)
 4b8:	4e7a      	ldr	r6, [pc, #488]	; (6a4 <aesgcm_test+0x6a4>)
 4ba:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4be:	e5ce      	b.n	5e <aesgcm_test+0x5e>
    if (XMEMCMP(c1, resultC, sizeof(c1)))
 4c0:	4879      	ldr	r0, [pc, #484]	; (6a8 <aesgcm_test+0x6a8>)
 4c2:	223c      	movs	r2, #60	; 0x3c
 4c4:	a927      	add	r1, sp, #156	; 0x9c
 4c6:	f7ff fffe 	bl	0 <memcmp>
 4ca:	2800      	cmp	r0, #0
 4cc:	f040 8114 	bne.w	6f8 <aesgcm_test+0x6f8>
    if (XMEMCMP(t1, resultT + 1, sizeof(t1) - 1))
 4d0:	4876      	ldr	r0, [pc, #472]	; (6ac <aesgcm_test+0x6ac>)
 4d2:	4652      	mov	r2, sl
 4d4:	4631      	mov	r1, r6
 4d6:	f7ff fffe 	bl	0 <memcmp>
 4da:	2800      	cmp	r0, #0
 4dc:	f040 810e 	bne.w	6fc <aesgcm_test+0x6fc>
    ret = wc_AesGcmDecrypt(enc, resultP, resultC, sizeof(p),
 4e0:	4b6f      	ldr	r3, [pc, #444]	; (6a0 <aesgcm_test+0x6a0>)
 4e2:	9300      	str	r3, [sp, #0]
 4e4:	e9cd 8b04 	strd	r8, fp, [sp, #16]
 4e8:	e9cd 6a02 	strd	r6, sl, [sp, #8]
 4ec:	9701      	str	r7, [sp, #4]
 4ee:	233c      	movs	r3, #60	; 0x3c
 4f0:	aa27      	add	r2, sp, #156	; 0x9c
 4f2:	a914      	add	r1, sp, #80	; 0x50
 4f4:	4620      	mov	r0, r4
 4f6:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
    if (ret != 0)
 4fa:	b128      	cbz	r0, 508 <aesgcm_test+0x508>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 4fc:	4240      	negs	r0, r0
 4fe:	4961      	ldr	r1, [pc, #388]	; (684 <aesgcm_test+0x684>)
 500:	4e6b      	ldr	r6, [pc, #428]	; (6b0 <aesgcm_test+0x6b0>)
 502:	f3c0 000a 	ubfx	r0, r0, #0, #11
 506:	e5aa      	b.n	5e <aesgcm_test+0x5e>
    if (XMEMCMP(p, resultP, sizeof(p)))
 508:	a914      	add	r1, sp, #80	; 0x50
 50a:	4859      	ldr	r0, [pc, #356]	; (670 <aesgcm_test+0x670>)
 50c:	223c      	movs	r2, #60	; 0x3c
 50e:	f7ff fffe 	bl	0 <memcmp>
 512:	4601      	mov	r1, r0
 514:	2800      	cmp	r0, #0
 516:	f040 80f3 	bne.w	700 <aesgcm_test+0x700>
        ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);
 51a:	f06f 0201 	mvn.w	r2, #1
 51e:	a807      	add	r0, sp, #28
 520:	f7ff fffe 	bl	0 <wc_InitRng_ex>
        if (ret != 0)
 524:	4682      	mov	sl, r0
 526:	b198      	cbz	r0, 550 <aesgcm_test+0x550>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 528:	4246      	negs	r6, r0
 52a:	4856      	ldr	r0, [pc, #344]	; (684 <aesgcm_test+0x684>)
 52c:	f3c6 060a 	ubfx	r6, r6, #0, #11
 530:	4346      	muls	r6, r0
 532:	f106 4660 	add.w	r6, r6, #3758096384	; 0xe0000000
 536:	f5a6 5643 	sub.w	r6, r6, #12480	; 0x30c0
        XFREE(enc, HEAP_HINT, DYNAMIC_TYPE_AES);
 53a:	4620      	mov	r0, r4
 53c:	f7ff fffe 	bl	0 <free>
    if (dec)
 540:	b115      	cbz	r5, 548 <aesgcm_test+0x548>
        XFREE(dec, HEAP_HINT, DYNAMIC_TYPE_AES);
 542:	4628      	mov	r0, r5
 544:	f7ff fffe 	bl	0 <free>
}
 548:	4630      	mov	r0, r6
 54a:	b03b      	add	sp, #236	; 0xec
 54c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        XMEMSET(randIV, 0, sizeof(randIV));
 550:	ae09      	add	r6, sp, #36	; 0x24
 552:	4601      	mov	r1, r0
 554:	463a      	mov	r2, r7
 556:	4630      	mov	r0, r6
 558:	f7ff fffe 	bl	0 <memset>
        XMEMSET(resultT, 0, sizeof(resultT));
 55c:	2220      	movs	r2, #32
 55e:	4651      	mov	r1, sl
 560:	4648      	mov	r0, r9
 562:	f7ff fffe 	bl	0 <memset>
        XMEMSET(resultC, 0, sizeof(resultC));
 566:	224c      	movs	r2, #76	; 0x4c
 568:	4651      	mov	r1, sl
 56a:	a827      	add	r0, sp, #156	; 0x9c
 56c:	f7ff fffe 	bl	0 <memset>
        XMEMSET(resultP, 0, sizeof(resultP));
 570:	224c      	movs	r2, #76	; 0x4c
 572:	4651      	mov	r1, sl
 574:	a814      	add	r0, sp, #80	; 0x50
 576:	f7ff fffe 	bl	0 <memset>
        wc_AesGcmSetKey(enc, k1, k1Sz);
 57a:	4947      	ldr	r1, [pc, #284]	; (698 <aesgcm_test+0x698>)
 57c:	2220      	movs	r2, #32
 57e:	4620      	mov	r0, r4
 580:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
        ret = wc_AesGcmSetIV(enc, sizeof(randIV), NULL, 0, &rng);
 584:	ab07      	add	r3, sp, #28
 586:	9300      	str	r3, [sp, #0]
 588:	4652      	mov	r2, sl
 58a:	4653      	mov	r3, sl
 58c:	4639      	mov	r1, r7
 58e:	4620      	mov	r0, r4
 590:	f7ff fffe 	bl	0 <wc_AesGcmSetIV>
        if (ret != 0)
 594:	b128      	cbz	r0, 5a2 <aesgcm_test+0x5a2>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 596:	4240      	negs	r0, r0
 598:	493a      	ldr	r1, [pc, #232]	; (684 <aesgcm_test+0x684>)
 59a:	4e46      	ldr	r6, [pc, #280]	; (6b4 <aesgcm_test+0x6b4>)
 59c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 5a0:	e55d      	b.n	5e <aesgcm_test+0x5e>
        ret = wc_AesGcmEncrypt_ex(enc,
 5a2:	2314      	movs	r3, #20
 5a4:	e9cd 8304 	strd	r8, r3, [sp, #16]
 5a8:	2310      	movs	r3, #16
 5aa:	9303      	str	r3, [sp, #12]
 5ac:	af0c      	add	r7, sp, #48	; 0x30
 5ae:	230c      	movs	r3, #12
 5b0:	e9cd 6300 	strd	r6, r3, [sp]
 5b4:	4a2e      	ldr	r2, [pc, #184]	; (670 <aesgcm_test+0x670>)
 5b6:	9702      	str	r7, [sp, #8]
 5b8:	233c      	movs	r3, #60	; 0x3c
 5ba:	a927      	add	r1, sp, #156	; 0x9c
 5bc:	4620      	mov	r0, r4
 5be:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt_ex>
        if (ret != 0)
 5c2:	b128      	cbz	r0, 5d0 <aesgcm_test+0x5d0>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 5c4:	4240      	negs	r0, r0
 5c6:	492f      	ldr	r1, [pc, #188]	; (684 <aesgcm_test+0x684>)
 5c8:	4e3b      	ldr	r6, [pc, #236]	; (6b8 <aesgcm_test+0x6b8>)
 5ca:	f3c0 000a 	ubfx	r0, r0, #0, #11
 5ce:	e546      	b.n	5e <aesgcm_test+0x5e>
 5d0:	4633      	mov	r3, r6
            for (i = 0; i < sizeof(randIV); i++)
 5d2:	4681      	mov	r9, r0
                ivSum += randIV[i];
 5d4:	f813 2b01 	ldrb.w	r2, [r3], #1
            for (i = 0; i < sizeof(randIV); i++)
 5d8:	f109 0901 	add.w	r9, r9, #1
 5dc:	f1b9 0f0c 	cmp.w	r9, #12
                ivSum += randIV[i];
 5e0:	4410      	add	r0, r2
            for (i = 0; i < sizeof(randIV); i++)
 5e2:	d1f7      	bne.n	5d4 <aesgcm_test+0x5d4>
            if (ivSum == 0)
 5e4:	2800      	cmp	r0, #0
 5e6:	d039      	beq.n	65c <aesgcm_test+0x65c>
        wc_AesGcmSetKey(dec, k1, k1Sz);
 5e8:	492b      	ldr	r1, [pc, #172]	; (698 <aesgcm_test+0x698>)
 5ea:	2220      	movs	r2, #32
 5ec:	4628      	mov	r0, r5
 5ee:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
        ret = wc_AesGcmSetIV(dec, sizeof(randIV), NULL, 0, &rng);
 5f2:	ab07      	add	r3, sp, #28
 5f4:	9300      	str	r3, [sp, #0]
 5f6:	2300      	movs	r3, #0
 5f8:	461a      	mov	r2, r3
 5fa:	4649      	mov	r1, r9
 5fc:	4628      	mov	r0, r5
 5fe:	f7ff fffe 	bl	0 <wc_AesGcmSetIV>
        if (ret != 0)
 602:	b128      	cbz	r0, 610 <aesgcm_test+0x610>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 604:	4240      	negs	r0, r0
 606:	491f      	ldr	r1, [pc, #124]	; (684 <aesgcm_test+0x684>)
 608:	4e2c      	ldr	r6, [pc, #176]	; (6bc <aesgcm_test+0x6bc>)
 60a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 60e:	e526      	b.n	5e <aesgcm_test+0x5e>
        ret = wc_AesGcmDecrypt(dec,
 610:	2314      	movs	r3, #20
 612:	e9cd 8304 	strd	r8, r3, [sp, #16]
 616:	2310      	movs	r3, #16
 618:	e9cd 7302 	strd	r7, r3, [sp, #8]
 61c:	e9cd 6900 	strd	r6, r9, [sp]
 620:	233c      	movs	r3, #60	; 0x3c
 622:	aa27      	add	r2, sp, #156	; 0x9c
 624:	a914      	add	r1, sp, #80	; 0x50
 626:	4628      	mov	r0, r5
 628:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        if (ret != 0)
 62c:	b128      	cbz	r0, 63a <aesgcm_test+0x63a>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 62e:	4240      	negs	r0, r0
 630:	4914      	ldr	r1, [pc, #80]	; (684 <aesgcm_test+0x684>)
 632:	4e23      	ldr	r6, [pc, #140]	; (6c0 <aesgcm_test+0x6c0>)
 634:	f3c0 000a 	ubfx	r0, r0, #0, #11
 638:	e511      	b.n	5e <aesgcm_test+0x5e>
        if (XMEMCMP(p, resultP, sizeof(p)))
 63a:	480d      	ldr	r0, [pc, #52]	; (670 <aesgcm_test+0x670>)
 63c:	223c      	movs	r2, #60	; 0x3c
 63e:	a914      	add	r1, sp, #80	; 0x50
 640:	f7ff fffe 	bl	0 <memcmp>
 644:	4606      	mov	r6, r0
 646:	b958      	cbnz	r0, 660 <aesgcm_test+0x660>
        wc_FreeRng(&rng);
 648:	a807      	add	r0, sp, #28
 64a:	f7ff fffe 	bl	0 <wc_FreeRng>
    wc_AesFree(enc);
 64e:	4620      	mov	r0, r4
 650:	f7ff fffe 	bl	0 <wc_AesFree>
    wc_AesFree(dec);
 654:	4628      	mov	r0, r5
 656:	f7ff fffe 	bl	0 <wc_AesFree>
    ret = 0;
 65a:	e76e      	b.n	53a <aesgcm_test+0x53a>
                ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 65c:	4e19      	ldr	r6, [pc, #100]	; (6c4 <aesgcm_test+0x6c4>)
 65e:	e76c      	b.n	53a <aesgcm_test+0x53a>
            ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 660:	4e19      	ldr	r6, [pc, #100]	; (6c8 <aesgcm_test+0x6c8>)
 662:	e76a      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 664:	4e19      	ldr	r6, [pc, #100]	; (6cc <aesgcm_test+0x6cc>)
    return ret;
 666:	e76f      	b.n	548 <aesgcm_test+0x548>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, out);
 668:	4e19      	ldr	r6, [pc, #100]	; (6d0 <aesgcm_test+0x6d0>)
 66a:	e766      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 66c:	4e19      	ldr	r6, [pc, #100]	; (6d4 <aesgcm_test+0x6d4>)
 66e:	e764      	b.n	53a <aesgcm_test+0x53a>
	...
 684:	fffe7960 	.word	0xfffe7960
 688:	dfffcf85 	.word	0xdfffcf85
	...
 694:	dfffcf76 	.word	0xdfffcf76
	...
 6a4:	dfffcf5f 	.word	0xdfffcf5f
	...
 6b0:	dfffcf51 	.word	0xdfffcf51
 6b4:	dfffcf36 	.word	0xdfffcf36
 6b8:	dfffcf2b 	.word	0xdfffcf2b
 6bc:	dfffcf1b 	.word	0xdfffcf1b
 6c0:	dfffcf10 	.word	0xdfffcf10
 6c4:	ffffcf22 	.word	0xffffcf22
 6c8:	ffffcf0e 	.word	0xffffcf0e
 6cc:	ffffd096 	.word	0xffffd096
 6d0:	ffffd094 	.word	0xffffd094
 6d4:	ffffd077 	.word	0xffffd077
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6d8:	4e0a      	ldr	r6, [pc, #40]	; (704 <aesgcm_test+0x704>)
 6da:	e72e      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6dc:	4e0a      	ldr	r6, [pc, #40]	; (708 <aesgcm_test+0x708>)
 6de:	e72c      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6e0:	4e0a      	ldr	r6, [pc, #40]	; (70c <aesgcm_test+0x70c>)
 6e2:	e72a      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6e4:	4e0a      	ldr	r6, [pc, #40]	; (710 <aesgcm_test+0x710>)
 6e6:	e728      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6e8:	4e0a      	ldr	r6, [pc, #40]	; (714 <aesgcm_test+0x714>)
 6ea:	e726      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6ec:	4e0a      	ldr	r6, [pc, #40]	; (718 <aesgcm_test+0x718>)
 6ee:	e724      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6f0:	4e0a      	ldr	r6, [pc, #40]	; (71c <aesgcm_test+0x71c>)
 6f2:	e722      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6f4:	4e0a      	ldr	r6, [pc, #40]	; (720 <aesgcm_test+0x720>)
 6f6:	e720      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6f8:	4e0a      	ldr	r6, [pc, #40]	; (724 <aesgcm_test+0x724>)
 6fa:	e71e      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 6fc:	4e0a      	ldr	r6, [pc, #40]	; (728 <aesgcm_test+0x728>)
 6fe:	e71c      	b.n	53a <aesgcm_test+0x53a>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 700:	4e0a      	ldr	r6, [pc, #40]	; (72c <aesgcm_test+0x72c>)
 702:	e71a      	b.n	53a <aesgcm_test+0x53a>
 704:	ffffd075 	.word	0xffffd075
 708:	ffffd065 	.word	0xffffd065
 70c:	ffffcfa2 	.word	0xffffcfa2
 710:	ffffcfa0 	.word	0xffffcfa0
 714:	ffffcf95 	.word	0xffffcf95
 718:	ffffcf82 	.word	0xffffcf82
 71c:	ffffcf80 	.word	0xffffcf80
 720:	ffffcf74 	.word	0xffffcf74
 724:	ffffcf5c 	.word	0xffffcf5c
 728:	ffffcf5a 	.word	0xffffcf5a
 72c:	ffffcf4f 	.word	0xffffcf4f

Disassembly of section .text.gmac_test:

00000000 <gmac_test>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if ((gmac = (Gmac *)XMALLOC(sizeof *gmac, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   4:	f44f 709c 	mov.w	r0, #312	; 0x138
{
   8:	b091      	sub	sp, #68	; 0x44
    if ((gmac = (Gmac *)XMALLOC(sizeof *gmac, HEAP_HINT, DYNAMIC_TYPE_AES)) == NULL)
   a:	f7ff fffe 	bl	0 <malloc>
   e:	4605      	mov	r5, r0
  10:	2800      	cmp	r0, #0
  12:	f000 80d8 	beq.w	1c6 <gmac_test+0x1c6>
    XMEMSET(gmac, 0, sizeof *gmac); /* clear context */
  16:	f44f 729c 	mov.w	r2, #312	; 0x138
  1a:	2100      	movs	r1, #0
  1c:	f7ff fffe 	bl	0 <memset>
    XMEMSET(tag, 0, sizeof(tag));
  20:	ae0c      	add	r6, sp, #48	; 0x30
    (void)wc_AesInit(&gmac->aes, HEAP_HINT, INVALID_DEVID); /* Make sure devId updated */
  22:	f06f 0201 	mvn.w	r2, #1
  26:	2100      	movs	r1, #0
  28:	4628      	mov	r0, r5
  2a:	f7ff fffe 	bl	0 <wc_AesInit>
    wc_GmacUpdate(gmac, iv1, sizeof(iv1), a1, sizeof(a1), tag, sizeof(t1));
  2e:	4f67      	ldr	r7, [pc, #412]	; (1cc <gmac_test+0x1cc>)
    if (XMEMCMP(t1, tag, sizeof(t1)) != 0)
  30:	f8df b19c 	ldr.w	fp, [pc, #412]	; 1d0 <gmac_test+0x1d0>
    XMEMSET(tag, 0, sizeof(tag));
  34:	2210      	movs	r2, #16
  36:	2100      	movs	r1, #0
  38:	4630      	mov	r0, r6
  3a:	f7ff fffe 	bl	0 <memset>
    wc_GmacUpdate(gmac, iv1, sizeof(iv1), a1, sizeof(a1), tag, sizeof(t1));
  3e:	2410      	movs	r4, #16
    wc_GmacSetKey(gmac, k1, sizeof(k1));
  40:	4964      	ldr	r1, [pc, #400]	; (1d4 <gmac_test+0x1d4>)
  42:	2210      	movs	r2, #16
  44:	4628      	mov	r0, r5
  46:	f7ff fffe 	bl	0 <wc_GmacSetKey>
    wc_GmacUpdate(gmac, iv1, sizeof(iv1), a1, sizeof(a1), tag, sizeof(t1));
  4a:	4963      	ldr	r1, [pc, #396]	; (1d8 <gmac_test+0x1d8>)
  4c:	9400      	str	r4, [sp, #0]
  4e:	463b      	mov	r3, r7
  50:	220c      	movs	r2, #12
  52:	e9cd 6401 	strd	r6, r4, [sp, #4]
  56:	4628      	mov	r0, r5
  58:	f7ff fffe 	bl	0 <wc_GmacUpdate>
    if (XMEMCMP(t1, tag, sizeof(t1)) != 0)
  5c:	4631      	mov	r1, r6
  5e:	4622      	mov	r2, r4
  60:	4658      	mov	r0, fp
  62:	f7ff fffe 	bl	0 <memcmp>
  66:	4601      	mov	r1, r0
  68:	2800      	cmp	r0, #0
  6a:	f040 80a8 	bne.w	1be <gmac_test+0x1be>
    XMEMSET(tag, 0, sizeof(tag));
  6e:	4622      	mov	r2, r4
  70:	4630      	mov	r0, r6
  72:	f7ff fffe 	bl	0 <memset>
    wc_GmacUpdate(gmac, iv2, sizeof(iv2), a2, sizeof(a2), tag, sizeof(t2));
  76:	f04f 090f 	mov.w	r9, #15
    wc_GmacSetKey(gmac, k2, sizeof(k2));
  7a:	4958      	ldr	r1, [pc, #352]	; (1dc <gmac_test+0x1dc>)
    if (XMEMCMP(t2, tag, sizeof(t2)) != 0)
  7c:	f8df a160 	ldr.w	sl, [pc, #352]	; 1e0 <gmac_test+0x1e0>
    wc_GmacSetKey(gmac, k2, sizeof(k2));
  80:	4622      	mov	r2, r4
  82:	4628      	mov	r0, r5
  84:	f7ff fffe 	bl	0 <wc_GmacSetKey>
    wc_GmacUpdate(gmac, iv2, sizeof(iv2), a2, sizeof(a2), tag, sizeof(t2));
  88:	4b56      	ldr	r3, [pc, #344]	; (1e4 <gmac_test+0x1e4>)
  8a:	4957      	ldr	r1, [pc, #348]	; (1e8 <gmac_test+0x1e8>)
  8c:	9400      	str	r4, [sp, #0]
  8e:	220c      	movs	r2, #12
  90:	e9cd 6901 	strd	r6, r9, [sp, #4]
  94:	4628      	mov	r0, r5
  96:	f7ff fffe 	bl	0 <wc_GmacUpdate>
    if (XMEMCMP(t2, tag, sizeof(t2)) != 0)
  9a:	4631      	mov	r1, r6
  9c:	464a      	mov	r2, r9
  9e:	4650      	mov	r0, sl
  a0:	f7ff fffe 	bl	0 <memcmp>
  a4:	4601      	mov	r1, r0
  a6:	2800      	cmp	r0, #0
  a8:	f040 808b 	bne.w	1c2 <gmac_test+0x1c2>
        ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);
  ac:	f10d 081c 	add.w	r8, sp, #28
  b0:	f06f 0201 	mvn.w	r2, #1
  b4:	4640      	mov	r0, r8
  b6:	f7ff fffe 	bl	0 <wc_InitRng_ex>
        if (ret != 0)
  ba:	b138      	cbz	r0, cc <gmac_test+0xcc>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  bc:	4240      	negs	r0, r0
  be:	494b      	ldr	r1, [pc, #300]	; (1ec <gmac_test+0x1ec>)
  c0:	4c4b      	ldr	r4, [pc, #300]	; (1f0 <gmac_test+0x1f0>)
  c2:	f3c0 000a 	ubfx	r0, r0, #0, #11
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  c6:	fb01 4400 	mla	r4, r1, r0, r4
  ca:	e027      	b.n	11c <gmac_test+0x11c>
        ret = wc_GmacVerify(k1, sizeof(k1), iv1, sizeof(iv1), a1, sizeof(a1),
  cc:	e9cd b402 	strd	fp, r4, [sp, #8]
  d0:	e9cd 7400 	strd	r7, r4, [sp]
  d4:	4a40      	ldr	r2, [pc, #256]	; (1d8 <gmac_test+0x1d8>)
  d6:	483f      	ldr	r0, [pc, #252]	; (1d4 <gmac_test+0x1d4>)
  d8:	230c      	movs	r3, #12
  da:	4621      	mov	r1, r4
  dc:	f7ff fffe 	bl	0 <wc_GmacVerify>
        if (ret != 0)
  e0:	b128      	cbz	r0, ee <gmac_test+0xee>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
  e2:	4240      	negs	r0, r0
  e4:	4941      	ldr	r1, [pc, #260]	; (1ec <gmac_test+0x1ec>)
  e6:	4c43      	ldr	r4, [pc, #268]	; (1f4 <gmac_test+0x1f4>)
  e8:	f3c0 000a 	ubfx	r0, r0, #0, #11
  ec:	e7eb      	b.n	c6 <gmac_test+0xc6>
        ret = wc_GmacVerify(k1, sizeof(k1), iv1, sizeof(iv1), a1, sizeof(a1),
  ee:	4b42      	ldr	r3, [pc, #264]	; (1f8 <gmac_test+0x1f8>)
  f0:	4a39      	ldr	r2, [pc, #228]	; (1d8 <gmac_test+0x1d8>)
  f2:	4838      	ldr	r0, [pc, #224]	; (1d4 <gmac_test+0x1d4>)
  f4:	9403      	str	r4, [sp, #12]
  f6:	e9cd 4301 	strd	r4, r3, [sp, #4]
  fa:	9700      	str	r7, [sp, #0]
  fc:	230c      	movs	r3, #12
  fe:	4621      	mov	r1, r4
 100:	f7ff fffe 	bl	0 <wc_GmacVerify>
        if (ret != AES_GCM_AUTH_E)
 104:	f110 0fb4 	cmn.w	r0, #180	; 0xb4
 108:	d012      	beq.n	130 <gmac_test+0x130>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 10a:	4244      	negs	r4, r0
 10c:	4837      	ldr	r0, [pc, #220]	; (1ec <gmac_test+0x1ec>)
 10e:	f3c4 040a 	ubfx	r4, r4, #0, #11
 112:	4344      	muls	r4, r0
 114:	f104 4460 	add.w	r4, r4, #3758096384	; 0xe0000000
 118:	f5a4 5448 	sub.w	r4, r4, #12800	; 0x3200
    wc_AesFree(&gmac->aes);
 11c:	4628      	mov	r0, r5
 11e:	f7ff fffe 	bl	0 <wc_AesFree>
    XFREE(gmac, HEAP_HINT, DYNAMIC_TYPE_AES);
 122:	4628      	mov	r0, r5
 124:	f7ff fffe 	bl	0 <free>
}
 128:	4620      	mov	r0, r4
 12a:	b011      	add	sp, #68	; 0x44
 12c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ret = wc_GmacVerify(k2, sizeof(k2), iv2, sizeof(iv2), a2, sizeof(a2),
 130:	4b2c      	ldr	r3, [pc, #176]	; (1e4 <gmac_test+0x1e4>)
 132:	9300      	str	r3, [sp, #0]
 134:	e9cd a902 	strd	sl, r9, [sp, #8]
 138:	4a2b      	ldr	r2, [pc, #172]	; (1e8 <gmac_test+0x1e8>)
 13a:	4828      	ldr	r0, [pc, #160]	; (1dc <gmac_test+0x1dc>)
 13c:	9401      	str	r4, [sp, #4]
 13e:	230c      	movs	r3, #12
 140:	4621      	mov	r1, r4
 142:	f7ff fffe 	bl	0 <wc_GmacVerify>
        if (ret != 0)
 146:	4681      	mov	r9, r0
 148:	b128      	cbz	r0, 156 <gmac_test+0x156>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 14a:	4240      	negs	r0, r0
 14c:	4927      	ldr	r1, [pc, #156]	; (1ec <gmac_test+0x1ec>)
 14e:	4c2b      	ldr	r4, [pc, #172]	; (1fc <gmac_test+0x1fc>)
 150:	f3c0 000a 	ubfx	r0, r0, #0, #11
 154:	e7b7      	b.n	c6 <gmac_test+0xc6>
        XMEMSET(tag, 0, sizeof(tag));
 156:	4601      	mov	r1, r0
 158:	4622      	mov	r2, r4
 15a:	4630      	mov	r0, r6
 15c:	f7ff fffe 	bl	0 <memset>
        XMEMSET(iv, 0, sizeof(iv));
 160:	220c      	movs	r2, #12
 162:	4649      	mov	r1, r9
 164:	a809      	add	r0, sp, #36	; 0x24
 166:	f7ff fffe 	bl	0 <memset>
        ret = wc_Gmac(k1, sizeof(k1), iv, sizeof(iv), a1, sizeof(a1),
 16a:	e9cd 4803 	strd	r4, r8, [sp, #12]
 16e:	e9cd 4601 	strd	r4, r6, [sp, #4]
 172:	4818      	ldr	r0, [pc, #96]	; (1d4 <gmac_test+0x1d4>)
 174:	9700      	str	r7, [sp, #0]
 176:	230c      	movs	r3, #12
 178:	aa09      	add	r2, sp, #36	; 0x24
 17a:	4621      	mov	r1, r4
 17c:	f7ff fffe 	bl	0 <wc_Gmac>
        if (ret != 0)
 180:	b128      	cbz	r0, 18e <gmac_test+0x18e>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 182:	4240      	negs	r0, r0
 184:	4919      	ldr	r1, [pc, #100]	; (1ec <gmac_test+0x1ec>)
 186:	4c1e      	ldr	r4, [pc, #120]	; (200 <gmac_test+0x200>)
 188:	f3c0 000a 	ubfx	r0, r0, #0, #11
 18c:	e79b      	b.n	c6 <gmac_test+0xc6>
        ret = wc_GmacVerify(k1, sizeof(k1), iv, sizeof(iv), a1, sizeof(a1),
 18e:	e9cd 6402 	strd	r6, r4, [sp, #8]
 192:	e9cd 7400 	strd	r7, r4, [sp]
 196:	4621      	mov	r1, r4
 198:	480e      	ldr	r0, [pc, #56]	; (1d4 <gmac_test+0x1d4>)
 19a:	230c      	movs	r3, #12
 19c:	aa09      	add	r2, sp, #36	; 0x24
 19e:	f7ff fffe 	bl	0 <wc_GmacVerify>
        if (ret != 0)
 1a2:	4604      	mov	r4, r0
 1a4:	b138      	cbz	r0, 1b6 <gmac_test+0x1b6>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), out);
 1a6:	4244      	negs	r4, r0
 1a8:	4910      	ldr	r1, [pc, #64]	; (1ec <gmac_test+0x1ec>)
 1aa:	4816      	ldr	r0, [pc, #88]	; (204 <gmac_test+0x204>)
 1ac:	f3c4 040a 	ubfx	r4, r4, #0, #11
 1b0:	fb01 0404 	mla	r4, r1, r4, r0
 1b4:	e7b2      	b.n	11c <gmac_test+0x11c>
        wc_FreeRng(&rng);
 1b6:	4640      	mov	r0, r8
 1b8:	f7ff fffe 	bl	0 <wc_FreeRng>
    ret = 0;
 1bc:	e7ae      	b.n	11c <gmac_test+0x11c>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 1be:	4c12      	ldr	r4, [pc, #72]	; (208 <gmac_test+0x208>)
 1c0:	e7ac      	b.n	11c <gmac_test+0x11c>
        ERROR_OUT(WC_TEST_RET_ENC_NC, out);
 1c2:	4c12      	ldr	r4, [pc, #72]	; (20c <gmac_test+0x20c>)
 1c4:	e7aa      	b.n	11c <gmac_test+0x11c>
        return WC_TEST_RET_ENC_ERRNO;
 1c6:	4c12      	ldr	r4, [pc, #72]	; (210 <gmac_test+0x210>)
 1c8:	e7ae      	b.n	128 <gmac_test+0x128>
 1ca:	bf00      	nop
	...
 1ec:	fffe7960 	.word	0xfffe7960
 1f0:	dfffce0e 	.word	0xdfffce0e
 1f4:	dfffce04 	.word	0xdfffce04
 1f8:	00000000 	.word	0x00000000
 1fc:	dfffcdfc 	.word	0xdfffcdfc
 200:	dfffcdf5 	.word	0xdfffcdf5
 204:	dfffcdf1 	.word	0xdfffcdf1
 208:	ffffce27 	.word	0xffffce27
 20c:	ffffce1e 	.word	0xffffce1e
 210:	ffffce30 	.word	0xffffce30

Disassembly of section .text.random_test:

00000000 <random_test>:
    return random_rng_test();
   0:	f7ff bffe 	b.w	0 <random_test>

Disassembly of section .text.memory_test:

00000000 <memory_test>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    b = (byte*)XMALLOC(sz, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
   2:	f44f 6080 	mov.w	r0, #1024	; 0x400
   6:	f7ff fffe 	bl	0 <malloc>
    if (b == NULL) {
   a:	b318      	cbz	r0, 54 <memory_test+0x54>
    for (i = 0; i < sz; i++) {
   c:	2300      	movs	r3, #0
        b[i] = (byte)i;
   e:	54c3      	strb	r3, [r0, r3]
    for (i = 0; i < sz; i++) {
  10:	3301      	adds	r3, #1
  12:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  16:	d1fa      	bne.n	e <memory_test+0xe>
    for (i = 0; i < sz; i++) {
  18:	2300      	movs	r3, #0
        if (b[i] != (byte)i) {
  1a:	5cc1      	ldrb	r1, [r0, r3]
  1c:	b2da      	uxtb	r2, r3
  1e:	4291      	cmp	r1, r2
  20:	d116      	bne.n	50 <memory_test+0x50>
    for (i = 0; i < sz; i++) {
  22:	3301      	adds	r3, #1
  24:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  28:	d1f7      	bne.n	1a <memory_test+0x1a>
    int ret = 0;
  2a:	2400      	movs	r4, #0
    XFREE(b, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
  2c:	f7ff fffe 	bl	0 <free>
    if (ret != 0)
  30:	b95c      	cbnz	r4, 4a <memory_test+0x4a>
    volatile word32 j = -1; /* must be volatile to properly detect error */
  32:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  36:	9301      	str	r3, [sp, #4]
    j = *outJ; /* Found index to use in const array. */
  38:	9401      	str	r4, [sp, #4]
    if (j == 0) {
  3a:	9b01      	ldr	r3, [sp, #4]
  3c:	b963      	cbnz	r3, 58 <memory_test+0x58>
        ret = in[j]; /* The big test: can we actually access the `in` data? */
  3e:	9b01      	ldr	r3, [sp, #4]
  40:	4a06      	ldr	r2, [pc, #24]	; (5c <memory_test+0x5c>)
        if (const_byte_ptr_test(const_byte_array, &j) != CBPTR_EXPECTED) {
  42:	5cd4      	ldrb	r4, [r2, r3]
  44:	3c41      	subs	r4, #65	; 0x41
  46:	bf18      	it	ne
  48:	2401      	movne	r4, #1
}
  4a:	4620      	mov	r0, r4
  4c:	b002      	add	sp, #8
  4e:	bd10      	pop	{r4, pc}
            ret = WC_TEST_RET_ENC_NC;
  50:	4c03      	ldr	r4, [pc, #12]	; (60 <memory_test+0x60>)
  52:	e7eb      	b.n	2c <memory_test+0x2c>
        return WC_TEST_RET_ENC_NC;
  54:	4c03      	ldr	r4, [pc, #12]	; (64 <memory_test+0x64>)
  56:	e7f8      	b.n	4a <memory_test+0x4a>
            ret = 1;
  58:	2401      	movs	r4, #1
  5a:	e7f6      	b.n	4a <memory_test+0x4a>
  5c:	00000000 	.word	0x00000000
  60:	ffffc5ce 	.word	0xffffc5ce
  64:	ffffc5d7 	.word	0xffffc5d7

Disassembly of section .text.ecc_test:

00000000 <ecc_test>:
{
       0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
       4:	b0d1      	sub	sp, #324	; 0x144
    ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);
       6:	f06f 0201 	mvn.w	r2, #1
       a:	2100      	movs	r1, #0
       c:	a80c      	add	r0, sp, #48	; 0x30
       e:	f7ff fffe 	bl	0 <wc_InitRng_ex>
    if (ret != 0)
      12:	4607      	mov	r7, r0
      14:	b150      	cbz	r0, 2c <ecc_test+0x2c>
        return WC_TEST_RET_ENC_EC(ret);
      16:	4247      	negs	r7, r0
      18:	f3c7 010a 	ubfx	r1, r7, #0, #11
      1c:	48b1      	ldr	r0, [pc, #708]	; (2e4 <ecc_test+0x2e4>)
      1e:	4fb2      	ldr	r7, [pc, #712]	; (2e8 <ecc_test+0x2e8>)
      20:	fb07 0701 	mla	r7, r7, r1, r0
}
      24:	4638      	mov	r0, r7
      26:	b051      	add	sp, #324	; 0x144
      28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    WC_DECLARE_VAR(sharedA, byte, ECC_SHARED_SIZE, HEAP_HINT);
      2c:	2080      	movs	r0, #128	; 0x80
      2e:	f7ff fffe 	bl	0 <malloc>
      32:	4683      	mov	fp, r0
    WC_DECLARE_VAR(sharedB, byte, ECC_SHARED_SIZE, HEAP_HINT);
      34:	2080      	movs	r0, #128	; 0x80
      36:	f7ff fffe 	bl	0 <malloc>
      3a:	4682      	mov	sl, r0
    WC_DECLARE_VAR(exportBuf, byte, ECC_KEY_EXPORT_BUF_SIZE, HEAP_HINT);
      3c:	2060      	movs	r0, #96	; 0x60
      3e:	f7ff fffe 	bl	0 <malloc>
      42:	9006      	str	r0, [sp, #24]
    WC_DECLARE_VAR(sig, byte, ECC_SIG_SIZE, HEAP_HINT);
      44:	2049      	movs	r0, #73	; 0x49
    word32  x = 0;
      46:	971f      	str	r7, [sp, #124]	; 0x7c
    WC_DECLARE_VAR(sig, byte, ECC_SIG_SIZE, HEAP_HINT);
      48:	f7ff fffe 	bl	0 <malloc>
      4c:	4681      	mov	r9, r0
    WC_DECLARE_VAR(digest, byte, ECC_DIGEST_SIZE, HEAP_HINT);
      4e:	2020      	movs	r0, #32
      50:	f7ff fffe 	bl	0 <malloc>
      54:	4606      	mov	r6, r0
    ecc_key *userA = (ecc_key *)XMALLOC(sizeof *userA, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
      56:	f44f 70de 	mov.w	r0, #444	; 0x1bc
      5a:	f7ff fffe 	bl	0 <malloc>
      5e:	4604      	mov	r4, r0
    ecc_key *userB = (ecc_key *)XMALLOC(sizeof *userB, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
      60:	f44f 70de 	mov.w	r0, #444	; 0x1bc
      64:	f7ff fffe 	bl	0 <malloc>
      68:	4605      	mov	r5, r0
    ecc_key *pubKey = (ecc_key *)XMALLOC(sizeof *pubKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
      6a:	f44f 70de 	mov.w	r0, #444	; 0x1bc
      6e:	f7ff fffe 	bl	0 <malloc>
      72:	4680      	mov	r8, r0
    if (sharedA == NULL || sharedB == NULL)
      74:	f1bb 0f00 	cmp.w	fp, #0
      78:	f000 81c0 	beq.w	3fc <ecc_test+0x3fc>
      7c:	f1ba 0f00 	cmp.w	sl, #0
      80:	f000 81bc 	beq.w	3fc <ecc_test+0x3fc>
    if (exportBuf == NULL)
      84:	9b06      	ldr	r3, [sp, #24]
      86:	2b00      	cmp	r3, #0
      88:	f000 81fd 	beq.w	486 <ecc_test+0x486>
    if (sig == NULL || digest == NULL)
      8c:	f1b9 0f00 	cmp.w	r9, #0
      90:	f000 81fb 	beq.w	48a <ecc_test+0x48a>
      94:	2e00      	cmp	r6, #0
      96:	f000 81f8 	beq.w	48a <ecc_test+0x48a>
    if ((userA == NULL) ||
      9a:	2c00      	cmp	r4, #0
      9c:	f000 8203 	beq.w	4a6 <ecc_test+0x4a6>
      a0:	2d00      	cmp	r5, #0
      a2:	f000 81f4 	beq.w	48e <ecc_test+0x48e>
        (userB == NULL) ||
      a6:	2800      	cmp	r0, #0
      a8:	f000 81f1 	beq.w	48e <ecc_test+0x48e>
    XMEMSET(userA, 0, sizeof *userA);
      ac:	f44f 72de 	mov.w	r2, #444	; 0x1bc
      b0:	4639      	mov	r1, r7
      b2:	4620      	mov	r0, r4
      b4:	f7ff fffe 	bl	0 <memset>
    XMEMSET(userB, 0, sizeof *userB);
      b8:	f44f 72de 	mov.w	r2, #444	; 0x1bc
      bc:	4639      	mov	r1, r7
      be:	4628      	mov	r0, r5
      c0:	f7ff fffe 	bl	0 <memset>
    XMEMSET(pubKey, 0, sizeof *pubKey);
      c4:	f44f 72de 	mov.w	r2, #444	; 0x1bc
      c8:	4639      	mov	r1, r7
      ca:	4640      	mov	r0, r8
      cc:	f7ff fffe 	bl	0 <memset>
    ret = wc_ecc_init_ex(userA, HEAP_HINT, devId);
      d0:	f06f 0201 	mvn.w	r2, #1
      d4:	4639      	mov	r1, r7
      d6:	4620      	mov	r0, r4
      d8:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
      dc:	b138      	cbz	r0, ee <ecc_test+0xee>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
      de:	4240      	negs	r0, r0
      e0:	4b81      	ldr	r3, [pc, #516]	; (2e8 <ecc_test+0x2e8>)
      e2:	4f82      	ldr	r7, [pc, #520]	; (2ec <ecc_test+0x2ec>)
      e4:	f3c0 000a 	ubfx	r0, r0, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
      e8:	fb03 7700 	mla	r7, r3, r0, r7
      ec:	e028      	b.n	140 <ecc_test+0x140>
    ret = wc_ecc_init_ex(userB, HEAP_HINT, devId);
      ee:	2100      	movs	r1, #0
      f0:	f06f 0201 	mvn.w	r2, #1
      f4:	4628      	mov	r0, r5
      f6:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
      fa:	4601      	mov	r1, r0
      fc:	b138      	cbz	r0, 10e <ecc_test+0x10e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
      fe:	4241      	negs	r1, r0
     100:	4f79      	ldr	r7, [pc, #484]	; (2e8 <ecc_test+0x2e8>)
     102:	487b      	ldr	r0, [pc, #492]	; (2f0 <ecc_test+0x2f0>)
     104:	f3c1 010a 	ubfx	r1, r1, #0, #11
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     108:	fb07 0701 	mla	r7, r7, r1, r0
     10c:	e018      	b.n	140 <ecc_test+0x140>
    ret = wc_ecc_init_ex(pubKey, HEAP_HINT, devId);
     10e:	f06f 0201 	mvn.w	r2, #1
     112:	4640      	mov	r0, r8
     114:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
     118:	4603      	mov	r3, r0
     11a:	b138      	cbz	r0, 12c <ecc_test+0x12c>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     11c:	4243      	negs	r3, r0
     11e:	4f72      	ldr	r7, [pc, #456]	; (2e8 <ecc_test+0x2e8>)
     120:	4874      	ldr	r0, [pc, #464]	; (2f4 <ecc_test+0x2f4>)
     122:	f3c3 030a 	ubfx	r3, r3, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     126:	fb03 0707 	mla	r7, r3, r7, r0
     12a:	e009      	b.n	140 <ecc_test+0x140>
    ret = wc_ecc_make_key_ex(rng, keySize, userA, curve_id);
     12c:	4622      	mov	r2, r4
     12e:	2120      	movs	r1, #32
     130:	a80c      	add	r0, sp, #48	; 0x30
     132:	f7ff fffe 	bl	0 <wc_ecc_make_key_ex>
    if (ret == ECC_CURVE_OID_E)
     136:	f110 0fac 	cmn.w	r0, #172	; 0xac
     13a:	d108      	bne.n	14e <ecc_test+0x14e>
    ret = wc_ecc_make_key_ex(rng, keySize, userA, curve_id);
     13c:	f06f 07ab 	mvn.w	r7, #171	; 0xab
        wc_ecc_free(userA);
     140:	4620      	mov	r0, r4
     142:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(userA, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     146:	4620      	mov	r0, r4
     148:	f7ff fffe 	bl	0 <free>
     14c:	e15a      	b.n	404 <ecc_test+0x404>
    if (ret != 0)
     14e:	b128      	cbz	r0, 15c <ecc_test+0x15c>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     150:	4247      	negs	r7, r0
     152:	4b65      	ldr	r3, [pc, #404]	; (2e8 <ecc_test+0x2e8>)
     154:	4868      	ldr	r0, [pc, #416]	; (2f8 <ecc_test+0x2f8>)
     156:	f3c7 070a 	ubfx	r7, r7, #0, #11
     15a:	e7e4      	b.n	126 <ecc_test+0x126>
    if (wc_ecc_get_curve_idx(curve_id) != -1) {
     15c:	f7ff fffe 	bl	0 <wc_ecc_get_curve_idx>
     160:	3001      	adds	r0, #1
     162:	d114      	bne.n	18e <ecc_test+0x18e>
    ret = wc_ecc_check_key(userA);
     164:	4620      	mov	r0, r4
     166:	f7ff fffe 	bl	0 <wc_ecc_check_key>
    if (ret != 0)
     16a:	4603      	mov	r3, r0
     16c:	b9c8      	cbnz	r0, 1a2 <ecc_test+0x1a2>
    ret = wc_ecc_make_key_ex(rng, keySize, userB, curve_id);
     16e:	462a      	mov	r2, r5
     170:	2120      	movs	r1, #32
     172:	a80c      	add	r0, sp, #48	; 0x30
     174:	f7ff fffe 	bl	0 <wc_ecc_make_key_ex>
    if (ret != 0)
     178:	b1c8      	cbz	r0, 1ae <ecc_test+0x1ae>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     17a:	4f5b      	ldr	r7, [pc, #364]	; (2e8 <ecc_test+0x2e8>)
     17c:	4240      	negs	r0, r0
     17e:	f3c0 000a 	ubfx	r0, r0, #0, #11
     182:	4378      	muls	r0, r7
     184:	f100 4760 	add.w	r7, r0, #3758096384	; 0xe0000000
     188:	f5a7 47ce 	sub.w	r7, r7, #26368	; 0x6700
     18c:	e7d8      	b.n	140 <ecc_test+0x140>
        curveSize = wc_ecc_get_curve_size_from_id(userA->dp->id);
     18e:	6923      	ldr	r3, [r4, #16]
     190:	6858      	ldr	r0, [r3, #4]
     192:	f7ff fffe 	bl	0 <wc_ecc_get_curve_size_from_id>
        if (curveSize != userA->dp->size)
     196:	6923      	ldr	r3, [r4, #16]
     198:	681b      	ldr	r3, [r3, #0]
     19a:	4298      	cmp	r0, r3
     19c:	d0e2      	beq.n	164 <ecc_test+0x164>
            ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     19e:	4f57      	ldr	r7, [pc, #348]	; (2fc <ecc_test+0x2fc>)
     1a0:	e7ce      	b.n	140 <ecc_test+0x140>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     1a2:	4243      	negs	r3, r0
     1a4:	4f50      	ldr	r7, [pc, #320]	; (2e8 <ecc_test+0x2e8>)
     1a6:	4856      	ldr	r0, [pc, #344]	; (300 <ecc_test+0x300>)
     1a8:	f3c3 030a 	ubfx	r3, r3, #0, #11
     1ac:	e7bb      	b.n	126 <ecc_test+0x126>
    if (dp == NULL && keySize > 0 && wc_ecc_size(userA) != keySize)
     1ae:	4620      	mov	r0, r4
     1b0:	f7ff fffe 	bl	0 <wc_ecc_size>
     1b4:	2820      	cmp	r0, #32
     1b6:	d1c1      	bne.n	13c <ecc_test+0x13c>
    ret = wc_ecc_set_rng(userA, rng);
     1b8:	a90c      	add	r1, sp, #48	; 0x30
     1ba:	4620      	mov	r0, r4
     1bc:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
    if (ret != 0)
     1c0:	b128      	cbz	r0, 1ce <ecc_test+0x1ce>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     1c2:	4240      	negs	r0, r0
     1c4:	4b48      	ldr	r3, [pc, #288]	; (2e8 <ecc_test+0x2e8>)
     1c6:	4f4f      	ldr	r7, [pc, #316]	; (304 <ecc_test+0x304>)
     1c8:	f3c0 000a 	ubfx	r0, r0, #0, #11
     1cc:	e78c      	b.n	e8 <ecc_test+0xe8>
    ret = wc_ecc_set_rng(userB, rng);
     1ce:	a90c      	add	r1, sp, #48	; 0x30
     1d0:	4628      	mov	r0, r5
     1d2:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
    if (ret != 0)
     1d6:	b128      	cbz	r0, 1e4 <ecc_test+0x1e4>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     1d8:	4240      	negs	r0, r0
     1da:	4b43      	ldr	r3, [pc, #268]	; (2e8 <ecc_test+0x2e8>)
     1dc:	4f4a      	ldr	r7, [pc, #296]	; (308 <ecc_test+0x308>)
     1de:	f3c0 000a 	ubfx	r0, r0, #0, #11
     1e2:	e781      	b.n	e8 <ecc_test+0xe8>
    x = ECC_SHARED_SIZE;
     1e4:	2780      	movs	r7, #128	; 0x80
            ret = wc_ecc_shared_secret(userA, userB, sharedA, &x);
     1e6:	ab1f      	add	r3, sp, #124	; 0x7c
     1e8:	465a      	mov	r2, fp
     1ea:	4629      	mov	r1, r5
     1ec:	4620      	mov	r0, r4
    x = ECC_SHARED_SIZE;
     1ee:	971f      	str	r7, [sp, #124]	; 0x7c
            ret = wc_ecc_shared_secret(userA, userB, sharedA, &x);
     1f0:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
    } while (ret == WC_PENDING_E);
     1f4:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
     1f8:	d100      	bne.n	1fc <ecc_test+0x1fc>
     1fa:	e7fe      	b.n	1fa <ecc_test+0x1fa>
    if (ret != 0)
     1fc:	b128      	cbz	r0, 20a <ecc_test+0x20a>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     1fe:	4240      	negs	r0, r0
     200:	4b39      	ldr	r3, [pc, #228]	; (2e8 <ecc_test+0x2e8>)
     202:	4f42      	ldr	r7, [pc, #264]	; (30c <ecc_test+0x30c>)
     204:	f3c0 000a 	ubfx	r0, r0, #0, #11
     208:	e76e      	b.n	e8 <ecc_test+0xe8>
            ret = wc_ecc_shared_secret(userB, userA, sharedB, &y);
     20a:	ab0e      	add	r3, sp, #56	; 0x38
     20c:	4652      	mov	r2, sl
     20e:	4621      	mov	r1, r4
     210:	4628      	mov	r0, r5
    y = ECC_SHARED_SIZE;
     212:	970e      	str	r7, [sp, #56]	; 0x38
            ret = wc_ecc_shared_secret(userB, userA, sharedB, &y);
     214:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
    } while (ret == WC_PENDING_E);
     218:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
     21c:	d100      	bne.n	220 <ecc_test+0x220>
     21e:	e7fe      	b.n	21e <ecc_test+0x21e>
    if (ret != 0)
     220:	b128      	cbz	r0, 22e <ecc_test+0x22e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     222:	4240      	negs	r0, r0
     224:	4b30      	ldr	r3, [pc, #192]	; (2e8 <ecc_test+0x2e8>)
     226:	4f3a      	ldr	r7, [pc, #232]	; (310 <ecc_test+0x310>)
     228:	f3c0 000a 	ubfx	r0, r0, #0, #11
     22c:	e75c      	b.n	e8 <ecc_test+0xe8>
    if (y != x)
     22e:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
     230:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     232:	4293      	cmp	r3, r2
     234:	f040 812d 	bne.w	492 <ecc_test+0x492>
    if (XMEMCMP(sharedA, sharedB, x))
     238:	4651      	mov	r1, sl
     23a:	4658      	mov	r0, fp
     23c:	f7ff fffe 	bl	0 <memcmp>
     240:	4603      	mov	r3, r0
     242:	2800      	cmp	r0, #0
     244:	f040 8127 	bne.w	496 <ecc_test+0x496>
    x = ECC_KEY_EXPORT_BUF_SIZE;
     248:	2260      	movs	r2, #96	; 0x60
     24a:	921f      	str	r2, [sp, #124]	; 0x7c
    ret = wc_ecc_export_x963_ex(userA, exportBuf, &x, 0);
     24c:	9906      	ldr	r1, [sp, #24]
     24e:	aa1f      	add	r2, sp, #124	; 0x7c
     250:	4620      	mov	r0, r4
     252:	f7ff fffe 	bl	0 <wc_ecc_export_x963_ex>
    if (ret != 0)
     256:	4603      	mov	r3, r0
     258:	b128      	cbz	r0, 266 <ecc_test+0x266>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     25a:	4243      	negs	r3, r0
     25c:	4f22      	ldr	r7, [pc, #136]	; (2e8 <ecc_test+0x2e8>)
     25e:	482d      	ldr	r0, [pc, #180]	; (314 <ecc_test+0x314>)
     260:	f3c3 030a 	ubfx	r3, r3, #0, #11
     264:	e75f      	b.n	126 <ecc_test+0x126>
    ret = wc_ecc_import_x963_ex(exportBuf, x, pubKey, curve_id);
     266:	991f      	ldr	r1, [sp, #124]	; 0x7c
     268:	9806      	ldr	r0, [sp, #24]
     26a:	4642      	mov	r2, r8
     26c:	f7ff fffe 	bl	0 <wc_ecc_import_x963_ex>
    if (ret != 0)
     270:	b128      	cbz	r0, 27e <ecc_test+0x27e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     272:	4240      	negs	r0, r0
     274:	4b1c      	ldr	r3, [pc, #112]	; (2e8 <ecc_test+0x2e8>)
     276:	4f28      	ldr	r7, [pc, #160]	; (318 <ecc_test+0x318>)
     278:	f3c0 000a 	ubfx	r0, r0, #0, #11
     27c:	e734      	b.n	e8 <ecc_test+0xe8>
    y = ECC_SHARED_SIZE;
     27e:	2380      	movs	r3, #128	; 0x80
     280:	930e      	str	r3, [sp, #56]	; 0x38
            ret = wc_ecc_shared_secret(userB, pubKey, sharedB, &y);
     282:	4652      	mov	r2, sl
     284:	ab0e      	add	r3, sp, #56	; 0x38
     286:	4641      	mov	r1, r8
     288:	4628      	mov	r0, r5
     28a:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
    } while (ret == WC_PENDING_E);
     28e:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
     292:	d100      	bne.n	296 <ecc_test+0x296>
     294:	e7fe      	b.n	294 <ecc_test+0x294>
    if (ret != 0)
     296:	b128      	cbz	r0, 2a4 <ecc_test+0x2a4>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     298:	4240      	negs	r0, r0
     29a:	4b13      	ldr	r3, [pc, #76]	; (2e8 <ecc_test+0x2e8>)
     29c:	4f1f      	ldr	r7, [pc, #124]	; (31c <ecc_test+0x31c>)
     29e:	f3c0 000a 	ubfx	r0, r0, #0, #11
     2a2:	e721      	b.n	e8 <ecc_test+0xe8>
    if (XMEMCMP(sharedA, sharedB, y))
     2a4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
     2a6:	4651      	mov	r1, sl
     2a8:	4658      	mov	r0, fp
     2aa:	f7ff fffe 	bl	0 <memcmp>
     2ae:	2800      	cmp	r0, #0
     2b0:	f040 80f3 	bne.w	49a <ecc_test+0x49a>
     2b4:	1e73      	subs	r3, r6, #1
     2b6:	f106 021f 	add.w	r2, r6, #31
        digest[i] = 0;
     2ba:	f803 0f01 	strb.w	r0, [r3, #1]!
    for (i = 0; i < (int)ECC_DIGEST_SIZE; i++) {
     2be:	429a      	cmp	r2, r3
     2c0:	d1fb      	bne.n	2ba <ecc_test+0x2ba>
    x = ECC_SIG_SIZE;
     2c2:	2349      	movs	r3, #73	; 0x49
     2c4:	931f      	str	r3, [sp, #124]	; 0x7c
            ret = wc_ecc_sign_hash(digest, ECC_DIGEST_SIZE, sig, &x, rng,
     2c6:	ab0c      	add	r3, sp, #48	; 0x30
     2c8:	9300      	str	r3, [sp, #0]
     2ca:	9401      	str	r4, [sp, #4]
     2cc:	ab1f      	add	r3, sp, #124	; 0x7c
     2ce:	464a      	mov	r2, r9
     2d0:	2120      	movs	r1, #32
     2d2:	4630      	mov	r0, r6
     2d4:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
    } while (ret == WC_PENDING_E);
     2d8:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
            ret = wc_ecc_sign_hash(digest, ECC_DIGEST_SIZE, sig, &x, rng,
     2dc:	4607      	mov	r7, r0
    } while (ret == WC_PENDING_E);
     2de:	d11f      	bne.n	320 <ecc_test+0x320>
     2e0:	e7fe      	b.n	2e0 <ecc_test+0x2e0>
     2e2:	bf00      	nop
     2e4:	dfff8e9d 	.word	0xdfff8e9d
     2e8:	fffe7960 	.word	0xfffe7960
     2ec:	dfff9937 	.word	0xdfff9937
     2f0:	dfff9934 	.word	0xdfff9934
     2f4:	dfff9931 	.word	0xdfff9931
     2f8:	dfff9916 	.word	0xdfff9916
     2fc:	ffff9910 	.word	0xffff9910
     300:	dfff990b 	.word	0xdfff990b
     304:	dfff98f3 	.word	0xdfff98f3
     308:	dfff98f0 	.word	0xdfff98f0
     30c:	dfff98e4 	.word	0xdfff98e4
     310:	dfff98d8 	.word	0xdfff98d8
     314:	dfff98a1 	.word	0xdfff98a1
     318:	dfff9895 	.word	0xdfff9895
     31c:	dfff9888 	.word	0xdfff9888
    if (ret != 0)
     320:	b128      	cbz	r0, 32e <ecc_test+0x32e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     322:	4240      	negs	r0, r0
     324:	4ba6      	ldr	r3, [pc, #664]	; (5c0 <ecc_test+0x5c0>)
     326:	4fa7      	ldr	r7, [pc, #668]	; (5c4 <ecc_test+0x5c4>)
     328:	f3c0 000a 	ubfx	r0, r0, #0, #11
     32c:	e6dc      	b.n	e8 <ecc_test+0xe8>
     32e:	2302      	movs	r3, #2
     330:	9307      	str	r3, [sp, #28]
                ret = wc_ecc_verify_hash(sig, x, digest, ECC_DIGEST_SIZE,
     332:	ab30      	add	r3, sp, #192	; 0xc0
     334:	991f      	ldr	r1, [sp, #124]	; 0x7c
     336:	9300      	str	r3, [sp, #0]
     338:	9401      	str	r4, [sp, #4]
     33a:	2320      	movs	r3, #32
     33c:	4632      	mov	r2, r6
     33e:	4648      	mov	r0, r9
        verify = 0;
     340:	9730      	str	r7, [sp, #192]	; 0xc0
                ret = wc_ecc_verify_hash(sig, x, digest, ECC_DIGEST_SIZE,
     342:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
        } while (ret == WC_PENDING_E);
     346:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
                ret = wc_ecc_verify_hash(sig, x, digest, ECC_DIGEST_SIZE,
     34a:	4601      	mov	r1, r0
        } while (ret == WC_PENDING_E);
     34c:	d100      	bne.n	350 <ecc_test+0x350>
     34e:	e7fe      	b.n	34e <ecc_test+0x34e>
        if (ret != 0)
     350:	b128      	cbz	r0, 35e <ecc_test+0x35e>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     352:	4241      	negs	r1, r0
     354:	4f9a      	ldr	r7, [pc, #616]	; (5c0 <ecc_test+0x5c0>)
     356:	489c      	ldr	r0, [pc, #624]	; (5c8 <ecc_test+0x5c8>)
     358:	f3c1 010a 	ubfx	r1, r1, #0, #11
     35c:	e6d4      	b.n	108 <ecc_test+0x108>
        if (verify != 1)
     35e:	9b30      	ldr	r3, [sp, #192]	; 0xc0
     360:	2b01      	cmp	r3, #1
     362:	f040 809c 	bne.w	49e <ecc_test+0x49e>
    for (i=0; i<testVerifyCount; i++) {
     366:	9a07      	ldr	r2, [sp, #28]
     368:	2a01      	cmp	r2, #1
     36a:	d1e1      	bne.n	330 <ecc_test+0x330>
        digest[i] = (byte)i;
     36c:	5471      	strb	r1, [r6, r1]
    for (i = 0; i < (int)ECC_DIGEST_SIZE; i++) {
     36e:	3101      	adds	r1, #1
     370:	2920      	cmp	r1, #32
     372:	d1fb      	bne.n	36c <ecc_test+0x36c>
    x = ECC_SIG_SIZE;
     374:	2349      	movs	r3, #73	; 0x49
     376:	931f      	str	r3, [sp, #124]	; 0x7c
            ret = wc_ecc_sign_hash(digest, ECC_DIGEST_SIZE, sig, &x, rng, userA);
     378:	ab0c      	add	r3, sp, #48	; 0x30
     37a:	9300      	str	r3, [sp, #0]
     37c:	9401      	str	r4, [sp, #4]
     37e:	ab1f      	add	r3, sp, #124	; 0x7c
     380:	464a      	mov	r2, r9
     382:	4630      	mov	r0, r6
     384:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
    } while (ret == WC_PENDING_E);
     388:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
            ret = wc_ecc_sign_hash(digest, ECC_DIGEST_SIZE, sig, &x, rng, userA);
     38c:	4607      	mov	r7, r0
    } while (ret == WC_PENDING_E);
     38e:	d100      	bne.n	392 <ecc_test+0x392>
     390:	e7fe      	b.n	390 <ecc_test+0x390>
    if (ret != 0)
     392:	b128      	cbz	r0, 3a0 <ecc_test+0x3a0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     394:	4247      	negs	r7, r0
     396:	4b8a      	ldr	r3, [pc, #552]	; (5c0 <ecc_test+0x5c0>)
     398:	488c      	ldr	r0, [pc, #560]	; (5cc <ecc_test+0x5cc>)
     39a:	f3c7 070a 	ubfx	r7, r7, #0, #11
     39e:	e6c2      	b.n	126 <ecc_test+0x126>
     3a0:	2302      	movs	r3, #2
     3a2:	9307      	str	r3, [sp, #28]
                ret = wc_ecc_verify_hash(sig, x, digest, ECC_DIGEST_SIZE, &verify, userA);
     3a4:	ab30      	add	r3, sp, #192	; 0xc0
     3a6:	9300      	str	r3, [sp, #0]
     3a8:	991f      	ldr	r1, [sp, #124]	; 0x7c
     3aa:	9401      	str	r4, [sp, #4]
     3ac:	2320      	movs	r3, #32
     3ae:	4632      	mov	r2, r6
     3b0:	4648      	mov	r0, r9
        verify = 0;
     3b2:	9730      	str	r7, [sp, #192]	; 0xc0
                ret = wc_ecc_verify_hash(sig, x, digest, ECC_DIGEST_SIZE, &verify, userA);
     3b4:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
        } while (ret == WC_PENDING_E);
     3b8:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
     3bc:	d100      	bne.n	3c0 <ecc_test+0x3c0>
     3be:	e7fe      	b.n	3be <ecc_test+0x3be>
        if (ret != 0)
     3c0:	b128      	cbz	r0, 3ce <ecc_test+0x3ce>
            ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     3c2:	4240      	negs	r0, r0
     3c4:	4b7e      	ldr	r3, [pc, #504]	; (5c0 <ecc_test+0x5c0>)
     3c6:	4f82      	ldr	r7, [pc, #520]	; (5d0 <ecc_test+0x5d0>)
     3c8:	f3c0 000a 	ubfx	r0, r0, #0, #11
     3cc:	e68c      	b.n	e8 <ecc_test+0xe8>
        if (verify != 1)
     3ce:	9b30      	ldr	r3, [sp, #192]	; 0xc0
     3d0:	2b01      	cmp	r3, #1
     3d2:	d166      	bne.n	4a2 <ecc_test+0x4a2>
    for (i=0; i<testVerifyCount; i++) {
     3d4:	9a07      	ldr	r2, [sp, #28]
     3d6:	2a01      	cmp	r2, #1
     3d8:	d1e3      	bne.n	3a2 <ecc_test+0x3a2>
    x = ECC_KEY_EXPORT_BUF_SIZE;
     3da:	2360      	movs	r3, #96	; 0x60
    ret = wc_ecc_export_private_only(userA, exportBuf, &x);
     3dc:	9906      	ldr	r1, [sp, #24]
    x = ECC_KEY_EXPORT_BUF_SIZE;
     3de:	931f      	str	r3, [sp, #124]	; 0x7c
    ret = wc_ecc_export_private_only(userA, exportBuf, &x);
     3e0:	aa1f      	add	r2, sp, #124	; 0x7c
     3e2:	4620      	mov	r0, r4
     3e4:	f7ff fffe 	bl	0 <wc_ecc_export_private_only>
    if (ret != 0)
     3e8:	4607      	mov	r7, r0
     3ea:	2800      	cmp	r0, #0
     3ec:	f43f aea8 	beq.w	140 <ecc_test+0x140>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     3f0:	4240      	negs	r0, r0
     3f2:	4b73      	ldr	r3, [pc, #460]	; (5c0 <ecc_test+0x5c0>)
     3f4:	4f77      	ldr	r7, [pc, #476]	; (5d4 <ecc_test+0x5d4>)
     3f6:	f3c0 000a 	ubfx	r0, r0, #0, #11
     3fa:	e675      	b.n	e8 <ecc_test+0xe8>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, done);
     3fc:	4f76      	ldr	r7, [pc, #472]	; (5d8 <ecc_test+0x5d8>)
    if (userA != NULL) {
     3fe:	2c00      	cmp	r4, #0
     400:	f47f ae9e 	bne.w	140 <ecc_test+0x140>
    if (userB != NULL) {
     404:	b12d      	cbz	r5, 412 <ecc_test+0x412>
        wc_ecc_free(userB);
     406:	4628      	mov	r0, r5
     408:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(userB, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     40c:	4628      	mov	r0, r5
     40e:	f7ff fffe 	bl	0 <free>
    if (pubKey != NULL) {
     412:	f1b8 0f00 	cmp.w	r8, #0
     416:	d005      	beq.n	424 <ecc_test+0x424>
        wc_ecc_free(pubKey);
     418:	4640      	mov	r0, r8
     41a:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(pubKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     41e:	4640      	mov	r0, r8
     420:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(sharedA, HEAP_HINT);
     424:	f1bb 0f00 	cmp.w	fp, #0
     428:	d002      	beq.n	430 <ecc_test+0x430>
     42a:	4658      	mov	r0, fp
     42c:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(sharedB, HEAP_HINT);
     430:	f1ba 0f00 	cmp.w	sl, #0
     434:	d002      	beq.n	43c <ecc_test+0x43c>
     436:	4650      	mov	r0, sl
     438:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(exportBuf, HEAP_HINT);
     43c:	9b06      	ldr	r3, [sp, #24]
     43e:	b113      	cbz	r3, 446 <ecc_test+0x446>
     440:	4618      	mov	r0, r3
     442:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(sig, HEAP_HINT);
     446:	f1b9 0f00 	cmp.w	r9, #0
     44a:	d002      	beq.n	452 <ecc_test+0x452>
     44c:	4648      	mov	r0, r9
     44e:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(digest, HEAP_HINT);
     452:	b116      	cbz	r6, 45a <ecc_test+0x45a>
     454:	4630      	mov	r0, r6
     456:	f7ff fffe 	bl	0 <free>
    if (ret < 0) {
     45a:	b337      	cbz	r7, 4aa <ecc_test+0x4aa>
        if (ret == ECC_CURVE_OID_E) {
     45c:	f117 0fac 	cmn.w	r7, #172	; 0xac
     460:	d023      	beq.n	4aa <ecc_test+0x4aa>
            printf("ecc_test_curve_size %d failed!\n", keySize);
     462:	485e      	ldr	r0, [pc, #376]	; (5dc <ecc_test+0x5dc>)
     464:	2120      	movs	r1, #32
            printf("ecc_test_key_gen %d failed!\n", keySize);
     466:	f7ff fffe 	bl	0 <printf>
     46a:	4b5d      	ldr	r3, [pc, #372]	; (5e0 <ecc_test+0x5e0>)
     46c:	681b      	ldr	r3, [r3, #0]
     46e:	6898      	ldr	r0, [r3, #8]
     470:	f7ff fffe 	bl	0 <fflush>
        printf("keySize=32, Default\n");
     474:	485b      	ldr	r0, [pc, #364]	; (5e4 <ecc_test+0x5e4>)
        printf("ecc_test_allocator failed!\n");
     476:	f7ff fffe 	bl	0 <printf>
     47a:	4b59      	ldr	r3, [pc, #356]	; (5e0 <ecc_test+0x5e0>)
     47c:	681b      	ldr	r3, [r3, #0]
     47e:	6898      	ldr	r0, [r3, #8]
     480:	f7ff fffe 	bl	0 <fflush>
        goto done;
     484:	e221      	b.n	8ca <ecc_test+0x8ca>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, done);
     486:	4f58      	ldr	r7, [pc, #352]	; (5e8 <ecc_test+0x5e8>)
     488:	e7b9      	b.n	3fe <ecc_test+0x3fe>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, done);
     48a:	4f58      	ldr	r7, [pc, #352]	; (5ec <ecc_test+0x5ec>)
     48c:	e7b7      	b.n	3fe <ecc_test+0x3fe>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     48e:	4f58      	ldr	r7, [pc, #352]	; (5f0 <ecc_test+0x5f0>)
     490:	e656      	b.n	140 <ecc_test+0x140>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     492:	4f58      	ldr	r7, [pc, #352]	; (5f4 <ecc_test+0x5f4>)
     494:	e654      	b.n	140 <ecc_test+0x140>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     496:	4f58      	ldr	r7, [pc, #352]	; (5f8 <ecc_test+0x5f8>)
     498:	e652      	b.n	140 <ecc_test+0x140>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     49a:	4f58      	ldr	r7, [pc, #352]	; (5fc <ecc_test+0x5fc>)
     49c:	e650      	b.n	140 <ecc_test+0x140>
            ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     49e:	4f58      	ldr	r7, [pc, #352]	; (600 <ecc_test+0x600>)
     4a0:	e64e      	b.n	140 <ecc_test+0x140>
            ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     4a2:	4f58      	ldr	r7, [pc, #352]	; (604 <ecc_test+0x604>)
     4a4:	e64c      	b.n	140 <ecc_test+0x140>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     4a6:	4f52      	ldr	r7, [pc, #328]	; (5f0 <ecc_test+0x5f0>)
     4a8:	e7ac      	b.n	404 <ecc_test+0x404>
    XMEMSET(&vec, 0, sizeof(vec));
     4aa:	2234      	movs	r2, #52	; 0x34
     4ac:	2100      	movs	r1, #0
     4ae:	a830      	add	r0, sp, #192	; 0xc0
     4b0:	f7ff fffe 	bl	0 <memset>
            vec.msg = "\xa3\xf9\x1a\xe2\x1b\xa6\xb3\x03\x98\x64\x47\x2f\x18\x41\x44\xc6\xaf\x62\xcd\x0e";
     4b4:	4b54      	ldr	r3, [pc, #336]	; (608 <ecc_test+0x608>)
     4b6:	9330      	str	r3, [sp, #192]	; 0xc0
            vec.msgLen = 20;
     4b8:	2314      	movs	r3, #20
     4ba:	9337      	str	r3, [sp, #220]	; 0xdc
        vec.Qx  = "fa2737fb93488d19caef11ae7faf6b7f4bcd67b286e3fc54e8a65c2b74aeccb0";
     4bc:	4b53      	ldr	r3, [pc, #332]	; (60c <ecc_test+0x60c>)
     4be:	9331      	str	r3, [sp, #196]	; 0xc4
        vec.Qy  = "d4ccd6dae698208aa8c3a6f39e45510d03be09b2f124bfc067856c324f9b4d09";
     4c0:	4b53      	ldr	r3, [pc, #332]	; (610 <ecc_test+0x610>)
     4c2:	9332      	str	r3, [sp, #200]	; 0xc8
        vec.d   = "be34baa8d040a3b991f9075b56ba292f755b90e4b6dc10dad36715c33cfdac25";
     4c4:	4b53      	ldr	r3, [pc, #332]	; (614 <ecc_test+0x614>)
     4c6:	9333      	str	r3, [sp, #204]	; 0xcc
        vec.R   = "2b826f5d44e2d0b6de531ad96b51e8f0c56fdfead3c236892e4d84eacfc3b75c";
     4c8:	4b53      	ldr	r3, [pc, #332]	; (618 <ecc_test+0x618>)
     4ca:	9334      	str	r3, [sp, #208]	; 0xd0
        vec.S   = "a2248b62c03db35a7cd63e8a120a3521a89d3d2f61ff99035a2148ae32e3a248";
     4cc:	4b53      	ldr	r3, [pc, #332]	; (61c <ecc_test+0x61c>)
     4ce:	9335      	str	r3, [sp, #212]	; 0xd4
        vec.r   = (byte*)"\x2b\x82\x6f\x5d\x44\xe2\xd0\xb6\xde\x53\x1a\xd9"
     4d0:	4b53      	ldr	r3, [pc, #332]	; (620 <ecc_test+0x620>)
    vec.keySize = (word32)keySize;
     4d2:	2720      	movs	r7, #32
        vec.rSz = 32;
     4d4:	e9cd 3739 	strd	r3, r7, [sp, #228]	; 0xe4
        vec.s   = (byte*)"\xa2\x24\x8b\x62\xc0\x3d\xb3\x5a\x7c\xd6\x3e\x8a"
     4d8:	4b52      	ldr	r3, [pc, #328]	; (624 <ecc_test+0x624>)
    vec.keySize = (word32)keySize;
     4da:	9738      	str	r7, [sp, #224]	; 0xe0
        vec.sSz = 32;
     4dc:	e9cd 373b 	strd	r3, r7, [sp, #236]	; 0xec
    int verify = 0;
     4e0:	f04f 0a00 	mov.w	sl, #0
        vec.curveName = "SECP256R1";
     4e4:	4b50      	ldr	r3, [pc, #320]	; (628 <ecc_test+0x628>)
     4e6:	9336      	str	r3, [sp, #216]	; 0xd8
    ecc_key *userA = (ecc_key *)XMALLOC(sizeof *userA, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     4e8:	f44f 70de 	mov.w	r0, #444	; 0x1bc
    int verify = 0;
     4ec:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    ecc_key *userA = (ecc_key *)XMALLOC(sizeof *userA, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     4f0:	f7ff fffe 	bl	0 <malloc>
     4f4:	4604      	mov	r4, r0
    WC_DECLARE_VAR(sig, byte, ECC_SIG_SIZE, HEAP_HINT);
     4f6:	2049      	movs	r0, #73	; 0x49
     4f8:	f7ff fffe 	bl	0 <malloc>
     4fc:	4605      	mov	r5, r0
    WC_DECLARE_VAR(sigRaw, byte, ECC_SIG_SIZE, HEAP_HINT);
     4fe:	2049      	movs	r0, #73	; 0x49
    word32  sigRawSz, rSz = MAX_ECC_BYTES, sSz = MAX_ECC_BYTES;
     500:	970e      	str	r7, [sp, #56]	; 0x38
     502:	971f      	str	r7, [sp, #124]	; 0x7c
    WC_DECLARE_VAR(sigRaw, byte, ECC_SIG_SIZE, HEAP_HINT);
     504:	f7ff fffe 	bl	0 <malloc>
     508:	4606      	mov	r6, r0
    WC_DECLARE_VAR(r, byte, MAX_ECC_BYTES, HEAP_HINT);
     50a:	4638      	mov	r0, r7
     50c:	f7ff fffe 	bl	0 <malloc>
     510:	4680      	mov	r8, r0
    WC_DECLARE_VAR(s, byte, MAX_ECC_BYTES, HEAP_HINT);
     512:	4638      	mov	r0, r7
     514:	f7ff fffe 	bl	0 <malloc>
     518:	4681      	mov	r9, r0
    if (sig == NULL)
     51a:	2d00      	cmp	r5, #0
     51c:	f000 80c9 	beq.w	6b2 <ecc_test+0x6b2>
    if (sigRaw == NULL || r == NULL || s == NULL)
     520:	2e00      	cmp	r6, #0
     522:	f000 8713 	beq.w	134c <ecc_test+0x134c>
     526:	f1b8 0f00 	cmp.w	r8, #0
     52a:	f000 8705 	beq.w	1338 <ecc_test+0x1338>
     52e:	2800      	cmp	r0, #0
     530:	f000 8702 	beq.w	1338 <ecc_test+0x1338>
    if (userA == NULL)
     534:	2c00      	cmp	r4, #0
     536:	f000 8702 	beq.w	133e <ecc_test+0x133e>
    ret = wc_ecc_init_ex(userA, HEAP_HINT, devId);
     53a:	f06f 0201 	mvn.w	r2, #1
     53e:	4651      	mov	r1, sl
     540:	4620      	mov	r0, r4
     542:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
     546:	4607      	mov	r7, r0
     548:	bb90      	cbnz	r0, 5b0 <ecc_test+0x5b0>
    ret = wc_ecc_import_raw(userA, vector->Qx, vector->Qy,
     54a:	9b36      	ldr	r3, [sp, #216]	; 0xd8
     54c:	9300      	str	r3, [sp, #0]
     54e:	9931      	ldr	r1, [sp, #196]	; 0xc4
     550:	e9dd 2332 	ldrd	r2, r3, [sp, #200]	; 0xc8
     554:	4620      	mov	r0, r4
     556:	f7ff fffe 	bl	0 <wc_ecc_import_raw>
    if (ret != 0)
     55a:	4607      	mov	r7, r0
     55c:	bb40      	cbnz	r0, 5b0 <ecc_test+0x5b0>
    XMEMSET(sig, 0, ECC_SIG_SIZE);
     55e:	4601      	mov	r1, r0
     560:	2249      	movs	r2, #73	; 0x49
     562:	4628      	mov	r0, r5
     564:	f7ff fffe 	bl	0 <memset>
    sigSz = ECC_SIG_SIZE;
     568:	f04f 0b49 	mov.w	fp, #73	; 0x49
    ret = wc_ecc_rs_to_sig(vector->R, vector->S, sig, &sigSz);
     56c:	e9dd 0134 	ldrd	r0, r1, [sp, #208]	; 0xd0
     570:	ab0a      	add	r3, sp, #40	; 0x28
     572:	462a      	mov	r2, r5
    sigSz = ECC_SIG_SIZE;
     574:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
    ret = wc_ecc_rs_to_sig(vector->R, vector->S, sig, &sigSz);
     578:	f7ff fffe 	bl	0 <wc_ecc_rs_to_sig>
    if (ret != 0)
     57c:	4607      	mov	r7, r0
     57e:	b9b8      	cbnz	r0, 5b0 <ecc_test+0x5b0>
    XMEMSET(sigRaw, 0, ECC_SIG_SIZE);
     580:	4601      	mov	r1, r0
     582:	465a      	mov	r2, fp
     584:	4630      	mov	r0, r6
    sigRawSz = ECC_SIG_SIZE;
     586:	f10d 0a2c 	add.w	sl, sp, #44	; 0x2c
    XMEMSET(sigRaw, 0, ECC_SIG_SIZE);
     58a:	f7ff fffe 	bl	0 <memset>
    ret = wc_ecc_rs_raw_to_sig(vector->r, vector->rSz, vector->s, vector->sSz,
     58e:	e9cd 6a00 	strd	r6, sl, [sp]
     592:	e9dd 233b 	ldrd	r2, r3, [sp, #236]	; 0xec
     596:	e9dd 0139 	ldrd	r0, r1, [sp, #228]	; 0xe4
    sigRawSz = ECC_SIG_SIZE;
     59a:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
    ret = wc_ecc_rs_raw_to_sig(vector->r, vector->rSz, vector->s, vector->sSz,
     59e:	f7ff fffe 	bl	0 <wc_ecc_rs_raw_to_sig>
    if (ret != 0)
     5a2:	4607      	mov	r7, r0
     5a4:	b920      	cbnz	r0, 5b0 <ecc_test+0x5b0>
    if (sigSz != sigRawSz || XMEMCMP(sig, sigRaw, sigSz) != 0) {
     5a6:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
     5aa:	429a      	cmp	r2, r3
     5ac:	d040      	beq.n	630 <ecc_test+0x630>
        ret = WC_TEST_RET_ENC_NC;
     5ae:	4f1f      	ldr	r7, [pc, #124]	; (62c <ecc_test+0x62c>)
        wc_ecc_free(userA);
     5b0:	4620      	mov	r0, r4
     5b2:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(userA, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     5b6:	4620      	mov	r0, r4
     5b8:	f7ff fffe 	bl	0 <free>
     5bc:	e07e      	b.n	6bc <ecc_test+0x6bc>
     5be:	bf00      	nop
     5c0:	fffe7960 	.word	0xfffe7960
     5c4:	dfff983b 	.word	0xdfff983b
     5c8:	dfff982c 	.word	0xdfff982c
     5cc:	dfff9816 	.word	0xdfff9816
     5d0:	dfff9808 	.word	0xdfff9808
     5d4:	dfff97f8 	.word	0xdfff97f8
     5d8:	ffff9958 	.word	0xffff9958
	...
     5e4:	0000021f 	.word	0x0000021f
     5e8:	ffff9953 	.word	0xffff9953
     5ec:	ffff994c 	.word	0xffff994c
     5f0:	ffff9940 	.word	0xffff9940
     5f4:	ffff98d5 	.word	0xffff98d5
     5f8:	ffff98d2 	.word	0xffff98d2
     5fc:	ffff9885 	.word	0xffff9885
     600:	ffff982a 	.word	0xffff982a
     604:	ffff9806 	.word	0xffff9806
     608:	00000020 	.word	0x00000020
     60c:	00000035 	.word	0x00000035
     610:	00000076 	.word	0x00000076
     614:	000000b7 	.word	0x000000b7
     618:	000000f8 	.word	0x000000f8
     61c:	00000139 	.word	0x00000139
     620:	0000017a 	.word	0x0000017a
     624:	0000019b 	.word	0x0000019b
     628:	000001bc 	.word	0x000001bc
     62c:	ffff9ea3 	.word	0xffff9ea3
    if (sigSz != sigRawSz || XMEMCMP(sig, sigRaw, sigSz) != 0) {
     630:	4631      	mov	r1, r6
     632:	4628      	mov	r0, r5
     634:	f7ff fffe 	bl	0 <memcmp>
     638:	2800      	cmp	r0, #0
     63a:	d1b8      	bne.n	5ae <ecc_test+0x5ae>
    ret = wc_ecc_sig_to_rs(sig, sigSz, r, &rSz, s, &sSz);
     63c:	ab1f      	add	r3, sp, #124	; 0x7c
     63e:	e9cd 9300 	strd	r9, r3, [sp]
     642:	990a      	ldr	r1, [sp, #40]	; 0x28
     644:	ab0e      	add	r3, sp, #56	; 0x38
     646:	4642      	mov	r2, r8
     648:	4628      	mov	r0, r5
     64a:	f7ff fffe 	bl	0 <wc_ecc_sig_to_rs>
    if (ret != 0)
     64e:	4607      	mov	r7, r0
     650:	2800      	cmp	r0, #0
     652:	d1ad      	bne.n	5b0 <ecc_test+0x5b0>
    if (rSz != vector->rSz || XMEMCMP(r, vector->r, rSz) != 0 ||
     654:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     656:	9a3a      	ldr	r2, [sp, #232]	; 0xe8
     658:	429a      	cmp	r2, r3
     65a:	d001      	beq.n	660 <ecc_test+0x660>
        ret = WC_TEST_RET_ENC_NC;
     65c:	4fa2      	ldr	r7, [pc, #648]	; (8e8 <ecc_test+0x8e8>)
     65e:	e7a7      	b.n	5b0 <ecc_test+0x5b0>
    if (rSz != vector->rSz || XMEMCMP(r, vector->r, rSz) != 0 ||
     660:	9939      	ldr	r1, [sp, #228]	; 0xe4
     662:	4640      	mov	r0, r8
     664:	f7ff fffe 	bl	0 <memcmp>
     668:	2800      	cmp	r0, #0
     66a:	d1f7      	bne.n	65c <ecc_test+0x65c>
     66c:	9a3c      	ldr	r2, [sp, #240]	; 0xf0
     66e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     670:	429a      	cmp	r2, r3
     672:	d1f3      	bne.n	65c <ecc_test+0x65c>
        sSz != vector->sSz || XMEMCMP(s, vector->s, sSz) != 0) {
     674:	993b      	ldr	r1, [sp, #236]	; 0xec
     676:	4648      	mov	r0, r9
     678:	f7ff fffe 	bl	0 <memcmp>
     67c:	2800      	cmp	r0, #0
     67e:	d1ed      	bne.n	65c <ecc_test+0x65c>
            ret = wc_ecc_verify_hash(sig, sigSz, (byte*)vector->msg,
     680:	f10d 0a24 	add.w	sl, sp, #36	; 0x24
     684:	9b37      	ldr	r3, [sp, #220]	; 0xdc
     686:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     688:	990a      	ldr	r1, [sp, #40]	; 0x28
     68a:	9401      	str	r4, [sp, #4]
     68c:	f8cd a000 	str.w	sl, [sp]
     690:	4628      	mov	r0, r5
     692:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
    } while (ret == WC_PENDING_E);
     696:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
            ret = wc_ecc_verify_hash(sig, sigSz, (byte*)vector->msg,
     69a:	4607      	mov	r7, r0
    } while (ret == WC_PENDING_E);
     69c:	d100      	bne.n	6a0 <ecc_test+0x6a0>
     69e:	e7fe      	b.n	69e <ecc_test+0x69e>
    if (ret != 0)
     6a0:	2800      	cmp	r0, #0
     6a2:	d185      	bne.n	5b0 <ecc_test+0x5b0>
    if (verify != 1)
     6a4:	f8da 2000 	ldr.w	r2, [sl]
        ret = WC_TEST_RET_ENC_NC;
     6a8:	4b90      	ldr	r3, [pc, #576]	; (8ec <ecc_test+0x8ec>)
     6aa:	2a01      	cmp	r2, #1
     6ac:	bf18      	it	ne
     6ae:	461f      	movne	r7, r3
     6b0:	e77e      	b.n	5b0 <ecc_test+0x5b0>
        ERROR_OUT(MEMORY_E, done);
     6b2:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    if (userA != NULL) {
     6b6:	2c00      	cmp	r4, #0
     6b8:	f47f af7a 	bne.w	5b0 <ecc_test+0x5b0>
    WC_FREE_VAR(sigRaw, HEAP_HINT);
     6bc:	2e00      	cmp	r6, #0
     6be:	f040 8640 	bne.w	1342 <ecc_test+0x1342>
    WC_FREE_VAR(r, HEAP_HINT);
     6c2:	f1b8 0f00 	cmp.w	r8, #0
     6c6:	d002      	beq.n	6ce <ecc_test+0x6ce>
     6c8:	4640      	mov	r0, r8
     6ca:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(s, HEAP_HINT);
     6ce:	f1b9 0f00 	cmp.w	r9, #0
     6d2:	d002      	beq.n	6da <ecc_test+0x6da>
     6d4:	4648      	mov	r0, r9
     6d6:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(sig, HEAP_HINT);
     6da:	b115      	cbz	r5, 6e2 <ecc_test+0x6e2>
     6dc:	4628      	mov	r0, r5
     6de:	f7ff fffe 	bl	0 <free>
    if (ret < 0) {
     6e2:	2f00      	cmp	r7, #0
     6e4:	da05      	bge.n	6f2 <ecc_test+0x6f2>
        printf("ecc_test_vector %d failed!\n", keySize);
     6e6:	4882      	ldr	r0, [pc, #520]	; (8f0 <ecc_test+0x8f0>)
     6e8:	2120      	movs	r1, #32
     6ea:	e6bc      	b.n	466 <ecc_test+0x466>
        ERROR_OUT(MEMORY_E, done);
     6ec:	f06f 077c 	mvn.w	r7, #124	; 0x7c
     6f0:	e75e      	b.n	5b0 <ecc_test+0x5b0>
    ecc_key *eccKey = (ecc_key *)XMALLOC(sizeof *eccKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     6f2:	f44f 70de 	mov.w	r0, #444	; 0x1bc
     6f6:	f7ff fffe 	bl	0 <malloc>
     6fa:	4604      	mov	r4, r0
    byte *tmpBuf = (byte *)XMALLOC(ECC_BUFSIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     6fc:	f240 1001 	movw	r0, #257	; 0x101
     700:	f7ff fffe 	bl	0 <malloc>
     704:	4606      	mov	r6, r0
    if ((eccKey == NULL) || (tmpBuf == NULL))
     706:	2c00      	cmp	r4, #0
     708:	f000 862d 	beq.w	1366 <ecc_test+0x1366>
     70c:	2800      	cmp	r0, #0
     70e:	f000 860c 	beq.w	132a <ecc_test+0x132a>
    ret = wc_ecc_init(eccKey);
     712:	4620      	mov	r0, r4
     714:	f7ff fffe 	bl	0 <wc_ecc_init>
    if (ret != 0) {
     718:	4607      	mov	r7, r0
     71a:	bb88      	cbnz	r0, 780 <ecc_test+0x780>
    ret = wc_ecc_make_key(rng, keySize, eccKey);
     71c:	4622      	mov	r2, r4
     71e:	2120      	movs	r1, #32
     720:	a80c      	add	r0, sp, #48	; 0x30
     722:	f7ff fffe 	bl	0 <wc_ecc_make_key>
    if (ret != 0) {
     726:	4607      	mov	r7, r0
     728:	bb50      	cbnz	r0, 780 <ecc_test+0x780>
    ret = wc_EccKeyToDer(eccKey, tmpBuf, tmpSz);
     72a:	f240 1201 	movw	r2, #257	; 0x101
     72e:	4631      	mov	r1, r6
     730:	4620      	mov	r0, r4
     732:	f7ff fffe 	bl	0 <wc_EccKeyToDer>
     736:	4605      	mov	r5, r0
    wc_ecc_free(eccKey);
     738:	4620      	mov	r0, r4
     73a:	f7ff fffe 	bl	0 <wc_ecc_free>
    if (ret < 0) {
     73e:	2d00      	cmp	r5, #0
     740:	f2c0 85f7 	blt.w	1332 <ecc_test+0x1332>
    ret = wc_ecc_init(eccKey);
     744:	4620      	mov	r0, r4
     746:	f7ff fffe 	bl	0 <wc_ecc_init>
    if (ret != 0) {
     74a:	4607      	mov	r7, r0
     74c:	b9c0      	cbnz	r0, 780 <ecc_test+0x780>
    idx = 0;
     74e:	9030      	str	r0, [sp, #192]	; 0xc0
    ret = wc_EccPrivateKeyDecode(tmpBuf, &idx, eccKey, tmpSz);
     750:	462b      	mov	r3, r5
     752:	4622      	mov	r2, r4
     754:	a930      	add	r1, sp, #192	; 0xc0
     756:	4630      	mov	r0, r6
     758:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
    if (ret != 0) {
     75c:	4607      	mov	r7, r0
     75e:	b978      	cbnz	r0, 780 <ecc_test+0x780>
    wc_ecc_free(eccKey);
     760:	4620      	mov	r0, r4
     762:	f7ff fffe 	bl	0 <wc_ecc_free>
    ret = wc_ecc_init(eccKey);
     766:	4620      	mov	r0, r4
     768:	f7ff fffe 	bl	0 <wc_ecc_init>
    if (ret != 0) {
     76c:	4607      	mov	r7, r0
     76e:	b938      	cbnz	r0, 780 <ecc_test+0x780>
    idx = 0;
     770:	9030      	str	r0, [sp, #192]	; 0xc0
    ret = wc_EccPublicKeyDecode(tmpBuf, &idx, eccKey, tmpSz);
     772:	462b      	mov	r3, r5
     774:	4622      	mov	r2, r4
     776:	a930      	add	r1, sp, #192	; 0xc0
     778:	4630      	mov	r0, r6
     77a:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
     77e:	4607      	mov	r7, r0
        wc_ecc_free(eccKey);
     780:	4620      	mov	r0, r4
     782:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(eccKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     786:	4620      	mov	r0, r4
     788:	f7ff fffe 	bl	0 <free>
    if (tmpBuf != NULL)
     78c:	b916      	cbnz	r6, 794 <ecc_test+0x794>
     78e:	e004      	b.n	79a <ecc_test+0x79a>
        ERROR_OUT(MEMORY_E, done);
     790:	f06f 077c 	mvn.w	r7, #124	; 0x7c
        XFREE(tmpBuf, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     794:	4630      	mov	r0, r6
     796:	f7ff fffe 	bl	0 <free>
    if (ret < 0) {
     79a:	2f00      	cmp	r7, #0
     79c:	da05      	bge.n	7aa <ecc_test+0x7aa>
        if (ret == ECC_CURVE_OID_E) {
     79e:	f117 0fac 	cmn.w	r7, #172	; 0xac
     7a2:	d002      	beq.n	7aa <ecc_test+0x7aa>
            printf("ecc_test_key_decode %d failed!\n", keySize);
     7a4:	4853      	ldr	r0, [pc, #332]	; (8f4 <ecc_test+0x8f4>)
     7a6:	2120      	movs	r1, #32
     7a8:	e65d      	b.n	466 <ecc_test+0x466>
    byte *der = (byte *)XMALLOC(ECC_BUFSIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     7aa:	f240 1001 	movw	r0, #257	; 0x101
     7ae:	f7ff fffe 	bl	0 <malloc>
     7b2:	4605      	mov	r5, r0
    ecc_key *userA = (ecc_key *)XMALLOC(sizeof *userA, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     7b4:	f44f 70de 	mov.w	r0, #444	; 0x1bc
     7b8:	f7ff fffe 	bl	0 <malloc>
     7bc:	4604      	mov	r4, r0
    if ((der == NULL) || (userA == NULL))
     7be:	2d00      	cmp	r5, #0
     7c0:	f000 85cb 	beq.w	135a <ecc_test+0x135a>
     7c4:	2800      	cmp	r0, #0
     7c6:	f000 85aa 	beq.w	131e <ecc_test+0x131e>
    ret = wc_ecc_init_ex(userA, HEAP_HINT, devId);
     7ca:	f06f 0201 	mvn.w	r2, #1
     7ce:	2100      	movs	r1, #0
     7d0:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
     7d4:	b138      	cbz	r0, 7e6 <ecc_test+0x7e6>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     7d6:	4240      	negs	r0, r0
     7d8:	4b47      	ldr	r3, [pc, #284]	; (8f8 <ecc_test+0x8f8>)
     7da:	4f48      	ldr	r7, [pc, #288]	; (8fc <ecc_test+0x8fc>)
     7dc:	f3c0 000a 	ubfx	r0, r0, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_I(derSz), done);
     7e0:	fb03 7700 	mla	r7, r3, r0, r7
     7e4:	e00c      	b.n	800 <ecc_test+0x800>
    ret = wc_ecc_make_key(rng, keySize, userA);
     7e6:	4622      	mov	r2, r4
     7e8:	2120      	movs	r1, #32
     7ea:	a80c      	add	r0, sp, #48	; 0x30
     7ec:	f7ff fffe 	bl	0 <wc_ecc_make_key>
    if (ret != 0)
     7f0:	b160      	cbz	r0, 80c <ecc_test+0x80c>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     7f2:	4247      	negs	r7, r0
     7f4:	f3c7 030a 	ubfx	r3, r7, #0, #11
     7f8:	4841      	ldr	r0, [pc, #260]	; (900 <ecc_test+0x900>)
     7fa:	4f3f      	ldr	r7, [pc, #252]	; (8f8 <ecc_test+0x8f8>)
     7fc:	fb07 0703 	mla	r7, r7, r3, r0
        XFREE(der, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     800:	4628      	mov	r0, r5
     802:	f7ff fffe 	bl	0 <free>
    if (userA != NULL) {
     806:	2c00      	cmp	r4, #0
     808:	d13b      	bne.n	882 <ecc_test+0x882>
     80a:	e040      	b.n	88e <ecc_test+0x88e>
    ret = wc_ecc_check_key(userA);
     80c:	4620      	mov	r0, r4
     80e:	f7ff fffe 	bl	0 <wc_ecc_check_key>
    if (ret != 0)
     812:	4607      	mov	r7, r0
     814:	b128      	cbz	r0, 822 <ecc_test+0x822>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     816:	4240      	negs	r0, r0
     818:	4b37      	ldr	r3, [pc, #220]	; (8f8 <ecc_test+0x8f8>)
     81a:	4f3a      	ldr	r7, [pc, #232]	; (904 <ecc_test+0x904>)
     81c:	f3c0 000a 	ubfx	r0, r0, #0, #11
     820:	e7de      	b.n	7e0 <ecc_test+0x7e0>
    derSz = wc_EccKeyToDer(userA, der, ECC_BUFSIZE);
     822:	f240 1201 	movw	r2, #257	; 0x101
     826:	4629      	mov	r1, r5
     828:	4620      	mov	r0, r4
     82a:	f7ff fffe 	bl	0 <wc_EccKeyToDer>
    if (derSz < 0) {
     82e:	2800      	cmp	r0, #0
     830:	da04      	bge.n	83c <ecc_test+0x83c>
        ERROR_OUT(WC_TEST_RET_ENC_I(derSz), done);
     832:	4b31      	ldr	r3, [pc, #196]	; (8f8 <ecc_test+0x8f8>)
     834:	4f34      	ldr	r7, [pc, #208]	; (908 <ecc_test+0x908>)
     836:	f3c0 000a 	ubfx	r0, r0, #0, #11
     83a:	e7d1      	b.n	7e0 <ecc_test+0x7e0>
    derSz = wc_EccPublicKeyToDer(userA, der, ECC_BUFSIZE, 1);
     83c:	2301      	movs	r3, #1
     83e:	f240 1201 	movw	r2, #257	; 0x101
     842:	4629      	mov	r1, r5
     844:	4620      	mov	r0, r4
     846:	f7ff fffe 	bl	0 <wc_EccPublicKeyToDer>
    if (derSz < 0) {
     84a:	2800      	cmp	r0, #0
     84c:	da04      	bge.n	858 <ecc_test+0x858>
        ERROR_OUT(WC_TEST_RET_ENC_I(derSz), done);
     84e:	4b2a      	ldr	r3, [pc, #168]	; (8f8 <ecc_test+0x8f8>)
     850:	4f2e      	ldr	r7, [pc, #184]	; (90c <ecc_test+0x90c>)
     852:	f3c0 000a 	ubfx	r0, r0, #0, #11
     856:	e7c3      	b.n	7e0 <ecc_test+0x7e0>
    if (derSz == 0) {
     858:	f000 8564 	beq.w	1324 <ecc_test+0x1324>
    pkcs8Sz = FOURK_BUF;
     85c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    derSz = wc_EccPrivateKeyToPKCS8(userA, der, &pkcs8Sz);
     860:	aa30      	add	r2, sp, #192	; 0xc0
     862:	4629      	mov	r1, r5
     864:	4620      	mov	r0, r4
    pkcs8Sz = FOURK_BUF;
     866:	9330      	str	r3, [sp, #192]	; 0xc0
    derSz = wc_EccPrivateKeyToPKCS8(userA, der, &pkcs8Sz);
     868:	f7ff fffe 	bl	0 <wc_EccPrivateKeyToPKCS8>
    if (derSz < 0) {
     86c:	2800      	cmp	r0, #0
     86e:	da04      	bge.n	87a <ecc_test+0x87a>
        ERROR_OUT(WC_TEST_RET_ENC_I(derSz), done);
     870:	4b21      	ldr	r3, [pc, #132]	; (8f8 <ecc_test+0x8f8>)
     872:	4f27      	ldr	r7, [pc, #156]	; (910 <ecc_test+0x910>)
     874:	f3c0 000a 	ubfx	r0, r0, #0, #11
     878:	e7b2      	b.n	7e0 <ecc_test+0x7e0>
    if (derSz == 0) {
     87a:	d1c1      	bne.n	800 <ecc_test+0x800>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
     87c:	4f25      	ldr	r7, [pc, #148]	; (914 <ecc_test+0x914>)
     87e:	e7bf      	b.n	800 <ecc_test+0x800>
        ERROR_OUT(WC_TEST_RET_ENC_EC(MEMORY_E), done);
     880:	4f25      	ldr	r7, [pc, #148]	; (918 <ecc_test+0x918>)
        wc_ecc_free(userA);
     882:	4620      	mov	r0, r4
     884:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(userA, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     888:	4620      	mov	r0, r4
     88a:	f7ff fffe 	bl	0 <free>
    if (ret < 0) {
     88e:	b12f      	cbz	r7, 89c <ecc_test+0x89c>
        if (ret == ECC_CURVE_OID_E) {
     890:	f117 0fac 	cmn.w	r7, #172	; 0xac
     894:	d002      	beq.n	89c <ecc_test+0x89c>
            printf("ecc_test_key_gen %d failed!\n", keySize);
     896:	4821      	ldr	r0, [pc, #132]	; (91c <ecc_test+0x91c>)
     898:	2120      	movs	r1, #32
     89a:	e5e4      	b.n	466 <ecc_test+0x466>
    byte       der[] = { 0x04, /* = Uncompressed */
     89c:	2741      	movs	r7, #65	; 0x41
     89e:	4920      	ldr	r1, [pc, #128]	; (920 <ecc_test+0x920>)
     8a0:	463a      	mov	r2, r7
     8a2:	a81f      	add	r0, sp, #124	; 0x7c
     8a4:	f7ff fffe 	bl	0 <memcpy>
    byte       altDer[] = { 0x04, /* = Uncompressed */
     8a8:	491e      	ldr	r1, [pc, #120]	; (924 <ecc_test+0x924>)
     8aa:	463a      	mov	r2, r7
     8ac:	a830      	add	r0, sp, #192	; 0xc0
     8ae:	f7ff fffe 	bl	0 <memcpy>
    int curve_idx = wc_ecc_get_curve_idx(ECC_SECP256R1);
     8b2:	2007      	movs	r0, #7
     8b4:	f7ff fffe 	bl	0 <wc_ecc_get_curve_idx>
    if (curve_idx == ECC_CURVE_INVALID)
     8b8:	1c43      	adds	r3, r0, #1
    int curve_idx = wc_ecc_get_curve_idx(ECC_SECP256R1);
     8ba:	4605      	mov	r5, r0
    if (curve_idx == ECC_CURVE_INVALID)
     8bc:	d053      	beq.n	966 <ecc_test+0x966>
    outLen = sizeof(out);
     8be:	970b      	str	r7, [sp, #44]	; 0x2c
    point = wc_ecc_new_point();
     8c0:	f7ff fffe 	bl	0 <wc_ecc_new_point>
    if (point == NULL)
     8c4:	4604      	mov	r4, r0
     8c6:	b928      	cbnz	r0, 8d4 <ecc_test+0x8d4>
        return WC_TEST_RET_ENC_ERRNO;
     8c8:	4f17      	ldr	r7, [pc, #92]	; (928 <ecc_test+0x928>)
    wc_FreeRng(&rng);
     8ca:	a80c      	add	r0, sp, #48	; 0x30
     8cc:	f7ff fffe 	bl	0 <wc_FreeRng>
    return ret;
     8d0:	f7ff bba8 	b.w	24 <ecc_test+0x24>
    point2 = wc_ecc_new_point();
     8d4:	f7ff fffe 	bl	0 <wc_ecc_new_point>
    if (point2 == NULL) {
     8d8:	4606      	mov	r6, r0
     8da:	bb48      	cbnz	r0, 930 <ecc_test+0x930>
        wc_ecc_del_point(point);
     8dc:	4620      	mov	r0, r4
     8de:	f7ff fffe 	bl	0 <wc_ecc_del_point>
        return WC_TEST_RET_ENC_NC;
     8e2:	4f12      	ldr	r7, [pc, #72]	; (92c <ecc_test+0x92c>)
     8e4:	e7f1      	b.n	8ca <ecc_test+0x8ca>
     8e6:	bf00      	nop
     8e8:	ffff9e9a 	.word	0xffff9e9a
     8ec:	ffff9e87 	.word	0xffff9e87
     8f0:	000001c6 	.word	0x000001c6
     8f4:	000001e2 	.word	0x000001e2
     8f8:	fffe7960 	.word	0xfffe7960
     8fc:	dfff99d6 	.word	0xdfff99d6
     900:	dfff99cf 	.word	0xdfff99cf
     904:	dfff99ca 	.word	0xdfff99ca
     908:	9fff99c5 	.word	0x9fff99c5
     90c:	9fff99ba 	.word	0x9fff99ba
     910:	9fff99a0 	.word	0x9fff99a0
     914:	ffff999c 	.word	0xffff999c
     918:	df40ddbb 	.word	0xdf40ddbb
     91c:	00000202 	.word	0x00000202
     920:	00000290 	.word	0x00000290
     924:	0000014c 	.word	0x0000014c
     928:	ffff9758 	.word	0xffff9758
     92c:	ffff9754 	.word	0xffff9754
    wc_ecc_del_point(NULL);
     930:	2000      	movs	r0, #0
     932:	f7ff fffe 	bl	0 <wc_ecc_del_point>
    ret = wc_ecc_import_point_der(NULL, sizeof(der), curve_idx, point);
     936:	4623      	mov	r3, r4
     938:	462a      	mov	r2, r5
     93a:	4639      	mov	r1, r7
     93c:	2000      	movs	r0, #0
     93e:	f7ff fffe 	bl	0 <wc_ecc_import_point_der>
    if (ret != ECC_BAD_ARG_E) {
     942:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     946:	d02d      	beq.n	9a4 <ecc_test+0x9a4>
        ret = WC_TEST_RET_ENC_EC(ret);
     948:	4240      	negs	r0, r0
     94a:	4ba8      	ldr	r3, [pc, #672]	; (bec <ecc_test+0xbec>)
     94c:	4fa8      	ldr	r7, [pc, #672]	; (bf0 <ecc_test+0xbf0>)
     94e:	f3c0 000a 	ubfx	r0, r0, #0, #11
        ret = WC_TEST_RET_ENC_EC(ret);
     952:	fb03 7700 	mla	r7, r3, r0, r7
    wc_ecc_del_point(point2);
     956:	4630      	mov	r0, r6
     958:	f7ff fffe 	bl	0 <wc_ecc_del_point>
    wc_ecc_del_point(point);
     95c:	4620      	mov	r0, r4
     95e:	f7ff fffe 	bl	0 <wc_ecc_del_point>
    if (ret < 0) {
     962:	2f00      	cmp	r7, #0
     964:	dbb1      	blt.n	8ca <ecc_test+0x8ca>
    ecc_key *key = (ecc_key *)XMALLOC(sizeof *key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     966:	f44f 70de 	mov.w	r0, #444	; 0x1bc
     96a:	f7ff fffe 	bl	0 <malloc>
    word32 idx = 0;
     96e:	2500      	movs	r5, #0
     970:	950b      	str	r5, [sp, #44]	; 0x2c
    if (key == NULL)
     972:	4604      	mov	r4, r0
     974:	2800      	cmp	r0, #0
     976:	f000 82c4 	beq.w	f02 <ecc_test+0xf02>
    wc_ecc_init_ex(key, HEAP_HINT, devId);
     97a:	f06f 0201 	mvn.w	r2, #1
     97e:	4629      	mov	r1, r5
     980:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    ret = wc_ecc_set_flags(NULL, 0);
     984:	4629      	mov	r1, r5
     986:	4628      	mov	r0, r5
     988:	f7ff fffe 	bl	0 <wc_ecc_set_flags>
    if (ret != BAD_FUNC_ARG) {
     98c:	f110 0fad 	cmn.w	r0, #173	; 0xad
     990:	f000 8120 	beq.w	bd4 <ecc_test+0xbd4>
        ret = WC_TEST_RET_ENC_EC(ret);
     994:	4240      	negs	r0, r0
     996:	4b95      	ldr	r3, [pc, #596]	; (bec <ecc_test+0xbec>)
     998:	4f96      	ldr	r7, [pc, #600]	; (bf4 <ecc_test+0xbf4>)
     99a:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
     99e:	fb03 7700 	mla	r7, r3, r0, r7
     9a2:	e17b      	b.n	c9c <ecc_test+0xc9c>
    ret = wc_ecc_import_point_der(der, sizeof(der), ECC_CURVE_INVALID, point);
     9a4:	4623      	mov	r3, r4
     9a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
     9aa:	4639      	mov	r1, r7
     9ac:	a81f      	add	r0, sp, #124	; 0x7c
     9ae:	f7ff fffe 	bl	0 <wc_ecc_import_point_der>
    if (ret != ECC_BAD_ARG_E) {
     9b2:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     9b6:	d005      	beq.n	9c4 <ecc_test+0x9c4>
        ret = WC_TEST_RET_ENC_EC(ret);
     9b8:	4240      	negs	r0, r0
     9ba:	4b8c      	ldr	r3, [pc, #560]	; (bec <ecc_test+0xbec>)
     9bc:	4f8e      	ldr	r7, [pc, #568]	; (bf8 <ecc_test+0xbf8>)
     9be:	f3c0 000a 	ubfx	r0, r0, #0, #11
     9c2:	e7c6      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_import_point_der(der, sizeof(der), curve_idx, NULL);
     9c4:	2300      	movs	r3, #0
     9c6:	462a      	mov	r2, r5
     9c8:	4639      	mov	r1, r7
     9ca:	a81f      	add	r0, sp, #124	; 0x7c
     9cc:	f7ff fffe 	bl	0 <wc_ecc_import_point_der>
    if (ret != ECC_BAD_ARG_E) {
     9d0:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     9d4:	d005      	beq.n	9e2 <ecc_test+0x9e2>
        ret = WC_TEST_RET_ENC_EC(ret);
     9d6:	4240      	negs	r0, r0
     9d8:	4b84      	ldr	r3, [pc, #528]	; (bec <ecc_test+0xbec>)
     9da:	4f88      	ldr	r7, [pc, #544]	; (bfc <ecc_test+0xbfc>)
     9dc:	f3c0 000a 	ubfx	r0, r0, #0, #11
     9e0:	e7b7      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_export_point_der(-1, point, out, &outLen);
     9e2:	ab0b      	add	r3, sp, #44	; 0x2c
     9e4:	aa0e      	add	r2, sp, #56	; 0x38
     9e6:	4621      	mov	r1, r4
     9e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     9ec:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
    if (ret != ECC_BAD_ARG_E) {
     9f0:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     9f4:	d005      	beq.n	a02 <ecc_test+0xa02>
        ret = WC_TEST_RET_ENC_EC(ret);
     9f6:	4240      	negs	r0, r0
     9f8:	4b7c      	ldr	r3, [pc, #496]	; (bec <ecc_test+0xbec>)
     9fa:	4f81      	ldr	r7, [pc, #516]	; (c00 <ecc_test+0xc00>)
     9fc:	f3c0 000a 	ubfx	r0, r0, #0, #11
     a00:	e7a7      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_export_point_der(curve_idx, NULL, out, &outLen);
     a02:	ab0b      	add	r3, sp, #44	; 0x2c
     a04:	aa0e      	add	r2, sp, #56	; 0x38
     a06:	2100      	movs	r1, #0
     a08:	4628      	mov	r0, r5
     a0a:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
    if (ret != ECC_BAD_ARG_E) {
     a0e:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     a12:	d005      	beq.n	a20 <ecc_test+0xa20>
        ret = WC_TEST_RET_ENC_EC(ret);
     a14:	4240      	negs	r0, r0
     a16:	4b75      	ldr	r3, [pc, #468]	; (bec <ecc_test+0xbec>)
     a18:	4f7a      	ldr	r7, [pc, #488]	; (c04 <ecc_test+0xc04>)
     a1a:	f3c0 000a 	ubfx	r0, r0, #0, #11
     a1e:	e798      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_export_point_der(curve_idx, point, NULL, &outLen);
     a20:	ab0b      	add	r3, sp, #44	; 0x2c
     a22:	2200      	movs	r2, #0
     a24:	4621      	mov	r1, r4
     a26:	4628      	mov	r0, r5
     a28:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
    if (ret != LENGTH_ONLY_E || outLen != sizeof(out)) {
     a2c:	f110 0fca 	cmn.w	r0, #202	; 0xca
     a30:	d102      	bne.n	a38 <ecc_test+0xa38>
     a32:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     a34:	2b41      	cmp	r3, #65	; 0x41
     a36:	d005      	beq.n	a44 <ecc_test+0xa44>
        ret = WC_TEST_RET_ENC_EC(ret);
     a38:	4240      	negs	r0, r0
     a3a:	4b6c      	ldr	r3, [pc, #432]	; (bec <ecc_test+0xbec>)
     a3c:	4f72      	ldr	r7, [pc, #456]	; (c08 <ecc_test+0xc08>)
     a3e:	f3c0 000a 	ubfx	r0, r0, #0, #11
     a42:	e786      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_export_point_der(curve_idx, point, out, NULL);
     a44:	2300      	movs	r3, #0
     a46:	aa0e      	add	r2, sp, #56	; 0x38
     a48:	4621      	mov	r1, r4
     a4a:	4628      	mov	r0, r5
     a4c:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
    if (ret != ECC_BAD_ARG_E) {
     a50:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     a54:	d005      	beq.n	a62 <ecc_test+0xa62>
        ret = WC_TEST_RET_ENC_EC(ret);
     a56:	4240      	negs	r0, r0
     a58:	4b64      	ldr	r3, [pc, #400]	; (bec <ecc_test+0xbec>)
     a5a:	4f6c      	ldr	r7, [pc, #432]	; (c0c <ecc_test+0xc0c>)
     a5c:	f3c0 000a 	ubfx	r0, r0, #0, #11
     a60:	e777      	b.n	952 <ecc_test+0x952>
    outLen = 0;
     a62:	2700      	movs	r7, #0
    ret = wc_ecc_export_point_der(curve_idx, point, out, &outLen);
     a64:	ab0b      	add	r3, sp, #44	; 0x2c
     a66:	aa0e      	add	r2, sp, #56	; 0x38
     a68:	4621      	mov	r1, r4
     a6a:	4628      	mov	r0, r5
    outLen = 0;
     a6c:	970b      	str	r7, [sp, #44]	; 0x2c
    ret = wc_ecc_export_point_der(curve_idx, point, out, &outLen);
     a6e:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
    if (ret != BUFFER_E) {
     a72:	f110 0f84 	cmn.w	r0, #132	; 0x84
     a76:	d005      	beq.n	a84 <ecc_test+0xa84>
        ret = WC_TEST_RET_ENC_EC(ret);
     a78:	4240      	negs	r0, r0
     a7a:	4b5c      	ldr	r3, [pc, #368]	; (bec <ecc_test+0xbec>)
     a7c:	4f64      	ldr	r7, [pc, #400]	; (c10 <ecc_test+0xc10>)
     a7e:	f3c0 000a 	ubfx	r0, r0, #0, #11
     a82:	e766      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_copy_point(NULL, NULL);
     a84:	4639      	mov	r1, r7
     a86:	4638      	mov	r0, r7
     a88:	f7ff fffe 	bl	0 <wc_ecc_copy_point>
    if (ret != ECC_BAD_ARG_E) {
     a8c:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     a90:	d005      	beq.n	a9e <ecc_test+0xa9e>
        ret = WC_TEST_RET_ENC_EC(ret);
     a92:	4240      	negs	r0, r0
     a94:	4b55      	ldr	r3, [pc, #340]	; (bec <ecc_test+0xbec>)
     a96:	4f5f      	ldr	r7, [pc, #380]	; (c14 <ecc_test+0xc14>)
     a98:	f3c0 000a 	ubfx	r0, r0, #0, #11
     a9c:	e759      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_copy_point(NULL, point2);
     a9e:	4631      	mov	r1, r6
     aa0:	4638      	mov	r0, r7
     aa2:	f7ff fffe 	bl	0 <wc_ecc_copy_point>
    if (ret != ECC_BAD_ARG_E) {
     aa6:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     aaa:	d005      	beq.n	ab8 <ecc_test+0xab8>
        ret = WC_TEST_RET_ENC_EC(ret);
     aac:	4240      	negs	r0, r0
     aae:	4b4f      	ldr	r3, [pc, #316]	; (bec <ecc_test+0xbec>)
     ab0:	4f59      	ldr	r7, [pc, #356]	; (c18 <ecc_test+0xc18>)
     ab2:	f3c0 000a 	ubfx	r0, r0, #0, #11
     ab6:	e74c      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_copy_point(point, NULL);
     ab8:	4639      	mov	r1, r7
     aba:	4620      	mov	r0, r4
     abc:	f7ff fffe 	bl	0 <wc_ecc_copy_point>
    if (ret != ECC_BAD_ARG_E) {
     ac0:	f110 0faa 	cmn.w	r0, #170	; 0xaa
     ac4:	d005      	beq.n	ad2 <ecc_test+0xad2>
        ret = WC_TEST_RET_ENC_EC(ret);
     ac6:	4240      	negs	r0, r0
     ac8:	4b48      	ldr	r3, [pc, #288]	; (bec <ecc_test+0xbec>)
     aca:	4f54      	ldr	r7, [pc, #336]	; (c1c <ecc_test+0xc1c>)
     acc:	f3c0 000a 	ubfx	r0, r0, #0, #11
     ad0:	e73f      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_cmp_point(NULL, NULL);
     ad2:	4639      	mov	r1, r7
     ad4:	4638      	mov	r0, r7
     ad6:	f7ff fffe 	bl	0 <wc_ecc_cmp_point>
    if (ret != BAD_FUNC_ARG) {
     ada:	f110 0fad 	cmn.w	r0, #173	; 0xad
     ade:	d005      	beq.n	aec <ecc_test+0xaec>
        ret = WC_TEST_RET_ENC_EC(ret);
     ae0:	4240      	negs	r0, r0
     ae2:	4b42      	ldr	r3, [pc, #264]	; (bec <ecc_test+0xbec>)
     ae4:	4f4e      	ldr	r7, [pc, #312]	; (c20 <ecc_test+0xc20>)
     ae6:	f3c0 000a 	ubfx	r0, r0, #0, #11
     aea:	e732      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_cmp_point(NULL, point2);
     aec:	4631      	mov	r1, r6
     aee:	4638      	mov	r0, r7
     af0:	f7ff fffe 	bl	0 <wc_ecc_cmp_point>
    if (ret != BAD_FUNC_ARG) {
     af4:	f110 0fad 	cmn.w	r0, #173	; 0xad
     af8:	d005      	beq.n	b06 <ecc_test+0xb06>
        ret = WC_TEST_RET_ENC_EC(ret);
     afa:	4240      	negs	r0, r0
     afc:	4b3b      	ldr	r3, [pc, #236]	; (bec <ecc_test+0xbec>)
     afe:	4f49      	ldr	r7, [pc, #292]	; (c24 <ecc_test+0xc24>)
     b00:	f3c0 000a 	ubfx	r0, r0, #0, #11
     b04:	e725      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_cmp_point(point, NULL);
     b06:	4639      	mov	r1, r7
     b08:	4620      	mov	r0, r4
     b0a:	f7ff fffe 	bl	0 <wc_ecc_cmp_point>
    if (ret != BAD_FUNC_ARG) {
     b0e:	f110 0fad 	cmn.w	r0, #173	; 0xad
     b12:	d005      	beq.n	b20 <ecc_test+0xb20>
        ret = WC_TEST_RET_ENC_EC(ret);
     b14:	4240      	negs	r0, r0
     b16:	4b35      	ldr	r3, [pc, #212]	; (bec <ecc_test+0xbec>)
     b18:	4f43      	ldr	r7, [pc, #268]	; (c28 <ecc_test+0xc28>)
     b1a:	f3c0 000a 	ubfx	r0, r0, #0, #11
     b1e:	e718      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_import_point_der(der, sizeof(der), curve_idx, point);
     b20:	4623      	mov	r3, r4
     b22:	462a      	mov	r2, r5
     b24:	2141      	movs	r1, #65	; 0x41
     b26:	a81f      	add	r0, sp, #124	; 0x7c
     b28:	f7ff fffe 	bl	0 <wc_ecc_import_point_der>
    if (ret != 0) {
     b2c:	b128      	cbz	r0, b3a <ecc_test+0xb3a>
        ret = WC_TEST_RET_ENC_EC(ret);
     b2e:	4240      	negs	r0, r0
     b30:	4b2e      	ldr	r3, [pc, #184]	; (bec <ecc_test+0xbec>)
     b32:	4f3e      	ldr	r7, [pc, #248]	; (c2c <ecc_test+0xc2c>)
     b34:	f3c0 000a 	ubfx	r0, r0, #0, #11
     b38:	e70b      	b.n	952 <ecc_test+0x952>
    outLen = sizeof(out);
     b3a:	2341      	movs	r3, #65	; 0x41
     b3c:	930b      	str	r3, [sp, #44]	; 0x2c
    ret = wc_ecc_export_point_der(curve_idx, point, out, &outLen);
     b3e:	aa0e      	add	r2, sp, #56	; 0x38
     b40:	ab0b      	add	r3, sp, #44	; 0x2c
     b42:	4621      	mov	r1, r4
     b44:	4628      	mov	r0, r5
     b46:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
    if (ret != 0) {
     b4a:	b128      	cbz	r0, b58 <ecc_test+0xb58>
        ret = WC_TEST_RET_ENC_EC(ret);
     b4c:	4240      	negs	r0, r0
     b4e:	4b27      	ldr	r3, [pc, #156]	; (bec <ecc_test+0xbec>)
     b50:	4f37      	ldr	r7, [pc, #220]	; (c30 <ecc_test+0xc30>)
     b52:	f3c0 000a 	ubfx	r0, r0, #0, #11
     b56:	e6fc      	b.n	952 <ecc_test+0x952>
    if (outLen != sizeof(der)) {
     b58:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
     b5a:	2f41      	cmp	r7, #65	; 0x41
     b5c:	d136      	bne.n	bcc <ecc_test+0xbcc>
    if (XMEMCMP(out, der, outLen) != 0) {
     b5e:	463a      	mov	r2, r7
     b60:	a91f      	add	r1, sp, #124	; 0x7c
     b62:	a80e      	add	r0, sp, #56	; 0x38
     b64:	f7ff fffe 	bl	0 <memcmp>
     b68:	bb90      	cbnz	r0, bd0 <ecc_test+0xbd0>
    ret = wc_ecc_copy_point(point2, point);
     b6a:	4621      	mov	r1, r4
     b6c:	4630      	mov	r0, r6
     b6e:	f7ff fffe 	bl	0 <wc_ecc_copy_point>
    if (ret != MP_OKAY) {
     b72:	b128      	cbz	r0, b80 <ecc_test+0xb80>
        ret = WC_TEST_RET_ENC_EC(ret);
     b74:	4240      	negs	r0, r0
     b76:	4b1d      	ldr	r3, [pc, #116]	; (bec <ecc_test+0xbec>)
     b78:	4f2e      	ldr	r7, [pc, #184]	; (c34 <ecc_test+0xc34>)
     b7a:	f3c0 000a 	ubfx	r0, r0, #0, #11
     b7e:	e6e8      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_cmp_point(point2, point);
     b80:	4621      	mov	r1, r4
     b82:	4630      	mov	r0, r6
     b84:	f7ff fffe 	bl	0 <wc_ecc_cmp_point>
    if (ret != MP_EQ) {
     b88:	b128      	cbz	r0, b96 <ecc_test+0xb96>
        ret = WC_TEST_RET_ENC_EC(ret);
     b8a:	4240      	negs	r0, r0
     b8c:	4b17      	ldr	r3, [pc, #92]	; (bec <ecc_test+0xbec>)
     b8e:	4f2a      	ldr	r7, [pc, #168]	; (c38 <ecc_test+0xc38>)
     b90:	f3c0 000a 	ubfx	r0, r0, #0, #11
     b94:	e6dd      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_import_point_der(altDer, sizeof(altDer), curve_idx, point2);
     b96:	4633      	mov	r3, r6
     b98:	462a      	mov	r2, r5
     b9a:	4639      	mov	r1, r7
     b9c:	a830      	add	r0, sp, #192	; 0xc0
     b9e:	f7ff fffe 	bl	0 <wc_ecc_import_point_der>
    if (ret != 0) {
     ba2:	b128      	cbz	r0, bb0 <ecc_test+0xbb0>
        ret = WC_TEST_RET_ENC_EC(ret);
     ba4:	4240      	negs	r0, r0
     ba6:	4b11      	ldr	r3, [pc, #68]	; (bec <ecc_test+0xbec>)
     ba8:	4f24      	ldr	r7, [pc, #144]	; (c3c <ecc_test+0xc3c>)
     baa:	f3c0 000a 	ubfx	r0, r0, #0, #11
     bae:	e6d0      	b.n	952 <ecc_test+0x952>
    ret = wc_ecc_cmp_point(point2, point);
     bb0:	4621      	mov	r1, r4
     bb2:	4630      	mov	r0, r6
     bb4:	f7ff fffe 	bl	0 <wc_ecc_cmp_point>
    if (ret != MP_GT) {
     bb8:	2801      	cmp	r0, #1
    ret = wc_ecc_cmp_point(point2, point);
     bba:	4607      	mov	r7, r0
    if (ret != MP_GT) {
     bbc:	f43f aecb 	beq.w	956 <ecc_test+0x956>
        ret = WC_TEST_RET_ENC_EC(ret);
     bc0:	4240      	negs	r0, r0
     bc2:	4b0a      	ldr	r3, [pc, #40]	; (bec <ecc_test+0xbec>)
     bc4:	4f1e      	ldr	r7, [pc, #120]	; (c40 <ecc_test+0xc40>)
     bc6:	f3c0 000a 	ubfx	r0, r0, #0, #11
     bca:	e6c2      	b.n	952 <ecc_test+0x952>
        ret = WC_TEST_RET_ENC_NC;
     bcc:	4f1d      	ldr	r7, [pc, #116]	; (c44 <ecc_test+0xc44>)
     bce:	e6c2      	b.n	956 <ecc_test+0x956>
        ret = WC_TEST_RET_ENC_NC;
     bd0:	4f1d      	ldr	r7, [pc, #116]	; (c48 <ecc_test+0xc48>)
     bd2:	e6c0      	b.n	956 <ecc_test+0x956>
    ret = wc_ecc_set_flags(key, 0);
     bd4:	4629      	mov	r1, r5
     bd6:	4620      	mov	r0, r4
     bd8:	f7ff fffe 	bl	0 <wc_ecc_set_flags>
    if (ret != 0) {
     bdc:	b3c0      	cbz	r0, c50 <ecc_test+0xc50>
        ret = WC_TEST_RET_ENC_EC(ret);
     bde:	4240      	negs	r0, r0
     be0:	4b02      	ldr	r3, [pc, #8]	; (bec <ecc_test+0xbec>)
     be2:	4f1a      	ldr	r7, [pc, #104]	; (c4c <ecc_test+0xc4c>)
     be4:	f3c0 000a 	ubfx	r0, r0, #0, #11
     be8:	e6d9      	b.n	99e <ecc_test+0x99e>
     bea:	bf00      	nop
     bec:	fffe7960 	.word	0xfffe7960
     bf0:	dfff973e 	.word	0xdfff973e
     bf4:	dfff9558 	.word	0xdfff9558
     bf8:	dfff9739 	.word	0xdfff9739
     bfc:	dfff9734 	.word	0xdfff9734
     c00:	dfff972f 	.word	0xdfff972f
     c04:	dfff972a 	.word	0xdfff972a
     c08:	dfff9725 	.word	0xdfff9725
     c0c:	dfff9720 	.word	0xdfff9720
     c10:	dfff971a 	.word	0xdfff971a
     c14:	dfff9715 	.word	0xdfff9715
     c18:	dfff9710 	.word	0xdfff9710
     c1c:	dfff970b 	.word	0xdfff970b
     c20:	dfff9706 	.word	0xdfff9706
     c24:	dfff9701 	.word	0xdfff9701
     c28:	dfff96fc 	.word	0xdfff96fc
     c2c:	dfff96f5 	.word	0xdfff96f5
     c30:	dfff96ee 	.word	0xdfff96ee
     c34:	dfff96e0 	.word	0xdfff96e0
     c38:	dfff96db 	.word	0xdfff96db
     c3c:	dfff96d5 	.word	0xdfff96d5
     c40:	dfff96d0 	.word	0xdfff96d0
     c44:	ffff96ea 	.word	0xffff96ea
     c48:	ffff96e6 	.word	0xffff96e6
     c4c:	dfff9553 	.word	0xdfff9553
    ret = wc_ecc_make_key(rng, ECC_KEYGEN_SIZE, key);
     c50:	4622      	mov	r2, r4
     c52:	2120      	movs	r1, #32
     c54:	a80c      	add	r0, sp, #48	; 0x30
     c56:	f7ff fffe 	bl	0 <wc_ecc_make_key>
    if (ret != 0) {
     c5a:	4607      	mov	r7, r0
     c5c:	b9f0      	cbnz	r0, c9c <ecc_test+0xc9c>
    byte    in[] = TEST_STRING;
     c5e:	4baa      	ldr	r3, [pc, #680]	; (f08 <ecc_test+0xf08>)
     c60:	aa1f      	add	r2, sp, #124	; 0x7c
     c62:	f103 0618 	add.w	r6, r3, #24
     c66:	6818      	ldr	r0, [r3, #0]
     c68:	6859      	ldr	r1, [r3, #4]
     c6a:	4615      	mov	r5, r2
     c6c:	c503      	stmia	r5!, {r0, r1}
     c6e:	3308      	adds	r3, #8
     c70:	42b3      	cmp	r3, r6
     c72:	462a      	mov	r2, r5
     c74:	d1f7      	bne.n	c66 <ecc_test+0xc66>
     c76:	881b      	ldrh	r3, [r3, #0]
     c78:	802b      	strh	r3, [r5, #0]
    word32 inLen = (word32)XSTRLEN((char*)in);
     c7a:	a81f      	add	r0, sp, #124	; 0x7c
     c7c:	f7ff fffe 	bl	0 <strlen>
     c80:	4606      	mov	r6, r0
    size = wc_ecc_sig_size(key);
     c82:	4620      	mov	r0, r4
     c84:	f7ff fffe 	bl	0 <wc_ecc_sig_size>
    ret = wc_SignatureGetSize(WC_SIGNATURE_TYPE_ECC, key, sizeof(*key));
     c88:	f44f 72de 	mov.w	r2, #444	; 0x1bc
    size = wc_ecc_sig_size(key);
     c8c:	4605      	mov	r5, r0
    ret = wc_SignatureGetSize(WC_SIGNATURE_TYPE_ECC, key, sizeof(*key));
     c8e:	4621      	mov	r1, r4
     c90:	2001      	movs	r0, #1
     c92:	f7ff fffe 	bl	0 <wc_SignatureGetSize>
    if (ret != size)
     c96:	4285      	cmp	r5, r0
     c98:	d00d      	beq.n	cb6 <ecc_test+0xcb6>
        return WC_TEST_RET_ENC_NC;
     c9a:	4f9c      	ldr	r7, [pc, #624]	; (f0c <ecc_test+0xf0c>)
    wc_ecc_free(key);
     c9c:	4620      	mov	r0, r4
     c9e:	f7ff fffe 	bl	0 <wc_ecc_free>
    if (key != NULL) {
     ca2:	b114      	cbz	r4, caa <ecc_test+0xcaa>
        XFREE(key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     ca4:	4620      	mov	r0, r4
     ca6:	f7ff fffe 	bl	0 <free>
    if (ret < 0) {
     caa:	2f00      	cmp	r7, #0
     cac:	f280 814e 	bge.w	f4c <ecc_test+0xf4c>
        printf("Default\n");
     cb0:	4897      	ldr	r0, [pc, #604]	; (f10 <ecc_test+0xf10>)
     cb2:	f7ff bbe0 	b.w	476 <ecc_test+0x476>
    ret = wc_SignatureGenerate(WC_HASH_TYPE_SHA256, WC_SIGNATURE_TYPE_ECC, in,
     cb6:	ab0c      	add	r3, sp, #48	; 0x30
     cb8:	9304      	str	r3, [sp, #16]
     cba:	ab0e      	add	r3, sp, #56	; 0x38
    sigSz = (word32)ret;
     cbc:	950e      	str	r5, [sp, #56]	; 0x38
    ret = wc_SignatureGenerate(WC_HASH_TYPE_SHA256, WC_SIGNATURE_TYPE_ECC, in,
     cbe:	9301      	str	r3, [sp, #4]
     cc0:	f44f 75de 	mov.w	r5, #444	; 0x1bc
     cc4:	ab30      	add	r3, sp, #192	; 0xc0
     cc6:	9300      	str	r3, [sp, #0]
     cc8:	e9cd 4502 	strd	r4, r5, [sp, #8]
     ccc:	4633      	mov	r3, r6
     cce:	aa1f      	add	r2, sp, #124	; 0x7c
     cd0:	2101      	movs	r1, #1
     cd2:	2006      	movs	r0, #6
     cd4:	f7ff fffe 	bl	0 <wc_SignatureGenerate>
    if (ret != 0)
     cd8:	b128      	cbz	r0, ce6 <ecc_test+0xce6>
        return WC_TEST_RET_ENC_EC(ret);
     cda:	4240      	negs	r0, r0
     cdc:	4b8d      	ldr	r3, [pc, #564]	; (f14 <ecc_test+0xf14>)
     cde:	4f8e      	ldr	r7, [pc, #568]	; (f18 <ecc_test+0xf18>)
     ce0:	f3c0 000a 	ubfx	r0, r0, #0, #11
     ce4:	e65b      	b.n	99e <ecc_test+0x99e>
    ret = wc_SignatureVerify(WC_HASH_TYPE_SHA256, WC_SIGNATURE_TYPE_ECC, in,
     ce6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     ce8:	9301      	str	r3, [sp, #4]
     cea:	ab30      	add	r3, sp, #192	; 0xc0
     cec:	9300      	str	r3, [sp, #0]
     cee:	e9cd 4502 	strd	r4, r5, [sp, #8]
     cf2:	4633      	mov	r3, r6
     cf4:	aa1f      	add	r2, sp, #124	; 0x7c
     cf6:	2101      	movs	r1, #1
     cf8:	2006      	movs	r0, #6
     cfa:	f7ff fffe 	bl	0 <wc_SignatureVerify>
    if (ret != 0)
     cfe:	b128      	cbz	r0, d0c <ecc_test+0xd0c>
        return WC_TEST_RET_ENC_EC(ret);
     d00:	4240      	negs	r0, r0
     d02:	4b84      	ldr	r3, [pc, #528]	; (f14 <ecc_test+0xf14>)
     d04:	4f85      	ldr	r7, [pc, #532]	; (f1c <ecc_test+0xf1c>)
     d06:	f3c0 000a 	ubfx	r0, r0, #0, #11
     d0a:	e648      	b.n	99e <ecc_test+0x99e>
    sigSz = (word32)sizeof(out);
     d0c:	2349      	movs	r3, #73	; 0x49
     d0e:	930e      	str	r3, [sp, #56]	; 0x38
    ret = wc_SignatureGenerateHash(WC_HASH_TYPE_SHA256, WC_SIGNATURE_TYPE_ECC,
     d10:	ab0c      	add	r3, sp, #48	; 0x30
     d12:	e9cd 5303 	strd	r5, r3, [sp, #12]
     d16:	ab0e      	add	r3, sp, #56	; 0x38
     d18:	9301      	str	r3, [sp, #4]
     d1a:	ab30      	add	r3, sp, #192	; 0xc0
     d1c:	9300      	str	r3, [sp, #0]
     d1e:	4a80      	ldr	r2, [pc, #512]	; (f20 <ecc_test+0xf20>)
     d20:	9402      	str	r4, [sp, #8]
     d22:	2320      	movs	r3, #32
     d24:	2101      	movs	r1, #1
     d26:	2006      	movs	r0, #6
     d28:	f7ff fffe 	bl	0 <wc_SignatureGenerateHash>
    if (ret != 0)
     d2c:	b128      	cbz	r0, d3a <ecc_test+0xd3a>
        return WC_TEST_RET_ENC_EC(ret);
     d2e:	4240      	negs	r0, r0
     d30:	4b78      	ldr	r3, [pc, #480]	; (f14 <ecc_test+0xf14>)
     d32:	4f7c      	ldr	r7, [pc, #496]	; (f24 <ecc_test+0xf24>)
     d34:	f3c0 000a 	ubfx	r0, r0, #0, #11
     d38:	e631      	b.n	99e <ecc_test+0x99e>
    ret = wc_SignatureVerifyHash(WC_HASH_TYPE_SHA256, WC_SIGNATURE_TYPE_ECC,
     d3a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     d3c:	9301      	str	r3, [sp, #4]
     d3e:	ab30      	add	r3, sp, #192	; 0xc0
     d40:	e9cd 4502 	strd	r4, r5, [sp, #8]
     d44:	9300      	str	r3, [sp, #0]
     d46:	4a76      	ldr	r2, [pc, #472]	; (f20 <ecc_test+0xf20>)
     d48:	2320      	movs	r3, #32
     d4a:	2101      	movs	r1, #1
     d4c:	2006      	movs	r0, #6
     d4e:	f7ff fffe 	bl	0 <wc_SignatureVerifyHash>
    if (ret != 0)
     d52:	4605      	mov	r5, r0
     d54:	b9d0      	cbnz	r0, d8c <ecc_test+0xd8c>
    word32 outLen = sizeof(out);
     d56:	2380      	movs	r3, #128	; 0x80
    ret = wc_ecc_shared_secret_ssh(NULL, &key->pubkey, out, &outLen);
     d58:	f104 0618 	add.w	r6, r4, #24
    word32 outLen = sizeof(out);
     d5c:	931f      	str	r3, [sp, #124]	; 0x7c
    ret = wc_ecc_shared_secret_ssh(NULL, &key->pubkey, out, &outLen);
     d5e:	aa30      	add	r2, sp, #192	; 0xc0
     d60:	ab1f      	add	r3, sp, #124	; 0x7c
     d62:	4631      	mov	r1, r6
     d64:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_ex>
    if (ret != BAD_FUNC_ARG)
     d68:	f110 0fad 	cmn.w	r0, #173	; 0xad
     d6c:	d116      	bne.n	d9c <ecc_test+0xd9c>
    ret = wc_ecc_shared_secret_ssh(key, NULL, out, &outLen);
     d6e:	ab1f      	add	r3, sp, #124	; 0x7c
     d70:	aa30      	add	r2, sp, #192	; 0xc0
     d72:	4629      	mov	r1, r5
     d74:	4620      	mov	r0, r4
     d76:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_ex>
    if (ret != BAD_FUNC_ARG)
     d7a:	f110 0fad 	cmn.w	r0, #173	; 0xad
     d7e:	d013      	beq.n	da8 <ecc_test+0xda8>
        return WC_TEST_RET_ENC_EC(ret);
     d80:	4240      	negs	r0, r0
     d82:	4b64      	ldr	r3, [pc, #400]	; (f14 <ecc_test+0xf14>)
     d84:	4f68      	ldr	r7, [pc, #416]	; (f28 <ecc_test+0xf28>)
     d86:	f3c0 000a 	ubfx	r0, r0, #0, #11
     d8a:	e608      	b.n	99e <ecc_test+0x99e>
        return WC_TEST_RET_ENC_EC(ret);
     d8c:	4245      	negs	r5, r0
     d8e:	4f61      	ldr	r7, [pc, #388]	; (f14 <ecc_test+0xf14>)
     d90:	4866      	ldr	r0, [pc, #408]	; (f2c <ecc_test+0xf2c>)
     d92:	f3c5 050a 	ubfx	r5, r5, #0, #11
     d96:	fb07 0705 	mla	r7, r7, r5, r0
     d9a:	e77f      	b.n	c9c <ecc_test+0xc9c>
        return WC_TEST_RET_ENC_EC(ret);
     d9c:	4240      	negs	r0, r0
     d9e:	4b5d      	ldr	r3, [pc, #372]	; (f14 <ecc_test+0xf14>)
     da0:	4f63      	ldr	r7, [pc, #396]	; (f30 <ecc_test+0xf30>)
     da2:	f3c0 000a 	ubfx	r0, r0, #0, #11
     da6:	e5fa      	b.n	99e <ecc_test+0x99e>
    ret = wc_ecc_shared_secret_ssh(key, &key->pubkey, NULL, &outLen);
     da8:	ab1f      	add	r3, sp, #124	; 0x7c
     daa:	462a      	mov	r2, r5
     dac:	4631      	mov	r1, r6
     dae:	4620      	mov	r0, r4
     db0:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_ex>
    if (ret != BAD_FUNC_ARG)
     db4:	f110 0fad 	cmn.w	r0, #173	; 0xad
     db8:	d005      	beq.n	dc6 <ecc_test+0xdc6>
        return WC_TEST_RET_ENC_EC(ret);
     dba:	4240      	negs	r0, r0
     dbc:	4b55      	ldr	r3, [pc, #340]	; (f14 <ecc_test+0xf14>)
     dbe:	4f5d      	ldr	r7, [pc, #372]	; (f34 <ecc_test+0xf34>)
     dc0:	f3c0 000a 	ubfx	r0, r0, #0, #11
     dc4:	e5eb      	b.n	99e <ecc_test+0x99e>
    ret = wc_ecc_shared_secret_ssh(key, &key->pubkey, out, NULL);
     dc6:	462b      	mov	r3, r5
     dc8:	aa30      	add	r2, sp, #192	; 0xc0
     dca:	4631      	mov	r1, r6
     dcc:	4620      	mov	r0, r4
     dce:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_ex>
    if (ret != BAD_FUNC_ARG)
     dd2:	f110 0fad 	cmn.w	r0, #173	; 0xad
     dd6:	d005      	beq.n	de4 <ecc_test+0xde4>
        return WC_TEST_RET_ENC_EC(ret);
     dd8:	4240      	negs	r0, r0
     dda:	4b4e      	ldr	r3, [pc, #312]	; (f14 <ecc_test+0xf14>)
     ddc:	4f56      	ldr	r7, [pc, #344]	; (f38 <ecc_test+0xf38>)
     dde:	f3c0 000a 	ubfx	r0, r0, #0, #11
     de2:	e5dc      	b.n	99e <ecc_test+0x99e>
    ret = wc_ecc_set_rng(key, rng);
     de4:	a90c      	add	r1, sp, #48	; 0x30
     de6:	4620      	mov	r0, r4
     de8:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
    if (ret != 0)
     dec:	b128      	cbz	r0, dfa <ecc_test+0xdfa>
        return WC_TEST_RET_ENC_EC(ret);
     dee:	4240      	negs	r0, r0
     df0:	4b48      	ldr	r3, [pc, #288]	; (f14 <ecc_test+0xf14>)
     df2:	4f52      	ldr	r7, [pc, #328]	; (f3c <ecc_test+0xf3c>)
     df4:	f3c0 000a 	ubfx	r0, r0, #0, #11
     df8:	e5d1      	b.n	99e <ecc_test+0x99e>
            ret = wc_ecc_shared_secret_ssh(key, &key->pubkey, out, &outLen);
     dfa:	ab1f      	add	r3, sp, #124	; 0x7c
     dfc:	aa30      	add	r2, sp, #192	; 0xc0
     dfe:	4631      	mov	r1, r6
     e00:	4620      	mov	r0, r4
     e02:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_ex>
    } while (ret == WC_PENDING_E);
     e06:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
            ret = wc_ecc_shared_secret_ssh(key, &key->pubkey, out, &outLen);
     e0a:	4680      	mov	r8, r0
    } while (ret == WC_PENDING_E);
     e0c:	d100      	bne.n	e10 <ecc_test+0xe10>
     e0e:	e7fe      	b.n	e0e <ecc_test+0xe0e>
    if (ret != 0)
     e10:	2800      	cmp	r0, #0
     e12:	d164      	bne.n	ede <ecc_test+0xede>
    wc_ecc_free(key);
     e14:	4620      	mov	r0, r4
     e16:	f7ff fffe 	bl	0 <wc_ecc_free>
    ret = wc_EccPrivateKeyDecode(ecc_key_der_256, &idx, key,
     e1a:	4849      	ldr	r0, [pc, #292]	; (f40 <ecc_test+0xf40>)
     e1c:	2379      	movs	r3, #121	; 0x79
     e1e:	4622      	mov	r2, r4
     e20:	a90b      	add	r1, sp, #44	; 0x2c
     e22:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
    if (ret != 0) {
     e26:	4607      	mov	r7, r0
     e28:	2800      	cmp	r0, #0
     e2a:	f47f af37 	bne.w	c9c <ecc_test+0xc9c>
    ret = ecc_exp_imp_test(key);
     e2e:	4620      	mov	r0, r4
     e30:	f7ff fffe 	bl	0 <ecc_test>
    if (ret < 0)
     e34:	1e07      	subs	r7, r0, #0
     e36:	f6ff af31 	blt.w	c9c <ecc_test+0xc9c>
    ecc_key    *key2 = (ecc_key *)XMALLOC(sizeof *key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     e3a:	f44f 70de 	mov.w	r0, #444	; 0x1bc
     e3e:	f7ff fffe 	bl	0 <malloc>
     e42:	4606      	mov	r6, r0
    ecc_key    *key3 = (ecc_key *)XMALLOC(sizeof *key3, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     e44:	f44f 70de 	mov.w	r0, #444	; 0x1bc
     e48:	f7ff fffe 	bl	0 <malloc>
     e4c:	4605      	mov	r5, r0
    if ((key2 == NULL) || (key3 == NULL))
     e4e:	2e00      	cmp	r6, #0
     e50:	d04b      	beq.n	eea <ecc_test+0xeea>
     e52:	2800      	cmp	r0, #0
     e54:	f000 8260 	beq.w	1318 <ecc_test+0x1318>
    wc_ecc_init_ex(key2, HEAP_HINT, devId);
     e58:	4641      	mov	r1, r8
     e5a:	f06f 0201 	mvn.w	r2, #1
     e5e:	4630      	mov	r0, r6
     e60:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    wc_ecc_init_ex(key3, HEAP_HINT, devId);
     e64:	4641      	mov	r1, r8
     e66:	f06f 0201 	mvn.w	r2, #1
     e6a:	4628      	mov	r0, r5
     e6c:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    ret = wc_ecc_import_raw_ex(key2, key1->dp->Gx, key1->dp->Gy, key1->dp->Af,
     e70:	f04f 0807 	mov.w	r8, #7
     e74:	6921      	ldr	r1, [r4, #16]
     e76:	f8cd 8000 	str.w	r8, [sp]
     e7a:	690b      	ldr	r3, [r1, #16]
     e7c:	4630      	mov	r0, r6
     e7e:	e9d1 1207 	ldrd	r1, r2, [r1, #28]
     e82:	f7ff fffe 	bl	0 <wc_ecc_import_raw_ex>
    if (ret != 0)
     e86:	4607      	mov	r7, r0
     e88:	bb10      	cbnz	r0, ed0 <ecc_test+0xed0>
    ret = wc_ecc_import_raw_ex(key3, key1->dp->Gx, key1->dp->Gy,
     e8a:	6921      	ldr	r1, [r4, #16]
     e8c:	f8cd 8000 	str.w	r8, [sp]
     e90:	68cb      	ldr	r3, [r1, #12]
     e92:	4628      	mov	r0, r5
     e94:	e9d1 1207 	ldrd	r1, r2, [r1, #28]
     e98:	f7ff fffe 	bl	0 <wc_ecc_import_raw_ex>
    if (ret != 0)
     e9c:	4607      	mov	r7, r0
     e9e:	b9b8      	cbnz	r0, ed0 <ecc_test+0xed0>
    ret = wc_ecc_mulmod(wc_ecc_key_get_priv(key1), &key2->pubkey, &key3->pubkey,
     ea0:	2301      	movs	r3, #1
     ea2:	9301      	str	r3, [sp, #4]
                        wc_ecc_key_get_priv(key2), wc_ecc_key_get_priv(key3),
     ea4:	f505 73a8 	add.w	r3, r5, #336	; 0x150
    ret = wc_ecc_mulmod(wc_ecc_key_get_priv(key1), &key2->pubkey, &key3->pubkey,
     ea8:	9300      	str	r3, [sp, #0]
     eaa:	f105 0218 	add.w	r2, r5, #24
     eae:	f506 73a8 	add.w	r3, r6, #336	; 0x150
     eb2:	f106 0118 	add.w	r1, r6, #24
     eb6:	f504 70a8 	add.w	r0, r4, #336	; 0x150
     eba:	f7ff fffe 	bl	0 <wc_ecc_mulmod>
    if (ret != 0) {
     ebe:	4607      	mov	r7, r0
     ec0:	b130      	cbz	r0, ed0 <ecc_test+0xed0>
        ret = WC_TEST_RET_ENC_EC(ret);
     ec2:	4240      	negs	r0, r0
     ec4:	f3c0 070a 	ubfx	r7, r0, #0, #11
     ec8:	4b12      	ldr	r3, [pc, #72]	; (f14 <ecc_test+0xf14>)
     eca:	481e      	ldr	r0, [pc, #120]	; (f44 <ecc_test+0xf44>)
     ecc:	fb03 0707 	mla	r7, r3, r7, r0
        wc_ecc_free(key2);
     ed0:	4630      	mov	r0, r6
     ed2:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(key2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     ed6:	4630      	mov	r0, r6
     ed8:	f7ff fffe 	bl	0 <free>
     edc:	e007      	b.n	eee <ecc_test+0xeee>
        return WC_TEST_RET_ENC_EC(ret);
     ede:	4240      	negs	r0, r0
     ee0:	4b0c      	ldr	r3, [pc, #48]	; (f14 <ecc_test+0xf14>)
     ee2:	4f19      	ldr	r7, [pc, #100]	; (f48 <ecc_test+0xf48>)
     ee4:	f3c0 000a 	ubfx	r0, r0, #0, #11
     ee8:	e559      	b.n	99e <ecc_test+0x99e>
        ERROR_OUT(MEMORY_E, done);
     eea:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    if (key3 != NULL) {
     eee:	2d00      	cmp	r5, #0
     ef0:	f43f aed4 	beq.w	c9c <ecc_test+0xc9c>
        wc_ecc_free(key3);
     ef4:	4628      	mov	r0, r5
     ef6:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(key3, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     efa:	4628      	mov	r0, r5
     efc:	f7ff fffe 	bl	0 <free>
     f00:	e6cc      	b.n	c9c <ecc_test+0xc9c>
        ERROR_OUT(MEMORY_E, done);
     f02:	f06f 077c 	mvn.w	r7, #124	; 0x7c
     f06:	e6c9      	b.n	c9c <ecc_test+0xc9c>
     f08:	000002d2 	.word	0x000002d2
     f0c:	ffff9685 	.word	0xffff9685
     f10:	00000234 	.word	0x00000234
     f14:	fffe7960 	.word	0xfffe7960
     f18:	dfff967f 	.word	0xdfff967f
     f1c:	dfff9679 	.word	0xdfff9679
     f20:	00000000 	.word	0x00000000
     f24:	dfff9672 	.word	0xdfff9672
     f28:	dfff9592 	.word	0xdfff9592
     f2c:	dfff966c 	.word	0xdfff966c
     f30:	dfff9595 	.word	0xdfff9595
     f34:	dfff958f 	.word	0xdfff958f
     f38:	dfff958c 	.word	0xdfff958c
     f3c:	dfff9585 	.word	0xdfff9585
     f40:	00000000 	.word	0x00000000
     f44:	dfff95b8 	.word	0xdfff95b8
     f48:	dfff9576 	.word	0xdfff9576
    ecc_key *key = (ecc_key *)XMALLOC(sizeof *key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     f4c:	f44f 70de 	mov.w	r0, #444	; 0x1bc
     f50:	f7ff fffe 	bl	0 <malloc>
     f54:	4605      	mov	r5, r0
    ecc_key *pub = (ecc_key *)XMALLOC(sizeof *pub, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     f56:	f44f 70de 	mov.w	r0, #444	; 0x1bc
     f5a:	f7ff fffe 	bl	0 <malloc>
     f5e:	4681      	mov	r9, r0
    byte *exportBuf = (byte *)XMALLOC(ECC_BUFSIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     f60:	f240 1001 	movw	r0, #257	; 0x101
     f64:	f7ff fffe 	bl	0 <malloc>
     f68:	4606      	mov	r6, r0
    byte *tmp = (byte *)XMALLOC(ECC_BUFSIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     f6a:	f240 1001 	movw	r0, #257	; 0x101
     f6e:	f7ff fffe 	bl	0 <malloc>
    int verify = 0;
     f72:	f04f 0a00 	mov.w	sl, #0
    byte *tmp = (byte *)XMALLOC(ECC_BUFSIZE, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
     f76:	4680      	mov	r8, r0
    int verify = 0;
     f78:	f8cd a0c0 	str.w	sl, [sp, #192]	; 0xc0
    if ((key == NULL) ||
     f7c:	2d00      	cmp	r5, #0
     f7e:	f000 8169 	beq.w	1254 <ecc_test+0x1254>
     f82:	f1b9 0f00 	cmp.w	r9, #0
     f86:	f000 8169 	beq.w	125c <ecc_test+0x125c>
        (pub == NULL) ||
     f8a:	2e00      	cmp	r6, #0
     f8c:	f000 8168 	beq.w	1260 <ecc_test+0x1260>
        (exportBuf == NULL) ||
     f90:	2800      	cmp	r0, #0
     f92:	f000 8167 	beq.w	1264 <ecc_test+0x1264>
    wc_ecc_init_ex(key, HEAP_HINT, devId);
     f96:	f06f 0201 	mvn.w	r2, #1
     f9a:	4651      	mov	r1, sl
     f9c:	4628      	mov	r0, r5
     f9e:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    XMEMCPY(tmp, ecc_key_der_256, (size_t)sizeof_ecc_key_der_256);
     fa2:	49b8      	ldr	r1, [pc, #736]	; (1284 <ecc_test+0x1284>)
     fa4:	2279      	movs	r2, #121	; 0x79
     fa6:	4640      	mov	r0, r8
     fa8:	f7ff fffe 	bl	0 <memcpy>
    tmpSz = (size_t)sizeof_ecc_key_der_256;
     fac:	2179      	movs	r1, #121	; 0x79
    ret = wc_ecc_import_private_key(tmp, tmpSz, NULL, 0, NULL);
     fae:	f8cd a000 	str.w	sl, [sp]
     fb2:	4653      	mov	r3, sl
     fb4:	4652      	mov	r2, sl
     fb6:	4640      	mov	r0, r8
    tmpSz = (size_t)sizeof_ecc_key_der_256;
     fb8:	911f      	str	r1, [sp, #124]	; 0x7c
    ret = wc_ecc_import_private_key(tmp, tmpSz, NULL, 0, NULL);
     fba:	f7ff fffe 	bl	0 <wc_ecc_import_private_key>
    if (ret == 0) {
     fbe:	2800      	cmp	r0, #0
     fc0:	f000 8152 	beq.w	1268 <ecc_test+0x1268>
    ret = wc_ecc_import_private_key(NULL, tmpSz, NULL, 0, key);
     fc4:	991f      	ldr	r1, [sp, #124]	; 0x7c
     fc6:	9500      	str	r5, [sp, #0]
     fc8:	4653      	mov	r3, sl
     fca:	4652      	mov	r2, sl
     fcc:	4650      	mov	r0, sl
     fce:	f7ff fffe 	bl	0 <wc_ecc_import_private_key>
    if (ret == 0) {
     fd2:	2800      	cmp	r0, #0
     fd4:	f000 814b 	beq.w	126e <ecc_test+0x126e>
    ret = wc_EccPrivateKeyDecode(tmp, &x, key, tmpSz);
     fd8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    x = 0;
     fda:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    ret = wc_EccPrivateKeyDecode(tmp, &x, key, tmpSz);
     fde:	462a      	mov	r2, r5
     fe0:	a90e      	add	r1, sp, #56	; 0x38
     fe2:	4640      	mov	r0, r8
     fe4:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
    if (ret != 0)
     fe8:	4604      	mov	r4, r0
     fea:	b140      	cbz	r0, ffe <ecc_test+0xffe>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     fec:	4244      	negs	r4, r0
     fee:	4fa6      	ldr	r7, [pc, #664]	; (1288 <ecc_test+0x1288>)
     ff0:	48a6      	ldr	r0, [pc, #664]	; (128c <ecc_test+0x128c>)
     ff2:	f3c4 040a 	ubfx	r4, r4, #0, #11
     ff6:	fb07 0704 	mla	r7, r7, r4, r0
    ecc_point* pubPoint = NULL;
     ffa:	2400      	movs	r4, #0
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
     ffc:	e012      	b.n	1024 <ecc_test+0x1024>
    x = ECC_BUFSIZE;
     ffe:	f240 1301 	movw	r3, #257	; 0x101
    ret = wc_ecc_export_private_only(key, exportBuf, &x);
    1002:	aa0e      	add	r2, sp, #56	; 0x38
    1004:	4631      	mov	r1, r6
    1006:	4628      	mov	r0, r5
    x = ECC_BUFSIZE;
    1008:	930e      	str	r3, [sp, #56]	; 0x38
    ret = wc_ecc_export_private_only(key, exportBuf, &x);
    100a:	f7ff fffe 	bl	0 <wc_ecc_export_private_only>
    if (ret != 0)
    100e:	4607      	mov	r7, r0
    1010:	b348      	cbz	r0, 1066 <ecc_test+0x1066>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    1012:	4f9d      	ldr	r7, [pc, #628]	; (1288 <ecc_test+0x1288>)
    1014:	4240      	negs	r0, r0
    1016:	f3c0 000a 	ubfx	r0, r0, #0, #11
    101a:	4378      	muls	r0, r7
    101c:	f100 4760 	add.w	r7, r0, #3758096384	; 0xe0000000
    1020:	f5a7 47ca 	sub.w	r7, r7, #25856	; 0x6500
    wc_ecc_del_point_h(pubPoint, HEAP_HINT);
    1024:	2100      	movs	r1, #0
    1026:	4620      	mov	r0, r4
    1028:	f7ff fffe 	bl	0 <wc_ecc_del_point_h>
    if (key != NULL) {
    102c:	b12d      	cbz	r5, 103a <ecc_test+0x103a>
        wc_ecc_free(key);
    102e:	4628      	mov	r0, r5
    1030:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(key, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
    1034:	4628      	mov	r0, r5
    1036:	f7ff fffe 	bl	0 <free>
    if (pub != NULL)
    103a:	f1b9 0f00 	cmp.w	r9, #0
    103e:	d002      	beq.n	1046 <ecc_test+0x1046>
        XFREE(pub, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
    1040:	4648      	mov	r0, r9
    1042:	f7ff fffe 	bl	0 <free>
    if (exportBuf != NULL)
    1046:	b116      	cbz	r6, 104e <ecc_test+0x104e>
        XFREE(exportBuf, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
    1048:	4630      	mov	r0, r6
    104a:	f7ff fffe 	bl	0 <free>
    if (tmp != NULL)
    104e:	f1b8 0f00 	cmp.w	r8, #0
    1052:	d002      	beq.n	105a <ecc_test+0x105a>
        XFREE(tmp, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
    1054:	4640      	mov	r0, r8
    1056:	f7ff fffe 	bl	0 <free>
    if (ret != 0) {
    105a:	2f00      	cmp	r7, #0
    105c:	f000 813e 	beq.w	12dc <ecc_test+0x12dc>
        printf("ecc_test_make_pub failed!\n");
    1060:	488b      	ldr	r0, [pc, #556]	; (1290 <ecc_test+0x1290>)
    1062:	f7ff ba08 	b.w	476 <ecc_test+0x476>
    wc_ecc_free(key);
    1066:	4628      	mov	r0, r5
    1068:	f7ff fffe 	bl	0 <wc_ecc_free>
    wc_ecc_init_ex(key, HEAP_HINT, devId);
    106c:	f06f 0201 	mvn.w	r2, #1
    1070:	4639      	mov	r1, r7
    1072:	4628      	mov	r0, r5
    1074:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    ret = wc_ecc_import_private_key(exportBuf, x, NULL, 0, key);
    1078:	990e      	ldr	r1, [sp, #56]	; 0x38
    107a:	9500      	str	r5, [sp, #0]
    107c:	463b      	mov	r3, r7
    107e:	463a      	mov	r2, r7
    1080:	4630      	mov	r0, r6
    1082:	f7ff fffe 	bl	0 <wc_ecc_import_private_key>
    if (ret != 0)
    1086:	b138      	cbz	r0, 1098 <ecc_test+0x1098>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    1088:	4b7f      	ldr	r3, [pc, #508]	; (1288 <ecc_test+0x1288>)
    108a:	4f82      	ldr	r7, [pc, #520]	; (1294 <ecc_test+0x1294>)
    108c:	4240      	negs	r0, r0
    108e:	f3c0 000a 	ubfx	r0, r0, #0, #11
    1092:	fb03 7700 	mla	r7, r3, r0, r7
    1096:	e7b0      	b.n	ffa <ecc_test+0xffa>
    x = ECC_BUFSIZE;
    1098:	f240 1701 	movw	r7, #257	; 0x101
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    109c:	2300      	movs	r3, #0
    109e:	aa0e      	add	r2, sp, #56	; 0x38
    10a0:	4631      	mov	r1, r6
    10a2:	4628      	mov	r0, r5
    x = ECC_BUFSIZE;
    10a4:	970e      	str	r7, [sp, #56]	; 0x38
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    10a6:	f7ff fffe 	bl	0 <wc_ecc_export_x963_ex>
    if (ret == 0) {
    10aa:	2800      	cmp	r0, #0
    10ac:	f000 80e2 	beq.w	1274 <ecc_test+0x1274>
    ret = wc_ecc_make_pub(NULL, NULL);
    10b0:	2100      	movs	r1, #0
    10b2:	4608      	mov	r0, r1
    10b4:	f7ff fffe 	bl	0 <wc_ecc_make_pub>
    if (ret == 0) {
    10b8:	2800      	cmp	r0, #0
    10ba:	f000 80de 	beq.w	127a <ecc_test+0x127a>
    pubPoint = wc_ecc_new_point_h(HEAP_HINT);
    10be:	2000      	movs	r0, #0
    10c0:	f7ff fffe 	bl	0 <wc_ecc_new_point_h>
    if (pubPoint == NULL) {
    10c4:	4604      	mov	r4, r0
    10c6:	2800      	cmp	r0, #0
    10c8:	f000 80da 	beq.w	1280 <ecc_test+0x1280>
    ret = wc_ecc_make_pub(key, pubPoint);
    10cc:	4601      	mov	r1, r0
    10ce:	4628      	mov	r0, r5
    10d0:	f7ff fffe 	bl	0 <wc_ecc_make_pub>
    if (ret != 0)
    10d4:	4603      	mov	r3, r0
    10d6:	b138      	cbz	r0, 10e8 <ecc_test+0x10e8>
       ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    10d8:	4243      	negs	r3, r0
    10da:	4f6b      	ldr	r7, [pc, #428]	; (1288 <ecc_test+0x1288>)
    10dc:	486e      	ldr	r0, [pc, #440]	; (1298 <ecc_test+0x1298>)
    10de:	f3c3 030a 	ubfx	r3, r3, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    10e2:	fb07 0703 	mla	r7, r7, r3, r0
    10e6:	e79d      	b.n	1024 <ecc_test+0x1024>
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    10e8:	aa0e      	add	r2, sp, #56	; 0x38
    10ea:	4631      	mov	r1, r6
    10ec:	4628      	mov	r0, r5
    x = ECC_BUFSIZE;
    10ee:	970e      	str	r7, [sp, #56]	; 0x38
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    10f0:	f7ff fffe 	bl	0 <wc_ecc_export_x963_ex>
    if (ret == 0) {
    10f4:	2800      	cmp	r0, #0
    10f6:	f000 80eb 	beq.w	12d0 <ecc_test+0x12d0>
            ret = wc_ecc_sign_hash(msg, (word32)XSTRLEN((const char* )msg), tmp,
    10fa:	4868      	ldr	r0, [pc, #416]	; (129c <ecc_test+0x129c>)
    tmpSz = ECC_BUFSIZE;
    10fc:	971f      	str	r7, [sp, #124]	; 0x7c
            ret = wc_ecc_sign_hash(msg, (word32)XSTRLEN((const char* )msg), tmp,
    10fe:	f7ff fffe 	bl	0 <strlen>
    1102:	f10d 0b30 	add.w	fp, sp, #48	; 0x30
    1106:	4601      	mov	r1, r0
    1108:	9501      	str	r5, [sp, #4]
    110a:	4864      	ldr	r0, [pc, #400]	; (129c <ecc_test+0x129c>)
    110c:	f8cd b000 	str.w	fp, [sp]
    1110:	ab1f      	add	r3, sp, #124	; 0x7c
    1112:	4642      	mov	r2, r8
    1114:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
    } while (ret == WC_PENDING_E);
    1118:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
    111c:	d100      	bne.n	1120 <ecc_test+0x1120>
    111e:	e7fe      	b.n	111e <ecc_test+0x111e>
    if (ret != 0)
    1120:	b138      	cbz	r0, 1132 <ecc_test+0x1132>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    1122:	4240      	negs	r0, r0
    1124:	4b58      	ldr	r3, [pc, #352]	; (1288 <ecc_test+0x1288>)
    1126:	4f5e      	ldr	r7, [pc, #376]	; (12a0 <ecc_test+0x12a0>)
    1128:	f3c0 000a 	ubfx	r0, r0, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    112c:	fb03 7700 	mla	r7, r3, r0, r7
    1130:	e778      	b.n	1024 <ecc_test+0x1024>
                (word32)XSTRLEN((const char*)msg), &verify, key);
    1132:	485a      	ldr	r0, [pc, #360]	; (129c <ecc_test+0x129c>)
            ret = wc_ecc_verify_hash(tmp, tmpSz, msg,
    1134:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
                (word32)XSTRLEN((const char*)msg), &verify, key);
    1136:	f7ff fffe 	bl	0 <strlen>
            ret = wc_ecc_verify_hash(tmp, tmpSz, msg,
    113a:	aa30      	add	r2, sp, #192	; 0xc0
                (word32)XSTRLEN((const char*)msg), &verify, key);
    113c:	4603      	mov	r3, r0
            ret = wc_ecc_verify_hash(tmp, tmpSz, msg,
    113e:	9200      	str	r2, [sp, #0]
    1140:	9501      	str	r5, [sp, #4]
    1142:	4a56      	ldr	r2, [pc, #344]	; (129c <ecc_test+0x129c>)
    1144:	4639      	mov	r1, r7
    1146:	4640      	mov	r0, r8
    1148:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
    } while (ret == WC_PENDING_E);
    114c:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
    1150:	d100      	bne.n	1154 <ecc_test+0x1154>
    1152:	e7fe      	b.n	1152 <ecc_test+0x1152>
    if (ret != 0)
    1154:	b128      	cbz	r0, 1162 <ecc_test+0x1162>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    1156:	4240      	negs	r0, r0
    1158:	4b4b      	ldr	r3, [pc, #300]	; (1288 <ecc_test+0x1288>)
    115a:	4f52      	ldr	r7, [pc, #328]	; (12a4 <ecc_test+0x12a4>)
    115c:	f3c0 000a 	ubfx	r0, r0, #0, #11
    1160:	e7e4      	b.n	112c <ecc_test+0x112c>
    if (verify != 1) {
    1162:	9b30      	ldr	r3, [sp, #192]	; 0xc0
    1164:	2b01      	cmp	r3, #1
    1166:	f040 80b5 	bne.w	12d4 <ecc_test+0x12d4>
    x = ECC_BUFSIZE;
    116a:	f240 1a01 	movw	sl, #257	; 0x101
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    116e:	2300      	movs	r3, #0
    1170:	aa0e      	add	r2, sp, #56	; 0x38
    1172:	4631      	mov	r1, r6
    1174:	4628      	mov	r0, r5
    x = ECC_BUFSIZE;
    1176:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    117a:	f7ff fffe 	bl	0 <wc_ecc_export_x963_ex>
    if (ret != 0)
    117e:	b128      	cbz	r0, 118c <ecc_test+0x118c>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    1180:	4240      	negs	r0, r0
    1182:	4b41      	ldr	r3, [pc, #260]	; (1288 <ecc_test+0x1288>)
    1184:	4f48      	ldr	r7, [pc, #288]	; (12a8 <ecc_test+0x12a8>)
    1186:	f3c0 000a 	ubfx	r0, r0, #0, #11
    118a:	e7cf      	b.n	112c <ecc_test+0x112c>
    ret = wc_ecc_export_private_only(key, exportBuf, &x);
    118c:	aa0e      	add	r2, sp, #56	; 0x38
    118e:	4631      	mov	r1, r6
    1190:	4628      	mov	r0, r5
    x = ECC_BUFSIZE;
    1192:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    ret = wc_ecc_export_private_only(key, exportBuf, &x);
    1196:	f7ff fffe 	bl	0 <wc_ecc_export_private_only>
    if (ret != 0)
    119a:	4607      	mov	r7, r0
    119c:	b128      	cbz	r0, 11aa <ecc_test+0x11aa>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    119e:	4247      	negs	r7, r0
    11a0:	f3c7 030a 	ubfx	r3, r7, #0, #11
    11a4:	4841      	ldr	r0, [pc, #260]	; (12ac <ecc_test+0x12ac>)
    11a6:	4f38      	ldr	r7, [pc, #224]	; (1288 <ecc_test+0x1288>)
    11a8:	e79b      	b.n	10e2 <ecc_test+0x10e2>
    wc_ecc_free(key);
    11aa:	4628      	mov	r0, r5
    11ac:	f7ff fffe 	bl	0 <wc_ecc_free>
    wc_ecc_init_ex(key, HEAP_HINT, devId);
    11b0:	4639      	mov	r1, r7
    11b2:	f06f 0201 	mvn.w	r2, #1
    11b6:	4628      	mov	r0, r5
    11b8:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    ret = wc_ecc_import_private_key(exportBuf, x, NULL, 0, key);
    11bc:	463b      	mov	r3, r7
    11be:	463a      	mov	r2, r7
    11c0:	990e      	ldr	r1, [sp, #56]	; 0x38
    11c2:	9500      	str	r5, [sp, #0]
    11c4:	4630      	mov	r0, r6
    11c6:	f7ff fffe 	bl	0 <wc_ecc_import_private_key>
    if (ret != 0)
    11ca:	4607      	mov	r7, r0
    11cc:	b128      	cbz	r0, 11da <ecc_test+0x11da>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    11ce:	4247      	negs	r7, r0
    11d0:	f3c7 030a 	ubfx	r3, r7, #0, #11
    11d4:	4836      	ldr	r0, [pc, #216]	; (12b0 <ecc_test+0x12b0>)
    11d6:	4f2c      	ldr	r7, [pc, #176]	; (1288 <ecc_test+0x1288>)
    11d8:	e783      	b.n	10e2 <ecc_test+0x10e2>
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    11da:	4603      	mov	r3, r0
    11dc:	aa0e      	add	r2, sp, #56	; 0x38
    11de:	4631      	mov	r1, r6
    11e0:	4628      	mov	r0, r5
    x = ECC_BUFSIZE;
    11e2:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    ret = wc_ecc_export_x963_ex(key, exportBuf, &x, 0);
    11e6:	f7ff fffe 	bl	0 <wc_ecc_export_x963_ex>
    if (ret == 0) {
    11ea:	2800      	cmp	r0, #0
    11ec:	d074      	beq.n	12d8 <ecc_test+0x12d8>
    wc_ecc_init_ex(pub, HEAP_HINT, devId);
    11ee:	f06f 0201 	mvn.w	r2, #1
    11f2:	4639      	mov	r1, r7
    11f4:	4648      	mov	r0, r9
    11f6:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    ret = wc_ecc_make_key(rng, ECC_KEYGEN_SIZE, pub);
    11fa:	464a      	mov	r2, r9
    11fc:	2120      	movs	r1, #32
    11fe:	4658      	mov	r0, fp
    1200:	f7ff fffe 	bl	0 <wc_ecc_make_key>
    if (ret != 0)
    1204:	b128      	cbz	r0, 1212 <ecc_test+0x1212>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    1206:	4240      	negs	r0, r0
    1208:	4b1f      	ldr	r3, [pc, #124]	; (1288 <ecc_test+0x1288>)
    120a:	4f2a      	ldr	r7, [pc, #168]	; (12b4 <ecc_test+0x12b4>)
    120c:	f3c0 000a 	ubfx	r0, r0, #0, #11
    1210:	e78c      	b.n	112c <ecc_test+0x112c>
    ret = wc_ecc_set_rng(key, rng);
    1212:	4659      	mov	r1, fp
    1214:	4628      	mov	r0, r5
    1216:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
    if (ret != 0)
    121a:	4607      	mov	r7, r0
    121c:	2800      	cmp	r0, #0
    121e:	f47f af01 	bne.w	1024 <ecc_test+0x1024>
            ret = wc_ecc_shared_secret(key, pub, exportBuf, &x);
    1222:	ab0e      	add	r3, sp, #56	; 0x38
    1224:	4632      	mov	r2, r6
    1226:	4649      	mov	r1, r9
    1228:	4628      	mov	r0, r5
    x = ECC_BUFSIZE;
    122a:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
            ret = wc_ecc_shared_secret(key, pub, exportBuf, &x);
    122e:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
    } while (ret == WC_PENDING_E);
    1232:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
            ret = wc_ecc_shared_secret(key, pub, exportBuf, &x);
    1236:	4607      	mov	r7, r0
    } while (ret == WC_PENDING_E);
    1238:	d100      	bne.n	123c <ecc_test+0x123c>
    123a:	e7fe      	b.n	123a <ecc_test+0x123a>
    wc_ecc_free(pub);
    123c:	4648      	mov	r0, r9
    123e:	f7ff fffe 	bl	0 <wc_ecc_free>
    if (ret != 0)
    1242:	2f00      	cmp	r7, #0
    1244:	f43f aeee 	beq.w	1024 <ecc_test+0x1024>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
    1248:	4278      	negs	r0, r7
    124a:	4b0f      	ldr	r3, [pc, #60]	; (1288 <ecc_test+0x1288>)
    124c:	4f1a      	ldr	r7, [pc, #104]	; (12b8 <ecc_test+0x12b8>)
    124e:	f3c0 000a 	ubfx	r0, r0, #0, #11
    1252:	e76b      	b.n	112c <ecc_test+0x112c>
    ecc_point* pubPoint = NULL;
    1254:	462c      	mov	r4, r5
        ERROR_OUT(MEMORY_E, done);
    1256:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    125a:	e6e3      	b.n	1024 <ecc_test+0x1024>
    ecc_point* pubPoint = NULL;
    125c:	464c      	mov	r4, r9
    125e:	e7fa      	b.n	1256 <ecc_test+0x1256>
    1260:	4634      	mov	r4, r6
    1262:	e7f8      	b.n	1256 <ecc_test+0x1256>
    1264:	4604      	mov	r4, r0
    1266:	e7f6      	b.n	1256 <ecc_test+0x1256>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    1268:	4f14      	ldr	r7, [pc, #80]	; (12bc <ecc_test+0x12bc>)
    ecc_point* pubPoint = NULL;
    126a:	4604      	mov	r4, r0
    126c:	e6da      	b.n	1024 <ecc_test+0x1024>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    126e:	4f14      	ldr	r7, [pc, #80]	; (12c0 <ecc_test+0x12c0>)
    ecc_point* pubPoint = NULL;
    1270:	4604      	mov	r4, r0
    1272:	e6d7      	b.n	1024 <ecc_test+0x1024>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    1274:	4f13      	ldr	r7, [pc, #76]	; (12c4 <ecc_test+0x12c4>)
    ecc_point* pubPoint = NULL;
    1276:	4604      	mov	r4, r0
    1278:	e6d4      	b.n	1024 <ecc_test+0x1024>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    127a:	4f13      	ldr	r7, [pc, #76]	; (12c8 <ecc_test+0x12c8>)
    ecc_point* pubPoint = NULL;
    127c:	4604      	mov	r4, r0
    127e:	e6d1      	b.n	1024 <ecc_test+0x1024>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, done);
    1280:	4f12      	ldr	r7, [pc, #72]	; (12cc <ecc_test+0x12cc>)
    1282:	e6cf      	b.n	1024 <ecc_test+0x1024>
    1284:	00000000 	.word	0x00000000
    1288:	fffe7960 	.word	0xfffe7960
    128c:	dfff9b06 	.word	0xdfff9b06
    1290:	00000259 	.word	0x00000259
    1294:	dfff9af9 	.word	0xdfff9af9
    1298:	dfff9ade 	.word	0xdfff9ade
    129c:	0000023d 	.word	0x0000023d
    12a0:	dfff9ab7 	.word	0xdfff9ab7
    12a4:	dfff9aa7 	.word	0xdfff9aa7
    12a8:	dfff9a9c 	.word	0xdfff9a9c
    12ac:	dfff9a91 	.word	0xdfff9a91
    12b0:	dfff9a89 	.word	0xdfff9a89
    12b4:	dfff9a74 	.word	0xdfff9a74
    12b8:	dfff9a5e 	.word	0xdfff9a5e
    12bc:	ffff9b11 	.word	0xffff9b11
    12c0:	ffff9b0c 	.word	0xffff9b0c
    12c4:	ffff9af4 	.word	0xffff9af4
    12c8:	ffff9aed 	.word	0xffff9aed
    12cc:	ffff9ae6 	.word	0xffff9ae6
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    12d0:	4f28      	ldr	r7, [pc, #160]	; (1374 <ecc_test+0x1374>)
    12d2:	e6a7      	b.n	1024 <ecc_test+0x1024>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    12d4:	4f28      	ldr	r7, [pc, #160]	; (1378 <ecc_test+0x1378>)
    12d6:	e6a5      	b.n	1024 <ecc_test+0x1024>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    12d8:	4f28      	ldr	r7, [pc, #160]	; (137c <ecc_test+0x137c>)
    12da:	e6a3      	b.n	1024 <ecc_test+0x1024>
    key = wc_ecc_key_new(HEAP_HINT);
    12dc:	4638      	mov	r0, r7
    12de:	f7ff fffe 	bl	0 <wc_ecc_key_new>
    if (key == NULL) {
    12e2:	4604      	mov	r4, r0
    12e4:	b1b0      	cbz	r0, 1314 <ecc_test+0x1314>
    ret = wc_ecc_make_key(rng, ECC_KEYGEN_SIZE, key);
    12e6:	4602      	mov	r2, r0
    12e8:	2120      	movs	r1, #32
    12ea:	a80c      	add	r0, sp, #48	; 0x30
    12ec:	f7ff fffe 	bl	0 <wc_ecc_make_key>
    if (ret != 0)
    12f0:	4607      	mov	r7, r0
    12f2:	b130      	cbz	r0, 1302 <ecc_test+0x1302>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), exit);
    12f4:	4b22      	ldr	r3, [pc, #136]	; (1380 <ecc_test+0x1380>)
    12f6:	4f23      	ldr	r7, [pc, #140]	; (1384 <ecc_test+0x1384>)
    12f8:	4240      	negs	r0, r0
    12fa:	f3c0 000a 	ubfx	r0, r0, #0, #11
    12fe:	fb03 7700 	mla	r7, r3, r0, r7
    wc_ecc_key_free(key);
    1302:	4620      	mov	r0, r4
    1304:	f7ff fffe 	bl	0 <wc_ecc_key_free>
    if (ret != 0) {
    1308:	2f00      	cmp	r7, #0
    130a:	f43f aade 	beq.w	8ca <ecc_test+0x8ca>
        printf("ecc_test_allocator failed!\n");
    130e:	481e      	ldr	r0, [pc, #120]	; (1388 <ecc_test+0x1388>)
    1310:	f7ff b8b1 	b.w	476 <ecc_test+0x476>
        ERROR_OUT(WC_TEST_RET_ENC_ERRNO, exit);
    1314:	4f1d      	ldr	r7, [pc, #116]	; (138c <ecc_test+0x138c>)
    1316:	e7f4      	b.n	1302 <ecc_test+0x1302>
        ERROR_OUT(MEMORY_E, done);
    1318:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    131c:	e5d8      	b.n	ed0 <ecc_test+0xed0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(MEMORY_E), done);
    131e:	4f1c      	ldr	r7, [pc, #112]	; (1390 <ecc_test+0x1390>)
    1320:	f7ff ba6e 	b.w	800 <ecc_test+0x800>
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
    1324:	4f1b      	ldr	r7, [pc, #108]	; (1394 <ecc_test+0x1394>)
    1326:	f7ff ba6b 	b.w	800 <ecc_test+0x800>
        ERROR_OUT(MEMORY_E, done);
    132a:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    132e:	f7ff ba27 	b.w	780 <ecc_test+0x780>
    1332:	462f      	mov	r7, r5
    1334:	f7ff ba24 	b.w	780 <ecc_test+0x780>
    if (userA != NULL) {
    1338:	2c00      	cmp	r4, #0
    133a:	f47f a9d7 	bne.w	6ec <ecc_test+0x6ec>
        ERROR_OUT(MEMORY_E, done);
    133e:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    WC_FREE_VAR(sigRaw, HEAP_HINT);
    1342:	4630      	mov	r0, r6
    1344:	f7ff fffe 	bl	0 <free>
    1348:	f7ff b9bb 	b.w	6c2 <ecc_test+0x6c2>
    if (userA != NULL) {
    134c:	2c00      	cmp	r4, #0
    134e:	f47f a9cd 	bne.w	6ec <ecc_test+0x6ec>
        ERROR_OUT(MEMORY_E, done);
    1352:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    1356:	f7ff b9b4 	b.w	6c2 <ecc_test+0x6c2>
    if (userA != NULL) {
    135a:	2800      	cmp	r0, #0
    135c:	f47f aa90 	bne.w	880 <ecc_test+0x880>
        ERROR_OUT(WC_TEST_RET_ENC_EC(MEMORY_E), done);
    1360:	4f0b      	ldr	r7, [pc, #44]	; (1390 <ecc_test+0x1390>)
    1362:	f7ff ba98 	b.w	896 <ecc_test+0x896>
    if (tmpBuf != NULL)
    1366:	2800      	cmp	r0, #0
    1368:	f47f aa12 	bne.w	790 <ecc_test+0x790>
        ERROR_OUT(MEMORY_E, done);
    136c:	f06f 077c 	mvn.w	r7, #124	; 0x7c
    1370:	f7ff ba18 	b.w	7a4 <ecc_test+0x7a4>
    1374:	ffff9ad5 	.word	0xffff9ad5
    1378:	ffff9aa4 	.word	0xffff9aa4
    137c:	ffff9a83 	.word	0xffff9a83
    1380:	fffe7960 	.word	0xfffe7960
    1384:	dfff90a0 	.word	0xdfff90a0
    1388:	00000274 	.word	0x00000274
    138c:	ffff90a9 	.word	0xffff90a9
    1390:	df40ddbb 	.word	0xdf40ddbb
    1394:	ffff99b7 	.word	0xffff99b7

Disassembly of section .text.ecc_test_buffers:

00000000 <ecc_test_buffers>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ecc_key *cliKey = (ecc_key *)XMALLOC(sizeof *cliKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
   4:	f44f 70de 	mov.w	r0, #444	; 0x1bc
{
   8:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
    ecc_key *cliKey = (ecc_key *)XMALLOC(sizeof *cliKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
   c:	f7ff fffe 	bl	0 <malloc>
  10:	4605      	mov	r5, r0
    ecc_key *servKey = (ecc_key *)XMALLOC(sizeof *servKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
  12:	f44f 70de 	mov.w	r0, #444	; 0x1bc
  16:	f7ff fffe 	bl	0 <malloc>
  1a:	4607      	mov	r7, r0
    ecc_key *tmpKey = (ecc_key *)XMALLOC(sizeof *tmpKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
  1c:	f44f 70de 	mov.w	r0, #444	; 0x1bc
  20:	f7ff fffe 	bl	0 <malloc>
    word32 idx = 0;
  24:	2300      	movs	r3, #0
  26:	9303      	str	r3, [sp, #12]
    byte   in[] = "Everyone gets Friday off. ecc p";
  28:	4b74      	ldr	r3, [pc, #464]	; (1fc <ecc_test_buffers+0x1fc>)
    ecc_key *tmpKey = (ecc_key *)XMALLOC(sizeof *tmpKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
  2a:	4680      	mov	r8, r0
    byte   in[] = "Everyone gets Friday off. ecc p";
  2c:	ac08      	add	r4, sp, #32
  2e:	f103 0620 	add.w	r6, r3, #32
  32:	6818      	ldr	r0, [r3, #0]
  34:	6859      	ldr	r1, [r3, #4]
  36:	4622      	mov	r2, r4
  38:	c203      	stmia	r2!, {r0, r1}
  3a:	3308      	adds	r3, #8
  3c:	42b3      	cmp	r3, r6
  3e:	4614      	mov	r4, r2
  40:	d1f7      	bne.n	32 <ecc_test_buffers+0x32>
    word32 inLen = (word32)XSTRLEN((char*)in);
  42:	a808      	add	r0, sp, #32
  44:	f7ff fffe 	bl	0 <strlen>
    int verify = 0;
  48:	f10d 0a10 	add.w	sl, sp, #16
  4c:	2100      	movs	r1, #0
    word32 inLen = (word32)XSTRLEN((char*)in);
  4e:	4681      	mov	r9, r0
    int verify = 0;
  50:	f8ca 1000 	str.w	r1, [sl]
    if ((cliKey == NULL) || (servKey == NULL) || (tmpKey == NULL))
  54:	2d00      	cmp	r5, #0
  56:	f000 80b3 	beq.w	1c0 <ecc_test_buffers+0x1c0>
  5a:	2f00      	cmp	r7, #0
  5c:	f000 80ca 	beq.w	1f4 <ecc_test_buffers+0x1f4>
  60:	f1b8 0f00 	cmp.w	r8, #0
  64:	f000 80c6 	beq.w	1f4 <ecc_test_buffers+0x1f4>
    ret = wc_ecc_init_ex(cliKey, HEAP_HINT, devId);
  68:	f06f 0201 	mvn.w	r2, #1
  6c:	4628      	mov	r0, r5
  6e:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
  72:	4601      	mov	r1, r0
  74:	b138      	cbz	r0, 86 <ecc_test_buffers+0x86>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
  76:	4241      	negs	r1, r0
  78:	4c61      	ldr	r4, [pc, #388]	; (200 <ecc_test_buffers+0x200>)
  7a:	4862      	ldr	r0, [pc, #392]	; (204 <ecc_test_buffers+0x204>)
  7c:	f3c1 010a 	ubfx	r1, r1, #0, #11
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
  80:	fb01 4400 	mla	r4, r1, r0, r4
  84:	e059      	b.n	13a <ecc_test_buffers+0x13a>
    ret = wc_ecc_init_ex(servKey, HEAP_HINT, devId);
  86:	f06f 0201 	mvn.w	r2, #1
  8a:	4638      	mov	r0, r7
  8c:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
  90:	4601      	mov	r1, r0
  92:	b128      	cbz	r0, a0 <ecc_test_buffers+0xa0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
  94:	4241      	negs	r1, r0
  96:	4c5c      	ldr	r4, [pc, #368]	; (208 <ecc_test_buffers+0x208>)
  98:	485a      	ldr	r0, [pc, #360]	; (204 <ecc_test_buffers+0x204>)
  9a:	f3c1 010a 	ubfx	r1, r1, #0, #11
  9e:	e7ef      	b.n	80 <ecc_test_buffers+0x80>
    ret = wc_ecc_init_ex(tmpKey, HEAP_HINT, devId);
  a0:	f06f 0201 	mvn.w	r2, #1
  a4:	4640      	mov	r0, r8
  a6:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0)
  aa:	b128      	cbz	r0, b8 <ecc_test_buffers+0xb8>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
  ac:	4240      	negs	r0, r0
  ae:	4955      	ldr	r1, [pc, #340]	; (204 <ecc_test_buffers+0x204>)
  b0:	4c56      	ldr	r4, [pc, #344]	; (20c <ecc_test_buffers+0x20c>)
  b2:	f3c0 000a 	ubfx	r0, r0, #0, #11
  b6:	e7e3      	b.n	80 <ecc_test_buffers+0x80>
    ret = wc_EccPrivateKeyDecode(ecc_clikey_der_256, &idx, cliKey,
  b8:	4855      	ldr	r0, [pc, #340]	; (210 <ecc_test_buffers+0x210>)
  ba:	2379      	movs	r3, #121	; 0x79
  bc:	462a      	mov	r2, r5
  be:	a903      	add	r1, sp, #12
  c0:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
    if (ret != 0)
  c4:	b128      	cbz	r0, d2 <ecc_test_buffers+0xd2>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
  c6:	4240      	negs	r0, r0
  c8:	494e      	ldr	r1, [pc, #312]	; (204 <ecc_test_buffers+0x204>)
  ca:	4c52      	ldr	r4, [pc, #328]	; (214 <ecc_test_buffers+0x214>)
  cc:	f3c0 000a 	ubfx	r0, r0, #0, #11
  d0:	e7d6      	b.n	80 <ecc_test_buffers+0x80>
    idx = 0;
  d2:	9003      	str	r0, [sp, #12]
    ret = wc_EccPrivateKeyDecode(ecc_key_der_256, &idx, servKey,
  d4:	a903      	add	r1, sp, #12
  d6:	4850      	ldr	r0, [pc, #320]	; (218 <ecc_test_buffers+0x218>)
  d8:	2379      	movs	r3, #121	; 0x79
  da:	463a      	mov	r2, r7
  dc:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
    if (ret != 0)
  e0:	4601      	mov	r1, r0
  e2:	b128      	cbz	r0, f0 <ecc_test_buffers+0xf0>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
  e4:	4241      	negs	r1, r0
  e6:	4c4d      	ldr	r4, [pc, #308]	; (21c <ecc_test_buffers+0x21c>)
  e8:	4846      	ldr	r0, [pc, #280]	; (204 <ecc_test_buffers+0x204>)
  ea:	f3c1 010a 	ubfx	r1, r1, #0, #11
  ee:	e7c7      	b.n	80 <ecc_test_buffers+0x80>
    ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);
  f0:	ae06      	add	r6, sp, #24
  f2:	f06f 0201 	mvn.w	r2, #1
  f6:	4630      	mov	r0, r6
  f8:	f7ff fffe 	bl	0 <wc_InitRng_ex>
    if (ret != 0)
  fc:	b128      	cbz	r0, 10a <ecc_test_buffers+0x10a>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
  fe:	4240      	negs	r0, r0
 100:	4940      	ldr	r1, [pc, #256]	; (204 <ecc_test_buffers+0x204>)
 102:	4c47      	ldr	r4, [pc, #284]	; (220 <ecc_test_buffers+0x220>)
 104:	f3c0 000a 	ubfx	r0, r0, #0, #11
 108:	e7ba      	b.n	80 <ecc_test_buffers+0x80>
    ret = wc_ecc_set_rng(cliKey, &rng);
 10a:	4631      	mov	r1, r6
 10c:	4628      	mov	r0, r5
 10e:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
    if (ret != 0)
 112:	b128      	cbz	r0, 120 <ecc_test_buffers+0x120>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
 114:	4240      	negs	r0, r0
 116:	493b      	ldr	r1, [pc, #236]	; (204 <ecc_test_buffers+0x204>)
 118:	4c42      	ldr	r4, [pc, #264]	; (224 <ecc_test_buffers+0x224>)
 11a:	f3c0 000a 	ubfx	r0, r0, #0, #11
 11e:	e7af      	b.n	80 <ecc_test_buffers+0x80>
    ret = wc_ecc_set_rng(servKey, &rng);
 120:	4631      	mov	r1, r6
 122:	4638      	mov	r0, r7
 124:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
    if (ret != 0)
 128:	4604      	mov	r4, r0
 12a:	b168      	cbz	r0, 148 <ecc_test_buffers+0x148>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
 12c:	4244      	negs	r4, r0
 12e:	4935      	ldr	r1, [pc, #212]	; (204 <ecc_test_buffers+0x204>)
 130:	483d      	ldr	r0, [pc, #244]	; (228 <ecc_test_buffers+0x228>)
 132:	f3c4 040a 	ubfx	r4, r4, #0, #11
 136:	fb01 0404 	mla	r4, r1, r4, r0
        wc_ecc_free(cliKey);
 13a:	4628      	mov	r0, r5
 13c:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(cliKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 140:	4628      	mov	r0, r5
 142:	f7ff fffe 	bl	0 <free>
 146:	e03d      	b.n	1c4 <ecc_test_buffers+0x1c4>
            ret = wc_ecc_sign_hash(in, inLen, out, &x, &rng, cliKey);
 148:	e9cd 6500 	strd	r6, r5, [sp]
    x = sizeof(out);
 14c:	f44f 7b80 	mov.w	fp, #256	; 0x100
            ret = wc_ecc_sign_hash(in, inLen, out, &x, &rng, cliKey);
 150:	ab05      	add	r3, sp, #20
 152:	aa10      	add	r2, sp, #64	; 0x40
 154:	4649      	mov	r1, r9
 156:	a808      	add	r0, sp, #32
    x = sizeof(out);
 158:	f8cd b014 	str.w	fp, [sp, #20]
            ret = wc_ecc_sign_hash(in, inLen, out, &x, &rng, cliKey);
 15c:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
    } while (ret == WC_PENDING_E);
 160:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
            ret = wc_ecc_sign_hash(in, inLen, out, &x, &rng, cliKey);
 164:	4606      	mov	r6, r0
    } while (ret == WC_PENDING_E);
 166:	d100      	bne.n	16a <ecc_test_buffers+0x16a>
 168:	e7fe      	b.n	168 <ecc_test_buffers+0x168>
    if (ret < 0)
 16a:	2800      	cmp	r0, #0
 16c:	da07      	bge.n	17e <ecc_test_buffers+0x17e>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
 16e:	4246      	negs	r6, r0
 170:	4c2e      	ldr	r4, [pc, #184]	; (22c <ecc_test_buffers+0x22c>)
 172:	4824      	ldr	r0, [pc, #144]	; (204 <ecc_test_buffers+0x204>)
 174:	f3c6 060a 	ubfx	r6, r6, #0, #11
 178:	fb00 4406 	mla	r4, r0, r6, r4
 17c:	e7dd      	b.n	13a <ecc_test_buffers+0x13a>
    XMEMSET(plain, 0, sizeof(plain));
 17e:	465a      	mov	r2, fp
 180:	4621      	mov	r1, r4
 182:	a850      	add	r0, sp, #320	; 0x140
 184:	f7ff fffe 	bl	0 <memset>
        if (ret == 0)
 188:	b99e      	cbnz	r6, 1b2 <ecc_test_buffers+0x1b2>
            ret = wc_ecc_verify_hash(out, x, in, inLen, &verify,
 18a:	e9cd a500 	strd	sl, r5, [sp]
 18e:	9905      	ldr	r1, [sp, #20]
 190:	464b      	mov	r3, r9
 192:	aa08      	add	r2, sp, #32
 194:	a810      	add	r0, sp, #64	; 0x40
 196:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
    } while (ret == WC_PENDING_E);
 19a:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
 19e:	d100      	bne.n	1a2 <ecc_test_buffers+0x1a2>
 1a0:	e7fe      	b.n	1a0 <ecc_test_buffers+0x1a0>
    if (ret < 0)
 1a2:	2800      	cmp	r0, #0
 1a4:	da05      	bge.n	1b2 <ecc_test_buffers+0x1b2>
        ERROR_OUT(WC_TEST_RET_ENC_EC(ret), done);
 1a6:	4240      	negs	r0, r0
 1a8:	4916      	ldr	r1, [pc, #88]	; (204 <ecc_test_buffers+0x204>)
 1aa:	4c21      	ldr	r4, [pc, #132]	; (230 <ecc_test_buffers+0x230>)
 1ac:	f3c0 000a 	ubfx	r0, r0, #0, #11
 1b0:	e766      	b.n	80 <ecc_test_buffers+0x80>
    if (verify != 1)
 1b2:	f8da 2000 	ldr.w	r2, [sl]
        ERROR_OUT(WC_TEST_RET_ENC_NC, done);
 1b6:	4b1f      	ldr	r3, [pc, #124]	; (234 <ecc_test_buffers+0x234>)
 1b8:	2a01      	cmp	r2, #1
 1ba:	bf18      	it	ne
 1bc:	461c      	movne	r4, r3
 1be:	e7bc      	b.n	13a <ecc_test_buffers+0x13a>
        ERROR_OUT(MEMORY_E, done);
 1c0:	f06f 047c 	mvn.w	r4, #124	; 0x7c
    if (servKey != NULL) {
 1c4:	b12f      	cbz	r7, 1d2 <ecc_test_buffers+0x1d2>
        wc_ecc_free(servKey);
 1c6:	4638      	mov	r0, r7
 1c8:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(servKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 1cc:	4638      	mov	r0, r7
 1ce:	f7ff fffe 	bl	0 <free>
    if (tmpKey != NULL) {
 1d2:	f1b8 0f00 	cmp.w	r8, #0
 1d6:	d005      	beq.n	1e4 <ecc_test_buffers+0x1e4>
        wc_ecc_free(tmpKey);
 1d8:	4640      	mov	r0, r8
 1da:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(tmpKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 1de:	4640      	mov	r0, r8
 1e0:	f7ff fffe 	bl	0 <free>
    wc_FreeRng(&rng);
 1e4:	a806      	add	r0, sp, #24
 1e6:	f7ff fffe 	bl	0 <wc_FreeRng>
}
 1ea:	4620      	mov	r0, r4
 1ec:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
 1f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ERROR_OUT(MEMORY_E, done);
 1f4:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 1f8:	e79f      	b.n	13a <ecc_test_buffers+0x13a>
 1fa:	bf00      	nop
 1fc:	00000000 	.word	0x00000000
 200:	dfff8a8e 	.word	0xdfff8a8e
 204:	fffe7960 	.word	0xfffe7960
 208:	dfff8a8b 	.word	0xdfff8a8b
 20c:	dfff8a88 	.word	0xdfff8a88
 210:	00000000 	.word	0x00000000
 214:	dfff8a81 	.word	0xdfff8a81
 218:	00000000 	.word	0x00000000
 21c:	dfff8a78 	.word	0xdfff8a78
 220:	dfff8a6f 	.word	0xdfff8a6f
 224:	dfff8a68 	.word	0xdfff8a68
 228:	dfff8a65 	.word	0xdfff8a65
 22c:	dfff8a3e 	.word	0xdfff8a3e
 230:	dfff8a30 	.word	0xdfff8a30
 234:	ffff8a2e 	.word	0xffff8a2e

Disassembly of section .text.curve25519_test:

00000000 <curve25519_test>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	f5ad 7d59 	sub.w	sp, sp, #868	; 0x364
    word32  x = 0;
   6:	2300      	movs	r3, #0
   8:	9304      	str	r3, [sp, #16]
    byte sa[] = {
   a:	4ba8      	ldr	r3, [pc, #672]	; (2ac <curve25519_test+0x2ac>)
   c:	ac20      	add	r4, sp, #128	; 0x80
   e:	f103 0520 	add.w	r5, r3, #32
  12:	6818      	ldr	r0, [r3, #0]
  14:	6859      	ldr	r1, [r3, #4]
  16:	4622      	mov	r2, r4
  18:	c203      	stmia	r2!, {r0, r1}
  1a:	3308      	adds	r3, #8
  1c:	42ab      	cmp	r3, r5
  1e:	4614      	mov	r4, r2
  20:	d1f7      	bne.n	12 <curve25519_test+0x12>
    byte pa[] = {
  22:	4ba3      	ldr	r3, [pc, #652]	; (2b0 <curve25519_test+0x2b0>)
  24:	ac28      	add	r4, sp, #160	; 0xa0
  26:	f103 0520 	add.w	r5, r3, #32
  2a:	6818      	ldr	r0, [r3, #0]
  2c:	6859      	ldr	r1, [r3, #4]
  2e:	4622      	mov	r2, r4
  30:	c203      	stmia	r2!, {r0, r1}
  32:	3308      	adds	r3, #8
  34:	42ab      	cmp	r3, r5
  36:	4614      	mov	r4, r2
  38:	d1f7      	bne.n	2a <curve25519_test+0x2a>
    byte sb[] = {
  3a:	4b9e      	ldr	r3, [pc, #632]	; (2b4 <curve25519_test+0x2b4>)
  3c:	ac30      	add	r4, sp, #192	; 0xc0
  3e:	f103 0520 	add.w	r5, r3, #32
  42:	6818      	ldr	r0, [r3, #0]
  44:	6859      	ldr	r1, [r3, #4]
  46:	4622      	mov	r2, r4
  48:	c203      	stmia	r2!, {r0, r1}
  4a:	3308      	adds	r3, #8
  4c:	42ab      	cmp	r3, r5
  4e:	4614      	mov	r4, r2
  50:	d1f7      	bne.n	42 <curve25519_test+0x42>
    byte pb[] = {
  52:	4b99      	ldr	r3, [pc, #612]	; (2b8 <curve25519_test+0x2b8>)
  54:	ac38      	add	r4, sp, #224	; 0xe0
  56:	f103 0520 	add.w	r5, r3, #32
  5a:	6818      	ldr	r0, [r3, #0]
  5c:	6859      	ldr	r1, [r3, #4]
  5e:	4622      	mov	r2, r4
  60:	c203      	stmia	r2!, {r0, r1}
  62:	3308      	adds	r3, #8
  64:	42ab      	cmp	r3, r5
  66:	4614      	mov	r4, r2
  68:	d1f7      	bne.n	5a <curve25519_test+0x5a>
    byte ss[] = {
  6a:	4b94      	ldr	r3, [pc, #592]	; (2bc <curve25519_test+0x2bc>)
  6c:	ac40      	add	r4, sp, #256	; 0x100
  6e:	f103 0520 	add.w	r5, r3, #32
  72:	6818      	ldr	r0, [r3, #0]
  74:	6859      	ldr	r1, [r3, #4]
  76:	4622      	mov	r2, r4
  78:	c203      	stmia	r2!, {r0, r1}
  7a:	3308      	adds	r3, #8
  7c:	42ab      	cmp	r3, r5
  7e:	4614      	mov	r4, r2
  80:	d1f7      	bne.n	72 <curve25519_test+0x72>
    ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);
  82:	f06f 0201 	mvn.w	r2, #1
  86:	2100      	movs	r1, #0
  88:	a806      	add	r0, sp, #24
  8a:	f7ff fffe 	bl	0 <wc_InitRng_ex>
    if (ret != 0)
  8e:	4604      	mov	r4, r0
  90:	b138      	cbz	r0, a2 <curve25519_test+0xa2>
        return WC_TEST_RET_ENC_EC(ret);
  92:	4244      	negs	r4, r0
  94:	f3c4 010a 	ubfx	r1, r4, #0, #11
  98:	4889      	ldr	r0, [pc, #548]	; (2c0 <curve25519_test+0x2c0>)
  9a:	4c8a      	ldr	r4, [pc, #552]	; (2c4 <curve25519_test+0x2c4>)
        return WC_TEST_RET_ENC_EC(ret);
  9c:	fb01 0404 	mla	r4, r1, r4, r0
  a0:	e01f      	b.n	e2 <curve25519_test+0xe2>
    wc_curve25519_init_ex(&userA, HEAP_HINT, devId);
  a2:	4601      	mov	r1, r0
  a4:	f06f 0201 	mvn.w	r2, #1
  a8:	a867      	add	r0, sp, #412	; 0x19c
    wc_curve25519_init_ex(&userB, HEAP_HINT, devId);
  aa:	ae7a      	add	r6, sp, #488	; 0x1e8
    wc_curve25519_init_ex(&userA, HEAP_HINT, devId);
  ac:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
    wc_curve25519_init_ex(&userB, HEAP_HINT, devId);
  b0:	f06f 0201 	mvn.w	r2, #1
  b4:	4621      	mov	r1, r4
  b6:	4630      	mov	r0, r6
  b8:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
    wc_curve25519_init_ex(&pubKey, HEAP_HINT, devId);
  bc:	f06f 0201 	mvn.w	r2, #1
  c0:	4621      	mov	r1, r4
  c2:	a88d      	add	r0, sp, #564	; 0x234
  c4:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
    ret = wc_curve25519_make_key(&rng, 32, &userA);
  c8:	aa67      	add	r2, sp, #412	; 0x19c
  ca:	2120      	movs	r1, #32
  cc:	a806      	add	r0, sp, #24
  ce:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret != 0)
  d2:	b150      	cbz	r0, ea <curve25519_test+0xea>
        return WC_TEST_RET_ENC_EC(ret);
  d4:	4240      	negs	r0, r0
  d6:	497b      	ldr	r1, [pc, #492]	; (2c4 <curve25519_test+0x2c4>)
  d8:	4c7b      	ldr	r4, [pc, #492]	; (2c8 <curve25519_test+0x2c8>)
  da:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  de:	fb01 4400 	mla	r4, r1, r0, r4
}
  e2:	4620      	mov	r0, r4
  e4:	f50d 7d59 	add.w	sp, sp, #868	; 0x364
  e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret = wc_curve25519_make_key(&rng, 32, &userB);
  ea:	4632      	mov	r2, r6
  ec:	2120      	movs	r1, #32
  ee:	a806      	add	r0, sp, #24
  f0:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret != 0)
  f4:	b128      	cbz	r0, 102 <curve25519_test+0x102>
        return WC_TEST_RET_ENC_EC(ret);
  f6:	4240      	negs	r0, r0
  f8:	4972      	ldr	r1, [pc, #456]	; (2c4 <curve25519_test+0x2c4>)
  fa:	4c74      	ldr	r4, [pc, #464]	; (2cc <curve25519_test+0x2cc>)
  fc:	f3c0 000a 	ubfx	r0, r0, #0, #11
 100:	e7ed      	b.n	de <curve25519_test+0xde>
    x = sizeof(sharedA);
 102:	2520      	movs	r5, #32
    if ((ret = wc_curve25519_shared_secret(&userA, &userB, sharedA, &x)) != 0) {
 104:	ab04      	add	r3, sp, #16
 106:	eb0d 0205 	add.w	r2, sp, r5
 10a:	4631      	mov	r1, r6
 10c:	a867      	add	r0, sp, #412	; 0x19c
    x = sizeof(sharedA);
 10e:	9504      	str	r5, [sp, #16]
    if ((ret = wc_curve25519_shared_secret(&userA, &userB, sharedA, &x)) != 0) {
 110:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
 114:	4604      	mov	r4, r0
 116:	b168      	cbz	r0, 134 <curve25519_test+0x134>
        printf("wc_curve25519_shared_secret 1 failed\n");
 118:	486d      	ldr	r0, [pc, #436]	; (2d0 <curve25519_test+0x2d0>)
 11a:	f7ff fffe 	bl	0 <printf>
 11e:	4b6d      	ldr	r3, [pc, #436]	; (2d4 <curve25519_test+0x2d4>)
 120:	681b      	ldr	r3, [r3, #0]
        return WC_TEST_RET_ENC_EC(ret);
 122:	4264      	negs	r4, r4
        printf("wc_curve25519_shared_secret 1 failed\n");
 124:	6898      	ldr	r0, [r3, #8]
 126:	f7ff fffe 	bl	0 <fflush>
        return WC_TEST_RET_ENC_EC(ret);
 12a:	f3c4 040a 	ubfx	r4, r4, #0, #11
 12e:	4965      	ldr	r1, [pc, #404]	; (2c4 <curve25519_test+0x2c4>)
 130:	4869      	ldr	r0, [pc, #420]	; (2d8 <curve25519_test+0x2d8>)
 132:	e7b3      	b.n	9c <curve25519_test+0x9c>
    if ((ret = wc_curve25519_shared_secret(&userB, &userA, sharedB, &y)) != 0) {
 134:	ab03      	add	r3, sp, #12
 136:	aa10      	add	r2, sp, #64	; 0x40
 138:	a967      	add	r1, sp, #412	; 0x19c
 13a:	4630      	mov	r0, r6
    y = sizeof(sharedB);
 13c:	9503      	str	r5, [sp, #12]
    if ((ret = wc_curve25519_shared_secret(&userB, &userA, sharedB, &y)) != 0) {
 13e:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
 142:	4604      	mov	r4, r0
 144:	b168      	cbz	r0, 162 <curve25519_test+0x162>
        printf("wc_curve25519_shared_secret 2 failed\n");
 146:	4865      	ldr	r0, [pc, #404]	; (2dc <curve25519_test+0x2dc>)
 148:	f7ff fffe 	bl	0 <printf>
 14c:	4b61      	ldr	r3, [pc, #388]	; (2d4 <curve25519_test+0x2d4>)
 14e:	681b      	ldr	r3, [r3, #0]
        return WC_TEST_RET_ENC_EC(ret);
 150:	4264      	negs	r4, r4
        printf("wc_curve25519_shared_secret 2 failed\n");
 152:	6898      	ldr	r0, [r3, #8]
 154:	f7ff fffe 	bl	0 <fflush>
        return WC_TEST_RET_ENC_EC(ret);
 158:	f3c4 040a 	ubfx	r4, r4, #0, #11
 15c:	4959      	ldr	r1, [pc, #356]	; (2c4 <curve25519_test+0x2c4>)
 15e:	4860      	ldr	r0, [pc, #384]	; (2e0 <curve25519_test+0x2e0>)
 160:	e79c      	b.n	9c <curve25519_test+0x9c>
    if (y != x)
 162:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 166:	429a      	cmp	r2, r3
 168:	f040 82c1 	bne.w	6ee <curve25519_test+0x6ee>
    if (XMEMCMP(sharedA, sharedB, x))
 16c:	a910      	add	r1, sp, #64	; 0x40
 16e:	a808      	add	r0, sp, #32
 170:	f7ff fffe 	bl	0 <memcmp>
 174:	2800      	cmp	r0, #0
 176:	f040 82bc 	bne.w	6f2 <curve25519_test+0x6f2>
    ret = wc_curve25519_export_public(&userA, exportBuf, &x);
 17a:	aa04      	add	r2, sp, #16
 17c:	a918      	add	r1, sp, #96	; 0x60
 17e:	a867      	add	r0, sp, #412	; 0x19c
    x = sizeof(exportBuf);
 180:	9504      	str	r5, [sp, #16]
    ret = wc_curve25519_export_public(&userA, exportBuf, &x);
 182:	f7ff fffe 	bl	0 <wc_curve25519_export_public>
    if (ret != 0)
 186:	b128      	cbz	r0, 194 <curve25519_test+0x194>
        return WC_TEST_RET_ENC_EC(ret);
 188:	4240      	negs	r0, r0
 18a:	494e      	ldr	r1, [pc, #312]	; (2c4 <curve25519_test+0x2c4>)
 18c:	4c55      	ldr	r4, [pc, #340]	; (2e4 <curve25519_test+0x2e4>)
 18e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 192:	e7a4      	b.n	de <curve25519_test+0xde>
    ret = wc_curve25519_import_public(exportBuf, x, &pubKey);
 194:	9904      	ldr	r1, [sp, #16]
 196:	aa8d      	add	r2, sp, #564	; 0x234
 198:	a818      	add	r0, sp, #96	; 0x60
 19a:	f7ff fffe 	bl	0 <wc_curve25519_import_public>
    if (ret != 0)
 19e:	b128      	cbz	r0, 1ac <curve25519_test+0x1ac>
        return WC_TEST_RET_ENC_EC(ret);
 1a0:	4240      	negs	r0, r0
 1a2:	4948      	ldr	r1, [pc, #288]	; (2c4 <curve25519_test+0x2c4>)
 1a4:	4c50      	ldr	r4, [pc, #320]	; (2e8 <curve25519_test+0x2e8>)
 1a6:	f3c0 000a 	ubfx	r0, r0, #0, #11
 1aa:	e798      	b.n	de <curve25519_test+0xde>
    XMEMSET(sharedB, 0, sizeof(sharedB));
 1ac:	2220      	movs	r2, #32
 1ae:	2100      	movs	r1, #0
 1b0:	a810      	add	r0, sp, #64	; 0x40
 1b2:	f7ff fffe 	bl	0 <memset>
    y = sizeof(sharedB);
 1b6:	2520      	movs	r5, #32
    if (wc_curve25519_shared_secret(&userB, &pubKey, sharedB, &y) != 0) {
 1b8:	ab03      	add	r3, sp, #12
 1ba:	aa10      	add	r2, sp, #64	; 0x40
 1bc:	a98d      	add	r1, sp, #564	; 0x234
 1be:	4630      	mov	r0, r6
    y = sizeof(sharedB);
 1c0:	9503      	str	r5, [sp, #12]
    if (wc_curve25519_shared_secret(&userB, &pubKey, sharedB, &y) != 0) {
 1c2:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
 1c6:	2800      	cmp	r0, #0
 1c8:	f040 8295 	bne.w	6f6 <curve25519_test+0x6f6>
    if (XMEMCMP(sharedA, sharedB, y))
 1cc:	9a03      	ldr	r2, [sp, #12]
 1ce:	a910      	add	r1, sp, #64	; 0x40
 1d0:	eb0d 0005 	add.w	r0, sp, r5
 1d4:	f7ff fffe 	bl	0 <memcmp>
 1d8:	2800      	cmp	r0, #0
 1da:	f040 828e 	bne.w	6fa <curve25519_test+0x6fa>
    ret = wc_curve25519_import_private_raw(sa, sizeof(sa), pa, sizeof(pa),
 1de:	ab67      	add	r3, sp, #412	; 0x19c
 1e0:	9300      	str	r3, [sp, #0]
 1e2:	aa28      	add	r2, sp, #160	; 0xa0
 1e4:	462b      	mov	r3, r5
 1e6:	4629      	mov	r1, r5
 1e8:	a820      	add	r0, sp, #128	; 0x80
 1ea:	f7ff fffe 	bl	0 <wc_curve25519_import_private_raw>
    if (ret != 0)
 1ee:	b128      	cbz	r0, 1fc <curve25519_test+0x1fc>
        return WC_TEST_RET_ENC_EC(ret);
 1f0:	4240      	negs	r0, r0
 1f2:	4934      	ldr	r1, [pc, #208]	; (2c4 <curve25519_test+0x2c4>)
 1f4:	4c3d      	ldr	r4, [pc, #244]	; (2ec <curve25519_test+0x2ec>)
 1f6:	f3c0 000a 	ubfx	r0, r0, #0, #11
 1fa:	e770      	b.n	de <curve25519_test+0xde>
    ret = wc_curve25519_import_private_raw(sb, sizeof(sb), pb, sizeof(pb),
 1fc:	4629      	mov	r1, r5
 1fe:	9600      	str	r6, [sp, #0]
 200:	462b      	mov	r3, r5
 202:	aa38      	add	r2, sp, #224	; 0xe0
 204:	a830      	add	r0, sp, #192	; 0xc0
 206:	f7ff fffe 	bl	0 <wc_curve25519_import_private_raw>
    if (ret != 0)
 20a:	4601      	mov	r1, r0
 20c:	b128      	cbz	r0, 21a <curve25519_test+0x21a>
        return WC_TEST_RET_ENC_EC(ret);
 20e:	4241      	negs	r1, r0
 210:	4c2c      	ldr	r4, [pc, #176]	; (2c4 <curve25519_test+0x2c4>)
 212:	4837      	ldr	r0, [pc, #220]	; (2f0 <curve25519_test+0x2f0>)
 214:	f3c1 010a 	ubfx	r1, r1, #0, #11
 218:	e740      	b.n	9c <curve25519_test+0x9c>
    XMEMSET(sharedB, 0, sizeof(sharedB));
 21a:	462a      	mov	r2, r5
 21c:	a810      	add	r0, sp, #64	; 0x40
 21e:	f7ff fffe 	bl	0 <memset>
    ret = wc_curve25519_shared_secret(&userA, &userB, sharedB, &y);
 222:	ab03      	add	r3, sp, #12
 224:	aa10      	add	r2, sp, #64	; 0x40
 226:	4631      	mov	r1, r6
 228:	a867      	add	r0, sp, #412	; 0x19c
    y = sizeof(sharedB);
 22a:	9503      	str	r5, [sp, #12]
    ret = wc_curve25519_shared_secret(&userA, &userB, sharedB, &y);
 22c:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
    if (ret != 0)
 230:	b128      	cbz	r0, 23e <curve25519_test+0x23e>
        return WC_TEST_RET_ENC_EC(ret);
 232:	4240      	negs	r0, r0
 234:	4923      	ldr	r1, [pc, #140]	; (2c4 <curve25519_test+0x2c4>)
 236:	4c2f      	ldr	r4, [pc, #188]	; (2f4 <curve25519_test+0x2f4>)
 238:	f3c0 000a 	ubfx	r0, r0, #0, #11
 23c:	e74f      	b.n	de <curve25519_test+0xde>
    if (XMEMCMP(ss, sharedB, y))
 23e:	a910      	add	r1, sp, #64	; 0x40
 240:	9a03      	ldr	r2, [sp, #12]
 242:	a840      	add	r0, sp, #256	; 0x100
 244:	f7ff fffe 	bl	0 <memcmp>
 248:	4601      	mov	r1, r0
 24a:	2800      	cmp	r0, #0
 24c:	f040 8257 	bne.w	6fe <curve25519_test+0x6fe>
    XMEMSET(sharedB, 0, sizeof(sharedB));
 250:	462a      	mov	r2, r5
 252:	a810      	add	r0, sp, #64	; 0x40
 254:	f7ff fffe 	bl	0 <memset>
    ret = wc_curve25519_shared_secret(&userB, &userA, sharedB, &y);
 258:	ab03      	add	r3, sp, #12
 25a:	aa10      	add	r2, sp, #64	; 0x40
 25c:	a967      	add	r1, sp, #412	; 0x19c
 25e:	4630      	mov	r0, r6
    y = sizeof(sharedB);
 260:	9503      	str	r5, [sp, #12]
    ret = wc_curve25519_shared_secret(&userB, &userA, sharedB, &y);
 262:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
    if (ret != 0)
 266:	b148      	cbz	r0, 27c <curve25519_test+0x27c>
        return WC_TEST_RET_ENC_EC(ret);
 268:	4c16      	ldr	r4, [pc, #88]	; (2c4 <curve25519_test+0x2c4>)
 26a:	4240      	negs	r0, r0
 26c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 270:	4360      	muls	r0, r4
 272:	f100 4460 	add.w	r4, r0, #3758096384	; 0xe0000000
 276:	f5a4 44f0 	sub.w	r4, r4, #30720	; 0x7800
 27a:	e732      	b.n	e2 <curve25519_test+0xe2>
    if (XMEMCMP(ss, sharedB, y))
 27c:	9a03      	ldr	r2, [sp, #12]
 27e:	a910      	add	r1, sp, #64	; 0x40
 280:	a840      	add	r0, sp, #256	; 0x100
 282:	f7ff fffe 	bl	0 <memcmp>
 286:	2800      	cmp	r0, #0
 288:	f040 823b 	bne.w	702 <curve25519_test+0x702>
    ret = wc_curve25519_import_private_raw(sa, sizeof(sa), pa, sizeof(pa),
 28c:	ab67      	add	r3, sp, #412	; 0x19c
 28e:	9300      	str	r3, [sp, #0]
 290:	aa28      	add	r2, sp, #160	; 0xa0
 292:	462b      	mov	r3, r5
 294:	4629      	mov	r1, r5
 296:	a820      	add	r0, sp, #128	; 0x80
 298:	f7ff fffe 	bl	0 <wc_curve25519_import_private_raw>
    if (ret != 0)
 29c:	4604      	mov	r4, r0
 29e:	b368      	cbz	r0, 2fc <curve25519_test+0x2fc>
        return WC_TEST_RET_ENC_EC(ret);
 2a0:	4244      	negs	r4, r0
 2a2:	f3c4 010a 	ubfx	r1, r4, #0, #11
 2a6:	4814      	ldr	r0, [pc, #80]	; (2f8 <curve25519_test+0x2f8>)
 2a8:	4c06      	ldr	r4, [pc, #24]	; (2c4 <curve25519_test+0x2c4>)
 2aa:	e6f7      	b.n	9c <curve25519_test+0x9c>
 2ac:	0000004c 	.word	0x0000004c
 2b0:	0000006d 	.word	0x0000006d
 2b4:	0000008e 	.word	0x0000008e
 2b8:	000000af 	.word	0x000000af
 2bc:	000000d0 	.word	0x000000d0
 2c0:	dfff8859 	.word	0xdfff8859
 2c4:	fffe7960 	.word	0xfffe7960
 2c8:	dfff8850 	.word	0xdfff8850
 2cc:	dfff884c 	.word	0xdfff884c
	...
 2d8:	dfff8845 	.word	0xdfff8845
 2dc:	00000026 	.word	0x00000026
 2e0:	dfff883f 	.word	0xdfff883f
 2e4:	dfff882f 	.word	0xdfff882f
 2e8:	dfff882a 	.word	0xdfff882a
 2ec:	dfff8816 	.word	0xdfff8816
 2f0:	dfff8811 	.word	0xdfff8811
 2f4:	dfff880a 	.word	0xdfff880a
 2f8:	dfff87f7 	.word	0xdfff87f7
    wc_curve25519_free(&userB);
 2fc:	4630      	mov	r0, r6
 2fe:	f7ff fffe 	bl	0 <wc_curve25519_free>
    wc_curve25519_init_ex(&userB, HEAP_HINT, devId);
 302:	f06f 0201 	mvn.w	r2, #1
 306:	4621      	mov	r1, r4
 308:	4630      	mov	r0, r6
 30a:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
    ret = wc_curve25519_make_key(&rng, 32, &userB);
 30e:	4632      	mov	r2, r6
 310:	4629      	mov	r1, r5
 312:	a806      	add	r0, sp, #24
 314:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret != 0)
 318:	b128      	cbz	r0, 326 <curve25519_test+0x326>
        return WC_TEST_RET_ENC_EC(ret);
 31a:	4240      	negs	r0, r0
 31c:	49aa      	ldr	r1, [pc, #680]	; (5c8 <curve25519_test+0x5c8>)
 31e:	4cab      	ldr	r4, [pc, #684]	; (5cc <curve25519_test+0x5cc>)
 320:	f3c0 000a 	ubfx	r0, r0, #0, #11
 324:	e6db      	b.n	de <curve25519_test+0xde>
    x = sizeof(sharedA);
 326:	2420      	movs	r4, #32
    ret = wc_curve25519_shared_secret(&userA, &userB, sharedA, &x);
 328:	ab04      	add	r3, sp, #16
 32a:	eb0d 0204 	add.w	r2, sp, r4
 32e:	a97a      	add	r1, sp, #488	; 0x1e8
 330:	a867      	add	r0, sp, #412	; 0x19c
    x = sizeof(sharedA);
 332:	9404      	str	r4, [sp, #16]
    ret = wc_curve25519_shared_secret(&userA, &userB, sharedA, &x);
 334:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
    if (ret != 0)
 338:	b128      	cbz	r0, 346 <curve25519_test+0x346>
        return WC_TEST_RET_ENC_EC(ret);
 33a:	4240      	negs	r0, r0
 33c:	49a2      	ldr	r1, [pc, #648]	; (5c8 <curve25519_test+0x5c8>)
 33e:	4ca4      	ldr	r4, [pc, #656]	; (5d0 <curve25519_test+0x5d0>)
 340:	f3c0 000a 	ubfx	r0, r0, #0, #11
 344:	e6cb      	b.n	de <curve25519_test+0xde>
    ret = wc_curve25519_shared_secret(&userB, &userA, sharedB, &y);
 346:	ab03      	add	r3, sp, #12
 348:	aa10      	add	r2, sp, #64	; 0x40
 34a:	a967      	add	r1, sp, #412	; 0x19c
 34c:	a87a      	add	r0, sp, #488	; 0x1e8
    y = sizeof(sharedB);
 34e:	9403      	str	r4, [sp, #12]
    ret = wc_curve25519_shared_secret(&userB, &userA, sharedB, &y);
 350:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
    if (ret != 0)
 354:	b128      	cbz	r0, 362 <curve25519_test+0x362>
        return WC_TEST_RET_ENC_EC(ret);
 356:	4240      	negs	r0, r0
 358:	499b      	ldr	r1, [pc, #620]	; (5c8 <curve25519_test+0x5c8>)
 35a:	4c9e      	ldr	r4, [pc, #632]	; (5d4 <curve25519_test+0x5d4>)
 35c:	f3c0 000a 	ubfx	r0, r0, #0, #11
 360:	e6bd      	b.n	de <curve25519_test+0xde>
    if (y != x)
 362:	e9dd 2303 	ldrd	r2, r3, [sp, #12]
 366:	429a      	cmp	r2, r3
 368:	f040 81cd 	bne.w	706 <curve25519_test+0x706>
    if (XMEMCMP(sharedA, sharedB, x))
 36c:	a910      	add	r1, sp, #64	; 0x40
 36e:	a808      	add	r0, sp, #32
 370:	f7ff fffe 	bl	0 <memcmp>
 374:	2800      	cmp	r0, #0
 376:	f040 81c8 	bne.w	70a <curve25519_test+0x70a>
    byte sa[X25519_TEST_CNT][32] = {
 37a:	4b97      	ldr	r3, [pc, #604]	; (5d8 <curve25519_test+0x5d8>)
 37c:	ac48      	add	r4, sp, #288	; 0x120
 37e:	f103 0520 	add.w	r5, r3, #32
 382:	6818      	ldr	r0, [r3, #0]
 384:	6859      	ldr	r1, [r3, #4]
 386:	4622      	mov	r2, r4
 388:	c203      	stmia	r2!, {r0, r1}
 38a:	3308      	adds	r3, #8
 38c:	42ab      	cmp	r3, r5
 38e:	4614      	mov	r4, r2
 390:	d1f7      	bne.n	382 <curve25519_test+0x382>
    byte pb[X25519_TEST_CNT][32] = {
 392:	4b92      	ldr	r3, [pc, #584]	; (5dc <curve25519_test+0x5dc>)
 394:	ac50      	add	r4, sp, #320	; 0x140
 396:	f103 0520 	add.w	r5, r3, #32
 39a:	6818      	ldr	r0, [r3, #0]
 39c:	6859      	ldr	r1, [r3, #4]
 39e:	4622      	mov	r2, r4
 3a0:	c203      	stmia	r2!, {r0, r1}
 3a2:	3308      	adds	r3, #8
 3a4:	42ab      	cmp	r3, r5
 3a6:	4614      	mov	r4, r2
 3a8:	d1f7      	bne.n	39a <curve25519_test+0x39a>
    byte ss[X25519_TEST_CNT][32] = {
 3aa:	4b8d      	ldr	r3, [pc, #564]	; (5e0 <curve25519_test+0x5e0>)
 3ac:	ac5b      	add	r4, sp, #364	; 0x16c
 3ae:	f103 0520 	add.w	r5, r3, #32
 3b2:	6818      	ldr	r0, [r3, #0]
 3b4:	6859      	ldr	r1, [r3, #4]
 3b6:	4622      	mov	r2, r4
 3b8:	c203      	stmia	r2!, {r0, r1}
 3ba:	3308      	adds	r3, #8
 3bc:	42ab      	cmp	r3, r5
 3be:	4614      	mov	r4, r2
 3c0:	d1f7      	bne.n	3b2 <curve25519_test+0x3b2>
    wc_curve25519_init_ex(&userA, HEAP_HINT, devId);
 3c2:	adb8      	add	r5, sp, #736	; 0x2e0
 3c4:	f06f 0201 	mvn.w	r2, #1
 3c8:	2100      	movs	r1, #0
 3ca:	4628      	mov	r0, r5
 3cc:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
        if (wc_curve25519_import_private_raw(sa[i], sizeof(sa[i]), pb[i],
 3d0:	2320      	movs	r3, #32
 3d2:	4619      	mov	r1, r3
 3d4:	9500      	str	r5, [sp, #0]
 3d6:	aa50      	add	r2, sp, #320	; 0x140
 3d8:	a848      	add	r0, sp, #288	; 0x120
 3da:	f7ff fffe 	bl	0 <wc_curve25519_import_private_raw>
 3de:	4601      	mov	r1, r0
 3e0:	2800      	cmp	r0, #0
 3e2:	d140      	bne.n	466 <curve25519_test+0x466>
        XMEMSET(shared, 0, sizeof(shared));
 3e4:	2220      	movs	r2, #32
 3e6:	a8a0      	add	r0, sp, #640	; 0x280
 3e8:	f7ff fffe 	bl	0 <memset>
        y = sizeof(shared);
 3ec:	2320      	movs	r3, #32
 3ee:	9305      	str	r3, [sp, #20]
        if (wc_curve25519_shared_secret(&userA, &userA, shared, &y) != 0) {
 3f0:	aaa0      	add	r2, sp, #640	; 0x280
 3f2:	ab05      	add	r3, sp, #20
 3f4:	4629      	mov	r1, r5
 3f6:	4628      	mov	r0, r5
 3f8:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
 3fc:	2800      	cmp	r0, #0
 3fe:	d134      	bne.n	46a <curve25519_test+0x46a>
        if (XMEMCMP(ss[i], shared, y)) {
 400:	9a05      	ldr	r2, [sp, #20]
 402:	a9a0      	add	r1, sp, #640	; 0x280
 404:	a85b      	add	r0, sp, #364	; 0x16c
 406:	f7ff fffe 	bl	0 <memcmp>
            ret = WC_TEST_RET_ENC_I(i); break;
 40a:	4b76      	ldr	r3, [pc, #472]	; (5e4 <curve25519_test+0x5e4>)
 40c:	1e04      	subs	r4, r0, #0
 40e:	bf18      	it	ne
 410:	461c      	movne	r4, r3
    wc_curve25519_free(&userA);
 412:	4628      	mov	r0, r5
 414:	f7ff fffe 	bl	0 <wc_curve25519_free>
    if (ret != 0)
 418:	2c00      	cmp	r4, #0
 41a:	f47f ae62 	bne.w	e2 <curve25519_test+0xe2>
    byte fail_le[][CURVE25519_KEYSIZE] = {
 41e:	4972      	ldr	r1, [pc, #456]	; (5e8 <curve25519_test+0x5e8>)
 420:	2260      	movs	r2, #96	; 0x60
 422:	a8a0      	add	r0, sp, #640	; 0x280
 424:	f7ff fffe 	bl	0 <memcpy>
    byte fail_be[][CURVE25519_KEYSIZE] = {
 428:	4970      	ldr	r1, [pc, #448]	; (5ec <curve25519_test+0x5ec>)
 42a:	2260      	movs	r2, #96	; 0x60
 42c:	4628      	mov	r0, r5
 42e:	f7ff fffe 	bl	0 <memcpy>
    byte good[CURVE25519_KEYSIZE] = {
 432:	4b6f      	ldr	r3, [pc, #444]	; (5f0 <curve25519_test+0x5f0>)
 434:	ae5b      	add	r6, sp, #364	; 0x16c
 436:	f103 0720 	add.w	r7, r3, #32
 43a:	6818      	ldr	r0, [r3, #0]
 43c:	6859      	ldr	r1, [r3, #4]
 43e:	4632      	mov	r2, r6
 440:	c203      	stmia	r2!, {r0, r1}
 442:	3308      	adds	r3, #8
 444:	42bb      	cmp	r3, r7
 446:	4616      	mov	r6, r2
 448:	d1f7      	bne.n	43a <curve25519_test+0x43a>
    ret = wc_curve25519_check_public(NULL, 0, EC25519_LITTLE_ENDIAN);
 44a:	2200      	movs	r2, #0
 44c:	4611      	mov	r1, r2
 44e:	4610      	mov	r0, r2
 450:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
    if (ret != BAD_FUNC_ARG) {
 454:	f110 0fad 	cmn.w	r0, #173	; 0xad
 458:	d009      	beq.n	46e <curve25519_test+0x46e>
        return WC_TEST_RET_ENC_EC(ret);
 45a:	4240      	negs	r0, r0
 45c:	495a      	ldr	r1, [pc, #360]	; (5c8 <curve25519_test+0x5c8>)
 45e:	4c65      	ldr	r4, [pc, #404]	; (5f4 <curve25519_test+0x5f4>)
 460:	f3c0 000a 	ubfx	r0, r0, #0, #11
 464:	e63b      	b.n	de <curve25519_test+0xde>
            ret = WC_TEST_RET_ENC_I(i); break;
 466:	4c64      	ldr	r4, [pc, #400]	; (5f8 <curve25519_test+0x5f8>)
 468:	e7d3      	b.n	412 <curve25519_test+0x412>
            ret = WC_TEST_RET_ENC_I(i); break;
 46a:	4c64      	ldr	r4, [pc, #400]	; (5fc <curve25519_test+0x5fc>)
 46c:	e7d1      	b.n	412 <curve25519_test+0x412>
    ret = wc_curve25519_check_public(NULL, 0, EC25519_BIG_ENDIAN);
 46e:	2100      	movs	r1, #0
 470:	2201      	movs	r2, #1
 472:	4608      	mov	r0, r1
 474:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
    if (ret != BAD_FUNC_ARG) {
 478:	f110 0fad 	cmn.w	r0, #173	; 0xad
 47c:	d005      	beq.n	48a <curve25519_test+0x48a>
        return WC_TEST_RET_ENC_EC(ret);
 47e:	4240      	negs	r0, r0
 480:	4951      	ldr	r1, [pc, #324]	; (5c8 <curve25519_test+0x5c8>)
 482:	4c5f      	ldr	r4, [pc, #380]	; (600 <curve25519_test+0x600>)
 484:	f3c0 000a 	ubfx	r0, r0, #0, #11
 488:	e629      	b.n	de <curve25519_test+0xde>
    ret = wc_curve25519_check_public(good, 0, EC25519_LITTLE_ENDIAN);
 48a:	2200      	movs	r2, #0
 48c:	4611      	mov	r1, r2
 48e:	a85b      	add	r0, sp, #364	; 0x16c
 490:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
    if (ret != BUFFER_E)
 494:	f110 0f84 	cmn.w	r0, #132	; 0x84
 498:	d005      	beq.n	4a6 <curve25519_test+0x4a6>
        return WC_TEST_RET_ENC_EC(ret);
 49a:	4240      	negs	r0, r0
 49c:	494a      	ldr	r1, [pc, #296]	; (5c8 <curve25519_test+0x5c8>)
 49e:	4c59      	ldr	r4, [pc, #356]	; (604 <curve25519_test+0x604>)
 4a0:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4a4:	e61b      	b.n	de <curve25519_test+0xde>
    ret = wc_curve25519_check_public(good, 0, EC25519_BIG_ENDIAN);
 4a6:	2201      	movs	r2, #1
 4a8:	2100      	movs	r1, #0
 4aa:	a85b      	add	r0, sp, #364	; 0x16c
 4ac:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
    if (ret != BUFFER_E)
 4b0:	f110 0f84 	cmn.w	r0, #132	; 0x84
 4b4:	d005      	beq.n	4c2 <curve25519_test+0x4c2>
        return WC_TEST_RET_ENC_EC(ret);
 4b6:	4240      	negs	r0, r0
 4b8:	4943      	ldr	r1, [pc, #268]	; (5c8 <curve25519_test+0x5c8>)
 4ba:	4c53      	ldr	r4, [pc, #332]	; (608 <curve25519_test+0x608>)
 4bc:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4c0:	e60d      	b.n	de <curve25519_test+0xde>
    for (i = 1; i < CURVE25519_KEYSIZE + 2; i++) {
 4c2:	2601      	movs	r6, #1
        if (i == CURVE25519_KEYSIZE)
 4c4:	2e20      	cmp	r6, #32
 4c6:	d015      	beq.n	4f4 <curve25519_test+0x4f4>
        if (wc_curve25519_check_public(good, i, EC25519_LITTLE_ENDIAN) !=
 4c8:	2200      	movs	r2, #0
 4ca:	4631      	mov	r1, r6
 4cc:	a85b      	add	r0, sp, #364	; 0x16c
 4ce:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
 4d2:	30aa      	adds	r0, #170	; 0xaa
 4d4:	d004      	beq.n	4e0 <curve25519_test+0x4e0>
            return WC_TEST_RET_ENC_I(i);
 4d6:	4c3c      	ldr	r4, [pc, #240]	; (5c8 <curve25519_test+0x5c8>)
 4d8:	484c      	ldr	r0, [pc, #304]	; (60c <curve25519_test+0x60c>)
            return WC_TEST_RET_ENC_I(i);
 4da:	fb04 0406 	mla	r4, r4, r6, r0
 4de:	e600      	b.n	e2 <curve25519_test+0xe2>
        if (wc_curve25519_check_public(good, i, EC25519_BIG_ENDIAN) !=
 4e0:	2201      	movs	r2, #1
 4e2:	4631      	mov	r1, r6
 4e4:	a85b      	add	r0, sp, #364	; 0x16c
 4e6:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
 4ea:	30aa      	adds	r0, #170	; 0xaa
 4ec:	d002      	beq.n	4f4 <curve25519_test+0x4f4>
            return WC_TEST_RET_ENC_I(i);
 4ee:	4c36      	ldr	r4, [pc, #216]	; (5c8 <curve25519_test+0x5c8>)
 4f0:	4847      	ldr	r0, [pc, #284]	; (610 <curve25519_test+0x610>)
 4f2:	e7f2      	b.n	4da <curve25519_test+0x4da>
    for (i = 1; i < CURVE25519_KEYSIZE + 2; i++) {
 4f4:	3601      	adds	r6, #1
 4f6:	2e22      	cmp	r6, #34	; 0x22
 4f8:	d1e4      	bne.n	4c4 <curve25519_test+0x4c4>
 4fa:	afa0      	add	r7, sp, #640	; 0x280
    for (i = 0; i < (int)(sizeof(fail_le) / sizeof(*fail_le)); i++) {
 4fc:	2600      	movs	r6, #0
        if (wc_curve25519_check_public(fail_le[i], CURVE25519_KEYSIZE,
 4fe:	2200      	movs	r2, #0
 500:	2120      	movs	r1, #32
 502:	4638      	mov	r0, r7
 504:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
 508:	b910      	cbnz	r0, 510 <curve25519_test+0x510>
            return WC_TEST_RET_ENC_I(i);
 50a:	4c2f      	ldr	r4, [pc, #188]	; (5c8 <curve25519_test+0x5c8>)
 50c:	4841      	ldr	r0, [pc, #260]	; (614 <curve25519_test+0x614>)
 50e:	e7e4      	b.n	4da <curve25519_test+0x4da>
    for (i = 0; i < (int)(sizeof(fail_le) / sizeof(*fail_le)); i++) {
 510:	3601      	adds	r6, #1
 512:	2e03      	cmp	r6, #3
 514:	f107 0720 	add.w	r7, r7, #32
 518:	d1f1      	bne.n	4fe <curve25519_test+0x4fe>
 51a:	462e      	mov	r6, r5
        if (wc_curve25519_check_public(fail_be[i], CURVE25519_KEYSIZE,
 51c:	2201      	movs	r2, #1
 51e:	2120      	movs	r1, #32
 520:	4630      	mov	r0, r6
 522:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
 526:	b920      	cbnz	r0, 532 <curve25519_test+0x532>
            return WC_TEST_RET_ENC_I(i);
 528:	4a27      	ldr	r2, [pc, #156]	; (5c8 <curve25519_test+0x5c8>)
 52a:	4b3b      	ldr	r3, [pc, #236]	; (618 <curve25519_test+0x618>)
 52c:	fb02 3404 	mla	r4, r2, r4, r3
 530:	e5d7      	b.n	e2 <curve25519_test+0xe2>
    for (i = 0; i < (int)(sizeof(fail_be) / sizeof(*fail_be)); i++) {
 532:	3401      	adds	r4, #1
 534:	2c03      	cmp	r4, #3
 536:	f106 0620 	add.w	r6, r6, #32
 53a:	d1ef      	bne.n	51c <curve25519_test+0x51c>
    ret = wc_curve25519_check_public(good, CURVE25519_KEYSIZE,
 53c:	2200      	movs	r2, #0
 53e:	2120      	movs	r1, #32
 540:	a85b      	add	r0, sp, #364	; 0x16c
 542:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
    if (ret != 0) {
 546:	b128      	cbz	r0, 554 <curve25519_test+0x554>
        return WC_TEST_RET_ENC_EC(ret);
 548:	4240      	negs	r0, r0
 54a:	491f      	ldr	r1, [pc, #124]	; (5c8 <curve25519_test+0x5c8>)
 54c:	4c33      	ldr	r4, [pc, #204]	; (61c <curve25519_test+0x61c>)
 54e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 552:	e5c4      	b.n	de <curve25519_test+0xde>
    ret = wc_curve25519_check_public(good, CURVE25519_KEYSIZE,
 554:	2201      	movs	r2, #1
 556:	2120      	movs	r1, #32
 558:	a85b      	add	r0, sp, #364	; 0x16c
 55a:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
    if (ret != 0) {
 55e:	2800      	cmp	r0, #0
 560:	d164      	bne.n	62c <curve25519_test+0x62c>
    const byte kCurve25519PrivDer[] = {
 562:	4b2f      	ldr	r3, [pc, #188]	; (620 <curve25519_test+0x620>)
 564:	ac5b      	add	r4, sp, #364	; 0x16c
 566:	f103 0630 	add.w	r6, r3, #48	; 0x30
 56a:	6818      	ldr	r0, [r3, #0]
 56c:	6859      	ldr	r1, [r3, #4]
 56e:	4622      	mov	r2, r4
 570:	c203      	stmia	r2!, {r0, r1}
 572:	3308      	adds	r3, #8
 574:	42b3      	cmp	r3, r6
 576:	4614      	mov	r4, r2
 578:	d1f7      	bne.n	56a <curve25519_test+0x56a>
    const byte kCurve25519PubDer[] = {
 57a:	4a2a      	ldr	r2, [pc, #168]	; (624 <curve25519_test+0x624>)
 57c:	ab50      	add	r3, sp, #320	; 0x140
 57e:	f102 0628 	add.w	r6, r2, #40	; 0x28
 582:	6810      	ldr	r0, [r2, #0]
 584:	6851      	ldr	r1, [r2, #4]
 586:	461c      	mov	r4, r3
 588:	c403      	stmia	r4!, {r0, r1}
 58a:	3208      	adds	r2, #8
 58c:	42b2      	cmp	r2, r6
 58e:	4623      	mov	r3, r4
 590:	d1f7      	bne.n	582 <curve25519_test+0x582>
 592:	6810      	ldr	r0, [r2, #0]
 594:	6020      	str	r0, [r4, #0]
    ret = wc_curve25519_init_ex(&key, HEAP_HINT, devId);
 596:	f06f 0201 	mvn.w	r2, #1
 59a:	2100      	movs	r1, #0
 59c:	a8a0      	add	r0, sp, #640	; 0x280
 59e:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
    if (ret != 0)
 5a2:	2800      	cmp	r0, #0
 5a4:	d148      	bne.n	638 <curve25519_test+0x638>
        idx = 0;
 5a6:	9048      	str	r0, [sp, #288]	; 0x120
        ret = wc_Curve25519PrivateKeyDecode(kCurve25519PrivDer, &idx, &key,
 5a8:	2330      	movs	r3, #48	; 0x30
 5aa:	aaa0      	add	r2, sp, #640	; 0x280
 5ac:	a948      	add	r1, sp, #288	; 0x120
 5ae:	a85b      	add	r0, sp, #364	; 0x16c
 5b0:	f7ff fffe 	bl	0 <wc_Curve25519PrivateKeyDecode>
        if (ret < 0)
 5b4:	1e04      	subs	r4, r0, #0
 5b6:	da45      	bge.n	644 <curve25519_test+0x644>
            ret = WC_TEST_RET_ENC_EC(ret);
 5b8:	4260      	negs	r0, r4
 5ba:	4903      	ldr	r1, [pc, #12]	; (5c8 <curve25519_test+0x5c8>)
 5bc:	4c1a      	ldr	r4, [pc, #104]	; (628 <curve25519_test+0x628>)
 5be:	f3c0 000a 	ubfx	r0, r0, #0, #11
            ret = WC_TEST_RET_ENC_EC(ret);
 5c2:	fb01 4400 	mla	r4, r1, r0, r4
 5c6:	e048      	b.n	65a <curve25519_test+0x65a>
 5c8:	fffe7960 	.word	0xfffe7960
 5cc:	dfff87f0 	.word	0xdfff87f0
 5d0:	dfff87eb 	.word	0xdfff87eb
 5d4:	dfff87e6 	.word	0xdfff87e6
 5d8:	0000018d 	.word	0x0000018d
 5dc:	000001ad 	.word	0x000001ad
 5e0:	000001cd 	.word	0x000001cd
 5e4:	9fff8974 	.word	0x9fff8974
 5e8:	000001ed 	.word	0x000001ed
 5ec:	0000024d 	.word	0x0000024d
 5f0:	000002ad 	.word	0x000002ad
 5f4:	dfff892d 	.word	0xdfff892d
 5f8:	9fff897f 	.word	0x9fff897f
 5fc:	9fff8978 	.word	0x9fff8978
 600:	dfff8929 	.word	0xdfff8929
 604:	dfff8924 	.word	0xdfff8924
 608:	dfff8921 	.word	0xdfff8921
 60c:	9fff8919 	.word	0x9fff8919
 610:	9fff8915 	.word	0x9fff8915
 614:	9fff890d 	.word	0x9fff890d
 618:	9fff8906 	.word	0x9fff8906
 61c:	dfff88fe 	.word	0xdfff88fe
 620:	000002cd 	.word	0x000002cd
 624:	000002fd 	.word	0x000002fd
 628:	dfff88cf 	.word	0xdfff88cf
        return WC_TEST_RET_ENC_EC(ret);
 62c:	4240      	negs	r0, r0
 62e:	4938      	ldr	r1, [pc, #224]	; (710 <curve25519_test+0x710>)
 630:	4c38      	ldr	r4, [pc, #224]	; (714 <curve25519_test+0x714>)
 632:	f3c0 000a 	ubfx	r0, r0, #0, #11
 636:	e552      	b.n	de <curve25519_test+0xde>
        return WC_TEST_RET_ENC_EC(ret);
 638:	4240      	negs	r0, r0
 63a:	4935      	ldr	r1, [pc, #212]	; (710 <curve25519_test+0x710>)
 63c:	4c36      	ldr	r4, [pc, #216]	; (718 <curve25519_test+0x718>)
 63e:	f3c0 000a 	ubfx	r0, r0, #0, #11
 642:	e54c      	b.n	de <curve25519_test+0xde>
    if (ret == 0) {
 644:	d109      	bne.n	65a <curve25519_test+0x65a>
        ret = wc_Curve25519PrivateKeyToDer(&key, output, outputSz);
 646:	2280      	movs	r2, #128	; 0x80
 648:	4629      	mov	r1, r5
 64a:	a8a0      	add	r0, sp, #640	; 0x280
 64c:	f7ff fffe 	bl	0 <wc_Curve25519PrivateKeyToDer>
        if (ret >= 0) {
 650:	1e02      	subs	r2, r0, #0
 652:	db15      	blt.n	680 <curve25519_test+0x680>
    if (ret == 0 && (outputSz != (word32)sizeof(kCurve25519PrivDer) ||
 654:	2a30      	cmp	r2, #48	; 0x30
 656:	d01b      	beq.n	690 <curve25519_test+0x690>
        ret = WC_TEST_RET_ENC_NC;
 658:	4c30      	ldr	r4, [pc, #192]	; (71c <curve25519_test+0x71c>)
    wc_curve25519_free(&key);
 65a:	a8a0      	add	r0, sp, #640	; 0x280
 65c:	f7ff fffe 	bl	0 <wc_curve25519_free>
    if (ret != 0)
 660:	2c00      	cmp	r4, #0
 662:	f47f ad3e 	bne.w	e2 <curve25519_test+0xe2>
    wc_curve25519_free(&pubKey);
 666:	a88d      	add	r0, sp, #564	; 0x234
 668:	f7ff fffe 	bl	0 <wc_curve25519_free>
    wc_curve25519_free(&userB);
 66c:	a87a      	add	r0, sp, #488	; 0x1e8
 66e:	f7ff fffe 	bl	0 <wc_curve25519_free>
    wc_curve25519_free(&userA);
 672:	a867      	add	r0, sp, #412	; 0x19c
 674:	f7ff fffe 	bl	0 <wc_curve25519_free>
    wc_FreeRng(&rng);
 678:	a806      	add	r0, sp, #24
 67a:	f7ff fffe 	bl	0 <wc_FreeRng>
    return 0;
 67e:	e530      	b.n	e2 <curve25519_test+0xe2>
            ret = WC_TEST_RET_ENC_EC(ret);
 680:	4252      	negs	r2, r2
 682:	4c23      	ldr	r4, [pc, #140]	; (710 <curve25519_test+0x710>)
 684:	4826      	ldr	r0, [pc, #152]	; (720 <curve25519_test+0x720>)
 686:	f3c2 020a 	ubfx	r2, r2, #0, #11
            ret = WC_TEST_RET_ENC_EC(ret);
 68a:	fb04 0402 	mla	r4, r4, r2, r0
 68e:	e7e4      	b.n	65a <curve25519_test+0x65a>
                     XMEMCMP(output, kCurve25519PrivDer, outputSz) != 0)) {
 690:	a95b      	add	r1, sp, #364	; 0x16c
 692:	4628      	mov	r0, r5
 694:	f7ff fffe 	bl	0 <memcmp>
    if (ret == 0 && (outputSz != (word32)sizeof(kCurve25519PrivDer) ||
 698:	2800      	cmp	r0, #0
 69a:	d1dd      	bne.n	658 <curve25519_test+0x658>
        idx = 0;
 69c:	9048      	str	r0, [sp, #288]	; 0x120
        ret = wc_Curve25519PublicKeyDecode(kCurve25519PubDer, &idx, &key,
 69e:	232c      	movs	r3, #44	; 0x2c
 6a0:	aaa0      	add	r2, sp, #640	; 0x280
 6a2:	a948      	add	r1, sp, #288	; 0x120
 6a4:	a850      	add	r0, sp, #320	; 0x140
 6a6:	f7ff fffe 	bl	0 <wc_Curve25519PublicKeyDecode>
        if (ret < 0)
 6aa:	1e04      	subs	r4, r0, #0
 6ac:	da05      	bge.n	6ba <curve25519_test+0x6ba>
            ret = WC_TEST_RET_ENC_EC(ret);
 6ae:	4260      	negs	r0, r4
 6b0:	4917      	ldr	r1, [pc, #92]	; (710 <curve25519_test+0x710>)
 6b2:	4c1c      	ldr	r4, [pc, #112]	; (724 <curve25519_test+0x724>)
 6b4:	f3c0 000a 	ubfx	r0, r0, #0, #11
 6b8:	e783      	b.n	5c2 <curve25519_test+0x5c2>
    if (ret == 0) {
 6ba:	d1ce      	bne.n	65a <curve25519_test+0x65a>
        ret = wc_Curve25519PublicKeyToDer(&key, output, outputSz, 1);
 6bc:	2280      	movs	r2, #128	; 0x80
 6be:	2301      	movs	r3, #1
 6c0:	4629      	mov	r1, r5
 6c2:	a8a0      	add	r0, sp, #640	; 0x280
 6c4:	f7ff fffe 	bl	0 <wc_Curve25519PublicKeyToDer>
        if (ret >= 0) {
 6c8:	1e02      	subs	r2, r0, #0
 6ca:	db0a      	blt.n	6e2 <curve25519_test+0x6e2>
    if (ret == 0 && (outputSz != (word32)sizeof(kCurve25519PubDer) ||
 6cc:	2a2c      	cmp	r2, #44	; 0x2c
 6ce:	d106      	bne.n	6de <curve25519_test+0x6de>
                     XMEMCMP(output, kCurve25519PubDer, outputSz) != 0)) {
 6d0:	a950      	add	r1, sp, #320	; 0x140
 6d2:	a8b8      	add	r0, sp, #736	; 0x2e0
 6d4:	f7ff fffe 	bl	0 <memcmp>
    if (ret == 0 && (outputSz != (word32)sizeof(kCurve25519PubDer) ||
 6d8:	4604      	mov	r4, r0
 6da:	2800      	cmp	r0, #0
 6dc:	d0bd      	beq.n	65a <curve25519_test+0x65a>
        ret = WC_TEST_RET_ENC_NC;
 6de:	4c12      	ldr	r4, [pc, #72]	; (728 <curve25519_test+0x728>)
 6e0:	e7bb      	b.n	65a <curve25519_test+0x65a>
            ret = WC_TEST_RET_ENC_EC(ret);
 6e2:	4252      	negs	r2, r2
 6e4:	4c0a      	ldr	r4, [pc, #40]	; (710 <curve25519_test+0x710>)
 6e6:	4811      	ldr	r0, [pc, #68]	; (72c <curve25519_test+0x72c>)
 6e8:	f3c2 020a 	ubfx	r2, r2, #0, #11
 6ec:	e7cd      	b.n	68a <curve25519_test+0x68a>
        return WC_TEST_RET_ENC_NC;
 6ee:	4c10      	ldr	r4, [pc, #64]	; (730 <curve25519_test+0x730>)
 6f0:	e4f7      	b.n	e2 <curve25519_test+0xe2>
        return WC_TEST_RET_ENC_NC;
 6f2:	4c10      	ldr	r4, [pc, #64]	; (734 <curve25519_test+0x734>)
 6f4:	e4f5      	b.n	e2 <curve25519_test+0xe2>
        return WC_TEST_RET_ENC_NC;
 6f6:	4c10      	ldr	r4, [pc, #64]	; (738 <curve25519_test+0x738>)
 6f8:	e4f3      	b.n	e2 <curve25519_test+0xe2>
        return WC_TEST_RET_ENC_NC;
 6fa:	4c10      	ldr	r4, [pc, #64]	; (73c <curve25519_test+0x73c>)
 6fc:	e4f1      	b.n	e2 <curve25519_test+0xe2>
        return WC_TEST_RET_ENC_NC;
 6fe:	4c10      	ldr	r4, [pc, #64]	; (740 <curve25519_test+0x740>)
 700:	e4ef      	b.n	e2 <curve25519_test+0xe2>
        return WC_TEST_RET_ENC_NC;
 702:	4c10      	ldr	r4, [pc, #64]	; (744 <curve25519_test+0x744>)
 704:	e4ed      	b.n	e2 <curve25519_test+0xe2>
        return WC_TEST_RET_ENC_NC;
 706:	4c10      	ldr	r4, [pc, #64]	; (748 <curve25519_test+0x748>)
 708:	e4eb      	b.n	e2 <curve25519_test+0xe2>
        return WC_TEST_RET_ENC_NC;
 70a:	4c10      	ldr	r4, [pc, #64]	; (74c <curve25519_test+0x74c>)
 70c:	e4e9      	b.n	e2 <curve25519_test+0xe2>
 70e:	bf00      	nop
 710:	fffe7960 	.word	0xfffe7960
 714:	dfff88f9 	.word	0xdfff88f9
 718:	dfff88d7 	.word	0xdfff88d7
 71c:	ffff88c0 	.word	0xffff88c0
 720:	dfff88c5 	.word	0xdfff88c5
 724:	dfff88b7 	.word	0xdfff88b7
 728:	ffff88a8 	.word	0xffff88a8
 72c:	dfff88ad 	.word	0xdfff88ad
 730:	ffff883a 	.word	0xffff883a
 734:	ffff8837 	.word	0xffff8837
 738:	ffff8820 	.word	0xffff8820
 73c:	ffff881c 	.word	0xffff881c
 740:	ffff8807 	.word	0xffff8807
 744:	ffff87fd 	.word	0xffff87fd
 748:	ffff87e2 	.word	0xffff87e2
 74c:	ffff87df 	.word	0xffff87df

Disassembly of section .text.ed25519_test:

00000000 <ed25519_test>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f5ad 7d2b 	sub.w	sp, sp, #684	; 0x2ac
    ret = wc_InitRng_ex(&rng, HEAP_HINT, devId);
   8:	f06f 0201 	mvn.w	r2, #1
   c:	2100      	movs	r1, #0
   e:	a810      	add	r0, sp, #64	; 0x40
  10:	f7ff fffe 	bl	0 <wc_InitRng_ex>
    if (ret != 0)
  14:	4604      	mov	r4, r0
  16:	b138      	cbz	r0, 28 <ed25519_test+0x28>
        return WC_TEST_RET_ENC_EC(ret);
  18:	4240      	negs	r0, r0
  1a:	4987      	ldr	r1, [pc, #540]	; (238 <ed25519_test+0x238>)
  1c:	4c87      	ldr	r4, [pc, #540]	; (23c <ed25519_test+0x23c>)
  1e:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  22:	fb01 4400 	mla	r4, r1, r0, r4
    if (ret != 0)
  26:	e04c      	b.n	c2 <ed25519_test+0xc2>
    wc_ed25519_init_ex(&key, HEAP_HINT, devId);
  28:	4601      	mov	r1, r0
  2a:	f06f 0201 	mvn.w	r2, #1
  2e:	a842      	add	r0, sp, #264	; 0x108
  30:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
    wc_ed25519_init_ex(&key2, HEAP_HINT, devId);
  34:	f06f 0201 	mvn.w	r2, #1
  38:	4621      	mov	r1, r4
  3a:	a85c      	add	r0, sp, #368	; 0x170
  3c:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
    wc_ed25519_init_ex(&key3, HEAP_HINT, devId);
  40:	f06f 0201 	mvn.w	r2, #1
  44:	4621      	mov	r1, r4
  46:	a876      	add	r0, sp, #472	; 0x1d8
  48:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
    wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &key);
  4c:	aa42      	add	r2, sp, #264	; 0x108
  4e:	2120      	movs	r1, #32
  50:	a810      	add	r0, sp, #64	; 0x40
  52:	f7ff fffe 	bl	0 <wc_ed25519_make_key>
    wc_ed25519_make_key(&rng, ED25519_KEY_SIZE, &key2);
  56:	aa5c      	add	r2, sp, #368	; 0x170
  58:	2120      	movs	r1, #32
  5a:	a810      	add	r0, sp, #64	; 0x40
  5c:	f7ff fffe 	bl	0 <wc_ed25519_make_key>
    keySz = wc_ed25519_size(&key);
  60:	a842      	add	r0, sp, #264	; 0x108
  62:	f7ff fffe 	bl	0 <wc_ed25519_size>
    sigSz = wc_ed25519_sig_size(&key);
  66:	a842      	add	r0, sp, #264	; 0x108
  68:	f7ff fffe 	bl	0 <wc_ed25519_sig_size>
    for (i = 0; i < 6; i++) {
  6c:	4b74      	ldr	r3, [pc, #464]	; (240 <ed25519_test+0x240>)
  6e:	9308      	str	r3, [sp, #32]
  70:	4b74      	ldr	r3, [pc, #464]	; (244 <ed25519_test+0x244>)
  72:	9309      	str	r3, [sp, #36]	; 0x24
  74:	4b74      	ldr	r3, [pc, #464]	; (248 <ed25519_test+0x248>)
  76:	9304      	str	r3, [sp, #16]
  78:	4b74      	ldr	r3, [pc, #464]	; (24c <ed25519_test+0x24c>)
  7a:	9305      	str	r3, [sp, #20]
  7c:	4b74      	ldr	r3, [pc, #464]	; (250 <ed25519_test+0x250>)
  7e:	9306      	str	r3, [sp, #24]
  80:	4b74      	ldr	r3, [pc, #464]	; (254 <ed25519_test+0x254>)
  82:	9307      	str	r3, [sp, #28]
        outlen = sizeof(out);
  84:	f04f 0940 	mov.w	r9, #64	; 0x40
        XMEMSET(out, 0, sizeof(out));
  88:	2240      	movs	r2, #64	; 0x40
  8a:	2100      	movs	r1, #0
  8c:	a822      	add	r0, sp, #136	; 0x88
        outlen = sizeof(out);
  8e:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
        if (wc_ed25519_import_private_key(sKeys[i], ED25519_KEY_SIZE, pKeys[i],
  92:	ad42      	add	r5, sp, #264	; 0x108
        XMEMSET(out, 0, sizeof(out));
  94:	f7ff fffe 	bl	0 <memset>
        if (wc_ed25519_import_private_key(sKeys[i], ED25519_KEY_SIZE, pKeys[i],
  98:	9a04      	ldr	r2, [sp, #16]
  9a:	9909      	ldr	r1, [sp, #36]	; 0x24
  9c:	9500      	str	r5, [sp, #0]
  9e:	f812 3b01 	ldrb.w	r3, [r2], #1
  a2:	9e08      	ldr	r6, [sp, #32]
  a4:	9204      	str	r2, [sp, #16]
  a6:	f851 2b04 	ldr.w	r2, [r1], #4
  aa:	f856 0b04 	ldr.w	r0, [r6], #4
  ae:	9109      	str	r1, [sp, #36]	; 0x24
  b0:	2120      	movs	r1, #32
  b2:	9608      	str	r6, [sp, #32]
  b4:	f7ff fffe 	bl	0 <wc_ed25519_import_private_key>
  b8:	b140      	cbz	r0, cc <ed25519_test+0xcc>
            return WC_TEST_RET_ENC_I(i);
  ba:	495f      	ldr	r1, [pc, #380]	; (238 <ed25519_test+0x238>)
  bc:	4866      	ldr	r0, [pc, #408]	; (258 <ed25519_test+0x258>)
            return WC_TEST_RET_ENC_I(i);
  be:	fb01 0404 	mla	r4, r1, r4, r0
}
  c2:	4620      	mov	r0, r4
  c4:	f50d 7d2b 	add.w	sp, sp, #684	; 0x2ac
  c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (wc_ed25519_sign_msg(msgs[i], msgSz[i], out, &outlen, &key) != 0)
  cc:	9b06      	ldr	r3, [sp, #24]
  ce:	f853 6b04 	ldr.w	r6, [r3], #4
  d2:	9306      	str	r3, [sp, #24]
  d4:	9b07      	ldr	r3, [sp, #28]
  d6:	f833 8b02 	ldrh.w	r8, [r3], #2
  da:	9307      	str	r3, [sp, #28]
  dc:	9500      	str	r5, [sp, #0]
  de:	ab0c      	add	r3, sp, #48	; 0x30
  e0:	aa22      	add	r2, sp, #136	; 0x88
  e2:	4641      	mov	r1, r8
  e4:	4630      	mov	r0, r6
  e6:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
  ea:	b110      	cbz	r0, f2 <ed25519_test+0xf2>
            return WC_TEST_RET_ENC_I(i);
  ec:	4952      	ldr	r1, [pc, #328]	; (238 <ed25519_test+0x238>)
  ee:	485b      	ldr	r0, [pc, #364]	; (25c <ed25519_test+0x25c>)
  f0:	e7e5      	b.n	be <ed25519_test+0xbe>
        if (XMEMCMP(out, sigs[i], 64))
  f2:	9b05      	ldr	r3, [sp, #20]
  f4:	f853 ab04 	ldr.w	sl, [r3], #4
  f8:	9305      	str	r3, [sp, #20]
  fa:	2240      	movs	r2, #64	; 0x40
  fc:	4651      	mov	r1, sl
  fe:	a822      	add	r0, sp, #136	; 0x88
 100:	f7ff fffe 	bl	0 <memcmp>
 104:	b110      	cbz	r0, 10c <ed25519_test+0x10c>
            return WC_TEST_RET_ENC_I(i);
 106:	494c      	ldr	r1, [pc, #304]	; (238 <ed25519_test+0x238>)
 108:	4855      	ldr	r0, [pc, #340]	; (260 <ed25519_test+0x260>)
 10a:	e7d8      	b.n	be <ed25519_test+0xbe>
        if (wc_ed25519_verify_msg(out, outlen, msgs[i], msgSz[i], &verify,
 10c:	af0d      	add	r7, sp, #52	; 0x34
 10e:	990c      	ldr	r1, [sp, #48]	; 0x30
 110:	9501      	str	r5, [sp, #4]
 112:	9700      	str	r7, [sp, #0]
 114:	4643      	mov	r3, r8
 116:	4632      	mov	r2, r6
 118:	a822      	add	r0, sp, #136	; 0x88
 11a:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
 11e:	b110      	cbz	r0, 126 <ed25519_test+0x126>
            return WC_TEST_RET_ENC_I(i);
 120:	4945      	ldr	r1, [pc, #276]	; (238 <ed25519_test+0x238>)
 122:	4850      	ldr	r0, [pc, #320]	; (264 <ed25519_test+0x264>)
 124:	e7cb      	b.n	be <ed25519_test+0xbe>
                    &key) != 0 || verify != 1)
 126:	f8d7 b000 	ldr.w	fp, [r7]
 12a:	f1bb 0f01 	cmp.w	fp, #1
 12e:	d1f7      	bne.n	120 <ed25519_test+0x120>
        out[outlen-1] = out[outlen-1] + 1;
 130:	990c      	ldr	r1, [sp, #48]	; 0x30
 132:	ab22      	add	r3, sp, #136	; 0x88
 134:	1e4a      	subs	r2, r1, #1
 136:	a822      	add	r0, sp, #136	; 0x88
 138:	5c9b      	ldrb	r3, [r3, r2]
 13a:	3301      	adds	r3, #1
 13c:	5483      	strb	r3, [r0, r2]
        if (wc_ed25519_verify_msg(out, outlen, msgs[i], msgSz[i], &verify,
 13e:	e9cd 7500 	strd	r7, r5, [sp]
 142:	4643      	mov	r3, r8
 144:	4632      	mov	r2, r6
 146:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
 14a:	b910      	cbnz	r0, 152 <ed25519_test+0x152>
            return WC_TEST_RET_ENC_I(i);
 14c:	493a      	ldr	r1, [pc, #232]	; (238 <ed25519_test+0x238>)
 14e:	4846      	ldr	r0, [pc, #280]	; (268 <ed25519_test+0x268>)
 150:	e7b5      	b.n	be <ed25519_test+0xbe>
                    &key) == 0 || verify == 1)
 152:	683b      	ldr	r3, [r7, #0]
 154:	2b01      	cmp	r3, #1
 156:	d0f9      	beq.n	14c <ed25519_test+0x14c>
        exportPSz = sizeof(exportPKey);
 158:	2320      	movs	r3, #32
        if (wc_ed25519_export_public(&key, exportPKey, &exportPSz) != 0)
 15a:	aa0a      	add	r2, sp, #40	; 0x28
 15c:	a912      	add	r1, sp, #72	; 0x48
 15e:	4628      	mov	r0, r5
        exportSSz = sizeof(exportSKey);
 160:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
        if (wc_ed25519_export_public(&key, exportPKey, &exportPSz) != 0)
 164:	f7ff fffe 	bl	0 <wc_ed25519_export_public>
 168:	b110      	cbz	r0, 170 <ed25519_test+0x170>
            return WC_TEST_RET_ENC_I(i);
 16a:	4933      	ldr	r1, [pc, #204]	; (238 <ed25519_test+0x238>)
 16c:	483f      	ldr	r0, [pc, #252]	; (26c <ed25519_test+0x26c>)
 16e:	e7a6      	b.n	be <ed25519_test+0xbe>
        if (wc_ed25519_import_public_ex(exportPKey, exportPSz, &key2, 1) != 0)
 170:	990a      	ldr	r1, [sp, #40]	; 0x28
 172:	465b      	mov	r3, fp
 174:	aa5c      	add	r2, sp, #368	; 0x170
 176:	a812      	add	r0, sp, #72	; 0x48
 178:	f7ff fffe 	bl	0 <wc_ed25519_import_public_ex>
 17c:	b110      	cbz	r0, 184 <ed25519_test+0x184>
            return WC_TEST_RET_ENC_I(i);
 17e:	492e      	ldr	r1, [pc, #184]	; (238 <ed25519_test+0x238>)
 180:	483b      	ldr	r0, [pc, #236]	; (270 <ed25519_test+0x270>)
 182:	e79c      	b.n	be <ed25519_test+0xbe>
        if (wc_ed25519_export_private_only(&key, exportSKey, &exportSSz) != 0)
 184:	aa0b      	add	r2, sp, #44	; 0x2c
 186:	a91a      	add	r1, sp, #104	; 0x68
 188:	4628      	mov	r0, r5
 18a:	f7ff fffe 	bl	0 <wc_ed25519_export_private_only>
 18e:	b110      	cbz	r0, 196 <ed25519_test+0x196>
            return WC_TEST_RET_ENC_I(i);
 190:	4929      	ldr	r1, [pc, #164]	; (238 <ed25519_test+0x238>)
 192:	4838      	ldr	r0, [pc, #224]	; (274 <ed25519_test+0x274>)
 194:	e793      	b.n	be <ed25519_test+0xbe>
        if (wc_ed25519_import_private_key(exportSKey, exportSSz,
 196:	ad5c      	add	r5, sp, #368	; 0x170
 198:	990b      	ldr	r1, [sp, #44]	; 0x2c
 19a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 19c:	9500      	str	r5, [sp, #0]
 19e:	aa12      	add	r2, sp, #72	; 0x48
 1a0:	a81a      	add	r0, sp, #104	; 0x68
 1a2:	f7ff fffe 	bl	0 <wc_ed25519_import_private_key>
 1a6:	4601      	mov	r1, r0
 1a8:	b110      	cbz	r0, 1b0 <ed25519_test+0x1b0>
            return WC_TEST_RET_ENC_I(i);
 1aa:	4923      	ldr	r1, [pc, #140]	; (238 <ed25519_test+0x238>)
 1ac:	4832      	ldr	r0, [pc, #200]	; (278 <ed25519_test+0x278>)
 1ae:	e786      	b.n	be <ed25519_test+0xbe>
        XMEMSET(out, 0, sizeof(out));
 1b0:	2240      	movs	r2, #64	; 0x40
 1b2:	a822      	add	r0, sp, #136	; 0x88
        outlen = sizeof(out);
 1b4:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
        XMEMSET(out, 0, sizeof(out));
 1b8:	f7ff fffe 	bl	0 <memset>
        if (wc_ed25519_sign_msg(msgs[i], msgSz[i], out, &outlen, &key2) != 0)
 1bc:	9500      	str	r5, [sp, #0]
 1be:	ab0c      	add	r3, sp, #48	; 0x30
 1c0:	aa22      	add	r2, sp, #136	; 0x88
 1c2:	4641      	mov	r1, r8
 1c4:	4630      	mov	r0, r6
 1c6:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
 1ca:	b110      	cbz	r0, 1d2 <ed25519_test+0x1d2>
            return WC_TEST_RET_ENC_I(i);
 1cc:	491a      	ldr	r1, [pc, #104]	; (238 <ed25519_test+0x238>)
 1ce:	482b      	ldr	r0, [pc, #172]	; (27c <ed25519_test+0x27c>)
 1d0:	e775      	b.n	be <ed25519_test+0xbe>
        if (wc_ed25519_verify_msg(out, outlen, msgs[i], msgSz[i], &verify,
 1d2:	9501      	str	r5, [sp, #4]
 1d4:	ad0d      	add	r5, sp, #52	; 0x34
 1d6:	990c      	ldr	r1, [sp, #48]	; 0x30
 1d8:	9500      	str	r5, [sp, #0]
 1da:	4643      	mov	r3, r8
 1dc:	4632      	mov	r2, r6
 1de:	a822      	add	r0, sp, #136	; 0x88
 1e0:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
 1e4:	b110      	cbz	r0, 1ec <ed25519_test+0x1ec>
            return WC_TEST_RET_ENC_I(i);
 1e6:	4914      	ldr	r1, [pc, #80]	; (238 <ed25519_test+0x238>)
 1e8:	4825      	ldr	r0, [pc, #148]	; (280 <ed25519_test+0x280>)
 1ea:	e768      	b.n	be <ed25519_test+0xbe>
                                  &key2) != 0 || verify != 1)
 1ec:	682b      	ldr	r3, [r5, #0]
 1ee:	2b01      	cmp	r3, #1
 1f0:	d1f9      	bne.n	1e6 <ed25519_test+0x1e6>
        if (XMEMCMP(out, sigs[i], 64))
 1f2:	2240      	movs	r2, #64	; 0x40
 1f4:	4651      	mov	r1, sl
 1f6:	a822      	add	r0, sp, #136	; 0x88
 1f8:	f7ff fffe 	bl	0 <memcmp>
 1fc:	4680      	mov	r8, r0
 1fe:	b110      	cbz	r0, 206 <ed25519_test+0x206>
            return WC_TEST_RET_ENC_I(i);
 200:	490d      	ldr	r1, [pc, #52]	; (238 <ed25519_test+0x238>)
 202:	4820      	ldr	r0, [pc, #128]	; (284 <ed25519_test+0x284>)
 204:	e75b      	b.n	be <ed25519_test+0xbe>
    for (i = 0; i < 6; i++) {
 206:	3401      	adds	r4, #1
 208:	2c06      	cmp	r4, #6
 20a:	f47f af3d 	bne.w	88 <ed25519_test+0x88>
    XMEMSET(out, 0, sizeof(out));
 20e:	4601      	mov	r1, r0
 210:	2240      	movs	r2, #64	; 0x40
    int    verify = 0;
 212:	900f      	str	r0, [sp, #60]	; 0x3c
    ret = wc_ed25519_init_ex(&key, HEAP_HINT, devId);
 214:	af90      	add	r7, sp, #576	; 0x240
    XMEMSET(out, 0, sizeof(out));
 216:	a832      	add	r0, sp, #200	; 0xc8
    outlen = sizeof(out);
 218:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
    XMEMSET(out, 0, sizeof(out));
 21c:	f7ff fffe 	bl	0 <memset>
    ret = wc_ed25519_init_ex(&key, HEAP_HINT, devId);
 220:	f06f 0201 	mvn.w	r2, #1
 224:	4641      	mov	r1, r8
 226:	4638      	mov	r0, r7
    int    verify = 0;
 228:	ae0f      	add	r6, sp, #60	; 0x3c
    ret = wc_ed25519_init_ex(&key, HEAP_HINT, devId);
 22a:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
    if (ret != 0)
 22e:	b358      	cbz	r0, 288 <ed25519_test+0x288>
        return 10800;
 230:	f642 2430 	movw	r4, #10800	; 0x2a30
 234:	e745      	b.n	c2 <ed25519_test+0xc2>
 236:	bf00      	nop
 238:	fffe7960 	.word	0xfffe7960
 23c:	dfff8488 	.word	0xdfff8488
	...
 258:	9fff8470 	.word	0x9fff8470
 25c:	9fff846d 	.word	0x9fff846d
 260:	9fff846a 	.word	0x9fff846a
 264:	9fff8464 	.word	0x9fff8464
 268:	9fff8450 	.word	0x9fff8450
 26c:	9fff8449 	.word	0x9fff8449
 270:	9fff8446 	.word	0x9fff8446
 274:	9fff8443 	.word	0x9fff8443
 278:	9fff843f 	.word	0x9fff843f
 27c:	9fff8439 	.word	0x9fff8439
 280:	9fff8434 	.word	0x9fff8434
 284:	9fff8431 	.word	0x9fff8431
    ret = wc_ed25519_import_private_key(sKeyCtx, ED25519_KEY_SIZE, pKeyCtx,
 288:	2320      	movs	r3, #32
 28a:	4a9e      	ldr	r2, [pc, #632]	; (504 <ed25519_test+0x504>)
 28c:	489e      	ldr	r0, [pc, #632]	; (508 <ed25519_test+0x508>)
 28e:	9700      	str	r7, [sp, #0]
 290:	4619      	mov	r1, r3
 292:	f7ff fffe 	bl	0 <wc_ed25519_import_private_key>
    if (ret == 0)
 296:	4604      	mov	r4, r0
 298:	2800      	cmp	r0, #0
 29a:	d149      	bne.n	330 <ed25519_test+0x330>
        ret = wc_ed25519ctx_sign_msg(msgCtx, sizeof(msgCtx), out, &outlen, &key,
 29c:	f8df 826c 	ldr.w	r8, [pc, #620]	; 50c <ed25519_test+0x50c>
 2a0:	489b      	ldr	r0, [pc, #620]	; (510 <ed25519_test+0x510>)
 2a2:	2303      	movs	r3, #3
 2a4:	9302      	str	r3, [sp, #8]
 2a6:	e9cd 7800 	strd	r7, r8, [sp]
 2aa:	ab0e      	add	r3, sp, #56	; 0x38
 2ac:	aa32      	add	r2, sp, #200	; 0xc8
 2ae:	2110      	movs	r1, #16
 2b0:	f7ff fffe 	bl	0 <wc_ed25519ctx_sign_msg>
    if (ret == 0 && XMEMCMP(out, sigCtx1, 64) != 0)
 2b4:	4604      	mov	r4, r0
 2b6:	2800      	cmp	r0, #0
 2b8:	d13a      	bne.n	330 <ed25519_test+0x330>
 2ba:	4996      	ldr	r1, [pc, #600]	; (514 <ed25519_test+0x514>)
 2bc:	2240      	movs	r2, #64	; 0x40
 2be:	a832      	add	r0, sp, #200	; 0xc8
 2c0:	f7ff fffe 	bl	0 <memcmp>
 2c4:	2800      	cmp	r0, #0
 2c6:	d151      	bne.n	36c <ed25519_test+0x36c>
        ret = wc_ed25519ctx_verify_msg(out, outlen, msgCtx, sizeof(msgCtx),
 2c8:	2303      	movs	r3, #3
 2ca:	af90      	add	r7, sp, #576	; 0x240
 2cc:	e9cd 8302 	strd	r8, r3, [sp, #8]
 2d0:	e9cd 6700 	strd	r6, r7, [sp]
 2d4:	4a8e      	ldr	r2, [pc, #568]	; (510 <ed25519_test+0x510>)
 2d6:	990e      	ldr	r1, [sp, #56]	; 0x38
 2d8:	2310      	movs	r3, #16
 2da:	a832      	add	r0, sp, #200	; 0xc8
 2dc:	f7ff fffe 	bl	0 <wc_ed25519ctx_verify_msg>
    if (ret == 0 && verify != 1)
 2e0:	4604      	mov	r4, r0
 2e2:	bb28      	cbnz	r0, 330 <ed25519_test+0x330>
 2e4:	6833      	ldr	r3, [r6, #0]
 2e6:	2b01      	cmp	r3, #1
 2e8:	d142      	bne.n	370 <ed25519_test+0x370>
        ret = wc_ed25519ctx_sign_msg(msgCtx, sizeof(msgCtx), out, &outlen, &key,
 2ea:	e9cd 4401 	strd	r4, r4, [sp, #4]
 2ee:	4888      	ldr	r0, [pc, #544]	; (510 <ed25519_test+0x510>)
 2f0:	9700      	str	r7, [sp, #0]
 2f2:	ab0e      	add	r3, sp, #56	; 0x38
 2f4:	aa32      	add	r2, sp, #200	; 0xc8
 2f6:	2110      	movs	r1, #16
 2f8:	f7ff fffe 	bl	0 <wc_ed25519ctx_sign_msg>
    if (ret == 0 && XMEMCMP(out, sigCtx2, 64) != 0)
 2fc:	4604      	mov	r4, r0
 2fe:	b9b8      	cbnz	r0, 330 <ed25519_test+0x330>
 300:	4985      	ldr	r1, [pc, #532]	; (518 <ed25519_test+0x518>)
 302:	2240      	movs	r2, #64	; 0x40
 304:	a832      	add	r0, sp, #200	; 0xc8
 306:	f7ff fffe 	bl	0 <memcmp>
 30a:	2800      	cmp	r0, #0
 30c:	d132      	bne.n	374 <ed25519_test+0x374>
        ret = wc_ed25519ctx_verify_msg(out, outlen, msgCtx, sizeof(msgCtx),
 30e:	e9cd 4402 	strd	r4, r4, [sp, #8]
 312:	e9cd 6700 	strd	r6, r7, [sp]
 316:	4a7e      	ldr	r2, [pc, #504]	; (510 <ed25519_test+0x510>)
 318:	990e      	ldr	r1, [sp, #56]	; 0x38
 31a:	2310      	movs	r3, #16
 31c:	a832      	add	r0, sp, #200	; 0xc8
 31e:	f7ff fffe 	bl	0 <wc_ed25519ctx_verify_msg>
    if (ret == 0 && verify != 1)
 322:	4604      	mov	r4, r0
 324:	b920      	cbnz	r0, 330 <ed25519_test+0x330>
 326:	6832      	ldr	r2, [r6, #0]
        ret = WC_TEST_RET_ENC_NC;
 328:	4b7c      	ldr	r3, [pc, #496]	; (51c <ed25519_test+0x51c>)
 32a:	2a01      	cmp	r2, #1
 32c:	bf18      	it	ne
 32e:	461c      	movne	r4, r3
    wc_ed25519_free(&key);
 330:	af90      	add	r7, sp, #576	; 0x240
 332:	4638      	mov	r0, r7
 334:	f7ff fffe 	bl	0 <wc_ed25519_free>
    if (ret != 0)
 338:	2c00      	cmp	r4, #0
 33a:	f47f aec2 	bne.w	c2 <ed25519_test+0xc2>
    outlen = sizeof(out);
 33e:	f04f 0840 	mov.w	r8, #64	; 0x40
    XMEMSET(out, 0, sizeof(out));
 342:	4642      	mov	r2, r8
 344:	4621      	mov	r1, r4
    int    verify = 0;
 346:	6034      	str	r4, [r6, #0]
    XMEMSET(out, 0, sizeof(out));
 348:	a832      	add	r0, sp, #200	; 0xc8
    outlen = sizeof(out);
 34a:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    XMEMSET(out, 0, sizeof(out));
 34e:	f7ff fffe 	bl	0 <memset>
    ret = wc_ed25519_init_ex(&key, HEAP_HINT, devId);
 352:	f06f 0201 	mvn.w	r2, #1
 356:	4621      	mov	r1, r4
 358:	4638      	mov	r0, r7
 35a:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
    if (ret != 0)
 35e:	b158      	cbz	r0, 378 <ed25519_test+0x378>
        return WC_TEST_RET_ENC_EC(ret);
 360:	4240      	negs	r0, r0
 362:	496f      	ldr	r1, [pc, #444]	; (520 <ed25519_test+0x520>)
 364:	4c6f      	ldr	r4, [pc, #444]	; (524 <ed25519_test+0x524>)
 366:	f3c0 000a 	ubfx	r0, r0, #0, #11
 36a:	e65a      	b.n	22 <ed25519_test+0x22>
        ret = WC_TEST_RET_ENC_NC;
 36c:	4c6e      	ldr	r4, [pc, #440]	; (528 <ed25519_test+0x528>)
 36e:	e7df      	b.n	330 <ed25519_test+0x330>
        ret = WC_TEST_RET_ENC_NC;
 370:	4c6e      	ldr	r4, [pc, #440]	; (52c <ed25519_test+0x52c>)
 372:	e7dd      	b.n	330 <ed25519_test+0x330>
        ret = WC_TEST_RET_ENC_NC;
 374:	4c6e      	ldr	r4, [pc, #440]	; (530 <ed25519_test+0x530>)
 376:	e7db      	b.n	330 <ed25519_test+0x330>
    ret = wc_ed25519_import_private_key(sKeyPh, ED25519_KEY_SIZE, pKeyPh,
 378:	2320      	movs	r3, #32
 37a:	4a6e      	ldr	r2, [pc, #440]	; (534 <ed25519_test+0x534>)
 37c:	486e      	ldr	r0, [pc, #440]	; (538 <ed25519_test+0x538>)
 37e:	9700      	str	r7, [sp, #0]
 380:	4619      	mov	r1, r3
 382:	f7ff fffe 	bl	0 <wc_ed25519_import_private_key>
    if (ret == 0)
 386:	4604      	mov	r4, r0
 388:	2800      	cmp	r0, #0
 38a:	f040 8097 	bne.w	4bc <ed25519_test+0x4bc>
        ret = wc_ed25519ph_sign_msg(msgPh, sizeof(msgPh), out, &outlen, &key,
 38e:	e9cd 0001 	strd	r0, r0, [sp, #4]
 392:	9700      	str	r7, [sp, #0]
 394:	4869      	ldr	r0, [pc, #420]	; (53c <ed25519_test+0x53c>)
 396:	ab0e      	add	r3, sp, #56	; 0x38
 398:	aa32      	add	r2, sp, #200	; 0xc8
 39a:	2103      	movs	r1, #3
 39c:	f7ff fffe 	bl	0 <wc_ed25519ph_sign_msg>
    if (ret == 0 && XMEMCMP(out, sigPh1, 64) != 0)
 3a0:	4604      	mov	r4, r0
 3a2:	2800      	cmp	r0, #0
 3a4:	f040 808a 	bne.w	4bc <ed25519_test+0x4bc>
 3a8:	4965      	ldr	r1, [pc, #404]	; (540 <ed25519_test+0x540>)
 3aa:	4642      	mov	r2, r8
 3ac:	a832      	add	r0, sp, #200	; 0xc8
 3ae:	f7ff fffe 	bl	0 <memcmp>
 3b2:	2800      	cmp	r0, #0
 3b4:	f040 8097 	bne.w	4e6 <ed25519_test+0x4e6>
        ret = wc_ed25519ph_verify_msg(out, outlen, msgPh, sizeof(msgPh),
 3b8:	e9cd 4402 	strd	r4, r4, [sp, #8]
 3bc:	e9cd 6700 	strd	r6, r7, [sp]
 3c0:	4a5e      	ldr	r2, [pc, #376]	; (53c <ed25519_test+0x53c>)
 3c2:	990e      	ldr	r1, [sp, #56]	; 0x38
 3c4:	2303      	movs	r3, #3
 3c6:	a832      	add	r0, sp, #200	; 0xc8
 3c8:	f7ff fffe 	bl	0 <wc_ed25519ph_verify_msg>
    if (ret == 0 && verify != 1)
 3cc:	4604      	mov	r4, r0
 3ce:	2800      	cmp	r0, #0
 3d0:	d174      	bne.n	4bc <ed25519_test+0x4bc>
 3d2:	6833      	ldr	r3, [r6, #0]
 3d4:	2b01      	cmp	r3, #1
 3d6:	f040 8088 	bne.w	4ea <ed25519_test+0x4ea>
        ret = wc_ed25519ph_sign_msg(msgPh, sizeof(msgPh), out, &outlen, &key,
 3da:	f8df a168 	ldr.w	sl, [pc, #360]	; 544 <ed25519_test+0x544>
 3de:	4857      	ldr	r0, [pc, #348]	; (53c <ed25519_test+0x53c>)
 3e0:	f04f 0903 	mov.w	r9, #3
 3e4:	e9cd 7a00 	strd	r7, sl, [sp]
 3e8:	f8cd 9008 	str.w	r9, [sp, #8]
 3ec:	ab0e      	add	r3, sp, #56	; 0x38
 3ee:	aa32      	add	r2, sp, #200	; 0xc8
 3f0:	4649      	mov	r1, r9
 3f2:	f7ff fffe 	bl	0 <wc_ed25519ph_sign_msg>
    if (ret == 0 && XMEMCMP(out, sigPh2, 64) != 0)
 3f6:	4604      	mov	r4, r0
 3f8:	2800      	cmp	r0, #0
 3fa:	d15f      	bne.n	4bc <ed25519_test+0x4bc>
 3fc:	4952      	ldr	r1, [pc, #328]	; (548 <ed25519_test+0x548>)
 3fe:	4642      	mov	r2, r8
 400:	a832      	add	r0, sp, #200	; 0xc8
 402:	f7ff fffe 	bl	0 <memcmp>
 406:	2800      	cmp	r0, #0
 408:	d171      	bne.n	4ee <ed25519_test+0x4ee>
        ret = wc_ed25519ph_verify_msg(out, outlen, msgPh, sizeof(msgPh), &verify,
 40a:	e9cd a902 	strd	sl, r9, [sp, #8]
 40e:	e9cd 6700 	strd	r6, r7, [sp]
 412:	4a4a      	ldr	r2, [pc, #296]	; (53c <ed25519_test+0x53c>)
 414:	990e      	ldr	r1, [sp, #56]	; 0x38
 416:	464b      	mov	r3, r9
 418:	a832      	add	r0, sp, #200	; 0xc8
 41a:	f7ff fffe 	bl	0 <wc_ed25519ph_verify_msg>
    if (ret == 0 && verify != 1)
 41e:	4604      	mov	r4, r0
 420:	2800      	cmp	r0, #0
 422:	d14b      	bne.n	4bc <ed25519_test+0x4bc>
 424:	6833      	ldr	r3, [r6, #0]
 426:	2b01      	cmp	r3, #1
 428:	d163      	bne.n	4f2 <ed25519_test+0x4f2>
        ret = wc_ed25519ph_sign_hash(hashPh, sizeof(hashPh), out, &outlen, &key,
 42a:	2300      	movs	r3, #0
 42c:	af90      	add	r7, sp, #576	; 0x240
 42e:	e9cd 3301 	strd	r3, r3, [sp, #4]
 432:	4846      	ldr	r0, [pc, #280]	; (54c <ed25519_test+0x54c>)
 434:	9700      	str	r7, [sp, #0]
 436:	ab0e      	add	r3, sp, #56	; 0x38
 438:	aa32      	add	r2, sp, #200	; 0xc8
 43a:	2140      	movs	r1, #64	; 0x40
 43c:	f7ff fffe 	bl	0 <wc_ed25519ph_sign_hash>
    if (ret == 0 && XMEMCMP(out, sigPh1, 64) != 0)
 440:	4604      	mov	r4, r0
 442:	2800      	cmp	r0, #0
 444:	d13a      	bne.n	4bc <ed25519_test+0x4bc>
 446:	493e      	ldr	r1, [pc, #248]	; (540 <ed25519_test+0x540>)
 448:	2240      	movs	r2, #64	; 0x40
 44a:	a832      	add	r0, sp, #200	; 0xc8
 44c:	f7ff fffe 	bl	0 <memcmp>
 450:	2800      	cmp	r0, #0
 452:	d150      	bne.n	4f6 <ed25519_test+0x4f6>
        ret = wc_ed25519ph_verify_hash(out, outlen, hashPh, sizeof(hashPh),
 454:	e9cd 4402 	strd	r4, r4, [sp, #8]
 458:	e9cd 6700 	strd	r6, r7, [sp]
 45c:	4a3b      	ldr	r2, [pc, #236]	; (54c <ed25519_test+0x54c>)
 45e:	990e      	ldr	r1, [sp, #56]	; 0x38
 460:	2340      	movs	r3, #64	; 0x40
 462:	a832      	add	r0, sp, #200	; 0xc8
 464:	f7ff fffe 	bl	0 <wc_ed25519ph_verify_hash>
    if (ret == 0 && verify != 1)
 468:	4604      	mov	r4, r0
 46a:	bb38      	cbnz	r0, 4bc <ed25519_test+0x4bc>
 46c:	6833      	ldr	r3, [r6, #0]
 46e:	2b01      	cmp	r3, #1
 470:	d143      	bne.n	4fa <ed25519_test+0x4fa>
        ret = wc_ed25519ph_sign_hash(hashPh, sizeof(hashPh), out, &outlen, &key,
 472:	f04f 0803 	mov.w	r8, #3
 476:	e9cd a801 	strd	sl, r8, [sp, #4]
 47a:	4834      	ldr	r0, [pc, #208]	; (54c <ed25519_test+0x54c>)
 47c:	9700      	str	r7, [sp, #0]
 47e:	ab0e      	add	r3, sp, #56	; 0x38
 480:	aa32      	add	r2, sp, #200	; 0xc8
 482:	2140      	movs	r1, #64	; 0x40
 484:	f7ff fffe 	bl	0 <wc_ed25519ph_sign_hash>
    if (ret == 0 && XMEMCMP(out, sigPh2, 64) != 0)
 488:	4604      	mov	r4, r0
 48a:	b9b8      	cbnz	r0, 4bc <ed25519_test+0x4bc>
 48c:	492e      	ldr	r1, [pc, #184]	; (548 <ed25519_test+0x548>)
 48e:	2240      	movs	r2, #64	; 0x40
 490:	a832      	add	r0, sp, #200	; 0xc8
 492:	f7ff fffe 	bl	0 <memcmp>
 496:	2800      	cmp	r0, #0
 498:	d131      	bne.n	4fe <ed25519_test+0x4fe>
        ret = wc_ed25519ph_verify_hash(out, outlen, hashPh, sizeof(hashPh), &verify,
 49a:	e9cd a802 	strd	sl, r8, [sp, #8]
 49e:	e9cd 6700 	strd	r6, r7, [sp]
 4a2:	4a2a      	ldr	r2, [pc, #168]	; (54c <ed25519_test+0x54c>)
 4a4:	990e      	ldr	r1, [sp, #56]	; 0x38
 4a6:	2340      	movs	r3, #64	; 0x40
 4a8:	a832      	add	r0, sp, #200	; 0xc8
 4aa:	f7ff fffe 	bl	0 <wc_ed25519ph_verify_hash>
    if (ret == 0 && verify != 1)
 4ae:	4604      	mov	r4, r0
 4b0:	b920      	cbnz	r0, 4bc <ed25519_test+0x4bc>
 4b2:	6832      	ldr	r2, [r6, #0]
        ret = WC_TEST_RET_ENC_NC;
 4b4:	4b26      	ldr	r3, [pc, #152]	; (550 <ed25519_test+0x550>)
 4b6:	2a01      	cmp	r2, #1
 4b8:	bf18      	it	ne
 4ba:	461c      	movne	r4, r3
    wc_ed25519_free(&key);
 4bc:	a890      	add	r0, sp, #576	; 0x240
 4be:	f7ff fffe 	bl	0 <wc_ed25519_free>
    if (ret != 0)
 4c2:	2c00      	cmp	r4, #0
 4c4:	f47f adfd 	bne.w	c2 <ed25519_test+0xc2>
    ret = wc_Ed25519PrivateKeyDecode(privateEd25519, &idx, &key3,
 4c8:	4822      	ldr	r0, [pc, #136]	; (554 <ed25519_test+0x554>)
    idx = 0;
 4ca:	9490      	str	r4, [sp, #576]	; 0x240
    ret = wc_Ed25519PrivateKeyDecode(privateEd25519, &idx, &key3,
 4cc:	2330      	movs	r3, #48	; 0x30
 4ce:	aa76      	add	r2, sp, #472	; 0x1d8
 4d0:	a990      	add	r1, sp, #576	; 0x240
 4d2:	f7ff fffe 	bl	0 <wc_Ed25519PrivateKeyDecode>
    if (ret != 0)
 4d6:	2800      	cmp	r0, #0
 4d8:	d04e      	beq.n	578 <ed25519_test+0x578>
        return WC_TEST_RET_ENC_EC(ret);
 4da:	4240      	negs	r0, r0
 4dc:	4910      	ldr	r1, [pc, #64]	; (520 <ed25519_test+0x520>)
 4de:	4c1e      	ldr	r4, [pc, #120]	; (558 <ed25519_test+0x558>)
 4e0:	f3c0 000a 	ubfx	r0, r0, #0, #11
 4e4:	e59d      	b.n	22 <ed25519_test+0x22>
        ret = WC_TEST_RET_ENC_NC;
 4e6:	4c1d      	ldr	r4, [pc, #116]	; (55c <ed25519_test+0x55c>)
 4e8:	e7e8      	b.n	4bc <ed25519_test+0x4bc>
        ret = WC_TEST_RET_ENC_NC;
 4ea:	4c1d      	ldr	r4, [pc, #116]	; (560 <ed25519_test+0x560>)
 4ec:	e7e6      	b.n	4bc <ed25519_test+0x4bc>
        ret = WC_TEST_RET_ENC_NC;
 4ee:	4c1d      	ldr	r4, [pc, #116]	; (564 <ed25519_test+0x564>)
 4f0:	e7e4      	b.n	4bc <ed25519_test+0x4bc>
        ret = WC_TEST_RET_ENC_NC;
 4f2:	4c1d      	ldr	r4, [pc, #116]	; (568 <ed25519_test+0x568>)
 4f4:	e7e2      	b.n	4bc <ed25519_test+0x4bc>
        ret = WC_TEST_RET_ENC_NC;
 4f6:	4c1d      	ldr	r4, [pc, #116]	; (56c <ed25519_test+0x56c>)
 4f8:	e7e0      	b.n	4bc <ed25519_test+0x4bc>
        ret = WC_TEST_RET_ENC_NC;
 4fa:	4c1d      	ldr	r4, [pc, #116]	; (570 <ed25519_test+0x570>)
 4fc:	e7de      	b.n	4bc <ed25519_test+0x4bc>
        ret = WC_TEST_RET_ENC_NC;
 4fe:	4c1d      	ldr	r4, [pc, #116]	; (574 <ed25519_test+0x574>)
 500:	e7dc      	b.n	4bc <ed25519_test+0x4bc>
 502:	bf00      	nop
	...
 51c:	ffff86bb 	.word	0xffff86bb
 520:	fffe7960 	.word	0xfffe7960
 524:	dfff866c 	.word	0xdfff866c
 528:	ffff86d3 	.word	0xffff86d3
 52c:	ffff86cb 	.word	0xffff86cb
 530:	ffff86c3 	.word	0xffff86c3
	...
 550:	ffff862e 	.word	0xffff862e
 554:	00000000 	.word	0x00000000
 558:	dfff841f 	.word	0xdfff841f
 55c:	ffff8663 	.word	0xffff8663
 560:	ffff865b 	.word	0xffff865b
 564:	ffff8653 	.word	0xffff8653
 568:	ffff864b 	.word	0xffff864b
 56c:	ffff8643 	.word	0xffff8643
 570:	ffff863c 	.word	0xffff863c
 574:	ffff8635 	.word	0xffff8635
    if (wc_Ed25519PrivateKeyDecode(badPrivateEd25519, &idx, &key3,
 578:	484d      	ldr	r0, [pc, #308]	; (6b0 <ed25519_test+0x6b0>)
    idx = 0;
 57a:	9490      	str	r4, [sp, #576]	; 0x240
    if (wc_Ed25519PrivateKeyDecode(badPrivateEd25519, &idx, &key3,
 57c:	2355      	movs	r3, #85	; 0x55
 57e:	aa76      	add	r2, sp, #472	; 0x1d8
 580:	a990      	add	r1, sp, #576	; 0x240
 582:	f7ff fffe 	bl	0 <wc_Ed25519PrivateKeyDecode>
 586:	2800      	cmp	r0, #0
 588:	f000 8089 	beq.w	69e <ed25519_test+0x69e>
    ret = wc_ed25519_sign_msg(msgs[0], msgSz[0], out, &outlen, &key3);
 58c:	ab76      	add	r3, sp, #472	; 0x1d8
 58e:	9300      	str	r3, [sp, #0]
 590:	4848      	ldr	r0, [pc, #288]	; (6b4 <ed25519_test+0x6b4>)
 592:	ab0c      	add	r3, sp, #48	; 0x30
 594:	aa22      	add	r2, sp, #136	; 0x88
 596:	4621      	mov	r1, r4
 598:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
    if (ret != BAD_FUNC_ARG)
 59c:	f110 0fad 	cmn.w	r0, #173	; 0xad
 5a0:	d005      	beq.n	5ae <ed25519_test+0x5ae>
        return WC_TEST_RET_ENC_EC(ret);
 5a2:	4240      	negs	r0, r0
 5a4:	4944      	ldr	r1, [pc, #272]	; (6b8 <ed25519_test+0x6b8>)
 5a6:	4c45      	ldr	r4, [pc, #276]	; (6bc <ed25519_test+0x6bc>)
 5a8:	f3c0 000a 	ubfx	r0, r0, #0, #11
 5ac:	e539      	b.n	22 <ed25519_test+0x22>
    if (wc_Ed25519PublicKeyDecode(badPublicEd25519, &idx, &key3,
 5ae:	4844      	ldr	r0, [pc, #272]	; (6c0 <ed25519_test+0x6c0>)
    idx = 0;
 5b0:	9490      	str	r4, [sp, #576]	; 0x240
    if (wc_Ed25519PublicKeyDecode(badPublicEd25519, &idx, &key3,
 5b2:	232d      	movs	r3, #45	; 0x2d
 5b4:	aa76      	add	r2, sp, #472	; 0x1d8
 5b6:	a990      	add	r1, sp, #576	; 0x240
 5b8:	f7ff fffe 	bl	0 <wc_Ed25519PublicKeyDecode>
 5bc:	2800      	cmp	r0, #0
 5be:	d070      	beq.n	6a2 <ed25519_test+0x6a2>
    ret = wc_Ed25519PublicKeyDecode(publicEd25519, &idx, &key3,
 5c0:	4840      	ldr	r0, [pc, #256]	; (6c4 <ed25519_test+0x6c4>)
    idx = 0;
 5c2:	9490      	str	r4, [sp, #576]	; 0x240
    ret = wc_Ed25519PublicKeyDecode(publicEd25519, &idx, &key3,
 5c4:	232c      	movs	r3, #44	; 0x2c
 5c6:	aa76      	add	r2, sp, #472	; 0x1d8
 5c8:	a990      	add	r1, sp, #576	; 0x240
 5ca:	f7ff fffe 	bl	0 <wc_Ed25519PublicKeyDecode>
    if (ret != 0)
 5ce:	b128      	cbz	r0, 5dc <ed25519_test+0x5dc>
        return WC_TEST_RET_ENC_EC(ret);
 5d0:	4240      	negs	r0, r0
 5d2:	4939      	ldr	r1, [pc, #228]	; (6b8 <ed25519_test+0x6b8>)
 5d4:	4c3c      	ldr	r4, [pc, #240]	; (6c8 <ed25519_test+0x6c8>)
 5d6:	f3c0 000a 	ubfx	r0, r0, #0, #11
 5da:	e522      	b.n	22 <ed25519_test+0x22>
    ret = wc_ed25519_sign_msg(msgs[0], msgSz[0], out, &outlen, &key3);
 5dc:	ab76      	add	r3, sp, #472	; 0x1d8
 5de:	9300      	str	r3, [sp, #0]
 5e0:	4834      	ldr	r0, [pc, #208]	; (6b4 <ed25519_test+0x6b4>)
 5e2:	ab0c      	add	r3, sp, #48	; 0x30
 5e4:	aa22      	add	r2, sp, #136	; 0x88
 5e6:	4621      	mov	r1, r4
 5e8:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
    if (ret != 0)
 5ec:	b128      	cbz	r0, 5fa <ed25519_test+0x5fa>
        return WC_TEST_RET_ENC_EC(ret);
 5ee:	4240      	negs	r0, r0
 5f0:	4931      	ldr	r1, [pc, #196]	; (6b8 <ed25519_test+0x6b8>)
 5f2:	4c36      	ldr	r4, [pc, #216]	; (6cc <ed25519_test+0x6cc>)
 5f4:	f3c0 000a 	ubfx	r0, r0, #0, #11
 5f8:	e513      	b.n	22 <ed25519_test+0x22>
    if (XMEMCMP(out, sigs[0], 64))
 5fa:	4935      	ldr	r1, [pc, #212]	; (6d0 <ed25519_test+0x6d0>)
 5fc:	2240      	movs	r2, #64	; 0x40
 5fe:	a822      	add	r0, sp, #136	; 0x88
 600:	f7ff fffe 	bl	0 <memcmp>
 604:	2800      	cmp	r0, #0
 606:	d14e      	bne.n	6a6 <ed25519_test+0x6a6>
    ret = wc_ed25519_verify_msg(out, outlen, msgs[0], msgSz[0], &verify, &key3);
 608:	ab76      	add	r3, sp, #472	; 0x1d8
 60a:	e9cd 5300 	strd	r5, r3, [sp]
 60e:	4a29      	ldr	r2, [pc, #164]	; (6b4 <ed25519_test+0x6b4>)
 610:	990c      	ldr	r1, [sp, #48]	; 0x30
 612:	4623      	mov	r3, r4
 614:	a822      	add	r0, sp, #136	; 0x88
 616:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
    if (ret != 0 || verify != 1)
 61a:	b910      	cbnz	r0, 622 <ed25519_test+0x622>
 61c:	682b      	ldr	r3, [r5, #0]
 61e:	2b01      	cmp	r3, #1
 620:	d005      	beq.n	62e <ed25519_test+0x62e>
        return WC_TEST_RET_ENC_EC(ret);
 622:	4240      	negs	r0, r0
 624:	4924      	ldr	r1, [pc, #144]	; (6b8 <ed25519_test+0x6b8>)
 626:	4c2b      	ldr	r4, [pc, #172]	; (6d4 <ed25519_test+0x6d4>)
 628:	f3c0 000a 	ubfx	r0, r0, #0, #11
 62c:	e4f9      	b.n	22 <ed25519_test+0x22>
    wc_ed25519_free(&key3);
 62e:	a876      	add	r0, sp, #472	; 0x1d8
 630:	f7ff fffe 	bl	0 <wc_ed25519_free>
    wc_ed25519_init(&key3);
 634:	a876      	add	r0, sp, #472	; 0x1d8
 636:	f7ff fffe 	bl	0 <wc_ed25519_init>
    idx = 0;
 63a:	2300      	movs	r3, #0
 63c:	9390      	str	r3, [sp, #576]	; 0x240
    ret = wc_Ed25519PrivateKeyDecode(privPubEd25519, &idx, &key3,
 63e:	a990      	add	r1, sp, #576	; 0x240
 640:	4825      	ldr	r0, [pc, #148]	; (6d8 <ed25519_test+0x6d8>)
 642:	2352      	movs	r3, #82	; 0x52
 644:	aa76      	add	r2, sp, #472	; 0x1d8
 646:	f7ff fffe 	bl	0 <wc_Ed25519PrivateKeyDecode>
    if (ret != 0)
 64a:	4601      	mov	r1, r0
 64c:	b128      	cbz	r0, 65a <ed25519_test+0x65a>
        return WC_TEST_RET_ENC_EC(ret);
 64e:	4241      	negs	r1, r0
 650:	4c19      	ldr	r4, [pc, #100]	; (6b8 <ed25519_test+0x6b8>)
 652:	4822      	ldr	r0, [pc, #136]	; (6dc <ed25519_test+0x6dc>)
 654:	f3c1 010a 	ubfx	r1, r1, #0, #11
 658:	e531      	b.n	be <ed25519_test+0xbe>
    ret = wc_ed25519_sign_msg(msgs[0], msgSz[0], out, &outlen, &key3);
 65a:	ab76      	add	r3, sp, #472	; 0x1d8
 65c:	9300      	str	r3, [sp, #0]
 65e:	4815      	ldr	r0, [pc, #84]	; (6b4 <ed25519_test+0x6b4>)
 660:	ab0c      	add	r3, sp, #48	; 0x30
 662:	aa22      	add	r2, sp, #136	; 0x88
 664:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
    if (ret != 0)
 668:	b128      	cbz	r0, 676 <ed25519_test+0x676>
        return WC_TEST_RET_ENC_EC(ret);
 66a:	4240      	negs	r0, r0
 66c:	4912      	ldr	r1, [pc, #72]	; (6b8 <ed25519_test+0x6b8>)
 66e:	4c1c      	ldr	r4, [pc, #112]	; (6e0 <ed25519_test+0x6e0>)
 670:	f3c0 000a 	ubfx	r0, r0, #0, #11
 674:	e4d5      	b.n	22 <ed25519_test+0x22>
    if (XMEMCMP(out, sigs[0], 64))
 676:	4916      	ldr	r1, [pc, #88]	; (6d0 <ed25519_test+0x6d0>)
 678:	2240      	movs	r2, #64	; 0x40
 67a:	a822      	add	r0, sp, #136	; 0x88
 67c:	f7ff fffe 	bl	0 <memcmp>
 680:	4604      	mov	r4, r0
 682:	b990      	cbnz	r0, 6aa <ed25519_test+0x6aa>
    wc_ed25519_free(&key3);
 684:	a876      	add	r0, sp, #472	; 0x1d8
 686:	f7ff fffe 	bl	0 <wc_ed25519_free>
    wc_ed25519_free(&key);
 68a:	a842      	add	r0, sp, #264	; 0x108
 68c:	f7ff fffe 	bl	0 <wc_ed25519_free>
    wc_ed25519_free(&key2);
 690:	a85c      	add	r0, sp, #368	; 0x170
 692:	f7ff fffe 	bl	0 <wc_ed25519_free>
    wc_FreeRng(&rng);
 696:	a810      	add	r0, sp, #64	; 0x40
 698:	f7ff fffe 	bl	0 <wc_FreeRng>
    return 0;
 69c:	e511      	b.n	c2 <ed25519_test+0xc2>
        return WC_TEST_RET_ENC_NC;
 69e:	4c11      	ldr	r4, [pc, #68]	; (6e4 <ed25519_test+0x6e4>)
 6a0:	e50f      	b.n	c2 <ed25519_test+0xc2>
        return WC_TEST_RET_ENC_NC;
 6a2:	4c11      	ldr	r4, [pc, #68]	; (6e8 <ed25519_test+0x6e8>)
 6a4:	e50d      	b.n	c2 <ed25519_test+0xc2>
        return WC_TEST_RET_ENC_NC;
 6a6:	4c11      	ldr	r4, [pc, #68]	; (6ec <ed25519_test+0x6ec>)
 6a8:	e50b      	b.n	c2 <ed25519_test+0xc2>
        return WC_TEST_RET_ENC_NC;
 6aa:	4c11      	ldr	r4, [pc, #68]	; (6f0 <ed25519_test+0x6f0>)
 6ac:	e509      	b.n	c2 <ed25519_test+0xc2>
 6ae:	bf00      	nop
	...
 6b8:	fffe7960 	.word	0xfffe7960
 6bc:	dfff8416 	.word	0xdfff8416
	...
 6c8:	dfff840a 	.word	0xdfff840a
 6cc:	dfff8406 	.word	0xdfff8406
 6d0:	00000000 	.word	0x00000000
 6d4:	dfff83fd 	.word	0xdfff83fd
 6d8:	00000000 	.word	0x00000000
 6dc:	dfff83f2 	.word	0xdfff83f2
 6e0:	dfff83ee 	.word	0xdfff83ee
 6e4:	ffff841a 	.word	0xffff841a
 6e8:	ffff8410 	.word	0xffff8410
 6ec:	ffff8403 	.word	0xffff8403
 6f0:	ffff83eb 	.word	0xffff83eb

Disassembly of section .text.logging_test:

00000000 <logging_test>:
{
   0:	b508      	push	{r3, lr}
    ret = wolfSSL_Debugging_ON();
   2:	f7ff fffe 	bl	0 <wolfSSL_Debugging_ON>
    if (ret != NOT_COMPILED_IN)
   6:	f110 0fae 	cmn.w	r0, #174	; 0xae
   a:	d007      	beq.n	1c <logging_test+0x1c>
        return WC_TEST_RET_ENC_EC(ret);
   c:	4240      	negs	r0, r0
   e:	4a0b      	ldr	r2, [pc, #44]	; (3c <logging_test+0x3c>)
  10:	4b0b      	ldr	r3, [pc, #44]	; (40 <logging_test+0x40>)
  12:	f3c0 000a 	ubfx	r0, r0, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  16:	fb02 3000 	mla	r0, r2, r0, r3
}
  1a:	bd08      	pop	{r3, pc}
    wolfSSL_Debugging_OFF();
  1c:	f7ff fffe 	bl	0 <wolfSSL_Debugging_OFF>
    ret = wolfSSL_SetLoggingCb(NULL);
  20:	2000      	movs	r0, #0
  22:	f7ff fffe 	bl	0 <wolfSSL_SetLoggingCb>
    if (ret != NOT_COMPILED_IN)
  26:	f110 0fae 	cmn.w	r0, #174	; 0xae
  2a:	d005      	beq.n	38 <logging_test+0x38>
        return WC_TEST_RET_ENC_EC(ret);
  2c:	4240      	negs	r0, r0
  2e:	4a03      	ldr	r2, [pc, #12]	; (3c <logging_test+0x3c>)
  30:	4b04      	ldr	r3, [pc, #16]	; (44 <logging_test+0x44>)
  32:	f3c0 000a 	ubfx	r0, r0, #0, #11
  36:	e7ee      	b.n	16 <logging_test+0x16>
    return 0;
  38:	2000      	movs	r0, #0
  3a:	e7ee      	b.n	1a <logging_test+0x1a>
  3c:	fffe7960 	.word	0xfffe7960
  40:	dfff488d 	.word	0xdfff488d
  44:	dfff4889 	.word	0xdfff4889

Disassembly of section .text.mutex_test:

00000000 <mutex_test>:
{
   0:	b510      	push	{r4, lr}
    wolfSSL_Mutex *mm = wc_InitAndAllocMutex();
   2:	f7ff fffe 	bl	0 <wc_InitAndAllocMutex>
    if (mm == NULL)
   6:	4604      	mov	r4, r0
   8:	b130      	cbz	r0, 18 <mutex_test+0x18>
    wc_FreeMutex(mm);
   a:	f7ff fffe 	bl	0 <wc_FreeMutex>
    XFREE(mm, HEAP_HINT, DYNAMIC_TYPE_MUTEX);
   e:	4620      	mov	r0, r4
  10:	f7ff fffe 	bl	0 <free>
    return 0;
  14:	2000      	movs	r0, #0
}
  16:	bd10      	pop	{r4, pc}
        return WC_TEST_RET_ENC_ERRNO;
  18:	4800      	ldr	r0, [pc, #0]	; (1c <mutex_test+0x1c>)
  1a:	e7fc      	b.n	16 <mutex_test+0x16>
  1c:	ffff4867 	.word	0xffff4867

Disassembly of section .text.time_test:

00000000 <time_test>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    ret = wc_SetTimeCb(time_cb);
   2:	481b      	ldr	r0, [pc, #108]	; (70 <time_test+0x70>)
   4:	f7ff fffe 	bl	0 <wc_SetTimeCb>
    if (ret != 0)
   8:	b148      	cbz	r0, 1e <time_test+0x1e>
        return WC_TEST_RET_ENC_EC(ret);
   a:	4243      	negs	r3, r0
   c:	4a19      	ldr	r2, [pc, #100]	; (74 <time_test+0x74>)
   e:	481a      	ldr	r0, [pc, #104]	; (78 <time_test+0x78>)
  10:	f3c3 030a 	ubfx	r3, r3, #0, #11
        return WC_TEST_RET_ENC_EC(ret);
  14:	fb02 0003 	mla	r0, r2, r3, r0
}
  18:	b003      	add	sp, #12
  1a:	f85d fb04 	ldr.w	pc, [sp], #4
    t = wc_Time(NULL);
  1e:	f7ff fffe 	bl	0 <wc_Time>
  22:	e9cd 0100 	strd	r0, r1, [sp]
    if (t != 99)
  26:	3863      	subs	r0, #99	; 0x63
  28:	ea50 0301 	orrs.w	r3, r0, r1
  2c:	d11b      	bne.n	66 <time_test+0x66>
    ret = wc_GetTime(&t, sizeof(time_t));
  2e:	2108      	movs	r1, #8
  30:	4668      	mov	r0, sp
  32:	f7ff fffe 	bl	0 <wc_GetTime>
    if (ret != 0)
  36:	b128      	cbz	r0, 44 <time_test+0x44>
        return WC_TEST_RET_ENC_EC(ret);
  38:	4243      	negs	r3, r0
  3a:	4a0e      	ldr	r2, [pc, #56]	; (74 <time_test+0x74>)
  3c:	480f      	ldr	r0, [pc, #60]	; (7c <time_test+0x7c>)
  3e:	f3c3 030a 	ubfx	r3, r3, #0, #11
  42:	e7e7      	b.n	14 <time_test+0x14>
    if (t != 99)
  44:	9b00      	ldr	r3, [sp, #0]
  46:	9a01      	ldr	r2, [sp, #4]
  48:	3b63      	subs	r3, #99	; 0x63
  4a:	4313      	orrs	r3, r2
  4c:	d10d      	bne.n	6a <time_test+0x6a>
    ret = wc_SetTimeCb(NULL);
  4e:	f7ff fffe 	bl	0 <wc_SetTimeCb>
    if (ret != 0)
  52:	2800      	cmp	r0, #0
  54:	d0e0      	beq.n	18 <time_test+0x18>
        return WC_TEST_RET_ENC_EC(ret);
  56:	4a07      	ldr	r2, [pc, #28]	; (74 <time_test+0x74>)
  58:	4b09      	ldr	r3, [pc, #36]	; (80 <time_test+0x80>)
  5a:	4240      	negs	r0, r0
  5c:	f3c0 000a 	ubfx	r0, r0, #0, #11
  60:	fb02 3000 	mla	r0, r2, r0, r3
  64:	e7d8      	b.n	18 <time_test+0x18>
        return WC_TEST_RET_ENC_NC;
  66:	4807      	ldr	r0, [pc, #28]	; (84 <time_test+0x84>)
  68:	e7d6      	b.n	18 <time_test+0x18>
        return WC_TEST_RET_ENC_NC;
  6a:	4807      	ldr	r0, [pc, #28]	; (88 <time_test+0x88>)
  6c:	e7d4      	b.n	18 <time_test+0x18>
  6e:	bf00      	nop
  70:	00000000 	.word	0x00000000
  74:	fffe7960 	.word	0xfffe7960
  78:	dfff4239 	.word	0xdfff4239
  7c:	dfff4233 	.word	0xdfff4233
  80:	dfff422e 	.word	0xdfff422e
  84:	ffff4236 	.word	0xffff4236
  88:	ffff4231 	.word	0xffff4231

Disassembly of section .text.wolfcrypt_test:

00000000 <wolfcrypt_test>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    printf("------------------------------------------------------------------------------\n");
   2:	4c9d      	ldr	r4, [pc, #628]	; (278 <wolfcrypt_test+0x278>)
{
   4:	4605      	mov	r5, r0
    printf("------------------------------------------------------------------------------\n");
   6:	489d      	ldr	r0, [pc, #628]	; (27c <wolfcrypt_test+0x27c>)
   8:	f7ff fffe 	bl	0 <printf>
   c:	6823      	ldr	r3, [r4, #0]
   e:	6898      	ldr	r0, [r3, #8]
  10:	f7ff fffe 	bl	0 <fflush>
    printf(" wolfSSL version %s\n", LIBWOLFSSL_VERSION_STRING);
  14:	499a      	ldr	r1, [pc, #616]	; (280 <wolfcrypt_test+0x280>)
  16:	489b      	ldr	r0, [pc, #620]	; (284 <wolfcrypt_test+0x284>)
  18:	f7ff fffe 	bl	0 <printf>
  1c:	6823      	ldr	r3, [r4, #0]
  1e:	6898      	ldr	r0, [r3, #8]
  20:	f7ff fffe 	bl	0 <fflush>
    printf("------------------------------------------------------------------------------\n");
  24:	4895      	ldr	r0, [pc, #596]	; (27c <wolfcrypt_test+0x27c>)
  26:	f7ff fffe 	bl	0 <printf>
  2a:	6823      	ldr	r3, [r4, #0]
  2c:	6898      	ldr	r0, [r3, #8]
  2e:	f7ff fffe 	bl	0 <fflush>
    if (args) {
  32:	b115      	cbz	r5, 3a <wolfcrypt_test+0x3a>
        ((func_args*)args)->return_code = -1; /* error state */
  34:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  38:	60ab      	str	r3, [r5, #8]
    if (CheckCtcSettings() != 1) {
  3a:	f7ff fffe 	bl	0 <CheckRunTimeSettings>
  3e:	2820      	cmp	r0, #32
  40:	d015      	beq.n	6e <wolfcrypt_test+0x6e>
        printf("Sizeof mismatch (build) %x != (run) %lx\n",
  42:	f7ff fffe 	bl	0 <CheckRunTimeSettings>
  46:	2120      	movs	r1, #32
  48:	4602      	mov	r2, r0
  4a:	488f      	ldr	r0, [pc, #572]	; (288 <wolfcrypt_test+0x288>)
  4c:	f7ff fffe 	bl	0 <printf>
  50:	6823      	ldr	r3, [r4, #0]
  52:	6898      	ldr	r0, [r3, #8]
  54:	f7ff fffe 	bl	0 <fflush>
    render_error_message(msg, es);
  58:	488c      	ldr	r0, [pc, #560]	; (28c <wolfcrypt_test+0x28c>)
  5a:	f46f 717c 	mvn.w	r1, #1008	; 0x3f0
  5e:	f7ff fffe 	bl	0 <wolfcrypt_test>
    print_fiducials();
  62:	f7ff fffe 	bl	0 <wolfcrypt_test>
        TEST_FAIL("mutex    test failed!\n", ret);
  66:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
}
  6a:	4620      	mov	r0, r4
  6c:	bd70      	pop	{r4, r5, r6, pc}
    if (CheckFastMathSettings() != 1)
  6e:	f7ff fffe 	bl	0 <CheckRunTimeFastMath>
  72:	2818      	cmp	r0, #24
  74:	d002      	beq.n	7c <wolfcrypt_test+0x7c>
    render_error_message(msg, es);
  76:	4986      	ldr	r1, [pc, #536]	; (290 <wolfcrypt_test+0x290>)
  78:	4886      	ldr	r0, [pc, #536]	; (294 <wolfcrypt_test+0x294>)
  7a:	e7f0      	b.n	5e <wolfcrypt_test+0x5e>
    if ( (ret = error_test()) != 0)
  7c:	f7ff fffe 	bl	0 <wolfcrypt_test>
  80:	4601      	mov	r1, r0
  82:	b108      	cbz	r0, 88 <wolfcrypt_test+0x88>
    render_error_message(msg, es);
  84:	4884      	ldr	r0, [pc, #528]	; (298 <wolfcrypt_test+0x298>)
  86:	e7ea      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("error    test passed!\n");
  88:	4884      	ldr	r0, [pc, #528]	; (29c <wolfcrypt_test+0x29c>)
  8a:	f7ff fffe 	bl	0 <printf>
  8e:	6823      	ldr	r3, [r4, #0]
  90:	6898      	ldr	r0, [r3, #8]
  92:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = memory_test()) != 0)
  96:	f7ff fffe 	bl	0 <wolfcrypt_test>
  9a:	4601      	mov	r1, r0
  9c:	b108      	cbz	r0, a2 <wolfcrypt_test+0xa2>
    render_error_message(msg, es);
  9e:	4880      	ldr	r0, [pc, #512]	; (2a0 <wolfcrypt_test+0x2a0>)
  a0:	e7dd      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("MEMORY   test passed!\n");
  a2:	4880      	ldr	r0, [pc, #512]	; (2a4 <wolfcrypt_test+0x2a4>)
  a4:	f7ff fffe 	bl	0 <printf>
  a8:	6823      	ldr	r3, [r4, #0]
  aa:	6898      	ldr	r0, [r3, #8]
  ac:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = base64_test()) != 0)
  b0:	f7ff fffe 	bl	0 <wolfcrypt_test>
  b4:	4601      	mov	r1, r0
  b6:	b108      	cbz	r0, bc <wolfcrypt_test+0xbc>
    render_error_message(msg, es);
  b8:	487b      	ldr	r0, [pc, #492]	; (2a8 <wolfcrypt_test+0x2a8>)
  ba:	e7d0      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("base64   test passed!\n");
  bc:	487b      	ldr	r0, [pc, #492]	; (2ac <wolfcrypt_test+0x2ac>)
  be:	f7ff fffe 	bl	0 <printf>
  c2:	6823      	ldr	r3, [r4, #0]
  c4:	6898      	ldr	r0, [r3, #8]
  c6:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = asn_test()) != 0)
  ca:	f7ff fffe 	bl	0 <wolfcrypt_test>
  ce:	4601      	mov	r1, r0
  d0:	b108      	cbz	r0, d6 <wolfcrypt_test+0xd6>
    render_error_message(msg, es);
  d2:	4877      	ldr	r0, [pc, #476]	; (2b0 <wolfcrypt_test+0x2b0>)
  d4:	e7c3      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("asn      test passed!\n");
  d6:	4877      	ldr	r0, [pc, #476]	; (2b4 <wolfcrypt_test+0x2b4>)
  d8:	f7ff fffe 	bl	0 <printf>
  dc:	6823      	ldr	r3, [r4, #0]
  de:	6898      	ldr	r0, [r3, #8]
  e0:	f7ff fffe 	bl	0 <fflush>
    return random_rng_test();
  e4:	f7ff fffe 	bl	0 <wolfcrypt_test>
    if ( (ret = random_test()) != 0)
  e8:	4601      	mov	r1, r0
  ea:	b108      	cbz	r0, f0 <wolfcrypt_test+0xf0>
    render_error_message(msg, es);
  ec:	4872      	ldr	r0, [pc, #456]	; (2b8 <wolfcrypt_test+0x2b8>)
  ee:	e7b6      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("RANDOM   test passed!\n");
  f0:	4872      	ldr	r0, [pc, #456]	; (2bc <wolfcrypt_test+0x2bc>)
  f2:	f7ff fffe 	bl	0 <printf>
  f6:	6823      	ldr	r3, [r4, #0]
  f8:	6898      	ldr	r0, [r3, #8]
  fa:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = sha_test()) != 0)
  fe:	f7ff fffe 	bl	0 <wolfcrypt_test>
 102:	4601      	mov	r1, r0
 104:	b108      	cbz	r0, 10a <wolfcrypt_test+0x10a>
    render_error_message(msg, es);
 106:	486e      	ldr	r0, [pc, #440]	; (2c0 <wolfcrypt_test+0x2c0>)
 108:	e7a9      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("SHA      test passed!\n");
 10a:	486e      	ldr	r0, [pc, #440]	; (2c4 <wolfcrypt_test+0x2c4>)
 10c:	f7ff fffe 	bl	0 <printf>
 110:	6823      	ldr	r3, [r4, #0]
 112:	6898      	ldr	r0, [r3, #8]
 114:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = sha256_test()) != 0)
 118:	f7ff fffe 	bl	0 <wolfcrypt_test>
 11c:	4601      	mov	r1, r0
 11e:	b108      	cbz	r0, 124 <wolfcrypt_test+0x124>
    render_error_message(msg, es);
 120:	4869      	ldr	r0, [pc, #420]	; (2c8 <wolfcrypt_test+0x2c8>)
 122:	e79c      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("SHA-256  test passed!\n");
 124:	4869      	ldr	r0, [pc, #420]	; (2cc <wolfcrypt_test+0x2cc>)
 126:	f7ff fffe 	bl	0 <printf>
 12a:	6823      	ldr	r3, [r4, #0]
 12c:	6898      	ldr	r0, [r3, #8]
 12e:	f7ff fffe 	bl	0 <fflush>
    if ((ret = sha512_test()) != 0) {
 132:	f7ff fffe 	bl	0 <wolfcrypt_test>
 136:	4601      	mov	r1, r0
 138:	b108      	cbz	r0, 13e <wolfcrypt_test+0x13e>
    render_error_message(msg, es);
 13a:	4865      	ldr	r0, [pc, #404]	; (2d0 <wolfcrypt_test+0x2d0>)
 13c:	e78f      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("SHA-512  test passed!\n");
 13e:	4865      	ldr	r0, [pc, #404]	; (2d4 <wolfcrypt_test+0x2d4>)
 140:	f7ff fffe 	bl	0 <printf>
 144:	6823      	ldr	r3, [r4, #0]
 146:	6898      	ldr	r0, [r3, #8]
 148:	f7ff fffe 	bl	0 <fflush>
    if ((ret = sha512_224_test()) != 0) {
 14c:	f7ff fffe 	bl	0 <wolfcrypt_test>
 150:	4601      	mov	r1, r0
 152:	b108      	cbz	r0, 158 <wolfcrypt_test+0x158>
    render_error_message(msg, es);
 154:	4860      	ldr	r0, [pc, #384]	; (2d8 <wolfcrypt_test+0x2d8>)
 156:	e782      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("SHA-512/224  test passed!\n");
 158:	4860      	ldr	r0, [pc, #384]	; (2dc <wolfcrypt_test+0x2dc>)
 15a:	f7ff fffe 	bl	0 <printf>
 15e:	6823      	ldr	r3, [r4, #0]
 160:	6898      	ldr	r0, [r3, #8]
 162:	f7ff fffe 	bl	0 <fflush>
    if ((ret = sha512_256_test()) != 0) {
 166:	f7ff fffe 	bl	0 <wolfcrypt_test>
 16a:	4601      	mov	r1, r0
 16c:	b108      	cbz	r0, 172 <wolfcrypt_test+0x172>
    render_error_message(msg, es);
 16e:	485c      	ldr	r0, [pc, #368]	; (2e0 <wolfcrypt_test+0x2e0>)
 170:	e775      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("SHA-512/256  test passed!\n");
 172:	485c      	ldr	r0, [pc, #368]	; (2e4 <wolfcrypt_test+0x2e4>)
 174:	f7ff fffe 	bl	0 <printf>
 178:	6823      	ldr	r3, [r4, #0]
 17a:	6898      	ldr	r0, [r3, #8]
 17c:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = hash_test()) != 0)
 180:	f7ff fffe 	bl	0 <wolfcrypt_test>
 184:	4601      	mov	r1, r0
 186:	b108      	cbz	r0, 18c <wolfcrypt_test+0x18c>
    render_error_message(msg, es);
 188:	4857      	ldr	r0, [pc, #348]	; (2e8 <wolfcrypt_test+0x2e8>)
 18a:	e768      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("Hash     test passed!\n");
 18c:	4857      	ldr	r0, [pc, #348]	; (2ec <wolfcrypt_test+0x2ec>)
 18e:	f7ff fffe 	bl	0 <printf>
 192:	6823      	ldr	r3, [r4, #0]
 194:	6898      	ldr	r0, [r3, #8]
 196:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = hmac_sha_test()) != 0)
 19a:	f7ff fffe 	bl	0 <wolfcrypt_test>
 19e:	4601      	mov	r1, r0
 1a0:	b108      	cbz	r0, 1a6 <wolfcrypt_test+0x1a6>
    render_error_message(msg, es);
 1a2:	4853      	ldr	r0, [pc, #332]	; (2f0 <wolfcrypt_test+0x2f0>)
 1a4:	e75b      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("HMAC-SHA test passed!\n");
 1a6:	4853      	ldr	r0, [pc, #332]	; (2f4 <wolfcrypt_test+0x2f4>)
 1a8:	f7ff fffe 	bl	0 <printf>
 1ac:	6823      	ldr	r3, [r4, #0]
 1ae:	6898      	ldr	r0, [r3, #8]
 1b0:	f7ff fffe 	bl	0 <fflush>
        if ( (ret = hmac_sha256_test()) != 0)
 1b4:	f7ff fffe 	bl	0 <wolfcrypt_test>
 1b8:	4601      	mov	r1, r0
 1ba:	b108      	cbz	r0, 1c0 <wolfcrypt_test+0x1c0>
    render_error_message(msg, es);
 1bc:	484e      	ldr	r0, [pc, #312]	; (2f8 <wolfcrypt_test+0x2f8>)
 1be:	e74e      	b.n	5e <wolfcrypt_test+0x5e>
            TEST_PASS("HMAC-SHA256 test passed!\n");
 1c0:	484e      	ldr	r0, [pc, #312]	; (2fc <wolfcrypt_test+0x2fc>)
 1c2:	f7ff fffe 	bl	0 <printf>
 1c6:	6823      	ldr	r3, [r4, #0]
 1c8:	6898      	ldr	r0, [r3, #8]
 1ca:	f7ff fffe 	bl	0 <fflush>
        if ( (ret = hmac_sha512_test()) != 0)
 1ce:	f7ff fffe 	bl	0 <wolfcrypt_test>
 1d2:	4601      	mov	r1, r0
 1d4:	b108      	cbz	r0, 1da <wolfcrypt_test+0x1da>
    render_error_message(msg, es);
 1d6:	484a      	ldr	r0, [pc, #296]	; (300 <wolfcrypt_test+0x300>)
 1d8:	e741      	b.n	5e <wolfcrypt_test+0x5e>
            TEST_PASS("HMAC-SHA512 test passed!\n");
 1da:	484a      	ldr	r0, [pc, #296]	; (304 <wolfcrypt_test+0x304>)
 1dc:	f7ff fffe 	bl	0 <printf>
 1e0:	6823      	ldr	r3, [r4, #0]
 1e2:	6898      	ldr	r0, [r3, #8]
 1e4:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = gmac_test()) != 0)
 1e8:	f7ff fffe 	bl	0 <wolfcrypt_test>
 1ec:	4601      	mov	r1, r0
 1ee:	b108      	cbz	r0, 1f4 <wolfcrypt_test+0x1f4>
    render_error_message(msg, es);
 1f0:	4845      	ldr	r0, [pc, #276]	; (308 <wolfcrypt_test+0x308>)
 1f2:	e734      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("GMAC     test passed!\n");
 1f4:	4845      	ldr	r0, [pc, #276]	; (30c <wolfcrypt_test+0x30c>)
 1f6:	f7ff fffe 	bl	0 <printf>
 1fa:	6823      	ldr	r3, [r4, #0]
 1fc:	6898      	ldr	r0, [r3, #8]
 1fe:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = des_test()) != 0)
 202:	f7ff fffe 	bl	0 <wolfcrypt_test>
 206:	4601      	mov	r1, r0
 208:	b108      	cbz	r0, 20e <wolfcrypt_test+0x20e>
    render_error_message(msg, es);
 20a:	4841      	ldr	r0, [pc, #260]	; (310 <wolfcrypt_test+0x310>)
 20c:	e727      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("DES      test passed!\n");
 20e:	4841      	ldr	r0, [pc, #260]	; (314 <wolfcrypt_test+0x314>)
 210:	f7ff fffe 	bl	0 <printf>
 214:	6823      	ldr	r3, [r4, #0]
 216:	6898      	ldr	r0, [r3, #8]
 218:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = des3_test()) != 0)
 21c:	f7ff fffe 	bl	0 <wolfcrypt_test>
 220:	4601      	mov	r1, r0
 222:	b108      	cbz	r0, 228 <wolfcrypt_test+0x228>
    render_error_message(msg, es);
 224:	483c      	ldr	r0, [pc, #240]	; (318 <wolfcrypt_test+0x318>)
 226:	e71a      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("DES3     test passed!\n");
 228:	483c      	ldr	r0, [pc, #240]	; (31c <wolfcrypt_test+0x31c>)
 22a:	f7ff fffe 	bl	0 <printf>
 22e:	6823      	ldr	r3, [r4, #0]
 230:	6898      	ldr	r0, [r3, #8]
 232:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = aes_test()) != 0)
 236:	f7ff fffe 	bl	0 <wolfcrypt_test>
 23a:	4601      	mov	r1, r0
 23c:	b108      	cbz	r0, 242 <wolfcrypt_test+0x242>
    render_error_message(msg, es);
 23e:	4838      	ldr	r0, [pc, #224]	; (320 <wolfcrypt_test+0x320>)
 240:	e70d      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("AES      test passed!\n");
 242:	4838      	ldr	r0, [pc, #224]	; (324 <wolfcrypt_test+0x324>)
 244:	f7ff fffe 	bl	0 <printf>
 248:	6823      	ldr	r3, [r4, #0]
 24a:	6898      	ldr	r0, [r3, #8]
 24c:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = aes192_test()) != 0)
 250:	f7ff fffe 	bl	0 <wolfcrypt_test>
 254:	4601      	mov	r1, r0
 256:	b108      	cbz	r0, 25c <wolfcrypt_test+0x25c>
    render_error_message(msg, es);
 258:	4833      	ldr	r0, [pc, #204]	; (328 <wolfcrypt_test+0x328>)
 25a:	e700      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("AES192   test passed!\n");
 25c:	4833      	ldr	r0, [pc, #204]	; (32c <wolfcrypt_test+0x32c>)
 25e:	f7ff fffe 	bl	0 <printf>
 262:	6823      	ldr	r3, [r4, #0]
 264:	6898      	ldr	r0, [r3, #8]
 266:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = aes256_test()) != 0)
 26a:	f7ff fffe 	bl	0 <wolfcrypt_test>
 26e:	4601      	mov	r1, r0
 270:	2800      	cmp	r0, #0
 272:	d05f      	beq.n	334 <wolfcrypt_test+0x334>
    render_error_message(msg, es);
 274:	482e      	ldr	r0, [pc, #184]	; (330 <wolfcrypt_test+0x330>)
 276:	e6f2      	b.n	5e <wolfcrypt_test+0x5e>
	...
 280:	00000050 	.word	0x00000050
 284:	00000056 	.word	0x00000056
 288:	0000006b 	.word	0x0000006b
 28c:	00000094 	.word	0x00000094
 290:	fffffc08 	.word	0xfffffc08
 294:	000000b4 	.word	0x000000b4
 298:	000000e4 	.word	0x000000e4
 29c:	000000fb 	.word	0x000000fb
 2a0:	00000112 	.word	0x00000112
 2a4:	00000129 	.word	0x00000129
 2a8:	00000140 	.word	0x00000140
 2ac:	00000157 	.word	0x00000157
 2b0:	0000016e 	.word	0x0000016e
 2b4:	00000185 	.word	0x00000185
 2b8:	0000019c 	.word	0x0000019c
 2bc:	000001b3 	.word	0x000001b3
 2c0:	000001ca 	.word	0x000001ca
 2c4:	000001e1 	.word	0x000001e1
 2c8:	000001f8 	.word	0x000001f8
 2cc:	0000020f 	.word	0x0000020f
 2d0:	00000226 	.word	0x00000226
 2d4:	0000023d 	.word	0x0000023d
 2d8:	00000254 	.word	0x00000254
 2dc:	0000026f 	.word	0x0000026f
 2e0:	0000028a 	.word	0x0000028a
 2e4:	000002a5 	.word	0x000002a5
 2e8:	000002c0 	.word	0x000002c0
 2ec:	000002d7 	.word	0x000002d7
 2f0:	000002ee 	.word	0x000002ee
 2f4:	00000305 	.word	0x00000305
 2f8:	0000031c 	.word	0x0000031c
 2fc:	00000336 	.word	0x00000336
 300:	00000350 	.word	0x00000350
 304:	0000036a 	.word	0x0000036a
 308:	00000384 	.word	0x00000384
 30c:	0000039b 	.word	0x0000039b
 310:	000003b2 	.word	0x000003b2
 314:	000003c9 	.word	0x000003c9
 318:	000003e0 	.word	0x000003e0
 31c:	000003f7 	.word	0x000003f7
 320:	0000040e 	.word	0x0000040e
 324:	00000425 	.word	0x00000425
 328:	0000043c 	.word	0x0000043c
 32c:	00000453 	.word	0x00000453
 330:	0000046a 	.word	0x0000046a
        TEST_PASS("AES256   test passed!\n");
 334:	483f      	ldr	r0, [pc, #252]	; (434 <wolfcrypt_test+0x434>)
 336:	f7ff fffe 	bl	0 <printf>
 33a:	6823      	ldr	r3, [r4, #0]
 33c:	6898      	ldr	r0, [r3, #8]
 33e:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = aesgcm_test()) != 0)
 342:	f7ff fffe 	bl	0 <wolfcrypt_test>
 346:	4601      	mov	r1, r0
 348:	b108      	cbz	r0, 34e <wolfcrypt_test+0x34e>
    render_error_message(msg, es);
 34a:	483b      	ldr	r0, [pc, #236]	; (438 <wolfcrypt_test+0x438>)
 34c:	e687      	b.n	5e <wolfcrypt_test+0x5e>
    if ((ret = aesgcm_default_test()) != 0) {
 34e:	f7ff fffe 	bl	0 <wolfcrypt_test>
 352:	4601      	mov	r1, r0
 354:	2800      	cmp	r0, #0
 356:	d1f8      	bne.n	34a <wolfcrypt_test+0x34a>
        TEST_PASS("AES-GCM  test passed!\n");
 358:	4838      	ldr	r0, [pc, #224]	; (43c <wolfcrypt_test+0x43c>)
 35a:	f7ff fffe 	bl	0 <printf>
 35e:	6823      	ldr	r3, [r4, #0]
 360:	6898      	ldr	r0, [r3, #8]
 362:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = ecc_test()) != 0)
 366:	f7ff fffe 	bl	0 <wolfcrypt_test>
 36a:	4601      	mov	r1, r0
 36c:	b108      	cbz	r0, 372 <wolfcrypt_test+0x372>
    render_error_message(msg, es);
 36e:	4834      	ldr	r0, [pc, #208]	; (440 <wolfcrypt_test+0x440>)
 370:	e675      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("ECC      test passed!\n");
 372:	4834      	ldr	r0, [pc, #208]	; (444 <wolfcrypt_test+0x444>)
 374:	f7ff fffe 	bl	0 <printf>
 378:	6823      	ldr	r3, [r4, #0]
 37a:	6898      	ldr	r0, [r3, #8]
 37c:	f7ff fffe 	bl	0 <fflush>
        if ( (ret = ecc_test_buffers()) != 0)
 380:	f7ff fffe 	bl	0 <wolfcrypt_test>
 384:	4601      	mov	r1, r0
 386:	b108      	cbz	r0, 38c <wolfcrypt_test+0x38c>
    render_error_message(msg, es);
 388:	482f      	ldr	r0, [pc, #188]	; (448 <wolfcrypt_test+0x448>)
 38a:	e668      	b.n	5e <wolfcrypt_test+0x5e>
            TEST_PASS("ECC buffer test passed!\n");
 38c:	482f      	ldr	r0, [pc, #188]	; (44c <wolfcrypt_test+0x44c>)
 38e:	f7ff fffe 	bl	0 <printf>
 392:	6823      	ldr	r3, [r4, #0]
 394:	6898      	ldr	r0, [r3, #8]
 396:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = curve25519_test()) != 0)
 39a:	f7ff fffe 	bl	0 <wolfcrypt_test>
 39e:	4601      	mov	r1, r0
 3a0:	b108      	cbz	r0, 3a6 <wolfcrypt_test+0x3a6>
    render_error_message(msg, es);
 3a2:	482b      	ldr	r0, [pc, #172]	; (450 <wolfcrypt_test+0x450>)
 3a4:	e65b      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("CURVE25519 test passed!\n");
 3a6:	482b      	ldr	r0, [pc, #172]	; (454 <wolfcrypt_test+0x454>)
 3a8:	f7ff fffe 	bl	0 <printf>
 3ac:	6823      	ldr	r3, [r4, #0]
 3ae:	6898      	ldr	r0, [r3, #8]
 3b0:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = ed25519_test()) != 0)
 3b4:	f7ff fffe 	bl	0 <wolfcrypt_test>
 3b8:	4601      	mov	r1, r0
 3ba:	b108      	cbz	r0, 3c0 <wolfcrypt_test+0x3c0>
    render_error_message(msg, es);
 3bc:	4826      	ldr	r0, [pc, #152]	; (458 <wolfcrypt_test+0x458>)
 3be:	e64e      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("ED25519  test passed!\n");
 3c0:	4826      	ldr	r0, [pc, #152]	; (45c <wolfcrypt_test+0x45c>)
 3c2:	f7ff fffe 	bl	0 <printf>
 3c6:	6823      	ldr	r3, [r4, #0]
 3c8:	6898      	ldr	r0, [r3, #8]
 3ca:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = logging_test()) != 0)
 3ce:	f7ff fffe 	bl	0 <wolfcrypt_test>
 3d2:	4601      	mov	r1, r0
 3d4:	b108      	cbz	r0, 3da <wolfcrypt_test+0x3da>
    render_error_message(msg, es);
 3d6:	4822      	ldr	r0, [pc, #136]	; (460 <wolfcrypt_test+0x460>)
 3d8:	e641      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("logging  test passed!\n");
 3da:	4822      	ldr	r0, [pc, #136]	; (464 <wolfcrypt_test+0x464>)
 3dc:	f7ff fffe 	bl	0 <printf>
 3e0:	6823      	ldr	r3, [r4, #0]
 3e2:	6898      	ldr	r0, [r3, #8]
 3e4:	f7ff fffe 	bl	0 <fflush>
    if ( (ret = time_test()) != 0)
 3e8:	f7ff fffe 	bl	0 <wolfcrypt_test>
 3ec:	4601      	mov	r1, r0
 3ee:	b108      	cbz	r0, 3f4 <wolfcrypt_test+0x3f4>
    render_error_message(msg, es);
 3f0:	481d      	ldr	r0, [pc, #116]	; (468 <wolfcrypt_test+0x468>)
 3f2:	e634      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("time test passed!\n");
 3f4:	4e1d      	ldr	r6, [pc, #116]	; (46c <wolfcrypt_test+0x46c>)
 3f6:	481e      	ldr	r0, [pc, #120]	; (470 <wolfcrypt_test+0x470>)
 3f8:	f7ff fffe 	bl	0 <printf>
 3fc:	6833      	ldr	r3, [r6, #0]
 3fe:	6898      	ldr	r0, [r3, #8]
 400:	f7ff fffe 	bl	0 <fflush>
    if ((ret = mutex_test()) != 0)
 404:	f7ff fffe 	bl	0 <wolfcrypt_test>
 408:	4604      	mov	r4, r0
 40a:	b110      	cbz	r0, 412 <wolfcrypt_test+0x412>
    render_error_message(msg, es);
 40c:	4601      	mov	r1, r0
 40e:	4819      	ldr	r0, [pc, #100]	; (474 <wolfcrypt_test+0x474>)
 410:	e625      	b.n	5e <wolfcrypt_test+0x5e>
        TEST_PASS("mutex    test passed!\n");
 412:	4819      	ldr	r0, [pc, #100]	; (478 <wolfcrypt_test+0x478>)
 414:	f7ff fffe 	bl	0 <printf>
 418:	6833      	ldr	r3, [r6, #0]
 41a:	6898      	ldr	r0, [r3, #8]
 41c:	f7ff fffe 	bl	0 <fflush>
    if (args)
 420:	b105      	cbz	r5, 424 <wolfcrypt_test+0x424>
        ((func_args*)args)->return_code = ret;
 422:	60ac      	str	r4, [r5, #8]
    TEST_PASS("Test complete\n");
 424:	4815      	ldr	r0, [pc, #84]	; (47c <wolfcrypt_test+0x47c>)
 426:	f7ff fffe 	bl	0 <printf>
 42a:	6833      	ldr	r3, [r6, #0]
 42c:	6898      	ldr	r0, [r3, #8]
 42e:	f7ff fffe 	bl	0 <fflush>
    EXIT_TEST(ret);
 432:	e61a      	b.n	6a <wolfcrypt_test+0x6a>
 434:	00000481 	.word	0x00000481
 438:	00000498 	.word	0x00000498
 43c:	000004af 	.word	0x000004af
 440:	000004c6 	.word	0x000004c6
 444:	000004dd 	.word	0x000004dd
 448:	000004f4 	.word	0x000004f4
 44c:	0000050d 	.word	0x0000050d
 450:	00000526 	.word	0x00000526
 454:	0000053f 	.word	0x0000053f
 458:	00000558 	.word	0x00000558
 45c:	0000056f 	.word	0x0000056f
 460:	00000586 	.word	0x00000586
 464:	0000059d 	.word	0x0000059d
 468:	000005b4 	.word	0x000005b4
 46c:	00000000 	.word	0x00000000
 470:	000005c7 	.word	0x000005c7
 474:	000005da 	.word	0x000005da
 478:	000005f1 	.word	0x000005f1
 47c:	00000608 	.word	0x00000608

benchmark.o:     file format elf32-littlearm


Disassembly of section .text.bench_stats_start:

00000000 <bench_stats_start>:
#endif
    INIT_CYCLE_COUNTER
}

static WC_INLINE void bench_stats_start(int* count, double* start)
{
   0:	b510      	push	{r4, lr}
    *count = 0;
   2:	2300      	movs	r3, #0
   4:	6003      	str	r3, [r0, #0]
    *start = current_time(1);
   6:	2001      	movs	r0, #1
{
   8:	460c      	mov	r4, r1
    *start = current_time(1);
   a:	f7ff fffe 	bl	0 <current_time>
   e:	e9c4 0100 	strd	r0, r1, [r4]

    BEGIN_ESP_CYCLES
#else
    BEGIN_INTEL_CYCLES
#endif
}
  12:	bd10      	pop	{r4, pc}

Disassembly of section .text.bench_stats_check:

00000000 <bench_stats_check>:
        bench_stats_start(count, start);                                       \
    } while (0)
#endif

static WC_INLINE int bench_stats_check(double start)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
    return ((current_time(0) - start) < BENCH_MIN_RUNTIME_SEC);
   6:	2000      	movs	r0, #0
   8:	f7ff fffe 	bl	0 <current_time>
   c:	4622      	mov	r2, r4
   e:	462b      	mov	r3, r5
  10:	f7ff fffe 	bl	0 <__aeabi_dsub>
  14:	4b03      	ldr	r3, [pc, #12]	; (24 <bench_stats_check+0x24>)
  16:	2200      	movs	r2, #0
  18:	f7ff fffe 	bl	0 <__aeabi_dcmplt>
}
  1c:	3800      	subs	r0, #0
  1e:	bf18      	it	ne
  20:	2001      	movne	r0, #1
  22:	bd38      	pop	{r3, r4, r5, pc}
  24:	3ff00000 	.word	0x3ff00000

Disassembly of section .text.bench_stats_asym_finish_ex.constprop.0:

00000000 <bench_stats_asym_finish_ex.constprop.0>:
#ifdef BENCH_ASYM
#if defined(HAVE_ECC) || !defined(NO_RSA) || !defined(NO_DH) || \
    defined(HAVE_CURVE25519) || defined(HAVE_ED25519) || \
    defined(HAVE_CURVE448) || defined(HAVE_ED448) || \
    defined(WOLFSSL_HAVE_KYBER)
static void bench_stats_asym_finish_ex(const char* algo, int strength,
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b0db      	sub	sp, #364	; 0x16c
   6:	4605      	mov	r5, r0
   8:	460f      	mov	r7, r1
   a:	4616      	mov	r6, r2
    const char* kOpsSec = "Ops/Sec";
#endif
    char msg[256];
    static int asym_header_printed = 0;

    XMEMSET(msg, 0, sizeof(msg));
   c:	2100      	movs	r1, #0
   e:	f44f 7280 	mov.w	r2, #256	; 0x100
  12:	a81a      	add	r0, sp, #104	; 0x68
static void bench_stats_asym_finish_ex(const char* algo, int strength,
  14:	461c      	mov	r4, r3
    XMEMSET(msg, 0, sizeof(msg));
  16:	f7ff fffe 	bl	0 <memset>

    total = current_time(0) - start;
  1a:	2000      	movs	r0, #0
  1c:	f7ff fffe 	bl	0 <current_time>
  20:	e9dd 2364 	ldrd	r2, r3, [sp, #400]	; 0x190
  24:	f7ff fffe 	bl	0 <__aeabi_dsub>
        END_INTEL_CYCLES
    #endif
#endif

    /* some sanity checks on the final numbers */
    if (count > 0) {
  28:	2c00      	cmp	r4, #0
    total = current_time(0) - start;
  2a:	4680      	mov	r8, r0
  2c:	4689      	mov	r9, r1
    if (count > 0) {
  2e:	dd5b      	ble.n	e8 <bench_stats_asym_finish_ex.constprop.0+0xe8>
        each  = total / count; /* per second  */
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <__aeabi_i2d>
  36:	4602      	mov	r2, r0
  38:	460b      	mov	r3, r1
  3a:	4640      	mov	r0, r8
  3c:	4649      	mov	r1, r9
  3e:	f7ff fffe 	bl	0 <__aeabi_ddiv>
  42:	4682      	mov	sl, r0
  44:	468b      	mov	fp, r1
    else {
        count = 0;
        each = 0;
    }

    if (total > 0) {
  46:	2200      	movs	r2, #0
  48:	2300      	movs	r3, #0
  4a:	4640      	mov	r0, r8
  4c:	4649      	mov	r1, r9
  4e:	f7ff fffe 	bl	0 <__aeabi_dcmpgt>
  52:	2800      	cmp	r0, #0
  54:	d04e      	beq.n	f4 <bench_stats_asym_finish_ex.constprop.0+0xf4>
        opsSec = count / total;    /* ops second */
  56:	4620      	mov	r0, r4
  58:	f7ff fffe 	bl	0 <__aeabi_i2d>
  5c:	4642      	mov	r2, r8
  5e:	464b      	mov	r3, r9
  60:	f7ff fffe 	bl	0 <__aeabi_ddiv>
  64:	e9cd 0116 	strd	r0, r1, [sp, #88]	; 0x58
    }
    else {
        opsSec = 0;
    }

    milliEach = each * 1000;   /* milliseconds */
  68:	4b38      	ldr	r3, [pc, #224]	; (14c <bench_stats_asym_finish_ex.constprop.0+0x14c>)
  6a:	4650      	mov	r0, sl
  6c:	4659      	mov	r1, fp
  6e:	2200      	movs	r2, #0
  70:	f7ff fffe 	bl	0 <__aeabi_dmul>

    SLEEP_ON_ERROR(ret);
    /* format and print to terminal */
    if (csv_format == 1) {
  74:	4b36      	ldr	r3, [pc, #216]	; (150 <bench_stats_asym_finish_ex.constprop.0+0x150>)
  76:	681b      	ldr	r3, [r3, #0]
  78:	2b01      	cmp	r3, #1
    milliEach = each * 1000;   /* milliseconds */
  7a:	4682      	mov	sl, r0
  7c:	468b      	mov	fp, r1
    if (csv_format == 1) {
  7e:	d13e      	bne.n	fe <bench_stats_asym_finish_ex.constprop.0+0xfe>
        /* only print out header once */
        if (asym_header_printed == 0) {
  80:	4c34      	ldr	r4, [pc, #208]	; (154 <bench_stats_asym_finish_ex.constprop.0+0x154>)
  82:	6822      	ldr	r2, [r4, #0]
  84:	b952      	cbnz	r2, 9c <bench_stats_asym_finish_ex.constprop.0+0x9c>
    #else
            printf("%s", "\"asym\",Algorithm,key size,operation,avg ms,ops/sec,"
                   "ops,secs\n");
    #endif
#else
            printf("\n%sAsymmetric Ciphers:\n\n", info_prefix);
  86:	4934      	ldr	r1, [pc, #208]	; (158 <bench_stats_asym_finish_ex.constprop.0+0x158>)
  88:	4834      	ldr	r0, [pc, #208]	; (15c <bench_stats_asym_finish_ex.constprop.0+0x15c>)
  8a:	9319      	str	r3, [sp, #100]	; 0x64
  8c:	f7ff fffe 	bl	0 <printf>
            printf("%sAlgorithm,key size,operation,avg ms,ops/sec,\n",
  90:	4931      	ldr	r1, [pc, #196]	; (158 <bench_stats_asym_finish_ex.constprop.0+0x158>)
  92:	4833      	ldr	r0, [pc, #204]	; (160 <bench_stats_asym_finish_ex.constprop.0+0x160>)
  94:	f7ff fffe 	bl	0 <printf>
                   info_prefix);
#endif
            asym_header_printed = 1;
  98:	9b19      	ldr	r3, [sp, #100]	; 0x64
  9a:	6023      	str	r3, [r4, #0]
                        FLT_FMT_PREC_ARGS(3, milliEach),
                        FLT_FMT_PREC_ARGS(3, opsSec),
                        count, FLT_FMT_ARGS(total));
    #endif
#else
        (void)XSNPRINTF(msg, sizeof(msg), "%s,%d,%s%s," FLT_FMT_PREC ","
  9c:	e9dd 3416 	ldrd	r3, r4, [sp, #88]	; 0x58
  a0:	e9cd 3408 	strd	r3, r4, [sp, #32]
  a4:	2303      	movs	r3, #3
  a6:	9306      	str	r3, [sp, #24]
  a8:	9303      	str	r3, [sp, #12]
  aa:	4b2e      	ldr	r3, [pc, #184]	; (164 <bench_stats_asym_finish_ex.constprop.0+0x164>)
  ac:	4a2e      	ldr	r2, [pc, #184]	; (168 <bench_stats_asym_finish_ex.constprop.0+0x168>)
  ae:	9700      	str	r7, [sp, #0]
  b0:	e9cd 6301 	strd	r6, r3, [sp, #4]
  b4:	e9cd ab04 	strd	sl, fp, [sp, #16]
  b8:	462b      	mov	r3, r5
  ba:	f44f 7180 	mov.w	r1, #256	; 0x100
  be:	a81a      	add	r0, sp, #104	; 0x68
  c0:	f7ff fffe 	bl	0 <snprintf>
                        FLT_FMT_PREC2_ARGS(5, 3, total), word[1], word[2],
                        FLT_FMT_PREC2_ARGS(5, 3, milliEach),
                        FLT_FMT_PREC_ARGS(3, opsSec), word[3]);
#endif
    }
    printf("%s", msg);
  c4:	4829      	ldr	r0, [pc, #164]	; (16c <bench_stats_asym_finish_ex.constprop.0+0x16c>)
  c6:	a91a      	add	r1, sp, #104	; 0x68
  c8:	f7ff fffe 	bl	0 <printf>

    /* show errors */
    if (ret < 0) {
  cc:	9b66      	ldr	r3, [sp, #408]	; 0x198
  ce:	2b00      	cmp	r3, #0
  d0:	da07      	bge.n	e2 <bench_stats_asym_finish_ex.constprop.0+0xe2>
        printf("%sBenchmark %s %s %d failed: %d\n",
  d2:	e9cd 7300 	strd	r7, r3, [sp]
  d6:	4926      	ldr	r1, [pc, #152]	; (170 <bench_stats_asym_finish_ex.constprop.0+0x170>)
  d8:	4826      	ldr	r0, [pc, #152]	; (174 <bench_stats_asym_finish_ex.constprop.0+0x174>)
  da:	4633      	mov	r3, r6
  dc:	462a      	mov	r2, r5
  de:	f7ff fffe 	bl	0 <printf>
    (void)ret;

    RESTORE_VECTOR_REGISTERS();

    TEST_SLEEP();
} /* bench_stats_asym_finish_ex */
  e2:	b05b      	add	sp, #364	; 0x16c
  e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        each = 0;
  e8:	f04f 0a00 	mov.w	sl, #0
  ec:	f04f 0b00 	mov.w	fp, #0
        count = 0;
  f0:	2400      	movs	r4, #0
  f2:	e7a8      	b.n	46 <bench_stats_asym_finish_ex.constprop.0+0x46>
        opsSec = 0;
  f4:	2200      	movs	r2, #0
  f6:	2300      	movs	r3, #0
  f8:	e9cd 2316 	strd	r2, r3, [sp, #88]	; 0x58
  fc:	e7b4      	b.n	68 <bench_stats_asym_finish_ex.constprop.0+0x68>
        (void)XSNPRINTF(msg, sizeof(msg),
  fe:	4b1e      	ldr	r3, [pc, #120]	; (178 <bench_stats_asym_finish_ex.constprop.0+0x178>)
 100:	68da      	ldr	r2, [r3, #12]
 102:	9214      	str	r2, [sp, #80]	; 0x50
 104:	e9dd 1216 	ldrd	r1, r2, [sp, #88]	; 0x58
 108:	e9cd ab0e 	strd	sl, fp, [sp, #56]	; 0x38
 10c:	e9cd 1212 	strd	r1, r2, [sp, #72]	; 0x48
 110:	2203      	movs	r2, #3
 112:	2105      	movs	r1, #5
 114:	9210      	str	r2, [sp, #64]	; 0x40
 116:	920d      	str	r2, [sp, #52]	; 0x34
 118:	910c      	str	r1, [sp, #48]	; 0x30
 11a:	6898      	ldr	r0, [r3, #8]
 11c:	900b      	str	r0, [sp, #44]	; 0x2c
 11e:	6858      	ldr	r0, [r3, #4]
 120:	900a      	str	r0, [sp, #40]	; 0x28
 122:	e9cd 1206 	strd	r1, r2, [sp, #24]
 126:	e9cd 8908 	strd	r8, r9, [sp, #32]
 12a:	681b      	ldr	r3, [r3, #0]
 12c:	4a13      	ldr	r2, [pc, #76]	; (17c <bench_stats_asym_finish_ex.constprop.0+0x17c>)
 12e:	e9cd 4304 	strd	r4, r3, [sp, #16]
 132:	4b0c      	ldr	r3, [pc, #48]	; (164 <bench_stats_asym_finish_ex.constprop.0+0x164>)
 134:	e9cd 7600 	strd	r7, r6, [sp]
 138:	e9cd 3302 	strd	r3, r3, [sp, #8]
 13c:	f44f 7180 	mov.w	r1, #256	; 0x100
 140:	462b      	mov	r3, r5
 142:	a81a      	add	r0, sp, #104	; 0x68
 144:	f7ff fffe 	bl	0 <snprintf>
 148:	e7bc      	b.n	c4 <bench_stats_asym_finish_ex.constprop.0+0xc4>
 14a:	bf00      	nop
 14c:	408f4000 	.word	0x408f4000
	...
 160:	00000019 	.word	0x00000019
 164:	00000060 	.word	0x00000060
 168:	00000049 	.word	0x00000049
 16c:	0000009c 	.word	0x0000009c
 170:	00000000 	.word	0x00000000
 174:	0000009f 	.word	0x0000009f
 178:	00000000 	.word	0x00000000
 17c:	00000061 	.word	0x00000061

Disassembly of section .text.bench_stats_sym_finish.constprop.0:

00000000 <bench_stats_sym_finish.constprop.0>:
static void bench_stats_sym_finish(const char* desc, int useDeviceID,
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b0bb      	sub	sp, #236	; 0xec
   6:	460c      	mov	r4, r1
   8:	4692      	mov	sl, r2
    XMEMSET(msg, 0, sizeof(msg));
   a:	2100      	movs	r1, #0
   c:	2296      	movs	r2, #150	; 0x96
static void bench_stats_sym_finish(const char* desc, int useDeviceID,
   e:	4606      	mov	r6, r0
    XMEMSET(msg, 0, sizeof(msg));
  10:	a814      	add	r0, sp, #80	; 0x50
  12:	f7ff fffe 	bl	0 <memset>
    total = current_time(0) - start;
  16:	2000      	movs	r0, #0
  18:	f7ff fffe 	bl	0 <current_time>
  1c:	e9dd 2344 	ldrd	r2, r3, [sp, #272]	; 0x110
  20:	f7ff fffe 	bl	0 <__aeabi_dsub>
  24:	4680      	mov	r8, r0
    double total, persec = 0, blocks = (double)count;
  26:	4620      	mov	r0, r4
    total = current_time(0) - start;
  28:	4689      	mov	r9, r1
    double total, persec = 0, blocks = (double)count;
  2a:	f7ff fffe 	bl	0 <__aeabi_i2d>
  2e:	4604      	mov	r4, r0
    blocks *= countSz;
  30:	4650      	mov	r0, sl
    double total, persec = 0, blocks = (double)count;
  32:	460d      	mov	r5, r1
    blocks *= countSz;
  34:	f7ff fffe 	bl	0 <__aeabi_ui2d>
    if (csv_format == 1) {
  38:	f8df b194 	ldr.w	fp, [pc, #404]	; 1d0 <bench_stats_sym_finish.constprop.0+0x1d0>
    blocks *= countSz;
  3c:	4602      	mov	r2, r0
  3e:	460b      	mov	r3, r1
  40:	4620      	mov	r0, r4
  42:	4629      	mov	r1, r5
  44:	f7ff fffe 	bl	0 <__aeabi_dmul>
    if (csv_format == 1) {
  48:	f8db 7000 	ldr.w	r7, [fp]
  4c:	2f01      	cmp	r7, #1
    blocks *= countSz;
  4e:	4604      	mov	r4, r0
  50:	460d      	mov	r5, r1
    if (csv_format == 1) {
  52:	d10c      	bne.n	6e <bench_stats_sym_finish.constprop.0+0x6e>
        if (sym_header_printed == 0) {
  54:	f8df a17c 	ldr.w	sl, [pc, #380]	; 1d4 <bench_stats_sym_finish.constprop.0+0x1d4>
  58:	f8da 2000 	ldr.w	r2, [sl]
  5c:	b93a      	cbnz	r2, 6e <bench_stats_sym_finish.constprop.0+0x6e>
            printf("\n\nSymmetric Ciphers:\n\n");
  5e:	485e      	ldr	r0, [pc, #376]	; (1d8 <bench_stats_sym_finish.constprop.0+0x1d8>)
  60:	f7ff fffe 	bl	0 <printf>
            printf("Algorithm,"
  64:	485d      	ldr	r0, [pc, #372]	; (1dc <bench_stats_sym_finish.constprop.0+0x1dc>)
  66:	f7ff fffe 	bl	0 <printf>
            sym_header_printed = 1;
  6a:	f8ca 7000 	str.w	r7, [sl]
    if (base2) {
  6e:	4b5c      	ldr	r3, [pc, #368]	; (1e0 <bench_stats_sym_finish.constprop.0+0x1e0>)
  70:	681b      	ldr	r3, [r3, #0]
  72:	2b00      	cmp	r3, #0
  74:	d059      	beq.n	12a <bench_stats_sym_finish.constprop.0+0x12a>
    if (*blocks > (1024UL * 1024UL)) {
  76:	2200      	movs	r2, #0
  78:	4b5a      	ldr	r3, [pc, #360]	; (1e4 <bench_stats_sym_finish.constprop.0+0x1e4>)
  7a:	4620      	mov	r0, r4
  7c:	4629      	mov	r1, r5
  7e:	f7ff fffe 	bl	0 <__aeabi_dcmpgt>
        *blocks /= (1024UL * 1024UL);
  82:	2200      	movs	r2, #0
    if (*blocks > (1024UL * 1024UL)) {
  84:	2800      	cmp	r0, #0
  86:	d03f      	beq.n	108 <bench_stats_sym_finish.constprop.0+0x108>
        *blocks /= (1024UL * 1024UL);
  88:	4620      	mov	r0, r4
  8a:	4629      	mov	r1, r5
  8c:	4b56      	ldr	r3, [pc, #344]	; (1e8 <bench_stats_sym_finish.constprop.0+0x1e8>)
        rt = "MiB";
  8e:	f8df a15c 	ldr.w	sl, [pc, #348]	; 1ec <bench_stats_sym_finish.constprop.0+0x1ec>
        *blocks /= (1024UL * 1024UL);
  92:	f7ff fffe 	bl	0 <__aeabi_dmul>
  96:	4604      	mov	r4, r0
  98:	460d      	mov	r5, r1
    if (total > 0) {
  9a:	2200      	movs	r2, #0
  9c:	2300      	movs	r3, #0
  9e:	4640      	mov	r0, r8
  a0:	4649      	mov	r1, r9
  a2:	f7ff fffe 	bl	0 <__aeabi_dcmpgt>
  a6:	2800      	cmp	r0, #0
  a8:	d068      	beq.n	17c <bench_stats_sym_finish.constprop.0+0x17c>
        persec = (1 / total) * blocks;
  aa:	4642      	mov	r2, r8
  ac:	464b      	mov	r3, r9
  ae:	4950      	ldr	r1, [pc, #320]	; (1f0 <bench_stats_sym_finish.constprop.0+0x1f0>)
  b0:	2000      	movs	r0, #0
  b2:	f7ff fffe 	bl	0 <__aeabi_ddiv>
  b6:	4622      	mov	r2, r4
  b8:	462b      	mov	r3, r5
  ba:	f7ff fffe 	bl	0 <__aeabi_dmul>
    if (csv_format == 1) {
  be:	f8db 3000 	ldr.w	r3, [fp]
  c2:	2b01      	cmp	r3, #1
  c4:	d15d      	bne.n	182 <bench_stats_sym_finish.constprop.0+0x182>
        (void)XSNPRINTF(msg, sizeof(msg), "%s," FLT_FMT ",", desc,
  c6:	e9cd 0100 	strd	r0, r1, [sp]
  ca:	4a4a      	ldr	r2, [pc, #296]	; (1f4 <bench_stats_sym_finish.constprop.0+0x1f4>)
  cc:	4633      	mov	r3, r6
  ce:	2196      	movs	r1, #150	; 0x96
  d0:	a814      	add	r0, sp, #80	; 0x50
  d2:	f7ff fffe 	bl	0 <snprintf>
        SHOW_INTEL_CYCLES(msg, sizeof(msg), (unsigned)countSz);
  d6:	a814      	add	r0, sp, #80	; 0x50
  d8:	f7ff fffe 	bl	0 <strlen>
  dc:	f100 03e8 	add.w	r3, r0, #232	; 0xe8
  e0:	eb0d 0003 	add.w	r0, sp, r3
  e4:	230a      	movs	r3, #10
  e6:	f800 3c98 	strb.w	r3, [r0, #-152]
    printf("%s", msg);
  ea:	a914      	add	r1, sp, #80	; 0x50
  ec:	4842      	ldr	r0, [pc, #264]	; (1f8 <bench_stats_sym_finish.constprop.0+0x1f8>)
  ee:	f7ff fffe 	bl	0 <printf>
    if (ret < 0) {
  f2:	9b46      	ldr	r3, [sp, #280]	; 0x118
  f4:	2b00      	cmp	r3, #0
  f6:	da04      	bge.n	102 <bench_stats_sym_finish.constprop.0+0x102>
        printf("%sBenchmark %s failed: %d\n", err_prefix, desc, ret);
  f8:	4940      	ldr	r1, [pc, #256]	; (1fc <bench_stats_sym_finish.constprop.0+0x1fc>)
  fa:	4841      	ldr	r0, [pc, #260]	; (200 <bench_stats_sym_finish.constprop.0+0x200>)
  fc:	4632      	mov	r2, r6
  fe:	f7ff fffe 	bl	0 <printf>
} /* bench_stats_sym_finish */
 102:	b03b      	add	sp, #236	; 0xec
 104:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if (*blocks > 1024) {
 108:	4b3e      	ldr	r3, [pc, #248]	; (204 <bench_stats_sym_finish.constprop.0+0x204>)
 10a:	4620      	mov	r0, r4
 10c:	4629      	mov	r1, r5
 10e:	f7ff fffe 	bl	0 <__aeabi_dcmpgt>
 112:	b380      	cbz	r0, 176 <bench_stats_sym_finish.constprop.0+0x176>
        *blocks /= 1024;
 114:	4620      	mov	r0, r4
 116:	4629      	mov	r1, r5
 118:	4b3b      	ldr	r3, [pc, #236]	; (208 <bench_stats_sym_finish.constprop.0+0x208>)
        rt = "KiB";
 11a:	f8df a0f0 	ldr.w	sl, [pc, #240]	; 20c <bench_stats_sym_finish.constprop.0+0x20c>
        *blocks /= 1024;
 11e:	2200      	movs	r2, #0
 120:	f7ff fffe 	bl	0 <__aeabi_dmul>
 124:	4604      	mov	r4, r0
 126:	460d      	mov	r5, r1
        rt = "KiB";
 128:	e7b7      	b.n	9a <bench_stats_sym_finish.constprop.0+0x9a>
    if (*blocks > (1000UL * 1000UL)) {
 12a:	a327      	add	r3, pc, #156	; (adr r3, 1c8 <bench_stats_sym_finish.constprop.0+0x1c8>)
 12c:	e9d3 2300 	ldrd	r2, r3, [r3]
 130:	4620      	mov	r0, r4
 132:	4629      	mov	r1, r5
 134:	f7ff fffe 	bl	0 <__aeabi_dcmpgt>
 138:	b158      	cbz	r0, 152 <bench_stats_sym_finish.constprop.0+0x152>
        *blocks /= (1000UL * 1000UL);
 13a:	4620      	mov	r0, r4
 13c:	4629      	mov	r1, r5
 13e:	a322      	add	r3, pc, #136	; (adr r3, 1c8 <bench_stats_sym_finish.constprop.0+0x1c8>)
 140:	e9d3 2300 	ldrd	r2, r3, [r3]
 144:	f7ff fffe 	bl	0 <__aeabi_ddiv>
        rt = "MB";
 148:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 210 <bench_stats_sym_finish.constprop.0+0x210>
        *blocks /= (1000UL * 1000UL);
 14c:	4604      	mov	r4, r0
 14e:	460d      	mov	r5, r1
        rt = "MB";
 150:	e7a3      	b.n	9a <bench_stats_sym_finish.constprop.0+0x9a>
    else if (*blocks > 1000) {
 152:	4b30      	ldr	r3, [pc, #192]	; (214 <bench_stats_sym_finish.constprop.0+0x214>)
 154:	2200      	movs	r2, #0
 156:	4620      	mov	r0, r4
 158:	4629      	mov	r1, r5
 15a:	f7ff fffe 	bl	0 <__aeabi_dcmpgt>
 15e:	b150      	cbz	r0, 176 <bench_stats_sym_finish.constprop.0+0x176>
        *blocks /= 1000; /* make KB */
 160:	4620      	mov	r0, r4
 162:	4629      	mov	r1, r5
 164:	4b2b      	ldr	r3, [pc, #172]	; (214 <bench_stats_sym_finish.constprop.0+0x214>)
        rt = "KB";
 166:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 218 <bench_stats_sym_finish.constprop.0+0x218>
        *blocks /= 1000; /* make KB */
 16a:	2200      	movs	r2, #0
 16c:	f7ff fffe 	bl	0 <__aeabi_ddiv>
 170:	4604      	mov	r4, r0
 172:	460d      	mov	r5, r1
        rt = "KB";
 174:	e791      	b.n	9a <bench_stats_sym_finish.constprop.0+0x9a>
        rt = "bytes";
 176:	f8df a0a4 	ldr.w	sl, [pc, #164]	; 21c <bench_stats_sym_finish.constprop.0+0x21c>
 17a:	e78e      	b.n	9a <bench_stats_sym_finish.constprop.0+0x9a>
    double total, persec = 0, blocks = (double)count;
 17c:	2000      	movs	r0, #0
 17e:	2100      	movs	r1, #0
 180:	e79d      	b.n	be <bench_stats_sym_finish.constprop.0+0xbe>
        (void)XSNPRINTF(msg, sizeof(msg),
 182:	2303      	movs	r3, #3
 184:	2208      	movs	r2, #8
 186:	e9cd 230d 	strd	r2, r3, [sp, #52]	; 0x34
 18a:	e9cd 0110 	strd	r0, r1, [sp, #64]	; 0x40
 18e:	4a24      	ldr	r2, [pc, #144]	; (220 <bench_stats_sym_finish.constprop.0+0x220>)
 190:	f8cd a048 	str.w	sl, [sp, #72]	; 0x48
 194:	6851      	ldr	r1, [r2, #4]
 196:	9309      	str	r3, [sp, #36]	; 0x24
 198:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
 19c:	2305      	movs	r3, #5
 19e:	910c      	str	r1, [sp, #48]	; 0x30
 1a0:	9308      	str	r3, [sp, #32]
 1a2:	6812      	ldr	r2, [r2, #0]
 1a4:	e9cd a206 	strd	sl, r2, [sp, #24]
 1a8:	2200      	movs	r2, #0
 1aa:	e9cd 3201 	strd	r3, r2, [sp, #4]
 1ae:	4b1d      	ldr	r3, [pc, #116]	; (224 <bench_stats_sym_finish.constprop.0+0x224>)
 1b0:	9300      	str	r3, [sp, #0]
 1b2:	e9cd 4504 	strd	r4, r5, [sp, #16]
 1b6:	4a1c      	ldr	r2, [pc, #112]	; (228 <bench_stats_sym_finish.constprop.0+0x228>)
 1b8:	4633      	mov	r3, r6
 1ba:	2196      	movs	r1, #150	; 0x96
 1bc:	a814      	add	r0, sp, #80	; 0x50
 1be:	f7ff fffe 	bl	0 <snprintf>
 1c2:	e788      	b.n	d6 <bench_stats_sym_finish.constprop.0+0xd6>
 1c4:	f3af 8000 	nop.w
 1c8:	00000000 	.word	0x00000000
 1cc:	412e8480 	.word	0x412e8480
	...
 1d8:	00000014 	.word	0x00000014
 1dc:	0000002b 	.word	0x0000002b
 1e0:	00000000 	.word	0x00000000
 1e4:	41300000 	.word	0x41300000
 1e8:	3eb00000 	.word	0x3eb00000
 1ec:	00000010 	.word	0x00000010
 1f0:	3ff00000 	.word	0x3ff00000
 1f4:	0000003d 	.word	0x0000003d
 1f8:	0000009c 	.word	0x0000009c
 1fc:	00000000 	.word	0x00000000
 200:	0000006d 	.word	0x0000006d
 204:	40900000 	.word	0x40900000
 208:	3f500000 	.word	0x3f500000
 20c:	00000000 	.word	0x00000000
 210:	0000000a 	.word	0x0000000a
 214:	408f4000 	.word	0x408f4000
 218:	0000000d 	.word	0x0000000d
 21c:	00000004 	.word	0x00000004
 220:	00000000 	.word	0x00000000
 224:	00000060 	.word	0x00000060
 228:	00000044 	.word	0x00000044

Disassembly of section .text.bench_hmac.constprop.0:

00000000 <bench_hmac.constprop.0>:

#endif /* HAVE_SCRYPT */

#ifndef NO_HMAC

static void bench_hmac(int useDeviceID, int type, int digestSz,
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
                       const byte* key, word32 keySz, const char* label)
{
    Hmac   hmac[BENCH_MAX_PENDING];
    double start;
    int    ret = 0, i, count = 0, times, pending = 0;
   4:	f04f 0800 	mov.w	r8, #0
static void bench_hmac(int useDeviceID, int type, int digestSz,
   8:	f5ad 7d23 	sub.w	sp, sp, #652	; 0x28c
   c:	460c      	mov	r4, r1
   e:	4615      	mov	r5, r2
#endif

    (void)digestSz;

    /* clear for done cleanup */
    XMEMSET(hmac, 0, sizeof(hmac));
  10:	4641      	mov	r1, r8
  12:	f44f 720a 	mov.w	r2, #552	; 0x228
  16:	a818      	add	r0, sp, #96	; 0x60
static void bench_hmac(int useDeviceID, int type, int digestSz,
  18:	461f      	mov	r7, r3
  1a:	9eaa      	ldr	r6, [sp, #680]	; 0x2a8
    int    ret = 0, i, count = 0, times, pending = 0;
  1c:	f8cd 8014 	str.w	r8, [sp, #20]
    XMEMSET(hmac, 0, sizeof(hmac));
  20:	f7ff fffe 	bl	0 <memset>

    /* init keys */
    for (i = 0; i < BENCH_MAX_PENDING; i++) {
        ret = wc_HmacInit(&hmac[i], HEAP_HINT,
  24:	f06f 0201 	mvn.w	r2, #1
  28:	4641      	mov	r1, r8
  2a:	a818      	add	r0, sp, #96	; 0x60
  2c:	f7ff fffe 	bl	0 <wc_HmacInit>
                useDeviceID ? devId : INVALID_DEVID);
        if (ret != 0) {
  30:	4602      	mov	r2, r0
  32:	b150      	cbz	r0, 4a <bench_hmac.constprop.0+0x4a>
            printf("wc_HmacInit failed for %s, ret = %d\n", label, ret);
  34:	4824      	ldr	r0, [pc, #144]	; (c8 <bench_hmac.constprop.0+0xc8>)
  36:	4631      	mov	r1, r6
            goto exit;
        }

        ret = wc_HmacSetKey(&hmac[i], type, key, keySz);
        if (ret != 0) {
            printf("wc_HmacSetKey failed for %s, ret = %d\n", label, ret);
  38:	f7ff fffe 	bl	0 <printf>
    bench_stats_sym_finish(label, useDeviceID, count, bench_size, start, ret);

exit:

    for (i = 0; i < BENCH_MAX_PENDING; i++) {
        wc_HmacFree(&hmac[i]);
  3c:	a818      	add	r0, sp, #96	; 0x60
  3e:	f7ff fffe 	bl	0 <wc_HmacFree>
    }

#ifdef WOLFSSL_ASYNC_CRYPT
    WC_FREE_ARRAY(digest, BENCH_MAX_PENDING, HEAP_HINT);
#endif
}
  42:	f50d 7d23 	add.w	sp, sp, #652	; 0x28c
  46:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ret = wc_HmacSetKey(&hmac[i], type, key, keySz);
  4a:	462a      	mov	r2, r5
  4c:	463b      	mov	r3, r7
  4e:	4621      	mov	r1, r4
  50:	a818      	add	r0, sp, #96	; 0x60
  52:	f7ff fffe 	bl	0 <wc_HmacSetKey>
        if (ret != 0) {
  56:	4602      	mov	r2, r0
  58:	b110      	cbz	r0, 60 <bench_hmac.constprop.0+0x60>
            printf("wc_HmacSetKey failed for %s, ret = %d\n", label, ret);
  5a:	481c      	ldr	r0, [pc, #112]	; (cc <bench_hmac.constprop.0+0xcc>)
  5c:	4631      	mov	r1, r6
  5e:	e7eb      	b.n	38 <bench_hmac.constprop.0+0x38>
    bench_stats_start(&count, &start);
  60:	a906      	add	r1, sp, #24
  62:	a805      	add	r0, sp, #20
  64:	f7ff fffe 	bl	0 <bench_hmac.constprop.0>
        for (times = 0; times < numBlocks || pending > 0; ) {
  68:	4f19      	ldr	r7, [pc, #100]	; (d0 <bench_hmac.constprop.0+0xd0>)
                    ret = wc_HmacUpdate(&hmac[i], bench_plain, bench_size);
  6a:	f8df 8068 	ldr.w	r8, [pc, #104]	; d4 <bench_hmac.constprop.0+0xd4>
  6e:	f8df 9068 	ldr.w	r9, [pc, #104]	; d8 <bench_hmac.constprop.0+0xd8>
        for (times = 0; times < numBlocks || pending > 0; ) {
  72:	2500      	movs	r5, #0
  74:	683b      	ldr	r3, [r7, #0]
  76:	42ab      	cmp	r3, r5
  78:	dc1a      	bgt.n	b0 <bench_hmac.constprop.0+0xb0>
        count += times;
  7a:	9b05      	ldr	r3, [sp, #20]
                    ret = wc_HmacFinal(&hmac[i], digest[i]);
  7c:	a908      	add	r1, sp, #32
        count += times;
  7e:	442b      	add	r3, r5
                    ret = wc_HmacFinal(&hmac[i], digest[i]);
  80:	a818      	add	r0, sp, #96	; 0x60
        count += times;
  82:	9305      	str	r3, [sp, #20]
                    ret = wc_HmacFinal(&hmac[i], digest[i]);
  84:	f7ff fffe 	bl	0 <wc_HmacFinal>
        if (*ret >= 0) {
  88:	1e04      	subs	r4, r0, #0
  8a:	db05      	blt.n	98 <bench_hmac.constprop.0+0x98>
    } while (bench_stats_check(start));
  8c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  90:	f7ff fffe 	bl	0 <bench_hmac.constprop.0>
  94:	2800      	cmp	r0, #0
  96:	d1ea      	bne.n	6e <bench_hmac.constprop.0+0x6e>
    bench_stats_sym_finish(label, useDeviceID, count, bench_size, start, ret);
  98:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  9c:	e9cd 2300 	strd	r2, r3, [sp]
  a0:	4b0c      	ldr	r3, [pc, #48]	; (d4 <bench_hmac.constprop.0+0xd4>)
  a2:	9402      	str	r4, [sp, #8]
  a4:	681a      	ldr	r2, [r3, #0]
  a6:	9905      	ldr	r1, [sp, #20]
  a8:	4630      	mov	r0, r6
  aa:	f7ff fffe 	bl	0 <bench_hmac.constprop.0>
  ae:	e7c5      	b.n	3c <bench_hmac.constprop.0+0x3c>
                    ret = wc_HmacUpdate(&hmac[i], bench_plain, bench_size);
  b0:	f8d8 2000 	ldr.w	r2, [r8]
  b4:	f8d9 1000 	ldr.w	r1, [r9]
  b8:	a818      	add	r0, sp, #96	; 0x60
  ba:	f7ff fffe 	bl	0 <wc_HmacUpdate>
        if (*ret >= 0) {
  be:	1e04      	subs	r4, r0, #0
  c0:	dbea      	blt.n	98 <bench_hmac.constprop.0+0x98>
            (*times)++;
  c2:	3501      	adds	r5, #1
            for (i = 0; i < BENCH_MAX_PENDING; i++) {
  c4:	e7d6      	b.n	74 <bench_hmac.constprop.0+0x74>
  c6:	bf00      	nop
  c8:	00000000 	.word	0x00000000
  cc:	00000025 	.word	0x00000025
	...

Disassembly of section .text.bench_aesgcm_internal.constprop.0:

00000000 <bench_aesgcm_internal.constprop.0>:
static void bench_aesgcm_internal(int useDeviceID,
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f5ad 7d77 	sub.w	sp, sp, #988	; 0x3dc
    int    ret = 0, i, count = 0, times, pending = 0;
   8:	2600      	movs	r6, #0
    WC_DECLARE_VAR(bench_additional, byte, AES_AUTH_ADD_SZ, HEAP_HINT);
   a:	200d      	movs	r0, #13
static void bench_aesgcm_internal(int useDeviceID,
   c:	460f      	mov	r7, r1
   e:	4690      	mov	r8, r2
  10:	4699      	mov	r9, r3
    int    ret = 0, i, count = 0, times, pending = 0;
  12:	9609      	str	r6, [sp, #36]	; 0x24
    WC_DECLARE_VAR(bench_additional, byte, AES_AUTH_ADD_SZ, HEAP_HINT);
  14:	f7ff fffe 	bl	0 <malloc>
  18:	4604      	mov	r4, r0
    WC_DECLARE_VAR(bench_tag, byte, AES_AUTH_TAG_SZ, HEAP_HINT);
  1a:	2010      	movs	r0, #16
  1c:	f7ff fffe 	bl	0 <malloc>
  20:	4605      	mov	r5, r0
    if (bench_additional == NULL || bench_tag == NULL) {
  22:	b104      	cbz	r4, 26 <bench_aesgcm_internal.constprop.0+0x26>
  24:	b9a0      	cbnz	r0, 50 <bench_aesgcm_internal.constprop.0+0x50>
        printf("bench_aesgcm_internal malloc failed\n");
  26:	486b      	ldr	r0, [pc, #428]	; (1d4 <bench_aesgcm_internal.constprop.0+0x1d4>)
  28:	f7ff fffe 	bl	0 <printf>
        wc_AesFree(&dec[i]);
  2c:	a85a      	add	r0, sp, #360	; 0x168
  2e:	f7ff fffe 	bl	0 <wc_AesFree>
        wc_AesFree(&enc[i]);
  32:	a80c      	add	r0, sp, #48	; 0x30
  34:	f7ff fffe 	bl	0 <wc_AesFree>
    WC_FREE_VAR(bench_additional, HEAP_HINT);
  38:	b114      	cbz	r4, 40 <bench_aesgcm_internal.constprop.0+0x40>
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <free>
    WC_FREE_VAR(bench_tag, HEAP_HINT);
  40:	b115      	cbz	r5, 48 <bench_aesgcm_internal.constprop.0+0x48>
  42:	4628      	mov	r0, r5
  44:	f7ff fffe 	bl	0 <free>
}
  48:	f50d 7d77 	add.w	sp, sp, #988	; 0x3dc
  4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    XMEMSET(enc, 0, sizeof(enc));
  50:	f44f 729c 	mov.w	r2, #312	; 0x138
  54:	4631      	mov	r1, r6
  56:	a80c      	add	r0, sp, #48	; 0x30
  58:	f7ff fffe 	bl	0 <memset>
        XMEMSET(bench_additional, 0, AES_AUTH_ADD_SZ);
  5c:	220d      	movs	r2, #13
  5e:	4631      	mov	r1, r6
  60:	4620      	mov	r0, r4
  62:	f7ff fffe 	bl	0 <memset>
        XMEMSET(bench_tag, 0, AES_AUTH_TAG_SZ);
  66:	2210      	movs	r2, #16
  68:	4631      	mov	r1, r6
  6a:	4628      	mov	r0, r5
  6c:	f7ff fffe 	bl	0 <memset>
        if ((ret = wc_AesInit(&enc[i], HEAP_HINT,
  70:	f06f 0201 	mvn.w	r2, #1
  74:	4631      	mov	r1, r6
  76:	a80c      	add	r0, sp, #48	; 0x30
  78:	f7ff fffe 	bl	0 <wc_AesInit>
  7c:	4683      	mov	fp, r0
  7e:	b110      	cbz	r0, 86 <bench_aesgcm_internal.constprop.0+0x86>
            printf("AesInit failed, ret = %d\n", ret);
  80:	4855      	ldr	r0, [pc, #340]	; (1d8 <bench_aesgcm_internal.constprop.0+0x1d8>)
  82:	4659      	mov	r1, fp
  84:	e008      	b.n	98 <bench_aesgcm_internal.constprop.0+0x98>
        ret = wc_AesGcmSetKey(&enc[i], key, keySz);
  86:	4642      	mov	r2, r8
  88:	4639      	mov	r1, r7
  8a:	a80c      	add	r0, sp, #48	; 0x30
  8c:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
        if (ret != 0) {
  90:	4683      	mov	fp, r0
  92:	b158      	cbz	r0, ac <bench_aesgcm_internal.constprop.0+0xac>
            printf("AesGcmSetKey failed, ret = %d\n", ret);
  94:	4601      	mov	r1, r0
  96:	4851      	ldr	r0, [pc, #324]	; (1dc <bench_aesgcm_internal.constprop.0+0x1dc>)
  98:	f7ff fffe 	bl	0 <printf>
    if (ret < 0) {
  9c:	f1bb 0f00 	cmp.w	fp, #0
  a0:	dac4      	bge.n	2c <bench_aesgcm_internal.constprop.0+0x2c>
        printf("bench_aesgcm failed: %d\n", ret);
  a2:	4659      	mov	r1, fp
  a4:	484e      	ldr	r0, [pc, #312]	; (1e0 <bench_aesgcm_internal.constprop.0+0x1e0>)
  a6:	f7ff fffe 	bl	0 <printf>
  aa:	e7bf      	b.n	2c <bench_aesgcm_internal.constprop.0+0x2c>
    bench_stats_start(&count, &start);
  ac:	a90a      	add	r1, sp, #40	; 0x28
  ae:	a809      	add	r0, sp, #36	; 0x24
        for (times = 0; times < numBlocks || pending > 0; ) {
  b0:	f8df a130 	ldr.w	sl, [pc, #304]	; 1e4 <bench_aesgcm_internal.constprop.0+0x1e4>
    bench_stats_start(&count, &start);
  b4:	f7ff fffe 	bl	0 <bench_aesgcm_internal.constprop.0>
  b8:	465b      	mov	r3, fp
                    ret = wc_AesGcmEncrypt(&enc[i], bench_cipher,
  ba:	f8df b12c 	ldr.w	fp, [pc, #300]	; 1e8 <bench_aesgcm_internal.constprop.0+0x1e8>
        for (times = 0; times < numBlocks || pending > 0; ) {
  be:	2600      	movs	r6, #0
  c0:	f8da 2000 	ldr.w	r2, [sl]
  c4:	42b2      	cmp	r2, r6
  c6:	dc6e      	bgt.n	1a6 <bench_aesgcm_internal.constprop.0+0x1a6>
        count += times;
  c8:	9a09      	ldr	r2, [sp, #36]	; 0x24
  ca:	9307      	str	r3, [sp, #28]
  cc:	4432      	add	r2, r6
    } while (bench_stats_check(start));
  ce:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
        count += times;
  d2:	9209      	str	r2, [sp, #36]	; 0x24
    } while (bench_stats_check(start));
  d4:	f7ff fffe 	bl	0 <bench_aesgcm_internal.constprop.0>
  d8:	9b07      	ldr	r3, [sp, #28]
  da:	2800      	cmp	r0, #0
  dc:	d1ed      	bne.n	ba <bench_aesgcm_internal.constprop.0+0xba>
    bench_stats_sym_finish(encLabel, useDeviceID, count, bench_size,
  de:	9302      	str	r3, [sp, #8]
  e0:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  e4:	e9cd 2300 	strd	r2, r3, [sp]
  e8:	f8df a100 	ldr.w	sl, [pc, #256]	; 1ec <bench_aesgcm_internal.constprop.0+0x1ec>
  ec:	9909      	ldr	r1, [sp, #36]	; 0x24
  ee:	f8da 2000 	ldr.w	r2, [sl]
  f2:	f8dd 0400 	ldr.w	r0, [sp, #1024]	; 0x400
  f6:	f7ff fffe 	bl	0 <bench_aesgcm_internal.constprop.0>
    XMEMSET(dec, 0, sizeof(dec));
  fa:	f44f 721c 	mov.w	r2, #624	; 0x270
  fe:	2100      	movs	r1, #0
 100:	a85a      	add	r0, sp, #360	; 0x168
 102:	f7ff fffe 	bl	0 <memset>
        if ((ret = wc_AesInit(&dec[i], HEAP_HINT,
 106:	f06f 0201 	mvn.w	r2, #1
 10a:	2100      	movs	r1, #0
 10c:	a85a      	add	r0, sp, #360	; 0x168
 10e:	f7ff fffe 	bl	0 <wc_AesInit>
 112:	4683      	mov	fp, r0
 114:	2800      	cmp	r0, #0
 116:	d1b3      	bne.n	80 <bench_aesgcm_internal.constprop.0+0x80>
        ret = wc_AesGcmSetKey(&dec[i], key, keySz);
 118:	4642      	mov	r2, r8
 11a:	4639      	mov	r1, r7
 11c:	a85a      	add	r0, sp, #360	; 0x168
 11e:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
        if (ret != 0) {
 122:	4606      	mov	r6, r0
 124:	b128      	cbz	r0, 132 <bench_aesgcm_internal.constprop.0+0x132>
            printf("AesGcmSetKey failed, ret = %d\n", ret);
 126:	4601      	mov	r1, r0
 128:	482c      	ldr	r0, [pc, #176]	; (1dc <bench_aesgcm_internal.constprop.0+0x1dc>)
 12a:	f7ff fffe 	bl	0 <printf>
            goto exit;
 12e:	46b3      	mov	fp, r6
 130:	e7b4      	b.n	9c <bench_aesgcm_internal.constprop.0+0x9c>
    bench_stats_start(&count, &start);
 132:	a90a      	add	r1, sp, #40	; 0x28
 134:	a809      	add	r0, sp, #36	; 0x24
 136:	f7ff fffe 	bl	0 <bench_aesgcm_internal.constprop.0>
        for (times = 0; times < numBlocks || pending > 0; ) {
 13a:	4f2a      	ldr	r7, [pc, #168]	; (1e4 <bench_aesgcm_internal.constprop.0+0x1e4>)
                    ret = wc_AesGcmDecrypt(&dec[i], bench_plain,
 13c:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 1f0 <bench_aesgcm_internal.constprop.0+0x1f0>
        for (times = 0; times < numBlocks || pending > 0; ) {
 140:	2600      	movs	r6, #0
 142:	683a      	ldr	r2, [r7, #0]
 144:	42b2      	cmp	r2, r6
 146:	dc16      	bgt.n	176 <bench_aesgcm_internal.constprop.0+0x176>
        count += times;
 148:	9a09      	ldr	r2, [sp, #36]	; 0x24
    } while (bench_stats_check(start));
 14a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
        count += times;
 14e:	4432      	add	r2, r6
 150:	9209      	str	r2, [sp, #36]	; 0x24
    } while (bench_stats_check(start));
 152:	f7ff fffe 	bl	0 <bench_aesgcm_internal.constprop.0>
 156:	2800      	cmp	r0, #0
 158:	d1f2      	bne.n	140 <bench_aesgcm_internal.constprop.0+0x140>
    bench_stats_sym_finish(decLabel, useDeviceID, count, bench_size,
 15a:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 15e:	e9cd 0100 	strd	r0, r1, [sp]
 162:	f8cd b008 	str.w	fp, [sp, #8]
 166:	f8da 2000 	ldr.w	r2, [sl]
 16a:	9909      	ldr	r1, [sp, #36]	; 0x24
 16c:	f8dd 0404 	ldr.w	r0, [sp, #1028]	; 0x404
 170:	f7ff fffe 	bl	0 <bench_aesgcm_internal.constprop.0>
 174:	e792      	b.n	9c <bench_aesgcm_internal.constprop.0+0x9c>
                    ret = wc_AesGcmDecrypt(&dec[i], bench_plain,
 176:	4b1f      	ldr	r3, [pc, #124]	; (1f4 <bench_aesgcm_internal.constprop.0+0x1f4>)
 178:	491b      	ldr	r1, [pc, #108]	; (1e8 <bench_aesgcm_internal.constprop.0+0x1e8>)
 17a:	681b      	ldr	r3, [r3, #0]
 17c:	e9cd 4304 	strd	r4, r3, [sp, #16]
 180:	2310      	movs	r3, #16
 182:	e9cd 5302 	strd	r5, r3, [sp, #8]
 186:	230c      	movs	r3, #12
 188:	e9cd 9300 	strd	r9, r3, [sp]
 18c:	a85a      	add	r0, sp, #360	; 0x168
 18e:	f8da 3000 	ldr.w	r3, [sl]
 192:	f8d8 2000 	ldr.w	r2, [r8]
 196:	6809      	ldr	r1, [r1, #0]
 198:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        if (*ret >= 0) {
 19c:	f1b0 0b00 	subs.w	fp, r0, #0
 1a0:	dbdb      	blt.n	15a <bench_aesgcm_internal.constprop.0+0x15a>
            (*times)++;
 1a2:	3601      	adds	r6, #1
            for (i = 0; i < BENCH_MAX_PENDING; i++) {
 1a4:	e7cd      	b.n	142 <bench_aesgcm_internal.constprop.0+0x142>
                    ret = wc_AesGcmEncrypt(&enc[i], bench_cipher,
 1a6:	4b13      	ldr	r3, [pc, #76]	; (1f4 <bench_aesgcm_internal.constprop.0+0x1f4>)
 1a8:	4911      	ldr	r1, [pc, #68]	; (1f0 <bench_aesgcm_internal.constprop.0+0x1f0>)
 1aa:	681b      	ldr	r3, [r3, #0]
 1ac:	e9cd 4304 	strd	r4, r3, [sp, #16]
 1b0:	2310      	movs	r3, #16
 1b2:	e9cd 5302 	strd	r5, r3, [sp, #8]
 1b6:	230c      	movs	r3, #12
 1b8:	e9cd 9300 	strd	r9, r3, [sp]
 1bc:	4b0b      	ldr	r3, [pc, #44]	; (1ec <bench_aesgcm_internal.constprop.0+0x1ec>)
 1be:	f8db 2000 	ldr.w	r2, [fp]
 1c2:	681b      	ldr	r3, [r3, #0]
 1c4:	6809      	ldr	r1, [r1, #0]
 1c6:	a80c      	add	r0, sp, #48	; 0x30
 1c8:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        if (*ret >= 0) {
 1cc:	1e03      	subs	r3, r0, #0
 1ce:	db86      	blt.n	de <bench_aesgcm_internal.constprop.0+0xde>
            (*times)++;
 1d0:	3601      	adds	r6, #1
            for (i = 0; i < BENCH_MAX_PENDING; i++) {
 1d2:	e775      	b.n	c0 <bench_aesgcm_internal.constprop.0+0xc0>
 1d4:	00000000 	.word	0x00000000
 1d8:	00000025 	.word	0x00000025
 1dc:	0000003f 	.word	0x0000003f
 1e0:	0000005e 	.word	0x0000005e
	...

Disassembly of section .text.bench_aesgcm:

00000000 <bench_aesgcm>:
{
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
                          AES_GCM_STRING(128, enc), AES_GCM_STRING(128, dec));
   2:	4d25      	ldr	r5, [pc, #148]	; (98 <bench_aesgcm+0x98>)
    bench_aesgcm_internal(useDeviceID, bench_key, 16, bench_iv, 12,
   4:	4f25      	ldr	r7, [pc, #148]	; (9c <bench_aesgcm+0x9c>)
   6:	4e26      	ldr	r6, [pc, #152]	; (a0 <bench_aesgcm+0xa0>)
                          AES_GCM_STRING(128, enc), AES_GCM_STRING(128, dec));
   8:	682a      	ldr	r2, [r5, #0]
    bench_aesgcm_internal(useDeviceID, bench_key, 16, bench_iv, 12,
   a:	6839      	ldr	r1, [r7, #0]
   c:	6833      	ldr	r3, [r6, #0]
{
   e:	4604      	mov	r4, r0
    bench_aesgcm_internal(useDeviceID, bench_key, 16, bench_iv, 12,
  10:	2a00      	cmp	r2, #0
  12:	d038      	beq.n	86 <bench_aesgcm+0x86>
                          AES_GCM_STRING(128, enc), AES_GCM_STRING(128, dec));
  14:	4823      	ldr	r0, [pc, #140]	; (a4 <bench_aesgcm+0xa4>)
  16:	f8df c090 	ldr.w	ip, [pc, #144]	; a8 <bench_aesgcm+0xa8>
  1a:	2a0d      	cmp	r2, #13
  1c:	4a23      	ldr	r2, [pc, #140]	; (ac <bench_aesgcm+0xac>)
  1e:	bf18      	it	ne
  20:	4602      	movne	r2, r0
  22:	4823      	ldr	r0, [pc, #140]	; (b0 <bench_aesgcm+0xb0>)
  24:	bf18      	it	ne
  26:	4660      	movne	r0, ip
    bench_aesgcm_internal(useDeviceID, bench_key, 16, bench_iv, 12,
  28:	e9cd 2000 	strd	r2, r0, [sp]
  2c:	2210      	movs	r2, #16
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <bench_aesgcm>
                          AES_GCM_STRING(192, enc), AES_GCM_STRING(192, dec));
  34:	682a      	ldr	r2, [r5, #0]
    bench_aesgcm_internal(useDeviceID, bench_key, 24, bench_iv, 12,
  36:	6839      	ldr	r1, [r7, #0]
  38:	6833      	ldr	r3, [r6, #0]
  3a:	b33a      	cbz	r2, 8c <bench_aesgcm+0x8c>
                          AES_GCM_STRING(192, enc), AES_GCM_STRING(192, dec));
  3c:	481d      	ldr	r0, [pc, #116]	; (b4 <bench_aesgcm+0xb4>)
  3e:	f8df c078 	ldr.w	ip, [pc, #120]	; b8 <bench_aesgcm+0xb8>
  42:	2a0d      	cmp	r2, #13
  44:	4a1d      	ldr	r2, [pc, #116]	; (bc <bench_aesgcm+0xbc>)
  46:	bf08      	it	eq
  48:	4602      	moveq	r2, r0
  4a:	481d      	ldr	r0, [pc, #116]	; (c0 <bench_aesgcm+0xc0>)
  4c:	bf08      	it	eq
  4e:	4660      	moveq	r0, ip
    bench_aesgcm_internal(useDeviceID, bench_key, 24, bench_iv, 12,
  50:	e9cd 2000 	strd	r2, r0, [sp]
  54:	2218      	movs	r2, #24
  56:	4620      	mov	r0, r4
  58:	f7ff fffe 	bl	0 <bench_aesgcm>
                          AES_GCM_STRING(256, enc), AES_GCM_STRING(256, dec));
  5c:	682a      	ldr	r2, [r5, #0]
    bench_aesgcm_internal(useDeviceID, bench_key, 32, bench_iv, 12,
  5e:	6839      	ldr	r1, [r7, #0]
  60:	6833      	ldr	r3, [r6, #0]
  62:	b1b2      	cbz	r2, 92 <bench_aesgcm+0x92>
                          AES_GCM_STRING(256, enc), AES_GCM_STRING(256, dec));
  64:	4817      	ldr	r0, [pc, #92]	; (c4 <bench_aesgcm+0xc4>)
  66:	4d18      	ldr	r5, [pc, #96]	; (c8 <bench_aesgcm+0xc8>)
  68:	2a0d      	cmp	r2, #13
  6a:	4a18      	ldr	r2, [pc, #96]	; (cc <bench_aesgcm+0xcc>)
  6c:	bf08      	it	eq
  6e:	4602      	moveq	r2, r0
  70:	4817      	ldr	r0, [pc, #92]	; (d0 <bench_aesgcm+0xd0>)
  72:	bf08      	it	eq
  74:	4628      	moveq	r0, r5
    bench_aesgcm_internal(useDeviceID, bench_key, 32, bench_iv, 12,
  76:	e9cd 2000 	strd	r2, r0, [sp]
  7a:	2220      	movs	r2, #32
  7c:	4620      	mov	r0, r4
  7e:	f7ff fffe 	bl	0 <bench_aesgcm>
}
  82:	b003      	add	sp, #12
  84:	bdf0      	pop	{r4, r5, r6, r7, pc}
    bench_aesgcm_internal(useDeviceID, bench_key, 16, bench_iv, 12,
  86:	4a13      	ldr	r2, [pc, #76]	; (d4 <bench_aesgcm+0xd4>)
  88:	4813      	ldr	r0, [pc, #76]	; (d8 <bench_aesgcm+0xd8>)
  8a:	e7cd      	b.n	28 <bench_aesgcm+0x28>
    bench_aesgcm_internal(useDeviceID, bench_key, 24, bench_iv, 12,
  8c:	4a13      	ldr	r2, [pc, #76]	; (dc <bench_aesgcm+0xdc>)
  8e:	4814      	ldr	r0, [pc, #80]	; (e0 <bench_aesgcm+0xe0>)
  90:	e7de      	b.n	50 <bench_aesgcm+0x50>
    bench_aesgcm_internal(useDeviceID, bench_key, 32, bench_iv, 12,
  92:	4a14      	ldr	r2, [pc, #80]	; (e4 <bench_aesgcm+0xe4>)
  94:	4814      	ldr	r0, [pc, #80]	; (e8 <bench_aesgcm+0xe8>)
  96:	e7ee      	b.n	76 <bench_aesgcm+0x76>
	...
  a4:	0000004e 	.word	0x0000004e
  a8:	00000065 	.word	0x00000065
  ac:	0000002e 	.word	0x0000002e
  b0:	0000003e 	.word	0x0000003e
  b4:	000000d8 	.word	0x000000d8
  b8:	000000e8 	.word	0x000000e8
  bc:	000000aa 	.word	0x000000aa
  c0:	000000c1 	.word	0x000000c1
  c4:	00000154 	.word	0x00000154
  c8:	00000164 	.word	0x00000164
  cc:	00000126 	.word	0x00000126
  d0:	0000013d 	.word	0x0000013d
  d4:	00000000 	.word	0x00000000
  d8:	00000017 	.word	0x00000017
  dc:	0000007c 	.word	0x0000007c
  e0:	00000093 	.word	0x00000093
  e4:	000000f8 	.word	0x000000f8
  e8:	0000010f 	.word	0x0000010f

Disassembly of section .text.bench_aescbc_internal:

00000000 <bench_aescbc_internal>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int    ret = 0, i, count = 0, times, pending = 0;
   4:	2400      	movs	r4, #0
{
   6:	b0d6      	sub	sp, #344	; 0x158
   8:	460d      	mov	r5, r1
   a:	4690      	mov	r8, r2
    XMEMSET(enc, 0, sizeof(enc));
   c:	4621      	mov	r1, r4
   e:	f44f 729c 	mov.w	r2, #312	; 0x138
  12:	a808      	add	r0, sp, #32
{
  14:	4699      	mov	r9, r3
    int    ret = 0, i, count = 0, times, pending = 0;
  16:	9405      	str	r4, [sp, #20]
    XMEMSET(enc, 0, sizeof(enc));
  18:	f7ff fffe 	bl	0 <memset>
        if ((ret = wc_AesInit(&enc[i], HEAP_HINT,
  1c:	4621      	mov	r1, r4
  1e:	f06f 0201 	mvn.w	r2, #1
  22:	a808      	add	r0, sp, #32
  24:	f7ff fffe 	bl	0 <wc_AesInit>
  28:	4601      	mov	r1, r0
  2a:	b140      	cbz	r0, 3e <bench_aescbc_internal+0x3e>
            printf("AesInit failed, ret = %d\n", ret);
  2c:	483c      	ldr	r0, [pc, #240]	; (120 <bench_aescbc_internal+0x120>)
            printf("AesSetKey failed, ret = %d\n", ret);
  2e:	f7ff fffe 	bl	0 <printf>
        wc_AesFree(&enc[i]);
  32:	a808      	add	r0, sp, #32
  34:	f7ff fffe 	bl	0 <wc_AesFree>
}
  38:	b056      	add	sp, #344	; 0x158
  3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ret = wc_AesSetKey(&enc[i], key, keySz, iv, AES_ENCRYPTION);
  3e:	9000      	str	r0, [sp, #0]
  40:	464b      	mov	r3, r9
  42:	4642      	mov	r2, r8
  44:	4629      	mov	r1, r5
  46:	a808      	add	r0, sp, #32
  48:	f7ff fffe 	bl	0 <wc_AesSetKey>
        if (ret != 0) {
  4c:	4604      	mov	r4, r0
  4e:	b110      	cbz	r0, 56 <bench_aescbc_internal+0x56>
            printf("AesSetKey failed, ret = %d\n", ret);
  50:	4834      	ldr	r0, [pc, #208]	; (124 <bench_aescbc_internal+0x124>)
  52:	4621      	mov	r1, r4
  54:	e7eb      	b.n	2e <bench_aescbc_internal+0x2e>
    bench_stats_start(&count, &start);
  56:	a906      	add	r1, sp, #24
  58:	a805      	add	r0, sp, #20
  5a:	f7ff fffe 	bl	0 <bench_aescbc_internal>
        for (times = 0; times < numBlocks || pending > 0; ) {
  5e:	4f32      	ldr	r7, [pc, #200]	; (128 <bench_aescbc_internal+0x128>)
                    ret = wc_AesCbcEncrypt(&enc[i], bench_plain, bench_cipher,
  60:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 12c <bench_aescbc_internal+0x12c>
        for (times = 0; times < numBlocks || pending > 0; ) {
  64:	2600      	movs	r6, #0
  66:	683b      	ldr	r3, [r7, #0]
  68:	42b3      	cmp	r3, r6
  6a:	dc4c      	bgt.n	106 <bench_aescbc_internal+0x106>
        count += times;
  6c:	9b05      	ldr	r3, [sp, #20]
    } while (bench_stats_check(start));
  6e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count += times;
  72:	4433      	add	r3, r6
  74:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
  76:	f7ff fffe 	bl	0 <bench_aescbc_internal>
  7a:	2800      	cmp	r0, #0
  7c:	d1f2      	bne.n	64 <bench_aescbc_internal+0x64>
    bench_stats_sym_finish(encLabel, useDeviceID, count,
  7e:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  82:	e9cd 2300 	strd	r2, r3, [sp]
  86:	4e29      	ldr	r6, [pc, #164]	; (12c <bench_aescbc_internal+0x12c>)
  88:	9402      	str	r4, [sp, #8]
  8a:	6832      	ldr	r2, [r6, #0]
  8c:	9905      	ldr	r1, [sp, #20]
  8e:	985e      	ldr	r0, [sp, #376]	; 0x178
  90:	f7ff fffe 	bl	0 <bench_aescbc_internal>
    if (ret < 0) {
  94:	2c00      	cmp	r4, #0
  96:	dbcc      	blt.n	32 <bench_aescbc_internal+0x32>
        ret = wc_AesSetKey(&enc[i], key, keySz, iv, AES_DECRYPTION);
  98:	2301      	movs	r3, #1
  9a:	9300      	str	r3, [sp, #0]
  9c:	4642      	mov	r2, r8
  9e:	464b      	mov	r3, r9
  a0:	4629      	mov	r1, r5
  a2:	a808      	add	r0, sp, #32
  a4:	f7ff fffe 	bl	0 <wc_AesSetKey>
        if (ret != 0) {
  a8:	4604      	mov	r4, r0
  aa:	2800      	cmp	r0, #0
  ac:	d1d0      	bne.n	50 <bench_aescbc_internal+0x50>
    bench_stats_start(&count, &start);
  ae:	a906      	add	r1, sp, #24
  b0:	a805      	add	r0, sp, #20
  b2:	f7ff fffe 	bl	0 <bench_aescbc_internal>
                    ret = wc_AesCbcDecrypt(&enc[i], bench_cipher, bench_plain,
  b6:	f8df 8078 	ldr.w	r8, [pc, #120]	; 130 <bench_aescbc_internal+0x130>
  ba:	f8df 9078 	ldr.w	r9, [pc, #120]	; 134 <bench_aescbc_internal+0x134>
        for (times = 0; times < numBlocks || pending > 0; ) {
  be:	2500      	movs	r5, #0
  c0:	683b      	ldr	r3, [r7, #0]
  c2:	42ab      	cmp	r3, r5
  c4:	dc13      	bgt.n	ee <bench_aescbc_internal+0xee>
        count += times;
  c6:	9b05      	ldr	r3, [sp, #20]
    } while (bench_stats_check(start));
  c8:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count += times;
  cc:	442b      	add	r3, r5
  ce:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
  d0:	f7ff fffe 	bl	0 <bench_aescbc_internal>
  d4:	2800      	cmp	r0, #0
  d6:	d1f2      	bne.n	be <bench_aescbc_internal+0xbe>
    bench_stats_sym_finish(decLabel, useDeviceID, count, bench_size,
  d8:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  dc:	e9cd 2300 	strd	r2, r3, [sp]
  e0:	9402      	str	r4, [sp, #8]
  e2:	6832      	ldr	r2, [r6, #0]
  e4:	9905      	ldr	r1, [sp, #20]
  e6:	985f      	ldr	r0, [sp, #380]	; 0x17c
  e8:	f7ff fffe 	bl	0 <bench_aescbc_internal>
  ec:	e7a1      	b.n	32 <bench_aescbc_internal+0x32>
                    ret = wc_AesCbcDecrypt(&enc[i], bench_cipher, bench_plain,
  ee:	6833      	ldr	r3, [r6, #0]
  f0:	f8d8 2000 	ldr.w	r2, [r8]
  f4:	f8d9 1000 	ldr.w	r1, [r9]
  f8:	a808      	add	r0, sp, #32
  fa:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
        if (*ret >= 0) {
  fe:	1e04      	subs	r4, r0, #0
 100:	dbea      	blt.n	d8 <bench_aescbc_internal+0xd8>
            (*times)++;
 102:	3501      	adds	r5, #1
            for (i = 0; i < BENCH_MAX_PENDING; i++) {
 104:	e7dc      	b.n	c0 <bench_aescbc_internal+0xc0>
                    ret = wc_AesCbcEncrypt(&enc[i], bench_plain, bench_cipher,
 106:	4a0b      	ldr	r2, [pc, #44]	; (134 <bench_aescbc_internal+0x134>)
 108:	4909      	ldr	r1, [pc, #36]	; (130 <bench_aescbc_internal+0x130>)
 10a:	f8da 3000 	ldr.w	r3, [sl]
 10e:	6812      	ldr	r2, [r2, #0]
 110:	6809      	ldr	r1, [r1, #0]
 112:	a808      	add	r0, sp, #32
 114:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
        if (*ret >= 0) {
 118:	1e04      	subs	r4, r0, #0
 11a:	dbb0      	blt.n	7e <bench_aescbc_internal+0x7e>
            (*times)++;
 11c:	3601      	adds	r6, #1
            for (i = 0; i < BENCH_MAX_PENDING; i++) {
 11e:	e7a2      	b.n	66 <bench_aescbc_internal+0x66>
 120:	00000025 	.word	0x00000025
	...

Disassembly of section .text.benchmark_init:

00000000 <benchmark_init>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    if (gBenchStaticInit == 0 || force) {
   2:	4923      	ldr	r1, [pc, #140]	; (90 <benchmark_init+0x90>)
   4:	680b      	ldr	r3, [r1, #0]
   6:	bb13      	cbnz	r3, 4e <benchmark_init+0x4e>
        gBenchStaticInit = 1;
   8:	2201      	movs	r2, #1
   a:	600a      	str	r2, [r1, #0]
        numBlocks  = NUM_BLOCKS;
   c:	4921      	ldr	r1, [pc, #132]	; (94 <benchmark_init+0x94>)
   e:	2019      	movs	r0, #25
  10:	6008      	str	r0, [r1, #0]
        bench_size = BENCH_SIZE;
  12:	4921      	ldr	r1, [pc, #132]	; (98 <benchmark_init+0x98>)
  14:	f44f 6080 	mov.w	r0, #1024	; 0x400
  18:	6008      	str	r0, [r1, #0]
        aesAuthAddSz    = AES_AUTH_ADD_SZ;
  1a:	4920      	ldr	r1, [pc, #128]	; (9c <benchmark_init+0x9c>)
  1c:	200d      	movs	r0, #13
  1e:	6008      	str	r0, [r1, #0]
        aes_aad_options = AES_AAD_OPTIONS_DEFAULT;
  20:	491f      	ldr	r1, [pc, #124]	; (a0 <benchmark_init+0xa0>)
  22:	2003      	movs	r0, #3
  24:	6008      	str	r0, [r1, #0]
        aes_aad_size    = 0;
  26:	491f      	ldr	r1, [pc, #124]	; (a4 <benchmark_init+0xa4>)
  28:	600b      	str	r3, [r1, #0]
        base2 = 1;
  2a:	491f      	ldr	r1, [pc, #124]	; (a8 <benchmark_init+0xa8>)
  2c:	600a      	str	r2, [r1, #0]
        digest_stream = 1;
  2e:	491f      	ldr	r1, [pc, #124]	; (ac <benchmark_init+0xac>)
  30:	600a      	str	r2, [r1, #0]
        bench_all = 1;
  32:	491f      	ldr	r1, [pc, #124]	; (b0 <benchmark_init+0xb0>)
  34:	600a      	str	r2, [r1, #0]
        bench_cipher_algs = 0;
  36:	4a1f      	ldr	r2, [pc, #124]	; (b4 <benchmark_init+0xb4>)
  38:	6013      	str	r3, [r2, #0]
        bench_digest_algs = 0;
  3a:	4a1f      	ldr	r2, [pc, #124]	; (b8 <benchmark_init+0xb8>)
  3c:	6013      	str	r3, [r2, #0]
        bench_mac_algs = 0;
  3e:	4a1f      	ldr	r2, [pc, #124]	; (bc <benchmark_init+0xbc>)
  40:	6013      	str	r3, [r2, #0]
        bench_asym_algs = 0;
  42:	4a1f      	ldr	r2, [pc, #124]	; (c0 <benchmark_init+0xc0>)
  44:	6013      	str	r3, [r2, #0]
        bench_other_algs = 0;
  46:	4a1f      	ldr	r2, [pc, #124]	; (c4 <benchmark_init+0xc4>)
  48:	6013      	str	r3, [r2, #0]
        csv_format = 0;
  4a:	4a1f      	ldr	r2, [pc, #124]	; (c8 <benchmark_init+0xc8>)
  4c:	6013      	str	r3, [r2, #0]
    if ((ret = wolfCrypt_Init()) != 0) {
  4e:	f7ff fffe 	bl	0 <wolfCrypt_Init>
  52:	4604      	mov	r4, r0
  54:	b140      	cbz	r0, 68 <benchmark_init+0x68>
        printf("%swolfCrypt_Init failed %d\n", err_prefix, ret);
  56:	4602      	mov	r2, r0
  58:	491c      	ldr	r1, [pc, #112]	; (cc <benchmark_init+0xcc>)
  5a:	481d      	ldr	r0, [pc, #116]	; (d0 <benchmark_init+0xd0>)
  5c:	f7ff fffe 	bl	0 <printf>
        return EXIT_FAILURE;
  60:	2401      	movs	r4, #1
}
  62:	4620      	mov	r0, r4
  64:	b002      	add	sp, #8
  66:	bd10      	pop	{r4, pc}
    printf("%swolfCrypt Benchmark (block bytes %d, min " FLT_FMT_PREC " sec each)\n",
  68:	4b1a      	ldr	r3, [pc, #104]	; (d4 <benchmark_init+0xd4>)
  6a:	491b      	ldr	r1, [pc, #108]	; (d8 <benchmark_init+0xd8>)
  6c:	481b      	ldr	r0, [pc, #108]	; (dc <benchmark_init+0xdc>)
  6e:	2200      	movs	r2, #0
  70:	e9cd 2300 	strd	r2, r3, [sp]
  74:	4a08      	ldr	r2, [pc, #32]	; (98 <benchmark_init+0x98>)
  76:	2301      	movs	r3, #1
  78:	6812      	ldr	r2, [r2, #0]
  7a:	f7ff fffe 	bl	0 <printf>
    if (csv_format == 1) {
  7e:	4b12      	ldr	r3, [pc, #72]	; (c8 <benchmark_init+0xc8>)
  80:	681b      	ldr	r3, [r3, #0]
  82:	2b01      	cmp	r3, #1
  84:	d1ed      	bne.n	62 <benchmark_init+0x62>
        printf("This format allows you to easily copy "
  86:	4816      	ldr	r0, [pc, #88]	; (e0 <benchmark_init+0xe0>)
  88:	f7ff fffe 	bl	0 <printf>
  8c:	e7e9      	b.n	62 <benchmark_init+0x62>
  8e:	bf00      	nop
	...
  d4:	3ff00000 	.word	0x3ff00000
  d8:	00000000 	.word	0x00000000
  dc:	0000001c 	.word	0x0000001c
  e0:	00000057 	.word	0x00000057

Disassembly of section .text.benchmark_free:

00000000 <benchmark_free>:
{
   0:	b510      	push	{r4, lr}
    if ((ret = wolfCrypt_Cleanup()) != 0) {
   2:	f7ff fffe 	bl	0 <wolfCrypt_Cleanup>
   6:	4604      	mov	r4, r0
   8:	b120      	cbz	r0, 14 <benchmark_free+0x14>
        printf("%serror %d with wolfCrypt_Cleanup\n", err_prefix, ret);
   a:	4602      	mov	r2, r0
   c:	4902      	ldr	r1, [pc, #8]	; (18 <benchmark_free+0x18>)
   e:	4803      	ldr	r0, [pc, #12]	; (1c <benchmark_free+0x1c>)
  10:	f7ff fffe 	bl	0 <printf>
}
  14:	4620      	mov	r0, r4
  16:	bd10      	pop	{r4, pc}
	...

Disassembly of section .text.bench_rng:

00000000 <bench_rng>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	b08a      	sub	sp, #40	; 0x28
    ret = wc_InitRng_ex(&myrng, HEAP_HINT, devId);
   6:	f06f 0201 	mvn.w	r2, #1
   a:	2100      	movs	r1, #0
   c:	a808      	add	r0, sp, #32
   e:	f7ff fffe 	bl	0 <wc_InitRng_ex>
    if (ret < 0) {
  12:	1e04      	subs	r4, r0, #0
  14:	da06      	bge.n	24 <bench_rng+0x24>
        printf("InitRNG failed %d\n", ret);
  16:	4823      	ldr	r0, [pc, #140]	; (a4 <bench_rng+0xa4>)
  18:	4621      	mov	r1, r4
  1a:	f7ff fffe 	bl	0 <printf>
}
  1e:	b00a      	add	sp, #40	; 0x28
  20:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    bench_stats_start(&count, &start);
  24:	a906      	add	r1, sp, #24
  26:	a805      	add	r0, sp, #20
  28:	f7ff fffe 	bl	0 <bench_rng>
        for (i = 0; i < numBlocks; i++) {
  2c:	f8df 8078 	ldr.w	r8, [pc, #120]	; a8 <bench_rng+0xa8>
                ret = wc_RNG_GenerateBlock(&myrng, &bench_plain[pos],
  30:	f8df 9078 	ldr.w	r9, [pc, #120]	; ac <bench_rng+0xac>
        for (i = 0; i < numBlocks; i++) {
  34:	2500      	movs	r5, #0
  36:	f8d8 3000 	ldr.w	r3, [r8]
  3a:	42ab      	cmp	r3, r5
  3c:	dc17      	bgt.n	6e <bench_rng+0x6e>
        count += i;
  3e:	9b05      	ldr	r3, [sp, #20]
    } while (bench_stats_check(start));
  40:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count += i;
  44:	442b      	add	r3, r5
  46:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
  48:	f7ff fffe 	bl	0 <bench_rng>
  4c:	2800      	cmp	r0, #0
  4e:	d1f1      	bne.n	34 <bench_rng+0x34>
    bench_stats_sym_finish("RNG", 0, count, bench_size, start, ret);
  50:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  54:	e9cd 2300 	strd	r2, r3, [sp]
  58:	4b15      	ldr	r3, [pc, #84]	; (b0 <bench_rng+0xb0>)
  5a:	9402      	str	r4, [sp, #8]
  5c:	681a      	ldr	r2, [r3, #0]
  5e:	9905      	ldr	r1, [sp, #20]
  60:	4814      	ldr	r0, [pc, #80]	; (b4 <bench_rng+0xb4>)
  62:	f7ff fffe 	bl	0 <bench_rng>
    wc_FreeRng(&myrng);
  66:	a808      	add	r0, sp, #32
  68:	f7ff fffe 	bl	0 <wc_FreeRng>
  6c:	e7d7      	b.n	1e <bench_rng+0x1e>
            remain = (int)bench_size;
  6e:	4b10      	ldr	r3, [pc, #64]	; (b0 <bench_rng+0xb0>)
  70:	681e      	ldr	r6, [r3, #0]
            pos = 0;
  72:	2700      	movs	r7, #0
            while (remain > 0) {
  74:	2e00      	cmp	r6, #0
  76:	dc01      	bgt.n	7c <bench_rng+0x7c>
        for (i = 0; i < numBlocks; i++) {
  78:	3501      	adds	r5, #1
  7a:	e7dc      	b.n	36 <bench_rng+0x36>
                if (len > RNG_MAX_BLOCK_LEN)
  7c:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
                ret = wc_RNG_GenerateBlock(&myrng, &bench_plain[pos],
  80:	f8d9 1000 	ldr.w	r1, [r9]
  84:	46b2      	mov	sl, r6
  86:	bfa8      	it	ge
  88:	f44f 3a80 	movge.w	sl, #65536	; 0x10000
  8c:	4652      	mov	r2, sl
  8e:	4439      	add	r1, r7
  90:	a808      	add	r0, sp, #32
  92:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
                if (ret < 0)
  96:	1e04      	subs	r4, r0, #0
  98:	dbda      	blt.n	50 <bench_rng+0x50>
                remain -= len;
  9a:	eba6 060a 	sub.w	r6, r6, sl
                pos += len;
  9e:	4457      	add	r7, sl
  a0:	e7e8      	b.n	74 <bench_rng+0x74>
  a2:	bf00      	nop
	...
  b4:	00000013 	.word	0x00000013

Disassembly of section .text.bench_aescbc:

00000000 <bench_aescbc>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    bench_aescbc_internal(useDeviceID, bench_key, 16, bench_iv,
   2:	4b11      	ldr	r3, [pc, #68]	; (48 <bench_aescbc+0x48>)
   4:	4e11      	ldr	r6, [pc, #68]	; (4c <bench_aescbc+0x4c>)
   6:	4d12      	ldr	r5, [pc, #72]	; (50 <bench_aescbc+0x50>)
   8:	9301      	str	r3, [sp, #4]
   a:	4b12      	ldr	r3, [pc, #72]	; (54 <bench_aescbc+0x54>)
   c:	6829      	ldr	r1, [r5, #0]
   e:	9300      	str	r3, [sp, #0]
  10:	2210      	movs	r2, #16
  12:	6833      	ldr	r3, [r6, #0]
{
  14:	4604      	mov	r4, r0
    bench_aescbc_internal(useDeviceID, bench_key, 16, bench_iv,
  16:	f7ff fffe 	bl	0 <bench_aescbc>
    bench_aescbc_internal(useDeviceID, bench_key, 24, bench_iv,
  1a:	4b0f      	ldr	r3, [pc, #60]	; (58 <bench_aescbc+0x58>)
  1c:	9301      	str	r3, [sp, #4]
  1e:	4b0f      	ldr	r3, [pc, #60]	; (5c <bench_aescbc+0x5c>)
  20:	6829      	ldr	r1, [r5, #0]
  22:	9300      	str	r3, [sp, #0]
  24:	4620      	mov	r0, r4
  26:	6833      	ldr	r3, [r6, #0]
  28:	2218      	movs	r2, #24
  2a:	f7ff fffe 	bl	0 <bench_aescbc>
    bench_aescbc_internal(useDeviceID, bench_key, 32, bench_iv,
  2e:	4b0c      	ldr	r3, [pc, #48]	; (60 <bench_aescbc+0x60>)
  30:	9301      	str	r3, [sp, #4]
  32:	4b0c      	ldr	r3, [pc, #48]	; (64 <bench_aescbc+0x64>)
  34:	9300      	str	r3, [sp, #0]
  36:	6829      	ldr	r1, [r5, #0]
  38:	6833      	ldr	r3, [r6, #0]
  3a:	2220      	movs	r2, #32
  3c:	4620      	mov	r0, r4
  3e:	f7ff fffe 	bl	0 <bench_aescbc>
}
  42:	b002      	add	sp, #8
  44:	bd70      	pop	{r4, r5, r6, pc}
  46:	bf00      	nop
	...
  54:	00000010 	.word	0x00000010
  58:	00000020 	.word	0x00000020
  5c:	00000030 	.word	0x00000030
  60:	00000040 	.word	0x00000040
  64:	00000050 	.word	0x00000050

Disassembly of section .text.bench_gmac:

00000000 <bench_gmac>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    XMEMSET(bench_plain, 0, bench_size);
   4:	4d27      	ldr	r5, [pc, #156]	; (a4 <bench_gmac+0xa4>)
   6:	4e28      	ldr	r6, [pc, #160]	; (a8 <bench_gmac+0xa8>)
   8:	682a      	ldr	r2, [r5, #0]
   a:	6830      	ldr	r0, [r6, #0]
        ret = wc_GmacUpdate(&gmac, bench_iv, 12, bench_plain, bench_size,
   c:	f8df 809c 	ldr.w	r8, [pc, #156]	; ac <bench_gmac+0xac>
{
  10:	b0db      	sub	sp, #364	; 0x16c
    int ret, count = 0;
  12:	2400      	movs	r4, #0
    XMEMSET(bench_plain, 0, bench_size);
  14:	4621      	mov	r1, r4
    XMEMSET(tag, 0, sizeof(tag));
  16:	af08      	add	r7, sp, #32
    int ret, count = 0;
  18:	9405      	str	r4, [sp, #20]
    XMEMSET(bench_plain, 0, bench_size);
  1a:	f7ff fffe 	bl	0 <memset>
    XMEMSET(tag, 0, sizeof(tag));
  1e:	2210      	movs	r2, #16
  20:	4621      	mov	r1, r4
  22:	4638      	mov	r0, r7
  24:	f7ff fffe 	bl	0 <memset>
    XMEMSET(&gmac, 0, sizeof(Gmac)); /* clear context */
  28:	f44f 729c 	mov.w	r2, #312	; 0x138
  2c:	4621      	mov	r1, r4
  2e:	a80c      	add	r0, sp, #48	; 0x30
  30:	f7ff fffe 	bl	0 <memset>
    (void)wc_AesInit((Aes*)&gmac, HEAP_HINT,
  34:	f06f 0201 	mvn.w	r2, #1
  38:	4621      	mov	r1, r4
  3a:	a80c      	add	r0, sp, #48	; 0x30
  3c:	f7ff fffe 	bl	0 <wc_AesInit>
    wc_GmacSetKey(&gmac, bench_key, 16);
  40:	4b1b      	ldr	r3, [pc, #108]	; (b0 <bench_gmac+0xb0>)
  42:	2210      	movs	r2, #16
  44:	6819      	ldr	r1, [r3, #0]
  46:	a80c      	add	r0, sp, #48	; 0x30
  48:	f7ff fffe 	bl	0 <wc_GmacSetKey>
    bench_stats_start(&count, &start);
  4c:	a906      	add	r1, sp, #24
  4e:	a805      	add	r0, sp, #20
  50:	f7ff fffe 	bl	0 <bench_gmac>
        ret = wc_GmacUpdate(&gmac, bench_iv, 12, bench_plain, bench_size,
  54:	f04f 0910 	mov.w	r9, #16
  58:	682b      	ldr	r3, [r5, #0]
  5a:	f8d8 1000 	ldr.w	r1, [r8]
  5e:	9300      	str	r3, [sp, #0]
  60:	e9cd 7901 	strd	r7, r9, [sp, #4]
  64:	6833      	ldr	r3, [r6, #0]
  66:	220c      	movs	r2, #12
  68:	a80c      	add	r0, sp, #48	; 0x30
  6a:	f7ff fffe 	bl	0 <wc_GmacUpdate>
        count++;
  6e:	9b05      	ldr	r3, [sp, #20]
        ret = wc_GmacUpdate(&gmac, bench_iv, 12, bench_plain, bench_size,
  70:	4604      	mov	r4, r0
        count++;
  72:	3301      	adds	r3, #1
    } while (bench_stats_check(start));
  74:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count++;
  78:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
  7a:	f7ff fffe 	bl	0 <bench_gmac>
  7e:	2800      	cmp	r0, #0
  80:	d1ea      	bne.n	58 <bench_gmac+0x58>
    wc_AesFree((Aes*)&gmac);
  82:	a80c      	add	r0, sp, #48	; 0x30
  84:	f7ff fffe 	bl	0 <wc_AesFree>
    bench_stats_sym_finish(gmacStr, 0, count, bench_size, start, ret);
  88:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  8c:	9905      	ldr	r1, [sp, #20]
  8e:	4809      	ldr	r0, [pc, #36]	; (b4 <bench_gmac+0xb4>)
  90:	9402      	str	r4, [sp, #8]
  92:	e9cd 2300 	strd	r2, r3, [sp]
  96:	682a      	ldr	r2, [r5, #0]
  98:	f7ff fffe 	bl	0 <bench_gmac>
}
  9c:	b05b      	add	sp, #364	; 0x16c
  9e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  a2:	bf00      	nop
	...

Disassembly of section .text.bench_des:

00000000 <bench_des>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int    ret = 0, i, count = 0, times, pending = 0;
   4:	2400      	movs	r4, #0
{
   6:	b0ee      	sub	sp, #440	; 0x1b8
    XMEMSET(enc, 0, sizeof(enc));
   8:	f44f 72ca 	mov.w	r2, #404	; 0x194
   c:	4621      	mov	r1, r4
   e:	a809      	add	r0, sp, #36	; 0x24
    int    ret = 0, i, count = 0, times, pending = 0;
  10:	9405      	str	r4, [sp, #20]
    XMEMSET(enc, 0, sizeof(enc));
  12:	f7ff fffe 	bl	0 <memset>
        if ((ret = wc_Des3Init(&enc[i], HEAP_HINT,
  16:	f06f 0201 	mvn.w	r2, #1
  1a:	4621      	mov	r1, r4
  1c:	a809      	add	r0, sp, #36	; 0x24
  1e:	f7ff fffe 	bl	0 <wc_Des3Init>
  22:	4603      	mov	r3, r0
  24:	b148      	cbz	r0, 3a <bench_des+0x3a>
            printf("Des3Init failed, ret = %d\n", ret);
  26:	4601      	mov	r1, r0
  28:	4820      	ldr	r0, [pc, #128]	; (ac <bench_des+0xac>)
            printf("Des3_SetKey failed, ret = %d\n", ret);
  2a:	f7ff fffe 	bl	0 <printf>
        wc_Des3Free(&enc[i]);
  2e:	a809      	add	r0, sp, #36	; 0x24
  30:	f7ff fffe 	bl	0 <wc_Des3Free>
}
  34:	b06e      	add	sp, #440	; 0x1b8
  36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret = wc_Des3_SetKey(&enc[i], bench_key, bench_iv, DES_ENCRYPTION);
  3a:	4a1d      	ldr	r2, [pc, #116]	; (b0 <bench_des+0xb0>)
  3c:	491d      	ldr	r1, [pc, #116]	; (b4 <bench_des+0xb4>)
  3e:	6812      	ldr	r2, [r2, #0]
  40:	6809      	ldr	r1, [r1, #0]
  42:	a809      	add	r0, sp, #36	; 0x24
  44:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
        if (ret != 0) {
  48:	4604      	mov	r4, r0
  4a:	b110      	cbz	r0, 52 <bench_des+0x52>
            printf("Des3_SetKey failed, ret = %d\n", ret);
  4c:	4601      	mov	r1, r0
  4e:	481a      	ldr	r0, [pc, #104]	; (b8 <bench_des+0xb8>)
  50:	e7eb      	b.n	2a <bench_des+0x2a>
    bench_stats_start(&count, &start);
  52:	a906      	add	r1, sp, #24
  54:	a805      	add	r0, sp, #20
  56:	f7ff fffe 	bl	0 <bench_des>
        for (times = 0; times < numBlocks || pending > 0; ) {
  5a:	4e18      	ldr	r6, [pc, #96]	; (bc <bench_des+0xbc>)
                    ret = wc_Des3_CbcEncrypt(&enc[i],
  5c:	4f18      	ldr	r7, [pc, #96]	; (c0 <bench_des+0xc0>)
  5e:	f8df 8064 	ldr.w	r8, [pc, #100]	; c4 <bench_des+0xc4>
        for (times = 0; times < numBlocks || pending > 0; ) {
  62:	2500      	movs	r5, #0
  64:	6833      	ldr	r3, [r6, #0]
  66:	42ab      	cmp	r3, r5
  68:	dc14      	bgt.n	94 <bench_des+0x94>
        count += times;
  6a:	9b05      	ldr	r3, [sp, #20]
    } while (bench_stats_check(start));
  6c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count += times;
  70:	442b      	add	r3, r5
  72:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
  74:	f7ff fffe 	bl	0 <bench_des>
  78:	2800      	cmp	r0, #0
  7a:	d1f0      	bne.n	5e <bench_des+0x5e>
    bench_stats_sym_finish("3DES", useDeviceID, count, bench_size, start, ret);
  7c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  80:	e9cd 2300 	strd	r2, r3, [sp]
  84:	4b0e      	ldr	r3, [pc, #56]	; (c0 <bench_des+0xc0>)
  86:	9402      	str	r4, [sp, #8]
  88:	681a      	ldr	r2, [r3, #0]
  8a:	9905      	ldr	r1, [sp, #20]
  8c:	480e      	ldr	r0, [pc, #56]	; (c8 <bench_des+0xc8>)
  8e:	f7ff fffe 	bl	0 <bench_des>
  92:	e7cc      	b.n	2e <bench_des+0x2e>
                    ret = wc_Des3_CbcEncrypt(&enc[i],
  94:	490d      	ldr	r1, [pc, #52]	; (cc <bench_des+0xcc>)
  96:	683b      	ldr	r3, [r7, #0]
  98:	f8d8 2000 	ldr.w	r2, [r8]
  9c:	6809      	ldr	r1, [r1, #0]
  9e:	a809      	add	r0, sp, #36	; 0x24
  a0:	f7ff fffe 	bl	0 <wc_Des3_CbcEncrypt>
        if (*ret >= 0) {
  a4:	1e04      	subs	r4, r0, #0
  a6:	dbe9      	blt.n	7c <bench_des+0x7c>
            (*times)++;
  a8:	3501      	adds	r5, #1
            for (i = 0; i < BENCH_MAX_PENDING; i++) {
  aa:	e7db      	b.n	64 <bench_des+0x64>
	...
  b8:	0000001b 	.word	0x0000001b
	...
  c8:	00000039 	.word	0x00000039
  cc:	00000000 	.word	0x00000000

Disassembly of section .text.bench_sha:

00000000 <bench_sha>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b0a3      	sub	sp, #140	; 0x8c
    int    ret = 0, i, count = 0, times, pending = 0;
   6:	2400      	movs	r4, #0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   8:	2014      	movs	r0, #20
    int    ret = 0, i, count = 0, times, pending = 0;
   a:	9405      	str	r4, [sp, #20]
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   c:	f7ff fffe 	bl	0 <malloc>
    XMEMSET(hash, 0, sizeof(hash));
  10:	2264      	movs	r2, #100	; 0x64
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
  12:	4605      	mov	r5, r0
    XMEMSET(hash, 0, sizeof(hash));
  14:	4621      	mov	r1, r4
  16:	a809      	add	r0, sp, #36	; 0x24
  18:	f7ff fffe 	bl	0 <memset>
    if (digest_stream) {
  1c:	4b3f      	ldr	r3, [pc, #252]	; (11c <bench_sha+0x11c>)
  1e:	681b      	ldr	r3, [r3, #0]
  20:	bb23      	cbnz	r3, 6c <bench_sha+0x6c>
        bench_stats_start(&count, &start);
  22:	a906      	add	r1, sp, #24
  24:	a805      	add	r0, sp, #20
  26:	f7ff fffe 	bl	0 <bench_sha>
            for (times = 0; times < numBlocks; times++) {
  2a:	4e3d      	ldr	r6, [pc, #244]	; (120 <bench_sha+0x120>)
                    ret = wc_ShaUpdate(hash, bench_plain, bench_size);
  2c:	4f3d      	ldr	r7, [pc, #244]	; (124 <bench_sha+0x124>)
  2e:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 128 <bench_sha+0x128>
            for (times = 0; times < numBlocks; times++) {
  32:	f04f 0800 	mov.w	r8, #0
  36:	6833      	ldr	r3, [r6, #0]
  38:	4543      	cmp	r3, r8
  3a:	dc48      	bgt.n	ce <bench_sha+0xce>
            count += times;
  3c:	9b05      	ldr	r3, [sp, #20]
        } while (bench_stats_check(start));
  3e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
            count += times;
  42:	4443      	add	r3, r8
  44:	9305      	str	r3, [sp, #20]
        } while (bench_stats_check(start));
  46:	f7ff fffe 	bl	0 <bench_sha>
  4a:	4604      	mov	r4, r0
  4c:	2800      	cmp	r0, #0
  4e:	d1ee      	bne.n	2e <bench_sha+0x2e>
exit_sha:
  50:	e031      	b.n	b6 <bench_sha+0xb6>
                printf("InitSha failed, ret = %d\n", ret);
  52:	4836      	ldr	r0, [pc, #216]	; (12c <bench_sha+0x12c>)
  54:	f7ff fffe 	bl	0 <printf>
        wc_ShaFree(&hash[i]);
  58:	a809      	add	r0, sp, #36	; 0x24
  5a:	f7ff fffe 	bl	0 <wc_ShaFree>
    WC_FREE_ARRAY(digest, BENCH_MAX_PENDING, HEAP_HINT);
  5e:	b115      	cbz	r5, 66 <bench_sha+0x66>
  60:	4628      	mov	r0, r5
  62:	f7ff fffe 	bl	0 <free>
}
  66:	b023      	add	sp, #140	; 0x8c
  68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            ret = wc_InitSha_ex(&hash[i], HEAP_HINT,
  6c:	4621      	mov	r1, r4
  6e:	f06f 0201 	mvn.w	r2, #1
  72:	a809      	add	r0, sp, #36	; 0x24
  74:	f7ff fffe 	bl	0 <wc_InitSha_ex>
            if (ret != 0) {
  78:	4601      	mov	r1, r0
  7a:	2800      	cmp	r0, #0
  7c:	d1e9      	bne.n	52 <bench_sha+0x52>
        bench_stats_start(&count, &start);
  7e:	a906      	add	r1, sp, #24
  80:	a805      	add	r0, sp, #20
  82:	f7ff fffe 	bl	0 <bench_sha>
            for (times = 0; times < numBlocks || pending > 0; ) {
  86:	4f26      	ldr	r7, [pc, #152]	; (120 <bench_sha+0x120>)
                        ret = wc_ShaUpdate(&hash[i], bench_plain,
  88:	f8df 8098 	ldr.w	r8, [pc, #152]	; 124 <bench_sha+0x124>
  8c:	f8df 9098 	ldr.w	r9, [pc, #152]	; 128 <bench_sha+0x128>
            for (times = 0; times < numBlocks || pending > 0; ) {
  90:	2600      	movs	r6, #0
  92:	683b      	ldr	r3, [r7, #0]
  94:	42b3      	cmp	r3, r6
  96:	dc36      	bgt.n	106 <bench_sha+0x106>
            count += times;
  98:	9b05      	ldr	r3, [sp, #20]
                        ret = wc_ShaFinal(&hash[i], digest[i]);
  9a:	4629      	mov	r1, r5
            count += times;
  9c:	4433      	add	r3, r6
                        ret = wc_ShaFinal(&hash[i], digest[i]);
  9e:	a809      	add	r0, sp, #36	; 0x24
            count += times;
  a0:	9305      	str	r3, [sp, #20]
                        ret = wc_ShaFinal(&hash[i], digest[i]);
  a2:	f7ff fffe 	bl	0 <wc_ShaFinal>
        if (*ret >= 0) {
  a6:	1e04      	subs	r4, r0, #0
  a8:	db05      	blt.n	b6 <bench_sha+0xb6>
        } while (bench_stats_check(start));
  aa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  ae:	f7ff fffe 	bl	0 <bench_sha>
  b2:	2800      	cmp	r0, #0
  b4:	d1ea      	bne.n	8c <bench_sha+0x8c>
    bench_stats_sym_finish("SHA", useDeviceID, count, bench_size, start, ret);
  b6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  ba:	e9cd 2300 	strd	r2, r3, [sp]
  be:	4b19      	ldr	r3, [pc, #100]	; (124 <bench_sha+0x124>)
  c0:	9402      	str	r4, [sp, #8]
  c2:	681a      	ldr	r2, [r3, #0]
  c4:	9905      	ldr	r1, [sp, #20]
  c6:	481a      	ldr	r0, [pc, #104]	; (130 <bench_sha+0x130>)
  c8:	f7ff fffe 	bl	0 <bench_sha>
  cc:	e7c4      	b.n	58 <bench_sha+0x58>
                ret = wc_InitSha_ex(hash, HEAP_HINT,
  ce:	f06f 0201 	mvn.w	r2, #1
  d2:	2100      	movs	r1, #0
  d4:	a809      	add	r0, sp, #36	; 0x24
  d6:	f7ff fffe 	bl	0 <wc_InitSha_ex>
                if (ret == 0)
  da:	4604      	mov	r4, r0
  dc:	2800      	cmp	r0, #0
  de:	d1ea      	bne.n	b6 <bench_sha+0xb6>
                    ret = wc_ShaUpdate(hash, bench_plain, bench_size);
  e0:	683a      	ldr	r2, [r7, #0]
  e2:	f8d9 1000 	ldr.w	r1, [r9]
  e6:	a809      	add	r0, sp, #36	; 0x24
  e8:	f7ff fffe 	bl	0 <wc_ShaUpdate>
                if (ret == 0)
  ec:	4604      	mov	r4, r0
  ee:	2800      	cmp	r0, #0
  f0:	d1e1      	bne.n	b6 <bench_sha+0xb6>
                    ret = wc_ShaFinal(hash, digest[0]);
  f2:	4629      	mov	r1, r5
  f4:	a809      	add	r0, sp, #36	; 0x24
  f6:	f7ff fffe 	bl	0 <wc_ShaFinal>
                if (ret != 0)
  fa:	4604      	mov	r4, r0
  fc:	2800      	cmp	r0, #0
  fe:	d1da      	bne.n	b6 <bench_sha+0xb6>
            for (times = 0; times < numBlocks; times++) {
 100:	f108 0801 	add.w	r8, r8, #1
 104:	e797      	b.n	36 <bench_sha+0x36>
                        ret = wc_ShaUpdate(&hash[i], bench_plain,
 106:	f8d8 2000 	ldr.w	r2, [r8]
 10a:	f8d9 1000 	ldr.w	r1, [r9]
 10e:	a809      	add	r0, sp, #36	; 0x24
 110:	f7ff fffe 	bl	0 <wc_ShaUpdate>
        if (*ret >= 0) {
 114:	1e04      	subs	r4, r0, #0
 116:	dbce      	blt.n	b6 <bench_sha+0xb6>
            (*times)++;
 118:	3601      	adds	r6, #1
                for (i = 0; i < BENCH_MAX_PENDING; i++) {
 11a:	e7ba      	b.n	92 <bench_sha+0x92>
	...
 130:	0000001a 	.word	0x0000001a

Disassembly of section .text.bench_sha256:

00000000 <bench_sha256>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b0a5      	sub	sp, #148	; 0x94
    int    ret = 0, i, count = 0, times, pending = 0;
   6:	2400      	movs	r4, #0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   8:	2020      	movs	r0, #32
    int    ret = 0, i, count = 0, times, pending = 0;
   a:	9405      	str	r4, [sp, #20]
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   c:	f7ff fffe 	bl	0 <malloc>
    XMEMSET(hash, 0, sizeof(hash));
  10:	2270      	movs	r2, #112	; 0x70
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
  12:	4605      	mov	r5, r0
    XMEMSET(hash, 0, sizeof(hash));
  14:	4621      	mov	r1, r4
  16:	a808      	add	r0, sp, #32
  18:	f7ff fffe 	bl	0 <memset>
    if (digest_stream) {
  1c:	4b3f      	ldr	r3, [pc, #252]	; (11c <bench_sha256+0x11c>)
  1e:	681b      	ldr	r3, [r3, #0]
  20:	bb23      	cbnz	r3, 6c <bench_sha256+0x6c>
        bench_stats_start(&count, &start);
  22:	a906      	add	r1, sp, #24
  24:	a805      	add	r0, sp, #20
  26:	f7ff fffe 	bl	0 <bench_sha256>
            for (times = 0; times < numBlocks; times++) {
  2a:	4e3d      	ldr	r6, [pc, #244]	; (120 <bench_sha256+0x120>)
                    ret = wc_Sha256Update(hash, bench_plain, bench_size);
  2c:	4f3d      	ldr	r7, [pc, #244]	; (124 <bench_sha256+0x124>)
  2e:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 128 <bench_sha256+0x128>
            for (times = 0; times < numBlocks; times++) {
  32:	f04f 0800 	mov.w	r8, #0
  36:	6833      	ldr	r3, [r6, #0]
  38:	4543      	cmp	r3, r8
  3a:	dc48      	bgt.n	ce <bench_sha256+0xce>
            count += times;
  3c:	9b05      	ldr	r3, [sp, #20]
        } while (bench_stats_check(start));
  3e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
            count += times;
  42:	4443      	add	r3, r8
  44:	9305      	str	r3, [sp, #20]
        } while (bench_stats_check(start));
  46:	f7ff fffe 	bl	0 <bench_sha256>
  4a:	4604      	mov	r4, r0
  4c:	2800      	cmp	r0, #0
  4e:	d1ee      	bne.n	2e <bench_sha256+0x2e>
exit_sha256:
  50:	e031      	b.n	b6 <bench_sha256+0xb6>
                printf("InitSha256_ex failed, ret = %d\n", ret);
  52:	4836      	ldr	r0, [pc, #216]	; (12c <bench_sha256+0x12c>)
  54:	f7ff fffe 	bl	0 <printf>
        wc_Sha256Free(&hash[i]);
  58:	a808      	add	r0, sp, #32
  5a:	f7ff fffe 	bl	0 <wc_Sha256Free>
    WC_FREE_ARRAY(digest, BENCH_MAX_PENDING, HEAP_HINT);
  5e:	b115      	cbz	r5, 66 <bench_sha256+0x66>
  60:	4628      	mov	r0, r5
  62:	f7ff fffe 	bl	0 <free>
}
  66:	b025      	add	sp, #148	; 0x94
  68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            ret = wc_InitSha256_ex(&hash[i], HEAP_HINT,
  6c:	4621      	mov	r1, r4
  6e:	f06f 0201 	mvn.w	r2, #1
  72:	a808      	add	r0, sp, #32
  74:	f7ff fffe 	bl	0 <wc_InitSha256_ex>
            if (ret != 0) {
  78:	4601      	mov	r1, r0
  7a:	2800      	cmp	r0, #0
  7c:	d1e9      	bne.n	52 <bench_sha256+0x52>
        bench_stats_start(&count, &start);
  7e:	a906      	add	r1, sp, #24
  80:	a805      	add	r0, sp, #20
  82:	f7ff fffe 	bl	0 <bench_sha256>
            for (times = 0; times < numBlocks || pending > 0; ) {
  86:	4f26      	ldr	r7, [pc, #152]	; (120 <bench_sha256+0x120>)
                        ret = wc_Sha256Update(&hash[i], bench_plain,
  88:	f8df 8098 	ldr.w	r8, [pc, #152]	; 124 <bench_sha256+0x124>
  8c:	f8df 9098 	ldr.w	r9, [pc, #152]	; 128 <bench_sha256+0x128>
            for (times = 0; times < numBlocks || pending > 0; ) {
  90:	2600      	movs	r6, #0
  92:	683b      	ldr	r3, [r7, #0]
  94:	42b3      	cmp	r3, r6
  96:	dc36      	bgt.n	106 <bench_sha256+0x106>
            count += times;
  98:	9b05      	ldr	r3, [sp, #20]
                        ret = wc_Sha256Final(&hash[i], digest[i]);
  9a:	4629      	mov	r1, r5
            count += times;
  9c:	4433      	add	r3, r6
                        ret = wc_Sha256Final(&hash[i], digest[i]);
  9e:	a808      	add	r0, sp, #32
            count += times;
  a0:	9305      	str	r3, [sp, #20]
                        ret = wc_Sha256Final(&hash[i], digest[i]);
  a2:	f7ff fffe 	bl	0 <wc_Sha256Final>
        if (*ret >= 0) {
  a6:	1e04      	subs	r4, r0, #0
  a8:	db05      	blt.n	b6 <bench_sha256+0xb6>
        } while (bench_stats_check(start));
  aa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  ae:	f7ff fffe 	bl	0 <bench_sha256>
  b2:	2800      	cmp	r0, #0
  b4:	d1ea      	bne.n	8c <bench_sha256+0x8c>
    bench_stats_sym_finish("SHA-256", useDeviceID, count, bench_size,
  b6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  ba:	e9cd 2300 	strd	r2, r3, [sp]
  be:	4b19      	ldr	r3, [pc, #100]	; (124 <bench_sha256+0x124>)
  c0:	9402      	str	r4, [sp, #8]
  c2:	681a      	ldr	r2, [r3, #0]
  c4:	9905      	ldr	r1, [sp, #20]
  c6:	481a      	ldr	r0, [pc, #104]	; (130 <bench_sha256+0x130>)
  c8:	f7ff fffe 	bl	0 <bench_sha256>
  cc:	e7c4      	b.n	58 <bench_sha256+0x58>
                ret = wc_InitSha256_ex(hash, HEAP_HINT,
  ce:	f06f 0201 	mvn.w	r2, #1
  d2:	2100      	movs	r1, #0
  d4:	a808      	add	r0, sp, #32
  d6:	f7ff fffe 	bl	0 <wc_InitSha256_ex>
                if (ret == 0)
  da:	4604      	mov	r4, r0
  dc:	2800      	cmp	r0, #0
  de:	d1ea      	bne.n	b6 <bench_sha256+0xb6>
                    ret = wc_Sha256Update(hash, bench_plain, bench_size);
  e0:	683a      	ldr	r2, [r7, #0]
  e2:	f8d9 1000 	ldr.w	r1, [r9]
  e6:	a808      	add	r0, sp, #32
  e8:	f7ff fffe 	bl	0 <wc_Sha256Update>
                if (ret == 0)
  ec:	4604      	mov	r4, r0
  ee:	2800      	cmp	r0, #0
  f0:	d1e1      	bne.n	b6 <bench_sha256+0xb6>
                    ret = wc_Sha256Final(hash, digest[0]);
  f2:	4629      	mov	r1, r5
  f4:	a808      	add	r0, sp, #32
  f6:	f7ff fffe 	bl	0 <wc_Sha256Final>
                if (ret != 0)
  fa:	4604      	mov	r4, r0
  fc:	2800      	cmp	r0, #0
  fe:	d1da      	bne.n	b6 <bench_sha256+0xb6>
            for (times = 0; times < numBlocks; times++) {
 100:	f108 0801 	add.w	r8, r8, #1
 104:	e797      	b.n	36 <bench_sha256+0x36>
                        ret = wc_Sha256Update(&hash[i], bench_plain,
 106:	f8d8 2000 	ldr.w	r2, [r8]
 10a:	f8d9 1000 	ldr.w	r1, [r9]
 10e:	a808      	add	r0, sp, #32
 110:	f7ff fffe 	bl	0 <wc_Sha256Update>
        if (*ret >= 0) {
 114:	1e04      	subs	r4, r0, #0
 116:	dbce      	blt.n	b6 <bench_sha256+0xb6>
            (*times)++;
 118:	3601      	adds	r6, #1
                for (i = 0; i < BENCH_MAX_PENDING; i++) {
 11a:	e7ba      	b.n	92 <bench_sha256+0x92>
	...
 130:	00000020 	.word	0x00000020

Disassembly of section .text.bench_sha512:

00000000 <bench_sha512>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b0c1      	sub	sp, #260	; 0x104
    int    ret = 0, i, count = 0, times, pending = 0;
   6:	2400      	movs	r4, #0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   8:	2040      	movs	r0, #64	; 0x40
    int    ret = 0, i, count = 0, times, pending = 0;
   a:	9405      	str	r4, [sp, #20]
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   c:	f7ff fffe 	bl	0 <malloc>
    XMEMSET(hash, 0, sizeof(hash));
  10:	22e0      	movs	r2, #224	; 0xe0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
  12:	4605      	mov	r5, r0
    XMEMSET(hash, 0, sizeof(hash));
  14:	4621      	mov	r1, r4
  16:	a808      	add	r0, sp, #32
  18:	f7ff fffe 	bl	0 <memset>
    if (digest_stream) {
  1c:	4b3f      	ldr	r3, [pc, #252]	; (11c <bench_sha512+0x11c>)
  1e:	681b      	ldr	r3, [r3, #0]
  20:	bb23      	cbnz	r3, 6c <bench_sha512+0x6c>
        bench_stats_start(&count, &start);
  22:	a906      	add	r1, sp, #24
  24:	a805      	add	r0, sp, #20
  26:	f7ff fffe 	bl	0 <bench_sha512>
            for (times = 0; times < numBlocks; times++) {
  2a:	4e3d      	ldr	r6, [pc, #244]	; (120 <bench_sha512+0x120>)
                    ret = wc_Sha512Update(hash, bench_plain, bench_size);
  2c:	4f3d      	ldr	r7, [pc, #244]	; (124 <bench_sha512+0x124>)
  2e:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 128 <bench_sha512+0x128>
            for (times = 0; times < numBlocks; times++) {
  32:	f04f 0800 	mov.w	r8, #0
  36:	6833      	ldr	r3, [r6, #0]
  38:	4543      	cmp	r3, r8
  3a:	dc48      	bgt.n	ce <bench_sha512+0xce>
            count += times;
  3c:	9b05      	ldr	r3, [sp, #20]
        } while (bench_stats_check(start));
  3e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
            count += times;
  42:	4443      	add	r3, r8
  44:	9305      	str	r3, [sp, #20]
        } while (bench_stats_check(start));
  46:	f7ff fffe 	bl	0 <bench_sha512>
  4a:	4604      	mov	r4, r0
  4c:	2800      	cmp	r0, #0
  4e:	d1ee      	bne.n	2e <bench_sha512+0x2e>
exit_sha512:
  50:	e031      	b.n	b6 <bench_sha512+0xb6>
                printf("InitSha512_ex failed, ret = %d\n", ret);
  52:	4836      	ldr	r0, [pc, #216]	; (12c <bench_sha512+0x12c>)
  54:	f7ff fffe 	bl	0 <printf>
        wc_Sha512Free(&hash[i]);
  58:	a808      	add	r0, sp, #32
  5a:	f7ff fffe 	bl	0 <wc_Sha512Free>
    WC_FREE_ARRAY(digest, BENCH_MAX_PENDING, HEAP_HINT);
  5e:	b115      	cbz	r5, 66 <bench_sha512+0x66>
  60:	4628      	mov	r0, r5
  62:	f7ff fffe 	bl	0 <free>
}
  66:	b041      	add	sp, #260	; 0x104
  68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            ret = wc_InitSha512_ex(&hash[i], HEAP_HINT,
  6c:	4621      	mov	r1, r4
  6e:	f06f 0201 	mvn.w	r2, #1
  72:	a808      	add	r0, sp, #32
  74:	f7ff fffe 	bl	0 <wc_InitSha512_ex>
            if (ret != 0) {
  78:	4601      	mov	r1, r0
  7a:	2800      	cmp	r0, #0
  7c:	d1e9      	bne.n	52 <bench_sha512+0x52>
        bench_stats_start(&count, &start);
  7e:	a906      	add	r1, sp, #24
  80:	a805      	add	r0, sp, #20
  82:	f7ff fffe 	bl	0 <bench_sha512>
            for (times = 0; times < numBlocks || pending > 0; ) {
  86:	4f26      	ldr	r7, [pc, #152]	; (120 <bench_sha512+0x120>)
                        ret = wc_Sha512Update(&hash[i], bench_plain,
  88:	f8df 8098 	ldr.w	r8, [pc, #152]	; 124 <bench_sha512+0x124>
  8c:	f8df 9098 	ldr.w	r9, [pc, #152]	; 128 <bench_sha512+0x128>
            for (times = 0; times < numBlocks || pending > 0; ) {
  90:	2600      	movs	r6, #0
  92:	683b      	ldr	r3, [r7, #0]
  94:	42b3      	cmp	r3, r6
  96:	dc36      	bgt.n	106 <bench_sha512+0x106>
            count += times;
  98:	9b05      	ldr	r3, [sp, #20]
                        ret = wc_Sha512Final(&hash[i], digest[i]);
  9a:	4629      	mov	r1, r5
            count += times;
  9c:	4433      	add	r3, r6
                        ret = wc_Sha512Final(&hash[i], digest[i]);
  9e:	a808      	add	r0, sp, #32
            count += times;
  a0:	9305      	str	r3, [sp, #20]
                        ret = wc_Sha512Final(&hash[i], digest[i]);
  a2:	f7ff fffe 	bl	0 <wc_Sha512Final>
        if (*ret >= 0) {
  a6:	1e04      	subs	r4, r0, #0
  a8:	db05      	blt.n	b6 <bench_sha512+0xb6>
        } while (bench_stats_check(start));
  aa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  ae:	f7ff fffe 	bl	0 <bench_sha512>
  b2:	2800      	cmp	r0, #0
  b4:	d1ea      	bne.n	8c <bench_sha512+0x8c>
    bench_stats_sym_finish("SHA-512", useDeviceID, count, bench_size,
  b6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  ba:	e9cd 2300 	strd	r2, r3, [sp]
  be:	4b19      	ldr	r3, [pc, #100]	; (124 <bench_sha512+0x124>)
  c0:	9402      	str	r4, [sp, #8]
  c2:	681a      	ldr	r2, [r3, #0]
  c4:	9905      	ldr	r1, [sp, #20]
  c6:	481a      	ldr	r0, [pc, #104]	; (130 <bench_sha512+0x130>)
  c8:	f7ff fffe 	bl	0 <bench_sha512>
  cc:	e7c4      	b.n	58 <bench_sha512+0x58>
                ret = wc_InitSha512_ex(hash, HEAP_HINT,
  ce:	f06f 0201 	mvn.w	r2, #1
  d2:	2100      	movs	r1, #0
  d4:	a808      	add	r0, sp, #32
  d6:	f7ff fffe 	bl	0 <wc_InitSha512_ex>
                if (ret == 0)
  da:	4604      	mov	r4, r0
  dc:	2800      	cmp	r0, #0
  de:	d1ea      	bne.n	b6 <bench_sha512+0xb6>
                    ret = wc_Sha512Update(hash, bench_plain, bench_size);
  e0:	683a      	ldr	r2, [r7, #0]
  e2:	f8d9 1000 	ldr.w	r1, [r9]
  e6:	a808      	add	r0, sp, #32
  e8:	f7ff fffe 	bl	0 <wc_Sha512Update>
                if (ret == 0)
  ec:	4604      	mov	r4, r0
  ee:	2800      	cmp	r0, #0
  f0:	d1e1      	bne.n	b6 <bench_sha512+0xb6>
                    ret = wc_Sha512Final(hash, digest[0]);
  f2:	4629      	mov	r1, r5
  f4:	a808      	add	r0, sp, #32
  f6:	f7ff fffe 	bl	0 <wc_Sha512Final>
                if (ret != 0)
  fa:	4604      	mov	r4, r0
  fc:	2800      	cmp	r0, #0
  fe:	d1da      	bne.n	b6 <bench_sha512+0xb6>
            for (times = 0; times < numBlocks; times++) {
 100:	f108 0801 	add.w	r8, r8, #1
 104:	e797      	b.n	36 <bench_sha512+0x36>
                        ret = wc_Sha512Update(&hash[i], bench_plain,
 106:	f8d8 2000 	ldr.w	r2, [r8]
 10a:	f8d9 1000 	ldr.w	r1, [r9]
 10e:	a808      	add	r0, sp, #32
 110:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (*ret >= 0) {
 114:	1e04      	subs	r4, r0, #0
 116:	dbce      	blt.n	b6 <bench_sha512+0xb6>
            (*times)++;
 118:	3601      	adds	r6, #1
                for (i = 0; i < BENCH_MAX_PENDING; i++) {
 11a:	e7ba      	b.n	92 <bench_sha512+0x92>
	...
 130:	00000020 	.word	0x00000020

Disassembly of section .text.bench_sha512_224:

00000000 <bench_sha512_224>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b0c1      	sub	sp, #260	; 0x104
    int    ret = 0, i, count = 0, times, pending = 0;
   6:	2400      	movs	r4, #0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   8:	201c      	movs	r0, #28
    int    ret = 0, i, count = 0, times, pending = 0;
   a:	9405      	str	r4, [sp, #20]
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   c:	f7ff fffe 	bl	0 <malloc>
    XMEMSET(hash, 0, sizeof(hash));
  10:	22e0      	movs	r2, #224	; 0xe0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
  12:	4605      	mov	r5, r0
    XMEMSET(hash, 0, sizeof(hash));
  14:	4621      	mov	r1, r4
  16:	a808      	add	r0, sp, #32
  18:	f7ff fffe 	bl	0 <memset>
    if (digest_stream) {
  1c:	4b3f      	ldr	r3, [pc, #252]	; (11c <bench_sha512_224+0x11c>)
  1e:	681b      	ldr	r3, [r3, #0]
  20:	bb23      	cbnz	r3, 6c <bench_sha512_224+0x6c>
        bench_stats_start(&count, &start);
  22:	a906      	add	r1, sp, #24
  24:	a805      	add	r0, sp, #20
  26:	f7ff fffe 	bl	0 <bench_sha512_224>
            for (times = 0; times < numBlocks; times++) {
  2a:	4e3d      	ldr	r6, [pc, #244]	; (120 <bench_sha512_224+0x120>)
                    ret = wc_Sha512_224Update(hash, bench_plain, bench_size);
  2c:	4f3d      	ldr	r7, [pc, #244]	; (124 <bench_sha512_224+0x124>)
  2e:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 128 <bench_sha512_224+0x128>
            for (times = 0; times < numBlocks; times++) {
  32:	f04f 0800 	mov.w	r8, #0
  36:	6833      	ldr	r3, [r6, #0]
  38:	4543      	cmp	r3, r8
  3a:	dc48      	bgt.n	ce <bench_sha512_224+0xce>
            count += times;
  3c:	9b05      	ldr	r3, [sp, #20]
        } while (bench_stats_check(start));
  3e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
            count += times;
  42:	4443      	add	r3, r8
  44:	9305      	str	r3, [sp, #20]
        } while (bench_stats_check(start));
  46:	f7ff fffe 	bl	0 <bench_sha512_224>
  4a:	4604      	mov	r4, r0
  4c:	2800      	cmp	r0, #0
  4e:	d1ee      	bne.n	2e <bench_sha512_224+0x2e>
exit_sha512_224:
  50:	e031      	b.n	b6 <bench_sha512_224+0xb6>
                printf("InitSha512_224_ex failed, ret = %d\n", ret);
  52:	4836      	ldr	r0, [pc, #216]	; (12c <bench_sha512_224+0x12c>)
  54:	f7ff fffe 	bl	0 <printf>
        wc_Sha512_224Free(&hash[i]);
  58:	a808      	add	r0, sp, #32
  5a:	f7ff fffe 	bl	0 <wc_Sha512_224Free>
    WC_FREE_ARRAY(digest, BENCH_MAX_PENDING, HEAP_HINT);
  5e:	b115      	cbz	r5, 66 <bench_sha512_224+0x66>
  60:	4628      	mov	r0, r5
  62:	f7ff fffe 	bl	0 <free>
}
  66:	b041      	add	sp, #260	; 0x104
  68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            ret = wc_InitSha512_224_ex(&hash[i], HEAP_HINT,
  6c:	4621      	mov	r1, r4
  6e:	f06f 0201 	mvn.w	r2, #1
  72:	a808      	add	r0, sp, #32
  74:	f7ff fffe 	bl	0 <wc_InitSha512_224_ex>
            if (ret != 0) {
  78:	4601      	mov	r1, r0
  7a:	2800      	cmp	r0, #0
  7c:	d1e9      	bne.n	52 <bench_sha512_224+0x52>
        bench_stats_start(&count, &start);
  7e:	a906      	add	r1, sp, #24
  80:	a805      	add	r0, sp, #20
  82:	f7ff fffe 	bl	0 <bench_sha512_224>
            for (times = 0; times < numBlocks || pending > 0; ) {
  86:	4f26      	ldr	r7, [pc, #152]	; (120 <bench_sha512_224+0x120>)
                        ret = wc_Sha512_224Update(&hash[i], bench_plain,
  88:	f8df 8098 	ldr.w	r8, [pc, #152]	; 124 <bench_sha512_224+0x124>
  8c:	f8df 9098 	ldr.w	r9, [pc, #152]	; 128 <bench_sha512_224+0x128>
            for (times = 0; times < numBlocks || pending > 0; ) {
  90:	2600      	movs	r6, #0
  92:	683b      	ldr	r3, [r7, #0]
  94:	42b3      	cmp	r3, r6
  96:	dc36      	bgt.n	106 <bench_sha512_224+0x106>
            count += times;
  98:	9b05      	ldr	r3, [sp, #20]
                        ret = wc_Sha512_224Final(&hash[i], digest[i]);
  9a:	4629      	mov	r1, r5
            count += times;
  9c:	4433      	add	r3, r6
                        ret = wc_Sha512_224Final(&hash[i], digest[i]);
  9e:	a808      	add	r0, sp, #32
            count += times;
  a0:	9305      	str	r3, [sp, #20]
                        ret = wc_Sha512_224Final(&hash[i], digest[i]);
  a2:	f7ff fffe 	bl	0 <wc_Sha512_224Final>
        if (*ret >= 0) {
  a6:	1e04      	subs	r4, r0, #0
  a8:	db05      	blt.n	b6 <bench_sha512_224+0xb6>
        } while (bench_stats_check(start));
  aa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  ae:	f7ff fffe 	bl	0 <bench_sha512_224>
  b2:	2800      	cmp	r0, #0
  b4:	d1ea      	bne.n	8c <bench_sha512_224+0x8c>
    bench_stats_sym_finish("SHA-512/224", useDeviceID, count, bench_size,
  b6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  ba:	e9cd 2300 	strd	r2, r3, [sp]
  be:	4b19      	ldr	r3, [pc, #100]	; (124 <bench_sha512_224+0x124>)
  c0:	9402      	str	r4, [sp, #8]
  c2:	681a      	ldr	r2, [r3, #0]
  c4:	9905      	ldr	r1, [sp, #20]
  c6:	481a      	ldr	r0, [pc, #104]	; (130 <bench_sha512_224+0x130>)
  c8:	f7ff fffe 	bl	0 <bench_sha512_224>
  cc:	e7c4      	b.n	58 <bench_sha512_224+0x58>
                ret = wc_InitSha512_224_ex(hash, HEAP_HINT,
  ce:	f06f 0201 	mvn.w	r2, #1
  d2:	2100      	movs	r1, #0
  d4:	a808      	add	r0, sp, #32
  d6:	f7ff fffe 	bl	0 <wc_InitSha512_224_ex>
                if (ret == 0)
  da:	4604      	mov	r4, r0
  dc:	2800      	cmp	r0, #0
  de:	d1ea      	bne.n	b6 <bench_sha512_224+0xb6>
                    ret = wc_Sha512_224Update(hash, bench_plain, bench_size);
  e0:	683a      	ldr	r2, [r7, #0]
  e2:	f8d9 1000 	ldr.w	r1, [r9]
  e6:	a808      	add	r0, sp, #32
  e8:	f7ff fffe 	bl	0 <wc_Sha512_224Update>
                if (ret == 0)
  ec:	4604      	mov	r4, r0
  ee:	2800      	cmp	r0, #0
  f0:	d1e1      	bne.n	b6 <bench_sha512_224+0xb6>
                    ret = wc_Sha512_224Final(hash, digest[0]);
  f2:	4629      	mov	r1, r5
  f4:	a808      	add	r0, sp, #32
  f6:	f7ff fffe 	bl	0 <wc_Sha512_224Final>
                if (ret != 0)
  fa:	4604      	mov	r4, r0
  fc:	2800      	cmp	r0, #0
  fe:	d1da      	bne.n	b6 <bench_sha512_224+0xb6>
            for (times = 0; times < numBlocks; times++) {
 100:	f108 0801 	add.w	r8, r8, #1
 104:	e797      	b.n	36 <bench_sha512_224+0x36>
                        ret = wc_Sha512_224Update(&hash[i], bench_plain,
 106:	f8d8 2000 	ldr.w	r2, [r8]
 10a:	f8d9 1000 	ldr.w	r1, [r9]
 10e:	a808      	add	r0, sp, #32
 110:	f7ff fffe 	bl	0 <wc_Sha512_224Update>
        if (*ret >= 0) {
 114:	1e04      	subs	r4, r0, #0
 116:	dbce      	blt.n	b6 <bench_sha512_224+0xb6>
            (*times)++;
 118:	3601      	adds	r6, #1
                for (i = 0; i < BENCH_MAX_PENDING; i++) {
 11a:	e7ba      	b.n	92 <bench_sha512_224+0x92>
	...
 130:	00000024 	.word	0x00000024

Disassembly of section .text.bench_sha512_256:

00000000 <bench_sha512_256>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b0c1      	sub	sp, #260	; 0x104
    int    ret = 0, i, count = 0, times, pending = 0;
   6:	2400      	movs	r4, #0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   8:	2020      	movs	r0, #32
    int    ret = 0, i, count = 0, times, pending = 0;
   a:	9405      	str	r4, [sp, #20]
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
   c:	f7ff fffe 	bl	0 <malloc>
    XMEMSET(hash, 0, sizeof(hash));
  10:	22e0      	movs	r2, #224	; 0xe0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING,
  12:	4605      	mov	r5, r0
    XMEMSET(hash, 0, sizeof(hash));
  14:	4621      	mov	r1, r4
  16:	a808      	add	r0, sp, #32
  18:	f7ff fffe 	bl	0 <memset>
    if (digest_stream) {
  1c:	4b3f      	ldr	r3, [pc, #252]	; (11c <bench_sha512_256+0x11c>)
  1e:	681b      	ldr	r3, [r3, #0]
  20:	bb23      	cbnz	r3, 6c <bench_sha512_256+0x6c>
        bench_stats_start(&count, &start);
  22:	a906      	add	r1, sp, #24
  24:	a805      	add	r0, sp, #20
  26:	f7ff fffe 	bl	0 <bench_sha512_256>
            for (times = 0; times < numBlocks; times++) {
  2a:	4e3d      	ldr	r6, [pc, #244]	; (120 <bench_sha512_256+0x120>)
                    ret = wc_Sha512_256Update(hash, bench_plain, bench_size);
  2c:	4f3d      	ldr	r7, [pc, #244]	; (124 <bench_sha512_256+0x124>)
  2e:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 128 <bench_sha512_256+0x128>
            for (times = 0; times < numBlocks; times++) {
  32:	f04f 0800 	mov.w	r8, #0
  36:	6833      	ldr	r3, [r6, #0]
  38:	4543      	cmp	r3, r8
  3a:	dc48      	bgt.n	ce <bench_sha512_256+0xce>
            count += times;
  3c:	9b05      	ldr	r3, [sp, #20]
        } while (bench_stats_check(start));
  3e:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
            count += times;
  42:	4443      	add	r3, r8
  44:	9305      	str	r3, [sp, #20]
        } while (bench_stats_check(start));
  46:	f7ff fffe 	bl	0 <bench_sha512_256>
  4a:	4604      	mov	r4, r0
  4c:	2800      	cmp	r0, #0
  4e:	d1ee      	bne.n	2e <bench_sha512_256+0x2e>
exit_sha512_256:
  50:	e031      	b.n	b6 <bench_sha512_256+0xb6>
                printf("InitSha512_256_ex failed, ret = %d\n", ret);
  52:	4836      	ldr	r0, [pc, #216]	; (12c <bench_sha512_256+0x12c>)
  54:	f7ff fffe 	bl	0 <printf>
        wc_Sha512_256Free(&hash[i]);
  58:	a808      	add	r0, sp, #32
  5a:	f7ff fffe 	bl	0 <wc_Sha512_256Free>
    WC_FREE_ARRAY(digest, BENCH_MAX_PENDING, HEAP_HINT);
  5e:	b115      	cbz	r5, 66 <bench_sha512_256+0x66>
  60:	4628      	mov	r0, r5
  62:	f7ff fffe 	bl	0 <free>
}
  66:	b041      	add	sp, #260	; 0x104
  68:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            ret = wc_InitSha512_256_ex(&hash[i], HEAP_HINT,
  6c:	4621      	mov	r1, r4
  6e:	f06f 0201 	mvn.w	r2, #1
  72:	a808      	add	r0, sp, #32
  74:	f7ff fffe 	bl	0 <wc_InitSha512_256_ex>
            if (ret != 0) {
  78:	4601      	mov	r1, r0
  7a:	2800      	cmp	r0, #0
  7c:	d1e9      	bne.n	52 <bench_sha512_256+0x52>
        bench_stats_start(&count, &start);
  7e:	a906      	add	r1, sp, #24
  80:	a805      	add	r0, sp, #20
  82:	f7ff fffe 	bl	0 <bench_sha512_256>
            for (times = 0; times < numBlocks || pending > 0; ) {
  86:	4f26      	ldr	r7, [pc, #152]	; (120 <bench_sha512_256+0x120>)
                        ret = wc_Sha512_256Update(&hash[i], bench_plain,
  88:	f8df 8098 	ldr.w	r8, [pc, #152]	; 124 <bench_sha512_256+0x124>
  8c:	f8df 9098 	ldr.w	r9, [pc, #152]	; 128 <bench_sha512_256+0x128>
            for (times = 0; times < numBlocks || pending > 0; ) {
  90:	2600      	movs	r6, #0
  92:	683b      	ldr	r3, [r7, #0]
  94:	42b3      	cmp	r3, r6
  96:	dc36      	bgt.n	106 <bench_sha512_256+0x106>
            count += times;
  98:	9b05      	ldr	r3, [sp, #20]
                        ret = wc_Sha512_256Final(&hash[i], digest[i]);
  9a:	4629      	mov	r1, r5
            count += times;
  9c:	4433      	add	r3, r6
                        ret = wc_Sha512_256Final(&hash[i], digest[i]);
  9e:	a808      	add	r0, sp, #32
            count += times;
  a0:	9305      	str	r3, [sp, #20]
                        ret = wc_Sha512_256Final(&hash[i], digest[i]);
  a2:	f7ff fffe 	bl	0 <wc_Sha512_256Final>
        if (*ret >= 0) {
  a6:	1e04      	subs	r4, r0, #0
  a8:	db05      	blt.n	b6 <bench_sha512_256+0xb6>
        } while (bench_stats_check(start));
  aa:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  ae:	f7ff fffe 	bl	0 <bench_sha512_256>
  b2:	2800      	cmp	r0, #0
  b4:	d1ea      	bne.n	8c <bench_sha512_256+0x8c>
    bench_stats_sym_finish("SHA-512/256", useDeviceID, count, bench_size,
  b6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  ba:	e9cd 2300 	strd	r2, r3, [sp]
  be:	4b19      	ldr	r3, [pc, #100]	; (124 <bench_sha512_256+0x124>)
  c0:	9402      	str	r4, [sp, #8]
  c2:	681a      	ldr	r2, [r3, #0]
  c4:	9905      	ldr	r1, [sp, #20]
  c6:	481a      	ldr	r0, [pc, #104]	; (130 <bench_sha512_256+0x130>)
  c8:	f7ff fffe 	bl	0 <bench_sha512_256>
  cc:	e7c4      	b.n	58 <bench_sha512_256+0x58>
                ret = wc_InitSha512_256_ex(hash, HEAP_HINT,
  ce:	f06f 0201 	mvn.w	r2, #1
  d2:	2100      	movs	r1, #0
  d4:	a808      	add	r0, sp, #32
  d6:	f7ff fffe 	bl	0 <wc_InitSha512_256_ex>
                if (ret == 0)
  da:	4604      	mov	r4, r0
  dc:	2800      	cmp	r0, #0
  de:	d1ea      	bne.n	b6 <bench_sha512_256+0xb6>
                    ret = wc_Sha512_256Update(hash, bench_plain, bench_size);
  e0:	683a      	ldr	r2, [r7, #0]
  e2:	f8d9 1000 	ldr.w	r1, [r9]
  e6:	a808      	add	r0, sp, #32
  e8:	f7ff fffe 	bl	0 <wc_Sha512_256Update>
                if (ret == 0)
  ec:	4604      	mov	r4, r0
  ee:	2800      	cmp	r0, #0
  f0:	d1e1      	bne.n	b6 <bench_sha512_256+0xb6>
                    ret = wc_Sha512_256Final(hash, digest[0]);
  f2:	4629      	mov	r1, r5
  f4:	a808      	add	r0, sp, #32
  f6:	f7ff fffe 	bl	0 <wc_Sha512_256Final>
                if (ret != 0)
  fa:	4604      	mov	r4, r0
  fc:	2800      	cmp	r0, #0
  fe:	d1da      	bne.n	b6 <bench_sha512_256+0xb6>
            for (times = 0; times < numBlocks; times++) {
 100:	f108 0801 	add.w	r8, r8, #1
 104:	e797      	b.n	36 <bench_sha512_256+0x36>
                        ret = wc_Sha512_256Update(&hash[i], bench_plain,
 106:	f8d8 2000 	ldr.w	r2, [r8]
 10a:	f8d9 1000 	ldr.w	r1, [r9]
 10e:	a808      	add	r0, sp, #32
 110:	f7ff fffe 	bl	0 <wc_Sha512_256Update>
        if (*ret >= 0) {
 114:	1e04      	subs	r4, r0, #0
 116:	dbce      	blt.n	b6 <bench_sha512_256+0xb6>
            (*times)++;
 118:	3601      	adds	r6, #1
                for (i = 0; i < BENCH_MAX_PENDING; i++) {
 11a:	e7ba      	b.n	92 <bench_sha512_256+0x92>
	...
 130:	00000024 	.word	0x00000024

Disassembly of section .text.bench_hmac_sha:

00000000 <bench_hmac_sha>:
#endif /* NO_MD5 */

#ifndef NO_SHA

void bench_hmac_sha(int useDeviceID)
{
   0:	b507      	push	{r0, r1, r2, lr}
    WOLFSSL_SMALL_STACK_STATIC const byte key[] = {
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b };

    bench_hmac(useDeviceID, WC_SHA, WC_SHA_DIGEST_SIZE, key, sizeof(key),
   2:	4b05      	ldr	r3, [pc, #20]	; (18 <bench_hmac_sha+0x18>)
   4:	9300      	str	r3, [sp, #0]
   6:	4a05      	ldr	r2, [pc, #20]	; (1c <bench_hmac_sha+0x1c>)
   8:	2314      	movs	r3, #20
   a:	2104      	movs	r1, #4
   c:	f7ff fffe 	bl	0 <bench_hmac_sha>
               "HMAC-SHA");
}
  10:	b003      	add	sp, #12
  12:	f85d fb04 	ldr.w	pc, [sp], #4
  16:	bf00      	nop
	...

Disassembly of section .text.bench_hmac_sha256:

00000000 <bench_hmac_sha256>:
#endif /* WOLFSSL_SHA224 */

#ifndef NO_SHA256

void bench_hmac_sha256(int useDeviceID)
{
   0:	b507      	push	{r0, r1, r2, lr}
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b };

    bench_hmac(useDeviceID, WC_SHA256, WC_SHA256_DIGEST_SIZE, key, sizeof(key),
   2:	4b05      	ldr	r3, [pc, #20]	; (18 <bench_hmac_sha256+0x18>)
   4:	9300      	str	r3, [sp, #0]
   6:	4a05      	ldr	r2, [pc, #20]	; (1c <bench_hmac_sha256+0x1c>)
   8:	2320      	movs	r3, #32
   a:	2106      	movs	r1, #6
   c:	f7ff fffe 	bl	0 <bench_hmac_sha256>
               "HMAC-SHA256");
}
  10:	b003      	add	sp, #12
  12:	f85d fb04 	ldr.w	pc, [sp], #4
  16:	bf00      	nop
	...

Disassembly of section .text.bench_hmac_sha512:

00000000 <bench_hmac_sha512>:
#endif /* WOLFSSL_SHA384 */

#ifdef WOLFSSL_SHA512

void bench_hmac_sha512(int useDeviceID)
{
   0:	b507      	push	{r0, r1, r2, lr}
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                   0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b };

    bench_hmac(useDeviceID, WC_SHA512, WC_SHA512_DIGEST_SIZE, key, sizeof(key),
   2:	4b05      	ldr	r3, [pc, #20]	; (18 <bench_hmac_sha512+0x18>)
   4:	9300      	str	r3, [sp, #0]
   6:	4a05      	ldr	r2, [pc, #20]	; (1c <bench_hmac_sha512+0x1c>)
   8:	2340      	movs	r3, #64	; 0x40
   a:	2108      	movs	r1, #8
   c:	f7ff fffe 	bl	0 <bench_hmac_sha512>
               "HMAC-SHA512");
}
  10:	b003      	add	sp, #12
  12:	f85d fb04 	ldr.w	pc, [sp], #4
  16:	bf00      	nop
	...

Disassembly of section .text.bench_eccMakeKey:

00000000 <bench_eccMakeKey>:
    #endif
}


void bench_eccMakeKey(int useDeviceID, int curveId)
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    char name[BENCH_ECC_NAME_SZ];
    double start;
    const char**desc = bench_desc_words[lng_index];

#ifdef WOLFSSL_SMALL_STACK
    genKey = (ecc_key *)XMALLOC(sizeof(*genKey) * BENCH_MAX_PENDING,
   4:	f44f 70de 	mov.w	r0, #444	; 0x1bc
{
   8:	b08f      	sub	sp, #60	; 0x3c
   a:	460e      	mov	r6, r1
    genKey = (ecc_key *)XMALLOC(sizeof(*genKey) * BENCH_MAX_PENDING,
   c:	f7ff fffe 	bl	0 <malloc>
                                HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
    if (genKey == NULL) {
  10:	4604      	mov	r4, r0
  12:	b928      	cbnz	r0, 20 <bench_eccMakeKey+0x20>
        printf("bench_eccMakeKey malloc failed\n");
  14:	482c      	ldr	r0, [pc, #176]	; (c8 <bench_eccMakeKey+0xc8>)
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(genKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
#endif
}
  16:	b00f      	add	sp, #60	; 0x3c
  18:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        printf("bench_eccMakeKey malloc failed\n");
  1c:	f7ff bffe 	b.w	0 <printf>
    keySize = wc_ecc_get_curve_size_from_id(curveId);
  20:	4630      	mov	r0, r6
  22:	f7ff fffe 	bl	0 <wc_ecc_get_curve_size_from_id>
    XMEMSET(genKey, 0, sizeof(*genKey) * BENCH_MAX_PENDING);
  26:	f44f 72de 	mov.w	r2, #444	; 0x1bc
  2a:	2100      	movs	r1, #0
    keySize = wc_ecc_get_curve_size_from_id(curveId);
  2c:	4607      	mov	r7, r0
    XMEMSET(genKey, 0, sizeof(*genKey) * BENCH_MAX_PENDING);
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <memset>
    bench_stats_start(&count, &start);
  34:	a906      	add	r1, sp, #24
  36:	a805      	add	r0, sp, #20
  38:	f7ff fffe 	bl	0 <bench_eccMakeKey>
                    ret = wc_ecc_make_key_ex(&gRng, keySize, &genKey[i],
  3c:	f8df 808c 	ldr.w	r8, [pc, #140]	; cc <bench_eccMakeKey+0xcc>
        for (times = 0; times < agreeTimes || pending > 0; ) {
  40:	f04f 0900 	mov.w	r9, #0
                    wc_ecc_free(&genKey[i]);
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <wc_ecc_free>
                    ret = wc_ecc_init_ex(&genKey[i], HEAP_HINT, deviceID);
  4a:	f06f 0201 	mvn.w	r2, #1
  4e:	2100      	movs	r1, #0
  50:	4620      	mov	r0, r4
  52:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
                    if (ret < 0) {
  56:	1e05      	subs	r5, r0, #0
  58:	da1d      	bge.n	96 <bench_eccMakeKey+0x96>
    (void)XSNPRINTF(name, BENCH_ECC_NAME_SZ, "ECC   [%15s]",
  5a:	4630      	mov	r0, r6
  5c:	f7ff fffe 	bl	0 <wc_ecc_get_name>
  60:	4a1b      	ldr	r2, [pc, #108]	; (d0 <bench_eccMakeKey+0xd0>)
  62:	4603      	mov	r3, r0
  64:	2118      	movs	r1, #24
  66:	a808      	add	r0, sp, #32
  68:	f7ff fffe 	bl	0 <snprintf>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
  6c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  70:	e9cd 2300 	strd	r2, r3, [sp]
  74:	4a17      	ldr	r2, [pc, #92]	; (d4 <bench_eccMakeKey+0xd4>)
  76:	9502      	str	r5, [sp, #8]
  78:	9b05      	ldr	r3, [sp, #20]
  7a:	6892      	ldr	r2, [r2, #8]
  7c:	00f9      	lsls	r1, r7, #3
  7e:	a808      	add	r0, sp, #32
  80:	f7ff fffe 	bl	0 <bench_eccMakeKey>
        wc_ecc_free(&genKey[i]);
  84:	4620      	mov	r0, r4
  86:	f7ff fffe 	bl	0 <wc_ecc_free>
    XFREE(genKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
  8a:	4620      	mov	r0, r4
  8c:	f7ff fffe 	bl	0 <free>
}
  90:	b00f      	add	sp, #60	; 0x3c
  92:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                    ret = wc_ecc_make_key_ex(&gRng, keySize, &genKey[i],
  96:	4633      	mov	r3, r6
  98:	4622      	mov	r2, r4
  9a:	4639      	mov	r1, r7
  9c:	4640      	mov	r0, r8
  9e:	f7ff fffe 	bl	0 <wc_ecc_make_key_ex>
        if (*ret >= 0) {
  a2:	1e05      	subs	r5, r0, #0
  a4:	dbd9      	blt.n	5a <bench_eccMakeKey+0x5a>
        for (times = 0; times < agreeTimes || pending > 0; ) {
  a6:	f1b9 0f00 	cmp.w	r9, #0
  aa:	d102      	bne.n	b2 <bench_eccMakeKey+0xb2>
  ac:	f04f 0901 	mov.w	r9, #1
  b0:	e7c8      	b.n	44 <bench_eccMakeKey+0x44>
        count += times;
  b2:	9a05      	ldr	r2, [sp, #20]
    } while (bench_stats_check(start));
  b4:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count += times;
  b8:	3202      	adds	r2, #2
  ba:	9205      	str	r2, [sp, #20]
    } while (bench_stats_check(start));
  bc:	f7ff fffe 	bl	0 <bench_eccMakeKey>
  c0:	2800      	cmp	r0, #0
  c2:	d1bd      	bne.n	40 <bench_eccMakeKey+0x40>
exit:
  c4:	e7c9      	b.n	5a <bench_eccMakeKey+0x5a>
  c6:	bf00      	nop
	...
  d0:	00000020 	.word	0x00000020
  d4:	00000000 	.word	0x00000000

Disassembly of section .text.bench_ecc:

00000000 <bench_ecc>:


void bench_ecc(int useDeviceID, int curveId)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        int    verify[BENCH_MAX_PENDING];
    #endif
#endif

    word32 x[BENCH_MAX_PENDING];
    double start = 0;
   4:	2200      	movs	r2, #0
{
   6:	b093      	sub	sp, #76	; 0x4c
    double start = 0;
   8:	2300      	movs	r3, #0
    WC_DECLARE_ARRAY(digest, byte,
                     BENCH_MAX_PENDING, MAX_ECC_BYTES, HEAP_HINT);
#endif

#ifdef WOLFSSL_SMALL_STACK
    genKey = (ecc_key *)XMALLOC(sizeof(*genKey) * BENCH_MAX_PENDING,
   a:	f44f 70de 	mov.w	r0, #444	; 0x1bc
    double start = 0;
   e:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
{
  12:	4689      	mov	r9, r1
    genKey = (ecc_key *)XMALLOC(sizeof(*genKey) * BENCH_MAX_PENDING,
  14:	f7ff fffe 	bl	0 <malloc>
                                HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
    if (genKey == NULL) {
  18:	4604      	mov	r4, r0
  1a:	b928      	cbnz	r0, 28 <bench_ecc+0x28>
#ifdef HAVE_ECC_DHE
    genKey2 = (ecc_key *)XMALLOC(sizeof(*genKey2) * BENCH_MAX_PENDING,
                                 HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
    if (genKey2 == NULL) {
        XFREE(genKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
        printf("bench_eccMakeKey malloc failed\n");
  1c:	4899      	ldr	r0, [pc, #612]	; (284 <bench_ecc+0x284>)
  1e:	f7ff fffe 	bl	0 <printf>
    (void)count;
    (void)times;
    (void)desc;
    (void)start;
    (void)name;
}
  22:	b013      	add	sp, #76	; 0x4c
  24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    genKey2 = (ecc_key *)XMALLOC(sizeof(*genKey2) * BENCH_MAX_PENDING,
  28:	f44f 70de 	mov.w	r0, #444	; 0x1bc
  2c:	f7ff fffe 	bl	0 <malloc>
    if (genKey2 == NULL) {
  30:	4606      	mov	r6, r0
  32:	b918      	cbnz	r0, 3c <bench_ecc+0x3c>
        XFREE(genKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
  34:	4620      	mov	r0, r4
  36:	f7ff fffe 	bl	0 <free>
  3a:	e7ef      	b.n	1c <bench_ecc+0x1c>
    WC_INIT_ARRAY(shared, byte,
  3c:	2020      	movs	r0, #32
  3e:	f7ff fffe 	bl	0 <malloc>
  42:	9004      	str	r0, [sp, #16]
    WC_INIT_ARRAY(sig, byte, BENCH_MAX_PENDING, ECC_MAX_SIG_SIZE, HEAP_HINT);
  44:	2049      	movs	r0, #73	; 0x49
  46:	f7ff fffe 	bl	0 <malloc>
  4a:	4682      	mov	sl, r0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING, MAX_ECC_BYTES, HEAP_HINT);
  4c:	2020      	movs	r0, #32
  4e:	f7ff fffe 	bl	0 <malloc>
    XMEMSET(genKey, 0, sizeof(*genKey) * BENCH_MAX_PENDING);
  52:	f44f 72de 	mov.w	r2, #444	; 0x1bc
  56:	2100      	movs	r1, #0
    WC_INIT_ARRAY(digest, byte, BENCH_MAX_PENDING, MAX_ECC_BYTES, HEAP_HINT);
  58:	4680      	mov	r8, r0
    XMEMSET(genKey, 0, sizeof(*genKey) * BENCH_MAX_PENDING);
  5a:	4620      	mov	r0, r4
  5c:	f7ff fffe 	bl	0 <memset>
    XMEMSET(genKey2, 0, sizeof(*genKey2) * BENCH_MAX_PENDING);
  60:	f44f 72de 	mov.w	r2, #444	; 0x1bc
  64:	2100      	movs	r1, #0
  66:	4630      	mov	r0, r6
  68:	f7ff fffe 	bl	0 <memset>
    keySize = wc_ecc_get_curve_size_from_id(curveId);
  6c:	4648      	mov	r0, r9
  6e:	f7ff fffe 	bl	0 <wc_ecc_get_curve_size_from_id>
        if ((ret = wc_ecc_init_ex(&genKey[i], HEAP_HINT, deviceID)) < 0) {
  72:	f06f 0201 	mvn.w	r2, #1
    keySize = wc_ecc_get_curve_size_from_id(curveId);
  76:	4605      	mov	r5, r0
        if ((ret = wc_ecc_init_ex(&genKey[i], HEAP_HINT, deviceID)) < 0) {
  78:	2100      	movs	r1, #0
  7a:	4620      	mov	r0, r4
  7c:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
  80:	2800      	cmp	r0, #0
  82:	db4d      	blt.n	120 <bench_ecc+0x120>
        ret = wc_ecc_make_key_ex(&gRng, keySize, &genKey[i], curveId);
  84:	4880      	ldr	r0, [pc, #512]	; (288 <bench_ecc+0x288>)
  86:	f8df b200 	ldr.w	fp, [pc, #512]	; 288 <bench_ecc+0x288>
  8a:	464b      	mov	r3, r9
  8c:	4622      	mov	r2, r4
  8e:	4629      	mov	r1, r5
  90:	f7ff fffe 	bl	0 <wc_ecc_make_key_ex>
        if (ret < 0) {
  94:	2800      	cmp	r0, #0
  96:	db43      	blt.n	120 <bench_ecc+0x120>
        if ((ret = wc_ecc_init_ex(&genKey2[i], HEAP_HINT, deviceID)) < 0) {
  98:	f06f 0201 	mvn.w	r2, #1
  9c:	2100      	movs	r1, #0
  9e:	4630      	mov	r0, r6
  a0:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
  a4:	2800      	cmp	r0, #0
  a6:	db3b      	blt.n	120 <bench_ecc+0x120>
        if ((ret = wc_ecc_make_key_ex(&gRng, keySize, &genKey2[i],
  a8:	464b      	mov	r3, r9
  aa:	4632      	mov	r2, r6
  ac:	4629      	mov	r1, r5
  ae:	4658      	mov	r0, fp
  b0:	f7ff fffe 	bl	0 <wc_ecc_make_key_ex>
  b4:	2800      	cmp	r0, #0
  b6:	dc33      	bgt.n	120 <bench_ecc+0x120>
        (void)wc_ecc_set_rng(&genKey[i], &gRng);
  b8:	4659      	mov	r1, fp
  ba:	4620      	mov	r0, r4
  bc:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
    bench_stats_start(&count, &start);
  c0:	a90a      	add	r1, sp, #40	; 0x28
  c2:	a807      	add	r0, sp, #28
  c4:	f7ff fffe 	bl	0 <bench_ecc>
                    ret = wc_ecc_shared_secret(&genKey[i], &genKey2[i],
  c8:	9a04      	ldr	r2, [sp, #16]
                    x[i] = (word32)keySize;
  ca:	9509      	str	r5, [sp, #36]	; 0x24
                    ret = wc_ecc_shared_secret(&genKey[i], &genKey2[i],
  cc:	ab09      	add	r3, sp, #36	; 0x24
  ce:	4631      	mov	r1, r6
  d0:	4620      	mov	r0, r4
  d2:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
        if (*ret >= 0) {
  d6:	1e07      	subs	r7, r0, #0
  d8:	db08      	blt.n	ec <bench_ecc+0xec>
                    ret = wc_ecc_shared_secret(&genKey[i], &genKey2[i],
  da:	9a04      	ldr	r2, [sp, #16]
                    x[i] = (word32)keySize;
  dc:	9509      	str	r5, [sp, #36]	; 0x24
                    ret = wc_ecc_shared_secret(&genKey[i], &genKey2[i],
  de:	ab09      	add	r3, sp, #36	; 0x24
  e0:	4631      	mov	r1, r6
  e2:	4620      	mov	r0, r4
  e4:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
        if (*ret >= 0) {
  e8:	1e07      	subs	r7, r0, #0
  ea:	da38      	bge.n	15e <bench_ecc+0x15e>
    (void)XSNPRINTF(name, BENCH_ECC_NAME_SZ, "ECDHE [%15s]",
  ec:	4648      	mov	r0, r9
  ee:	f7ff fffe 	bl	0 <wc_ecc_get_name>
  f2:	4a66      	ldr	r2, [pc, #408]	; (28c <bench_ecc+0x28c>)
  f4:	4603      	mov	r3, r0
  f6:	2118      	movs	r1, #24
  f8:	a80c      	add	r0, sp, #48	; 0x30
  fa:	f7ff fffe 	bl	0 <snprintf>
    bench_stats_asym_finish(name, keySize * 8, desc[3],
  fe:	00eb      	lsls	r3, r5, #3
 100:	9305      	str	r3, [sp, #20]
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
 102:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 106:	e9cd 2300 	strd	r2, r3, [sp]
 10a:	4a61      	ldr	r2, [pc, #388]	; (290 <bench_ecc+0x290>)
 10c:	9702      	str	r7, [sp, #8]
 10e:	9b07      	ldr	r3, [sp, #28]
 110:	68d2      	ldr	r2, [r2, #12]
 112:	00e9      	lsls	r1, r5, #3
 114:	a80c      	add	r0, sp, #48	; 0x30
 116:	f7ff fffe 	bl	0 <bench_ecc>
    if (ret < 0) {
 11a:	2f00      	cmp	r7, #0
 11c:	f280 8094 	bge.w	248 <bench_ecc+0x248>
        wc_ecc_free(&genKey[i]);
 120:	4620      	mov	r0, r4
 122:	f7ff fffe 	bl	0 <wc_ecc_free>
        wc_ecc_free(&genKey2[i]);
 126:	4630      	mov	r0, r6
 128:	f7ff fffe 	bl	0 <wc_ecc_free>
    XFREE(genKey, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 12c:	4620      	mov	r0, r4
 12e:	f7ff fffe 	bl	0 <free>
    XFREE(genKey2, HEAP_HINT, DYNAMIC_TYPE_TMP_BUFFER);
 132:	4630      	mov	r0, r6
 134:	f7ff fffe 	bl	0 <free>
    WC_FREE_ARRAY(shared, BENCH_MAX_PENDING, HEAP_HINT);
 138:	9b04      	ldr	r3, [sp, #16]
 13a:	b113      	cbz	r3, 142 <bench_ecc+0x142>
 13c:	9804      	ldr	r0, [sp, #16]
 13e:	f7ff fffe 	bl	0 <free>
    WC_FREE_ARRAY(sig, BENCH_MAX_PENDING, HEAP_HINT);
 142:	f1ba 0f00 	cmp.w	sl, #0
 146:	d002      	beq.n	14e <bench_ecc+0x14e>
 148:	4650      	mov	r0, sl
 14a:	f7ff fffe 	bl	0 <free>
    WC_FREE_ARRAY(digest, BENCH_MAX_PENDING, HEAP_HINT);
 14e:	f1b8 0f00 	cmp.w	r8, #0
 152:	f43f af66 	beq.w	22 <bench_ecc+0x22>
 156:	4640      	mov	r0, r8
 158:	f7ff fffe 	bl	0 <free>
    (void)name;
 15c:	e761      	b.n	22 <bench_ecc+0x22>
        count += times;
 15e:	9b07      	ldr	r3, [sp, #28]
    } while (bench_stats_check(start));
 160:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
        count += times;
 164:	3302      	adds	r3, #2
 166:	9307      	str	r3, [sp, #28]
    } while (bench_stats_check(start));
 168:	f7ff fffe 	bl	0 <bench_ecc>
 16c:	2800      	cmp	r0, #0
 16e:	d1ab      	bne.n	c8 <bench_ecc+0xc8>
 170:	e7bc      	b.n	ec <bench_ecc+0xec>
            digest[i][count] = (byte)count;
 172:	f808 3003 	strb.w	r3, [r8, r3]
 176:	2201      	movs	r2, #1
 178:	3301      	adds	r3, #1
        for (count = 0; count < keySize; count++) {
 17a:	42ab      	cmp	r3, r5
 17c:	dbf9      	blt.n	172 <bench_ecc+0x172>
 17e:	ea25 73e5 	bic.w	r3, r5, r5, asr #31
 182:	b102      	cbz	r2, 186 <bench_ecc+0x186>
 184:	9307      	str	r3, [sp, #28]
    bench_stats_start(&count, &start);
 186:	a90a      	add	r1, sp, #40	; 0x28
 188:	a807      	add	r0, sp, #28
 18a:	f7ff fffe 	bl	0 <bench_ecc>
                    if (genKey[i].state == 0) {
 18e:	68a3      	ldr	r3, [r4, #8]
 190:	b90b      	cbnz	r3, 196 <bench_ecc+0x196>
                        x[i] = ECC_MAX_SIG_SIZE;
 192:	2349      	movs	r3, #73	; 0x49
 194:	9309      	str	r3, [sp, #36]	; 0x24
                    ret = wc_ecc_sign_hash(digest[i], (word32)keySize, sig[i],
 196:	e9cd b400 	strd	fp, r4, [sp]
 19a:	ab09      	add	r3, sp, #36	; 0x24
 19c:	4652      	mov	r2, sl
 19e:	4629      	mov	r1, r5
 1a0:	4640      	mov	r0, r8
 1a2:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
        if (*ret >= 0) {
 1a6:	1e07      	subs	r7, r0, #0
 1a8:	db0d      	blt.n	1c6 <bench_ecc+0x1c6>
                    if (genKey[i].state == 0) {
 1aa:	68a3      	ldr	r3, [r4, #8]
 1ac:	b90b      	cbnz	r3, 1b2 <bench_ecc+0x1b2>
                        x[i] = ECC_MAX_SIG_SIZE;
 1ae:	2349      	movs	r3, #73	; 0x49
 1b0:	9309      	str	r3, [sp, #36]	; 0x24
                    ret = wc_ecc_sign_hash(digest[i], (word32)keySize, sig[i],
 1b2:	e9cd b400 	strd	fp, r4, [sp]
 1b6:	ab09      	add	r3, sp, #36	; 0x24
 1b8:	4652      	mov	r2, sl
 1ba:	4629      	mov	r1, r5
 1bc:	4640      	mov	r0, r8
 1be:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
        if (*ret >= 0) {
 1c2:	1e07      	subs	r7, r0, #0
 1c4:	da44      	bge.n	250 <bench_ecc+0x250>
    (void)XSNPRINTF(name, BENCH_ECC_NAME_SZ, "ECDSA [%15s]",
 1c6:	4648      	mov	r0, r9
 1c8:	f7ff fffe 	bl	0 <wc_ecc_get_name>
 1cc:	4a31      	ldr	r2, [pc, #196]	; (294 <bench_ecc+0x294>)
 1ce:	4603      	mov	r3, r0
 1d0:	2118      	movs	r1, #24
 1d2:	a80c      	add	r0, sp, #48	; 0x30
 1d4:	f7ff fffe 	bl	0 <snprintf>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
 1d8:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 1dc:	e9cd 2300 	strd	r2, r3, [sp]
 1e0:	4a2b      	ldr	r2, [pc, #172]	; (290 <bench_ecc+0x290>)
 1e2:	9702      	str	r7, [sp, #8]
 1e4:	9b07      	ldr	r3, [sp, #28]
 1e6:	6912      	ldr	r2, [r2, #16]
 1e8:	9905      	ldr	r1, [sp, #20]
 1ea:	a80c      	add	r0, sp, #48	; 0x30
 1ec:	f7ff fffe 	bl	0 <bench_ecc>
    if (ret < 0) {
 1f0:	2f00      	cmp	r7, #0
 1f2:	db95      	blt.n	120 <bench_ecc+0x120>
    bench_stats_start(&count, &start);
 1f4:	a90a      	add	r1, sp, #40	; 0x28
 1f6:	a807      	add	r0, sp, #28
 1f8:	f7ff fffe 	bl	0 <bench_ecc>
        for (times = 0; times < agreeTimes || pending > 0; ) {
 1fc:	f04f 0b00 	mov.w	fp, #0
                    if (genKey[i].state == 0) {
 200:	68a3      	ldr	r3, [r4, #8]
 202:	b903      	cbnz	r3, 206 <bench_ecc+0x206>
                        verify[i] = 0;
 204:	9308      	str	r3, [sp, #32]
                    ret = wc_ecc_verify_hash(sig[i], x[i], digest[i],
 206:	ab08      	add	r3, sp, #32
 208:	9300      	str	r3, [sp, #0]
 20a:	9909      	ldr	r1, [sp, #36]	; 0x24
 20c:	9401      	str	r4, [sp, #4]
 20e:	462b      	mov	r3, r5
 210:	4642      	mov	r2, r8
 212:	4650      	mov	r0, sl
 214:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
        if (*ret >= 0) {
 218:	1e07      	subs	r7, r0, #0
 21a:	da23      	bge.n	264 <bench_ecc+0x264>
    (void)XSNPRINTF(name, BENCH_ECC_NAME_SZ, "ECDSA [%15s]",
 21c:	4648      	mov	r0, r9
 21e:	f7ff fffe 	bl	0 <wc_ecc_get_name>
 222:	4a1c      	ldr	r2, [pc, #112]	; (294 <bench_ecc+0x294>)
 224:	4603      	mov	r3, r0
 226:	2118      	movs	r1, #24
 228:	a80c      	add	r0, sp, #48	; 0x30
 22a:	f7ff fffe 	bl	0 <snprintf>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
 22e:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 232:	e9cd 2300 	strd	r2, r3, [sp]
 236:	4a16      	ldr	r2, [pc, #88]	; (290 <bench_ecc+0x290>)
 238:	9702      	str	r7, [sp, #8]
 23a:	9b07      	ldr	r3, [sp, #28]
 23c:	6952      	ldr	r2, [r2, #20]
 23e:	9905      	ldr	r1, [sp, #20]
 240:	a80c      	add	r0, sp, #48	; 0x30
 242:	f7ff fffe 	bl	0 <bench_ecc>
}
 246:	e76b      	b.n	120 <bench_ecc+0x120>
        for (count = 0; count < keySize; count++) {
 248:	2300      	movs	r3, #0
 24a:	9307      	str	r3, [sp, #28]
 24c:	461a      	mov	r2, r3
 24e:	e794      	b.n	17a <bench_ecc+0x17a>
        count += times;
 250:	9b07      	ldr	r3, [sp, #28]
    } while (bench_stats_check(start));
 252:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
        count += times;
 256:	3302      	adds	r3, #2
 258:	9307      	str	r3, [sp, #28]
    } while (bench_stats_check(start));
 25a:	f7ff fffe 	bl	0 <bench_ecc>
 25e:	2800      	cmp	r0, #0
 260:	d195      	bne.n	18e <bench_ecc+0x18e>
 262:	e7b0      	b.n	1c6 <bench_ecc+0x1c6>
        for (times = 0; times < agreeTimes || pending > 0; ) {
 264:	f1bb 0f00 	cmp.w	fp, #0
 268:	d102      	bne.n	270 <bench_ecc+0x270>
 26a:	f04f 0b01 	mov.w	fp, #1
 26e:	e7c7      	b.n	200 <bench_ecc+0x200>
        count += times;
 270:	9b07      	ldr	r3, [sp, #28]
    } while (bench_stats_check(start));
 272:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
        count += times;
 276:	3302      	adds	r3, #2
 278:	9307      	str	r3, [sp, #28]
    } while (bench_stats_check(start));
 27a:	f7ff fffe 	bl	0 <bench_ecc>
 27e:	2800      	cmp	r0, #0
 280:	d1bc      	bne.n	1fc <bench_ecc+0x1fc>
 282:	e7cb      	b.n	21c <bench_ecc+0x21c>
	...
 294:	0000000d 	.word	0x0000000d

Disassembly of section .text.bench_ecc_curve:

00000000 <bench_ecc_curve>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if (bench_all || (bench_asym_algs & BENCH_ECC_MAKEKEY)) {
   2:	4e0d      	ldr	r6, [pc, #52]	; (38 <bench_ecc_curve+0x38>)
   4:	4d0d      	ldr	r5, [pc, #52]	; (3c <bench_ecc_curve+0x3c>)
   6:	6833      	ldr	r3, [r6, #0]
   8:	682a      	ldr	r2, [r5, #0]
   a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
   e:	4313      	orrs	r3, r2
{
  10:	4604      	mov	r4, r0
    if (bench_all || (bench_asym_algs & BENCH_ECC_MAKEKEY)) {
  12:	d103      	bne.n	1c <bench_ecc_curve+0x1c>
    if (bench_all || (bench_asym_algs & BENCH_ECC)) {
  14:	6833      	ldr	r3, [r6, #0]
  16:	049b      	lsls	r3, r3, #18
  18:	d407      	bmi.n	2a <bench_ecc_curve+0x2a>
}
  1a:	bd70      	pop	{r4, r5, r6, pc}
        bench_eccMakeKey(0, curveId);
  1c:	4601      	mov	r1, r0
  1e:	2000      	movs	r0, #0
  20:	f7ff fffe 	bl	0 <bench_ecc_curve>
    if (bench_all || (bench_asym_algs & BENCH_ECC)) {
  24:	682b      	ldr	r3, [r5, #0]
  26:	2b00      	cmp	r3, #0
  28:	d0f4      	beq.n	14 <bench_ecc_curve+0x14>
        bench_ecc(0, curveId);
  2a:	4621      	mov	r1, r4
  2c:	2000      	movs	r0, #0
}
  2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        bench_ecc(0, curveId);
  32:	f7ff bffe 	b.w	0 <bench_ecc_curve>
  36:	bf00      	nop
	...

Disassembly of section .text.bench_curve25519KeyGen:

00000000 <bench_curve25519KeyGen>:
#endif /* WOLFSSL_SM2 */
#endif /* HAVE_ECC */

#ifdef HAVE_CURVE25519
void bench_curve25519KeyGen(int useDeviceID)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b09c      	sub	sp, #112	; 0x70
    double start;
    int    ret = 0, i, count;
    const char**desc = bench_desc_words[lng_index];

    /* Key Gen */
    bench_stats_start(&count, &start);
   6:	a906      	add	r1, sp, #24
   8:	a805      	add	r0, sp, #20
   a:	f7ff fffe 	bl	0 <bench_curve25519KeyGen>
            if (ret != 0) {
                printf("wc_curve25519_init_ex failed: %d\n", ret);
                break;
            }

            ret = wc_curve25519_make_key(&gRng, 32, &genKey);
   e:	4e1e      	ldr	r6, [pc, #120]	; (88 <bench_curve25519KeyGen+0x88>)
            wc_curve25519_free(&genKey);
            if (ret != 0) {
                printf("wc_curve25519_make_key failed: %d\n", ret);
  10:	4f1e      	ldr	r7, [pc, #120]	; (8c <bench_curve25519KeyGen+0x8c>)
                printf("wc_curve25519_init_ex failed: %d\n", ret);
  12:	f8df 807c 	ldr.w	r8, [pc, #124]	; 90 <bench_curve25519KeyGen+0x90>
            ret = wc_curve25519_init_ex(&genKey, HEAP_HINT,
  16:	f06f 0201 	mvn.w	r2, #1
  1a:	2100      	movs	r1, #0
  1c:	a809      	add	r0, sp, #36	; 0x24
  1e:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
            if (ret != 0) {
  22:	4604      	mov	r4, r0
  24:	b1f0      	cbz	r0, 64 <bench_curve25519KeyGen+0x64>
                printf("wc_curve25519_init_ex failed: %d\n", ret);
  26:	4601      	mov	r1, r0
  28:	4640      	mov	r0, r8
  2a:	f7ff fffe 	bl	0 <printf>
                break;
  2e:	4625      	mov	r5, r4
  30:	2400      	movs	r4, #0
                break;
            }
        }
        count += i;
  32:	9805      	ldr	r0, [sp, #20]
  34:	4420      	add	r0, r4
  36:	9005      	str	r0, [sp, #20]
    } while (bench_stats_check(start));
  38:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
  3c:	f7ff fffe 	bl	0 <bench_curve25519KeyGen>
  40:	2800      	cmp	r0, #0
  42:	d1e8      	bne.n	16 <bench_curve25519KeyGen+0x16>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
  44:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  48:	e9cd 2300 	strd	r2, r3, [sp]
  4c:	4a11      	ldr	r2, [pc, #68]	; (94 <bench_curve25519KeyGen+0x94>)
  4e:	9502      	str	r5, [sp, #8]
  50:	9b05      	ldr	r3, [sp, #20]
  52:	6892      	ldr	r2, [r2, #8]
  54:	4810      	ldr	r0, [pc, #64]	; (98 <bench_curve25519KeyGen+0x98>)
  56:	f246 31af 	movw	r1, #25519	; 0x63af
  5a:	f7ff fffe 	bl	0 <bench_curve25519KeyGen>
    bench_stats_asym_finish("CURVE", 25519, desc[2], useDeviceID, count, start,
        ret);
}
  5e:	b01c      	add	sp, #112	; 0x70
  60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ret = wc_curve25519_make_key(&gRng, 32, &genKey);
  64:	aa09      	add	r2, sp, #36	; 0x24
  66:	2120      	movs	r1, #32
  68:	4630      	mov	r0, r6
  6a:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
  6e:	4605      	mov	r5, r0
            wc_curve25519_free(&genKey);
  70:	a809      	add	r0, sp, #36	; 0x24
  72:	f7ff fffe 	bl	0 <wc_curve25519_free>
            if (ret != 0) {
  76:	b125      	cbz	r5, 82 <bench_curve25519KeyGen+0x82>
                printf("wc_curve25519_make_key failed: %d\n", ret);
  78:	4629      	mov	r1, r5
  7a:	4638      	mov	r0, r7
  7c:	f7ff fffe 	bl	0 <printf>
                break;
  80:	e7d7      	b.n	32 <bench_curve25519KeyGen+0x32>
        for (i = 0; i < genTimes; i++) {
  82:	2401      	movs	r4, #1
  84:	e7d5      	b.n	32 <bench_curve25519KeyGen+0x32>
  86:	bf00      	nop
  88:	00000000 	.word	0x00000000
  8c:	00000022 	.word	0x00000022
	...
  98:	00000045 	.word	0x00000045

Disassembly of section .text.bench_curve25519KeyAgree:

00000000 <bench_curve25519KeyAgree>:

#ifdef HAVE_CURVE25519_SHARED_SECRET
void bench_curve25519KeyAgree(int useDeviceID)
{
   0:	b530      	push	{r4, r5, lr}
    curve25519_key genKey, genKey2;
    double start;
    int    ret, i, count;
    byte   shared[32];
    const char**desc = bench_desc_words[lng_index];
    word32 x = 0;
   2:	2400      	movs	r4, #0
{
   4:	b0b7      	sub	sp, #220	; 0xdc

    wc_curve25519_init_ex(&genKey,  HEAP_HINT,
   6:	f06f 0201 	mvn.w	r2, #1
   a:	4621      	mov	r1, r4
   c:	a810      	add	r0, sp, #64	; 0x40
    word32 x = 0;
   e:	9405      	str	r4, [sp, #20]
    wc_curve25519_init_ex(&genKey,  HEAP_HINT,
  10:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
        useDeviceID ? devId : INVALID_DEVID);
    wc_curve25519_init_ex(&genKey2, HEAP_HINT,
  14:	f06f 0201 	mvn.w	r2, #1
  18:	4621      	mov	r1, r4
  1a:	a823      	add	r0, sp, #140	; 0x8c
  1c:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
        useDeviceID ? devId : INVALID_DEVID);

    ret = wc_curve25519_make_key(&gRng, 32, &genKey);
  20:	4827      	ldr	r0, [pc, #156]	; (c0 <bench_curve25519KeyAgree+0xc0>)
  22:	aa10      	add	r2, sp, #64	; 0x40
  24:	2120      	movs	r1, #32
  26:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret != 0) {
  2a:	b120      	cbz	r0, 36 <bench_curve25519KeyAgree+0x36>
        printf("curve25519_make_key failed\n");
  2c:	4825      	ldr	r0, [pc, #148]	; (c4 <bench_curve25519KeyAgree+0xc4>)
  2e:	f7ff fffe 	bl	0 <printf>
    bench_stats_asym_finish("CURVE", 25519, desc[3], useDeviceID, count, start,
        ret);

    wc_curve25519_free(&genKey2);
    wc_curve25519_free(&genKey);
}
  32:	b037      	add	sp, #220	; 0xdc
  34:	bd30      	pop	{r4, r5, pc}
    ret = wc_curve25519_make_key(&gRng, 32, &genKey2);
  36:	2120      	movs	r1, #32
  38:	4821      	ldr	r0, [pc, #132]	; (c0 <bench_curve25519KeyAgree+0xc0>)
  3a:	aa23      	add	r2, sp, #140	; 0x8c
  3c:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret != 0) {
  40:	4601      	mov	r1, r0
  42:	b130      	cbz	r0, 52 <bench_curve25519KeyAgree+0x52>
        printf("curve25519_make_key failed: %d\n", ret);
  44:	4820      	ldr	r0, [pc, #128]	; (c8 <bench_curve25519KeyAgree+0xc8>)
  46:	f7ff fffe 	bl	0 <printf>
    wc_curve25519_free(&genKey);
  4a:	a810      	add	r0, sp, #64	; 0x40
  4c:	f7ff fffe 	bl	0 <wc_curve25519_free>
  50:	e7ef      	b.n	32 <bench_curve25519KeyAgree+0x32>
    bench_stats_start(&count, &start);
  52:	a906      	add	r1, sp, #24
  54:	a804      	add	r0, sp, #16
  56:	f7ff fffe 	bl	0 <bench_curve25519KeyAgree>
            x = sizeof(shared);
  5a:	2520      	movs	r5, #32
            ret = wc_curve25519_shared_secret(&genKey, &genKey2, shared, &x);
  5c:	ab05      	add	r3, sp, #20
  5e:	aa08      	add	r2, sp, #32
  60:	a923      	add	r1, sp, #140	; 0x8c
  62:	a810      	add	r0, sp, #64	; 0x40
            x = sizeof(shared);
  64:	9505      	str	r5, [sp, #20]
            ret = wc_curve25519_shared_secret(&genKey, &genKey2, shared, &x);
  66:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
            if (ret != 0) {
  6a:	4604      	mov	r4, r0
  6c:	b940      	cbnz	r0, 80 <bench_curve25519KeyAgree+0x80>
            ret = wc_curve25519_shared_secret(&genKey, &genKey2, shared, &x);
  6e:	ab05      	add	r3, sp, #20
  70:	aa08      	add	r2, sp, #32
  72:	a923      	add	r1, sp, #140	; 0x8c
  74:	a810      	add	r0, sp, #64	; 0x40
            x = sizeof(shared);
  76:	9505      	str	r5, [sp, #20]
            ret = wc_curve25519_shared_secret(&genKey, &genKey2, shared, &x);
  78:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
            if (ret != 0) {
  7c:	4604      	mov	r4, r0
  7e:	b1a0      	cbz	r0, aa <bench_curve25519KeyAgree+0xaa>
                printf("curve25519_shared_secret failed: %d\n", ret);
  80:	4812      	ldr	r0, [pc, #72]	; (cc <bench_curve25519KeyAgree+0xcc>)
  82:	4621      	mov	r1, r4
  84:	f7ff fffe 	bl	0 <printf>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
  88:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  8c:	e9cd 2300 	strd	r2, r3, [sp]
  90:	4a0f      	ldr	r2, [pc, #60]	; (d0 <bench_curve25519KeyAgree+0xd0>)
  92:	9402      	str	r4, [sp, #8]
  94:	9b04      	ldr	r3, [sp, #16]
  96:	68d2      	ldr	r2, [r2, #12]
  98:	480e      	ldr	r0, [pc, #56]	; (d4 <bench_curve25519KeyAgree+0xd4>)
  9a:	f246 31af 	movw	r1, #25519	; 0x63af
  9e:	f7ff fffe 	bl	0 <bench_curve25519KeyAgree>
    wc_curve25519_free(&genKey2);
  a2:	a823      	add	r0, sp, #140	; 0x8c
  a4:	f7ff fffe 	bl	0 <wc_curve25519_free>
  a8:	e7cf      	b.n	4a <bench_curve25519KeyAgree+0x4a>
        count += i;
  aa:	9b04      	ldr	r3, [sp, #16]
    } while (bench_stats_check(start));
  ac:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count += i;
  b0:	3302      	adds	r3, #2
  b2:	9304      	str	r3, [sp, #16]
    } while (bench_stats_check(start));
  b4:	f7ff fffe 	bl	0 <bench_curve25519KeyAgree>
  b8:	4604      	mov	r4, r0
  ba:	2800      	cmp	r0, #0
  bc:	d1ce      	bne.n	5c <bench_curve25519KeyAgree+0x5c>
exit:
  be:	e7e3      	b.n	88 <bench_curve25519KeyAgree+0x88>
	...
  c8:	0000001c 	.word	0x0000001c
  cc:	0000003c 	.word	0x0000003c
  d0:	00000000 	.word	0x00000000
  d4:	00000045 	.word	0x00000045

Disassembly of section .text.bench_ed25519KeyGen:

00000000 <bench_ed25519KeyGen>:
#endif /* HAVE_CURVE25519_SHARED_SECRET */
#endif /* HAVE_CURVE25519 */

#ifdef HAVE_ED25519
void bench_ed25519KeyGen(void)
{
   0:	b510      	push	{r4, lr}
   2:	b0a2      	sub	sp, #136	; 0x88
    double start;
    int    i, count;
    const char**desc = bench_desc_words[lng_index];

    /* Key Gen */
    bench_stats_start(&count, &start);
   4:	a906      	add	r1, sp, #24
   6:	a805      	add	r0, sp, #20
   8:	f7ff fffe 	bl	0 <bench_ed25519KeyGen>
    do {
        for (i = 0; i < genTimes; i++) {
            wc_ed25519_init(&genKey);
            (void)wc_ed25519_make_key(&gRng, 32, &genKey);
   c:	4c11      	ldr	r4, [pc, #68]	; (54 <bench_ed25519KeyGen+0x54>)
            wc_ed25519_init(&genKey);
   e:	a808      	add	r0, sp, #32
  10:	f7ff fffe 	bl	0 <wc_ed25519_init>
            (void)wc_ed25519_make_key(&gRng, 32, &genKey);
  14:	2120      	movs	r1, #32
  16:	aa08      	add	r2, sp, #32
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <wc_ed25519_make_key>
            wc_ed25519_free(&genKey);
  1e:	a808      	add	r0, sp, #32
  20:	f7ff fffe 	bl	0 <wc_ed25519_free>
        }
        count += i;
  24:	9b05      	ldr	r3, [sp, #20]
    } while (bench_stats_check(start));
  26:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
        count += i;
  2a:	3301      	adds	r3, #1
  2c:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
  2e:	f7ff fffe 	bl	0 <bench_ed25519KeyGen>
  32:	2800      	cmp	r0, #0
  34:	d1eb      	bne.n	e <bench_ed25519KeyGen+0xe>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
  36:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  3a:	e9cd 2300 	strd	r2, r3, [sp]
  3e:	4a06      	ldr	r2, [pc, #24]	; (58 <bench_ed25519KeyGen+0x58>)
  40:	9002      	str	r0, [sp, #8]
  42:	9b05      	ldr	r3, [sp, #20]
  44:	6892      	ldr	r2, [r2, #8]
  46:	4805      	ldr	r0, [pc, #20]	; (5c <bench_ed25519KeyGen+0x5c>)
  48:	f246 31af 	movw	r1, #25519	; 0x63af
  4c:	f7ff fffe 	bl	0 <bench_ed25519KeyGen>
    bench_stats_asym_finish("ED", 25519, desc[2], 0, count, start, 0);
#endif /* HAVE_ED25519_MAKE_KEY */
}
  50:	b022      	add	sp, #136	; 0x88
  52:	bd10      	pop	{r4, pc}
	...

Disassembly of section .text.bench_ed25519KeySign:

00000000 <bench_ed25519KeySign>:


void bench_ed25519KeySign(void)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	f5ad 7d34 	sub.w	sp, sp, #720	; 0x2d0
    byte   msg[512];
    word32 x = 0;
    const char**desc = bench_desc_words[lng_index];
#endif

    wc_ed25519_init(&genKey);
   8:	ad1a      	add	r5, sp, #104	; 0x68
    word32 x = 0;
   a:	2300      	movs	r3, #0
    wc_ed25519_init(&genKey);
   c:	4628      	mov	r0, r5
    word32 x = 0;
   e:	9306      	str	r3, [sp, #24]
    wc_ed25519_init(&genKey);
  10:	f7ff fffe 	bl	0 <wc_ed25519_init>

#ifdef HAVE_ED25519_MAKE_KEY
    ret = wc_ed25519_make_key(&gRng, ED25519_KEY_SIZE, &genKey);
  14:	4845      	ldr	r0, [pc, #276]	; (12c <bench_ed25519KeySign+0x12c>)
  16:	462a      	mov	r2, r5
  18:	2120      	movs	r1, #32
  1a:	f7ff fffe 	bl	0 <wc_ed25519_make_key>
    if (ret != 0) {
  1e:	b130      	cbz	r0, 2e <bench_ed25519KeySign+0x2e>
        printf("ed25519_make_key failed\n");
  20:	4843      	ldr	r0, [pc, #268]	; (130 <bench_ed25519KeySign+0x130>)
  22:	f7ff fffe 	bl	0 <printf>
    bench_stats_asym_finish("ED", 25519, desc[5], 0, count, start, ret);
#endif /* HAVE_ED25519_VERIFY */
#endif /* HAVE_ED25519_SIGN */

    wc_ed25519_free(&genKey);
}
  26:	f50d 7d34 	add.w	sp, sp, #720	; 0x2d0
  2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  2e:	ab34      	add	r3, sp, #208	; 0xd0
  30:	461e      	mov	r6, r3
        msg[i] = (byte)i;
  32:	f803 0b01 	strb.w	r0, [r3], #1
    for (i = 0; i < (int)sizeof(msg); i++)
  36:	3001      	adds	r0, #1
  38:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
  3c:	d1f9      	bne.n	32 <bench_ed25519KeySign+0x32>
    bench_stats_start(&count, &start);
  3e:	a908      	add	r1, sp, #32
  40:	a805      	add	r0, sp, #20
  42:	f7ff fffe 	bl	0 <bench_ed25519KeySign>
            x = sizeof(sig);
  46:	2740      	movs	r7, #64	; 0x40
            ret = wc_ed25519_sign_msg(msg, sizeof(msg), sig, &x, &genKey);
  48:	9500      	str	r5, [sp, #0]
  4a:	ab06      	add	r3, sp, #24
  4c:	aa0a      	add	r2, sp, #40	; 0x28
  4e:	f44f 7100 	mov.w	r1, #512	; 0x200
  52:	4630      	mov	r0, r6
            x = sizeof(sig);
  54:	9706      	str	r7, [sp, #24]
            ret = wc_ed25519_sign_msg(msg, sizeof(msg), sig, &x, &genKey);
  56:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
            if (ret != 0) {
  5a:	4604      	mov	r4, r0
  5c:	b958      	cbnz	r0, 76 <bench_ed25519KeySign+0x76>
            ret = wc_ed25519_sign_msg(msg, sizeof(msg), sig, &x, &genKey);
  5e:	9500      	str	r5, [sp, #0]
  60:	ab06      	add	r3, sp, #24
  62:	aa0a      	add	r2, sp, #40	; 0x28
  64:	f44f 7100 	mov.w	r1, #512	; 0x200
  68:	4630      	mov	r0, r6
            x = sizeof(sig);
  6a:	9706      	str	r7, [sp, #24]
            ret = wc_ed25519_sign_msg(msg, sizeof(msg), sig, &x, &genKey);
  6c:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
            if (ret != 0) {
  70:	4604      	mov	r4, r0
  72:	2800      	cmp	r0, #0
  74:	d03e      	beq.n	f4 <bench_ed25519KeySign+0xf4>
                printf("ed25519_sign_msg failed\n");
  76:	482f      	ldr	r0, [pc, #188]	; (134 <bench_ed25519KeySign+0x134>)
  78:	f7ff fffe 	bl	0 <printf>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
  7c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    bench_stats_asym_finish("ED", 25519, desc[4], 0, count, start, ret);
  80:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 138 <bench_ed25519KeySign+0x138>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
  84:	482d      	ldr	r0, [pc, #180]	; (13c <bench_ed25519KeySign+0x13c>)
  86:	9402      	str	r4, [sp, #8]
  88:	e9cd 2300 	strd	r2, r3, [sp]
  8c:	f246 31af 	movw	r1, #25519	; 0x63af
  90:	9b05      	ldr	r3, [sp, #20]
  92:	f8d8 2010 	ldr.w	r2, [r8, #16]
  96:	f7ff fffe 	bl	0 <bench_ed25519KeySign>
    bench_stats_start(&count, &start);
  9a:	a908      	add	r1, sp, #32
  9c:	a805      	add	r0, sp, #20
  9e:	f7ff fffe 	bl	0 <bench_ed25519KeySign>
            int verify = 0;
  a2:	af07      	add	r7, sp, #28
  a4:	f04f 0900 	mov.w	r9, #0
{
  a8:	f04f 0a02 	mov.w	sl, #2
            int verify = 0;
  ac:	f8c7 9000 	str.w	r9, [r7]
            ret = wc_ed25519_verify_msg(sig, x, msg, sizeof(msg), &verify,
  b0:	9906      	ldr	r1, [sp, #24]
  b2:	e9cd 7500 	strd	r7, r5, [sp]
  b6:	f44f 7300 	mov.w	r3, #512	; 0x200
  ba:	4632      	mov	r2, r6
  bc:	a80a      	add	r0, sp, #40	; 0x28
  be:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
            if (ret != 0 || verify != 1) {
  c2:	4604      	mov	r4, r0
  c4:	b910      	cbnz	r0, cc <bench_ed25519KeySign+0xcc>
  c6:	683b      	ldr	r3, [r7, #0]
  c8:	2b01      	cmp	r3, #1
  ca:	d020      	beq.n	10e <bench_ed25519KeySign+0x10e>
                printf("ed25519_verify_msg failed\n");
  cc:	481c      	ldr	r0, [pc, #112]	; (140 <bench_ed25519KeySign+0x140>)
  ce:	f7ff fffe 	bl	0 <printf>
    bench_stats_asym_finish_ex(algo, strength, desc, "", useDeviceID, count,
  d2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
  d6:	4819      	ldr	r0, [pc, #100]	; (13c <bench_ed25519KeySign+0x13c>)
  d8:	9402      	str	r4, [sp, #8]
  da:	e9cd 2300 	strd	r2, r3, [sp]
  de:	f246 31af 	movw	r1, #25519	; 0x63af
  e2:	9b05      	ldr	r3, [sp, #20]
  e4:	f8d8 2014 	ldr.w	r2, [r8, #20]
  e8:	f7ff fffe 	bl	0 <bench_ed25519KeySign>
    wc_ed25519_free(&genKey);
  ec:	4628      	mov	r0, r5
  ee:	f7ff fffe 	bl	0 <wc_ed25519_free>
  f2:	e798      	b.n	26 <bench_ed25519KeySign+0x26>
        count += i;
  f4:	9b05      	ldr	r3, [sp, #20]
    } while (bench_stats_check(start));
  f6:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
        count += i;
  fa:	3302      	adds	r3, #2
  fc:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
  fe:	f7ff fffe 	bl	0 <bench_ed25519KeySign>
 102:	4604      	mov	r4, r0
 104:	2800      	cmp	r0, #0
 106:	d19f      	bne.n	48 <bench_ed25519KeySign+0x48>
exit_ed_sign:
 108:	e7b8      	b.n	7c <bench_ed25519KeySign+0x7c>
 10a:	469a      	mov	sl, r3
 10c:	e7ce      	b.n	ac <bench_ed25519KeySign+0xac>
        for (i = 0; i < agreeTimes; i++) {
 10e:	f1ba 0f01 	cmp.w	sl, #1
 112:	d1fa      	bne.n	10a <bench_ed25519KeySign+0x10a>
        count += i;
 114:	9b05      	ldr	r3, [sp, #20]
    } while (bench_stats_check(start));
 116:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
        count += i;
 11a:	3302      	adds	r3, #2
 11c:	9305      	str	r3, [sp, #20]
    } while (bench_stats_check(start));
 11e:	f7ff fffe 	bl	0 <bench_ed25519KeySign>
 122:	4604      	mov	r4, r0
 124:	2800      	cmp	r0, #0
 126:	d1bf      	bne.n	a8 <bench_ed25519KeySign+0xa8>
exit_ed_verify:
 128:	e7d3      	b.n	d2 <bench_ed25519KeySign+0xd2>
 12a:	bf00      	nop
	...
 134:	00000019 	.word	0x00000019
	...
 140:	00000032 	.word	0x00000032

Disassembly of section .text.benchmark_test:

00000000 <benchmark_test>:
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ret = benchmark_init();
   4:	f7ff fffe 	bl	0 <benchmark_test>
   8:	4601      	mov	r1, r0
    if (ret != 0)
   a:	2800      	cmp	r0, #0
   c:	f040 8192 	bne.w	334 <benchmark_test+0x334>
        rngRet = wc_InitRng_ex(&gRng, HEAP_HINT, devId);
  10:	488f      	ldr	r0, [pc, #572]	; (250 <benchmark_test+0x250>)
  12:	f06f 0201 	mvn.w	r2, #1
  16:	f7ff fffe 	bl	0 <wc_InitRng_ex>
        if (rngRet < 0) {
  1a:	2800      	cmp	r0, #0
  1c:	da0b      	bge.n	36 <benchmark_test+0x36>
            printf("%sInitRNG failed\n", err_prefix);
  1e:	498d      	ldr	r1, [pc, #564]	; (254 <benchmark_test+0x254>)
  20:	488d      	ldr	r0, [pc, #564]	; (258 <benchmark_test+0x258>)
  22:	f7ff fffe 	bl	0 <printf>
    printf("%sBenchmark complete\n", info_prefix);
  26:	498d      	ldr	r1, [pc, #564]	; (25c <benchmark_test+0x25c>)
  28:	488d      	ldr	r0, [pc, #564]	; (260 <benchmark_test+0x260>)
  2a:	f7ff fffe 	bl	0 <printf>
}
  2e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ret = benchmark_free();
  32:	f7ff bffe 	b.w	0 <benchmark_test>
    bench_buf_size = (int)bench_size + BENCH_CIPHER_ADD;
  36:	4b8b      	ldr	r3, [pc, #556]	; (264 <benchmark_test+0x264>)
  38:	681b      	ldr	r3, [r3, #0]
  3a:	f103 0410 	add.w	r4, r3, #16
    if (bench_buf_size % 16)
  3e:	f013 030f 	ands.w	r3, r3, #15
  42:	d007      	beq.n	54 <benchmark_test+0x54>
        bench_buf_size += 16 - (bench_buf_size % 16);
  44:	4262      	negs	r2, r4
  46:	f002 020f 	and.w	r2, r2, #15
  4a:	bf58      	it	pl
  4c:	4253      	negpl	r3, r2
  4e:	f1c3 0310 	rsb	r3, r3, #16
  52:	441c      	add	r4, r3
    bench_plain = (byte*)XMALLOC((size_t)bench_buf_size + 16,
  54:	f104 0510 	add.w	r5, r4, #16
  58:	4628      	mov	r0, r5
  5a:	f7ff fffe 	bl	0 <malloc>
  5e:	4f82      	ldr	r7, [pc, #520]	; (268 <benchmark_test+0x268>)
    bench_cipher = (byte*)XMALLOC((size_t)bench_buf_size + 16,
  60:	4e82      	ldr	r6, [pc, #520]	; (26c <benchmark_test+0x26c>)
    bench_plain = (byte*)XMALLOC((size_t)bench_buf_size + 16,
  62:	6038      	str	r0, [r7, #0]
    bench_cipher = (byte*)XMALLOC((size_t)bench_buf_size + 16,
  64:	4628      	mov	r0, r5
  66:	f7ff fffe 	bl	0 <malloc>
  6a:	4603      	mov	r3, r0
  6c:	6030      	str	r0, [r6, #0]
    if (bench_plain == NULL || bench_cipher == NULL) {
  6e:	6838      	ldr	r0, [r7, #0]
  70:	b110      	cbz	r0, 78 <benchmark_test+0x78>
  72:	b9c3      	cbnz	r3, a6 <benchmark_test+0xa6>
        XFREE(bench_plain, HEAP_HINT, DYNAMIC_TYPE_WOLF_BIGINT);
  74:	f7ff fffe 	bl	0 <free>
        XFREE(bench_cipher, HEAP_HINT, DYNAMIC_TYPE_WOLF_BIGINT);
  78:	6830      	ldr	r0, [r6, #0]
  7a:	b108      	cbz	r0, 80 <benchmark_test+0x80>
  7c:	f7ff fffe 	bl	0 <free>
        bench_plain = bench_cipher = NULL;
  80:	2300      	movs	r3, #0
        printf("%sBenchmark block buffer alloc failed!\n", err_prefix);
  82:	4974      	ldr	r1, [pc, #464]	; (254 <benchmark_test+0x254>)
  84:	487a      	ldr	r0, [pc, #488]	; (270 <benchmark_test+0x270>)
        bench_plain = bench_cipher = NULL;
  86:	6033      	str	r3, [r6, #0]
  88:	603b      	str	r3, [r7, #0]
        printf("%sBenchmark block buffer alloc failed!\n", err_prefix);
  8a:	f7ff fffe 	bl	0 <printf>
    XFREE(bench_plain, HEAP_HINT, DYNAMIC_TYPE_WOLF_BIGINT);
  8e:	6838      	ldr	r0, [r7, #0]
  90:	b108      	cbz	r0, 96 <benchmark_test+0x96>
  92:	f7ff fffe 	bl	0 <free>
    XFREE(bench_cipher, HEAP_HINT, DYNAMIC_TYPE_WOLF_BIGINT);
  96:	6830      	ldr	r0, [r6, #0]
  98:	b108      	cbz	r0, 9e <benchmark_test+0x9e>
  9a:	f7ff fffe 	bl	0 <free>
    wc_FreeRng(&gRng);
  9e:	486c      	ldr	r0, [pc, #432]	; (250 <benchmark_test+0x250>)
  a0:	f7ff fffe 	bl	0 <wc_FreeRng>
    return NULL;
  a4:	e7bf      	b.n	26 <benchmark_test+0x26>
    XMEMSET(bench_plain, 0, (size_t)bench_buf_size);
  a6:	4622      	mov	r2, r4
  a8:	2100      	movs	r1, #0
  aa:	f7ff fffe 	bl	0 <memset>
    XMEMSET(bench_cipher, 0, (size_t)bench_buf_size);
  ae:	4622      	mov	r2, r4
  b0:	6830      	ldr	r0, [r6, #0]
    if (bench_all || (bench_other_algs & BENCH_RNG))
  b2:	4c70      	ldr	r4, [pc, #448]	; (274 <benchmark_test+0x274>)
    XMEMSET(bench_cipher, 0, (size_t)bench_buf_size);
  b4:	2100      	movs	r1, #0
  b6:	f7ff fffe 	bl	0 <memset>
    bench_key = (byte*)bench_key_buf;
  ba:	4b6f      	ldr	r3, [pc, #444]	; (278 <benchmark_test+0x278>)
  bc:	4a6f      	ldr	r2, [pc, #444]	; (27c <benchmark_test+0x27c>)
  be:	601a      	str	r2, [r3, #0]
    bench_iv = (byte*)bench_iv_buf;
  c0:	4b6f      	ldr	r3, [pc, #444]	; (280 <benchmark_test+0x280>)
  c2:	4a70      	ldr	r2, [pc, #448]	; (284 <benchmark_test+0x284>)
  c4:	601a      	str	r2, [r3, #0]
    if (bench_all || (bench_other_algs & BENCH_RNG))
  c6:	4b70      	ldr	r3, [pc, #448]	; (288 <benchmark_test+0x288>)
  c8:	6822      	ldr	r2, [r4, #0]
  ca:	681b      	ldr	r3, [r3, #0]
  cc:	f003 0301 	and.w	r3, r3, #1
  d0:	4313      	orrs	r3, r2
  d2:	d13c      	bne.n	14e <benchmark_test+0x14e>
    if (bench_all || (bench_cipher_algs & BENCH_AES_CBC)) {
  d4:	4b6d      	ldr	r3, [pc, #436]	; (28c <benchmark_test+0x28c>)
  d6:	681b      	ldr	r3, [r3, #0]
  d8:	07da      	lsls	r2, r3, #31
  da:	d43d      	bmi.n	158 <benchmark_test+0x158>
    if (bench_all || (bench_cipher_algs & BENCH_AES_GCM)) {
  dc:	4b6b      	ldr	r3, [pc, #428]	; (28c <benchmark_test+0x28c>)
  de:	681b      	ldr	r3, [r3, #0]
  e0:	079b      	lsls	r3, r3, #30
  e2:	d43f      	bmi.n	164 <benchmark_test+0x164>
    if (bench_all || (bench_cipher_algs & BENCH_DES)) {
  e4:	4b69      	ldr	r3, [pc, #420]	; (28c <benchmark_test+0x28c>)
  e6:	681b      	ldr	r3, [r3, #0]
  e8:	045d      	lsls	r5, r3, #17
  ea:	d44d      	bmi.n	188 <benchmark_test+0x188>
    if (bench_all || (bench_digest_algs & BENCH_SHA)) {
  ec:	4b68      	ldr	r3, [pc, #416]	; (290 <benchmark_test+0x290>)
  ee:	681b      	ldr	r3, [r3, #0]
  f0:	075a      	lsls	r2, r3, #29
  f2:	d44f      	bmi.n	194 <benchmark_test+0x194>
    if (bench_all || (bench_digest_algs & BENCH_SHA256)) {
  f4:	4b66      	ldr	r3, [pc, #408]	; (290 <benchmark_test+0x290>)
  f6:	681b      	ldr	r3, [r3, #0]
  f8:	069b      	lsls	r3, r3, #26
  fa:	d451      	bmi.n	1a0 <benchmark_test+0x1a0>
    if (bench_all || (bench_digest_algs & BENCH_SHA512)) {
  fc:	4b64      	ldr	r3, [pc, #400]	; (290 <benchmark_test+0x290>)
  fe:	681b      	ldr	r3, [r3, #0]
 100:	061d      	lsls	r5, r3, #24
 102:	d453      	bmi.n	1ac <benchmark_test+0x1ac>
        if (bench_all || (bench_mac_algs & BENCH_HMAC_SHA)) {
 104:	4b63      	ldr	r3, [pc, #396]	; (294 <benchmark_test+0x294>)
 106:	681b      	ldr	r3, [r3, #0]
 108:	075a      	lsls	r2, r3, #29
 10a:	d467      	bmi.n	1dc <benchmark_test+0x1dc>
        if (bench_all || (bench_mac_algs & BENCH_HMAC_SHA256)) {
 10c:	4b61      	ldr	r3, [pc, #388]	; (294 <benchmark_test+0x294>)
 10e:	681b      	ldr	r3, [r3, #0]
 110:	069b      	lsls	r3, r3, #26
 112:	d469      	bmi.n	1e8 <benchmark_test+0x1e8>
        if (bench_all || (bench_mac_algs & BENCH_HMAC_SHA512)) {
 114:	4b5f      	ldr	r3, [pc, #380]	; (294 <benchmark_test+0x294>)
 116:	681b      	ldr	r3, [r3, #0]
 118:	061d      	lsls	r5, r3, #24
 11a:	d46b      	bmi.n	1f4 <benchmark_test+0x1f4>
            (bench_asym_algs & BENCH_ECC_ALL) ||
 11c:	4b5e      	ldr	r3, [pc, #376]	; (298 <benchmark_test+0x298>)
 11e:	681b      	ldr	r3, [r3, #0]
 120:	f413 4f70 	tst.w	r3, #61440	; 0xf000
 124:	d16c      	bne.n	200 <benchmark_test+0x200>
    if (bench_all || (bench_asym_algs & BENCH_CURVE25519_KEYGEN)) {
 126:	4b5c      	ldr	r3, [pc, #368]	; (298 <benchmark_test+0x298>)
 128:	681b      	ldr	r3, [r3, #0]
 12a:	03d9      	lsls	r1, r3, #15
 12c:	f100 80e2 	bmi.w	2f4 <benchmark_test+0x2f4>
    if (bench_all || (bench_asym_algs & BENCH_CURVE25519_KA)) {
 130:	4b59      	ldr	r3, [pc, #356]	; (298 <benchmark_test+0x298>)
 132:	681b      	ldr	r3, [r3, #0]
 134:	0399      	lsls	r1, r3, #14
 136:	f100 80e4 	bmi.w	302 <benchmark_test+0x302>
    if (bench_all || (bench_asym_algs & BENCH_ED25519_KEYGEN))
 13a:	4b57      	ldr	r3, [pc, #348]	; (298 <benchmark_test+0x298>)
 13c:	681b      	ldr	r3, [r3, #0]
 13e:	035a      	lsls	r2, r3, #13
 140:	f100 80e6 	bmi.w	310 <benchmark_test+0x310>
    if (bench_all || (bench_asym_algs & BENCH_ED25519_SIGN))
 144:	4b54      	ldr	r3, [pc, #336]	; (298 <benchmark_test+0x298>)
 146:	681b      	ldr	r3, [r3, #0]
 148:	031b      	lsls	r3, r3, #12
 14a:	d5a0      	bpl.n	8e <benchmark_test+0x8e>
 14c:	e0e6      	b.n	31c <benchmark_test+0x31c>
        bench_rng();
 14e:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_cipher_algs & BENCH_AES_CBC)) {
 152:	6823      	ldr	r3, [r4, #0]
 154:	2b00      	cmp	r3, #0
 156:	d0bd      	beq.n	d4 <benchmark_test+0xd4>
        bench_aescbc(0);
 158:	2000      	movs	r0, #0
 15a:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_cipher_algs & BENCH_AES_GCM)) {
 15e:	6823      	ldr	r3, [r4, #0]
 160:	2b00      	cmp	r3, #0
 162:	d0bb      	beq.n	dc <benchmark_test+0xdc>
        word32 aesAuthAddSz_orig = aesAuthAddSz;
 164:	f8df 8134 	ldr.w	r8, [pc, #308]	; 29c <benchmark_test+0x29c>
        word32 options = aes_aad_options;
 168:	4b4d      	ldr	r3, [pc, #308]	; (2a0 <benchmark_test+0x2a0>)
        word32 aesAuthAddSz_orig = aesAuthAddSz;
 16a:	f8d8 9000 	ldr.w	r9, [r8]
        word32 options = aes_aad_options;
 16e:	681d      	ldr	r5, [r3, #0]
                aesAuthAddSz = aes_aad_size;
 170:	f8df a130 	ldr.w	sl, [pc, #304]	; 2a4 <benchmark_test+0x2a4>
                aesAuthAddSz = AES_AUTH_ADD_SZ;
 174:	f04f 0b0d 	mov.w	fp, #13
        while(options) {
 178:	2d00      	cmp	r5, #0
 17a:	d14c      	bne.n	216 <benchmark_test+0x216>
        bench_gmac(0);
 17c:	4628      	mov	r0, r5
 17e:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_cipher_algs & BENCH_DES)) {
 182:	6823      	ldr	r3, [r4, #0]
 184:	2b00      	cmp	r3, #0
 186:	d0ad      	beq.n	e4 <benchmark_test+0xe4>
        bench_des(0);
 188:	2000      	movs	r0, #0
 18a:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_digest_algs & BENCH_SHA)) {
 18e:	6823      	ldr	r3, [r4, #0]
 190:	2b00      	cmp	r3, #0
 192:	d0ab      	beq.n	ec <benchmark_test+0xec>
        bench_sha(0);
 194:	2000      	movs	r0, #0
 196:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_digest_algs & BENCH_SHA256)) {
 19a:	6823      	ldr	r3, [r4, #0]
 19c:	2b00      	cmp	r3, #0
 19e:	d0a9      	beq.n	f4 <benchmark_test+0xf4>
        bench_sha256(0);
 1a0:	2000      	movs	r0, #0
 1a2:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_digest_algs & BENCH_SHA512)) {
 1a6:	6823      	ldr	r3, [r4, #0]
 1a8:	2b00      	cmp	r3, #0
 1aa:	d0a7      	beq.n	fc <benchmark_test+0xfc>
        bench_sha512(0);
 1ac:	2000      	movs	r0, #0
 1ae:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_digest_algs & BENCH_SHA512)) {
 1b2:	6823      	ldr	r3, [r4, #0]
 1b4:	b91b      	cbnz	r3, 1be <benchmark_test+0x1be>
 1b6:	4b36      	ldr	r3, [pc, #216]	; (290 <benchmark_test+0x290>)
 1b8:	681b      	ldr	r3, [r3, #0]
 1ba:	0618      	lsls	r0, r3, #24
 1bc:	d5a2      	bpl.n	104 <benchmark_test+0x104>
        bench_sha512_224(0);
 1be:	2000      	movs	r0, #0
 1c0:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_digest_algs & BENCH_SHA512)) {
 1c4:	6823      	ldr	r3, [r4, #0]
 1c6:	b91b      	cbnz	r3, 1d0 <benchmark_test+0x1d0>
 1c8:	4b31      	ldr	r3, [pc, #196]	; (290 <benchmark_test+0x290>)
 1ca:	681b      	ldr	r3, [r3, #0]
 1cc:	0619      	lsls	r1, r3, #24
 1ce:	d599      	bpl.n	104 <benchmark_test+0x104>
        bench_sha512_256(0);
 1d0:	2000      	movs	r0, #0
 1d2:	f7ff fffe 	bl	0 <benchmark_test>
        if (bench_all || (bench_mac_algs & BENCH_HMAC_SHA)) {
 1d6:	6823      	ldr	r3, [r4, #0]
 1d8:	2b00      	cmp	r3, #0
 1da:	d093      	beq.n	104 <benchmark_test+0x104>
            bench_hmac_sha(0);
 1dc:	2000      	movs	r0, #0
 1de:	f7ff fffe 	bl	0 <benchmark_test>
        if (bench_all || (bench_mac_algs & BENCH_HMAC_SHA256)) {
 1e2:	6823      	ldr	r3, [r4, #0]
 1e4:	2b00      	cmp	r3, #0
 1e6:	d091      	beq.n	10c <benchmark_test+0x10c>
            bench_hmac_sha256(0);
 1e8:	2000      	movs	r0, #0
 1ea:	f7ff fffe 	bl	0 <benchmark_test>
        if (bench_all || (bench_mac_algs & BENCH_HMAC_SHA512)) {
 1ee:	6823      	ldr	r3, [r4, #0]
 1f0:	2b00      	cmp	r3, #0
 1f2:	d08f      	beq.n	114 <benchmark_test+0x114>
            bench_hmac_sha512(0);
 1f4:	2000      	movs	r0, #0
 1f6:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_asym_algs & BENCH_ECC_MAKEKEY) ||
 1fa:	6823      	ldr	r3, [r4, #0]
 1fc:	2b00      	cmp	r3, #0
 1fe:	d08d      	beq.n	11c <benchmark_test+0x11c>
        if (bench_asym_algs & BENCH_ECC_ALL) {
 200:	4a25      	ldr	r2, [pc, #148]	; (298 <benchmark_test+0x298>)
 202:	6813      	ldr	r3, [r2, #0]
 204:	0418      	lsls	r0, r3, #16
 206:	d44f      	bmi.n	2a8 <benchmark_test+0x2a8>
        else if (bench_asym_algs & BENCH_ECC_P256) {
 208:	01da      	lsls	r2, r3, #7
 20a:	f140 808a 	bpl.w	322 <benchmark_test+0x322>
            bench_ecc_curve((int)ECC_SECP256R1);
 20e:	2007      	movs	r0, #7
            bench_ecc_curve((int)ECC_SECP521R1);
 210:	f7ff fffe 	bl	0 <benchmark_test>
 214:	e06a      	b.n	2ec <benchmark_test+0x2ec>
            if (options & AAD_SIZE_DEFAULT) {
 216:	f015 0301 	ands.w	r3, r5, #1
 21a:	d009      	beq.n	230 <benchmark_test+0x230>
                aesAuthAddSz = AES_AUTH_ADD_SZ;
 21c:	f8c8 b000 	str.w	fp, [r8]
                options &= ~(word32)AAD_SIZE_DEFAULT;
 220:	f025 0501 	bic.w	r5, r5, #1
            fn(i);
 224:	2000      	movs	r0, #0
 226:	f7ff fffe 	bl	0 <benchmark_test>
            aesAuthAddSz = aesAuthAddSz_orig;
 22a:	f8c8 9000 	str.w	r9, [r8]
 22e:	e7a3      	b.n	178 <benchmark_test+0x178>
            else if (options & AAD_SIZE_ZERO) {
 230:	07a8      	lsls	r0, r5, #30
 232:	d504      	bpl.n	23e <benchmark_test+0x23e>
                aesAuthAddSz = 0;
 234:	f8c8 3000 	str.w	r3, [r8]
                options &= ~(word32)AAD_SIZE_ZERO;
 238:	f025 0502 	bic.w	r5, r5, #2
 23c:	e7f2      	b.n	224 <benchmark_test+0x224>
            else if (options & AAD_SIZE_CUSTOM) {
 23e:	0769      	lsls	r1, r5, #29
                aesAuthAddSz = aes_aad_size;
 240:	bf42      	ittt	mi
 242:	f8da 3000 	ldrmi.w	r3, [sl]
 246:	f8c8 3000 	strmi.w	r3, [r8]
                options &= ~(word32)AAD_SIZE_CUSTOM;
 24a:	f025 0504 	bicmi.w	r5, r5, #4
 24e:	e7e9      	b.n	224 <benchmark_test+0x224>
	...
 260:	00000050 	.word	0x00000050
	...
 270:	00000012 	.word	0x00000012
	...
            if (csv_format != 1) {
 2a8:	f8df 808c 	ldr.w	r8, [pc, #140]	; 338 <benchmark_test+0x338>
            bench_asym_algs |= BENCH_ECC_MAKEKEY | BENCH_ECC |
 2ac:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
 2b0:	6013      	str	r3, [r2, #0]
            if (csv_format != 1) {
 2b2:	f8d8 3000 	ldr.w	r3, [r8]
 2b6:	2b01      	cmp	r3, #1
 2b8:	d003      	beq.n	2c2 <benchmark_test+0x2c2>
                printf("\n%sECC Benchmarks:\n", info_prefix);
 2ba:	4920      	ldr	r1, [pc, #128]	; (33c <benchmark_test+0x33c>)
 2bc:	4820      	ldr	r0, [pc, #128]	; (340 <benchmark_test+0x340>)
 2be:	f7ff fffe 	bl	0 <printf>
                        printf("\n");
 2c2:	f8df 9080 	ldr.w	r9, [pc, #128]	; 344 <benchmark_test+0x344>
{
 2c6:	2501      	movs	r5, #1
                if (wc_ecc_get_curve_size_from_id(curveId) !=
 2c8:	4628      	mov	r0, r5
 2ca:	f7ff fffe 	bl	0 <wc_ecc_get_curve_size_from_id>
 2ce:	30aa      	adds	r0, #170	; 0xaa
 2d0:	d009      	beq.n	2e6 <benchmark_test+0x2e6>
                    bench_ecc_curve(curveId);
 2d2:	4628      	mov	r0, r5
 2d4:	f7ff fffe 	bl	0 <benchmark_test>
                    if (csv_format != 1) {
 2d8:	f8d8 3000 	ldr.w	r3, [r8]
 2dc:	2b01      	cmp	r3, #1
 2de:	d002      	beq.n	2e6 <benchmark_test+0x2e6>
                        printf("\n");
 2e0:	4648      	mov	r0, r9
 2e2:	f7ff fffe 	bl	0 <printf>
                curveId++;
 2e6:	3501      	adds	r5, #1
            } while (curveId != (int)ECC_CURVE_MAX);
 2e8:	2d1e      	cmp	r5, #30
 2ea:	d1ed      	bne.n	2c8 <benchmark_test+0x2c8>
    if (bench_all || (bench_asym_algs & BENCH_CURVE25519_KEYGEN)) {
 2ec:	6823      	ldr	r3, [r4, #0]
 2ee:	2b00      	cmp	r3, #0
 2f0:	f43f af19 	beq.w	126 <benchmark_test+0x126>
        bench_curve25519KeyGen(0);
 2f4:	2000      	movs	r0, #0
 2f6:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_asym_algs & BENCH_CURVE25519_KA)) {
 2fa:	6823      	ldr	r3, [r4, #0]
 2fc:	2b00      	cmp	r3, #0
 2fe:	f43f af17 	beq.w	130 <benchmark_test+0x130>
        bench_curve25519KeyAgree(0);
 302:	2000      	movs	r0, #0
 304:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_asym_algs & BENCH_ED25519_KEYGEN))
 308:	6823      	ldr	r3, [r4, #0]
 30a:	2b00      	cmp	r3, #0
 30c:	f43f af15 	beq.w	13a <benchmark_test+0x13a>
        bench_ed25519KeyGen();
 310:	f7ff fffe 	bl	0 <benchmark_test>
    if (bench_all || (bench_asym_algs & BENCH_ED25519_SIGN))
 314:	6823      	ldr	r3, [r4, #0]
 316:	2b00      	cmp	r3, #0
 318:	f43f af14 	beq.w	144 <benchmark_test+0x144>
        bench_ed25519KeySign();
 31c:	f7ff fffe 	bl	0 <benchmark_test>
 320:	e6b5      	b.n	8e <benchmark_test+0x8e>
        else if (bench_asym_algs & BENCH_ECC_P384) {
 322:	019d      	lsls	r5, r3, #6
 324:	d501      	bpl.n	32a <benchmark_test+0x32a>
            bench_ecc_curve((int)ECC_SECP384R1);
 326:	200f      	movs	r0, #15
 328:	e772      	b.n	210 <benchmark_test+0x210>
        else if (bench_asym_algs & BENCH_ECC_P521) {
 32a:	0158      	lsls	r0, r3, #5
 32c:	f57f af6f 	bpl.w	20e <benchmark_test+0x20e>
            bench_ecc_curve((int)ECC_SECP521R1);
 330:	2010      	movs	r0, #16
 332:	e76d      	b.n	210 <benchmark_test+0x210>
}
 334:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...
 340:	0000003a 	.word	0x0000003a
 344:	0000004e 	.word	0x0000004e

Disassembly of section .text.benchmark_configure:

00000000 <benchmark_configure>:
    #endif

#endif /* HAVE_GET_CYCLES */

void benchmark_configure(word32 block_size)
{
   0:	b510      	push	{r4, lr}
    /* must be greater than 0 */
    if (block_size > 0) {
   2:	b140      	cbz	r0, 16 <benchmark_configure+0x16>
        numBlocks = (int)((word32)numBlocks * bench_size / block_size);
   4:	4904      	ldr	r1, [pc, #16]	; (18 <benchmark_configure+0x18>)
   6:	4a05      	ldr	r2, [pc, #20]	; (1c <benchmark_configure+0x1c>)
   8:	680b      	ldr	r3, [r1, #0]
   a:	6814      	ldr	r4, [r2, #0]
        bench_size = block_size;
   c:	6010      	str	r0, [r2, #0]
        numBlocks = (int)((word32)numBlocks * bench_size / block_size);
   e:	4363      	muls	r3, r4
  10:	fbb3 f3f0 	udiv	r3, r3, r0
  14:	600b      	str	r3, [r1, #0]
    }
}
  16:	bd10      	pop	{r4, pc}
	...

bio.o:     file format elf32-littlearm


crl.o:     file format elf32-littlearm


internal.o:     file format elf32-littlearm


Disassembly of section .text.ForceZero:

00000000 <ForceZero>:
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
   0:	4401      	add	r1, r0
   2:	2300      	movs	r3, #0
   4:	4288      	cmp	r0, r1
   6:	d100      	bne.n	a <ForceZero+0xa>
}
   8:	4770      	bx	lr
    while (len--) *z++ = 0;
   a:	f800 3b01 	strb.w	r3, [r0], #1
   e:	e7f9      	b.n	4 <ForceZero+0x4>

Disassembly of section .text.c24to32:

00000000 <c24to32>:
#ifndef WOLFSSL_NO_INT_DECODE
/* convert a 24 bit integer into a 32 bit one */
WC_MISC_STATIC WC_INLINE void c24to32(const word24 wc_u24, word32* wc_u32)
{
    *wc_u32 = ((word32)wc_u24[0] << 16) |
              ((word32)wc_u24[1] << 8) |
   0:	7843      	ldrb	r3, [r0, #1]
    *wc_u32 = ((word32)wc_u24[0] << 16) |
   2:	7802      	ldrb	r2, [r0, #0]
              ((word32)wc_u24[1] << 8) |
   4:	021b      	lsls	r3, r3, #8
    *wc_u32 = ((word32)wc_u24[0] << 16) |
   6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
               (word32)wc_u24[2];
   a:	7882      	ldrb	r2, [r0, #2]
              ((word32)wc_u24[1] << 8) |
   c:	4313      	orrs	r3, r2
    *wc_u32 = ((word32)wc_u24[0] << 16) |
   e:	600b      	str	r3, [r1, #0]
}
  10:	4770      	bx	lr

Disassembly of section .text.ato16:

00000000 <ato16>:
}

/* convert opaque to 16 bit integer */
WC_MISC_STATIC WC_INLINE void ato16(const byte* c, word16* wc_u16)
{
    *wc_u16 = (word16) ((c[0] << 8) | (c[1]));
   0:	8803      	ldrh	r3, [r0, #0]
   2:	ba5b      	rev16	r3, r3
   4:	800b      	strh	r3, [r1, #0]
}
   6:	4770      	bx	lr

Disassembly of section .text.CipherRequires:

00000000 <CipherRequires>:

/* Does this cipher suite (first, second) have the requirement
   an ephemeral key exchange will still require the key for signing
   the key exchange so ECDHE_RSA requires an rsa key thus rsa_kea */
static int CipherRequires(byte first, byte second, int requirement)
{
   0:	4603      	mov	r3, r0
            return 1;
    }
#endif /* HAVE_CHACHA */

    /* ECC extensions */
    if (first == ECC_BYTE) {
   2:	2bc0      	cmp	r3, #192	; 0xc0
{
   4:	4610      	mov	r0, r2
    if (first == ECC_BYTE) {
   6:	d15e      	bne.n	c6 <CipherRequires+0xc6>

        switch (second) {
   8:	293a      	cmp	r1, #58	; 0x3a
   a:	d844      	bhi.n	96 <CipherRequires+0x96>
   c:	2922      	cmp	r1, #34	; 0x22
   e:	d807      	bhi.n	20 <CipherRequires+0x20>
  10:	2906      	cmp	r1, #6
  12:	d03e      	beq.n	92 <CipherRequires+0x92>
  14:	d83a      	bhi.n	8c <CipherRequires+0x8c>
  16:	3903      	subs	r1, #3
  18:	2902      	cmp	r1, #2
  1a:	d945      	bls.n	a8 <CipherRequires+0xa8>
                    return 1;
                break;
    #endif /* HAVE_ECC || HAVE_CURVE25519 || HAVE_CURVE448 */
            default:
                WOLFSSL_MSG("Unsupported cipher suite, CipherRequires ECC PSK");
                return 0;
  1c:	2000      	movs	r0, #0
    }  /* if ECC / Normal suites else */

#endif /* !WOLFSSL_NO_TLS12 */

    return 0;
}
  1e:	4770      	bx	lr
        switch (second) {
  20:	3923      	subs	r1, #35	; 0x23
  22:	2917      	cmp	r1, #23
  24:	d8fa      	bhi.n	1c <CipherRequires+0x1c>
  26:	a301      	add	r3, pc, #4	; (adr r3, 2c <CipherRequires+0x2c>)
  28:	f853 f021 	ldr.w	pc, [r3, r1, lsl #2]
  2c:	00000093 	.word	0x00000093
  30:	00000093 	.word	0x00000093
  34:	000000bb 	.word	0x000000bb
  38:	000000bb 	.word	0x000000bb
  3c:	0000001d 	.word	0x0000001d
  40:	0000001d 	.word	0x0000001d
  44:	0000001d 	.word	0x0000001d
  48:	0000001d 	.word	0x0000001d
  4c:	000000a3 	.word	0x000000a3
  50:	000000a3 	.word	0x000000a3
  54:	000000b3 	.word	0x000000b3
  58:	000000b3 	.word	0x000000b3
  5c:	0000001d 	.word	0x0000001d
  60:	0000001d 	.word	0x0000001d
  64:	0000001d 	.word	0x0000001d
  68:	0000001d 	.word	0x0000001d
  6c:	0000001d 	.word	0x0000001d
  70:	0000001d 	.word	0x0000001d
  74:	0000001d 	.word	0x0000001d
  78:	0000001d 	.word	0x0000001d
  7c:	000000cf 	.word	0x000000cf
  80:	0000001d 	.word	0x0000001d
  84:	0000001d 	.word	0x0000001d
  88:	000000cf 	.word	0x000000cf
  8c:	3908      	subs	r1, #8
  8e:	2902      	cmp	r1, #2
  90:	d8c4      	bhi.n	1c <CipherRequires+0x1c>
                if (requirement == REQUIRES_ECC)
  92:	2802      	cmp	r0, #2
  94:	e009      	b.n	aa <CipherRequires+0xaa>
        switch (second) {
  96:	29ac      	cmp	r1, #172	; 0xac
  98:	d003      	beq.n	a2 <CipherRequires+0xa2>
  9a:	3152      	adds	r1, #82	; 0x52
  9c:	b2c9      	uxtb	r1, r1
  9e:	2901      	cmp	r1, #1
  a0:	d8bc      	bhi.n	1c <CipherRequires+0x1c>
                if (requirement == REQUIRES_ECC)
  a2:	f020 0004 	bic.w	r0, r0, #4
  a6:	e7f4      	b.n	92 <CipherRequires+0x92>
                if (requirement == REQUIRES_ECC_STATIC)
  a8:	2a03      	cmp	r2, #3
  aa:	bf14      	ite	ne
  ac:	2000      	movne	r0, #0
  ae:	2001      	moveq	r0, #1
  b0:	4770      	bx	lr
                if (requirement == REQUIRES_ECC_STATIC)
  b2:	2a03      	cmp	r2, #3
  b4:	d00d      	beq.n	d2 <CipherRequires+0xd2>
                if (requirement == REQUIRES_AEAD)
  b6:	2a06      	cmp	r2, #6
  b8:	e7f7      	b.n	aa <CipherRequires+0xaa>
                if (requirement == REQUIRES_ECC)
  ba:	1e90      	subs	r0, r2, #2
  bc:	2801      	cmp	r0, #1
  be:	bf8c      	ite	hi
  c0:	2000      	movhi	r0, #0
  c2:	2001      	movls	r0, #1
  c4:	4770      	bx	lr
    if (first == ECDHE_PSK_BYTE) {
  c6:	2bd0      	cmp	r3, #208	; 0xd0
  c8:	d1a8      	bne.n	1c <CipherRequires+0x1c>
        switch (second) {
  ca:	2901      	cmp	r1, #1
  cc:	d1a6      	bne.n	1c <CipherRequires+0x1c>
                if (requirement == REQUIRES_PSK)
  ce:	2804      	cmp	r0, #4
  d0:	e7eb      	b.n	aa <CipherRequires+0xaa>
                    return 1;
  d2:	2001      	movs	r0, #1
  d4:	4770      	bx	lr
  d6:	bf00      	nop

Disassembly of section .text.SanityCheckMsgReceived:

00000000 <SanityCheckMsgReceived>:

/* Make sure no duplicates, no fast forward, or other problems; 0 on success */
static int SanityCheckMsgReceived(WOLFSSL* ssl, byte type)
{
    /* verify not a duplicate, mark received, check state */
    switch (type) {
   0:	2916      	cmp	r1, #22
   2:	d81a      	bhi.n	3a <SanityCheckMsgReceived+0x3a>
   4:	2916      	cmp	r1, #22
   6:	d81b      	bhi.n	40 <SanityCheckMsgReceived+0x40>
   8:	e8df f011 	tbh	[pc, r1, lsl #1]
   c:	002e001c 	.word	0x002e001c
  10:	004e003f 	.word	0x004e003f
  14:	001a0060 	.word	0x001a0060
  18:	001a001a 	.word	0x001a001a
  1c:	001a001a 	.word	0x001a001a
  20:	006f001a 	.word	0x006f001a
  24:	00b3009f 	.word	0x00b3009f
  28:	00e900c4 	.word	0x00e900c4
  2c:	001a00fa 	.word	0x001a00fa
  30:	001a001a 	.word	0x001a001a
  34:	001a0111 	.word	0x001a0111
  38:	008b      	.short	0x008b
  3a:	2937      	cmp	r1, #55	; 0x37
  3c:	f000 8105 	beq.w	24a <SanityCheckMsgReceived+0x24a>
  40:	4ba8      	ldr	r3, [pc, #672]	; (2e4 <SanityCheckMsgReceived+0x2e4>)
  42:	e00f      	b.n	64 <SanityCheckMsgReceived+0x64>

#ifndef NO_WOLFSSL_CLIENT
        case hello_request:
        #ifndef NO_WOLFSSL_SERVER
            if (ssl->options.side == WOLFSSL_SERVER_END) {
  44:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
  48:	f013 0f30 	tst.w	r3, #48	; 0x30
  4c:	f000 8144 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
                WOLFSSL_MSG("HelloRequest received by server");
                WOLFSSL_ERROR_VERBOSE(SIDE_ERROR);
                return SIDE_ERROR;
            }
        #endif
            if (ssl->msgsReceived.got_hello_request) {
  50:	f890 2138 	ldrb.w	r2, [r0, #312]	; 0x138
  54:	f012 0301 	ands.w	r3, r2, #1
  58:	f040 8140 	bne.w	2dc <SanityCheckMsgReceived+0x2dc>
                WOLFSSL_MSG("Duplicate HelloRequest received");
                WOLFSSL_ERROR_VERBOSE(DUPLICATE_MSG_E);
                return DUPLICATE_MSG_E;
            }
            ssl->msgsReceived.got_hello_request = 1;
  5c:	f042 0201 	orr.w	r2, r2, #1
            if (ssl->msgsReceived.got_client_hello) {
                WOLFSSL_MSG("Duplicate ClientHello received");
                WOLFSSL_ERROR_VERBOSE(DUPLICATE_MSG_E);
                return DUPLICATE_MSG_E;
            }
            ssl->msgsReceived.got_client_hello = 1;
  60:	f880 2138 	strb.w	r2, [r0, #312]	; 0x138
            WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);
            return SANITY_MSG_E;
    }

    return 0;
}
  64:	4618      	mov	r0, r3
  66:	4770      	bx	lr
            if (ssl->options.side == WOLFSSL_CLIENT_END) {
  68:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
  6c:	f003 0330 	and.w	r3, r3, #48	; 0x30
  70:	2b10      	cmp	r3, #16
  72:	f000 8131 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_client_hello) {
  76:	f890 2138 	ldrb.w	r2, [r0, #312]	; 0x138
  7a:	f012 0306 	ands.w	r3, r2, #6
  7e:	f040 812d 	bne.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_client_hello = 1;
  82:	2101      	movs	r1, #1
  84:	f361 0242 	bfi	r2, r1, #1, #2
  88:	e7ea      	b.n	60 <SanityCheckMsgReceived+0x60>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
  8a:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
  8e:	f013 0f30 	tst.w	r3, #48	; 0x30
  92:	f000 8121 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_server_hello) {
  96:	f890 2138 	ldrb.w	r2, [r0, #312]	; 0x138
  9a:	f012 0308 	ands.w	r3, r2, #8
  9e:	f040 811d 	bne.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_server_hello = 1;
  a2:	f042 0208 	orr.w	r2, r2, #8
  a6:	e7db      	b.n	60 <SanityCheckMsgReceived+0x60>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
  a8:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
  ac:	f013 0f30 	tst.w	r3, #48	; 0x30
  b0:	f000 8112 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_hello_verify_request) {
  b4:	f890 2138 	ldrb.w	r2, [r0, #312]	; 0x138
  b8:	f012 0310 	ands.w	r3, r2, #16
  bc:	f040 810e 	bne.w	2dc <SanityCheckMsgReceived+0x2dc>
            if (ssl->msgsReceived.got_hello_retry_request) {
  c0:	0611      	lsls	r1, r2, #24
  c2:	f100 8107 	bmi.w	2d4 <SanityCheckMsgReceived+0x2d4>
            ssl->msgsReceived.got_hello_verify_request = 1;
  c6:	f042 0210 	orr.w	r2, r2, #16
  ca:	e7c9      	b.n	60 <SanityCheckMsgReceived+0x60>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
  cc:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
  d0:	f013 0f30 	tst.w	r3, #48	; 0x30
  d4:	f000 8100 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_session_ticket) {
  d8:	f890 2138 	ldrb.w	r2, [r0, #312]	; 0x138
  dc:	f012 0320 	ands.w	r3, r2, #32
  e0:	f040 80fc 	bne.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_session_ticket = 1;
  e4:	f042 0220 	orr.w	r2, r2, #32
  e8:	e7ba      	b.n	60 <SanityCheckMsgReceived+0x60>
            if (ssl->msgsReceived.got_certificate) {
  ea:	f890 2139 	ldrb.w	r2, [r0, #313]	; 0x139
  ee:	f012 0302 	ands.w	r3, r2, #2
  f2:	f040 80f3 	bne.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_certificate = 1;
  f6:	f042 0202 	orr.w	r2, r2, #2
  fa:	f880 2139 	strb.w	r2, [r0, #313]	; 0x139
            if (ssl->options.side == WOLFSSL_CLIENT_END) {
  fe:	f890 2270 	ldrb.w	r2, [r0, #624]	; 0x270
 102:	f002 0230 	and.w	r2, r2, #48	; 0x30
 106:	2a10      	cmp	r2, #16
 108:	d106      	bne.n	118 <SanityCheckMsgReceived+0x118>
                if ( ssl->msgsReceived.got_server_hello == 0) {
 10a:	f890 2138 	ldrb.w	r2, [r0, #312]	; 0x138
 10e:	0710      	lsls	r0, r2, #28
 110:	d4a8      	bmi.n	64 <SanityCheckMsgReceived+0x64>
                        return OUT_OF_ORDER_E;
 112:	f46f 73ba 	mvn.w	r3, #372	; 0x174
 116:	e7a5      	b.n	64 <SanityCheckMsgReceived+0x64>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
 118:	2a00      	cmp	r2, #0
 11a:	f000 8081 	beq.w	220 <SanityCheckMsgReceived+0x220>
    return 0;
 11e:	2300      	movs	r3, #0
 120:	e7a0      	b.n	64 <SanityCheckMsgReceived+0x64>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
 122:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
 126:	f013 0f30 	tst.w	r3, #48	; 0x30
 12a:	f000 80d5 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_certificate_status) {
 12e:	f890 3139 	ldrb.w	r3, [r0, #313]	; 0x139
 132:	0759      	lsls	r1, r3, #29
 134:	f100 80d2 	bmi.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_certificate_status = 1;
 138:	f043 0304 	orr.w	r3, r3, #4
            if (ssl->msgsReceived.got_certificate == 0) {
 13c:	079a      	lsls	r2, r3, #30
            ssl->msgsReceived.got_certificate_status = 1;
 13e:	f880 3139 	strb.w	r3, [r0, #313]	; 0x139
            if (ssl->msgsReceived.got_certificate == 0) {
 142:	d5e6      	bpl.n	112 <SanityCheckMsgReceived+0x112>
            if (ssl->msgsReceived.got_server_key_exchange != 0) {
 144:	0718      	lsls	r0, r3, #28
 146:	d5ea      	bpl.n	11e <SanityCheckMsgReceived+0x11e>
 148:	e7e3      	b.n	112 <SanityCheckMsgReceived+0x112>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
 14a:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
 14e:	f013 0f30 	tst.w	r3, #48	; 0x30
 152:	f000 80c1 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_server_key_exchange) {
 156:	f890 3139 	ldrb.w	r3, [r0, #313]	; 0x139
 15a:	0719      	lsls	r1, r3, #28
 15c:	f100 80be 	bmi.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_server_key_exchange = 1;
 160:	f043 0308 	orr.w	r3, r3, #8
 164:	f880 3139 	strb.w	r3, [r0, #313]	; 0x139
            if (ssl->msgsReceived.got_server_hello == 0) {
 168:	f890 3138 	ldrb.w	r3, [r0, #312]	; 0x138
 16c:	f013 0f08 	tst.w	r3, #8
 170:	e05a      	b.n	228 <SanityCheckMsgReceived+0x228>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
 172:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
 176:	f013 0f30 	tst.w	r3, #48	; 0x30
 17a:	f000 80ad 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_certificate_request) {
 17e:	f890 2139 	ldrb.w	r2, [r0, #313]	; 0x139
 182:	f012 0310 	ands.w	r3, r2, #16
 186:	f040 80a9 	bne.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_certificate_request = 1;
 18a:	f042 0210 	orr.w	r2, r2, #16
 18e:	f880 2139 	strb.w	r2, [r0, #313]	; 0x139
            break;
 192:	e767      	b.n	64 <SanityCheckMsgReceived+0x64>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
 194:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
 198:	f013 0f30 	tst.w	r3, #48	; 0x30
 19c:	f000 809c 	beq.w	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_server_hello_done) {
 1a0:	f890 3139 	ldrb.w	r3, [r0, #313]	; 0x139
 1a4:	069a      	lsls	r2, r3, #26
 1a6:	f100 8099 	bmi.w	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_server_hello_done = 1;
 1aa:	f043 0320 	orr.w	r3, r3, #32
            if (ssl->msgsReceived.got_certificate == 0) {
 1ae:	0799      	lsls	r1, r3, #30
            ssl->msgsReceived.got_server_hello_done = 1;
 1b0:	f880 3139 	strb.w	r3, [r0, #313]	; 0x139
            if (ssl->msgsReceived.got_certificate == 0) {
 1b4:	d408      	bmi.n	1c8 <SanityCheckMsgReceived+0x1c8>
                    ssl->specs.kea == dhe_psk_kea ||
 1b6:	f890 214b 	ldrb.w	r2, [r0, #331]	; 0x14b
                if (ssl->specs.kea == psk_kea ||
 1ba:	3a04      	subs	r2, #4
 1bc:	2a02      	cmp	r2, #2
 1be:	d903      	bls.n	1c8 <SanityCheckMsgReceived+0x1c8>
                    ssl->specs.kea == ecdhe_psk_kea ||
 1c0:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 1c4:	0712      	lsls	r2, r2, #28
 1c6:	d5a4      	bpl.n	112 <SanityCheckMsgReceived+0x112>
            if (ssl->msgsReceived.got_server_key_exchange == 0) {
 1c8:	071b      	lsls	r3, r3, #28
 1ca:	d4a8      	bmi.n	11e <SanityCheckMsgReceived+0x11e>
                if (ssl->specs.static_ecdh == 1 ||
 1cc:	f890 314f 	ldrb.w	r3, [r0, #335]	; 0x14f
 1d0:	2b01      	cmp	r3, #1
 1d2:	d0a4      	beq.n	11e <SanityCheckMsgReceived+0x11e>
 1d4:	f890 314b 	ldrb.w	r3, [r0, #331]	; 0x14b
 1d8:	2b01      	cmp	r3, #1
 1da:	d0a0      	beq.n	11e <SanityCheckMsgReceived+0x11e>
 1dc:	e799      	b.n	112 <SanityCheckMsgReceived+0x112>
            if (ssl->options.side == WOLFSSL_CLIENT_END) {
 1de:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
 1e2:	f003 0330 	and.w	r3, r3, #48	; 0x30
 1e6:	2b10      	cmp	r3, #16
 1e8:	d076      	beq.n	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_certificate_verify) {
 1ea:	f890 3139 	ldrb.w	r3, [r0, #313]	; 0x139
 1ee:	0659      	lsls	r1, r3, #25
 1f0:	d474      	bmi.n	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_certificate_verify = 1;
 1f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 1f6:	f880 3139 	strb.w	r3, [r0, #313]	; 0x139
            if ( ssl->msgsReceived.got_certificate == 0) {
 1fa:	f013 0f02 	tst.w	r3, #2
 1fe:	e013      	b.n	228 <SanityCheckMsgReceived+0x228>
            if (ssl->options.side == WOLFSSL_CLIENT_END) {
 200:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
 204:	f003 0330 	and.w	r3, r3, #48	; 0x30
 208:	2b10      	cmp	r3, #16
 20a:	d065      	beq.n	2d8 <SanityCheckMsgReceived+0x2d8>
            if (ssl->msgsReceived.got_client_key_exchange) {
 20c:	f990 3139 	ldrsb.w	r3, [r0, #313]	; 0x139
 210:	2b00      	cmp	r3, #0
 212:	db63      	blt.n	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_client_key_exchange = 1;
 214:	f890 3139 	ldrb.w	r3, [r0, #313]	; 0x139
 218:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 21c:	f880 3139 	strb.w	r3, [r0, #313]	; 0x139
                if ( ssl->msgsReceived.got_client_hello == 0) {
 220:	f890 3138 	ldrb.w	r3, [r0, #312]	; 0x138
 224:	f013 0f06 	tst.w	r3, #6
 228:	f47f af79 	bne.w	11e <SanityCheckMsgReceived+0x11e>
 22c:	e771      	b.n	112 <SanityCheckMsgReceived+0x112>
            if (ssl->msgsReceived.got_finished) {
 22e:	f890 313a 	ldrb.w	r3, [r0, #314]	; 0x13a
 232:	07da      	lsls	r2, r3, #31
 234:	d452      	bmi.n	2dc <SanityCheckMsgReceived+0x2dc>
            ssl->msgsReceived.got_finished = 1;
 236:	f043 0301 	orr.w	r3, r3, #1
 23a:	f880 313a 	strb.w	r3, [r0, #314]	; 0x13a
            if (ssl->msgsReceived.got_change_cipher == 0) {
 23e:	0758      	lsls	r0, r3, #29
 240:	f53f af6d 	bmi.w	11e <SanityCheckMsgReceived+0x11e>
                return NO_CHANGE_CIPHER_E;
 244:	f46f 73c4 	mvn.w	r3, #392	; 0x188
 248:	e70c      	b.n	64 <SanityCheckMsgReceived+0x64>
            if (ssl->msgsReceived.got_change_cipher) {
 24a:	f890 213a 	ldrb.w	r2, [r0, #314]	; 0x13a
 24e:	0751      	lsls	r1, r2, #29
 250:	d444      	bmi.n	2dc <SanityCheckMsgReceived+0x2dc>
            if (!ssl->options.dtls)
 252:	f890 3272 	ldrb.w	r3, [r0, #626]	; 0x272
 256:	f013 0304 	ands.w	r3, r3, #4
                ssl->msgsReceived.got_change_cipher = 1;
 25a:	bf04      	itt	eq
 25c:	f042 0204 	orreq.w	r2, r2, #4
 260:	f880 213a 	strbeq.w	r2, [r0, #314]	; 0x13a
            if (ssl->options.side == WOLFSSL_CLIENT_END) {
 264:	f890 2270 	ldrb.w	r2, [r0, #624]	; 0x270
 268:	f002 0130 	and.w	r1, r2, #48	; 0x30
 26c:	2910      	cmp	r1, #16
 26e:	d118      	bne.n	2a2 <SanityCheckMsgReceived+0x2a2>
                if (!ssl->options.resuming) {
 270:	f890 2271 	ldrb.w	r2, [r0, #625]	; 0x271
 274:	0712      	lsls	r2, r2, #28
 276:	d40f      	bmi.n	298 <SanityCheckMsgReceived+0x298>
                   if (ssl->msgsReceived.got_server_hello_done == 0) {
 278:	f890 2139 	ldrb.w	r2, [r0, #313]	; 0x139
 27c:	f012 0f20 	tst.w	r2, #32
                    if (ssl->msgsReceived.got_server_hello == 0) {
 280:	f43f af47 	beq.w	112 <SanityCheckMsgReceived+0x112>
            if (ssl->options.dtls)
 284:	2b00      	cmp	r3, #0
 286:	f43f af4a 	beq.w	11e <SanityCheckMsgReceived+0x11e>
                ssl->msgsReceived.got_change_cipher = 1;
 28a:	f890 313a 	ldrb.w	r3, [r0, #314]	; 0x13a
 28e:	f043 0304 	orr.w	r3, r3, #4
 292:	f880 313a 	strb.w	r3, [r0, #314]	; 0x13a
 296:	e742      	b.n	11e <SanityCheckMsgReceived+0x11e>
                    if (ssl->msgsReceived.got_server_hello == 0) {
 298:	f890 2138 	ldrb.w	r2, [r0, #312]	; 0x138
 29c:	f012 0f08 	tst.w	r2, #8
 2a0:	e7ee      	b.n	280 <SanityCheckMsgReceived+0x280>
            if (ssl->options.side == WOLFSSL_SERVER_END) {
 2a2:	2900      	cmp	r1, #0
 2a4:	d1ee      	bne.n	284 <SanityCheckMsgReceived+0x284>
                if (!ssl->options.resuming &&
 2a6:	f890 1271 	ldrb.w	r1, [r0, #625]	; 0x271
 2aa:	0709      	lsls	r1, r1, #28
 2ac:	d404      	bmi.n	2b8 <SanityCheckMsgReceived+0x2b8>
 2ae:	f990 1139 	ldrsb.w	r1, [r0, #313]	; 0x139
 2b2:	2900      	cmp	r1, #0
 2b4:	f6bf af2d 	bge.w	112 <SanityCheckMsgReceived+0x112>
                    if (ssl->options.verifyPeer &&
 2b8:	0652      	lsls	r2, r2, #25
 2ba:	d5e3      	bpl.n	284 <SanityCheckMsgReceived+0x284>
 2bc:	f890 2274 	ldrb.w	r2, [r0, #628]	; 0x274
 2c0:	07d1      	lsls	r1, r2, #31
 2c2:	d5df      	bpl.n	284 <SanityCheckMsgReceived+0x284>
                        if (!ssl->options.havePeerVerify ||
 2c4:	0791      	lsls	r1, r2, #30
 2c6:	d503      	bpl.n	2d0 <SanityCheckMsgReceived+0x2d0>
                                !ssl->msgsReceived.got_certificate_verify) {
 2c8:	f890 2139 	ldrb.w	r2, [r0, #313]	; 0x139
                        if (!ssl->options.havePeerVerify ||
 2cc:	0652      	lsls	r2, r2, #25
 2ce:	d4d9      	bmi.n	284 <SanityCheckMsgReceived+0x284>
                            return NO_PEER_VERIFY;
 2d0:	4b05      	ldr	r3, [pc, #20]	; (2e8 <SanityCheckMsgReceived+0x2e8>)
 2d2:	e6c7      	b.n	64 <SanityCheckMsgReceived+0x64>
                return VERSION_ERROR;
 2d4:	4b05      	ldr	r3, [pc, #20]	; (2ec <SanityCheckMsgReceived+0x2ec>)
 2d6:	e6c5      	b.n	64 <SanityCheckMsgReceived+0x64>
                return SIDE_ERROR;
 2d8:	4b05      	ldr	r3, [pc, #20]	; (2f0 <SanityCheckMsgReceived+0x2f0>)
 2da:	e6c3      	b.n	64 <SanityCheckMsgReceived+0x64>
                return DUPLICATE_MSG_E;
 2dc:	f46f 73c5 	mvn.w	r3, #394	; 0x18a
 2e0:	e6c0      	b.n	64 <SanityCheckMsgReceived+0x64>
 2e2:	bf00      	nop
 2e4:	fffffe76 	.word	0xfffffe76
 2e8:	fffffe86 	.word	0xfffffe86
 2ec:	fffffeba 	.word	0xfffffeba
 2f0:	fffffea8 	.word	0xfffffea8

Disassembly of section .text.FreeSckeArgs:

00000000 <FreeSckeArgs>:
{
    SckeArgs* args = (SckeArgs*)pArgs;

    (void)ssl;

    if (args->encSecret) {
   0:	6848      	ldr	r0, [r1, #4]
{
   2:	b510      	push	{r4, lr}
   4:	460c      	mov	r4, r1
    if (args->encSecret) {
   6:	b118      	cbz	r0, 10 <FreeSckeArgs+0x10>
        XFREE(args->encSecret, ssl->heap, DYNAMIC_TYPE_SECRET);
   8:	f7ff fffe 	bl	0 <free>
        args->encSecret = NULL;
   c:	2300      	movs	r3, #0
   e:	6063      	str	r3, [r4, #4]
    }
    if (args->input) {
  10:	68a0      	ldr	r0, [r4, #8]
  12:	b118      	cbz	r0, 1c <FreeSckeArgs+0x1c>
        XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
  14:	f7ff fffe 	bl	0 <free>
        args->input = NULL;
  18:	2300      	movs	r3, #0
  1a:	60a3      	str	r3, [r4, #8]
    }
}
  1c:	bd10      	pop	{r4, pc}

Disassembly of section .text.FreeScvArgs:

00000000 <FreeScvArgs>:
    if (args->verifySig) {
        XFREE(args->verifySig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
        args->verifySig = NULL;
    }
#endif
    if (args->input) {
   0:	6888      	ldr	r0, [r1, #8]
{
   2:	b510      	push	{r4, lr}
   4:	460c      	mov	r4, r1
    if (args->input) {
   6:	b118      	cbz	r0, 10 <FreeScvArgs+0x10>
        XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
   8:	f7ff fffe 	bl	0 <free>
        args->input = NULL;
   c:	2300      	movs	r3, #0
   e:	60a3      	str	r3, [r4, #8]
    }
}
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.FreeSskeArgs:

00000000 <FreeSskeArgs>:
        SskeArgs* args = (SskeArgs*)pArgs;

        (void)ssl;

    #if defined(HAVE_ECC) || defined(HAVE_CURVE25519) || defined(HAVE_CURVE448)
        if (args->exportBuf) {
   0:	6848      	ldr	r0, [r1, #4]
    {
   2:	b510      	push	{r4, lr}
   4:	460c      	mov	r4, r1
        if (args->exportBuf) {
   6:	b118      	cbz	r0, 10 <FreeSskeArgs+0x10>
            XFREE(args->exportBuf, ssl->heap, DYNAMIC_TYPE_DER);
   8:	f7ff fffe 	bl	0 <free>
            args->exportBuf = NULL;
   c:	2300      	movs	r3, #0
   e:	6063      	str	r3, [r4, #4]
            XFREE(args->verifySig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
            args->verifySig = NULL;
        }
    #endif
        (void)args;
    }
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.ProcessPeerCertParse:

00000000 <ProcessPeerCertParse>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460c      	mov	r4, r1
   4:	4615      	mov	r5, r2
   6:	461f      	mov	r7, r3
    if (ssl == NULL || args == NULL
   8:	4606      	mov	r6, r0
   a:	2800      	cmp	r0, #0
   c:	d040      	beq.n	90 <ProcessPeerCertParse+0x90>
   e:	2900      	cmp	r1, #0
  10:	d03e      	beq.n	90 <ProcessPeerCertParse+0x90>
        || args->dCert == NULL
  12:	6848      	ldr	r0, [r1, #4]
  14:	2800      	cmp	r0, #0
  16:	d03b      	beq.n	90 <ProcessPeerCertParse+0x90>
    if (args->certIdx > args->count)
  18:	e9d1 3105 	ldrd	r3, r1, [r1, #20]
  1c:	4299      	cmp	r1, r3
  1e:	dc3b      	bgt.n	98 <ProcessPeerCertParse+0x98>
    if (!args->dCertInit
  20:	f894 3020 	ldrb.w	r3, [r4, #32]
  24:	075a      	lsls	r2, r3, #29
  26:	d414      	bmi.n	52 <ProcessPeerCertParse+0x52>
    cert = &args->certs[args->certIdx];
  28:	f8d4 c000 	ldr.w	ip, [r4]
        InitDecodedCert(args->dCert, cert->buffer, cert->length, ssl->heap);
  2c:	6a73      	ldr	r3, [r6, #36]	; 0x24
    cert = &args->certs[args->certIdx];
  2e:	eb0c 02c1 	add.w	r2, ip, r1, lsl #3
        InitDecodedCert(args->dCert, cert->buffer, cert->length, ssl->heap);
  32:	f85c 1031 	ldr.w	r1, [ip, r1, lsl #3]
  36:	6852      	ldr	r2, [r2, #4]
  38:	f7ff fffe 	bl	0 <InitDecodedCert>
        args->dCertInit = 1;
  3c:	f894 3020 	ldrb.w	r3, [r4, #32]
  40:	f043 0304 	orr.w	r3, r3, #4
  44:	f884 3020 	strb.w	r3, [r4, #32]
        args->dCert->sigCtx.devId = ssl->devId;
  48:	6863      	ldr	r3, [r4, #4]
  4a:	f8d6 22bc 	ldr.w	r2, [r6, #700]	; 0x2bc
  4e:	f8c3 2338 	str.w	r2, [r3, #824]	; 0x338
    ret = ParseCertRelative(args->dCert, certType, verify, SSL_CM(ssl));
  52:	6833      	ldr	r3, [r6, #0]
  54:	6860      	ldr	r0, [r4, #4]
  56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  58:	4629      	mov	r1, r5
  5a:	463a      	mov	r2, r7
  5c:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (ret == 0 || ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E) {
  60:	4605      	mov	r5, r0
  62:	b118      	cbz	r0, 6c <ProcessPeerCertParse+0x6c>
  64:	f100 0397 	add.w	r3, r0, #151	; 0x97
  68:	2b01      	cmp	r3, #1
  6a:	d818      	bhi.n	9e <ProcessPeerCertParse+0x9e>
        if (args->dCert->extAuthKeyIdSet)
  6c:	6864      	ldr	r4, [r4, #4]
  6e:	f894 3354 	ldrb.w	r3, [r4, #852]	; 0x354
  72:	075b      	lsls	r3, r3, #29
        alreadySigner = AlreadySigner(SSL_CM(ssl), subjectHash);
  74:	6833      	ldr	r3, [r6, #0]
            subjectHash = args->dCert->extSubjKeyId;
  76:	bf4c      	ite	mi
  78:	f504 7433 	addmi.w	r4, r4, #716	; 0x2cc
            subjectHash = args->dCert->subjectHash;
  7c:	3438      	addpl	r4, #56	; 0x38
        alreadySigner = AlreadySigner(SSL_CM(ssl), subjectHash);
  7e:	6a98      	ldr	r0, [r3, #40]	; 0x28
  80:	4621      	mov	r1, r4
  82:	f7ff fffe 	bl	0 <AlreadySigner>
        *pSubjectHash = subjectHash;
  86:	9b06      	ldr	r3, [sp, #24]
  88:	601c      	str	r4, [r3, #0]
        *pAlreadySigner = alreadySigner;
  8a:	9b07      	ldr	r3, [sp, #28]
  8c:	6018      	str	r0, [r3, #0]
  8e:	e001      	b.n	94 <ProcessPeerCertParse+0x94>
        return BAD_FUNC_ARG;
  90:	f06f 05ac 	mvn.w	r5, #172	; 0xac
}
  94:	4628      	mov	r0, r5
  96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BUFFER_E;
  98:	f06f 0583 	mvn.w	r5, #131	; 0x83
  9c:	e7fa      	b.n	94 <ProcessPeerCertParse+0x94>
    int alreadySigner = 0;
  9e:	2000      	movs	r0, #0
    byte* subjectHash = NULL;
  a0:	4604      	mov	r4, r0
  a2:	e7f0      	b.n	86 <ProcessPeerCertParse+0x86>

Disassembly of section .text.HashSkeData:

00000000 <HashSkeData>:
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4604      	mov	r4, r0
    int digest_sz = wc_HashGetDigestSize(hashType);
   6:	4608      	mov	r0, r1
{
   8:	460e      	mov	r6, r1
   a:	4690      	mov	r8, r2
   c:	461f      	mov	r7, r3
    int digest_sz = wc_HashGetDigestSize(hashType);
   e:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (digest_sz <= 0) {
  12:	1e05      	subs	r5, r0, #0
  14:	dd49      	ble.n	aa <HashSkeData+0xaa>
        ssl->buffers.sig.buffer = (byte*)XMALLOC(SEED_LEN + sz, ssl->heap,
  16:	f107 0940 	add.w	r9, r7, #64	; 0x40
  1a:	4648      	mov	r0, r9
  1c:	f7ff fffe 	bl	0 <malloc>
  20:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
        if (ssl->buffers.sig.buffer == NULL) {
  24:	b928      	cbnz	r0, 32 <HashSkeData+0x32>
            ret = MEMORY_E;
  26:	f06f 057c 	mvn.w	r5, #124	; 0x7c
}
  2a:	4628      	mov	r0, r5
  2c:	b003      	add	sp, #12
  2e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        XMEMCPY(ssl->buffers.sig.buffer, ssl->arrays->clientRandom, RAN_LEN);
  32:	68a1      	ldr	r1, [r4, #8]
        ssl->buffers.sig.length = SEED_LEN + sz;
  34:	f8c4 90c4 	str.w	r9, [r4, #196]	; 0xc4
        XMEMCPY(ssl->buffers.sig.buffer, ssl->arrays->clientRandom, RAN_LEN);
  38:	2220      	movs	r2, #32
  3a:	3114      	adds	r1, #20
  3c:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(&ssl->buffers.sig.buffer[RAN_LEN], ssl->arrays->serverRandom,
  40:	68a1      	ldr	r1, [r4, #8]
  42:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  46:	2220      	movs	r2, #32
  48:	3134      	adds	r1, #52	; 0x34
  4a:	4410      	add	r0, r2
  4c:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(&ssl->buffers.sig.buffer[RAN_LEN * 2], data, sz);
  50:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  54:	463a      	mov	r2, r7
  56:	4641      	mov	r1, r8
  58:	3040      	adds	r0, #64	; 0x40
  5a:	f7ff fffe 	bl	0 <memcpy>
    if (sigAlgo == ed25519_sa_algo) {
  5e:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
  62:	2b09      	cmp	r3, #9
  64:	d023      	beq.n	ae <HashSkeData+0xae>
        ssl->options.dontFreeDigest = 0;
  66:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
        ssl->buffers.digest.length = (unsigned int)digest_sz;
  6a:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc
        ssl->options.dontFreeDigest = 0;
  6e:	f36f 0382 	bfc	r3, #2, #1
  72:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
        ssl->buffers.digest.buffer = (byte*)XMALLOC(ssl->buffers.digest.length,
  76:	4628      	mov	r0, r5
  78:	f7ff fffe 	bl	0 <malloc>
  7c:	4603      	mov	r3, r0
  7e:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
        if (ssl->buffers.digest.buffer == NULL) {
  82:	2800      	cmp	r0, #0
  84:	d0cf      	beq.n	26 <HashSkeData+0x26>
        ret = wc_Hash(hashType, ssl->buffers.sig.buffer,
  86:	f8d4 20cc 	ldr.w	r2, [r4, #204]	; 0xcc
  8a:	9200      	str	r2, [sp, #0]
  8c:	4630      	mov	r0, r6
  8e:	e9d4 1230 	ldrd	r1, r2, [r4, #192]	; 0xc0
  92:	f7ff fffe 	bl	0 <wc_Hash>
  96:	4605      	mov	r5, r0
            XFREE(ssl->buffers.sig.buffer, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
  98:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  9c:	b108      	cbz	r0, a2 <HashSkeData+0xa2>
  9e:	f7ff fffe 	bl	0 <free>
            ssl->buffers.sig.buffer = NULL;
  a2:	2300      	movs	r3, #0
  a4:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
  a8:	e7bf      	b.n	2a <HashSkeData+0x2a>
  aa:	4d02      	ldr	r5, [pc, #8]	; (b4 <HashSkeData+0xb4>)
  ac:	e7bd      	b.n	2a <HashSkeData+0x2a>
  ae:	2500      	movs	r5, #0
    return ret;
  b0:	e7bb      	b.n	2a <HashSkeData+0x2a>
  b2:	bf00      	nop
  b4:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.DecodeSigAlg:

00000000 <DecodeSigAlg>:
    *hsType = invalid_sa_algo;
   0:	23ff      	movs	r3, #255	; 0xff
   2:	7013      	strb	r3, [r2, #0]
    switch (input[0]) {
   4:	7803      	ldrb	r3, [r0, #0]
   6:	2b08      	cmp	r3, #8
{
   8:	b510      	push	{r4, lr}
    switch (input[0]) {
   a:	d10a      	bne.n	22 <DecodeSigAlg+0x22>
            if (input[1] == ED25519_SA_MINOR) {
   c:	7844      	ldrb	r4, [r0, #1]
   e:	2c07      	cmp	r4, #7
                *hsType = ed25519_sa_algo;
  10:	bf0b      	itete	eq
  12:	2309      	moveq	r3, #9
                *hsType   = input[0];
  14:	7013      	strbne	r3, [r2, #0]
                *hsType = ed25519_sa_algo;
  16:	7013      	strbeq	r3, [r2, #0]
                *hashAlgo = input[1];
  18:	7843      	ldrbne	r3, [r0, #1]
                *hashAlgo = sha512_mac;
  1a:	bf08      	it	eq
  1c:	2306      	moveq	r3, #6
                *hashAlgo = input[1];
  1e:	700b      	strb	r3, [r1, #0]
}
  20:	bd10      	pop	{r4, pc}
            *hashAlgo = input[0];
  22:	700b      	strb	r3, [r1, #0]
            *hsType   = input[1];
  24:	7843      	ldrb	r3, [r0, #1]
  26:	7013      	strb	r3, [r2, #0]
}
  28:	e7fa      	b.n	20 <DecodeSigAlg+0x20>

Disassembly of section .text.SetDigest:

00000000 <SetDigest>:
    switch (hashAlgo) {
   0:	2904      	cmp	r1, #4
   2:	d011      	beq.n	28 <SetDigest+0x28>
   4:	2906      	cmp	r1, #6
   6:	d01b      	beq.n	40 <SetDigest+0x40>
   8:	2902      	cmp	r1, #2
   a:	d10c      	bne.n	26 <SetDigest+0x26>
            ssl->options.dontFreeDigest = 1;
   c:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
  10:	f043 0304 	orr.w	r3, r3, #4
  14:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
            ssl->buffers.digest.buffer = ssl->hsHashes->certHashes.sha;
  18:	68c3      	ldr	r3, [r0, #12]
  1a:	3374      	adds	r3, #116	; 0x74
  1c:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
            ssl->buffers.digest.length = WC_SHA_DIGEST_SIZE;
  20:	2314      	movs	r3, #20
            ssl->buffers.digest.length = WC_SHA512_DIGEST_SIZE;
  22:	f8c0 30cc 	str.w	r3, [r0, #204]	; 0xcc
}
  26:	4770      	bx	lr
            ssl->options.dontFreeDigest = 1;
  28:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
  2c:	f043 0304 	orr.w	r3, r3, #4
  30:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
            ssl->buffers.digest.buffer = ssl->hsHashes->certHashes.sha256;
  34:	68c3      	ldr	r3, [r0, #12]
  36:	3388      	adds	r3, #136	; 0x88
  38:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
            ssl->buffers.digest.length = WC_SHA256_DIGEST_SIZE;
  3c:	2320      	movs	r3, #32
  3e:	e7f0      	b.n	22 <SetDigest+0x22>
            ssl->options.dontFreeDigest = 1;
  40:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
  44:	f043 0304 	orr.w	r3, r3, #4
  48:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
            ssl->buffers.digest.buffer = ssl->hsHashes->certHashes.sha512;
  4c:	68c3      	ldr	r3, [r0, #12]
  4e:	33a8      	adds	r3, #168	; 0xa8
  50:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
            ssl->buffers.digest.length = WC_SHA512_DIGEST_SIZE;
  54:	2340      	movs	r3, #64	; 0x40
  56:	e7e4      	b.n	22 <SetDigest+0x22>

Disassembly of section .text.AddRecordHeader.constprop.0:

00000000 <AddRecordHeader.constprop.0>:
    if (rl == NULL) {
   0:	b170      	cbz	r0, 20 <AddRecordHeader.constprop.0+0x20>
    rl->type    = type;
   2:	7002      	strb	r2, [r0, #0]
    rl->pvMajor = ssl->version.major;       /* type and version same in each */
   4:	f893 213c 	ldrb.w	r2, [r3, #316]	; 0x13c
   8:	7042      	strb	r2, [r0, #1]
        rl->pvMinor = ssl->version.minor;
   a:	f893 213d 	ldrb.w	r2, [r3, #317]	; 0x13d
   e:	7082      	strb	r2, [r0, #2]
    if (!ssl->options.dtls) {
  10:	f893 3272 	ldrb.w	r3, [r3, #626]	; 0x272
  14:	075b      	lsls	r3, r3, #29
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  16:	bf5e      	ittt	pl
  18:	f3c1 2307 	ubfxpl	r3, r1, #8, #8
  1c:	70c3      	strbpl	r3, [r0, #3]
    c[1] =  (byte)(wc_u16       & 0xff);
  1e:	7101      	strbpl	r1, [r0, #4]
}
  20:	4770      	bx	lr

Disassembly of section .text.AddHeaders:

00000000 <AddHeaders>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4616      	mov	r6, r2
    AddRecordHeader(output, length + lengthAdj, handshake, ssl, CUR_ORDER);
   6:	3104      	adds	r1, #4
   8:	2216      	movs	r2, #22
   a:	f7ff fffe 	bl	0 <AddHeaders>
    out[0] = (byte)((in >> 16) & 0xff);
   e:	0c2b      	lsrs	r3, r5, #16
  10:	7183      	strb	r3, [r0, #6]
    out[1] = (byte)((in >>  8) & 0xff);
  12:	0a2b      	lsrs	r3, r5, #8
    hs->type = type;
  14:	7146      	strb	r6, [r0, #5]
  16:	71c3      	strb	r3, [r0, #7]
    out[2] =  (byte)(in        & 0xff);
  18:	7205      	strb	r5, [r0, #8]
}
  1a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.CompareSuites.isra.0:

00000000 <CompareSuites.isra.0>:
#endif /* WOLFSSL_TLS13 */

        return 1;
    }

    static int CompareSuites(const WOLFSSL* ssl, const Suites* suites,
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4604      	mov	r4, r0
                             Suites* peerSuites, word16 i, word16 j,
                             CipherSuite* cs, TLSX* extensions)
    {
        if (suites->suites[i]   == peerSuites->suites[j] &&
   6:	f8bd 0020 	ldrh.w	r0, [sp, #32]
    static int CompareSuites(const WOLFSSL* ssl, const Suites* suites,
   a:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
        if (suites->suites[i]   == peerSuites->suites[j] &&
   e:	eb01 0903 	add.w	r9, r1, r3
  12:	4402      	add	r2, r0
  14:	f899 5004 	ldrb.w	r5, [r9, #4]
  18:	7910      	ldrb	r0, [r2, #4]
  1a:	42a8      	cmp	r0, r5
  1c:	d004      	beq.n	28 <CompareSuites.isra.0+0x28>
            else {
                WOLFSSL_MSG("Could not verify suite validity, continue");
            }
        }

        return MATCH_SUITE_ERROR;
  1e:	f46f 7afa 	mvn.w	sl, #500	; 0x1f4
    }
  22:	4650      	mov	r0, sl
  24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            suites->suites[i+1] == peerSuites->suites[j+1] ) {
  28:	3301      	adds	r3, #1
  2a:	18cf      	adds	r7, r1, r3
        if (suites->suites[i]   == peerSuites->suites[j] &&
  2c:	7953      	ldrb	r3, [r2, #5]
            suites->suites[i+1] == peerSuites->suites[j+1] ) {
  2e:	793e      	ldrb	r6, [r7, #4]
        if (suites->suites[i]   == peerSuites->suites[j] &&
  30:	42b3      	cmp	r3, r6
  32:	d1f4      	bne.n	1e <CompareSuites.isra.0+0x1e>
        if (CipherRequires(first, second, REQUIRES_RSA)) {
  34:	2200      	movs	r2, #0
  36:	4631      	mov	r1, r6
  38:	4628      	mov	r0, r5
  3a:	f7ff fffe 	bl	0 <CompareSuites.isra.0>
  3e:	b118      	cbz	r0, 48 <CompareSuites.isra.0+0x48>
            if (ssl->options.haveRSA == 0) {
  40:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
  44:	0798      	lsls	r0, r3, #30
  46:	d5ea      	bpl.n	1e <CompareSuites.isra.0+0x1e>
        if (CipherRequires(first, second, REQUIRES_DHE)) {
  48:	2201      	movs	r2, #1
  4a:	4631      	mov	r1, r6
  4c:	4628      	mov	r0, r5
  4e:	f7ff fffe 	bl	0 <CompareSuites.isra.0>
  52:	b118      	cbz	r0, 5c <CompareSuites.isra.0+0x5c>
            if (ssl->options.haveDH == 0) {
  54:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
  58:	0719      	lsls	r1, r3, #28
  5a:	d5e0      	bpl.n	1e <CompareSuites.isra.0+0x1e>
        if (CipherRequires(first, second, REQUIRES_ECC)) {
  5c:	2202      	movs	r2, #2
  5e:	4631      	mov	r1, r6
  60:	4628      	mov	r0, r5
  62:	f7ff fffe 	bl	0 <CompareSuites.isra.0>
  66:	b118      	cbz	r0, 70 <CompareSuites.isra.0+0x70>
            if (ssl->options.haveECC == 0) {
  68:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
  6c:	075a      	lsls	r2, r3, #29
  6e:	d5d6      	bpl.n	1e <CompareSuites.isra.0+0x1e>
        if (CipherRequires(first, second, REQUIRES_ECC_STATIC)) {
  70:	2203      	movs	r2, #3
  72:	4631      	mov	r1, r6
  74:	4628      	mov	r0, r5
  76:	f7ff fffe 	bl	0 <CompareSuites.isra.0>
  7a:	b118      	cbz	r0, 84 <CompareSuites.isra.0+0x84>
            if (ssl->options.haveStaticECC == 0) {
  7c:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
  80:	069b      	lsls	r3, r3, #26
  82:	d5cc      	bpl.n	1e <CompareSuites.isra.0+0x1e>
        if (CipherRequires(first, second, REQUIRES_PSK)) {
  84:	2204      	movs	r2, #4
  86:	4631      	mov	r1, r6
  88:	4628      	mov	r0, r5
  8a:	f7ff fffe 	bl	0 <CompareSuites.isra.0>
  8e:	4682      	mov	sl, r0
  90:	2800      	cmp	r0, #0
  92:	d1c4      	bne.n	1e <CompareSuites.isra.0+0x1e>
        if (CipherRequires(first, second, REQUIRES_RSA_SIG)) {
  94:	2205      	movs	r2, #5
  96:	4631      	mov	r1, r6
  98:	4628      	mov	r0, r5
  9a:	f7ff fffe 	bl	0 <CompareSuites.isra.0>
  9e:	b160      	cbz	r0, ba <CompareSuites.isra.0+0xba>
            if (ssl->options.side == WOLFSSL_SERVER_END &&
  a0:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
  a4:	f023 436f 	bic.w	r3, r3, #4009754624	; 0xef000000
  a8:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
  ac:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
  b0:	f023 03cf 	bic.w	r3, r3, #207	; 0xcf
  b4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  b8:	d0b1      	beq.n	1e <CompareSuites.isra.0+0x1e>
        if (CipherRequires(first, second, REQUIRES_AEAD)) {
  ba:	2206      	movs	r2, #6
  bc:	4631      	mov	r1, r6
  be:	4628      	mov	r0, r5
  c0:	f7ff fffe 	bl	0 <CompareSuites.isra.0>
  c4:	b138      	cbz	r0, d6 <CompareSuites.isra.0+0xd6>
            if (ssl->version.major == SSLv3_MAJOR &&
  c6:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
  ca:	2b03      	cmp	r3, #3
  cc:	d103      	bne.n	d6 <CompareSuites.isra.0+0xd6>
  ce:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
  d2:	2b02      	cmp	r3, #2
  d4:	d9a3      	bls.n	1e <CompareSuites.isra.0+0x1e>
        if (!TLSX_ValidateSupportedCurves(ssl, first, second,
  d6:	f108 0304 	add.w	r3, r8, #4
  da:	4632      	mov	r2, r6
  dc:	4629      	mov	r1, r5
  de:	4620      	mov	r0, r4
  e0:	f7ff fffe 	bl	0 <TLSX_ValidateSupportedCurves>
  e4:	2800      	cmp	r0, #0
  e6:	d09a      	beq.n	1e <CompareSuites.isra.0+0x1e>
                cs->cipherSuite0 = suites->suites[i];
  e8:	f899 3004 	ldrb.w	r3, [r9, #4]
  ec:	f888 3000 	strb.w	r3, [r8]
                cs->cipherSuite  = suites->suites[i+1];
  f0:	793b      	ldrb	r3, [r7, #4]
  f2:	f888 3001 	strb.w	r3, [r8, #1]
                return 0;
  f6:	e794      	b.n	22 <CompareSuites.isra.0+0x22>

Disassembly of section .text.IsTLS:

00000000 <IsTLS>:
    if (ssl->version.major == SSLv3_MAJOR && ssl->version.minor >=TLSv1_MINOR)
   0:	f890 313c 	ldrb.w	r3, [r0, #316]	; 0x13c
   4:	2b03      	cmp	r3, #3
   6:	d105      	bne.n	14 <IsTLS+0x14>
   8:	f890 013d 	ldrb.w	r0, [r0, #317]	; 0x13d
   c:	3800      	subs	r0, #0
   e:	bf18      	it	ne
  10:	2001      	movne	r0, #1
  12:	4770      	bx	lr
    return 0;
  14:	2000      	movs	r0, #0
}
  16:	4770      	bx	lr

Disassembly of section .text.IsAtLeastTLSv1_2:

00000000 <IsAtLeastTLSv1_2>:
    if (ssl->version.major == SSLv3_MAJOR && ssl->version.minor >=TLSv1_2_MINOR)
   0:	f890 313c 	ldrb.w	r3, [r0, #316]	; 0x13c
   4:	2b03      	cmp	r3, #3
   6:	d106      	bne.n	16 <IsAtLeastTLSv1_2+0x16>
   8:	f890 013d 	ldrb.w	r0, [r0, #317]	; 0x13d
   c:	2802      	cmp	r0, #2
   e:	bf94      	ite	ls
  10:	2000      	movls	r0, #0
  12:	2001      	movhi	r0, #1
  14:	4770      	bx	lr
    return 0;
  16:	2000      	movs	r0, #0
}
  18:	4770      	bx	lr

Disassembly of section .text.IsAtLeastTLSv1_3:

00000000 <IsAtLeastTLSv1_3>:
{
   0:	b082      	sub	sp, #8
   2:	f8ad 0004 	strh.w	r0, [sp, #4]
    ret = (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR);
   6:	b2c0      	uxtb	r0, r0
   8:	2803      	cmp	r0, #3
   a:	d107      	bne.n	1c <IsAtLeastTLSv1_3+0x1c>
   c:	f89d 0005 	ldrb.w	r0, [sp, #5]
  10:	2803      	cmp	r0, #3
  12:	bf94      	ite	ls
  14:	2000      	movls	r0, #0
  16:	2001      	movhi	r0, #1
}
  18:	b002      	add	sp, #8
  1a:	4770      	bx	lr
    ret = (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR);
  1c:	2000      	movs	r0, #0
    return ret;
  1e:	e7fb      	b.n	18 <IsAtLeastTLSv1_3+0x18>

Disassembly of section .text.IsEncryptionOn:

00000000 <IsEncryptionOn>:
{
   0:	4603      	mov	r3, r0
    return ssl->keys.encryptionOn &&
   2:	f890 0268 	ldrb.w	r0, [r0, #616]	; 0x268
   6:	b128      	cbz	r0, 14 <IsEncryptionOn+0x14>
   8:	b129      	cbz	r1, 16 <IsEncryptionOn+0x16>
   a:	f893 0061 	ldrb.w	r0, [r3, #97]	; 0x61
   e:	3800      	subs	r0, #0
  10:	bf18      	it	ne
  12:	2001      	movne	r0, #1
}
  14:	4770      	bx	lr
    return ssl->keys.encryptionOn &&
  16:	f893 0075 	ldrb.w	r0, [r3, #117]	; 0x75
  1a:	e7f8      	b.n	e <IsEncryptionOn+0xe>

Disassembly of section .text.InitSSL_Method:

00000000 <InitSSL_Method>:
{
   0:	b082      	sub	sp, #8
   2:	f8ad 1004 	strh.w	r1, [sp, #4]
    method->version    = pv;
   6:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   a:	8003      	strh	r3, [r0, #0]
    method->side       = WOLFSSL_CLIENT_END;
   c:	2301      	movs	r3, #1
   e:	7083      	strb	r3, [r0, #2]
    method->downgrade  = 0;
  10:	2300      	movs	r3, #0
  12:	70c3      	strb	r3, [r0, #3]
}
  14:	b002      	add	sp, #8
  16:	4770      	bx	lr

Disassembly of section .text.InitSSL_Ctx:

00000000 <InitSSL_Ctx>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	460e      	mov	r6, r1
   6:	4615      	mov	r5, r2
    XMEMSET(ctx, 0, sizeof(WOLFSSL_CTX));
   8:	2100      	movs	r1, #0
   a:	226c      	movs	r2, #108	; 0x6c
   c:	f7ff fffe 	bl	0 <memset>
    if (heap == NULL) {
  10:	2d00      	cmp	r5, #0
  12:	bf14      	ite	ne
  14:	462b      	movne	r3, r5
  16:	4623      	moveq	r3, r4
  18:	6323      	str	r3, [r4, #48]	; 0x30
    ctx->timeout  = WOLFSSL_SESSION_TIMEOUT;
  1a:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
  1e:	6523      	str	r3, [r4, #80]	; 0x50
        ctx->minDowngrade = WOLFSSL_MIN_DOWNGRADE;
  20:	2303      	movs	r3, #3
  22:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
    wolfSSL_RefInit(&ctx->ref, &ret);
  26:	2301      	movs	r3, #1
  28:	60a3      	str	r3, [r4, #8]
    ctx->privateKeyDevId = INVALID_DEVID;
  2a:	f06f 0301 	mvn.w	r3, #1
  2e:	6263      	str	r3, [r4, #36]	; 0x24
    ctx->minEccKeySz  = MIN_ECCKEY_SZ;
  30:	231c      	movs	r3, #28
  32:	8763      	strh	r3, [r4, #58]	; 0x3a
    ctx->eccTempKeySz = ECDHE_SIZE;
  34:	2320      	movs	r3, #32
  36:	f8a4 3058 	strh.w	r3, [r4, #88]	; 0x58
    ctx->verifyDepth = MAX_CHAIN_DEPTH;
  3a:	2309      	movs	r3, #9
    ctx->method   = method;
  3c:	6026      	str	r6, [r4, #0]
    ctx->verifyDepth = MAX_CHAIN_DEPTH;
  3e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    if (method->side == WOLFSSL_CLIENT_END) {
  42:	78b3      	ldrb	r3, [r6, #2]
  44:	2b01      	cmp	r3, #1
        ctx->haveECC  = 1;             /* server turns on with ECC key cert */
  46:	bf01      	itttt	eq
  48:	f894 3036 	ldrbeq.w	r3, [r4, #54]	; 0x36
  4c:	f023 034a 	biceq.w	r3, r3, #74	; 0x4a
  50:	f043 034a 	orreq.w	r3, r3, #74	; 0x4a
  54:	f884 3036 	strbeq.w	r3, [r4, #54]	; 0x36
    ctx->devId = INVALID_DEVID;
  58:	f06f 0301 	mvn.w	r3, #1
  5c:	6623      	str	r3, [r4, #96]	; 0x60
    ctx->cm = wolfSSL_CertManagerNew_ex(heap);
  5e:	4628      	mov	r0, r5
  60:	f7ff fffe 	bl	0 <wolfSSL_CertManagerNew_ex>
  64:	62a0      	str	r0, [r4, #40]	; 0x28
    if (ctx->cm == NULL) {
  66:	b110      	cbz	r0, 6e <InitSSL_Ctx+0x6e>
    ctx->heap = heap; /* wolfSSL_CTX_load_static_memory sets */
  68:	6325      	str	r5, [r4, #48]	; 0x30
    return ret;
  6a:	2000      	movs	r0, #0
}
  6c:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_CERT_MANAGER_ERROR;
  6e:	f46f 70b3 	mvn.w	r0, #358	; 0x166
  72:	e7fb      	b.n	6c <InitSSL_Ctx+0x6c>

Disassembly of section .text.SSL_CtxResourceFree:

00000000 <SSL_CtxResourceFree>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
    XFREE(ctx->method, heapAtCTXInit, DYNAMIC_TYPE_METHOD);
   4:	6800      	ldr	r0, [r0, #0]
   6:	b108      	cbz	r0, c <SSL_CtxResourceFree+0xc>
   8:	f7ff fffe 	bl	0 <free>
    if (ctx->suites) {
   c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
    ctx->method = NULL;
   e:	2500      	movs	r5, #0
  10:	6025      	str	r5, [r4, #0]
    if (ctx->suites) {
  12:	b110      	cbz	r0, 1a <SSL_CtxResourceFree+0x1a>
        XFREE(ctx->suites, ctx->heap, DYNAMIC_TYPE_SUITES);
  14:	f7ff fffe 	bl	0 <free>
        ctx->suites = NULL;
  18:	62e5      	str	r5, [r4, #44]	; 0x2c
    if (ctx->rng) {
  1a:	6860      	ldr	r0, [r4, #4]
  1c:	b138      	cbz	r0, 2e <SSL_CtxResourceFree+0x2e>
        wc_FreeRng(ctx->rng);
  1e:	f7ff fffe 	bl	0 <wc_FreeRng>
        XFREE(ctx->rng, ctx->heap, DYNAMIC_TYPE_RNG);
  22:	6860      	ldr	r0, [r4, #4]
  24:	b108      	cbz	r0, 2a <SSL_CtxResourceFree+0x2a>
  26:	f7ff fffe 	bl	0 <free>
        ctx->rng = NULL;
  2a:	2300      	movs	r3, #0
  2c:	6063      	str	r3, [r4, #4]
    if (ctx->privateKey != NULL && ctx->privateKey->buffer != NULL) {
  2e:	69a3      	ldr	r3, [r4, #24]
  30:	b123      	cbz	r3, 3c <SSL_CtxResourceFree+0x3c>
  32:	6818      	ldr	r0, [r3, #0]
  34:	b110      	cbz	r0, 3c <SSL_CtxResourceFree+0x3c>
        ForceZero(ctx->privateKey->buffer, ctx->privateKey->length);
  36:	6899      	ldr	r1, [r3, #8]
  38:	f7ff fffe 	bl	0 <SSL_CtxResourceFree>
    FreeDer(&ctx->privateKey);
  3c:	f104 0018 	add.w	r0, r4, #24
  40:	f7ff fffe 	bl	0 <FreeDer>
    FreeDer(&ctx->certificate);
  44:	f104 0010 	add.w	r0, r4, #16
  48:	f7ff fffe 	bl	0 <FreeDer>
    FreeDer(&ctx->certChain);
  4c:	f104 0014 	add.w	r0, r4, #20
  50:	f7ff fffe 	bl	0 <FreeDer>
    wolfSSL_CertManagerFree(ctx->cm);
  54:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  56:	f7ff fffe 	bl	0 <wolfSSL_CertManagerFree>
    ctx->cm = NULL;
  5a:	2300      	movs	r3, #0
    TLSX_FreeAll(ctx->extensions, ctx->heap);
  5c:	6b21      	ldr	r1, [r4, #48]	; 0x30
  5e:	6e60      	ldr	r0, [r4, #100]	; 0x64
    ctx->cm = NULL;
  60:	62a3      	str	r3, [r4, #40]	; 0x28
}
  62:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    TLSX_FreeAll(ctx->extensions, ctx->heap);
  66:	f7ff bffe 	b.w	0 <TLSX_FreeAll>

Disassembly of section .text.FreeSSL_Ctx:

00000000 <FreeSSL_Ctx>:
    wolfSSL_RefDec(&ctx->ref, &isZero, &ret);
   0:	6883      	ldr	r3, [r0, #8]
   2:	3b01      	subs	r3, #1
{
   4:	b510      	push	{r4, lr}
   6:	4604      	mov	r4, r0
    wolfSSL_RefDec(&ctx->ref, &isZero, &ret);
   8:	6083      	str	r3, [r0, #8]
    if (isZero) {
   a:	b933      	cbnz	r3, 1a <FreeSSL_Ctx+0x1a>
        SSL_CtxResourceFree(ctx);
   c:	f7ff fffe 	bl	0 <FreeSSL_Ctx>
        XFREE(ctx, heap, DYNAMIC_TYPE_CTX);
  10:	4620      	mov	r0, r4
}
  12:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        XFREE(ctx, heap, DYNAMIC_TYPE_CTX);
  16:	f7ff bffe 	b.w	0 <free>
}
  1a:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitCiphers:

00000000 <InitCiphers>:
    ssl->encrypt.des3 = NULL;
   0:	2300      	movs	r3, #0
   2:	6503      	str	r3, [r0, #80]	; 0x50
    ssl->decrypt.des3 = NULL;
   4:	6643      	str	r3, [r0, #100]	; 0x64
    ssl->encrypt.aes = NULL;
   6:	6543      	str	r3, [r0, #84]	; 0x54
    ssl->decrypt.aes = NULL;
   8:	6683      	str	r3, [r0, #104]	; 0x68
    ssl->encrypt.setup = 0;
   a:	f880 3061 	strb.w	r3, [r0, #97]	; 0x61
    ssl->decrypt.setup = 0;
   e:	f880 3075 	strb.w	r3, [r0, #117]	; 0x75
}
  12:	4770      	bx	lr

Disassembly of section .text.FreeCiphers:

00000000 <FreeCiphers>:
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
    wc_Des3Free(ssl->encrypt.des3);
   4:	6d00      	ldr	r0, [r0, #80]	; 0x50
   6:	f7ff fffe 	bl	0 <wc_Des3Free>
    wc_Des3Free(ssl->decrypt.des3);
   a:	6e60      	ldr	r0, [r4, #100]	; 0x64
   c:	f7ff fffe 	bl	0 <wc_Des3Free>
    XFREE(ssl->encrypt.des3, ssl->heap, DYNAMIC_TYPE_CIPHER);
  10:	6d20      	ldr	r0, [r4, #80]	; 0x50
  12:	b108      	cbz	r0, 18 <FreeCiphers+0x18>
  14:	f7ff fffe 	bl	0 <free>
    XFREE(ssl->decrypt.des3, ssl->heap, DYNAMIC_TYPE_CIPHER);
  18:	6e60      	ldr	r0, [r4, #100]	; 0x64
  1a:	b108      	cbz	r0, 20 <FreeCiphers+0x20>
  1c:	f7ff fffe 	bl	0 <free>
    wc_AesFree(ssl->encrypt.aes);
  20:	6d60      	ldr	r0, [r4, #84]	; 0x54
  22:	f7ff fffe 	bl	0 <wc_AesFree>
    wc_AesFree(ssl->decrypt.aes);
  26:	6ea0      	ldr	r0, [r4, #104]	; 0x68
  28:	f7ff fffe 	bl	0 <wc_AesFree>
    XFREE(ssl->encrypt.aes, ssl->heap, DYNAMIC_TYPE_CIPHER);
  2c:	6d60      	ldr	r0, [r4, #84]	; 0x54
  2e:	b108      	cbz	r0, 34 <FreeCiphers+0x34>
  30:	f7ff fffe 	bl	0 <free>
    XFREE(ssl->decrypt.aes, ssl->heap, DYNAMIC_TYPE_CIPHER);
  34:	6ea0      	ldr	r0, [r4, #104]	; 0x68
  36:	b108      	cbz	r0, 3c <FreeCiphers+0x3c>
  38:	f7ff fffe 	bl	0 <free>
    XFREE(ssl->decrypt.additional, ssl->heap, DYNAMIC_TYPE_CIPHER);
  3c:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
  3e:	b108      	cbz	r0, 44 <FreeCiphers+0x44>
  40:	f7ff fffe 	bl	0 <free>
    XFREE(ssl->encrypt.additional, ssl->heap, DYNAMIC_TYPE_CIPHER);
  44:	6da0      	ldr	r0, [r4, #88]	; 0x58
  46:	b108      	cbz	r0, 4c <FreeCiphers+0x4c>
  48:	f7ff fffe 	bl	0 <free>
    XFREE(ssl->decrypt.nonce, ssl->heap, DYNAMIC_TYPE_CIPHER);
  4c:	6f20      	ldr	r0, [r4, #112]	; 0x70
  4e:	b108      	cbz	r0, 54 <FreeCiphers+0x54>
  50:	f7ff fffe 	bl	0 <free>
    XFREE(ssl->encrypt.nonce, ssl->heap, DYNAMIC_TYPE_CIPHER);
  54:	6de0      	ldr	r0, [r4, #92]	; 0x5c
  56:	b118      	cbz	r0, 60 <FreeCiphers+0x60>
}
  58:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    XFREE(ssl->encrypt.nonce, ssl->heap, DYNAMIC_TYPE_CIPHER);
  5c:	f7ff bffe 	b.w	0 <free>
}
  60:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitCipherSpecs:

00000000 <InitCipherSpecs>:
{
   0:	b510      	push	{r4, lr}
    XMEMSET(cs, 0, sizeof(CipherSpecs));
   2:	2210      	movs	r2, #16
{
   4:	4604      	mov	r4, r0
    XMEMSET(cs, 0, sizeof(CipherSpecs));
   6:	2100      	movs	r1, #0
   8:	f7ff fffe 	bl	0 <memset>
    cs->bulk_cipher_algorithm = INVALID_BYTE;
   c:	f64f 73ff 	movw	r3, #65535	; 0xffff
  10:	8123      	strh	r3, [r4, #8]
    cs->mac_algorithm         = INVALID_BYTE;
  12:	8163      	strh	r3, [r4, #10]
    cs->sig_algo              = INVALID_BYTE;
  14:	7323      	strb	r3, [r4, #12]
}
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitSuitesHashSigAlgo_ex2:

00000000 <InitSuitesHashSigAlgo_ex2>:
    if (haveSig & SIG_ECDSA) {
   0:	f011 0301 	ands.w	r3, r1, #1
{
   4:	b510      	push	{r4, lr}
    if (haveSig & SIG_ECDSA) {
   6:	d00b      	beq.n	20 <InitSuitesHashSigAlgo_ex2+0x20>
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
   8:	2306      	movs	r3, #6
   a:	b148      	cbz	r0, 20 <InitSuitesHashSigAlgo_ex2+0x20>
   c:	2203      	movs	r2, #3
   e:	7042      	strb	r2, [r0, #1]
  10:	70c2      	strb	r2, [r0, #3]
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx,
  12:	2208      	movs	r2, #8
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
  14:	2404      	movs	r4, #4
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx,
  16:	7102      	strb	r2, [r0, #4]
  18:	2207      	movs	r2, #7
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
  1a:	7003      	strb	r3, [r0, #0]
  1c:	7084      	strb	r4, [r0, #2]
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx,
  1e:	7142      	strb	r2, [r0, #5]
    if (haveSig & SIG_RSA) {
  20:	078a      	lsls	r2, r1, #30
  22:	d50f      	bpl.n	44 <InitSuitesHashSigAlgo_ex2+0x44>
            ADD_HASH_SIG_ALGO(hashSigAlgo, inOutIdx, macAlgo, sigAlgo);
  24:	b160      	cbz	r0, 40 <InitSuitesHashSigAlgo_ex2+0x40>
  26:	2206      	movs	r2, #6
  28:	54c2      	strb	r2, [r0, r3]
  2a:	1c5a      	adds	r2, r3, #1
  2c:	b292      	uxth	r2, r2
  2e:	2101      	movs	r1, #1
  30:	5481      	strb	r1, [r0, r2]
  32:	1c9a      	adds	r2, r3, #2
  34:	b292      	uxth	r2, r2
  36:	2404      	movs	r4, #4
  38:	5484      	strb	r4, [r0, r2]
  3a:	1cda      	adds	r2, r3, #3
  3c:	b292      	uxth	r2, r2
  3e:	5481      	strb	r1, [r0, r2]
  40:	3304      	adds	r3, #4
  42:	b29b      	uxth	r3, r3
    *len = idx;
  44:	9a02      	ldr	r2, [sp, #8]
  46:	8013      	strh	r3, [r2, #0]
}
  48:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitSuitesHashSigAlgo_ex:

00000000 <InitSuitesHashSigAlgo_ex>:
{
   0:	b4f0      	push	{r4, r5, r6, r7}
   2:	4694      	mov	ip, r2
    if (haveECDSAsig)     have |= SIG_ECDSA;
   4:	3900      	subs	r1, #0
{
   6:	461c      	mov	r4, r3
   8:	e9dd 7604 	ldrd	r7, r6, [sp, #16]
   c:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  10:	9d08      	ldr	r5, [sp, #32]
    if (haveECDSAsig)     have |= SIG_ECDSA;
  12:	bf18      	it	ne
  14:	2101      	movne	r1, #1
    if (haveRSAsig)       have |= SIG_RSA;
  16:	f1bc 0f00 	cmp.w	ip, #0
  1a:	d001      	beq.n	20 <InitSuitesHashSigAlgo_ex+0x20>
  1c:	f041 0102 	orr.w	r1, r1, #2
    if (haveFalconSig)    have |= SIG_FALCON;
  20:	b10c      	cbz	r4, 26 <InitSuitesHashSigAlgo_ex+0x26>
  22:	f041 0108 	orr.w	r1, r1, #8
    if (haveDilithiumSig) have |= SIG_DILITHIUM;
  26:	b10f      	cbz	r7, 2c <InitSuitesHashSigAlgo_ex+0x2c>
  28:	f041 0110 	orr.w	r1, r1, #16
    if (haveAnon)         have |= SIG_ANON;
  2c:	b10e      	cbz	r6, 32 <InitSuitesHashSigAlgo_ex+0x32>
  2e:	f041 0120 	orr.w	r1, r1, #32
    InitSuitesHashSigAlgo_ex2(hashSigAlgo, have, tls1_2, keySz, len);
  32:	9504      	str	r5, [sp, #16]
}
  34:	bcf0      	pop	{r4, r5, r6, r7}
    InitSuitesHashSigAlgo_ex2(hashSigAlgo, have, tls1_2, keySz, len);
  36:	f7ff bffe 	b.w	0 <InitSuitesHashSigAlgo_ex>

Disassembly of section .text.InitSuitesHashSigAlgo:

00000000 <InitSuitesHashSigAlgo>:
{
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
    InitSuitesHashSigAlgo_ex(suites->hashSigAlgo, haveECDSAsig, haveRSAsig,
   4:	1c84      	adds	r4, r0, #2
   6:	9404      	str	r4, [sp, #16]
   8:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   a:	9403      	str	r4, [sp, #12]
   c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   e:	9402      	str	r4, [sp, #8]
  10:	9c09      	ldr	r4, [sp, #36]	; 0x24
  12:	9401      	str	r4, [sp, #4]
  14:	9c08      	ldr	r4, [sp, #32]
  16:	9400      	str	r4, [sp, #0]
  18:	f500 7098 	add.w	r0, r0, #304	; 0x130
  1c:	f7ff fffe 	bl	0 <InitSuitesHashSigAlgo>
}
  20:	b006      	add	sp, #24
  22:	bd10      	pop	{r4, pc}

Disassembly of section .text.AllocateCtxSuites:

00000000 <AllocateCtxSuites>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (ctx->suites == NULL) {
   2:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
{
   4:	4605      	mov	r5, r0
    if (ctx->suites == NULL) {
   6:	b954      	cbnz	r4, 1e <AllocateCtxSuites+0x1e>
        ctx->suites = (Suites*)XMALLOC(sizeof(Suites), ctx->heap,
   8:	f44f 70ac 	mov.w	r0, #344	; 0x158
   c:	f7ff fffe 	bl	0 <malloc>
  10:	62e8      	str	r0, [r5, #44]	; 0x2c
        if (ctx->suites == NULL) {
  12:	b130      	cbz	r0, 22 <AllocateCtxSuites+0x22>
        XMEMSET(ctx->suites, 0, sizeof(Suites));
  14:	f44f 72ac 	mov.w	r2, #344	; 0x158
  18:	4621      	mov	r1, r4
  1a:	f7ff fffe 	bl	0 <memset>
    return 0;
  1e:	2000      	movs	r0, #0
}
  20:	bd38      	pop	{r3, r4, r5, pc}
            return MEMORY_ERROR;
  22:	f46f 7097 	mvn.w	r0, #302	; 0x12e
  26:	e7fb      	b.n	20 <AllocateCtxSuites+0x20>

Disassembly of section .text.AllocateSuites:

00000000 <AllocateSuites>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (ssl->suites == NULL) {
   2:	6844      	ldr	r4, [r0, #4]
{
   4:	4605      	mov	r5, r0
    if (ssl->suites == NULL) {
   6:	b974      	cbnz	r4, 26 <AllocateSuites+0x26>
        ssl->suites = (Suites*)XMALLOC(sizeof(Suites), ssl->heap,
   8:	f44f 70ac 	mov.w	r0, #344	; 0x158
   c:	f7ff fffe 	bl	0 <malloc>
  10:	4603      	mov	r3, r0
  12:	6068      	str	r0, [r5, #4]
        if (ssl->suites == NULL) {
  14:	b180      	cbz	r0, 38 <AllocateSuites+0x38>
        if (ssl->ctx != NULL && ssl->ctx->suites != NULL)
  16:	682a      	ldr	r2, [r5, #0]
  18:	b13a      	cbz	r2, 2a <AllocateSuites+0x2a>
  1a:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  1c:	b129      	cbz	r1, 2a <AllocateSuites+0x2a>
            XMEMCPY(ssl->suites, ssl->ctx->suites, sizeof(Suites));
  1e:	f44f 72ac 	mov.w	r2, #344	; 0x158
  22:	f7ff fffe 	bl	0 <memcpy>
    return 0;
  26:	2000      	movs	r0, #0
}
  28:	bd38      	pop	{r3, r4, r5, pc}
            XMEMSET(ssl->suites, 0, sizeof(Suites));
  2a:	f44f 72ac 	mov.w	r2, #344	; 0x158
  2e:	2100      	movs	r1, #0
  30:	4618      	mov	r0, r3
  32:	f7ff fffe 	bl	0 <memset>
  36:	e7f6      	b.n	26 <AllocateSuites+0x26>
            return MEMORY_ERROR;
  38:	f46f 7097 	mvn.w	r0, #302	; 0x12e
  3c:	e7f4      	b.n	28 <AllocateSuites+0x28>

Disassembly of section .text.InitSuites:

00000000 <InitSuites>:
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4617      	mov	r7, r2
   6:	f8ad 1004 	strh.w	r1, [sp, #4]
   a:	f3c1 2207 	ubfx	r2, r1, #8, #8
    int    tls    = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_MINOR;
   e:	b2c9      	uxtb	r1, r1
  10:	2903      	cmp	r1, #3
{
  12:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30
  16:	f8bd 6034 	ldrh.w	r6, [sp, #52]	; 0x34
  1a:	f8bd e040 	ldrh.w	lr, [sp, #64]	; 0x40
  1e:	f8bd c044 	ldrh.w	ip, [sp, #68]	; 0x44
    int    tls    = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_MINOR;
  22:	d140      	bne.n	a6 <InitSuites+0xa6>
  24:	1e14      	subs	r4, r2, #0
  26:	bf18      	it	ne
  28:	2401      	movne	r4, #1
    int    tls1_2 = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_2_MINOR;
  2a:	2a02      	cmp	r2, #2
  2c:	bf94      	ite	ls
  2e:	2200      	movls	r2, #0
  30:	2201      	movhi	r2, #1
    if (suites == NULL) {
  32:	2800      	cmp	r0, #0
  34:	d05d      	beq.n	f2 <InitSuites+0xf2>
    if (suites->setSuites)
  36:	f890 1156 	ldrb.w	r1, [r0, #342]	; 0x156
  3a:	2900      	cmp	r1, #0
  3c:	d159      	bne.n	f2 <InitSuites+0xf2>
    if (tls1_2 && haveECC) {
  3e:	2a00      	cmp	r2, #0
  40:	d053      	beq.n	ea <InitSuites+0xea>
  42:	2e00      	cmp	r6, #0
  44:	d04f      	beq.n	e6 <InitSuites+0xe6>
        suites->suites[idx++] = ECC_BYTE;
  46:	f44f 512f 	mov.w	r1, #11200	; 0x2bc0
  4a:	8081      	strh	r1, [r0, #4]
        suites->suites[idx++] = ECC_BYTE;
  4c:	f44f 510f 	mov.w	r1, #9152	; 0x23c0
  50:	80c1      	strh	r1, [r0, #6]
    if (tls && haveECC) {
  52:	2c00      	cmp	r4, #0
  54:	d145      	bne.n	e2 <InitSuites+0xe2>
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
  56:	2504      	movs	r5, #4
    if (suites->hashSigAlgoSz == 0) {
  58:	8841      	ldrh	r1, [r0, #2]
    suites->suiteSz = idx;
  5a:	8005      	strh	r5, [r0, #0]
    if (suites->hashSigAlgoSz == 0) {
  5c:	2900      	cmp	r1, #0
  5e:	d148      	bne.n	f2 <InitSuites+0xf2>
        haveSig |= (haveRSAsig | haveRSA) ? SIG_RSA : 0;
  60:	2b00      	cmp	r3, #0
  62:	bf14      	ite	ne
  64:	2102      	movne	r1, #2
  66:	2100      	moveq	r1, #0
        haveSig |= (haveECDSAsig | haveECC) ? SIG_ECDSA : 0;
  68:	ea56 0308 	orrs.w	r3, r6, r8
  6c:	bf0c      	ite	eq
  6e:	460b      	moveq	r3, r1
  70:	f041 0301 	orrne.w	r3, r1, #1
        haveSig |= haveFalconSig ? SIG_FALCON : 0;
  74:	f1be 0f00 	cmp.w	lr, #0
  78:	bf14      	ite	ne
  7a:	2108      	movne	r1, #8
  7c:	2100      	moveq	r1, #0
        haveSig |= haveDilithiumSig ? SIG_DILITHIUM : 0;
  7e:	f1bc 0f00 	cmp.w	ip, #0
        haveSig |= haveFalconSig ? SIG_FALCON : 0;
  82:	ea41 0103 	orr.w	r1, r1, r3
        haveSig |= haveDilithiumSig ? SIG_DILITHIUM : 0;
  86:	bf18      	it	ne
  88:	2410      	movne	r4, #16
        InitSuitesHashSigAlgo_ex2(suites->hashSigAlgo, haveSig, tls1_2, keySz,
  8a:	f100 0302 	add.w	r3, r0, #2
        haveSig |= haveDilithiumSig ? SIG_DILITHIUM : 0;
  8e:	bf08      	it	eq
  90:	2400      	moveq	r4, #0
        InitSuitesHashSigAlgo_ex2(suites->hashSigAlgo, haveSig, tls1_2, keySz,
  92:	930a      	str	r3, [sp, #40]	; 0x28
  94:	4321      	orrs	r1, r4
  96:	463b      	mov	r3, r7
  98:	f500 7098 	add.w	r0, r0, #304	; 0x130
}
  9c:	b002      	add	sp, #8
  9e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        InitSuitesHashSigAlgo_ex2(suites->hashSigAlgo, haveSig, tls1_2, keySz,
  a2:	f7ff bffe 	b.w	0 <InitSuites>
    int    tls    = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_MINOR;
  a6:	2400      	movs	r4, #0
    int    tls1_2 = pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_2_MINOR;
  a8:	4622      	mov	r2, r4
  aa:	e7c2      	b.n	32 <InitSuites+0x32>
    if (tls && haveECC) {
  ac:	b1de      	cbz	r6, e6 <InitSuites+0xe6>
    word16 idx = 0;
  ae:	4614      	mov	r4, r2
        suites->suites[idx++] = ECC_BYTE;
  b0:	1905      	adds	r5, r0, r4
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
  b2:	eb00 0904 	add.w	r9, r0, r4
        suites->suites[idx++] = ECC_BYTE;
  b6:	21c0      	movs	r1, #192	; 0xc0
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
  b8:	f04f 0a0a 	mov.w	sl, #10
        suites->suites[idx++] = ECC_BYTE;
  bc:	7129      	strb	r1, [r5, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
  be:	1ca5      	adds	r5, r4, #2
  c0:	f889 a005 	strb.w	sl, [r9, #5]
    if (tls && haveECC) {
  c4:	2e00      	cmp	r6, #0
  c6:	d0c7      	beq.n	58 <InitSuites+0x58>
        suites->suites[idx++] = ECC_BYTE;
  c8:	4405      	add	r5, r0
  ca:	7129      	strb	r1, [r5, #4]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
  cc:	464d      	mov	r5, r9
  ce:	f04f 0909 	mov.w	r9, #9
        suites->suites[idx++] = ECC_BYTE;
  d2:	7229      	strb	r1, [r5, #8]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
  d4:	f885 9007 	strb.w	r9, [r5, #7]
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
  d8:	1da5      	adds	r5, r4, #6
  da:	4404      	add	r4, r0
  dc:	2108      	movs	r1, #8
  de:	7261      	strb	r1, [r4, #9]
  e0:	e7ba      	b.n	58 <InitSuites+0x58>
        suites->suites[idx++] = TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
  e2:	2404      	movs	r4, #4
  e4:	e7e4      	b.n	b0 <InitSuites+0xb0>
    word16 idx = 0;
  e6:	4635      	mov	r5, r6
  e8:	e7b6      	b.n	58 <InitSuites+0x58>
    if (tls && haveECC) {
  ea:	2c00      	cmp	r4, #0
  ec:	d1de      	bne.n	ac <InitSuites+0xac>
    word16 idx = 0;
  ee:	4615      	mov	r5, r2
  f0:	e7b2      	b.n	58 <InitSuites+0x58>
}
  f2:	b002      	add	sp, #8
  f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

Disassembly of section .text.InitSuites_EitherSide.constprop.0:

00000000 <InitSuites_EitherSide.constprop.0>:
static void InitSuites_EitherSide(Suites* suites, ProtocolVersion pv, int keySz,
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b08e      	sub	sp, #56	; 0x38
   6:	461c      	mov	r4, r3
   8:	f8bd 6054 	ldrh.w	r6, [sp, #84]	; 0x54
   c:	f8bd 7058 	ldrh.w	r7, [sp, #88]	; 0x58
  10:	f8bd c05c 	ldrh.w	ip, [sp, #92]	; 0x5c
  14:	f8bd e060 	ldrh.w	lr, [sp, #96]	; 0x60
  18:	f8bd 8064 	ldrh.w	r8, [sp, #100]	; 0x64
  1c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  1e:	f8bd 5050 	ldrh.w	r5, [sp, #80]	; 0x50
  22:	f8ad 1034 	strh.w	r1, [sp, #52]	; 0x34
  26:	2101      	movs	r1, #1
        InitSuites(suites, pv, keySz, haveRSA, havePSK, haveDH, haveECDSAsig,
  28:	e9cd 1309 	strd	r1, r3, [sp, #36]	; 0x24
  2c:	e9cd e807 	strd	lr, r8, [sp, #28]
  30:	e9cd 7c05 	strd	r7, ip, [sp, #20]
  34:	e9cd 6103 	strd	r6, r1, [sp, #12]
  38:	9502      	str	r5, [sp, #8]
    if (side == WOLFSSL_SERVER_END) {
  3a:	b93b      	cbnz	r3, 4c <InitSuites_EitherSide.constprop.0+0x4c>
        InitSuites(suites, pv, keySz, haveRSA, havePSK, haveDH, haveECDSAsig,
  3c:	9401      	str	r4, [sp, #4]
        InitSuites(suites, pv, keySz, haveRSA, havePSK, TRUE, haveECDSAsig,
  3e:	990d      	ldr	r1, [sp, #52]	; 0x34
  40:	9300      	str	r3, [sp, #0]
  42:	f7ff fffe 	bl	0 <InitSuites_EitherSide.constprop.0>
}
  46:	b00e      	add	sp, #56	; 0x38
  48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        InitSuites(suites, pv, keySz, haveRSA, havePSK, TRUE, haveECDSAsig,
  4c:	9101      	str	r1, [sp, #4]
  4e:	2300      	movs	r3, #0
  50:	e7f5      	b.n	3e <InitSuites_EitherSide.constprop.0+0x3e>

Disassembly of section .text.InitX509Name:

00000000 <InitX509Name>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4615      	mov	r5, r2
    if (name != NULL) {
   4:	4604      	mov	r4, r0
   6:	b158      	cbz	r0, 20 <InitX509Name+0x20>
        XMEMSET(name, 0, sizeof(WOLFSSL_X509_NAME));
   8:	f44f 7288 	mov.w	r2, #272	; 0x110
   c:	2100      	movs	r1, #0
   e:	f7ff fffe 	bl	0 <memset>
        name->name        = name->staticName;
  12:	f104 030c 	add.w	r3, r4, #12
  16:	6023      	str	r3, [r4, #0]
        name->dynamicName = 0;
  18:	2300      	movs	r3, #0
        name->heap = heap;
  1a:	f8c4 510c 	str.w	r5, [r4, #268]	; 0x10c
        name->dynamicName = 0;
  1e:	6063      	str	r3, [r4, #4]
}
  20:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.FreeX509Name:

00000000 <FreeX509Name>:
{
   0:	b510      	push	{r4, lr}
    if (name != NULL) {
   2:	4604      	mov	r4, r0
   4:	b138      	cbz	r0, 16 <FreeX509Name+0x16>
        if (name->dynamicName) {
   6:	6843      	ldr	r3, [r0, #4]
   8:	b12b      	cbz	r3, 16 <FreeX509Name+0x16>
            XFREE(name->name, name->heap, DYNAMIC_TYPE_SUBJECT_CN);
   a:	6800      	ldr	r0, [r0, #0]
   c:	b108      	cbz	r0, 12 <FreeX509Name+0x12>
   e:	f7ff fffe 	bl	0 <free>
            name->name = NULL;
  12:	2300      	movs	r3, #0
  14:	6023      	str	r3, [r4, #0]
}
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitX509:

00000000 <InitX509>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460e      	mov	r6, r1
   4:	4615      	mov	r5, r2
    if (x509 == NULL) {
   6:	4604      	mov	r4, r0
   8:	b1a0      	cbz	r0, 34 <InitX509+0x34>
    XMEMSET(x509, 0, sizeof(WOLFSSL_X509));
   a:	f44f 7272 	mov.w	r2, #968	; 0x3c8
   e:	2100      	movs	r1, #0
  10:	f7ff fffe 	bl	0 <memset>
    InitX509Name(&x509->issuer, 0, heap);
  14:	462a      	mov	r2, r5
  16:	2100      	movs	r1, #0
  18:	f504 70d4 	add.w	r0, r4, #424	; 0x1a8
    x509->heap = heap;
  1c:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    InitX509Name(&x509->issuer, 0, heap);
  20:	f7ff fffe 	bl	0 <InitX509>
    InitX509Name(&x509->subject, 0, heap);
  24:	462a      	mov	r2, r5
  26:	2100      	movs	r1, #0
  28:	f504 702e 	add.w	r0, r4, #696	; 0x2b8
  2c:	f7ff fffe 	bl	0 <InitX509>
    x509->dynamicMemory  = (byte)dynamicFlag;
  30:	f884 6084 	strb.w	r6, [r4, #132]	; 0x84
}
  34:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.FreeX509:

00000000 <FreeX509>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (x509 == NULL)
   2:	4604      	mov	r4, r0
   4:	b1f0      	cbz	r0, 44 <FreeX509+0x44>
    FreeX509Name(&x509->issuer);
   6:	f500 70d4 	add.w	r0, r0, #424	; 0x1a8
   a:	f7ff fffe 	bl	0 <FreeX509>
    FreeX509Name(&x509->subject);
   e:	f504 702e 	add.w	r0, r4, #696	; 0x2b8
  12:	f7ff fffe 	bl	0 <FreeX509>
    if (x509->pubKey.buffer) {
  16:	6ea0      	ldr	r0, [r4, #104]	; 0x68
  18:	b118      	cbz	r0, 22 <FreeX509+0x22>
        XFREE(x509->pubKey.buffer, x509->heap, DYNAMIC_TYPE_PUBLIC_KEY);
  1a:	f7ff fffe 	bl	0 <free>
        x509->pubKey.buffer = NULL;
  1e:	2300      	movs	r3, #0
  20:	66a3      	str	r3, [r4, #104]	; 0x68
    FreeDer(&x509->derCert);
  22:	f104 007c 	add.w	r0, r4, #124	; 0x7c
  26:	f7ff fffe 	bl	0 <FreeDer>
    XFREE(x509->sig.buffer, x509->heap, DYNAMIC_TYPE_SIGNATURE);
  2a:	6da0      	ldr	r0, [r4, #88]	; 0x58
  2c:	b108      	cbz	r0, 32 <FreeX509+0x32>
  2e:	f7ff fffe 	bl	0 <free>
    if (x509->altNames) {
  32:	6e60      	ldr	r0, [r4, #100]	; 0x64
    x509->sig.buffer = NULL;
  34:	2500      	movs	r5, #0
  36:	65a5      	str	r5, [r4, #88]	; 0x58
    if (x509->altNames) {
  38:	b120      	cbz	r0, 44 <FreeX509+0x44>
        FreeAltNames(x509->altNames, x509->heap);
  3a:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
  3e:	f7ff fffe 	bl	0 <FreeAltNames>
        x509->altNames = NULL;
  42:	6665      	str	r5, [r4, #100]	; 0x64
}
  44:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.EccSign:

00000000 <EccSign>:
{
   0:	b410      	push	{r4}
   2:	4604      	mov	r4, r0
   4:	4608      	mov	r0, r1
        ret = wc_ecc_sign_hash(in, inSz, out, outSz, ssl->rng, key);
   6:	69a4      	ldr	r4, [r4, #24]
{
   8:	4611      	mov	r1, r2
   a:	461a      	mov	r2, r3
   c:	9b01      	ldr	r3, [sp, #4]
        ret = wc_ecc_sign_hash(in, inSz, out, outSz, ssl->rng, key);
   e:	9401      	str	r4, [sp, #4]
}
  10:	bc10      	pop	{r4}
        ret = wc_ecc_sign_hash(in, inSz, out, outSz, ssl->rng, key);
  12:	f7ff bffe 	b.w	0 <wc_ecc_sign_hash>

Disassembly of section .text.EccVerify:

00000000 <EccVerify>:
{
   0:	b513      	push	{r0, r1, r4, lr}
   2:	4604      	mov	r4, r0
   4:	4608      	mov	r0, r1
   6:	4611      	mov	r1, r2
   8:	461a      	mov	r2, r3
        ret = wc_ecc_verify_hash(in, inSz, out, outSz, &ssl->eccVerifyRes, key);
   a:	9b05      	ldr	r3, [sp, #20]
   c:	9301      	str	r3, [sp, #4]
   e:	f504 7323 	add.w	r3, r4, #652	; 0x28c
  12:	9300      	str	r3, [sp, #0]
  14:	9b04      	ldr	r3, [sp, #16]
  16:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
        if (ret != 0 || ssl->eccVerifyRes == 0) {
  1a:	b928      	cbnz	r0, 28 <EccVerify+0x28>
  1c:	f8d4 228c 	ldr.w	r2, [r4, #652]	; 0x28c
                ret = VERIFY_SIGN_ERROR;
  20:	4b02      	ldr	r3, [pc, #8]	; (2c <EccVerify+0x2c>)
  22:	2a00      	cmp	r2, #0
  24:	bf08      	it	eq
  26:	4618      	moveq	r0, r3
}
  28:	b002      	add	sp, #8
  2a:	bd10      	pop	{r4, pc}
  2c:	fffffeb6 	.word	0xfffffeb6

Disassembly of section .text.EccSharedSecret:

00000000 <EccSharedSecret>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460c      	mov	r4, r1
        ret = wc_ecc_set_rng(priv_key, ssl->rng);
   6:	6981      	ldr	r1, [r0, #24]
   8:	4620      	mov	r0, r4
{
   a:	e9dd 6707 	ldrd	r6, r7, [sp, #28]
   e:	4615      	mov	r5, r2
        ret = wc_ecc_set_rng(priv_key, ssl->rng);
  10:	f7ff fffe 	bl	0 <wc_ecc_set_rng>
        if (ret == 0)
  14:	b938      	cbnz	r0, 26 <EccSharedSecret+0x26>
            ret = wc_ecc_shared_secret(priv_key, pub_key, out, outlen);
  16:	463b      	mov	r3, r7
  18:	4632      	mov	r2, r6
  1a:	4629      	mov	r1, r5
  1c:	4620      	mov	r0, r4
}
  1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            ret = wc_ecc_shared_secret(priv_key, pub_key, out, outlen);
  22:	f7ff bffe 	b.w	0 <wc_ecc_shared_secret>
}
  26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.EccMakeKey:

00000000 <EccMakeKey>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
    if (peer == NULL || peer->dp == NULL) {
   6:	b10a      	cbz	r2, c <EccMakeKey+0xc>
   8:	6913      	ldr	r3, [r2, #16]
   a:	b953      	cbnz	r3, 22 <EccMakeKey+0x22>
        if (ssl->ecdhCurveOID > 0) {
   c:	f8d4 0290 	ldr.w	r0, [r4, #656]	; 0x290
        keySz = ssl->eccTempKeySz;
  10:	f8b4 62a4 	ldrh.w	r6, [r4, #676]	; 0x2a4
        if (ssl->ecdhCurveOID > 0) {
  14:	b118      	cbz	r0, 1e <EccMakeKey+0x1e>
            ecc_curve = wc_ecc_get_oid(ssl->ecdhCurveOID, NULL, NULL);
  16:	2200      	movs	r2, #0
  18:	4611      	mov	r1, r2
  1a:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
    int ecc_curve = ECC_CURVE_DEF;
  1e:	4603      	mov	r3, r0
  20:	e001      	b.n	26 <EccMakeKey+0x26>
        ecc_curve = peer->dp->id;
  22:	e9d3 6300 	ldrd	r6, r3, [r3]
        ret = wc_ecc_make_key_ex(ssl->rng, keySz, key, ecc_curve);
  26:	69a0      	ldr	r0, [r4, #24]
  28:	462a      	mov	r2, r5
  2a:	4631      	mov	r1, r6
  2c:	f7ff fffe 	bl	0 <wc_ecc_make_key_ex>
    if (ret == 0 && key->dp) {
  30:	b920      	cbnz	r0, 3c <EccMakeKey+0x3c>
  32:	692b      	ldr	r3, [r5, #16]
  34:	b113      	cbz	r3, 3c <EccMakeKey+0x3c>
        ssl->ecdhCurveOID = key->dp->oidSum;
  36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  38:	f8c4 3290 	str.w	r3, [r4, #656]	; 0x290
}
  3c:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.Ed25519CheckPubKey:

00000000 <Ed25519CheckPubKey>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    ed25519_key* key = (ed25519_key*)ssl->hsKey;
   2:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
    if (key != NULL && !key->pubKeySet) {
   4:	b19c      	cbz	r4, 2e <Ed25519CheckPubKey+0x2e>
   6:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
   a:	079b      	lsls	r3, r3, #30
   c:	d40f      	bmi.n	2e <Ed25519CheckPubKey+0x2e>
        ret = wc_CertGetPubKey(ssl->buffers.certificate->buffer,
   e:	f8d0 00dc 	ldr.w	r0, [r0, #220]	; 0xdc
  12:	ab01      	add	r3, sp, #4
  14:	6881      	ldr	r1, [r0, #8]
  16:	6800      	ldr	r0, [r0, #0]
  18:	466a      	mov	r2, sp
  1a:	f7ff fffe 	bl	0 <wc_CertGetPubKey>
        if (ret == 0) {
  1e:	b920      	cbnz	r0, 2a <Ed25519CheckPubKey+0x2a>
            ret = wc_ed25519_import_public(pubKey, pubKeySz, key);
  20:	e9dd 0100 	ldrd	r0, r1, [sp]
  24:	4622      	mov	r2, r4
  26:	f7ff fffe 	bl	0 <wc_ed25519_import_public>
}
  2a:	b002      	add	sp, #8
  2c:	bd10      	pop	{r4, pc}
    int ret = 0;
  2e:	2000      	movs	r0, #0
    return ret;
  30:	e7fb      	b.n	2a <Ed25519CheckPubKey+0x2a>

Disassembly of section .text.Ed25519Sign:

00000000 <Ed25519Sign>:
{
   0:	b410      	push	{r4}
   2:	4608      	mov	r0, r1
   4:	4611      	mov	r1, r2
   6:	461a      	mov	r2, r3
        ret = wc_ed25519_sign_msg(in, inSz, out, outSz, key);
   8:	e9dd 3401 	ldrd	r3, r4, [sp, #4]
   c:	9401      	str	r4, [sp, #4]
}
   e:	bc10      	pop	{r4}
        ret = wc_ed25519_sign_msg(in, inSz, out, outSz, key);
  10:	f7ff bffe 	b.w	0 <wc_ed25519_sign_msg>

Disassembly of section .text.Ed25519Verify:

00000000 <Ed25519Verify>:
{
   0:	b513      	push	{r0, r1, r4, lr}
   2:	4604      	mov	r4, r0
   4:	4608      	mov	r0, r1
   6:	4611      	mov	r1, r2
   8:	461a      	mov	r2, r3
        ret = wc_ed25519_verify_msg(in, inSz, msg, msgSz,
   a:	9b05      	ldr	r3, [sp, #20]
   c:	9301      	str	r3, [sp, #4]
   e:	f504 7323 	add.w	r3, r4, #652	; 0x28c
  12:	9300      	str	r3, [sp, #0]
  14:	9b04      	ldr	r3, [sp, #16]
  16:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
        ret = (ret != 0 || ssl->eccVerifyRes == 0) ? VERIFY_SIGN_ERROR : 0;
  1a:	b938      	cbnz	r0, 2c <Ed25519Verify+0x2c>
  1c:	f8d4 228c 	ldr.w	r2, [r4, #652]	; 0x28c
  20:	4b03      	ldr	r3, [pc, #12]	; (30 <Ed25519Verify+0x30>)
  22:	2a00      	cmp	r2, #0
  24:	bf08      	it	eq
  26:	4618      	moveq	r0, r3
}
  28:	b002      	add	sp, #8
  2a:	bd10      	pop	{r4, pc}
        ret = (ret != 0 || ssl->eccVerifyRes == 0) ? VERIFY_SIGN_ERROR : 0;
  2c:	4800      	ldr	r0, [pc, #0]	; (30 <Ed25519Verify+0x30>)
  2e:	e7fb      	b.n	28 <Ed25519Verify+0x28>
  30:	fffffeb6 	.word	0xfffffeb6

Disassembly of section .text.InitSSL_CTX_Suites:

00000000 <InitSSL_CTX_Suites>:
{
   0:	b510      	push	{r4, lr}
    InitSuites_EitherSide(ctx->suites, ctx->method->version, keySz,
   2:	6802      	ldr	r2, [r0, #0]
            haveRSA, havePSK, ctx->haveDH, ctx->haveECDSAsig, ctx->haveECC,
   4:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
    InitSuites_EitherSide(ctx->suites, ctx->method->version, keySz,
   8:	7891      	ldrb	r1, [r2, #2]
{
   a:	b088      	sub	sp, #32
    InitSuites_EitherSide(ctx->suites, ctx->method->version, keySz,
   c:	9106      	str	r1, [sp, #24]
   e:	2100      	movs	r1, #0
  10:	9105      	str	r1, [sp, #20]
  12:	f3c3 1140 	ubfx	r1, r3, #5, #1
  16:	9104      	str	r1, [sp, #16]
  18:	f3c3 1100 	ubfx	r1, r3, #4, #1
  1c:	9103      	str	r1, [sp, #12]
  1e:	f3c3 1180 	ubfx	r1, r3, #6, #1
  22:	9102      	str	r1, [sp, #8]
  24:	f3c3 0140 	ubfx	r1, r3, #1, #1
  28:	9101      	str	r1, [sp, #4]
  2a:	f3c3 01c0 	ubfx	r1, r3, #3, #1
  2e:	9100      	str	r1, [sp, #0]
  30:	7854      	ldrb	r4, [r2, #1]
  32:	7811      	ldrb	r1, [r2, #0]
  34:	6a02      	ldr	r2, [r0, #32]
  36:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  38:	f3c3 0380 	ubfx	r3, r3, #2, #1
  3c:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
  40:	f7ff fffe 	bl	0 <InitSSL_CTX_Suites>
}
  44:	b008      	add	sp, #32
  46:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitSSL_Suites:

00000000 <InitSSL_Suites>:
{
   0:	b510      	push	{r4, lr}
    if (!ssl)
   2:	4604      	mov	r4, r0
{
   4:	b088      	sub	sp, #32
    if (!ssl)
   6:	2800      	cmp	r0, #0
   8:	d04f      	beq.n	aa <InitSSL_Suites+0xaa>
    ssl->options.cacheMessages = ssl->options.side == WOLFSSL_SERVER_END ||
   a:	f890 2270 	ldrb.w	r2, [r0, #624]	; 0x270
                                      ssl->buffers.keyType == ed448_sa_algo ||
   e:	f012 0f30 	tst.w	r2, #48	; 0x30
  12:	d048      	beq.n	a6 <InitSSL_Suites+0xa6>
                                      ssl->buffers.keyType == ed25519_sa_algo ||
  14:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
    ssl->options.cacheMessages = ssl->options.side == WOLFSSL_SERVER_END ||
  18:	f003 013d 	and.w	r1, r3, #61	; 0x3d
  1c:	2909      	cmp	r1, #9
  1e:	d042      	beq.n	a6 <InitSSL_Suites+0xa6>
                                      ssl->buffers.keyType == ed448_sa_algo ||
  20:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  24:	f1a3 0111 	sub.w	r1, r3, #17
  28:	424b      	negs	r3, r1
  2a:	414b      	adcs	r3, r1
    ssl->options.cacheMessages = ssl->options.side == WOLFSSL_SERVER_END ||
  2c:	f894 1276 	ldrb.w	r1, [r4, #630]	; 0x276
    if (ssl->suites != NULL) {
  30:	6860      	ldr	r0, [r4, #4]
    ssl->options.cacheMessages = ssl->options.side == WOLFSSL_SERVER_END ||
  32:	f363 0182 	bfi	r1, r3, #2, #1
  36:	f884 1276 	strb.w	r1, [r4, #630]	; 0x276
    if (ssl->suites != NULL) {
  3a:	b1f8      	cbz	r0, 7c <InitSSL_Suites+0x7c>
        InitSuites_EitherSide(ssl->suites, ssl->version, keySz, haveRSA,
  3c:	f3c2 1201 	ubfx	r2, r2, #4, #2
                havePSK, ssl->options.haveDH, ssl->options.haveECDSAsig,
  40:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
        InitSuites_EitherSide(ssl->suites, ssl->version, keySz, haveRSA,
  44:	9206      	str	r2, [sp, #24]
                ssl->options.haveAnon, ssl->options.side);
  46:	f894 2275 	ldrb.w	r2, [r4, #629]	; 0x275
        InitSuites_EitherSide(ssl->suites, ssl->version, keySz, haveRSA,
  4a:	f3c2 1200 	ubfx	r2, r2, #4, #1
  4e:	9205      	str	r2, [sp, #20]
  50:	09da      	lsrs	r2, r3, #7
  52:	9204      	str	r2, [sp, #16]
  54:	f3c3 1280 	ubfx	r2, r3, #6, #1
  58:	9203      	str	r2, [sp, #12]
  5a:	f3c3 1240 	ubfx	r2, r3, #5, #1
  5e:	9202      	str	r2, [sp, #8]
  60:	f3c3 0280 	ubfx	r2, r3, #2, #1
  64:	9201      	str	r2, [sp, #4]
  66:	f3c3 1200 	ubfx	r2, r3, #4, #1
  6a:	9200      	str	r2, [sp, #0]
  6c:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
  70:	f8d4 113c 	ldr.w	r1, [r4, #316]	; 0x13c
  74:	f3c3 03c0 	ubfx	r3, r3, #3, #1
  78:	f7ff fffe 	bl	0 <InitSSL_Suites>
    if (ssl->options.side == WOLFSSL_SERVER_END &&
  7c:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  80:	f013 0f30 	tst.w	r3, #48	; 0x30
  84:	d114      	bne.n	b0 <InitSSL_Suites+0xb0>
        if (!ssl->buffers.certificate || !ssl->buffers.certificate->buffer) {
  86:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
  8a:	b19b      	cbz	r3, b4 <InitSSL_Suites+0xb4>
  8c:	681b      	ldr	r3, [r3, #0]
  8e:	b18b      	cbz	r3, b4 <InitSSL_Suites+0xb4>
        if (!ssl->buffers.key || !ssl->buffers.key->buffer) {
  90:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
  94:	b173      	cbz	r3, b4 <InitSSL_Suites+0xb4>
  96:	681b      	ldr	r3, [r3, #0]
                return NO_PRIVATE_KEY;
  98:	2b00      	cmp	r3, #0
  9a:	bf14      	ite	ne
  9c:	2001      	movne	r0, #1
  9e:	f46f 709e 	mvneq.w	r0, #316	; 0x13c
}
  a2:	b008      	add	sp, #32
  a4:	bd10      	pop	{r4, pc}
                                      ssl->buffers.keyType == ed448_sa_algo ||
  a6:	2301      	movs	r3, #1
  a8:	e7c0      	b.n	2c <InitSSL_Suites+0x2c>
        return BAD_FUNC_ARG;
  aa:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  ae:	e7f8      	b.n	a2 <InitSSL_Suites+0xa2>
    return WOLFSSL_SUCCESS;
  b0:	2001      	movs	r0, #1
  b2:	e7f6      	b.n	a2 <InitSSL_Suites+0xa2>
                return NO_PRIVATE_KEY;
  b4:	f46f 709e 	mvn.w	r0, #316	; 0x13c
  b8:	e7f3      	b.n	a2 <InitSSL_Suites+0xa2>

Disassembly of section .text.SetSSL_CTX:

00000000 <SetSSL_CTX>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	460d      	mov	r5, r1
   6:	b085      	sub	sp, #20
   8:	4690      	mov	r8, r2
    if (!ssl || !ctx)
   a:	4604      	mov	r4, r0
   c:	b928      	cbnz	r0, 1a <SetSSL_CTX+0x1a>
        return BAD_FUNC_ARG;
   e:	f06f 07ac 	mvn.w	r7, #172	; 0xac
}
  12:	4638      	mov	r0, r7
  14:	b005      	add	sp, #20
  16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (!ssl || !ctx)
  1a:	2900      	cmp	r1, #0
  1c:	d0f7      	beq.n	e <SetSSL_CTX+0xe>
    newSSL = ssl->ctx == NULL; /* Assign after null check */
  1e:	6806      	ldr	r6, [r0, #0]
    if (!newSSL) {
  20:	b116      	cbz	r6, 28 <SetSSL_CTX+0x28>
        wolfSSL_CTX_free(ssl->ctx);
  22:	4630      	mov	r0, r6
  24:	f7ff fffe 	bl	0 <wolfSSL_CTX_free>
    ret = wolfSSL_CTX_up_ref(ctx);
  28:	4628      	mov	r0, r5
  2a:	f7ff fffe 	bl	0 <wolfSSL_CTX_up_ref>
    if (!ssl->msgsReceived.got_client_hello &&
  2e:	f894 3138 	ldrb.w	r3, [r4, #312]	; 0x138
    ssl->ctx     = ctx; /* only for passing to calls, options could change */
  32:	6025      	str	r5, [r4, #0]
    if (!ssl->msgsReceived.got_client_hello &&
  34:	f013 0f0e 	tst.w	r3, #14
  38:	682b      	ldr	r3, [r5, #0]
        ssl->version = ctx->method->version;
  3a:	bf04      	itt	eq
  3c:	881a      	ldrheq	r2, [r3, #0]
  3e:	f8a4 213c 	strheq.w	r2, [r4, #316]	; 0x13c
    ssl->eccTempKeySz = ctx->eccTempKeySz;
  42:	f8b5 2058 	ldrh.w	r2, [r5, #88]	; 0x58
  46:	f8a4 22a4 	strh.w	r2, [r4, #676]	; 0x2a4
    ssl->ecdhCurveOID = ctx->ecdhCurveOID;
  4a:	6d6a      	ldr	r2, [r5, #84]	; 0x54
  4c:	f8c4 2290 	str.w	r2, [r4, #656]	; 0x290
    ssl->pkCurveOID = ctx->pkCurveOID;
  50:	6dea      	ldr	r2, [r5, #92]	; 0x5c
  52:	f8c4 22a8 	str.w	r2, [r4, #680]	; 0x2a8
    ssl->timeout = ctx->timeout;
  56:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  58:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
    ssl->verifyCallback    = ctx->verifyCallback;
  5c:	6caa      	ldr	r2, [r5, #72]	; 0x48
  5e:	6222      	str	r2, [r4, #32]
    if (newSSL || ctx->method->side != WOLFSSL_NEITHER_END)
  60:	7899      	ldrb	r1, [r3, #2]
    ret = wolfSSL_CTX_up_ref(ctx);
  62:	4607      	mov	r7, r0
    if (newSSL || ctx->method->side != WOLFSSL_NEITHER_END)
  64:	b10e      	cbz	r6, 6a <SetSSL_CTX+0x6a>
  66:	2903      	cmp	r1, #3
  68:	d005      	beq.n	76 <SetSSL_CTX+0x76>
        ssl->options.side      = ctx->method->side;
  6a:	f894 2270 	ldrb.w	r2, [r4, #624]	; 0x270
  6e:	f361 1205 	bfi	r2, r1, #4, #2
  72:	f884 2270 	strb.w	r2, [r4, #624]	; 0x270
    ssl->options.downgrade    = ctx->method->downgrade;
  76:	78d9      	ldrb	r1, [r3, #3]
    ssl->options.minDowngrade = ctx->minDowngrade;
  78:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
  7c:	f884 3280 	strb.w	r3, [r4, #640]	; 0x280
    ssl->options.haveRSA          = ctx->haveRSA;
  80:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    ssl->options.haveFalconSig    = ctx->haveFalconSig;
  84:	f3c3 1200 	ubfx	r2, r3, #4, #1
    ssl->options.haveRSA          = ctx->haveRSA;
  88:	f003 0a01 	and.w	sl, r3, #1
    ssl->options.haveDH           = ctx->haveDH;
  8c:	f3c3 0e80 	ubfx	lr, r3, #2, #1
    ssl->options.haveECDSAsig     = ctx->haveECDSAsig;
  90:	f3c3 0cc0 	ubfx	ip, r3, #3, #1
    ssl->options.haveECC          = ctx->haveECC;
  94:	f3c3 0940 	ubfx	r9, r3, #1, #1
    ssl->options.haveStaticECC    = ctx->haveStaticECC;
  98:	f3c3 1080 	ubfx	r0, r3, #6, #1
    ssl->options.haveDilithiumSig = ctx->haveDilithiumSig;
  9c:	f3c3 1340 	ubfx	r3, r3, #5, #1
  a0:	9301      	str	r3, [sp, #4]
    ssl->options.minEccKeySz = ctx->minEccKeySz;
  a2:	8f6b      	ldrh	r3, [r5, #58]	; 0x3a
  a4:	f8a4 3286 	strh.w	r3, [r4, #646]	; 0x286
    ssl->options.partialWrite  = ctx->partialWrite;
  a8:	f895 3036 	ldrb.w	r3, [r5, #54]	; 0x36
    ssl->options.haveFalconSig    = ctx->haveFalconSig;
  ac:	9200      	str	r2, [sp, #0]
    ssl->options.quietShutdown = ctx->quietShutdown;
  ae:	f895 2037 	ldrb.w	r2, [r5, #55]	; 0x37
    ssl->options.partialWrite  = ctx->partialWrite;
  b2:	09db      	lsrs	r3, r3, #7
  b4:	9302      	str	r3, [sp, #8]
    ssl->options.quietShutdown = ctx->quietShutdown;
  b6:	f3c2 0340 	ubfx	r3, r2, #1, #1
  ba:	9303      	str	r3, [sp, #12]
    ssl->options.sessionCacheOff      = ctx->sessionCacheOff;
  bc:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
    ssl->options.sendVerify     = ctx->sendVerify;
  c0:	f3c3 1b00 	ubfx	fp, r3, #4, #1
  c4:	099e      	lsrs	r6, r3, #6
  c6:	ea46 068b 	orr.w	r6, r6, fp, lsl #2
  ca:	f3c3 1b40 	ubfx	fp, r3, #5, #1
  ce:	ea46 06cb 	orr.w	r6, r6, fp, lsl #3
  d2:	f003 0b01 	and.w	fp, r3, #1
  d6:	ea46 168b 	orr.w	r6, r6, fp, lsl #6
  da:	f3c3 0b40 	ubfx	fp, r3, #1, #1
  de:	ea46 16cb 	orr.w	r6, r6, fp, lsl #7
  e2:	f3c3 0b80 	ubfx	fp, r3, #2, #1
  e6:	ea46 260b 	orr.w	r6, r6, fp, lsl #8
  ea:	f3c3 03c0 	ubfx	r3, r3, #3, #1
  ee:	ea46 2643 	orr.w	r6, r6, r3, lsl #9
  f2:	f001 0101 	and.w	r1, r1, #1
  f6:	ea46 2681 	orr.w	r6, r6, r1, lsl #10
  fa:	ea46 664a 	orr.w	r6, r6, sl, lsl #25
  fe:	ea46 6989 	orr.w	r9, r6, r9, lsl #26
 102:	ea49 6ece 	orr.w	lr, r9, lr, lsl #27
 106:	9b00      	ldr	r3, [sp, #0]
 108:	4940      	ldr	r1, [pc, #256]	; (20c <SetSSL_CTX+0x20c>)
 10a:	ea4e 7c0c 	orr.w	ip, lr, ip, lsl #28
 10e:	ea4c 7040 	orr.w	r0, ip, r0, lsl #29
 112:	ea40 7083 	orr.w	r0, r0, r3, lsl #30
 116:	9b01      	ldr	r3, [sp, #4]
 118:	ea40 70c3 	orr.w	r0, r0, r3, lsl #31
 11c:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
 120:	4019      	ands	r1, r3
    ssl->options.partialWrite  = ctx->partialWrite;
 122:	9b02      	ldr	r3, [sp, #8]
    ssl->options.sendVerify     = ctx->sendVerify;
 124:	4308      	orrs	r0, r1
    ssl->options.partialWrite  = ctx->partialWrite;
 126:	9903      	ldr	r1, [sp, #12]
    ssl->options.sendVerify     = ctx->sendVerify;
 128:	f8c4 0270 	str.w	r0, [r4, #624]	; 0x270
    ssl->options.partialWrite  = ctx->partialWrite;
 12c:	011b      	lsls	r3, r3, #4
 12e:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
    ssl->options.groupMessages = ctx->groupMessages;
 132:	f3c2 0280 	ubfx	r2, r2, #2, #1
    ssl->options.partialWrite  = ctx->partialWrite;
 136:	ea43 12c2 	orr.w	r2, r3, r2, lsl #7
 13a:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 13e:	f003 034f 	and.w	r3, r3, #79	; 0x4f
 142:	431a      	orrs	r2, r3
    ssl->buffers.certificate = ctx->certificate;
 144:	692b      	ldr	r3, [r5, #16]
 146:	f8c4 30dc 	str.w	r3, [r4, #220]	; 0xdc
    ssl->buffers.certChain = ctx->certChain;
 14a:	696b      	ldr	r3, [r5, #20]
    ssl->options.partialWrite  = ctx->partialWrite;
 14c:	f884 2274 	strb.w	r2, [r4, #628]	; 0x274
    ssl->buffers.certChain = ctx->certChain;
 150:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
    ssl->buffers.keyType  = ctx->privateKeyType;
 154:	7f2a      	ldrb	r2, [r5, #28]
    ssl->buffers.key      = ctx->privateKey;
 156:	69ab      	ldr	r3, [r5, #24]
 158:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
    ssl->buffers.keyType  = ctx->privateKeyType;
 15c:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
 160:	f3c2 0205 	ubfx	r2, r2, #0, #6
 164:	f362 0305 	bfi	r3, r2, #0, #6
    ssl->buffers.keyId    = ctx->privateKeyId;
 168:	7f2a      	ldrb	r2, [r5, #28]
 16a:	f3c2 1280 	ubfx	r2, r2, #6, #1
 16e:	f362 1386 	bfi	r3, r2, #6, #1
    ssl->buffers.keyLabel = ctx->privateKeyLabel;
 172:	7f2a      	ldrb	r2, [r5, #28]
 174:	09d2      	lsrs	r2, r2, #7
 176:	f362 13c7 	bfi	r3, r2, #7, #1
 17a:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
    ssl->buffers.keySz    = ctx->privateKeySz;
 17e:	6a2b      	ldr	r3, [r5, #32]
 180:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
                                      ssl->buffers.keyType == ed448_sa_algo ||
 184:	f010 0f30 	tst.w	r0, #48	; 0x30
    ssl->buffers.keyDevId = ctx->privateKeyDevId;
 188:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 18a:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
                                      ssl->buffers.keyType == ed448_sa_algo ||
 18e:	d032      	beq.n	1f6 <SetSSL_CTX+0x1f6>
                                      ssl->buffers.keyType == ed25519_sa_algo ||
 190:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
    ssl->options.cacheMessages = ssl->options.side == WOLFSSL_SERVER_END ||
 194:	f003 023d 	and.w	r2, r3, #61	; 0x3d
 198:	2a09      	cmp	r2, #9
 19a:	d02c      	beq.n	1f6 <SetSSL_CTX+0x1f6>
                                      ssl->buffers.keyType == ed448_sa_algo ||
 19c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1a0:	f1a3 0211 	sub.w	r2, r3, #17
 1a4:	4253      	negs	r3, r2
 1a6:	4153      	adcs	r3, r2
    ssl->options.cacheMessages = ssl->options.side == WOLFSSL_SERVER_END ||
 1a8:	f894 2276 	ldrb.w	r2, [r4, #630]	; 0x276
 1ac:	f363 0282 	bfi	r2, r3, #2, #1
 1b0:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
    if (writeDup == 0) {
 1b4:	f1b8 0f00 	cmp.w	r8, #0
 1b8:	d112      	bne.n	1e0 <SetSSL_CTX+0x1e0>
        if (ssl->suites != NULL) {
 1ba:	6860      	ldr	r0, [r4, #4]
 1bc:	b130      	cbz	r0, 1cc <SetSSL_CTX+0x1cc>
            if (ctx->suites == NULL)
 1be:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
                XMEMSET(ssl->suites, 0, sizeof(Suites));
 1c0:	f44f 72ac 	mov.w	r2, #344	; 0x158
            if (ctx->suites == NULL)
 1c4:	b9c9      	cbnz	r1, 1fa <SetSSL_CTX+0x1fa>
                XMEMSET(ssl->suites, 0, sizeof(Suites));
 1c6:	4641      	mov	r1, r8
 1c8:	f7ff fffe 	bl	0 <memset>
        if (ssl->options.side != WOLFSSL_NEITHER_END) {
 1cc:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
 1d0:	f003 0330 	and.w	r3, r3, #48	; 0x30
 1d4:	2b30      	cmp	r3, #48	; 0x30
 1d6:	d003      	beq.n	1e0 <SetSSL_CTX+0x1e0>
            ret = InitSSL_Suites(ssl);
 1d8:	4620      	mov	r0, r4
 1da:	f7ff fffe 	bl	0 <SetSSL_CTX>
 1de:	4607      	mov	r7, r0
    if (ctx->mask != 0 && wolfSSL_set_options(ssl, ctx->mask) == 0) {
 1e0:	6be9      	ldr	r1, [r5, #60]	; 0x3c
 1e2:	b969      	cbnz	r1, 200 <SetSSL_CTX+0x200>
        ssl->CBIORecv = ctx->CBIORecv;
 1e4:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 1e6:	62a3      	str	r3, [r4, #40]	; 0x28
        ssl->CBIOSend = ctx->CBIOSend;
 1e8:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 1ea:	62e3      	str	r3, [r4, #44]	; 0x2c
    ssl->verifyDepth = ctx->verifyDepth;
 1ec:	f895 3034 	ldrb.w	r3, [r5, #52]	; 0x34
 1f0:	f884 3132 	strb.w	r3, [r4, #306]	; 0x132
    return ret;
 1f4:	e70d      	b.n	12 <SetSSL_CTX+0x12>
                                      ssl->buffers.keyType == ed448_sa_algo ||
 1f6:	2301      	movs	r3, #1
 1f8:	e7d6      	b.n	1a8 <SetSSL_CTX+0x1a8>
                XMEMCPY(ssl->suites, ctx->suites, sizeof(Suites));
 1fa:	f7ff fffe 	bl	0 <memcpy>
 1fe:	e7e5      	b.n	1cc <SetSSL_CTX+0x1cc>
    if (ctx->mask != 0 && wolfSSL_set_options(ssl, ctx->mask) == 0) {
 200:	4620      	mov	r0, r4
 202:	f7ff fffe 	bl	0 <wolfSSL_set_options>
 206:	2800      	cmp	r0, #0
 208:	d1ec      	bne.n	1e4 <SetSSL_CTX+0x1e4>
 20a:	e700      	b.n	e <SetSSL_CTX+0xe>
 20c:	01fff830 	.word	0x01fff830

Disassembly of section .text.FreeHandshakeHashes:

00000000 <FreeHandshakeHashes>:
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
    if (ssl->hsHashes) {
   4:	68c0      	ldr	r0, [r0, #12]
   6:	b300      	cbz	r0, 4a <FreeHandshakeHashes+0x4a>
        wc_Sha256Free(&ssl->hsHashes->hashSha256);
   8:	f500 70a6 	add.w	r0, r0, #332	; 0x14c
   c:	f7ff fffe 	bl	0 <wc_Sha256Free>
        wc_Sha512Free(&ssl->hsHashes->hashSha512);
  10:	68e0      	ldr	r0, [r4, #12]
  12:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
  16:	f7ff fffe 	bl	0 <wc_Sha512Free>
        if (ssl->hsHashes->messages != NULL) {
  1a:	68e3      	ldr	r3, [r4, #12]
  1c:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
  20:	b168      	cbz	r0, 3e <FreeHandshakeHashes+0x3e>
            ForceZero(ssl->hsHashes->messages, ssl->hsHashes->length);
  22:	f8d3 12a4 	ldr.w	r1, [r3, #676]	; 0x2a4
  26:	f7ff fffe 	bl	0 <FreeHandshakeHashes>
            XFREE(ssl->hsHashes->messages, ssl->heap, DYNAMIC_TYPE_HASHES);
  2a:	68e3      	ldr	r3, [r4, #12]
  2c:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
  30:	b108      	cbz	r0, 36 <FreeHandshakeHashes+0x36>
  32:	f7ff fffe 	bl	0 <free>
            ssl->hsHashes->messages = NULL;
  36:	68e3      	ldr	r3, [r4, #12]
  38:	2200      	movs	r2, #0
  3a:	f8c3 22a0 	str.w	r2, [r3, #672]	; 0x2a0
        XFREE(ssl->hsHashes, ssl->heap, DYNAMIC_TYPE_HASHES);
  3e:	68e0      	ldr	r0, [r4, #12]
  40:	b108      	cbz	r0, 46 <FreeHandshakeHashes+0x46>
  42:	f7ff fffe 	bl	0 <free>
        ssl->hsHashes = NULL;
  46:	2300      	movs	r3, #0
  48:	60e3      	str	r3, [r4, #12]
}
  4a:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitHandshakeHashes:

00000000 <InitHandshakeHashes>:
    if (ssl->hsHashes != NULL) {
   0:	68c3      	ldr	r3, [r0, #12]
{
   2:	b510      	push	{r4, lr}
   4:	4604      	mov	r4, r0
    if (ssl->hsHashes != NULL) {
   6:	b10b      	cbz	r3, c <InitHandshakeHashes+0xc>
        FreeHandshakeHashes(ssl);
   8:	f7ff fffe 	bl	0 <InitHandshakeHashes>
    ssl->hsHashes = (HS_Hashes*)XMALLOC(sizeof(HS_Hashes), ssl->heap,
   c:	f44f 702c 	mov.w	r0, #688	; 0x2b0
  10:	f7ff fffe 	bl	0 <malloc>
  14:	60e0      	str	r0, [r4, #12]
    if (ssl->hsHashes == NULL) {
  16:	b1b8      	cbz	r0, 48 <InitHandshakeHashes+0x48>
    XMEMSET(ssl->hsHashes, 0, sizeof(HS_Hashes));
  18:	f44f 722c 	mov.w	r2, #688	; 0x2b0
  1c:	2100      	movs	r1, #0
  1e:	f7ff fffe 	bl	0 <memset>
    ret = wc_InitSha256_ex(&ssl->hsHashes->hashSha256, ssl->heap, ssl->devId);
  22:	68e0      	ldr	r0, [r4, #12]
  24:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
  28:	6a61      	ldr	r1, [r4, #36]	; 0x24
  2a:	f500 70a6 	add.w	r0, r0, #332	; 0x14c
  2e:	f7ff fffe 	bl	0 <wc_InitSha256_ex>
    if (ret != 0)
  32:	b958      	cbnz	r0, 4c <InitHandshakeHashes+0x4c>
    ret = wc_InitSha512_ex(&ssl->hsHashes->hashSha512, ssl->heap, ssl->devId);
  34:	68e0      	ldr	r0, [r4, #12]
  36:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
  3a:	6a61      	ldr	r1, [r4, #36]	; 0x24
  3c:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
}
  40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ret = wc_InitSha512_ex(&ssl->hsHashes->hashSha512, ssl->heap, ssl->devId);
  44:	f7ff bffe 	b.w	0 <wc_InitSha512_ex>
        return MEMORY_E;
  48:	f06f 007c 	mvn.w	r0, #124	; 0x7c
}
  4c:	bd10      	pop	{r4, pc}

Disassembly of section .text.InitHandshakeHashesAndCopy:

00000000 <InitHandshakeHashesAndCopy>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
   4:	4616      	mov	r6, r2
    if (source == NULL)
   6:	460c      	mov	r4, r1
   8:	b3a9      	cbz	r1, 76 <InitHandshakeHashesAndCopy+0x76>
    ssl->hsHashes = NULL;
   a:	2300      	movs	r3, #0
    tmpHashes = ssl->hsHashes;
   c:	68c7      	ldr	r7, [r0, #12]
    ssl->hsHashes = NULL;
   e:	60c3      	str	r3, [r0, #12]
    InitHandshakeHashes(ssl);
  10:	f7ff fffe 	bl	0 <InitHandshakeHashesAndCopy>
    *destination = ssl->hsHashes;
  14:	68eb      	ldr	r3, [r5, #12]
  16:	6033      	str	r3, [r6, #0]
    ssl->hsHashes = tmpHashes;
  18:	60ef      	str	r7, [r5, #12]
            ret = wc_Sha256Copy(&source->hashSha256,
  1a:	6831      	ldr	r1, [r6, #0]
  1c:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  20:	f501 71a6 	add.w	r1, r1, #332	; 0x14c
  24:	f7ff fffe 	bl	0 <wc_Sha256Copy>
        if (ret == 0)
  28:	4605      	mov	r5, r0
  2a:	bb10      	cbnz	r0, 72 <InitHandshakeHashesAndCopy+0x72>
            ret = wc_Sha512Copy(&source->hashSha512,
  2c:	6831      	ldr	r1, [r6, #0]
  2e:	f504 70e0 	add.w	r0, r4, #448	; 0x1c0
  32:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
  36:	f7ff fffe 	bl	0 <wc_Sha512Copy>
        if (ret == 0 && source->messages != NULL) {
  3a:	4605      	mov	r5, r0
  3c:	b9c8      	cbnz	r0, 72 <InitHandshakeHashesAndCopy+0x72>
  3e:	f8d4 32a0 	ldr.w	r3, [r4, #672]	; 0x2a0
  42:	b1b3      	cbz	r3, 72 <InitHandshakeHashesAndCopy+0x72>
            (*destination)->messages = (byte*)XMALLOC(source->length, ssl->heap,
  44:	f8d4 02a4 	ldr.w	r0, [r4, #676]	; 0x2a4
  48:	6837      	ldr	r7, [r6, #0]
  4a:	f7ff fffe 	bl	0 <malloc>
            (*destination)->length = source->length;
  4e:	6833      	ldr	r3, [r6, #0]
            (*destination)->messages = (byte*)XMALLOC(source->length, ssl->heap,
  50:	f8c7 02a0 	str.w	r0, [r7, #672]	; 0x2a0
            (*destination)->length = source->length;
  54:	f8d4 22a4 	ldr.w	r2, [r4, #676]	; 0x2a4
            if ((*destination)->messages == NULL) {
  58:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
            (*destination)->length = source->length;
  5c:	f8c3 22a4 	str.w	r2, [r3, #676]	; 0x2a4
            (*destination)->prevLen = source->prevLen;
  60:	f8d4 22a8 	ldr.w	r2, [r4, #680]	; 0x2a8
  64:	f8c3 22a8 	str.w	r2, [r3, #680]	; 0x2a8
            if ((*destination)->messages == NULL) {
  68:	b140      	cbz	r0, 7c <InitHandshakeHashesAndCopy+0x7c>
                XMEMCPY((*destination)->messages, source->messages,
  6a:	e9d4 12a8 	ldrd	r1, r2, [r4, #672]	; 0x2a0
  6e:	f7ff fffe 	bl	0 <memcpy>
}
  72:	4628      	mov	r0, r5
  74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
  76:	f06f 05ac 	mvn.w	r5, #172	; 0xac
  7a:	e7fa      	b.n	72 <InitHandshakeHashesAndCopy+0x72>
                ret = MEMORY_E;
  7c:	f06f 057c 	mvn.w	r5, #124	; 0x7c
  80:	e7f7      	b.n	72 <InitHandshakeHashesAndCopy+0x72>

Disassembly of section .text.ReinitSSL:

00000000 <ReinitSSL>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
    if (!writeDup && ssl->arrays == NULL) {
   6:	b96a      	cbnz	r2, 24 <ReinitSSL+0x24>
   8:	6886      	ldr	r6, [r0, #8]
   a:	b95e      	cbnz	r6, 24 <ReinitSSL+0x24>
        ssl->arrays = (Arrays*)XMALLOC(sizeof(Arrays), ssl->heap,
   c:	20a8      	movs	r0, #168	; 0xa8
   e:	f7ff fffe 	bl	0 <malloc>
  12:	60a0      	str	r0, [r4, #8]
        if (ssl->arrays == NULL) {
  14:	b910      	cbnz	r0, 1c <ReinitSSL+0x1c>
            return MEMORY_E;
  16:	f06f 007c 	mvn.w	r0, #124	; 0x7c
}
  1a:	bd70      	pop	{r4, r5, r6, pc}
        XMEMSET(ssl->arrays, 0, sizeof(Arrays));
  1c:	22a8      	movs	r2, #168	; 0xa8
  1e:	4631      	mov	r1, r6
  20:	f7ff fffe 	bl	0 <memset>
    if (ssl->rng == NULL) {
  24:	69a3      	ldr	r3, [r4, #24]
  26:	b18b      	cbz	r3, 4c <ReinitSSL+0x4c>
    ssl->options.shutdownDone = 0;
  28:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
    if (ssl->session != NULL)
  2c:	f8d4 00f4 	ldr.w	r0, [r4, #244]	; 0xf4
    ssl->options.shutdownDone = 0;
  30:	f36f 13c7 	bfc	r3, #7, #1
  34:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
    if (ssl->session != NULL)
  38:	2800      	cmp	r0, #0
  3a:	d0ee      	beq.n	1a <ReinitSSL+0x1a>
        ssl->session->side = (byte)ssl->options.side;
  3c:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  40:	f3c3 1301 	ubfx	r3, r3, #4, #2
  44:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    return ret;
  48:	2000      	movs	r0, #0
  4a:	e7e6      	b.n	1a <ReinitSSL+0x1a>
        ssl->rng = ctx->rng; /* CTX may have one, if so use it */
  4c:	686d      	ldr	r5, [r5, #4]
  4e:	61a5      	str	r5, [r4, #24]
    if (ssl->rng == NULL) {
  50:	2d00      	cmp	r5, #0
  52:	d1e9      	bne.n	28 <ReinitSSL+0x28>
        ssl->rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), ssl->heap,DYNAMIC_TYPE_RNG);
  54:	2008      	movs	r0, #8
  56:	f7ff fffe 	bl	0 <malloc>
  5a:	61a0      	str	r0, [r4, #24]
        if (ssl->rng == NULL) {
  5c:	2800      	cmp	r0, #0
  5e:	d0da      	beq.n	16 <ReinitSSL+0x16>
        XMEMSET(ssl->rng, 0, sizeof(WC_RNG));
  60:	2208      	movs	r2, #8
  62:	4629      	mov	r1, r5
  64:	f7ff fffe 	bl	0 <memset>
        ssl->options.weOwnRng = 1;
  68:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
        if ( (ret = wc_InitRng_ex(ssl->rng, ssl->heap, ssl->devId)) != 0) {
  6c:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
  70:	6a61      	ldr	r1, [r4, #36]	; 0x24
  72:	69a0      	ldr	r0, [r4, #24]
        ssl->options.weOwnRng = 1;
  74:	f043 0302 	orr.w	r3, r3, #2
  78:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
        if ( (ret = wc_InitRng_ex(ssl->rng, ssl->heap, ssl->devId)) != 0) {
  7c:	f7ff fffe 	bl	0 <wc_InitRng_ex>
  80:	2800      	cmp	r0, #0
  82:	d0d1      	beq.n	28 <ReinitSSL+0x28>
  84:	e7c9      	b.n	1a <ReinitSSL+0x1a>

Disassembly of section .text.InitSSL:

00000000 <InitSSL>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460e      	mov	r6, r1
   4:	4604      	mov	r4, r0
   6:	4617      	mov	r7, r2
    XMEMSET(ssl, 0, sizeof(WOLFSSL));
   8:	2100      	movs	r1, #0
   a:	f44f 7231 	mov.w	r2, #708	; 0x2c4
   e:	f7ff fffe 	bl	0 <memset>
    ssl->heap = ctx->heap; /* carry over user heap without static memory */
  12:	6b33      	ldr	r3, [r6, #48]	; 0x30
  14:	6263      	str	r3, [r4, #36]	; 0x24
    ssl->buffers.inputBuffer.buffer = ssl->buffers.inputBuffer.staticBuffer;
  16:	f104 0378 	add.w	r3, r4, #120	; 0x78
  1a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    ssl->buffers.inputBuffer.bufferSize  = STATIC_BUFFER_LEN;
  1e:	2305      	movs	r3, #5
  20:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
    ssl->buffers.outputBuffer.bufferSize  = STATIC_BUFFER_LEN;
  24:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    ssl->devId = ctx->devId; /* device for async HW (from wolfAsync_DevOpen) */
  28:	6e33      	ldr	r3, [r6, #96]	; 0x60
  2a:	f8c4 32bc 	str.w	r3, [r4, #700]	; 0x2bc
    ssl->options.serverState = NULL_STATE;
  2e:	2300      	movs	r3, #0
  30:	f8a4 327c 	strh.w	r3, [r4, #636]	; 0x27c
    ssl->options.handShakeState  = NULL_STATE;
  34:	f884 327e 	strb.w	r3, [r4, #638]	; 0x27e
    ssl->options.connectState = CONNECT_BEGIN;
  38:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
    ssl->options.acceptState  = ACCEPT_BEGIN;
  3c:	f8a4 3282 	strh.w	r3, [r4, #642]	; 0x282
    ssl->options.buildMsgState = BUILD_MSG_BEGIN;
  40:	f884 3284 	strb.w	r3, [r4, #644]	; 0x284
    ssl->encrypt.state = CIPHER_STATE_BEGIN;
  44:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    ssl->decrypt.state = CIPHER_STATE_BEGIN;
  48:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
    ssl->IOCB_ReadCtx  = &ssl->rfd;  /* prevent invalid pointer access if not */
  4c:	f504 738c 	add.w	r3, r4, #280	; 0x118
  50:	6123      	str	r3, [r4, #16]
    ssl->IOCB_WriteCtx = &ssl->wfd;  /* correctly set */
  52:	f504 738e 	add.w	r3, r4, #284	; 0x11c
  56:	6163      	str	r3, [r4, #20]
    ssl->buffers.outputBuffer.buffer = ssl->buffers.outputBuffer.staticBuffer;
  58:	f104 0294 	add.w	r2, r4, #148	; 0x94
        ssl->hmac = TLS_hmac;
  5c:	4b30      	ldr	r3, [pc, #192]	; (120 <InitSSL+0x120>)
    ssl->buffers.outputBuffer.buffer = ssl->buffers.outputBuffer.staticBuffer;
  5e:	f8c4 209c 	str.w	r2, [r4, #156]	; 0x9c
    ssl->rfd = -1;   /* set to invalid descriptor */
  62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    ssl->wfd = -1;
  66:	e9c4 2246 	strd	r2, r2, [r4, #280]	; 0x118
    ssl->cipher.ssl = ssl;
  6a:	e9c4 4312 	strd	r4, r3, [r4, #72]	; 0x48
    ssl->options.useClientOrder = ctx->useClientOrder;
  6e:	f896 1039 	ldrb.w	r1, [r6, #57]	; 0x39
    ssl->options.userCurves = ctx->userCurves;
  72:	f896 3068 	ldrb.w	r3, [r6, #104]	; 0x68
  76:	f003 0001 	and.w	r0, r3, #1
  7a:	f3c1 0340 	ubfx	r3, r1, #1, #1
  7e:	03db      	lsls	r3, r3, #15
  80:	ea43 3340 	orr.w	r3, r3, r0, lsl #13
  84:	f3c1 0180 	ubfx	r1, r1, #2, #1
  88:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  8c:	f8d4 1274 	ldr.w	r1, [r4, #628]	; 0x274
  90:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  94:	f421 31d0 	bic.w	r1, r1, #106496	; 0x1a000
  98:	430b      	orrs	r3, r1
    ssl->alert_history.last_rx.level = -1;
  9a:	e9c4 223f 	strd	r2, r2, [r4, #252]	; 0xfc
    ssl->alert_history.last_tx.level = -1;
  9e:	e9c4 2241 	strd	r2, r2, [r4, #260]	; 0x104
    ssl->options.userCurves = ctx->userCurves;
  a2:	f8c4 3274 	str.w	r3, [r4, #628]	; 0x274
    InitCiphers(ssl);
  a6:	4620      	mov	r0, r4
  a8:	f7ff fffe 	bl	0 <InitSSL>
    InitCipherSpecs(&ssl->specs);
  ac:	f504 70a0 	add.w	r0, r4, #320	; 0x140
  b0:	f7ff fffe 	bl	0 <InitSSL>
    if ((ret = ReinitSSL(ssl, ctx, writeDup)) != 0) {
  b4:	463a      	mov	r2, r7
  b6:	4631      	mov	r1, r6
  b8:	4620      	mov	r0, r4
  ba:	f7ff fffe 	bl	0 <InitSSL>
  be:	4605      	mov	r5, r0
  c0:	bb60      	cbnz	r0, 11c <InitSSL+0x11c>
    if (!writeDup) {
  c2:	b94f      	cbnz	r7, d8 <InitSSL+0xd8>
        if (ctx->suites == NULL) {
  c4:	6af3      	ldr	r3, [r6, #44]	; 0x2c
  c6:	b93b      	cbnz	r3, d8 <InitSSL+0xd8>
            ret = AllocateCtxSuites(ctx);
  c8:	4630      	mov	r0, r6
  ca:	f7ff fffe 	bl	0 <InitSSL>
            if (ret != 0)
  ce:	4605      	mov	r5, r0
  d0:	bb20      	cbnz	r0, 11c <InitSSL+0x11c>
            InitSSL_CTX_Suites(ctx);
  d2:	4630      	mov	r0, r6
  d4:	f7ff fffe 	bl	0 <InitSSL>
    if ((ret = SetSSL_CTX(ssl, ctx, writeDup)) != WOLFSSL_SUCCESS
  d8:	463a      	mov	r2, r7
  da:	4631      	mov	r1, r6
  dc:	4620      	mov	r0, r4
  de:	f7ff fffe 	bl	0 <InitSSL>
  e2:	2801      	cmp	r0, #1
  e4:	4605      	mov	r5, r0
  e6:	d119      	bne.n	11c <InitSSL+0x11c>
    ssl->options.dtls = ssl->version.major == DTLS_MAJOR;
  e8:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
  ec:	f1a3 02fe 	sub.w	r2, r3, #254	; 0xfe
  f0:	4253      	negs	r3, r2
  f2:	4153      	adcs	r3, r2
  f4:	f894 2272 	ldrb.w	r2, [r4, #626]	; 0x272
  f8:	f363 0282 	bfi	r2, r3, #2, #1
  fc:	f884 2272 	strb.w	r2, [r4, #626]	; 0x272
    ret = InitHandshakeHashes(ssl);
 100:	4620      	mov	r0, r4
 102:	f7ff fffe 	bl	0 <InitSSL>
    if (ret != 0)
 106:	4605      	mov	r5, r0
 108:	b940      	cbnz	r0, 11c <InitSSL+0x11c>
    ssl->session = wolfSSL_NewSession(ssl->heap);
 10a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 10c:	f7ff fffe 	bl	0 <wolfSSL_NewSession>
        return MEMORY_E;
 110:	2800      	cmp	r0, #0
    ssl->session = wolfSSL_NewSession(ssl->heap);
 112:	f8c4 00f4 	str.w	r0, [r4, #244]	; 0xf4
        return MEMORY_E;
 116:	bf08      	it	eq
 118:	f06f 057c 	mvneq.w	r5, #124	; 0x7c
}
 11c:	4628      	mov	r0, r5
 11e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 120:	00000000 	.word	0x00000000

Disassembly of section .text.FreeArrays:

00000000 <FreeArrays>:
    if (ssl->arrays) {
   0:	6883      	ldr	r3, [r0, #8]
{
   2:	b510      	push	{r4, lr}
   4:	4604      	mov	r4, r0
    if (ssl->arrays) {
   6:	b36b      	cbz	r3, 64 <FreeArrays+0x64>
        if (keep && !IsAtLeastTLSv1_3(ssl->version)) {
   8:	b199      	cbz	r1, 32 <FreeArrays+0x32>
   a:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
   e:	f7ff fffe 	bl	0 <FreeArrays>
  12:	b970      	cbnz	r0, 32 <FreeArrays+0x32>
            XMEMCPY(ssl->session->sessionID, ssl->arrays->sessionID, ID_LEN);
  14:	f8d4 00f4 	ldr.w	r0, [r4, #244]	; 0xf4
  18:	2220      	movs	r2, #32
  1a:	f103 0154 	add.w	r1, r3, #84	; 0x54
  1e:	303c      	adds	r0, #60	; 0x3c
  20:	f7ff fffe 	bl	0 <memcpy>
            ssl->session->sessionIDSz = ssl->arrays->sessionIDSz;
  24:	68a2      	ldr	r2, [r4, #8]
  26:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
  2a:	f892 2074 	ldrb.w	r2, [r2, #116]	; 0x74
  2e:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
        if (ssl->arrays->preMasterSecret) {
  32:	68a3      	ldr	r3, [r4, #8]
  34:	6858      	ldr	r0, [r3, #4]
  36:	b150      	cbz	r0, 4e <FreeArrays+0x4e>
            ForceZero(ssl->arrays->preMasterSecret, ENCRYPT_LEN);
  38:	218b      	movs	r1, #139	; 0x8b
  3a:	f7ff fffe 	bl	0 <FreeArrays>
            XFREE(ssl->arrays->preMasterSecret, ssl->heap, DYNAMIC_TYPE_SECRET);
  3e:	68a3      	ldr	r3, [r4, #8]
  40:	6858      	ldr	r0, [r3, #4]
  42:	b108      	cbz	r0, 48 <FreeArrays+0x48>
  44:	f7ff fffe 	bl	0 <free>
            ssl->arrays->preMasterSecret = NULL;
  48:	68a3      	ldr	r3, [r4, #8]
  4a:	2200      	movs	r2, #0
  4c:	605a      	str	r2, [r3, #4]
        XFREE(ssl->arrays->pendingMsg, ssl->heap, DYNAMIC_TYPE_ARRAYS);
  4e:	68a3      	ldr	r3, [r4, #8]
  50:	6818      	ldr	r0, [r3, #0]
  52:	b108      	cbz	r0, 58 <FreeArrays+0x58>
  54:	f7ff fffe 	bl	0 <free>
        ssl->arrays->pendingMsg = NULL;
  58:	68a0      	ldr	r0, [r4, #8]
  5a:	2300      	movs	r3, #0
  5c:	6003      	str	r3, [r0, #0]
        ForceZero(ssl->arrays, sizeof(Arrays)); /* clear arrays struct */
  5e:	21a8      	movs	r1, #168	; 0xa8
  60:	f7ff fffe 	bl	0 <FreeArrays>
    XFREE(ssl->arrays, ssl->heap, DYNAMIC_TYPE_ARRAYS);
  64:	68a0      	ldr	r0, [r4, #8]
  66:	b108      	cbz	r0, 6c <FreeArrays+0x6c>
  68:	f7ff fffe 	bl	0 <free>
    ssl->arrays = NULL;
  6c:	2300      	movs	r3, #0
  6e:	60a3      	str	r3, [r4, #8]
}
  70:	bd10      	pop	{r4, pc}

Disassembly of section .text.FreeKey:

00000000 <FreeKey>:
{
   0:	b510      	push	{r4, lr}
   2:	4614      	mov	r4, r2
    if (ssl && pKey && *pKey) {
   4:	b180      	cbz	r0, 28 <FreeKey+0x28>
   6:	b17a      	cbz	r2, 28 <FreeKey+0x28>
   8:	6810      	ldr	r0, [r2, #0]
   a:	b168      	cbz	r0, 28 <FreeKey+0x28>
        switch (type) {
   c:	2945      	cmp	r1, #69	; 0x45
   e:	d00f      	beq.n	30 <FreeKey+0x30>
  10:	2946      	cmp	r1, #70	; 0x46
  12:	d00a      	beq.n	2a <FreeKey+0x2a>
  14:	2925      	cmp	r1, #37	; 0x25
  16:	d101      	bne.n	1c <FreeKey+0x1c>
                wc_ecc_free((ecc_key*)*pKey);
  18:	f7ff fffe 	bl	0 <wc_ecc_free>
        XFREE(*pKey, ssl->heap, type);
  1c:	6820      	ldr	r0, [r4, #0]
  1e:	b108      	cbz	r0, 24 <FreeKey+0x24>
  20:	f7ff fffe 	bl	0 <free>
        *pKey = NULL;
  24:	2300      	movs	r3, #0
  26:	6023      	str	r3, [r4, #0]
}
  28:	bd10      	pop	{r4, pc}
                wc_ed25519_free((ed25519_key*)*pKey);
  2a:	f7ff fffe 	bl	0 <wc_ed25519_free>
                break;
  2e:	e7f5      	b.n	1c <FreeKey+0x1c>
                wc_curve25519_free((curve25519_key*)*pKey);
  30:	f7ff fffe 	bl	0 <wc_curve25519_free>
                break;
  34:	e7f2      	b.n	1c <FreeKey+0x1c>

Disassembly of section .text.AllocKey:

00000000 <AllocKey>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460e      	mov	r6, r1
   4:	4617      	mov	r7, r2
    if (ssl == NULL || pKey == NULL) {
   6:	4605      	mov	r5, r0
   8:	b140      	cbz	r0, 1c <AllocKey+0x1c>
   a:	b13a      	cbz	r2, 1c <AllocKey+0x1c>
    if (*pKey != NULL) {
   c:	6813      	ldr	r3, [r2, #0]
   e:	bb9b      	cbnz	r3, 78 <AllocKey+0x78>
    switch (type) {
  10:	2945      	cmp	r1, #69	; 0x45
  12:	d006      	beq.n	22 <AllocKey+0x22>
  14:	2946      	cmp	r1, #70	; 0x46
  16:	d01c      	beq.n	52 <AllocKey+0x52>
  18:	2925      	cmp	r1, #37	; 0x25
  1a:	d01c      	beq.n	56 <AllocKey+0x56>
        return BAD_FUNC_ARG;
  1c:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  20:	e022      	b.n	68 <AllocKey+0x68>
            sz = sizeof(curve25519_key);
  22:	204c      	movs	r0, #76	; 0x4c
    *pKey = (void *)XMALLOC(sz, ssl->heap, type);
  24:	f7ff fffe 	bl	0 <malloc>
  28:	6038      	str	r0, [r7, #0]
    if (*pKey == NULL) {
  2a:	b340      	cbz	r0, 7e <AllocKey+0x7e>
    switch (type) {
  2c:	2e45      	cmp	r6, #69	; 0x45
  2e:	d01d      	beq.n	6c <AllocKey+0x6c>
  30:	2e46      	cmp	r6, #70	; 0x46
  32:	d013      	beq.n	5c <AllocKey+0x5c>
  34:	2e25      	cmp	r6, #37	; 0x25
  36:	d1f1      	bne.n	1c <AllocKey+0x1c>
            ret = wc_ecc_init_ex(eccKey, ssl->heap, ssl->devId);
  38:	f8d5 22bc 	ldr.w	r2, [r5, #700]	; 0x2bc
  3c:	6a69      	ldr	r1, [r5, #36]	; 0x24
  3e:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    if (ret != 0) {
  42:	4604      	mov	r4, r0
  44:	b180      	cbz	r0, 68 <AllocKey+0x68>
        FreeKey(ssl, type, pKey);
  46:	463a      	mov	r2, r7
  48:	4631      	mov	r1, r6
  4a:	4628      	mov	r0, r5
  4c:	f7ff fffe 	bl	0 <AllocKey>
  50:	e00a      	b.n	68 <AllocKey+0x68>
            sz = sizeof(ed25519_key);
  52:	2068      	movs	r0, #104	; 0x68
  54:	e7e6      	b.n	24 <AllocKey+0x24>
    switch (type) {
  56:	f44f 70de 	mov.w	r0, #444	; 0x1bc
  5a:	e7e3      	b.n	24 <AllocKey+0x24>
            wc_ed25519_init_ex((ed25519_key*)*pKey, ssl->heap, ssl->devId);
  5c:	f8d5 22bc 	ldr.w	r2, [r5, #700]	; 0x2bc
  60:	6a69      	ldr	r1, [r5, #36]	; 0x24
  62:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
            ret = 0;
  66:	2400      	movs	r4, #0
}
  68:	4620      	mov	r0, r4
  6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            wc_curve25519_init_ex((curve25519_key*)*pKey, ssl->heap, ssl->devId);
  6c:	f8d5 22bc 	ldr.w	r2, [r5, #700]	; 0x2bc
  70:	6a69      	ldr	r1, [r5, #36]	; 0x24
  72:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
  76:	e7f6      	b.n	66 <AllocKey+0x66>
        return BAD_STATE_E;
  78:	f06f 04bf 	mvn.w	r4, #191	; 0xbf
  7c:	e7f4      	b.n	68 <AllocKey+0x68>
        return MEMORY_E;
  7e:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  82:	e7f1      	b.n	68 <AllocKey+0x68>

Disassembly of section .text.FreeAsyncCtx:

00000000 <FreeAsyncCtx>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    if (ssl->async != NULL) {
   4:	6b81      	ldr	r1, [r0, #56]	; 0x38
{
   6:	4604      	mov	r4, r0
    if (ssl->async != NULL) {
   8:	b169      	cbz	r1, 26 <FreeAsyncCtx+0x26>
        if (ssl->async->freeArgs != NULL) {
   a:	680b      	ldr	r3, [r1, #0]
   c:	b123      	cbz	r3, 18 <FreeAsyncCtx+0x18>
            ssl->async->freeArgs(ssl, ssl->async->args);
   e:	3104      	adds	r1, #4
  10:	4798      	blx	r3
            ssl->async->freeArgs = NULL;
  12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  14:	2200      	movs	r2, #0
  16:	601a      	str	r2, [r3, #0]
        if (freeAsync) {
  18:	b12d      	cbz	r5, 26 <FreeAsyncCtx+0x26>
            XFREE(ssl->async, ssl->heap, DYNAMIC_TYPE_ASYNC);
  1a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  1c:	b108      	cbz	r0, 22 <FreeAsyncCtx+0x22>
  1e:	f7ff fffe 	bl	0 <free>
            ssl->async = NULL;
  22:	2300      	movs	r3, #0
  24:	63a3      	str	r3, [r4, #56]	; 0x38
}
  26:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.FreeKeyExchange:

00000000 <FreeKeyExchange>:
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
    if (ssl->buffers.sig.buffer) {
   4:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
   8:	b120      	cbz	r0, 14 <FreeKeyExchange+0x14>
        XFREE(ssl->buffers.sig.buffer, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
   a:	f7ff fffe 	bl	0 <free>
        ssl->buffers.sig.buffer = NULL;
   e:	2300      	movs	r3, #0
        ssl->buffers.sig.length = 0;
  10:	e9c4 3330 	strd	r3, r3, [r4, #192]	; 0xc0
    if (ssl->buffers.digest.buffer) {
  14:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
  18:	b170      	cbz	r0, 38 <FreeKeyExchange+0x38>
        if (!ssl->options.dontFreeDigest) {
  1a:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
  1e:	075b      	lsls	r3, r3, #29
  20:	d401      	bmi.n	26 <FreeKeyExchange+0x26>
            XFREE(ssl->buffers.digest.buffer, ssl->heap, DYNAMIC_TYPE_DIGEST);
  22:	f7ff fffe 	bl	0 <free>
        ssl->options.dontFreeDigest = 0;
  26:	f894 2275 	ldrb.w	r2, [r4, #629]	; 0x275
        ssl->buffers.digest.buffer = NULL;
  2a:	2300      	movs	r3, #0
        ssl->buffers.digest.length = 0;
  2c:	e9c4 3332 	strd	r3, r3, [r4, #200]	; 0xc8
        ssl->options.dontFreeDigest = 0;
  30:	f363 0282 	bfi	r2, r3, #2, #1
  34:	f884 2275 	strb.w	r2, [r4, #629]	; 0x275
    FreeKey(ssl, ssl->hsType, &ssl->hsKey);
  38:	6c21      	ldr	r1, [r4, #64]	; 0x40
  3a:	f104 023c 	add.w	r2, r4, #60	; 0x3c
  3e:	4620      	mov	r0, r4
}
  40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    FreeKey(ssl, ssl->hsType, &ssl->hsKey);
  44:	f7ff bffe 	b.w	0 <FreeKeyExchange>

Disassembly of section .text.FreeSuites:

00000000 <FreeSuites>:
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
    XFREE(ssl->suites, ssl->heap, DYNAMIC_TYPE_SUITES);
   4:	6840      	ldr	r0, [r0, #4]
   6:	b108      	cbz	r0, c <FreeSuites+0xc>
   8:	f7ff fffe 	bl	0 <free>
    ssl->suites = NULL;
   c:	2300      	movs	r3, #0
   e:	6063      	str	r3, [r4, #4]
}
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.WriteSEQ:

00000000 <WriteSEQ>:
    if (!ssl->options.dtls) {
   0:	f890 3272 	ldrb.w	r3, [r0, #626]	; 0x272
   4:	075b      	lsls	r3, r3, #29
{
   6:	b510      	push	{r4, lr}
    if (!ssl->options.dtls) {
   8:	d424      	bmi.n	54 <WriteSEQ+0x54>
    if (verify) {
   a:	b1c9      	cbz	r1, 40 <WriteSEQ+0x40>
        seq[1] = ssl->keys.peer_sequence_number_lo++;
   c:	e9d0 1394 	ldrd	r1, r3, [r0, #592]	; 0x250
  10:	1c5c      	adds	r4, r3, #1
  12:	f8c0 4254 	str.w	r4, [r0, #596]	; 0x254
        if (seq[1] > ssl->keys.peer_sequence_number_lo) {
  16:	d304      	bcc.n	22 <WriteSEQ+0x22>
            ssl->keys.peer_sequence_number_hi++;
  18:	1c4b      	adds	r3, r1, #1
  1a:	f8c0 3250 	str.w	r3, [r0, #592]	; 0x250
            ssl->keys.sequence_number_hi++;
  1e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    c[0] = (byte)((wc_u32 >> 24) & 0xff);
  22:	0e08      	lsrs	r0, r1, #24
  24:	7010      	strb	r0, [r2, #0]
    c[1] = (byte)((wc_u32 >> 16) & 0xff);
  26:	0c08      	lsrs	r0, r1, #16
  28:	7050      	strb	r0, [r2, #1]
    c[3] =  (byte)(wc_u32        & 0xff);
  2a:	70d1      	strb	r1, [r2, #3]
    c[2] = (byte)((wc_u32 >>  8) & 0xff);
  2c:	0a08      	lsrs	r0, r1, #8
    c[0] = (byte)((wc_u32 >> 24) & 0xff);
  2e:	0e19      	lsrs	r1, r3, #24
  30:	7111      	strb	r1, [r2, #4]
    c[1] = (byte)((wc_u32 >> 16) & 0xff);
  32:	0c19      	lsrs	r1, r3, #16
  34:	7151      	strb	r1, [r2, #5]
    c[2] = (byte)((wc_u32 >>  8) & 0xff);
  36:	0a19      	lsrs	r1, r3, #8
  38:	7090      	strb	r0, [r2, #2]
  3a:	7191      	strb	r1, [r2, #6]
    c[3] =  (byte)(wc_u32        & 0xff);
  3c:	71d3      	strb	r3, [r2, #7]
}
  3e:	bd10      	pop	{r4, pc}
        seq[1] = ssl->keys.sequence_number_lo++;
  40:	e9d0 1396 	ldrd	r1, r3, [r0, #600]	; 0x258
  44:	1c5c      	adds	r4, r3, #1
  46:	f8c0 425c 	str.w	r4, [r0, #604]	; 0x25c
        if (seq[1] > ssl->keys.sequence_number_lo) {
  4a:	d3ea      	bcc.n	22 <WriteSEQ+0x22>
            ssl->keys.sequence_number_hi++;
  4c:	1c4b      	adds	r3, r1, #1
  4e:	f8c0 3258 	str.w	r3, [r0, #600]	; 0x258
  52:	e7e4      	b.n	1e <WriteSEQ+0x1e>
    word32 seq[2] = {0, 0};
  54:	2300      	movs	r3, #0
  56:	4619      	mov	r1, r3
  58:	e7e3      	b.n	22 <WriteSEQ+0x22>

Disassembly of section .text.HashRaw:

00000000 <HashRaw>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (ssl->hsHashes == NULL) {
   4:	68c4      	ldr	r4, [r0, #12]
{
   6:	4605      	mov	r5, r0
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
    if (ssl->hsHashes == NULL) {
   c:	2c00      	cmp	r4, #0
   e:	d049      	beq.n	a4 <HashRaw+0xa4>
    if (IsAtLeastTLSv1_2(ssl)) {
  10:	f7ff fffe 	bl	0 <HashRaw>
  14:	b918      	cbnz	r0, 1e <HashRaw+0x1e>
    int ret = 0;
  16:	2400      	movs	r4, #0
}
  18:	4620      	mov	r0, r4
  1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret = wc_Sha256Update(&ssl->hsHashes->hashSha256, data, sz);
  1e:	f504 70a6 	add.w	r0, r4, #332	; 0x14c
  22:	f7ff fffe 	bl	0 <wc_Sha256Update>
        if (ret != 0)
  26:	4604      	mov	r4, r0
  28:	2800      	cmp	r0, #0
  2a:	d1f5      	bne.n	18 <HashRaw+0x18>
        ret = wc_Sha512Update(&ssl->hsHashes->hashSha512, data, sz);
  2c:	68e8      	ldr	r0, [r5, #12]
  2e:	4632      	mov	r2, r6
  30:	4641      	mov	r1, r8
  32:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
  36:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret != 0)
  3a:	4604      	mov	r4, r0
  3c:	2800      	cmp	r0, #0
  3e:	d1eb      	bne.n	18 <HashRaw+0x18>
    if (ssl->options.cacheMessages) {
  40:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
  44:	075b      	lsls	r3, r3, #29
  46:	d5e6      	bpl.n	16 <HashRaw+0x16>
        msgs = (byte*)XMALLOC(ssl->hsHashes->length + sz, ssl->heap,
  48:	68eb      	ldr	r3, [r5, #12]
  4a:	f8d3 02a4 	ldr.w	r0, [r3, #676]	; 0x2a4
  4e:	4430      	add	r0, r6
  50:	f7ff fffe 	bl	0 <malloc>
        if (msgs == NULL)
  54:	4607      	mov	r7, r0
  56:	b340      	cbz	r0, aa <HashRaw+0xaa>
        if ((ret == 0) && (ssl->hsHashes->messages != NULL)) {
  58:	68eb      	ldr	r3, [r5, #12]
  5a:	f8d3 12a0 	ldr.w	r1, [r3, #672]	; 0x2a0
  5e:	b171      	cbz	r1, 7e <HashRaw+0x7e>
            XMEMCPY(msgs, ssl->hsHashes->messages, ssl->hsHashes->length);
  60:	f8d3 22a4 	ldr.w	r2, [r3, #676]	; 0x2a4
  64:	f7ff fffe 	bl	0 <memcpy>
            ForceZero(ssl->hsHashes->messages, ssl->hsHashes->length);
  68:	68eb      	ldr	r3, [r5, #12]
  6a:	e9d3 01a8 	ldrd	r0, r1, [r3, #672]	; 0x2a0
  6e:	f7ff fffe 	bl	0 <HashRaw>
            XFREE(ssl->hsHashes->messages, ssl->heap, DYNAMIC_TYPE_HASHES);
  72:	68eb      	ldr	r3, [r5, #12]
  74:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
  78:	b108      	cbz	r0, 7e <HashRaw+0x7e>
  7a:	f7ff fffe 	bl	0 <free>
            ssl->hsHashes->messages = msgs;
  7e:	68eb      	ldr	r3, [r5, #12]
            XMEMCPY(msgs + ssl->hsHashes->length, data, sz);
  80:	f8d3 02a4 	ldr.w	r0, [r3, #676]	; 0x2a4
            ssl->hsHashes->messages = msgs;
  84:	f8c3 72a0 	str.w	r7, [r3, #672]	; 0x2a0
            XMEMCPY(msgs + ssl->hsHashes->length, data, sz);
  88:	4632      	mov	r2, r6
  8a:	4641      	mov	r1, r8
  8c:	4438      	add	r0, r7
  8e:	f7ff fffe 	bl	0 <memcpy>
            ssl->hsHashes->prevLen = ssl->hsHashes->length;
  92:	68eb      	ldr	r3, [r5, #12]
  94:	f8d3 22a4 	ldr.w	r2, [r3, #676]	; 0x2a4
  98:	f8c3 22a8 	str.w	r2, [r3, #680]	; 0x2a8
            ssl->hsHashes->length += sz;
  9c:	4416      	add	r6, r2
  9e:	f8c3 62a4 	str.w	r6, [r3, #676]	; 0x2a4
  a2:	e7b9      	b.n	18 <HashRaw+0x18>
        return BAD_FUNC_ARG;
  a4:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  a8:	e7b6      	b.n	18 <HashRaw+0x18>
            ret = MEMORY_E;
  aa:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  ae:	e7b3      	b.n	18 <HashRaw+0x18>

Disassembly of section .text.HashOutput:

00000000 <HashOutput>:
{
   0:	b410      	push	{r4}
    if (ssl->hsHashes == NULL)
   2:	68c4      	ldr	r4, [r0, #12]
   4:	b12c      	cbz	r4, 12 <HashOutput+0x12>
    adj = output + RECORD_HEADER_SZ + ivSz;
   6:	3305      	adds	r3, #5
}
   8:	bc10      	pop	{r4}
    return HashRaw(ssl, adj, sz);
   a:	3a05      	subs	r2, #5
   c:	4419      	add	r1, r3
   e:	f7ff bffe 	b.w	0 <HashOutput>
}
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  16:	bc10      	pop	{r4}
  18:	4770      	bx	lr

Disassembly of section .text.HashInput:

00000000 <HashInput>:
    if (ssl->hsHashes == NULL) {
   0:	68c3      	ldr	r3, [r0, #12]
   2:	b11b      	cbz	r3, c <HashInput+0xc>
    return HashRaw(ssl, adj, sz);
   4:	3204      	adds	r2, #4
   6:	3904      	subs	r1, #4
   8:	f7ff bffe 	b.w	0 <HashInput>
}
   c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  10:	4770      	bx	lr

Disassembly of section .text.ShrinkOutputBuffer:

00000000 <ShrinkOutputBuffer>:
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
    XFREE(ssl->buffers.outputBuffer.buffer - ssl->buffers.outputBuffer.offset,
   4:	f890 30ad 	ldrb.w	r3, [r0, #173]	; 0xad
   8:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   c:	1ac0      	subs	r0, r0, r3
   e:	d001      	beq.n	14 <ShrinkOutputBuffer+0x14>
  10:	f7ff fffe 	bl	0 <free>
    ssl->buffers.outputBuffer.buffer = ssl->buffers.outputBuffer.staticBuffer;
  14:	f104 0394 	add.w	r3, r4, #148	; 0x94
  18:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
    ssl->buffers.outputBuffer.bufferSize  = STATIC_BUFFER_LEN;
  1c:	2305      	movs	r3, #5
  1e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    ssl->buffers.outputBuffer.dynamicFlag = 0;
  22:	2300      	movs	r3, #0
  24:	f8a4 30ac 	strh.w	r3, [r4, #172]	; 0xac
}
  28:	bd10      	pop	{r4, pc}

Disassembly of section .text.ShrinkInputBuffer:

00000000 <ShrinkInputBuffer>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    int usedLength = ssl->buffers.inputBuffer.length -
   2:	e9d0 5321 	ldrd	r5, r3, [r0, #132]	; 0x84
{
   6:	4604      	mov	r4, r0
    int usedLength = ssl->buffers.inputBuffer.length -
   8:	1aed      	subs	r5, r5, r3
    if (!forcedFree && (usedLength > STATIC_BUFFER_LEN ||
   a:	b969      	cbnz	r1, 28 <ShrinkInputBuffer+0x28>
   c:	2d05      	cmp	r5, #5
   e:	dc23      	bgt.n	58 <ShrinkInputBuffer+0x58>
  10:	f8d0 20bc 	ldr.w	r2, [r0, #188]	; 0xbc
  14:	bb02      	cbnz	r2, 58 <ShrinkInputBuffer+0x58>
    if (!forcedFree && usedLength > 0) {
  16:	2d00      	cmp	r5, #0
  18:	dd06      	ble.n	28 <ShrinkInputBuffer+0x28>
        XMEMCPY(ssl->buffers.inputBuffer.staticBuffer,
  1a:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
  1e:	462a      	mov	r2, r5
  20:	4419      	add	r1, r3
  22:	3078      	adds	r0, #120	; 0x78
  24:	f7ff fffe 	bl	0 <memcpy>
    ForceZero(ssl->buffers.inputBuffer.buffer,
  28:	e9d4 0120 	ldrd	r0, r1, [r4, #128]	; 0x80
  2c:	f7ff fffe 	bl	0 <ShrinkInputBuffer>
    XFREE(ssl->buffers.inputBuffer.buffer - ssl->buffers.inputBuffer.offset,
  30:	f894 3091 	ldrb.w	r3, [r4, #145]	; 0x91
  34:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
  38:	1ac0      	subs	r0, r0, r3
  3a:	d001      	beq.n	40 <ShrinkInputBuffer+0x40>
  3c:	f7ff fffe 	bl	0 <free>
    ssl->buffers.inputBuffer.buffer = ssl->buffers.inputBuffer.staticBuffer;
  40:	f104 0378 	add.w	r3, r4, #120	; 0x78
  44:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    ssl->buffers.inputBuffer.bufferSize  = STATIC_BUFFER_LEN;
  48:	2205      	movs	r2, #5
  4a:	2300      	movs	r3, #0
  4c:	e9c4 3222 	strd	r3, r2, [r4, #136]	; 0x88
    ssl->buffers.inputBuffer.dynamicFlag = 0;
  50:	f8a4 3090 	strh.w	r3, [r4, #144]	; 0x90
    ssl->buffers.inputBuffer.length = usedLength;
  54:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
}
  58:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.SSL_ResourceFree:

00000000 <SSL_ResourceFree>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
    FreeCiphers(ssl);
   4:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    FreeArrays(ssl, 0);
   8:	2100      	movs	r1, #0
   a:	4620      	mov	r0, r4
   c:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    FreeKeyExchange(ssl);
  10:	4620      	mov	r0, r4
  12:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    FreeAsyncCtx(ssl, 1);
  16:	2101      	movs	r1, #1
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    if (ssl->options.weOwnRng) {
  1e:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
  22:	079b      	lsls	r3, r3, #30
  24:	d50e      	bpl.n	44 <SSL_ResourceFree+0x44>
        wc_FreeRng(ssl->rng);
  26:	69a0      	ldr	r0, [r4, #24]
  28:	f7ff fffe 	bl	0 <wc_FreeRng>
        XFREE(ssl->rng, ssl->heap, DYNAMIC_TYPE_RNG);
  2c:	69a0      	ldr	r0, [r4, #24]
  2e:	b108      	cbz	r0, 34 <SSL_ResourceFree+0x34>
  30:	f7ff fffe 	bl	0 <free>
        ssl->options.weOwnRng = 0;
  34:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
        ssl->rng = NULL;
  38:	2200      	movs	r2, #0
        ssl->options.weOwnRng = 0;
  3a:	f362 0341 	bfi	r3, r2, #1, #1
        ssl->rng = NULL;
  3e:	61a2      	str	r2, [r4, #24]
        ssl->options.weOwnRng = 0;
  40:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
    FreeSuites(ssl);
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    FreeHandshakeHashes(ssl);
  4a:	4620      	mov	r0, r4
  4c:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    XFREE(ssl->buffers.domainName.buffer, ssl->heap, DYNAMIC_TYPE_DOMAIN);
  50:	f8d4 00b0 	ldr.w	r0, [r4, #176]	; 0xb0
  54:	b108      	cbz	r0, 5a <SSL_ResourceFree+0x5a>
  56:	f7ff fffe 	bl	0 <free>
    ForceZero(&ssl->keys, sizeof(Keys));
  5a:	f44f 718e 	mov.w	r1, #284	; 0x11c
  5e:	f504 70a8 	add.w	r0, r4, #336	; 0x150
  62:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    ssl->keepCert = 0; /* make sure certificate is free'd */
  66:	2300      	movs	r3, #0
  68:	f884 32b9 	strb.w	r3, [r4, #697]	; 0x2b9
    wolfSSL_UnloadCertsKeys(ssl);
  6c:	4620      	mov	r0, r4
  6e:	f7ff fffe 	bl	0 <wolfSSL_UnloadCertsKeys>
    if (ssl->buffers.inputBuffer.dynamicFlag)
  72:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
  76:	b11b      	cbz	r3, 80 <SSL_ResourceFree+0x80>
        ShrinkInputBuffer(ssl, FORCED_FREE);
  78:	2101      	movs	r1, #1
  7a:	4620      	mov	r0, r4
  7c:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    if (ssl->buffers.outputBuffer.dynamicFlag)
  80:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
  84:	b113      	cbz	r3, 8c <SSL_ResourceFree+0x8c>
        ShrinkOutputBuffer(ssl);
  86:	4620      	mov	r0, r4
  88:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccKey);
  8c:	f504 7227 	add.w	r2, r4, #668	; 0x29c
  90:	2125      	movs	r1, #37	; 0x25
  92:	4620      	mov	r0, r4
    ssl->peerEccKeyPresent = 0;
  94:	2500      	movs	r5, #0
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccKey);
  96:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    ssl->peerEccKeyPresent = 0;
  9a:	f884 5299 	strb.w	r5, [r4, #665]	; 0x299
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);
  9e:	f504 7228 	add.w	r2, r4, #672	; 0x2a0
  a2:	2125      	movs	r1, #37	; 0x25
  a4:	4620      	mov	r0, r4
  a6:	f7ff fffe 	bl	0 <SSL_ResourceFree>
        if (ssl->peerX25519KeyPresent
  aa:	f894 32b8 	ldrb.w	r3, [r4, #696]	; 0x2b8
    ssl->peerEccDsaKeyPresent = 0;
  ae:	f884 52a6 	strb.w	r5, [r4, #678]	; 0x2a6
        if (ssl->peerX25519KeyPresent
  b2:	bb53      	cbnz	r3, 10a <SSL_ResourceFree+0x10a>
                           || ssl->eccTempKeyPresent == DYNAMIC_TYPE_CURVE25519
  b4:	f894 3298 	ldrb.w	r3, [r4, #664]	; 0x298
        dtype = DYNAMIC_TYPE_ECC;
  b8:	2b45      	cmp	r3, #69	; 0x45
  ba:	bf0c      	ite	eq
  bc:	2145      	moveq	r1, #69	; 0x45
  be:	2125      	movne	r1, #37	; 0x25
        ssl->eccTempKeyPresent = 0;
  c0:	2500      	movs	r5, #0
        FreeKey(ssl, dtype, (void**)&ssl->eccTempKey);
  c2:	f504 7225 	add.w	r2, r4, #660	; 0x294
  c6:	4620      	mov	r0, r4
  c8:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    FreeKey(ssl, DYNAMIC_TYPE_CURVE25519, (void**)&ssl->peerX25519Key);
  cc:	f504 722d 	add.w	r2, r4, #692	; 0x2b4
  d0:	2145      	movs	r1, #69	; 0x45
  d2:	4620      	mov	r0, r4
        ssl->eccTempKeyPresent = 0;
  d4:	f884 5298 	strb.w	r5, [r4, #664]	; 0x298
    FreeKey(ssl, DYNAMIC_TYPE_CURVE25519, (void**)&ssl->peerX25519Key);
  d8:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    FreeKey(ssl, DYNAMIC_TYPE_ED25519, (void**)&ssl->peerEd25519Key);
  dc:	f504 722b 	add.w	r2, r4, #684	; 0x2ac
  e0:	2146      	movs	r1, #70	; 0x46
  e2:	4620      	mov	r0, r4
    ssl->peerX25519KeyPresent = 0;
  e4:	f884 52b8 	strb.w	r5, [r4, #696]	; 0x2b8
    FreeKey(ssl, DYNAMIC_TYPE_ED25519, (void**)&ssl->peerEd25519Key);
  e8:	f7ff fffe 	bl	0 <SSL_ResourceFree>
    TLSX_FreeAll(ssl->extensions, ssl->heap);
  ec:	6a61      	ldr	r1, [r4, #36]	; 0x24
  ee:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
    ssl->peerEd25519KeyPresent = 0;
  f2:	f884 52b0 	strb.w	r5, [r4, #688]	; 0x2b0
    TLSX_FreeAll(ssl->extensions, ssl->heap);
  f6:	f7ff fffe 	bl	0 <TLSX_FreeAll>
    if (ssl->session != NULL)
  fa:	f8d4 10f4 	ldr.w	r1, [r4, #244]	; 0xf4
  fe:	b131      	cbz	r1, 10e <SSL_ResourceFree+0x10e>
        wolfSSL_FreeSession(ssl->ctx, ssl->session);
 100:	6820      	ldr	r0, [r4, #0]
}
 102:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        wolfSSL_FreeSession(ssl->ctx, ssl->session);
 106:	f7ff bffe 	b.w	0 <wolfSSL_FreeSession>
            dtype = DYNAMIC_TYPE_CURVE25519;
 10a:	2145      	movs	r1, #69	; 0x45
 10c:	e7d8      	b.n	c0 <SSL_ResourceFree+0xc0>
}
 10e:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.FreeSSL:

00000000 <FreeSSL>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    WOLFSSL_CTX* ctx = ssl->ctx;
   2:	6805      	ldr	r5, [r0, #0]
{
   4:	4604      	mov	r4, r0
    SSL_ResourceFree(ssl);
   6:	f7ff fffe 	bl	0 <FreeSSL>
    XFREE(ssl, heap, DYNAMIC_TYPE_SSL);
   a:	4620      	mov	r0, r4
   c:	f7ff fffe 	bl	0 <free>
    if (ctx)
  10:	b125      	cbz	r5, 1c <FreeSSL+0x1c>
        FreeSSL_Ctx(ctx); /* will decrement and free underlying CTX if 0 */
  12:	4628      	mov	r0, r5
}
  14:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        FreeSSL_Ctx(ctx); /* will decrement and free underlying CTX if 0 */
  18:	f7ff bffe 	b.w	0 <FreeSSL>
}
  1c:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.FreeHandshakeResources:

00000000 <FreeHandshakeResources>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (ssl->buffers.inputBuffer.dynamicFlag)
   2:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
{
   6:	4604      	mov	r4, r0
    if (ssl->buffers.inputBuffer.dynamicFlag)
   8:	b113      	cbz	r3, 10 <FreeHandshakeResources+0x10>
        ShrinkInputBuffer(ssl, NO_FORCED_FREE);
   a:	2100      	movs	r1, #0
   c:	f7ff fffe 	bl	0 <FreeHandshakeResources>
        FreeSuites(ssl);
  10:	4620      	mov	r0, r4
  12:	f7ff fffe 	bl	0 <FreeHandshakeResources>
        FreeHandshakeHashes(ssl);
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <FreeHandshakeResources>
    if (ssl->options.tls1_1 == 0
  1c:	f994 3271 	ldrsb.w	r3, [r4, #625]	; 0x271
  20:	2b00      	cmp	r3, #0
  22:	da02      	bge.n	2a <FreeHandshakeResources+0x2a>
        || ssl->specs.cipher_type == stream
  24:	f894 3149 	ldrb.w	r3, [r4, #329]	; 0x149
  28:	b993      	cbnz	r3, 50 <FreeHandshakeResources+0x50>
        if (ssl->options.weOwnRng) {
  2a:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
  2e:	079a      	lsls	r2, r3, #30
  30:	d50e      	bpl.n	50 <FreeHandshakeResources+0x50>
            wc_FreeRng(ssl->rng);
  32:	69a0      	ldr	r0, [r4, #24]
  34:	f7ff fffe 	bl	0 <wc_FreeRng>
            XFREE(ssl->rng, ssl->heap, DYNAMIC_TYPE_RNG);
  38:	69a0      	ldr	r0, [r4, #24]
  3a:	b108      	cbz	r0, 40 <FreeHandshakeResources+0x40>
  3c:	f7ff fffe 	bl	0 <free>
            ssl->options.weOwnRng = 0;
  40:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
            ssl->rng = NULL;
  44:	2200      	movs	r2, #0
            ssl->options.weOwnRng = 0;
  46:	f362 0341 	bfi	r3, r2, #1, #1
            ssl->rng = NULL;
  4a:	61a2      	str	r2, [r4, #24]
            ssl->options.weOwnRng = 0;
  4c:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
        if (ssl->options.saveArrays == 0)
  50:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
  54:	07db      	lsls	r3, r3, #31
  56:	d403      	bmi.n	60 <FreeHandshakeResources+0x60>
            FreeArrays(ssl, 1);
  58:	2101      	movs	r1, #1
  5a:	4620      	mov	r0, r4
  5c:	f7ff fffe 	bl	0 <FreeHandshakeResources>
        ssl->peerEccDsaKeyPresent = 0;
  60:	2500      	movs	r5, #0
        FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);
  62:	f504 7228 	add.w	r2, r4, #672	; 0x2a0
  66:	2125      	movs	r1, #37	; 0x25
  68:	4620      	mov	r0, r4
  6a:	f7ff fffe 	bl	0 <FreeHandshakeResources>
        FreeKey(ssl, DYNAMIC_TYPE_ED25519, (void**)&ssl->peerEd25519Key);
  6e:	f504 722b 	add.w	r2, r4, #684	; 0x2ac
  72:	2146      	movs	r1, #70	; 0x46
  74:	4620      	mov	r0, r4
        ssl->peerEccDsaKeyPresent = 0;
  76:	f884 52a6 	strb.w	r5, [r4, #678]	; 0x2a6
        FreeKey(ssl, DYNAMIC_TYPE_ED25519, (void**)&ssl->peerEd25519Key);
  7a:	f7ff fffe 	bl	0 <FreeHandshakeResources>
        ssl->peerEd25519KeyPresent = 0;
  7e:	f884 52b0 	strb.w	r5, [r4, #688]	; 0x2b0
    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccKey);
  82:	f504 7227 	add.w	r2, r4, #668	; 0x29c
  86:	2125      	movs	r1, #37	; 0x25
  88:	4620      	mov	r0, r4
  8a:	f7ff fffe 	bl	0 <FreeHandshakeResources>
        if (ssl->peerX25519KeyPresent ||
  8e:	f894 32b8 	ldrb.w	r3, [r4, #696]	; 0x2b8
    ssl->peerEccKeyPresent = 0;
  92:	f884 5299 	strb.w	r5, [r4, #665]	; 0x299
        if (ssl->peerX25519KeyPresent ||
  96:	bb03      	cbnz	r3, da <FreeHandshakeResources+0xda>
  98:	f894 3298 	ldrb.w	r3, [r4, #664]	; 0x298
        dtype = DYNAMIC_TYPE_ECC;
  9c:	2b45      	cmp	r3, #69	; 0x45
  9e:	bf0c      	ite	eq
  a0:	2145      	moveq	r1, #69	; 0x45
  a2:	2125      	movne	r1, #37	; 0x25
        ssl->eccTempKeyPresent = 0;
  a4:	2500      	movs	r5, #0
        FreeKey(ssl, dtype, (void**)&ssl->eccTempKey);
  a6:	f504 7225 	add.w	r2, r4, #660	; 0x294
  aa:	4620      	mov	r0, r4
  ac:	f7ff fffe 	bl	0 <FreeHandshakeResources>
    FreeKey(ssl, DYNAMIC_TYPE_CURVE25519, (void**)&ssl->peerX25519Key);
  b0:	f504 722d 	add.w	r2, r4, #692	; 0x2b4
  b4:	2145      	movs	r1, #69	; 0x45
  b6:	4620      	mov	r0, r4
        ssl->eccTempKeyPresent = 0;
  b8:	f884 5298 	strb.w	r5, [r4, #664]	; 0x298
    FreeKey(ssl, DYNAMIC_TYPE_CURVE25519, (void**)&ssl->peerX25519Key);
  bc:	f7ff fffe 	bl	0 <FreeHandshakeResources>
    ssl->peerX25519KeyPresent = 0;
  c0:	f884 52b8 	strb.w	r5, [r4, #696]	; 0x2b8
    wolfSSL_UnloadCertsKeys(ssl);
  c4:	4620      	mov	r0, r4
  c6:	f7ff fffe 	bl	0 <wolfSSL_UnloadCertsKeys>
    TLSX_FreeAll(ssl->extensions, ssl->heap);
  ca:	6a61      	ldr	r1, [r4, #36]	; 0x24
  cc:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
  d0:	f7ff fffe 	bl	0 <TLSX_FreeAll>
    ssl->extensions = NULL;
  d4:	f8c4 52c0 	str.w	r5, [r4, #704]	; 0x2c0
}
  d8:	bd38      	pop	{r3, r4, r5, pc}
            dtype = DYNAMIC_TYPE_CURVE25519;
  da:	2145      	movs	r1, #69	; 0x45
  dc:	e7e2      	b.n	a4 <FreeHandshakeResources+0xa4>

Disassembly of section .text.SendBuffered:

00000000 <SendBuffered>:
    if (ssl->CBIOSend == NULL && !WOLFSSL_IS_QUIC(ssl)) {
   0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	4604      	mov	r4, r0
    if (ssl->CBIOSend == NULL && !WOLFSSL_IS_QUIC(ssl)) {
   6:	bb3b      	cbnz	r3, 58 <SendBuffered+0x58>
            return SOCKET_ERROR_E;
   8:	481e      	ldr	r0, [pc, #120]	; (84 <SendBuffered+0x84>)
}
   a:	bd70      	pop	{r4, r5, r6, pc}
        int sent = ssl->CBIOSend(ssl,
   c:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
  10:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
  14:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  16:	6963      	ldr	r3, [r4, #20]
  18:	4401      	add	r1, r0
  1a:	462a      	mov	r2, r5
  1c:	4620      	mov	r0, r4
  1e:	47b0      	blx	r6
        if (sent < 0) {
  20:	2800      	cmp	r0, #0
  22:	da0d      	bge.n	40 <SendBuffered+0x40>
            switch (sent) {
  24:	3005      	adds	r0, #5
  26:	2803      	cmp	r0, #3
  28:	d8ee      	bhi.n	8 <SendBuffered+0x8>
  2a:	e8df f000 	tbb	[pc, r0]
  2e:	1502      	.short	0x1502
  30:	2402      	.short	0x2402
                    ssl->options.connReset = 1;
  32:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  36:	f043 0308 	orr.w	r3, r3, #8
  3a:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
  3e:	e7e3      	b.n	8 <SendBuffered+0x8>
        if (sent > (int)ssl->buffers.outputBuffer.length) {
  40:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
  44:	4298      	cmp	r0, r3
  46:	dc19      	bgt.n	7c <SendBuffered+0x7c>
        ssl->buffers.outputBuffer.idx += sent;
  48:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
  4c:	4402      	add	r2, r0
        ssl->buffers.outputBuffer.length -= sent;
  4e:	1a18      	subs	r0, r3, r0
        ssl->buffers.outputBuffer.idx += sent;
  50:	f8c4 20a4 	str.w	r2, [r4, #164]	; 0xa4
        ssl->buffers.outputBuffer.length -= sent;
  54:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
    while (ssl->buffers.outputBuffer.length > 0) {
  58:	f8d4 50a0 	ldr.w	r5, [r4, #160]	; 0xa0
  5c:	2d00      	cmp	r5, #0
  5e:	d1d5      	bne.n	c <SendBuffered+0xc>
    if (ssl->buffers.outputBuffer.dynamicFlag)
  60:	f894 00ac 	ldrb.w	r0, [r4, #172]	; 0xac
    ssl->buffers.outputBuffer.idx = 0;
  64:	f8c4 50a4 	str.w	r5, [r4, #164]	; 0xa4
    if (ssl->buffers.outputBuffer.dynamicFlag)
  68:	2800      	cmp	r0, #0
  6a:	d0ce      	beq.n	a <SendBuffered+0xa>
        ShrinkOutputBuffer(ssl);
  6c:	4620      	mov	r0, r4
  6e:	f7ff fffe 	bl	0 <SendBuffered>
    return 0;
  72:	4628      	mov	r0, r5
  74:	e7c9      	b.n	a <SendBuffered+0xa>
                    return WANT_WRITE;
  76:	f46f 70a3 	mvn.w	r0, #326	; 0x146
  7a:	e7c6      	b.n	a <SendBuffered+0xa>
            return SEND_OOB_READ_E;
  7c:	f46f 70c1 	mvn.w	r0, #386	; 0x182
  80:	e7c3      	b.n	a <SendBuffered+0xa>
  82:	bf00      	nop
  84:	fffffecc 	.word	0xfffffecc

Disassembly of section .text.GetOutputBuffer:

00000000 <GetOutputBuffer>:
    return ssl->buffers.outputBuffer.buffer + ssl->buffers.outputBuffer.idx +
   0:	e9d0 2328 	ldrd	r2, r3, [r0, #160]	; 0xa0
   4:	f8d0 009c 	ldr.w	r0, [r0, #156]	; 0x9c
   8:	4413      	add	r3, r2
}
   a:	4418      	add	r0, r3
   c:	4770      	bx	lr

Disassembly of section .text.GrowInputBuffer:

00000000 <GrowInputBuffer>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    byte  align = ssl->options.dtls ? WOLFSSL_GENERAL_ALIGNMENT : 0;
   4:	f890 5272 	ldrb.w	r5, [r0, #626]	; 0x272
    if (align) {
   8:	f015 0504 	ands.w	r5, r5, #4
{
   c:	4604      	mov	r4, r0
   e:	4616      	mov	r6, r2
    if (align) {
  10:	d003      	beq.n	1a <GrowInputBuffer+0x1a>
           align *= 2;
  12:	006d      	lsls	r5, r5, #1
  14:	b2ed      	uxtb	r5, r5
       while (align < hdrSz)
  16:	2d0c      	cmp	r5, #12
  18:	d9fb      	bls.n	12 <GrowInputBuffer+0x12>
    if (usedLength < 0 || size < 0) {
  1a:	2e00      	cmp	r6, #0
  1c:	db3a      	blt.n	94 <GrowInputBuffer+0x94>
  1e:	2900      	cmp	r1, #0
  20:	db38      	blt.n	94 <GrowInputBuffer+0x94>
    tmp = (byte*)XMALLOC(size + usedLength + align,
  22:	1877      	adds	r7, r6, r1
  24:	1978      	adds	r0, r7, r5
  26:	f7ff fffe 	bl	0 <malloc>
    if (tmp == NULL)
  2a:	4680      	mov	r8, r0
  2c:	b3a8      	cbz	r0, 9a <GrowInputBuffer+0x9a>
    if (align)
  2e:	b115      	cbz	r5, 36 <GrowInputBuffer+0x36>
        tmp += align - hdrSz;
  30:	f1a5 030d 	sub.w	r3, r5, #13
  34:	4498      	add	r8, r3
    if (usedLength)
  36:	b146      	cbz	r6, 4a <GrowInputBuffer+0x4a>
        XMEMCPY(tmp, ssl->buffers.inputBuffer.buffer +
  38:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
  3c:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
  40:	4632      	mov	r2, r6
  42:	4419      	add	r1, r3
  44:	4640      	mov	r0, r8
  46:	f7ff fffe 	bl	0 <memcpy>
    if (ssl->buffers.inputBuffer.dynamicFlag) {
  4a:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
  4e:	b183      	cbz	r3, 72 <GrowInputBuffer+0x72>
        if (IsEncryptionOn(ssl, 1)) {
  50:	2101      	movs	r1, #1
  52:	4620      	mov	r0, r4
  54:	f7ff fffe 	bl	0 <GrowInputBuffer>
  58:	b118      	cbz	r0, 62 <GrowInputBuffer+0x62>
            ForceZero(ssl->buffers.inputBuffer.buffer,
  5a:	e9d4 0120 	ldrd	r0, r1, [r4, #128]	; 0x80
  5e:	f7ff fffe 	bl	0 <GrowInputBuffer>
        XFREE(ssl->buffers.inputBuffer.buffer - ssl->buffers.inputBuffer.offset,
  62:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
  66:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
  6a:	1a98      	subs	r0, r3, r2
  6c:	d001      	beq.n	72 <GrowInputBuffer+0x72>
  6e:	f7ff fffe 	bl	0 <free>
    ssl->buffers.inputBuffer.dynamicFlag = 1;
  72:	2301      	movs	r3, #1
  74:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
    if (align)
  78:	b10d      	cbz	r5, 7e <GrowInputBuffer+0x7e>
        ssl->buffers.inputBuffer.offset = align - hdrSz;
  7a:	3d0d      	subs	r5, #13
  7c:	b2ed      	uxtb	r5, r5
    ssl->buffers.inputBuffer.idx    = 0;
  7e:	2000      	movs	r0, #0
    ssl->buffers.inputBuffer.length = usedLength;
  80:	e9c4 6021 	strd	r6, r0, [r4, #132]	; 0x84
  84:	f884 5091 	strb.w	r5, [r4, #145]	; 0x91
    ssl->buffers.inputBuffer.buffer = tmp;
  88:	f8c4 8080 	str.w	r8, [r4, #128]	; 0x80
    ssl->buffers.inputBuffer.bufferSize = size + usedLength;
  8c:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
}
  90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return BAD_FUNC_ARG;
  94:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  98:	e7fa      	b.n	90 <GrowInputBuffer+0x90>
        return MEMORY_E;
  9a:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  9e:	e7f7      	b.n	90 <GrowInputBuffer+0x90>

Disassembly of section .text.GetInputData:

00000000 <GetInputData>:
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    usedLength = ssl->buffers.inputBuffer.length - ssl->buffers.inputBuffer.idx;
   4:	e9d0 6221 	ldrd	r6, r2, [r0, #132]	; 0x84
    maxLength  = ssl->buffers.inputBuffer.bufferSize - usedLength;
   8:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
   c:	1b95      	subs	r5, r2, r6
    if (usedLength < 0 || maxLength < 0 || inSz <= 0) {
   e:	1ab6      	subs	r6, r6, r2
    maxLength  = ssl->buffers.inputBuffer.bufferSize - usedLength;
  10:	442b      	add	r3, r5
{
  12:	4604      	mov	r4, r0
  14:	460f      	mov	r7, r1
    inSz       = (int)(size - usedLength);      /* from last partial read */
  16:	440d      	add	r5, r1
    if (usedLength < 0 || maxLength < 0 || inSz <= 0) {
  18:	d472      	bmi.n	100 <GetInputData+0x100>
  1a:	2b00      	cmp	r3, #0
  1c:	db70      	blt.n	100 <GetInputData+0x100>
  1e:	2d00      	cmp	r5, #0
  20:	dd6e      	ble.n	100 <GetInputData+0x100>
    if (inSz > maxLength) {
  22:	42ab      	cmp	r3, r5
  24:	db0c      	blt.n	40 <GetInputData+0x40>
    if (usedLength > 0 && ssl->buffers.inputBuffer.idx != 0)
  26:	b99e      	cbnz	r6, 50 <GetInputData+0x50>
    ssl->buffers.inputBuffer.idx    = 0;
  28:	2300      	movs	r3, #0
    ssl->buffers.inputBuffer.length = usedLength;
  2a:	e9c4 6321 	strd	r6, r3, [r4, #132]	; 0x84
        int in = wolfSSLReceive(ssl,
  2e:	e9d4 3120 	ldrd	r3, r1, [r4, #128]	; 0x80
  32:	eb03 0901 	add.w	r9, r3, r1
    if (ssl->CBIORecv == NULL) {
  36:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  38:	b9ab      	cbnz	r3, 66 <GetInputData+0x66>
            return SOCKET_ERROR_E;
  3a:	4835      	ldr	r0, [pc, #212]	; (110 <GetInputData+0x110>)
}
  3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (GrowInputBuffer(ssl, size + dtlsExtra, usedLength) < 0)
  40:	4632      	mov	r2, r6
  42:	f7ff fffe 	bl	0 <GetInputData>
  46:	2800      	cmp	r0, #0
  48:	daed      	bge.n	26 <GetInputData+0x26>
            return MEMORY_E;
  4a:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  4e:	e7f5      	b.n	3c <GetInputData+0x3c>
    if (usedLength > 0 && ssl->buffers.inputBuffer.idx != 0)
  50:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
  54:	2900      	cmp	r1, #0
  56:	d0e7      	beq.n	28 <GetInputData+0x28>
        XMEMMOVE(ssl->buffers.inputBuffer.buffer,
  58:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
  5c:	4632      	mov	r2, r6
  5e:	4401      	add	r1, r0
  60:	f7ff fffe 	bl	0 <memmove>
  64:	e7e0      	b.n	28 <GetInputData+0x28>
    int retryLimit = WOLFSSL_MODE_AUTO_RETRY_ATTEMPTS;
  66:	f04f 080a 	mov.w	r8, #10
    recvd = ssl->CBIORecv(ssl, (char *)buf, (int)sz, ssl->IOCB_ReadCtx);
  6a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  6c:	6923      	ldr	r3, [r4, #16]
  6e:	462a      	mov	r2, r5
  70:	4649      	mov	r1, r9
  72:	4620      	mov	r0, r4
  74:	47b0      	blx	r6
    if (recvd < 0) {
  76:	2800      	cmp	r0, #0
  78:	da35      	bge.n	e6 <GetInputData+0xe6>
        switch (recvd) {
  7a:	1d83      	adds	r3, r0, #6
  7c:	2b05      	cmp	r3, #5
  7e:	d82d      	bhi.n	dc <GetInputData+0xdc>
  80:	a201      	add	r2, pc, #4	; (adr r2, 88 <GetInputData+0x88>)
  82:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  86:	bf00      	nop
  88:	0000003b 	.word	0x0000003b
  8c:	000000d3 	.word	0x000000d3
  90:	0000006b 	.word	0x0000006b
  94:	000000c5 	.word	0x000000c5
  98:	000000a1 	.word	0x000000a1
  9c:	0000003b 	.word	0x0000003b
                if (retryLimit > 0 && ssl->ctx->autoRetry &&
  a0:	f1b8 0f00 	cmp.w	r8, #0
  a4:	dd2e      	ble.n	104 <GetInputData+0x104>
  a6:	6823      	ldr	r3, [r4, #0]
  a8:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
  ac:	07da      	lsls	r2, r3, #31
  ae:	d529      	bpl.n	104 <GetInputData+0x104>
  b0:	f894 327f 	ldrb.w	r3, [r4, #639]	; 0x27f
  b4:	bb33      	cbnz	r3, 104 <GetInputData+0x104>
                        !ssl->options.handShakeDone && !ssl->options.dtls) {
  b6:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  ba:	075b      	lsls	r3, r3, #29
  bc:	d422      	bmi.n	104 <GetInputData+0x104>
                    retryLimit--;
  be:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
                    goto retry;
  c2:	e7d2      	b.n	6a <GetInputData+0x6a>
                ssl->options.connReset = 1;
  c4:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  c8:	f043 0308 	orr.w	r3, r3, #8
  cc:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
  d0:	e7b3      	b.n	3a <GetInputData+0x3a>
                ssl->options.isClosed = 1;
  d2:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  d6:	f043 0310 	orr.w	r3, r3, #16
  da:	e7f7      	b.n	cc <GetInputData+0xcc>
        if (in == WANT_READ)
  dc:	f46f 73a1 	mvn.w	r3, #322	; 0x142
  e0:	4298      	cmp	r0, r3
  e2:	d1aa      	bne.n	3a <GetInputData+0x3a>
  e4:	e7aa      	b.n	3c <GetInputData+0x3c>
        if (in > inSz) {
  e6:	4285      	cmp	r5, r0
  e8:	db0f      	blt.n	10a <GetInputData+0x10a>
        ssl->buffers.inputBuffer.length += in;
  ea:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
  ee:	4403      	add	r3, r0
    } while (ssl->buffers.inputBuffer.length < size);
  f0:	42bb      	cmp	r3, r7
        ssl->buffers.inputBuffer.length += in;
  f2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        inSz -= in;
  f6:	eba5 0500 	sub.w	r5, r5, r0
    } while (ssl->buffers.inputBuffer.length < size);
  fa:	d398      	bcc.n	2e <GetInputData+0x2e>
    return 0;
  fc:	2000      	movs	r0, #0
  fe:	e79d      	b.n	3c <GetInputData+0x3c>
        return BUFFER_ERROR;
 100:	4804      	ldr	r0, [pc, #16]	; (114 <GetInputData+0x114>)
 102:	e79b      	b.n	3c <GetInputData+0x3c>
            return WANT_READ;
 104:	f46f 70a1 	mvn.w	r0, #322	; 0x142
 108:	e798      	b.n	3c <GetInputData+0x3c>
            return RECV_OVERFLOW_E;
 10a:	4803      	ldr	r0, [pc, #12]	; (118 <GetInputData+0x118>)
 10c:	e796      	b.n	3c <GetInputData+0x3c>
 10e:	bf00      	nop
 110:	fffffecc 	.word	0xfffffecc
 114:	fffffeb8 	.word	0xfffffeb8
 118:	fffffe88 	.word	0xfffffe88

Disassembly of section .text.CheckAvailableSize:

00000000 <CheckAvailableSize>:
    if (size < 0) {
   0:	2900      	cmp	r1, #0
{
   2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   4:	4604      	mov	r4, r0
    if (size < 0) {
   6:	db3b      	blt.n	80 <CheckAvailableSize+0x80>
    if ((ssl->buffers.outputBuffer.bufferSize -
   8:	e9d0 7328 	ldrd	r7, r3, [r0, #160]	; 0xa0
   c:	441f      	add	r7, r3
             ssl->buffers.outputBuffer.length -
   e:	f8d0 30a8 	ldr.w	r3, [r0, #168]	; 0xa8
  12:	1bdb      	subs	r3, r3, r7
    if ((ssl->buffers.outputBuffer.bufferSize -
  14:	428b      	cmp	r3, r1
  16:	d231      	bcs.n	7c <CheckAvailableSize+0x7c>
    byte  hdrSz = ssl->options.dtls ? DTLS_RECORD_HEADER_SZ :
  18:	f890 3272 	ldrb.w	r3, [r0, #626]	; 0x272
  1c:	f013 0f04 	tst.w	r3, #4
  20:	bf14      	ite	ne
  22:	250d      	movne	r5, #13
  24:	2505      	moveq	r5, #5
    int newSz = size + ssl->buffers.outputBuffer.idx +
  26:	440f      	add	r7, r1
    byte align = WOLFSSL_GENERAL_ALIGNMENT;
  28:	2604      	movs	r6, #4
        align *= 2;
  2a:	0076      	lsls	r6, r6, #1
  2c:	b2f6      	uxtb	r6, r6
    while (align < hdrSz)
  2e:	42ae      	cmp	r6, r5
  30:	d3fb      	bcc.n	2a <CheckAvailableSize+0x2a>
    tmp = (byte*)XMALLOC(newSz + align, ssl->heap, DYNAMIC_TYPE_OUT_BUFFER);
  32:	19b8      	adds	r0, r7, r6
  34:	f7ff fffe 	bl	0 <malloc>
    if (tmp == NULL)
  38:	b328      	cbz	r0, 86 <CheckAvailableSize+0x86>
    if (ssl->buffers.outputBuffer.length)
  3a:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
        tmp += align - hdrSz;
  3e:	1b76      	subs	r6, r6, r5
  40:	1985      	adds	r5, r0, r6
    if (ssl->buffers.outputBuffer.length)
  42:	b13b      	cbz	r3, 54 <CheckAvailableSize+0x54>
        XMEMCPY(tmp, ssl->buffers.outputBuffer.buffer,
  44:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
  48:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
  4c:	441a      	add	r2, r3
  4e:	4628      	mov	r0, r5
  50:	f7ff fffe 	bl	0 <memcpy>
    if (ssl->buffers.outputBuffer.dynamicFlag) {
  54:	f894 30ac 	ldrb.w	r3, [r4, #172]	; 0xac
  58:	b13b      	cbz	r3, 6a <CheckAvailableSize+0x6a>
        XFREE(ssl->buffers.outputBuffer.buffer -
  5a:	f894 30ad 	ldrb.w	r3, [r4, #173]	; 0xad
  5e:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
  62:	1ac0      	subs	r0, r0, r3
  64:	d001      	beq.n	6a <CheckAvailableSize+0x6a>
  66:	f7ff fffe 	bl	0 <free>
    ssl->buffers.outputBuffer.dynamicFlag = 1;
  6a:	2301      	movs	r3, #1
  6c:	f884 30ac 	strb.w	r3, [r4, #172]	; 0xac
        ssl->buffers.outputBuffer.offset = align - hdrSz;
  70:	f884 60ad 	strb.w	r6, [r4, #173]	; 0xad
    ssl->buffers.outputBuffer.buffer = tmp;
  74:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
    ssl->buffers.outputBuffer.bufferSize = newSz;
  78:	f8c4 70a8 	str.w	r7, [r4, #168]	; 0xa8
    return 0;
  7c:	2000      	movs	r0, #0
  7e:	e001      	b.n	84 <CheckAvailableSize+0x84>
        return BAD_FUNC_ARG;
  80:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return MEMORY_E;
  86:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  8a:	e7fb      	b.n	84 <CheckAvailableSize+0x84>

Disassembly of section .text.MatchDomainName:

00000000 <MatchDomainName>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (pattern == NULL || str == NULL || len <= 0)
   2:	2800      	cmp	r0, #0
   4:	d03a      	beq.n	7c <MatchDomainName+0x7c>
   6:	2a00      	cmp	r2, #0
   8:	d03d      	beq.n	86 <MatchDomainName+0x86>
   a:	2900      	cmp	r1, #0
   c:	dd3b      	ble.n	86 <MatchDomainName+0x86>
        char p = (char)XTOLOWER((unsigned char)*pattern++);
   e:	4d24      	ldr	r5, [pc, #144]	; (a0 <MatchDomainName+0xa0>)
  10:	f810 4b01 	ldrb.w	r4, [r0], #1
  14:	5d63      	ldrb	r3, [r4, r5]
  16:	f003 0303 	and.w	r3, r3, #3
  1a:	2b01      	cmp	r3, #1
  1c:	bf08      	it	eq
  1e:	3420      	addeq	r4, #32
        if (p == '\0')
  20:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
            if (p != (char)XTOLOWER((unsigned char) *str))
  24:	7813      	ldrb	r3, [r2, #0]
        if (p == '\0')
  26:	d024      	beq.n	72 <MatchDomainName+0x72>
        if (p == '*') {
  28:	5cee      	ldrb	r6, [r5, r3]
  2a:	2c2a      	cmp	r4, #42	; 0x2a
  2c:	f006 0603 	and.w	r6, r6, #3
  30:	d12b      	bne.n	8a <MatchDomainName+0x8a>
  32:	4606      	mov	r6, r0
            while (--len > 0) {
  34:	3901      	subs	r1, #1
  36:	4630      	mov	r0, r6
  38:	d101      	bne.n	3e <MatchDomainName+0x3e>
                p = '\0';
  3a:	460c      	mov	r4, r1
  3c:	e00b      	b.n	56 <MatchDomainName+0x56>
                p = (char)XTOLOWER((unsigned char)*pattern);
  3e:	f816 3b01 	ldrb.w	r3, [r6], #1
  42:	5ce8      	ldrb	r0, [r5, r3]
  44:	f000 0003 	and.w	r0, r0, #3
  48:	2801      	cmp	r0, #1
  4a:	bf08      	it	eq
  4c:	3320      	addeq	r3, #32
  4e:	b2dc      	uxtb	r4, r3
                if (p != '*')
  50:	2c2a      	cmp	r4, #42	; 0x2a
                pattern++;
  52:	4630      	mov	r0, r6
                if (p != '*')
  54:	d0ee      	beq.n	34 <MatchDomainName+0x34>
  56:	4616      	mov	r6, r2
  58:	4632      	mov	r2, r6
            while ( (s = (char)XTOLOWER((unsigned char) *str)) != '\0') {
  5a:	f816 3b01 	ldrb.w	r3, [r6], #1
  5e:	5cef      	ldrb	r7, [r5, r3]
  60:	f007 0703 	and.w	r7, r7, #3
  64:	2f01      	cmp	r7, #1
  66:	bf08      	it	eq
  68:	3320      	addeq	r3, #32
  6a:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  6e:	d106      	bne.n	7e <MatchDomainName+0x7e>
        if (len > 0) {
  70:	b989      	cbnz	r1, 96 <MatchDomainName+0x96>
    if (*str == '\0' && len == 0) {
  72:	7813      	ldrb	r3, [r2, #0]
  74:	b93b      	cbnz	r3, 86 <MatchDomainName+0x86>
  76:	fab1 f081 	clz	r0, r1
  7a:	0940      	lsrs	r0, r0, #5
}
  7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                if (s == p)
  7e:	42a3      	cmp	r3, r4
  80:	d0f6      	beq.n	70 <MatchDomainName+0x70>
                if (s == '.')
  82:	2b2e      	cmp	r3, #46	; 0x2e
  84:	d1e8      	bne.n	58 <MatchDomainName+0x58>
        return 0;
  86:	2000      	movs	r0, #0
  88:	e7f8      	b.n	7c <MatchDomainName+0x7c>
            if (p != (char)XTOLOWER((unsigned char) *str))
  8a:	2e01      	cmp	r6, #1
  8c:	bf08      	it	eq
  8e:	3320      	addeq	r3, #32
  90:	b2db      	uxtb	r3, r3
  92:	429c      	cmp	r4, r3
  94:	d1f7      	bne.n	86 <MatchDomainName+0x86>
    while (len > 0) {
  96:	3901      	subs	r1, #1
            str++;
  98:	f102 0201 	add.w	r2, r2, #1
    while (len > 0) {
  9c:	d1b8      	bne.n	10 <MatchDomainName+0x10>
  9e:	e7e8      	b.n	72 <MatchDomainName+0x72>
  a0:	00000001 	.word	0x00000001

Disassembly of section .text.CheckForAltNames:

00000000 <CheckForAltNames>:
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	460f      	mov	r7, r1
   6:	4615      	mov	r5, r2
    if (dCert)
   8:	4604      	mov	r4, r0
   a:	b100      	cbz	r0, e <CheckForAltNames+0xe>
        altName = dCert->altNames;
   c:	6a44      	ldr	r4, [r0, #36]	; 0x24
    if (checkCN != NULL) {
   e:	b11d      	cbz	r5, 18 <CheckForAltNames+0x18>
        *checkCN = (altName == NULL) ? 1 : 0;
  10:	fab4 f384 	clz	r3, r4
  14:	095b      	lsrs	r3, r3, #5
  16:	602b      	str	r3, [r5, #0]
            match = -1;
  18:	2600      	movs	r6, #0
    while (altName) {
  1a:	b914      	cbnz	r4, 22 <CheckForAltNames+0x22>
}
  1c:	4630      	mov	r0, r6
  1e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            len = altName->len;
  22:	e9d4 9802 	ldrd	r9, r8, [r4, #8]
        if (MatchDomainName(buf, len, domain)) {
  26:	463a      	mov	r2, r7
  28:	4649      	mov	r1, r9
  2a:	4640      	mov	r0, r8
  2c:	f7ff fffe 	bl	0 <CheckForAltNames>
  30:	b120      	cbz	r0, 3c <CheckForAltNames+0x3c>
            if (checkCN != NULL) {
  32:	b10d      	cbz	r5, 38 <CheckForAltNames+0x38>
                *checkCN = 0;
  34:	2300      	movs	r3, #0
  36:	602b      	str	r3, [r5, #0]
            match = 1;
  38:	2601      	movs	r6, #1
    return match;
  3a:	e7ef      	b.n	1c <CheckForAltNames+0x1c>
        else if (buf && (len >=1) && (buf[0] == '*')) {
  3c:	f1b8 0f00 	cmp.w	r8, #0
  40:	d008      	beq.n	54 <CheckForAltNames+0x54>
  42:	f1b9 0f00 	cmp.w	r9, #0
  46:	d005      	beq.n	54 <CheckForAltNames+0x54>
  48:	f898 3000 	ldrb.w	r3, [r8]
            match = -1;
  4c:	2b2a      	cmp	r3, #42	; 0x2a
  4e:	bf08      	it	eq
  50:	f04f 36ff 	moveq.w	r6, #4294967295	; 0xffffffff
        altName = altName->next;
  54:	6824      	ldr	r4, [r4, #0]
  56:	e7e0      	b.n	1a <CheckForAltNames+0x1a>

Disassembly of section .text.CheckHostName:

00000000 <CheckHostName>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if (CheckForAltNames(dCert, domainName, &checkCN) != 1) {
   2:	aa01      	add	r2, sp, #4
{
   4:	4605      	mov	r5, r0
   6:	460e      	mov	r6, r1
    if (CheckForAltNames(dCert, domainName, &checkCN) != 1) {
   8:	f7ff fffe 	bl	0 <CheckHostName>
    if (checkCN == 1) {
   c:	9b01      	ldr	r3, [sp, #4]
        ret = 0;
   e:	4c08      	ldr	r4, [pc, #32]	; (30 <CheckHostName+0x30>)
  10:	2801      	cmp	r0, #1
  12:	bf08      	it	eq
  14:	2400      	moveq	r4, #0
    if (checkCN == 1) {
  16:	2b01      	cmp	r3, #1
  18:	d107      	bne.n	2a <CheckHostName+0x2a>
        if (MatchDomainName(dCert->subjectCN, dCert->subjectCNLen,
  1a:	e9d5 0119 	ldrd	r0, r1, [r5, #100]	; 0x64
  1e:	4632      	mov	r2, r6
  20:	f7ff fffe 	bl	0 <CheckHostName>
            ret = 0;
  24:	2801      	cmp	r0, #1
  26:	bf08      	it	eq
  28:	2400      	moveq	r4, #0
}
  2a:	4620      	mov	r0, r4
  2c:	b002      	add	sp, #8
  2e:	bd70      	pop	{r4, r5, r6, pc}
  30:	fffffebe 	.word	0xfffffebe

Disassembly of section .text.CheckIPAddr:

00000000 <CheckIPAddr>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4605      	mov	r5, r0
    return CheckHostName(dCert, ipasc, (size_t)XSTRLEN(ipasc));
   4:	4608      	mov	r0, r1
{
   6:	460c      	mov	r4, r1
    return CheckHostName(dCert, ipasc, (size_t)XSTRLEN(ipasc));
   8:	f7ff fffe 	bl	0 <strlen>
   c:	4621      	mov	r1, r4
   e:	4602      	mov	r2, r0
  10:	4628      	mov	r0, r5
}
  12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return CheckHostName(dCert, ipasc, (size_t)XSTRLEN(ipasc));
  16:	f7ff bffe 	b.w	0 <CheckIPAddr>

Disassembly of section .text.DoVerifyCallback:

00000000 <DoVerifyCallback>:
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	460e      	mov	r6, r1
   6:	4615      	mov	r5, r2
   8:	4698      	mov	r8, r3
    if (cm == NULL) {
   a:	4682      	mov	sl, r0
   c:	2800      	cmp	r0, #0
   e:	d075      	beq.n	fc <DoVerifyCallback+0xfc>
    if (ret == 0) {
  10:	b172      	cbz	r2, 30 <DoVerifyCallback+0x30>
        if ((ssl != NULL) && (!ssl->options.verifyNone)) {
  12:	b909      	cbnz	r1, 18 <DoVerifyCallback+0x18>
    int verify_ok = 0, use_cb = 0;
  14:	2700      	movs	r7, #0
  16:	e005      	b.n	24 <DoVerifyCallback+0x24>
        if ((ssl != NULL) && (!ssl->options.verifyNone)) {
  18:	f996 3270 	ldrsb.w	r3, [r6, #624]	; 0x270
  1c:	2b00      	cmp	r3, #0
  1e:	dbf9      	blt.n	14 <DoVerifyCallback+0x14>
    if ((use_cb && (ssl != NULL) && ((ssl->verifyCallback != NULL)
  20:	6a37      	ldr	r7, [r6, #32]
  22:	b93f      	cbnz	r7, 34 <DoVerifyCallback+0x34>
        || (cm->verifyCallback != NULL)
  24:	f8da 3040 	ldr.w	r3, [sl, #64]	; 0x40
  28:	b92b      	cbnz	r3, 36 <DoVerifyCallback+0x36>
}
  2a:	4628      	mov	r0, r5
  2c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        verify_ok = 1;
  30:	2701      	movs	r7, #1
  32:	e7f7      	b.n	24 <DoVerifyCallback+0x24>
    int verify_ok = 0, use_cb = 0;
  34:	2700      	movs	r7, #0
        store = (WOLFSSL_X509_STORE_CTX*)XMALLOC(
  36:	2030      	movs	r0, #48	; 0x30
  38:	f7ff fffe 	bl	0 <malloc>
        if (store == NULL) {
  3c:	4604      	mov	r4, r0
  3e:	b140      	cbz	r0, 52 <DoVerifyCallback+0x52>
        domain = (char*)XMALLOC(ASN_NAME_MAX, heap, DYNAMIC_TYPE_STRING);
  40:	f44f 7080 	mov.w	r0, #256	; 0x100
  44:	f7ff fffe 	bl	0 <malloc>
        if (domain == NULL) {
  48:	4681      	mov	r9, r0
  4a:	b928      	cbnz	r0, 58 <DoVerifyCallback+0x58>
            XFREE(store, heap, DYNAMIC_TYPE_X509_STORE);
  4c:	4620      	mov	r0, r4
  4e:	f7ff fffe 	bl	0 <free>
            return MEMORY_E;
  52:	f06f 057c 	mvn.w	r5, #124	; 0x7c
  56:	e7e8      	b.n	2a <DoVerifyCallback+0x2a>
        XMEMSET(store, 0, sizeof(WOLFSSL_X509_STORE_CTX));
  58:	2230      	movs	r2, #48	; 0x30
  5a:	2100      	movs	r1, #0
  5c:	4620      	mov	r0, r4
  5e:	f7ff fffe 	bl	0 <memset>
        domain[0] = '\0';
  62:	2300      	movs	r3, #0
  64:	f889 3000 	strb.w	r3, [r9]
        if (args->dCertInit && args->dCert && args->dCert->subjectCN) {
  68:	f898 3020 	ldrb.w	r3, [r8, #32]
  6c:	075b      	lsls	r3, r3, #29
  6e:	d50c      	bpl.n	8a <DoVerifyCallback+0x8a>
  70:	f8d8 3004 	ldr.w	r3, [r8, #4]
  74:	b14b      	cbz	r3, 8a <DoVerifyCallback+0x8a>
  76:	6e59      	ldr	r1, [r3, #100]	; 0x64
  78:	b139      	cbz	r1, 8a <DoVerifyCallback+0x8a>
            int subjectCNLen = args->dCert->subjectCNLen;
  7a:	f8d3 b068 	ldr.w	fp, [r3, #104]	; 0x68
            if (subjectCNLen > ASN_NAME_MAX-1)
  7e:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
  82:	dc21      	bgt.n	c8 <DoVerifyCallback+0xc8>
            if (subjectCNLen > 0) {
  84:	f1bb 0f00 	cmp.w	fp, #0
  88:	dc20      	bgt.n	cc <DoVerifyCallback+0xcc>
        store->error_depth = args->certIdx;
  8a:	f8d8 3018 	ldr.w	r3, [r8, #24]
  8e:	61e3      	str	r3, [r4, #28]
        store->discardSessionCerts = 0;
  90:	2300      	movs	r3, #0
        store->error = ret;
  92:	61a5      	str	r5, [r4, #24]
        store->discardSessionCerts = 0;
  94:	6223      	str	r3, [r4, #32]
        store->domain = domain;
  96:	f8c4 9010 	str.w	r9, [r4, #16]
        if (ssl != NULL) {
  9a:	b316      	cbz	r6, e2 <DoVerifyCallback+0xe2>
            if (ssl->verifyCbCtx != NULL) {
  9c:	69f3      	ldr	r3, [r6, #28]
  9e:	b1eb      	cbz	r3, dc <DoVerifyCallback+0xdc>
                store->userCtx = ssl->ctx->verifyCbCtx;
  a0:	6163      	str	r3, [r4, #20]
        store->certs = args->certs;
  a2:	f8d8 3000 	ldr.w	r3, [r8]
  a6:	62a3      	str	r3, [r4, #40]	; 0x28
        store->totalCerts = args->totalCerts;
  a8:	f8d8 3010 	ldr.w	r3, [r8, #16]
  ac:	6263      	str	r3, [r4, #36]	; 0x24
        if (cm->verifyCallback != NULL) {
  ae:	f8da 3040 	ldr.w	r3, [sl, #64]	; 0x40
  b2:	b363      	cbz	r3, 10e <DoVerifyCallback+0x10e>
            store->userCtx = cm;
  b4:	f8c4 a014 	str.w	sl, [r4, #20]
            if (cm->verifyCallback(verify_ok, store)) {
  b8:	4621      	mov	r1, r4
  ba:	4638      	mov	r0, r7
  bc:	4798      	blx	r3
  be:	bb28      	cbnz	r0, 10c <DoVerifyCallback+0x10c>
        if (ssl != NULL) {
  c0:	b38e      	cbz	r6, 126 <DoVerifyCallback+0x126>
                verifyFail = 1;
  c2:	f04f 0a01 	mov.w	sl, #1
  c6:	e026      	b.n	116 <DoVerifyCallback+0x116>
                subjectCNLen = ASN_NAME_MAX-1;
  c8:	f04f 0bff 	mov.w	fp, #255	; 0xff
                XMEMCPY(domain, args->dCert->subjectCN, subjectCNLen);
  cc:	465a      	mov	r2, fp
  ce:	4648      	mov	r0, r9
  d0:	f7ff fffe 	bl	0 <memcpy>
                domain[subjectCNLen] = '\0';
  d4:	2300      	movs	r3, #0
  d6:	f809 300b 	strb.w	r3, [r9, fp]
  da:	e7d6      	b.n	8a <DoVerifyCallback+0x8a>
                store->userCtx = ssl->ctx->verifyCbCtx;
  dc:	6833      	ldr	r3, [r6, #0]
  de:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  e0:	e7de      	b.n	a0 <DoVerifyCallback+0xa0>
            store->userCtx = cm;
  e2:	f8c4 a014 	str.w	sl, [r4, #20]
  e6:	e7dc      	b.n	a2 <DoVerifyCallback+0xa2>
        if (verifyFail) {
  e8:	f1ba 0f00 	cmp.w	sl, #0
  ec:	d11b      	bne.n	126 <DoVerifyCallback+0x126>
        XFREE(domain, heap, DYNAMIC_TYPE_STRING);
  ee:	4648      	mov	r0, r9
  f0:	f7ff fffe 	bl	0 <free>
        XFREE(store, heap, DYNAMIC_TYPE_X509_STORE);
  f4:	4620      	mov	r0, r4
  f6:	f7ff fffe 	bl	0 <free>
  fa:	e796      	b.n	2a <DoVerifyCallback+0x2a>
        return BAD_FUNC_ARG;
  fc:	f06f 05ac 	mvn.w	r5, #172	; 0xac
 100:	e793      	b.n	2a <DoVerifyCallback+0x2a>
        if (verifyFail) {
 102:	f1ba 0f00 	cmp.w	sl, #0
 106:	d10f      	bne.n	128 <DoVerifyCallback+0x128>
 108:	4655      	mov	r5, sl
 10a:	e7f0      	b.n	ee <DoVerifyCallback+0xee>
                    ret = 0;
 10c:	2500      	movs	r5, #0
        if (ssl != NULL) {
 10e:	2e00      	cmp	r6, #0
 110:	d0ed      	beq.n	ee <DoVerifyCallback+0xee>
 112:	f04f 0a00 	mov.w	sl, #0
            if (ssl->verifyCallback) {
 116:	6a33      	ldr	r3, [r6, #32]
 118:	2b00      	cmp	r3, #0
 11a:	d0e5      	beq.n	e8 <DoVerifyCallback+0xe8>
                if (ssl->verifyCallback(verify_ok, store)) {
 11c:	4621      	mov	r1, r4
 11e:	4638      	mov	r0, r7
 120:	4798      	blx	r3
 122:	2800      	cmp	r0, #0
 124:	d1ed      	bne.n	102 <DoVerifyCallback+0x102>
            if (ret == 0) {
 126:	b90d      	cbnz	r5, 12c <DoVerifyCallback+0x12c>
                ret = VERIFY_CERT_ERROR;
 128:	f46f 75a4 	mvn.w	r5, #328	; 0x148
            args->verifyErr = 1;
 12c:	f898 3020 	ldrb.w	r3, [r8, #32]
 130:	f043 0302 	orr.w	r3, r3, #2
 134:	f888 3020 	strb.w	r3, [r8, #32]
 138:	e7d9      	b.n	ee <DoVerifyCallback+0xee>

Disassembly of section .text.DoFinished:

00000000 <DoFinished>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4604      	mov	r4, r0
   4:	4617      	mov	r7, r2
    word32 finishedSz = (ssl->options.tls ? TLS_FINISHED_SZ : FINISHED_SZ);
   6:	f894 2271 	ldrb.w	r2, [r4, #625]	; 0x271
   a:	f012 0f40 	tst.w	r2, #64	; 0x40
   e:	bf14      	ite	ne
  10:	250c      	movne	r5, #12
  12:	2524      	moveq	r5, #36	; 0x24
    if (finishedSz != size)
  14:	429d      	cmp	r5, r3
{
  16:	4608      	mov	r0, r1
  18:	461e      	mov	r6, r3
  1a:	9906      	ldr	r1, [sp, #24]
    if (finishedSz != size)
  1c:	d133      	bne.n	86 <DoFinished+0x86>
    if (size != totalSz) {
  1e:	428d      	cmp	r5, r1
            if (*inOutIdx + size + ssl->keys.padSz > totalSz)
  20:	683b      	ldr	r3, [r7, #0]
    if (size != totalSz) {
  22:	d005      	beq.n	30 <DoFinished+0x30>
            if (*inOutIdx + size + ssl->keys.padSz > totalSz)
  24:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
  28:	441d      	add	r5, r3
  2a:	4415      	add	r5, r2
  2c:	428d      	cmp	r5, r1
  2e:	d82c      	bhi.n	8a <DoFinished+0x8a>
    if (sniff == NO_SNIFF) {
  30:	9a07      	ldr	r2, [sp, #28]
  32:	b1aa      	cbz	r2, 60 <DoFinished+0x60>
    *inOutIdx += size + ssl->keys.padSz;
  34:	683b      	ldr	r3, [r7, #0]
  36:	4433      	add	r3, r6
  38:	f8d4 6264 	ldr.w	r6, [r4, #612]	; 0x264
  3c:	4433      	add	r3, r6
  3e:	603b      	str	r3, [r7, #0]
    if (ssl->options.side == WOLFSSL_CLIENT_END) {
  40:	f894 2270 	ldrb.w	r2, [r4, #624]	; 0x270
        if (!ssl->options.resuming) {
  44:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
    if (ssl->options.side == WOLFSSL_CLIENT_END) {
  48:	f002 0230 	and.w	r2, r2, #48	; 0x30
  4c:	2a10      	cmp	r2, #16
        if (!ssl->options.resuming) {
  4e:	f003 0308 	and.w	r3, r3, #8
    if (ssl->options.side == WOLFSSL_CLIENT_END) {
  52:	d10e      	bne.n	72 <DoFinished+0x72>
        ssl->options.serverState = SERVER_FINISHED_COMPLETE;
  54:	220a      	movs	r2, #10
  56:	f884 227c 	strb.w	r2, [r4, #636]	; 0x27c
        if (!ssl->options.resuming) {
  5a:	b17b      	cbz	r3, 7c <DoFinished+0x7c>
    return 0;
  5c:	2000      	movs	r0, #0
}
  5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (XMEMCMP(input + *inOutIdx, &ssl->hsHashes->verifyHashes,size) != 0){
  60:	68e1      	ldr	r1, [r4, #12]
  62:	4632      	mov	r2, r6
  64:	4418      	add	r0, r3
  66:	f7ff fffe 	bl	0 <memcmp>
  6a:	2800      	cmp	r0, #0
  6c:	d0e2      	beq.n	34 <DoFinished+0x34>
            return VERIFY_FINISHED_ERROR;
  6e:	4808      	ldr	r0, [pc, #32]	; (90 <DoFinished+0x90>)
  70:	e7f5      	b.n	5e <DoFinished+0x5e>
        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;
  72:	220f      	movs	r2, #15
  74:	f884 227d 	strb.w	r2, [r4, #637]	; 0x27d
        if (ssl->options.resuming) {
  78:	2b00      	cmp	r3, #0
  7a:	d0ef      	beq.n	5c <DoFinished+0x5c>
            ssl->options.handShakeState = HANDSHAKE_DONE;
  7c:	f44f 7388 	mov.w	r3, #272	; 0x110
  80:	f8a4 327e 	strh.w	r3, [r4, #638]	; 0x27e
  84:	e7ea      	b.n	5c <DoFinished+0x5c>
        return BUFFER_ERROR;
  86:	4803      	ldr	r0, [pc, #12]	; (94 <DoFinished+0x94>)
  88:	e7e9      	b.n	5e <DoFinished+0x5e>
                return BUFFER_E;
  8a:	f06f 0083 	mvn.w	r0, #131	; 0x83
  8e:	e7e6      	b.n	5e <DoFinished+0x5e>
  90:	fffffed0 	.word	0xfffffed0
  94:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.SendFatalAlertOnly:

00000000 <SendFatalAlertOnly>:
}
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.TimingPadVerify:

00000000 <TimingPadVerify>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b0ad      	sub	sp, #180	; 0xb4
   6:	4688      	mov	r8, r1
   8:	f8dd 90d8 	ldr.w	r9, [sp, #216]	; 0xd8
    int checkSz = sz - 1;
   c:	f109 37ff 	add.w	r7, r9, #4294967295	; 0xffffffff
{
  10:	4605      	mov	r5, r0
    byte paddingSz = data[sz - 1];
  12:	5dc8      	ldrb	r0, [r1, r7]
    byte good = ctMaskGT(paddingSz, sz - 1 - macSz);
  14:	1af9      	subs	r1, r7, r3

#ifndef WOLFSSL_NO_CT_OPS
/* Constant time - mask set when a > b. */
WC_MISC_STATIC WC_INLINE byte ctMaskGT(int a, int b)
{
    return (byte)((((word32)a - (word32)b - 1) >> 31) - 1);
  16:	43c9      	mvns	r1, r1
  18:	4401      	add	r1, r0
  1a:	0fc9      	lsrs	r1, r1, #31
  1c:	3901      	subs	r1, #1
  1e:	b2c9      	uxtb	r1, r1
  20:	2fff      	cmp	r7, #255	; 0xff
  22:	46bc      	mov	ip, r7
  24:	9105      	str	r1, [sp, #20]
    if (checkSz > TLS_MAX_PAD_SZ)
  26:	bfa8      	it	ge
  28:	f04f 0cff 	movge.w	ip, #255	; 0xff
    for (i = 0; i < checkSz; i++) {
  2c:	eb08 0a09 	add.w	sl, r8, r9
  30:	2400      	movs	r4, #0
  32:	45a4      	cmp	ip, r4
  34:	dc41      	bgt.n	ba <TimingPadVerify+0xba>
    ret = ssl->hmac(ssl, verify, input, pLen - macSz - padLen - 1, padLen,
  36:	2101      	movs	r1, #1
  38:	e9cd 1102 	strd	r1, r1, [sp, #8]
  3c:	9937      	ldr	r1, [sp, #220]	; 0xdc
  3e:	e9cd 2100 	strd	r2, r1, [sp]
  42:	eba9 0303 	sub.w	r3, r9, r3
  46:	1a9b      	subs	r3, r3, r2
  48:	6cec      	ldr	r4, [r5, #76]	; 0x4c
  4a:	3b01      	subs	r3, #1
  4c:	4642      	mov	r2, r8
  4e:	a90c      	add	r1, sp, #48	; 0x30
  50:	4628      	mov	r0, r5
  52:	47a0      	blx	r4
    good |= MaskMac(input, pLen, ssl->specs.hash_size, verify);
  54:	f895 414d 	ldrb.w	r4, [r5, #333]	; 0x14d
    int macEnd = sz - 1 - data[sz - 1];
  58:	f818 3007 	ldrb.w	r3, [r8, r7]
    ret = ssl->hmac(ssl, verify, input, pLen - macSz - padLen - 1, padLen,
  5c:	9007      	str	r0, [sp, #28]
    int scanStart = sz - 1 - TLS_MAX_PAD_SZ - macSz;
  5e:	f5a9 7680 	sub.w	r6, r9, #256	; 0x100
  62:	1b36      	subs	r6, r6, r4
    int macEnd = sz - 1 - data[sz - 1];
  64:	1aff      	subs	r7, r7, r3
}

/* Constant time - mask set when a >= b. */
WC_MISC_STATIC WC_INLINE int ctMaskIntGTE(int a, int b)
{
    return (int)((((word32)a - (word32)b) >> 31) - 1);
  66:	0ff3      	lsrs	r3, r6, #31
    int macStart = macEnd - macSz;
  68:	eba7 0b04 	sub.w	fp, r7, r4
  6c:	3b01      	subs	r3, #1
    scanStart &= ctMaskIntGTE(scanStart, 0);
  6e:	401e      	ands	r6, r3
  70:	ea4f 73db 	mov.w	r3, fp, lsr #31
  74:	3b01      	subs	r3, #1
    macStart &= ctMaskIntGTE(macStart, 0);
  76:	ea0b 0b03 	and.w	fp, fp, r3
    if ((macSz & (macSz - 1)) == 0)
  7a:	1e63      	subs	r3, r4, #1
  7c:	ea14 0a03 	ands.w	sl, r4, r3
  80:	9308      	str	r3, [sp, #32]
  82:	d128      	bne.n	d6 <TimingPadVerify+0xd6>
        r = (macSz - (scanStart - macStart)) & (macSz - 1);
  84:	eba6 050b 	sub.w	r5, r6, fp
  88:	1b65      	subs	r5, r4, r5
  8a:	401d      	ands	r5, r3
    XMEMSET(mac, 0, macSz);
  8c:	4622      	mov	r2, r4
  8e:	2100      	movs	r1, #0
  90:	a81c      	add	r0, sp, #112	; 0x70
  92:	f7ff fffe 	bl	0 <memset>
    for (i = scanStart; i < sz; i += macSz) {
  96:	eba7 0309 	sub.w	r3, r7, r9
  9a:	eba9 0006 	sub.w	r0, r9, r6
  9e:	930b      	str	r3, [sp, #44]	; 0x2c
  a0:	45b1      	cmp	r9, r6
  a2:	dd46      	ble.n	132 <TimingPadVerify+0x132>
  a4:	eb08 0206 	add.w	r2, r8, r6
  a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  aa:	9206      	str	r2, [sp, #24]
    return (byte)((((word32)a - (word32)b) >> 31) - 1);
  ac:	eba6 020b 	sub.w	r2, r6, fp
  b0:	4403      	add	r3, r0
  b2:	af1c      	add	r7, sp, #112	; 0x70
        for (j = 0; j < macSz && j + i < sz; j++) {
  b4:	2100      	movs	r1, #0
  b6:	920a      	str	r2, [sp, #40]	; 0x28
  b8:	e032      	b.n	120 <TimingPadVerify+0x120>
}

/* Constant time - mask set when a <= b. */
WC_MISC_STATIC WC_INLINE byte ctMaskLTE(int a, int b)
{
    return (byte)((((word32)b - (word32)a) >> 31) - 1);
  ba:	1b01      	subs	r1, r0, r4
        good |= mask & (data[sz - 1 - i] ^ paddingSz);
  bc:	f81a ed01 	ldrb.w	lr, [sl, #-1]!
  c0:	9e05      	ldr	r6, [sp, #20]
  c2:	0fc9      	lsrs	r1, r1, #31
  c4:	3901      	subs	r1, #1
  c6:	ea80 0e0e 	eor.w	lr, r0, lr
  ca:	ea01 010e 	and.w	r1, r1, lr
  ce:	430e      	orrs	r6, r1
  d0:	9605      	str	r6, [sp, #20]
    for (i = 0; i < checkSz; i++) {
  d2:	3401      	adds	r4, #1
  d4:	e7ad      	b.n	32 <TimingPadVerify+0x32>
    else if (macSz == WC_SHA_DIGEST_SIZE)
  d6:	2c14      	cmp	r4, #20
        r = (macSz - (scanStart - macStart)) % WC_SHA_DIGEST_SIZE;
  d8:	bf05      	ittet	eq
  da:	eba6 050b 	subeq.w	r5, r6, fp
  de:	f1c5 0514 	rsbeq	r5, r5, #20
    int r = 0;
  e2:	2500      	movne	r5, #0
        r = (macSz - (scanStart - macStart)) % WC_SHA_DIGEST_SIZE;
  e4:	fb95 f2f4 	sdiveq	r2, r5, r4
  e8:	bf08      	it	eq
  ea:	fb04 5512 	mlseq	r5, r4, r2, r5
  ee:	e7cd      	b.n	8c <TimingPadVerify+0x8c>
            mac[j] |= started & notEnded & data[i + j];
  f0:	783a      	ldrb	r2, [r7, #0]
  f2:	9209      	str	r2, [sp, #36]	; 0x24
  f4:	9a06      	ldr	r2, [sp, #24]
  f6:	f812 cb01 	ldrb.w	ip, [r2], #1
  fa:	9206      	str	r2, [sp, #24]
    return (byte)((((word32)a - (word32)b) >> 31) - 1);
  fc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    return (byte)((((word32)b - (word32)a - 1) >> 31) - 1);
  fe:	ea4f 7ed3 	mov.w	lr, r3, lsr #31
    return (byte)((((word32)a - (word32)b) >> 31) - 1);
 102:	440a      	add	r2, r1
 104:	0fd2      	lsrs	r2, r2, #31
    return (byte)((((word32)b - (word32)a - 1) >> 31) - 1);
 106:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
    return (byte)((((word32)a - (word32)b) >> 31) - 1);
 10a:	3a01      	subs	r2, #1
 10c:	ea0c 0c0e 	and.w	ip, ip, lr
 110:	ea02 0c0c 	and.w	ip, r2, ip
 114:	9a09      	ldr	r2, [sp, #36]	; 0x24
 116:	ea42 0c0c 	orr.w	ip, r2, ip
 11a:	f807 cb01 	strb.w	ip, [r7], #1
        for (j = 0; j < macSz && j + i < sz; j++) {
 11e:	3101      	adds	r1, #1
 120:	428c      	cmp	r4, r1
 122:	dd03      	ble.n	12c <TimingPadVerify+0x12c>
 124:	4281      	cmp	r1, r0
 126:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
 12a:	d1e1      	bne.n	f0 <TimingPadVerify+0xf0>
    for (i = scanStart; i < sz; i += macSz) {
 12c:	4426      	add	r6, r4
 12e:	1b00      	subs	r0, r0, r4
 130:	e7b6      	b.n	a0 <TimingPadVerify+0xa0>
    if ((macSz & (macSz - 1)) == 0) {
 132:	f1ba 0f00 	cmp.w	sl, #0
 136:	d12a      	bne.n	18e <TimingPadVerify+0x18e>
 138:	ae0c      	add	r6, sp, #48	; 0x30
    unsigned char good = 0;
 13a:	4652      	mov	r2, sl
        for (i = 0; i < macSz; i++)
 13c:	4554      	cmp	r4, sl
 13e:	dc15      	bgt.n	16c <TimingPadVerify+0x16c>
    good |= MaskMac(input, pLen, ssl->specs.hash_size, verify);
 140:	9b05      	ldr	r3, [sp, #20]
 142:	431a      	orrs	r2, r3
    good = (byte)~(word32)good;
 144:	43d2      	mvns	r2, r2
    good &= good >> 4;
 146:	f3c2 1303 	ubfx	r3, r2, #4, #4
 14a:	401a      	ands	r2, r3
    good &= good >> 2;
 14c:	ea02 0292 	and.w	r2, r2, r2, lsr #2
    ret -= 1 - good;
 150:	ea12 0352 	ands.w	r3, r2, r2, lsr #1
    if (ret != 0) {
 154:	9a07      	ldr	r2, [sp, #28]
    ret -= 1 - good;
 156:	bf0c      	ite	eq
 158:	2301      	moveq	r3, #1
 15a:	2300      	movne	r3, #0
    if (ret != 0) {
 15c:	4293      	cmp	r3, r2
}
 15e:	bf14      	ite	ne
 160:	f46f 7098 	mvnne.w	r0, #304	; 0x130
 164:	2000      	moveq	r0, #0
 166:	b02d      	add	sp, #180	; 0xb4
 168:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            good |= expMac[i] ^ mac[(i + r) & (macSz - 1)];
 16c:	9b08      	ldr	r3, [sp, #32]
 16e:	f816 0b01 	ldrb.w	r0, [r6], #1
 172:	eb0a 0105 	add.w	r1, sl, r5
 176:	4019      	ands	r1, r3
 178:	f101 03b0 	add.w	r3, r1, #176	; 0xb0
 17c:	eb0d 0103 	add.w	r1, sp, r3
        for (i = 0; i < macSz; i++)
 180:	f10a 0a01 	add.w	sl, sl, #1
            good |= expMac[i] ^ mac[(i + r) & (macSz - 1)];
 184:	f811 1c40 	ldrb.w	r1, [r1, #-64]
 188:	4041      	eors	r1, r0
 18a:	430a      	orrs	r2, r1
        for (i = 0; i < macSz; i++)
 18c:	e7d6      	b.n	13c <TimingPadVerify+0x13c>
    else if (macSz == WC_SHA_DIGEST_SIZE) {
 18e:	2c14      	cmp	r4, #20
 190:	d114      	bne.n	1bc <TimingPadVerify+0x1bc>
    unsigned char good = 0;
 192:	2200      	movs	r2, #0
 194:	ae0c      	add	r6, sp, #48	; 0x30
        for (i = 0; i < macSz; i++)
 196:	4611      	mov	r1, r2
            good |= expMac[i] ^ mac[(i + r) % WC_SHA_DIGEST_SIZE];
 198:	194b      	adds	r3, r1, r5
 19a:	fb93 f7f4 	sdiv	r7, r3, r4
 19e:	fb04 3317 	mls	r3, r4, r7, r3
 1a2:	33b0      	adds	r3, #176	; 0xb0
 1a4:	446b      	add	r3, sp
 1a6:	f816 0b01 	ldrb.w	r0, [r6], #1
 1aa:	f813 3c40 	ldrb.w	r3, [r3, #-64]
        for (i = 0; i < macSz; i++)
 1ae:	3101      	adds	r1, #1
            good |= expMac[i] ^ mac[(i + r) % WC_SHA_DIGEST_SIZE];
 1b0:	4043      	eors	r3, r0
        for (i = 0; i < macSz; i++)
 1b2:	2914      	cmp	r1, #20
            good |= expMac[i] ^ mac[(i + r) % WC_SHA_DIGEST_SIZE];
 1b4:	ea42 0203 	orr.w	r2, r2, r3
        for (i = 0; i < macSz; i++)
 1b8:	d1ee      	bne.n	198 <TimingPadVerify+0x198>
 1ba:	e7c1      	b.n	140 <TimingPadVerify+0x140>
    unsigned char good = 0;
 1bc:	2200      	movs	r2, #0
 1be:	e7bf      	b.n	140 <TimingPadVerify+0x140>

Disassembly of section .text.AlertTypeToString:

00000000 <AlertTypeToString>:
    switch (type) {
   0:	2878      	cmp	r0, #120	; 0x78
   2:	bf9a      	itte	ls
   4:	4b02      	ldrls	r3, [pc, #8]	; (10 <AlertTypeToString+0x10>)
   6:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
{
   a:	2000      	movhi	r0, #0
}
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	00000000 	.word	0x00000000

Disassembly of section .text.BuildCertHashes:

00000000 <BuildCertHashes>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (ssl->options.tls) {
   2:	f890 3271 	ldrb.w	r3, [r0, #625]	; 0x271
   6:	065b      	lsls	r3, r3, #25
{
   8:	4604      	mov	r4, r0
   a:	460d      	mov	r5, r1
    if (ssl->options.tls) {
   c:	d401      	bmi.n	12 <BuildCertHashes+0x12>
    int ret = 0;
   e:	2000      	movs	r0, #0
}
  10:	bd38      	pop	{r3, r4, r5, pc}
        ret = wc_ShaGetHash(&ssl->hsHashes->hashSha, hashes->sha);
  12:	68c0      	ldr	r0, [r0, #12]
  14:	30e8      	adds	r0, #232	; 0xe8
  16:	f7ff fffe 	bl	0 <wc_ShaGetHash>
        if (ret != 0)
  1a:	2800      	cmp	r0, #0
  1c:	d1f8      	bne.n	10 <BuildCertHashes+0x10>
        if (IsAtLeastTLSv1_2(ssl)) {
  1e:	4620      	mov	r0, r4
  20:	f7ff fffe 	bl	0 <BuildCertHashes>
  24:	2800      	cmp	r0, #0
  26:	d0f2      	beq.n	e <BuildCertHashes+0xe>
                ret = wc_Sha256GetHash(&ssl->hsHashes->hashSha256,
  28:	68e0      	ldr	r0, [r4, #12]
  2a:	f105 0114 	add.w	r1, r5, #20
  2e:	f500 70a6 	add.w	r0, r0, #332	; 0x14c
  32:	f7ff fffe 	bl	0 <wc_Sha256GetHash>
                if (ret != 0)
  36:	2800      	cmp	r0, #0
  38:	d1ea      	bne.n	10 <BuildCertHashes+0x10>
                ret = wc_Sha512GetHash(&ssl->hsHashes->hashSha512,
  3a:	68e0      	ldr	r0, [r4, #12]
  3c:	f105 0134 	add.w	r1, r5, #52	; 0x34
  40:	f500 70e0 	add.w	r0, r0, #448	; 0x1c0
}
  44:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                ret = wc_Sha512GetHash(&ssl->hsHashes->hashSha512,
  48:	f7ff bffe 	b.w	0 <wc_Sha512GetHash>

Disassembly of section .text.FreeBuildMsgArgs:

00000000 <FreeBuildMsgArgs>:
    if (args
   0:	b131      	cbz	r1, 10 <FreeBuildMsgArgs+0x10>
        if (args->iv && (args->iv != args->staticIvBuffer)) {
   2:	69c8      	ldr	r0, [r1, #28]
   4:	b120      	cbz	r0, 10 <FreeBuildMsgArgs+0x10>
   6:	3120      	adds	r1, #32
   8:	4288      	cmp	r0, r1
   a:	d001      	beq.n	10 <FreeBuildMsgArgs+0x10>
            XFREE(args->iv, ssl->heap, DYNAMIC_TYPE_SALT);
   c:	f7ff bffe 	b.w	0 <free>
}
  10:	4770      	bx	lr

Disassembly of section .text.BuildMessage:

00000000 <BuildMessage>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b093      	sub	sp, #76	; 0x4c
   6:	e9dd 8a1c 	ldrd	r8, sl, [sp, #112]	; 0x70
   a:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
   c:	460e      	mov	r6, r1
   e:	4615      	mov	r5, r2
  10:	4699      	mov	r9, r3
    if (ssl == NULL) {
  12:	4604      	mov	r4, r0
  14:	b110      	cbz	r0, 1c <BuildMessage+0x1c>
    if (!sizeOnly && (output == NULL || input == NULL) ) {
  16:	b927      	cbnz	r7, 22 <BuildMessage+0x22>
  18:	b101      	cbz	r1, 1c <BuildMessage+0x1c>
  1a:	b933      	cbnz	r3, 2a <BuildMessage+0x2a>
        return BAD_FUNC_ARG;
  1c:	f06f 05ac 	mvn.w	r5, #172	; 0xac
  20:	e038      	b.n	94 <BuildMessage+0x94>
    if (sizeOnly && (output || input) ) {
  22:	2900      	cmp	r1, #0
  24:	d1fa      	bne.n	1c <BuildMessage+0x1c>
  26:	2b00      	cmp	r3, #0
  28:	d1f8      	bne.n	1c <BuildMessage+0x1c>
        ssl->options.buildMsgState = BUILD_MSG_BEGIN;
  2a:	f04f 0b00 	mov.w	fp, #0
        XMEMSET(args, 0, sizeof(BuildMsgArgs));
  2e:	2230      	movs	r2, #48	; 0x30
        ssl->options.buildMsgState = BUILD_MSG_BEGIN;
  30:	f884 b284 	strb.w	fp, [r4, #644]	; 0x284
        XMEMSET(args, 0, sizeof(BuildMsgArgs));
  34:	4659      	mov	r1, fp
  36:	a806      	add	r0, sp, #24
  38:	f7ff fffe 	bl	0 <memset>
        args->idx  = RECORD_HEADER_SZ;
  3c:	2205      	movs	r2, #5
        args->headerSz = RECORD_HEADER_SZ;
  3e:	e9cd 2209 	strd	r2, r2, [sp, #36]	; 0x24
    switch (ssl->options.buildMsgState) {
  42:	f894 2284 	ldrb.w	r2, [r4, #644]	; 0x284
        args->sz = RECORD_HEADER_SZ + inSz;
  46:	f108 0305 	add.w	r3, r8, #5
  4a:	9307      	str	r3, [sp, #28]
    switch (ssl->options.buildMsgState) {
  4c:	2a04      	cmp	r2, #4
  4e:	d806      	bhi.n	5e <BuildMessage+0x5e>
  50:	e8df f012 	tbh	[pc, r2, lsl #1]
  54:	000c0009 	.word	0x000c0009
  58:	00de00cc 	.word	0x00de00cc
  5c:	00f8      	.short	0x00f8
    ssl->options.buildMsgState = BUILD_MSG_BEGIN;
  5e:	f884 b284 	strb.w	fp, [r4, #644]	; 0x284
        ret = args->sz;
  62:	9d07      	ldr	r5, [sp, #28]
  64:	e012      	b.n	8c <BuildMessage+0x8c>
            ssl->options.buildMsgState = BUILD_MSG_SIZE;
  66:	2201      	movs	r2, #1
  68:	f884 2284 	strb.w	r2, [r4, #644]	; 0x284
            args->digestSz = ssl->specs.hash_size;
  6c:	f894 014d 	ldrb.w	r0, [r4, #333]	; 0x14d
            if (ssl->specs.cipher_type == block) {
  70:	f894 2149 	ldrb.w	r2, [r4, #329]	; 0x149
            args->digestSz = ssl->specs.hash_size;
  74:	9006      	str	r0, [sp, #24]
            args->sz += args->digestSz;
  76:	4403      	add	r3, r0
            if (ssl->specs.cipher_type == block) {
  78:	2a01      	cmp	r2, #1
            args->sz += args->digestSz;
  7a:	9307      	str	r3, [sp, #28]
            if (ssl->specs.cipher_type == block) {
  7c:	d131      	bne.n	e2 <BuildMessage+0xe2>
                word32 blockSz = ssl->specs.block_size;
  7e:	f8b4 0144 	ldrh.w	r0, [r4, #324]	; 0x144
                if (blockSz == 0) {
  82:	b958      	cbnz	r0, 9c <BuildMessage+0x9c>
    ssl->options.buildMsgState = BUILD_MSG_BEGIN;
  84:	f884 0284 	strb.w	r0, [r4, #644]	; 0x284
                    ERROR_OUT(BAD_STATE_E, exit_buildmsg);
  88:	f06f 05bf 	mvn.w	r5, #191	; 0xbf
    FreeBuildMsgArgs(ssl, args);
  8c:	a906      	add	r1, sp, #24
  8e:	4620      	mov	r0, r4
  90:	f7ff fffe 	bl	0 <BuildMessage>
}
  94:	4628      	mov	r0, r5
  96:	b013      	add	sp, #76	; 0x4c
  98:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (ssl->options.tls1_1) {
  9c:	f994 2271 	ldrsb.w	r2, [r4, #625]	; 0x271
  a0:	2a00      	cmp	r2, #0
  a2:	da0a      	bge.n	ba <BuildMessage+0xba>
                    args->sz  += args->ivSz;
  a4:	4403      	add	r3, r0
                    if (args->ivSz > MAX_IV_SZ)
  a6:	2810      	cmp	r0, #16
                    args->ivSz = blockSz;
  a8:	900c      	str	r0, [sp, #48]	; 0x30
                    args->sz  += args->ivSz;
  aa:	9307      	str	r3, [sp, #28]
                    if (args->ivSz > MAX_IV_SZ)
  ac:	d905      	bls.n	ba <BuildMessage+0xba>
    ssl->options.buildMsgState = BUILD_MSG_BEGIN;
  ae:	2300      	movs	r3, #0
  b0:	f884 3284 	strb.w	r3, [r4, #644]	; 0x284
                        ERROR_OUT(BUFFER_E, exit_buildmsg);
  b4:	f06f 0583 	mvn.w	r5, #131	; 0x83
  b8:	e7e8      	b.n	8c <BuildMessage+0x8c>
                args->sz += 1;       /* pad byte */
  ba:	9b07      	ldr	r3, [sp, #28]
                    args->pad = (args->sz - args->headerSz) % blockSz;
  bc:	1f1a      	subs	r2, r3, #4
  be:	fbb2 f1f0 	udiv	r1, r2, r0
  c2:	fb00 2211 	mls	r2, r0, r1, r2
                if (args->pad != 0)
  c6:	b94a      	cbnz	r2, dc <BuildMessage+0xdc>
                    args->pad = (args->sz - args->headerSz) % blockSz;
  c8:	9208      	str	r2, [sp, #32]
                args->sz += args->pad;
  ca:	9a08      	ldr	r2, [sp, #32]
  cc:	4413      	add	r3, r2
  ce:	3301      	adds	r3, #1
                args->sz += (args->ivSz + ssl->specs.aead_mac_size - args->digestSz);
  d0:	9307      	str	r3, [sp, #28]
            if (sizeOnly)
  d2:	b1af      	cbz	r7, 100 <BuildMessage+0x100>
    ssl->options.buildMsgState = BUILD_MSG_BEGIN;
  d4:	2300      	movs	r3, #0
  d6:	f884 3284 	strb.w	r3, [r4, #644]	; 0x284
    if (ret == 0) {
  da:	e7c2      	b.n	62 <BuildMessage+0x62>
                    args->pad = blockSz - args->pad;
  dc:	1a80      	subs	r0, r0, r2
  de:	9008      	str	r0, [sp, #32]
  e0:	e7f3      	b.n	ca <BuildMessage+0xca>
            if (ssl->specs.cipher_type == aead) {
  e2:	2a02      	cmp	r2, #2
  e4:	d1f5      	bne.n	d2 <BuildMessage+0xd2>
                if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha)
  e6:	f894 2148 	ldrb.w	r2, [r4, #328]	; 0x148
  ea:	2a09      	cmp	r2, #9
                    args->ivSz = AESGCM_EXP_IV_SZ;
  ec:	bf1c      	itt	ne
  ee:	2208      	movne	r2, #8
  f0:	920c      	strne	r2, [sp, #48]	; 0x30
                args->sz += (args->ivSz + ssl->specs.aead_mac_size - args->digestSz);
  f2:	990c      	ldr	r1, [sp, #48]	; 0x30
  f4:	f8b4 2146 	ldrh.w	r2, [r4, #326]	; 0x146
  f8:	440a      	add	r2, r1
  fa:	4413      	add	r3, r2
  fc:	1a1b      	subs	r3, r3, r0
  fe:	e7e7      	b.n	d0 <BuildMessage+0xd0>
            if (args->sz > (word32)outSz) {
 100:	9b07      	ldr	r3, [sp, #28]
 102:	429d      	cmp	r5, r3
 104:	d3d3      	bcc.n	ae <BuildMessage+0xae>
            if (args->ivSz > 0) {
 106:	980c      	ldr	r0, [sp, #48]	; 0x30
 108:	2800      	cmp	r0, #0
 10a:	d156      	bne.n	1ba <BuildMessage+0x1ba>
            args->size = (word16)(args->sz - args->headerSz);    /* include mac and digest */
 10c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 10e:	9907      	ldr	r1, [sp, #28]
 110:	1ac9      	subs	r1, r1, r3
 112:	b289      	uxth	r1, r1
            AddRecordHeader(output, args->size, (byte)type, ssl, epochOrder);
 114:	fa5f f28a 	uxtb.w	r2, sl
 118:	4623      	mov	r3, r4
 11a:	4630      	mov	r0, r6
            args->size = (word16)(args->sz - args->headerSz);    /* include mac and digest */
 11c:	f8ad 102c 	strh.w	r1, [sp, #44]	; 0x2c
            AddRecordHeader(output, args->size, (byte)type, ssl, epochOrder);
 120:	f7ff fffe 	bl	0 <BuildMessage>
            if (args->ivSz > 0) {
 124:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 126:	b172      	cbz	r2, 146 <BuildMessage+0x146>
                XMEMCPY(output + args->idx, args->iv,
 128:	9809      	ldr	r0, [sp, #36]	; 0x24
 12a:	990d      	ldr	r1, [sp, #52]	; 0x34
 12c:	2a10      	cmp	r2, #16
 12e:	bf28      	it	cs
 130:	2210      	movcs	r2, #16
 132:	4430      	add	r0, r6
 134:	f7ff fffe 	bl	0 <memcpy>
                args->idx += min(args->ivSz, MAX_IV_SZ);
 138:	9b09      	ldr	r3, [sp, #36]	; 0x24
 13a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 13c:	2a10      	cmp	r2, #16
 13e:	bf94      	ite	ls
 140:	189b      	addls	r3, r3, r2
 142:	3310      	addhi	r3, #16
 144:	9309      	str	r3, [sp, #36]	; 0x24
            XMEMCPY(output + args->idx, input, inSz);
 146:	9809      	ldr	r0, [sp, #36]	; 0x24
 148:	4642      	mov	r2, r8
 14a:	4649      	mov	r1, r9
 14c:	4430      	add	r0, r6
 14e:	f7ff fffe 	bl	0 <memcpy>
            args->idx += inSz;
 152:	9b09      	ldr	r3, [sp, #36]	; 0x24
 154:	4443      	add	r3, r8
 156:	9309      	str	r3, [sp, #36]	; 0x24
            ssl->options.buildMsgState = BUILD_MSG_HASH;
 158:	2302      	movs	r3, #2
 15a:	f884 3284 	strb.w	r3, [r4, #644]	; 0x284
            if (type == handshake && hashOutput) {
 15e:	f1ba 0f16 	cmp.w	sl, #22
 162:	d047      	beq.n	1f4 <BuildMessage+0x1f4>
            if (ssl->specs.cipher_type == block) {
 164:	f894 3149 	ldrb.w	r3, [r4, #329]	; 0x149
 168:	2b01      	cmp	r3, #1
 16a:	d10b      	bne.n	184 <BuildMessage+0x184>
                    tmpIdx = args->idx + args->digestSz;
 16c:	9a06      	ldr	r2, [sp, #24]
 16e:	9b09      	ldr	r3, [sp, #36]	; 0x24
                for (i = 0; i <= args->pad; i++)
 170:	9908      	ldr	r1, [sp, #32]
                    tmpIdx = args->idx + args->digestSz;
 172:	4413      	add	r3, r2
                    output[tmpIdx++] = (byte)args->pad; /* pad byte gets pad value */
 174:	b2c8      	uxtb	r0, r1
 176:	4433      	add	r3, r6
                for (i = 0; i <= args->pad; i++)
 178:	2200      	movs	r2, #0
 17a:	3201      	adds	r2, #1
 17c:	4291      	cmp	r1, r2
                    output[tmpIdx++] = (byte)args->pad; /* pad byte gets pad value */
 17e:	f803 0b01 	strb.w	r0, [r3], #1
                for (i = 0; i <= args->pad; i++)
 182:	d2fa      	bcs.n	17a <BuildMessage+0x17a>
            ssl->options.buildMsgState = BUILD_MSG_VERIFY_MAC;
 184:	2303      	movs	r3, #3
 186:	f884 3284 	strb.w	r3, [r4, #644]	; 0x284
            if (ssl->specs.cipher_type != aead
 18a:	f894 3149 	ldrb.w	r3, [r4, #329]	; 0x149
 18e:	2b02      	cmp	r3, #2
 190:	d142      	bne.n	218 <BuildMessage+0x218>
            ssl->options.buildMsgState = BUILD_MSG_ENCRYPT;
 192:	2304      	movs	r3, #4
 194:	f884 3284 	strb.w	r3, [r4, #644]	; 0x284
    switch (ssl->encrypt.state) {
 198:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
                ret = Encrypt(ssl, output + args->headerSz,
 19c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 19e:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
    switch (ssl->encrypt.state) {
 1a2:	2b01      	cmp	r3, #1
 1a4:	d061      	beq.n	26a <BuildMessage+0x26a>
 1a6:	2b02      	cmp	r3, #2
 1a8:	f04f 0000 	mov.w	r0, #0
 1ac:	f000 80e6 	beq.w	37c <BuildMessage+0x37c>
 1b0:	2b00      	cmp	r3, #0
 1b2:	d04b      	beq.n	24c <BuildMessage+0x24c>
    ssl->encrypt.state = CIPHER_STATE_BEGIN;
 1b4:	f884 0060 	strb.w	r0, [r4, #96]	; 0x60
            if (ret != 0) {
 1b8:	e78c      	b.n	d4 <BuildMessage+0xd4>
                if (args->ivSz > sizeof(args->staticIvBuffer)) {
 1ba:	2810      	cmp	r0, #16
 1bc:	d908      	bls.n	1d0 <BuildMessage+0x1d0>
                    args->iv = (byte*)XMALLOC(args->ivSz, ssl->heap,
 1be:	f7ff fffe 	bl	0 <malloc>
 1c2:	900d      	str	r0, [sp, #52]	; 0x34
                    if (args->iv == NULL) {
 1c4:	b930      	cbnz	r0, 1d4 <BuildMessage+0x1d4>
    ssl->options.buildMsgState = BUILD_MSG_BEGIN;
 1c6:	f884 7284 	strb.w	r7, [r4, #644]	; 0x284
                        ERROR_OUT(MEMORY_E, exit_buildmsg);
 1ca:	f06f 057c 	mvn.w	r5, #124	; 0x7c
 1ce:	e75d      	b.n	8c <BuildMessage+0x8c>
                    args->iv = args->staticIvBuffer;
 1d0:	ab0e      	add	r3, sp, #56	; 0x38
 1d2:	930d      	str	r3, [sp, #52]	; 0x34
                ret = wc_RNG_GenerateBlock(ssl->rng, args->iv, args->ivSz);
 1d4:	e9dd 210c 	ldrd	r2, r1, [sp, #48]	; 0x30
 1d8:	69a0      	ldr	r0, [r4, #24]
 1da:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
                if (ret != 0)
 1de:	4605      	mov	r5, r0
 1e0:	2800      	cmp	r0, #0
 1e2:	d093      	beq.n	10c <BuildMessage+0x10c>
    ssl->options.buildMsgState = BUILD_MSG_BEGIN;
 1e4:	2300      	movs	r3, #0
 1e6:	f884 3284 	strb.w	r3, [r4, #644]	; 0x284
    if (ret == 0) {
 1ea:	e74f      	b.n	8c <BuildMessage+0x8c>
            if (sizeOnly)
 1ec:	2f00      	cmp	r7, #0
 1ee:	f47f af71 	bne.w	d4 <BuildMessage+0xd4>
 1f2:	e7b4      	b.n	15e <BuildMessage+0x15e>
            if (type == handshake && hashOutput) {
 1f4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 1f6:	2b00      	cmp	r3, #0
 1f8:	d0b4      	beq.n	164 <BuildMessage+0x164>
                ret = HashOutput(ssl, output, args->headerSz + inSz, args->ivSz);
 1fa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 1fc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 1fe:	4442      	add	r2, r8
 200:	4631      	mov	r1, r6
 202:	4620      	mov	r0, r4
 204:	f7ff fffe 	bl	0 <BuildMessage>
                if (ret != 0)
 208:	4605      	mov	r5, r0
 20a:	2800      	cmp	r0, #0
 20c:	d0aa      	beq.n	164 <BuildMessage+0x164>
 20e:	e7e9      	b.n	1e4 <BuildMessage+0x1e4>
            if (sizeOnly)
 210:	2f00      	cmp	r7, #0
 212:	f47f af5f 	bne.w	d4 <BuildMessage+0xd4>
 216:	e7b8      	b.n	18a <BuildMessage+0x18a>
                                args->headerSz + args->ivSz, inSz, -1, type, 0, epochOrder);
 218:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 21a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
                    ret = ssl->hmac(ssl, output + args->idx, output +
 21c:	9909      	ldr	r1, [sp, #36]	; 0x24
                                args->headerSz + args->ivSz, inSz, -1, type, 0, epochOrder);
 21e:	441a      	add	r2, r3
                    ret = ssl->hmac(ssl, output + args->idx, output +
 220:	9b21      	ldr	r3, [sp, #132]	; 0x84
 222:	9303      	str	r3, [sp, #12]
 224:	2300      	movs	r3, #0
 226:	e9cd a301 	strd	sl, r3, [sp, #4]
 22a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 22e:	9300      	str	r3, [sp, #0]
 230:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 232:	4643      	mov	r3, r8
 234:	4432      	add	r2, r6
 236:	4431      	add	r1, r6
 238:	4620      	mov	r0, r4
 23a:	47a8      	blx	r5
            if (ret != 0)
 23c:	4605      	mov	r5, r0
 23e:	2800      	cmp	r0, #0
 240:	d1d0      	bne.n	1e4 <BuildMessage+0x1e4>
 242:	e7a6      	b.n	192 <BuildMessage+0x192>
            if (sizeOnly)
 244:	2f00      	cmp	r7, #0
 246:	f47f af45 	bne.w	d4 <BuildMessage+0xd4>
 24a:	e7a5      	b.n	198 <BuildMessage+0x198>
            if (ssl->encrypt.setup == 0) {
 24c:	f894 3061 	ldrb.w	r3, [r4, #97]	; 0x61
 250:	2b00      	cmp	r3, #0
 252:	f000 8095 	beq.w	380 <BuildMessage+0x380>
            if (ssl->specs.bulk_cipher_algorithm == wolfssl_aes_ccm ||
 256:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
 25a:	1fda      	subs	r2, r3, #7
 25c:	2a01      	cmp	r2, #1
 25e:	d910      	bls.n	282 <BuildMessage+0x282>
                ssl->specs.bulk_cipher_algorithm == wolfssl_aes_gcm ||
 260:	2b0e      	cmp	r3, #14
 262:	d00e      	beq.n	282 <BuildMessage+0x282>
            ssl->encrypt.state = CIPHER_STATE_DO;
 264:	2301      	movs	r3, #1
 266:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    if (input == NULL) {
 26a:	19f7      	adds	r7, r6, r7
    switch (ssl->specs.bulk_cipher_algorithm) {
 26c:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
    if (input == NULL) {
 270:	f000 8081 	beq.w	376 <BuildMessage+0x376>
    switch (ssl->specs.bulk_cipher_algorithm) {
 274:	2b06      	cmp	r3, #6
 276:	d077      	beq.n	368 <BuildMessage+0x368>
 278:	d817      	bhi.n	2aa <BuildMessage+0x2aa>
 27a:	2b04      	cmp	r3, #4
 27c:	d051      	beq.n	322 <BuildMessage+0x322>
 27e:	4d41      	ldr	r5, [pc, #260]	; (384 <BuildMessage+0x384>)
 280:	e056      	b.n	330 <BuildMessage+0x330>
                if (ssl->encrypt.additional == NULL)
 282:	6da3      	ldr	r3, [r4, #88]	; 0x58
 284:	b91b      	cbnz	r3, 28e <BuildMessage+0x28e>
                    ssl->encrypt.additional = (byte*)XMALLOC(AEAD_AUTH_DATA_SZ,
 286:	200d      	movs	r0, #13
 288:	f7ff fffe 	bl	0 <malloc>
 28c:	65a0      	str	r0, [r4, #88]	; 0x58
                if (ssl->encrypt.nonce == NULL) {
 28e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 290:	b91b      	cbnz	r3, 29a <BuildMessage+0x29a>
                    ssl->encrypt.nonce = (byte*)XMALLOC(AESGCM_NONCE_SZ,
 292:	200c      	movs	r0, #12
 294:	f7ff fffe 	bl	0 <malloc>
 298:	65e0      	str	r0, [r4, #92]	; 0x5c
                if (ssl->encrypt.additional == NULL ||
 29a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 29c:	b113      	cbz	r3, 2a4 <BuildMessage+0x2a4>
 29e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 2a0:	2b00      	cmp	r3, #0
 2a2:	d1df      	bne.n	264 <BuildMessage+0x264>
                    return MEMORY_E;
 2a4:	f06f 057c 	mvn.w	r5, #124	; 0x7c
 2a8:	e057      	b.n	35a <BuildMessage+0x35a>
    switch (ssl->specs.bulk_cipher_algorithm) {
 2aa:	3b07      	subs	r3, #7
 2ac:	2b01      	cmp	r3, #1
 2ae:	d8e6      	bhi.n	27e <BuildMessage+0x27e>
            XMEMSET(ssl->encrypt.additional, 0, AEAD_AUTH_DATA_SZ);
 2b0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 2b2:	220d      	movs	r2, #13
 2b4:	2100      	movs	r1, #0
 2b6:	f7ff fffe 	bl	0 <memset>
            WriteSEQ(ssl, CUR_ORDER, ssl->encrypt.additional);
 2ba:	6da2      	ldr	r2, [r4, #88]	; 0x58
 2bc:	4620      	mov	r0, r4
 2be:	2100      	movs	r1, #0
 2c0:	f7ff fffe 	bl	0 <BuildMessage>
            XMEMCPY(ssl->encrypt.additional + AEAD_TYPE_OFFSET,
 2c4:	6da0      	ldr	r0, [r4, #88]	; 0x58
 2c6:	1f79      	subs	r1, r7, #5
 2c8:	2203      	movs	r2, #3
 2ca:	3008      	adds	r0, #8
 2cc:	f7ff fffe 	bl	0 <memcpy>
            c16toa(sz - AESGCM_EXP_IV_SZ - ssl->specs.aead_mac_size,
 2d0:	f8b4 2146 	ldrh.w	r2, [r4, #326]	; 0x146
                                ssl->encrypt.additional + AEAD_LEN_OFFSET);
 2d4:	6da3      	ldr	r3, [r4, #88]	; 0x58
            c16toa(sz - AESGCM_EXP_IV_SZ - ssl->specs.aead_mac_size,
 2d6:	f1a8 0008 	sub.w	r0, r8, #8
 2da:	1a82      	subs	r2, r0, r2
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 2dc:	f3c2 2107 	ubfx	r1, r2, #8, #8
 2e0:	72d9      	strb	r1, [r3, #11]
    c[1] =  (byte)(wc_u16       & 0xff);
 2e2:	731a      	strb	r2, [r3, #12]
                ret = aes_auth_fn(ssl->encrypt.aes,
 2e4:	210d      	movs	r1, #13
                        sz - AESGCM_EXP_IV_SZ - ssl->specs.aead_mac_size,
 2e6:	f8b4 3146 	ldrh.w	r3, [r4, #326]	; 0x146
                ret = aes_auth_fn(ssl->encrypt.aes,
 2ea:	9105      	str	r1, [sp, #20]
 2ec:	6da1      	ldr	r1, [r4, #88]	; 0x58
                        out + sz - ssl->specs.aead_mac_size,
 2ee:	eba8 0803 	sub.w	r8, r8, r3
                ret = aes_auth_fn(ssl->encrypt.aes,
 2f2:	e9cd 3103 	strd	r3, r1, [sp, #12]
 2f6:	eb07 0108 	add.w	r1, r7, r8
 2fa:	9102      	str	r1, [sp, #8]
 2fc:	210c      	movs	r1, #12
 2fe:	9101      	str	r1, [sp, #4]
 300:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 302:	9100      	str	r1, [sp, #0]
 304:	f107 0208 	add.w	r2, r7, #8
 308:	1ac3      	subs	r3, r0, r3
 30a:	4611      	mov	r1, r2
 30c:	6d60      	ldr	r0, [r4, #84]	; 0x54
 30e:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt_ex>
            XMEMCPY(out,
 312:	6de1      	ldr	r1, [r4, #92]	; 0x5c
                ret = aes_auth_fn(ssl->encrypt.aes,
 314:	4605      	mov	r5, r0
            XMEMCPY(out,
 316:	2208      	movs	r2, #8
 318:	3104      	adds	r1, #4
 31a:	4638      	mov	r0, r7
 31c:	f7ff fffe 	bl	0 <memcpy>
        break;
 320:	e006      	b.n	330 <BuildMessage+0x330>
            ret = wc_Des3_CbcEncrypt(ssl->encrypt.des3, out, input, sz);
 322:	6d20      	ldr	r0, [r4, #80]	; 0x50
 324:	4643      	mov	r3, r8
 326:	463a      	mov	r2, r7
 328:	4639      	mov	r1, r7
 32a:	f7ff fffe 	bl	0 <wc_Des3_CbcEncrypt>
            ret = wc_AesCbcEncrypt(ssl->encrypt.aes, out, input, sz);
 32e:	4605      	mov	r5, r0
            ssl->encrypt.state = CIPHER_STATE_END;
 330:	2302      	movs	r3, #2
 332:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
            if (ssl->specs.bulk_cipher_algorithm == wolfssl_aes_ccm ||
 336:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
 33a:	1fda      	subs	r2, r3, #7
 33c:	2a01      	cmp	r2, #1
 33e:	d901      	bls.n	344 <BuildMessage+0x344>
                ssl->specs.bulk_cipher_algorithm == wolfssl_aes_gcm ||
 340:	2b0e      	cmp	r3, #14
 342:	d104      	bne.n	34e <BuildMessage+0x34e>
                if (ssl->encrypt.nonce)
 344:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 346:	b110      	cbz	r0, 34e <BuildMessage+0x34e>
                    ForceZero(ssl->encrypt.nonce, AESGCM_NONCE_SZ);
 348:	210c      	movs	r1, #12
 34a:	f7ff fffe 	bl	0 <BuildMessage>
    ssl->encrypt.state = CIPHER_STATE_BEGIN;
 34e:	2300      	movs	r3, #0
 350:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
            if (ret != 0) {
 354:	2d00      	cmp	r5, #0
 356:	f43f aebd 	beq.w	d4 <BuildMessage+0xd4>
                        ForceZero(output + args->headerSz, (word16)args->size);
 35a:	980a      	ldr	r0, [sp, #40]	; 0x28
 35c:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
 360:	4430      	add	r0, r6
 362:	f7ff fffe 	bl	0 <BuildMessage>
                goto exit_buildmsg;
 366:	e73d      	b.n	1e4 <BuildMessage+0x1e4>
            ret = wc_AesCbcEncrypt(ssl->encrypt.aes, out, input, sz);
 368:	6d60      	ldr	r0, [r4, #84]	; 0x54
 36a:	4643      	mov	r3, r8
 36c:	463a      	mov	r2, r7
 36e:	4639      	mov	r1, r7
 370:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
 374:	e7db      	b.n	32e <BuildMessage+0x32e>
        return BAD_FUNC_ARG;
 376:	f06f 05ac 	mvn.w	r5, #172	; 0xac
 37a:	e7d9      	b.n	330 <BuildMessage+0x330>
    switch (ssl->encrypt.state) {
 37c:	4605      	mov	r5, r0
 37e:	e7da      	b.n	336 <BuildMessage+0x336>
                return ENCRYPT_ERROR;
 380:	4d00      	ldr	r5, [pc, #0]	; (384 <BuildMessage+0x384>)
 382:	e7ea      	b.n	35a <BuildMessage+0x35a>
 384:	fffffec6 	.word	0xfffffec6

Disassembly of section .text.SendChangeCipher:

00000000 <SendChangeCipher>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone) {
   2:	2101      	movs	r1, #1
{
   4:	b089      	sub	sp, #36	; 0x24
   6:	4604      	mov	r4, r0
    if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone) {
   8:	f7ff fffe 	bl	0 <SendChangeCipher>
   c:	b3b8      	cbz	r0, 7e <SendChangeCipher+0x7e>
   e:	f894 327f 	ldrb.w	r3, [r4, #639]	; 0x27f
        sendSz += MAX_MSG_EXTRA;
  12:	2b00      	cmp	r3, #0
  14:	bf0c      	ite	eq
  16:	2606      	moveq	r6, #6
  18:	266c      	movne	r6, #108	; 0x6c
    ssl->options.buildingMsg = 1;
  1a:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  1e:	f043 0308 	orr.w	r3, r3, #8
  22:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
    if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
  26:	4631      	mov	r1, r6
  28:	4620      	mov	r0, r4
  2a:	f7ff fffe 	bl	0 <SendChangeCipher>
  2e:	4605      	mov	r5, r0
  30:	bb10      	cbnz	r0, 78 <SendChangeCipher+0x78>
    output = GetOutputBuffer(ssl);
  32:	4620      	mov	r0, r4
  34:	f7ff fffe 	bl	0 <SendChangeCipher>
    AddRecordHeader(output, 1, change_cipher_spec, ssl, CUR_ORDER);
  38:	2101      	movs	r1, #1
  3a:	4623      	mov	r3, r4
  3c:	2214      	movs	r2, #20
  3e:	f7ff fffe 	bl	0 <SendChangeCipher>
    output = GetOutputBuffer(ssl);
  42:	4607      	mov	r7, r0
    output[idx] = 1;             /* turn it on */
  44:	7141      	strb	r1, [r0, #5]
    if (IsEncryptionOn(ssl, 1) && ssl->options.handShakeDone) {
  46:	4620      	mov	r0, r4
  48:	f7ff fffe 	bl	0 <SendChangeCipher>
  4c:	b1c8      	cbz	r0, 82 <SendChangeCipher+0x82>
  4e:	f894 327f 	ldrb.w	r3, [r4, #639]	; 0x27f
  52:	b1b3      	cbz	r3, 82 <SendChangeCipher+0x82>
        sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
  54:	2314      	movs	r3, #20
  56:	e9cd 1300 	strd	r1, r3, [sp]
        input[0] = 1;  /* turn it on */
  5a:	f88d 101c 	strb.w	r1, [sp, #28]
        sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
  5e:	4632      	mov	r2, r6
  60:	e9cd 5504 	strd	r5, r5, [sp, #16]
  64:	e9cd 5502 	strd	r5, r5, [sp, #8]
  68:	ab07      	add	r3, sp, #28
  6a:	4639      	mov	r1, r7
  6c:	4620      	mov	r0, r4
  6e:	f7ff fffe 	bl	0 <SendChangeCipher>
        if (sendSz < 0) {
  72:	1e06      	subs	r6, r0, #0
  74:	da05      	bge.n	82 <SendChangeCipher+0x82>
            return sendSz;
  76:	4635      	mov	r5, r6
}
  78:	4628      	mov	r0, r5
  7a:	b009      	add	sp, #36	; 0x24
  7c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int                sendSz = RECORD_HEADER_SZ + ENUM_LEN;
  7e:	2606      	movs	r6, #6
  80:	e7cb      	b.n	1a <SendChangeCipher+0x1a>
    ssl->buffers.outputBuffer.length += sendSz;
  82:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
  86:	4430      	add	r0, r6
  88:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
        if ((ret = SetKeysSide(ssl, ENCRYPT_SIDE_ONLY)) != 0)
  8c:	2101      	movs	r1, #1
  8e:	4620      	mov	r0, r4
  90:	f7ff fffe 	bl	0 <SetKeysSide>
  94:	4605      	mov	r5, r0
  96:	2800      	cmp	r0, #0
  98:	d1ee      	bne.n	78 <SendChangeCipher+0x78>
    ssl->options.buildingMsg = 0;
  9a:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  9e:	f360 03c3 	bfi	r3, r0, #3, #1
  a2:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
    if (ssl->options.groupMessages)
  a6:	f994 3274 	ldrsb.w	r3, [r4, #628]	; 0x274
  aa:	2b00      	cmp	r3, #0
  ac:	dbe4      	blt.n	78 <SendChangeCipher+0x78>
        return SendBuffered(ssl);
  ae:	4620      	mov	r0, r4
}
  b0:	b009      	add	sp, #36	; 0x24
  b2:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        return SendBuffered(ssl);
  b6:	f7ff bffe 	b.w	0 <SendChangeCipher>

Disassembly of section .text.SendAlert_ex:

00000000 <SendAlert_ex>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    ssl->pendingAlert.level = severity;
   2:	e9c0 2143 	strd	r2, r1, [r0, #268]	; 0x10c
{
   6:	b089      	sub	sp, #36	; 0x24
   8:	460d      	mov	r5, r1
    if ((ret = CheckAvailableSize(ssl, outputSz)) != 0) {
   a:	2168      	movs	r1, #104	; 0x68
{
   c:	4604      	mov	r4, r0
   e:	4617      	mov	r7, r2
    if ((ret = CheckAvailableSize(ssl, outputSz)) != 0) {
  10:	f7ff fffe 	bl	0 <SendAlert_ex>
  14:	2800      	cmp	r0, #0
  16:	d146      	bne.n	a6 <SendAlert_ex+0xa6>
    if (ssl->buffers.outputBuffer.buffer == NULL)
  18:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
  1c:	2b00      	cmp	r3, #0
  1e:	d044      	beq.n	aa <SendAlert_ex+0xaa>
    output = GetOutputBuffer(ssl);
  20:	4620      	mov	r0, r4
  22:	f7ff fffe 	bl	0 <SendAlert_ex>
    if (severity == alert_fatal) {
  26:	2d02      	cmp	r5, #2
            ssl->options.isClosed = 1;  /* Don't send close_notify */
  28:	bf08      	it	eq
  2a:	f894 3272 	ldrbeq.w	r3, [r4, #626]	; 0x272
    input[0] = (byte)severity;
  2e:	f88d 501c 	strb.w	r5, [sp, #28]
            ssl->options.isClosed = 1;  /* Don't send close_notify */
  32:	bf08      	it	eq
  34:	f043 0310 	orreq.w	r3, r3, #16
    output = GetOutputBuffer(ssl);
  38:	4606      	mov	r6, r0
            ssl->options.isClosed = 1;  /* Don't send close_notify */
  3a:	bf08      	it	eq
  3c:	f884 3272 	strbeq.w	r3, [r4, #626]	; 0x272
    ssl->alert_history.last_tx.level = severity;
  40:	e9c4 7541 	strd	r7, r5, [r4, #260]	; 0x104
    if (IsEncryptionOn(ssl, 1)) {
  44:	2101      	movs	r1, #1
  46:	4620      	mov	r0, r4
    input[1] = (byte)type;
  48:	f88d 701d 	strb.w	r7, [sp, #29]
    if (IsEncryptionOn(ssl, 1)) {
  4c:	f7ff fffe 	bl	0 <SendAlert_ex>
  50:	b190      	cbz	r0, 78 <SendAlert_ex+0x78>
        sendSz = BuildMessage(ssl, output, outputSz, input, ALERT_SIZE, alert,
  52:	2300      	movs	r3, #0
  54:	e9cd 3304 	strd	r3, r3, [sp, #16]
  58:	e9cd 3302 	strd	r3, r3, [sp, #8]
  5c:	2215      	movs	r2, #21
  5e:	2302      	movs	r3, #2
  60:	e9cd 3200 	strd	r3, r2, [sp]
  64:	4631      	mov	r1, r6
  66:	ab07      	add	r3, sp, #28
  68:	2268      	movs	r2, #104	; 0x68
  6a:	4620      	mov	r0, r4
  6c:	f7ff fffe 	bl	0 <SendAlert_ex>
    if (sendSz < 0)
  70:	2800      	cmp	r0, #0
  72:	da0d      	bge.n	90 <SendAlert_ex+0x90>
        return BUILD_MSG_ERROR;
  74:	480e      	ldr	r0, [pc, #56]	; (b0 <SendAlert_ex+0xb0>)
  76:	e016      	b.n	a6 <SendAlert_ex+0xa6>
                AddRecordHeader(output, ALERT_SIZE, alert, ssl, CUR_ORDER);
  78:	2102      	movs	r1, #2
  7a:	4623      	mov	r3, r4
  7c:	2215      	movs	r2, #21
  7e:	4630      	mov	r0, r6
  80:	f7ff fffe 	bl	0 <SendAlert_ex>
        XMEMCPY(output, input, ALERT_SIZE);
  84:	460a      	mov	r2, r1
  86:	1d70      	adds	r0, r6, #5
  88:	a907      	add	r1, sp, #28
  8a:	f7ff fffe 	bl	0 <memcpy>
        sendSz = RECORD_HEADER_SZ + ALERT_SIZE;
  8e:	2007      	movs	r0, #7
    ssl->buffers.outputBuffer.length += sendSz;
  90:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
  94:	4418      	add	r0, r3
  96:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
    ret = SendBuffered(ssl);
  9a:	4620      	mov	r0, r4
  9c:	f7ff fffe 	bl	0 <SendAlert_ex>
    ssl->pendingAlert.code = 0;
  a0:	2300      	movs	r3, #0
    ssl->pendingAlert.level = alert_none;
  a2:	e9c4 3343 	strd	r3, r3, [r4, #268]	; 0x10c
}
  a6:	b009      	add	sp, #36	; 0x24
  a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return BUFFER_E;
  aa:	f06f 0083 	mvn.w	r0, #131	; 0x83
  ae:	e7fa      	b.n	a6 <SendAlert_ex+0xa6>
  b0:	fffffec0 	.word	0xfffffec0

Disassembly of section .text.SendFinished:

00000000 <SendFinished>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
                     finishedSz = ssl->options.tls ? TLS_FINISHED_SZ :
   2:	f890 3271 	ldrb.w	r3, [r0, #625]	; 0x271
   6:	f013 0f40 	tst.w	r3, #64	; 0x40
    ssl->options.buildingMsg = 1;
   a:	f890 3276 	ldrb.w	r3, [r0, #630]	; 0x276
   e:	f043 0308 	orr.w	r3, r3, #8
{
  12:	b093      	sub	sp, #76	; 0x4c
    ssl->options.buildingMsg = 1;
  14:	f880 3276 	strb.w	r3, [r0, #630]	; 0x276
    if ((ret = CheckAvailableSize(ssl, outputSz)) != 0)
  18:	f04f 0196 	mov.w	r1, #150	; 0x96
{
  1c:	4604      	mov	r4, r0
                     finishedSz = ssl->options.tls ? TLS_FINISHED_SZ :
  1e:	bf14      	ite	ne
  20:	260c      	movne	r6, #12
  22:	2624      	moveq	r6, #36	; 0x24
    if ((ret = CheckAvailableSize(ssl, outputSz)) != 0)
  24:	f7ff fffe 	bl	0 <SendFinished>
  28:	4605      	mov	r5, r0
  2a:	2800      	cmp	r0, #0
  2c:	d150      	bne.n	d0 <SendFinished+0xd0>
    output = GetOutputBuffer(ssl);
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <SendFinished>
    hs->type = type;
  34:	2314      	movs	r3, #20
  36:	f88d 3018 	strb.w	r3, [sp, #24]
    ret = BuildFinished(ssl, hashes, ssl->options.side == WOLFSSL_CLIENT_END ?
  3a:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  3e:	492a      	ldr	r1, [pc, #168]	; (e8 <SendFinished+0xe8>)
  40:	4a2a      	ldr	r2, [pc, #168]	; (ec <SendFinished+0xec>)
    out[0] = (byte)((in >> 16) & 0xff);
  42:	f88d 5019 	strb.w	r5, [sp, #25]
  46:	f003 0330 	and.w	r3, r3, #48	; 0x30
  4a:	2b10      	cmp	r3, #16
  4c:	bf18      	it	ne
  4e:	460a      	movne	r2, r1
    if (ssl->options.tls) {
  50:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
    out[1] = (byte)((in >>  8) & 0xff);
  54:	f88d 501a 	strb.w	r5, [sp, #26]
  58:	0659      	lsls	r1, r3, #25
    output = GetOutputBuffer(ssl);
  5a:	4607      	mov	r7, r0
    out[2] =  (byte)(in        & 0xff);
  5c:	f88d 601b 	strb.w	r6, [sp, #27]
    if (ssl->options.tls) {
  60:	d505      	bpl.n	6e <SendFinished+0x6e>
        ret = BuildTlsFinished(ssl, hashes, sender);
  62:	a907      	add	r1, sp, #28
  64:	4620      	mov	r0, r4
  66:	f7ff fffe 	bl	0 <BuildTlsFinished>
    if (ret != 0) return ret;
  6a:	4605      	mov	r5, r0
  6c:	bb80      	cbnz	r0, d0 <SendFinished+0xd0>
    sendSz = BuildMessage(ssl, output, outputSz, input, headerSz + finishedSz,
  6e:	2300      	movs	r3, #0
  70:	e9cd 3304 	strd	r3, r3, [sp, #16]
  74:	9303      	str	r3, [sp, #12]
  76:	2201      	movs	r2, #1
  78:	2316      	movs	r3, #22
  7a:	3604      	adds	r6, #4
  7c:	e9cd 3201 	strd	r3, r2, [sp, #4]
  80:	9600      	str	r6, [sp, #0]
  82:	ab06      	add	r3, sp, #24
  84:	2296      	movs	r2, #150	; 0x96
  86:	4639      	mov	r1, r7
  88:	4620      	mov	r0, r4
  8a:	f7ff fffe 	bl	0 <SendFinished>
    if (sendSz < 0)
  8e:	1e05      	subs	r5, r0, #0
  90:	db28      	blt.n	e4 <SendFinished+0xe4>
    if (!ssl->options.resuming) {
  92:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  96:	071b      	lsls	r3, r3, #28
  98:	d41d      	bmi.n	d6 <SendFinished+0xd6>
        SetupSession(ssl);
  9a:	4620      	mov	r0, r4
  9c:	f7ff fffe 	bl	0 <SetupSession>
        if (ssl->options.side == WOLFSSL_SERVER_END) {
  a0:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  a4:	f013 0f30 	tst.w	r3, #48	; 0x30
  a8:	d103      	bne.n	b2 <SendFinished+0xb2>
            ssl->options.handShakeState = HANDSHAKE_DONE;
  aa:	f44f 7388 	mov.w	r3, #272	; 0x110
  ae:	f8a4 327e 	strh.w	r3, [r4, #638]	; 0x27e
    ssl->buffers.outputBuffer.length += sendSz;
  b2:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
  b6:	4428      	add	r0, r5
  b8:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
    ret = SendBuffered(ssl);
  bc:	4620      	mov	r0, r4
  be:	f7ff fffe 	bl	0 <SendFinished>
    ssl->options.buildingMsg = 0;
  c2:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  c6:	f36f 03c3 	bfc	r3, #3, #1
    ret = SendBuffered(ssl);
  ca:	4605      	mov	r5, r0
    ssl->options.buildingMsg = 0;
  cc:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
}
  d0:	4628      	mov	r0, r5
  d2:	b013      	add	sp, #76	; 0x4c
  d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (ssl->options.side == WOLFSSL_CLIENT_END) {
  d6:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  da:	f003 0330 	and.w	r3, r3, #48	; 0x30
  de:	2b10      	cmp	r3, #16
  e0:	d1e7      	bne.n	b2 <SendFinished+0xb2>
  e2:	e7e2      	b.n	aa <SendFinished+0xaa>
        return BUILD_MSG_ERROR;
  e4:	4d02      	ldr	r5, [pc, #8]	; (f0 <SendFinished+0xf0>)
  e6:	e7f3      	b.n	d0 <SendFinished+0xd0>
	...
  f0:	fffffec0 	.word	0xfffffec0

Disassembly of section .text.cipherExtraData:

00000000 <cipherExtraData>:
    if (ssl->specs.cipher_type == aead) {
   0:	f890 3149 	ldrb.w	r3, [r0, #329]	; 0x149
   4:	2b02      	cmp	r3, #2
{
   6:	4602      	mov	r2, r0
    if (ssl->specs.cipher_type == aead) {
   8:	d107      	bne.n	1a <cipherExtraData+0x1a>
        if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha) {
   a:	f892 3148 	ldrb.w	r3, [r2, #328]	; 0x148
        cipherExtra = ssl->specs.aead_mac_size;
   e:	f8b0 0146 	ldrh.w	r0, [r0, #326]	; 0x146
        if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha) {
  12:	2b09      	cmp	r3, #9
  14:	d009      	beq.n	2a <cipherExtraData+0x2a>
            cipherExtra += AESGCM_EXP_IV_SZ;
  16:	3008      	adds	r0, #8
  18:	4770      	bx	lr
        cipherExtra = ssl->specs.iv_size + ssl->specs.block_size +
  1a:	f8b0 3142 	ldrh.w	r3, [r0, #322]	; 0x142
  1e:	f8b0 0144 	ldrh.w	r0, [r0, #324]	; 0x144
  22:	4403      	add	r3, r0
            ssl->specs.hash_size;
  24:	f892 014d 	ldrb.w	r0, [r2, #333]	; 0x14d
        cipherExtra = ssl->specs.iv_size + ssl->specs.block_size +
  28:	4418      	add	r0, r3
}
  2a:	4770      	bx	lr

Disassembly of section .text.SendHandshakeMsg.constprop.0:

00000000 <SendHandshakeMsg.constprop.0>:
static int SendHandshakeMsg(WOLFSSL* ssl, byte* input, word32 inputSz,
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	460e      	mov	r6, r1
   6:	b089      	sub	sp, #36	; 0x24
    if (ssl == NULL || input == NULL)
   8:	4604      	mov	r4, r0
   a:	2800      	cmp	r0, #0
   c:	f000 808c 	beq.w	128 <SendHandshakeMsg.constprop.0+0x128>
  10:	2900      	cmp	r1, #0
  12:	f000 8089 	beq.w	128 <SendHandshakeMsg.constprop.0+0x128>
        inputSz += HANDSHAKE_HEADER_SZ;
  16:	f102 0a04 	add.w	sl, r2, #4
    if (input >= ssl->buffers.outputBuffer.buffer &&
  1a:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
  1e:	f5ba 4f80 	cmp.w	sl, #16384	; 0x4000
  22:	46d3      	mov	fp, sl
  24:	bfa8      	it	ge
  26:	f44f 4b80 	movge.w	fp, #16384	; 0x4000
  2a:	4299      	cmp	r1, r3
  2c:	d304      	bcc.n	38 <SendHandshakeMsg.constprop.0+0x38>
            input < ssl->buffers.outputBuffer.buffer +
  2e:	f8d0 10a8 	ldr.w	r1, [r0, #168]	; 0xa8
  32:	440b      	add	r3, r1
    if (input >= ssl->buffers.outputBuffer.buffer &&
  34:	429e      	cmp	r6, r3
  36:	d377      	bcc.n	128 <SendHandshakeMsg.constprop.0+0x128>
    if (!ssl->options.buildingMsg) {
  38:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  3c:	f013 0308 	ands.w	r3, r3, #8
  40:	d107      	bne.n	52 <SendHandshakeMsg.constprop.0+0x52>
        ret = HashOutput(ssl, input, headerSz + (int)inputSz, 0);
  42:	3209      	adds	r2, #9
  44:	4631      	mov	r1, r6
  46:	4620      	mov	r0, r4
  48:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
        if (ret != 0)
  4c:	4603      	mov	r3, r0
  4e:	2800      	cmp	r0, #0
  50:	d147      	bne.n	e2 <SendHandshakeMsg.constprop.0+0xe2>
    while (ssl->fragOffset < inputSz) {
  52:	f8d4 512c 	ldr.w	r5, [r4, #300]	; 0x12c
  56:	f894 2276 	ldrb.w	r2, [r4, #630]	; 0x276
  5a:	45aa      	cmp	sl, r5
  5c:	d807      	bhi.n	6e <SendHandshakeMsg.constprop.0+0x6e>
    ssl->fragOffset = 0;
  5e:	2300      	movs	r3, #0
    ssl->options.buildingMsg = 0;
  60:	f363 02c3 	bfi	r2, r3, #3, #1
    ssl->fragOffset = 0;
  64:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
    ssl->options.buildingMsg = 0;
  68:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
    return ret;
  6c:	e039      	b.n	e2 <SendHandshakeMsg.constprop.0+0xe2>
        byte* data = input + ssl->fragOffset + headerSz;
  6e:	f105 0905 	add.w	r9, r5, #5
        if (inputSz - ssl->fragOffset < fragSz)
  72:	ebaa 0505 	sub.w	r5, sl, r5
  76:	455d      	cmp	r5, fp
        ssl->options.buildingMsg = 1;
  78:	f042 0208 	orr.w	r2, r2, #8
  7c:	bf28      	it	cs
  7e:	465d      	movcs	r5, fp
  80:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
        if (IsEncryptionOn(ssl, 1))
  84:	2101      	movs	r1, #1
  86:	4620      	mov	r0, r4
        byte* data = input + ssl->fragOffset + headerSz;
  88:	44b1      	add	r9, r6
        outputSz = headerSz + fragSz;
  8a:	1d6f      	adds	r7, r5, #5
        if (IsEncryptionOn(ssl, 1))
  8c:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
  90:	b118      	cbz	r0, 9a <SendHandshakeMsg.constprop.0+0x9a>
            outputSz += cipherExtraData(ssl);
  92:	4620      	mov	r0, r4
  94:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
  98:	4407      	add	r7, r0
        if ((ret = CheckAvailableSize(ssl, outputSz)) != 0)
  9a:	4639      	mov	r1, r7
  9c:	4620      	mov	r0, r4
  9e:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
  a2:	4603      	mov	r3, r0
  a4:	b9e8      	cbnz	r0, e2 <SendHandshakeMsg.constprop.0+0xe2>
        if (ssl->buffers.outputBuffer.buffer == NULL)
  a6:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
  aa:	9007      	str	r0, [sp, #28]
  ac:	2a00      	cmp	r2, #0
  ae:	d03e      	beq.n	12e <SendHandshakeMsg.constprop.0+0x12e>
        output = GetOutputBuffer(ssl);
  b0:	4620      	mov	r0, r4
  b2:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
        if (IsEncryptionOn(ssl, 1)) {
  b6:	2101      	movs	r1, #1
        output = GetOutputBuffer(ssl);
  b8:	4680      	mov	r8, r0
        if (IsEncryptionOn(ssl, 1)) {
  ba:	4620      	mov	r0, r4
  bc:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
  c0:	b198      	cbz	r0, ea <SendHandshakeMsg.constprop.0+0xea>
            ret = BuildMessage(ssl, output, outputSz,
  c2:	9b07      	ldr	r3, [sp, #28]
  c4:	e9cd 3304 	strd	r3, r3, [sp, #16]
  c8:	e9cd 3302 	strd	r3, r3, [sp, #8]
  cc:	2316      	movs	r3, #22
  ce:	e9cd 5300 	strd	r5, r3, [sp]
  d2:	463a      	mov	r2, r7
  d4:	464b      	mov	r3, r9
  d6:	4641      	mov	r1, r8
  d8:	4620      	mov	r0, r4
  da:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
            if (ret >= 0)
  de:	1e03      	subs	r3, r0, #0
  e0:	da10      	bge.n	104 <SendHandshakeMsg.constprop.0+0x104>
}
  e2:	4618      	mov	r0, r3
  e4:	b009      	add	sp, #36	; 0x24
  e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                AddRecordHeader(output, fragSz, handshake, ssl, CUR_ORDER);
  ea:	4623      	mov	r3, r4
  ec:	2216      	movs	r2, #22
  ee:	4629      	mov	r1, r5
  f0:	4640      	mov	r0, r8
  f2:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
            XMEMCPY(output + headerSz, data, fragSz);
  f6:	462a      	mov	r2, r5
  f8:	4649      	mov	r1, r9
  fa:	f108 0005 	add.w	r0, r8, #5
  fe:	f7ff fffe 	bl	0 <memcpy>
 102:	463b      	mov	r3, r7
        ssl->buffers.outputBuffer.length += outputSz;
 104:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
 108:	4418      	add	r0, r3
        ssl->fragOffset += fragSz;
 10a:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
        ssl->buffers.outputBuffer.length += outputSz;
 10e:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
        ssl->fragOffset += fragSz;
 112:	442b      	add	r3, r5
 114:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
        if (!ssl->options.groupMessages)
 118:	f994 3274 	ldrsb.w	r3, [r4, #628]	; 0x274
 11c:	2b00      	cmp	r3, #0
 11e:	db98      	blt.n	52 <SendHandshakeMsg.constprop.0+0x52>
            ret = SendBuffered(ssl);
 120:	4620      	mov	r0, r4
 122:	f7ff fffe 	bl	0 <SendHandshakeMsg.constprop.0>
 126:	e791      	b.n	4c <SendHandshakeMsg.constprop.0+0x4c>
        return BAD_FUNC_ARG;
 128:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 12c:	e7d9      	b.n	e2 <SendHandshakeMsg.constprop.0+0xe2>
            return MEMORY_E;
 12e:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 132:	e7d6      	b.n	e2 <SendHandshakeMsg.constprop.0+0xe2>

Disassembly of section .text.SendCertificate:

00000000 <SendCertificate>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (ssl->options.usingPSK_cipher || ssl->options.usingAnon_cipher) {
   4:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
   8:	f013 030c 	ands.w	r3, r3, #12
{
   c:	b093      	sub	sp, #76	; 0x4c
   e:	4604      	mov	r4, r0
    if (ssl->options.usingPSK_cipher || ssl->options.usingAnon_cipher) {
  10:	f040 81bd 	bne.w	38e <SendCertificate+0x38e>
    if (ssl->options.sendVerify == SEND_BLANK_CERT) {
  14:	f890 2270 	ldrb.w	r2, [r0, #624]	; 0x270
  18:	f002 0203 	and.w	r2, r2, #3
  1c:	2a02      	cmp	r2, #2
  1e:	d057      	beq.n	d0 <SendCertificate+0xd0>
        if (!ssl->buffers.certificate) {
  20:	f8d0 30dc 	ldr.w	r3, [r0, #220]	; 0xdc
  24:	2b00      	cmp	r3, #0
  26:	f000 81b4 	beq.w	392 <SendCertificate+0x392>
        certSz = ssl->buffers.certificate->length;
  2a:	f8d3 8008 	ldr.w	r8, [r3, #8]
        if (certSz && ssl->buffers.certChain) {
  2e:	f1b8 0f00 	cmp.w	r8, #0
  32:	d054      	beq.n	de <SendCertificate+0xde>
        listSz = certSz + CERT_HEADER_SZ;
  34:	f108 0303 	add.w	r3, r8, #3
  38:	9307      	str	r3, [sp, #28]
        if (certSz && ssl->buffers.certChain) {
  3a:	f8d0 30f0 	ldr.w	r3, [r0, #240]	; 0xf0
        length = certSz + headerSz;
  3e:	f108 0a06 	add.w	sl, r8, #6
        if (certSz && ssl->buffers.certChain) {
  42:	2b00      	cmp	r3, #0
  44:	d053      	beq.n	ee <SendCertificate+0xee>
            certChainSz = ssl->buffers.certChain->length;
  46:	689b      	ldr	r3, [r3, #8]
  48:	9306      	str	r3, [sp, #24]
            listSz += certChainSz;
  4a:	9a06      	ldr	r2, [sp, #24]
            length += certChainSz;
  4c:	449a      	add	sl, r3
            listSz += certChainSz;
  4e:	f108 0303 	add.w	r3, r8, #3
  52:	4413      	add	r3, r2
  54:	9307      	str	r3, [sp, #28]
        headerSz = 2 * CERT_HEADER_SZ;
  56:	2306      	movs	r3, #6
  58:	9308      	str	r3, [sp, #32]
    if (ssl->fragOffset != 0)
  5a:	f8d4 712c 	ldr.w	r7, [r4, #300]	; 0x12c
  5e:	2f00      	cmp	r7, #0
  60:	d049      	beq.n	f6 <SendCertificate+0xf6>
        length -= (ssl->fragOffset + headerSz);
  62:	9b08      	ldr	r3, [sp, #32]
  64:	ebaa 0707 	sub.w	r7, sl, r7
  68:	1aff      	subs	r7, r7, r3
    out[0] = (byte)((in >> 16) & 0xff);
  6a:	f3ca 4307 	ubfx	r3, sl, #16, #8
  6e:	930b      	str	r3, [sp, #44]	; 0x2c
    out[1] = (byte)((in >>  8) & 0xff);
  70:	f3ca 2307 	ubfx	r3, sl, #8, #8
  74:	930c      	str	r3, [sp, #48]	; 0x30
    out[0] = (byte)((in >> 16) & 0xff);
  76:	9b07      	ldr	r3, [sp, #28]
  78:	f3c3 4307 	ubfx	r3, r3, #16, #8
  7c:	930d      	str	r3, [sp, #52]	; 0x34
    out[1] = (byte)((in >>  8) & 0xff);
  7e:	9b07      	ldr	r3, [sp, #28]
  80:	f3c3 2307 	ubfx	r3, r3, #8, #8
  84:	930e      	str	r3, [sp, #56]	; 0x38
    out[0] = (byte)((in >> 16) & 0xff);
  86:	f3c8 4307 	ubfx	r3, r8, #16, #8
  8a:	930f      	str	r3, [sp, #60]	; 0x3c
    out[1] = (byte)((in >>  8) & 0xff);
  8c:	f3c8 2307 	ubfx	r3, r8, #8, #8
  90:	9310      	str	r3, [sp, #64]	; 0x40
                if (headerSz + certSz + certChainSz <=
  92:	9b06      	ldr	r3, [sp, #24]
  94:	4443      	add	r3, r8
  96:	2500      	movs	r5, #0
  98:	930a      	str	r3, [sp, #40]	; 0x28
    while (length > 0 && ret == 0) {
  9a:	b107      	cbz	r7, 9e <SendCertificate+0x9e>
  9c:	b36d      	cbz	r5, fa <SendCertificate+0xfa>
    if (ret != WANT_WRITE) {
  9e:	f46f 73a3 	mvn.w	r3, #326	; 0x146
  a2:	429d      	cmp	r5, r3
  a4:	d010      	beq.n	c8 <SendCertificate+0xc8>
        ssl->options.buildingMsg = 0;
  a6:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  aa:	f36f 03c3 	bfc	r3, #3, #1
  ae:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
        ssl->fragOffset = 0;
  b2:	2300      	movs	r3, #0
  b4:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
        if (ssl->options.side == WOLFSSL_SERVER_END){
  b8:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  bc:	f013 0f30 	tst.w	r3, #48	; 0x30
  c0:	d102      	bne.n	c8 <SendCertificate+0xc8>
            ssl->options.serverState = SERVER_CERT_COMPLETE;
  c2:	2305      	movs	r3, #5
  c4:	f884 327c 	strb.w	r3, [r4, #636]	; 0x27c
}
  c8:	4628      	mov	r0, r5
  ca:	b013      	add	sp, #76	; 0x4c
  cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            length = CERT_HEADER_SZ;
  d0:	f04f 0a03 	mov.w	sl, #3
            headerSz = CERT_HEADER_SZ;
  d4:	e9cd 3a07 	strd	r3, sl, [sp, #28]
            certChainSz = 0;
  d8:	9306      	str	r3, [sp, #24]
            certSz = 0;
  da:	4698      	mov	r8, r3
  dc:	e7bd      	b.n	5a <SendCertificate+0x5a>
  de:	f04f 0a06 	mov.w	sl, #6
  e2:	2303      	movs	r3, #3
        headerSz = 2 * CERT_HEADER_SZ;
  e4:	e9cd 3a07 	strd	r3, sl, [sp, #28]
            certChainSz = 0;
  e8:	f8cd 8018 	str.w	r8, [sp, #24]
  ec:	e7b5      	b.n	5a <SendCertificate+0x5a>
        headerSz = 2 * CERT_HEADER_SZ;
  ee:	2206      	movs	r2, #6
  f0:	9208      	str	r2, [sp, #32]
            certChainSz = 0;
  f2:	9306      	str	r3, [sp, #24]
  f4:	e7b1      	b.n	5a <SendCertificate+0x5a>
  f6:	4657      	mov	r7, sl
  f8:	e7b7      	b.n	6a <SendCertificate+0x6a>
        ssl->options.buildingMsg = 1;
  fa:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  fe:	f043 0308 	orr.w	r3, r3, #8
 102:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
        if (!ssl->options.dtls) {
 106:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 10a:	0759      	lsls	r1, r3, #29
 10c:	f100 80da 	bmi.w	2c4 <SendCertificate+0x2c4>
            if (ssl->fragOffset == 0)  {
 110:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
 114:	2b00      	cmp	r3, #0
 116:	f040 80cb 	bne.w	2b0 <SendCertificate+0x2b0>
                if (headerSz + certSz + certChainSz <=
 11a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 11c:	9a08      	ldr	r2, [sp, #32]
 11e:	189d      	adds	r5, r3, r2
 120:	f643 73fc 	movw	r3, #16380	; 0x3ffc
 124:	429d      	cmp	r5, r3
 126:	bf28      	it	cs
 128:	461d      	movcs	r5, r3
                sendSz += fragSz + HANDSHAKE_HEADER_SZ;
 12a:	f105 0b09 	add.w	fp, r5, #9
                i += HANDSHAKE_HEADER_SZ;
 12e:	2609      	movs	r6, #9
            if (IsEncryptionOn(ssl, 1))
 130:	2101      	movs	r1, #1
 132:	4620      	mov	r0, r4
 134:	f7ff fffe 	bl	0 <SendCertificate>
 138:	b108      	cbz	r0, 13e <SendCertificate+0x13e>
                sendSz += MAX_MSG_EXTRA;
 13a:	f10b 0b66 	add.w	fp, fp, #102	; 0x66
        if (IsEncryptionOn(ssl, 1))
 13e:	2101      	movs	r1, #1
 140:	4620      	mov	r0, r4
 142:	f7ff fffe 	bl	0 <SendCertificate>
 146:	b118      	cbz	r0, 150 <SendCertificate+0x150>
            sendSz += cipherExtraData(ssl);
 148:	4620      	mov	r0, r4
 14a:	f7ff fffe 	bl	0 <SendCertificate>
 14e:	4483      	add	fp, r0
        if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
 150:	4659      	mov	r1, fp
 152:	4620      	mov	r0, r4
 154:	f7ff fffe 	bl	0 <SendCertificate>
 158:	9009      	str	r0, [sp, #36]	; 0x24
 15a:	2800      	cmp	r0, #0
 15c:	f040 811b 	bne.w	396 <SendCertificate+0x396>
        output = GetOutputBuffer(ssl);
 160:	4620      	mov	r0, r4
 162:	f7ff fffe 	bl	0 <SendCertificate>
            if (!ssl->options.dtls) {
 166:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
        if (ssl->fragOffset == 0) {
 16a:	f8d4 212c 	ldr.w	r2, [r4, #300]	; 0x12c
        output = GetOutputBuffer(ssl);
 16e:	4681      	mov	r9, r0
            if (!ssl->options.dtls) {
 170:	f003 0304 	and.w	r3, r3, #4
        if (ssl->fragOffset == 0) {
 174:	2a00      	cmp	r2, #0
 176:	f040 80fe 	bne.w	376 <SendCertificate+0x376>
            if (!ssl->options.dtls) {
 17a:	b9bb      	cbnz	r3, 1ac <SendCertificate+0x1ac>
    AddRecordHeader(output, fragSz + lengthAdj, handshake, ssl, CUR_ORDER);
 17c:	4623      	mov	r3, r4
 17e:	1d29      	adds	r1, r5, #4
 180:	2216      	movs	r2, #22
 182:	f7ff fffe 	bl	0 <SendCertificate>
    hs->type = type;
 186:	230b      	movs	r3, #11
 188:	7143      	strb	r3, [r0, #5]
    out[0] = (byte)((in >> 16) & 0xff);
 18a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 18c:	7183      	strb	r3, [r0, #6]
    out[1] = (byte)((in >>  8) & 0xff);
 18e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 190:	71c3      	strb	r3, [r0, #7]
    out[2] =  (byte)(in        & 0xff);
 192:	f880 a008 	strb.w	sl, [r0, #8]
                if (!IsEncryptionOn(ssl, 1))
 196:	2101      	movs	r1, #1
 198:	4620      	mov	r0, r4
 19a:	f7ff fffe 	bl	0 <SendCertificate>
 19e:	b928      	cbnz	r0, 1ac <SendCertificate+0x1ac>
                    HashRaw(ssl, output + RECORD_HEADER_SZ,
 1a0:	2204      	movs	r2, #4
 1a2:	f109 0105 	add.w	r1, r9, #5
 1a6:	4620      	mov	r0, r4
 1a8:	f7ff fffe 	bl	0 <SendCertificate>
    out[0] = (byte)((in >> 16) & 0xff);
 1ac:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 1ae:	f809 2006 	strb.w	r2, [r9, r6]
            c32to24(listSz, output + i);
 1b2:	eb09 0306 	add.w	r3, r9, r6
    out[1] = (byte)((in >>  8) & 0xff);
 1b6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 1b8:	705a      	strb	r2, [r3, #1]
    out[2] =  (byte)(in        & 0xff);
 1ba:	9a07      	ldr	r2, [sp, #28]
 1bc:	709a      	strb	r2, [r3, #2]
            if (ssl->options.dtls || !IsEncryptionOn(ssl, 1))
 1be:	f894 2272 	ldrb.w	r2, [r4, #626]	; 0x272
 1c2:	0752      	lsls	r2, r2, #29
 1c4:	d406      	bmi.n	1d4 <SendCertificate+0x1d4>
 1c6:	2101      	movs	r1, #1
 1c8:	4620      	mov	r0, r4
 1ca:	9311      	str	r3, [sp, #68]	; 0x44
 1cc:	f7ff fffe 	bl	0 <SendCertificate>
 1d0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 1d2:	b920      	cbnz	r0, 1de <SendCertificate+0x1de>
                HashRaw(ssl, output + i, CERT_HEADER_SZ);
 1d4:	2203      	movs	r2, #3
 1d6:	4619      	mov	r1, r3
 1d8:	4620      	mov	r0, r4
 1da:	f7ff fffe 	bl	0 <SendCertificate>
            i += CERT_HEADER_SZ;
 1de:	1cf2      	adds	r2, r6, #3
            if (certSz) {
 1e0:	f1b8 0f00 	cmp.w	r8, #0
 1e4:	d172      	bne.n	2cc <SendCertificate+0x2cc>
            length -= CERT_HEADER_SZ;
 1e6:	3f03      	subs	r7, #3
            fragSz -= CERT_HEADER_SZ;
 1e8:	3d03      	subs	r5, #3
            i += CERT_HEADER_SZ;
 1ea:	4616      	mov	r6, r2
        if (certChainSz && fragSz) {
 1ec:	9b06      	ldr	r3, [sp, #24]
 1ee:	b1cb      	cbz	r3, 224 <SendCertificate+0x224>
 1f0:	b1c5      	cbz	r5, 224 <SendCertificate+0x224>
            word32 copySz = min(certChainSz + certSz - ssl->fragOffset, fragSz);
 1f2:	f8d4 112c 	ldr.w	r1, [r4, #300]	; 0x12c
 1f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 1f8:	1a5a      	subs	r2, r3, r1
            XMEMCPY(output + i,
 1fa:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
        return a > b ? b : a;
 1fe:	4295      	cmp	r5, r2
 200:	681b      	ldr	r3, [r3, #0]
 202:	bf28      	it	cs
 204:	4615      	movcs	r5, r2
 206:	eba1 0108 	sub.w	r1, r1, r8
 20a:	4419      	add	r1, r3
 20c:	eb09 0006 	add.w	r0, r9, r6
 210:	462a      	mov	r2, r5
 212:	f7ff fffe 	bl	0 <memcpy>
            ssl->fragOffset += copySz;
 216:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
 21a:	442b      	add	r3, r5
            i += copySz;
 21c:	442e      	add	r6, r5
            ssl->fragOffset += copySz;
 21e:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
            length -= copySz;
 222:	1b7f      	subs	r7, r7, r5
        if (IsEncryptionOn(ssl, 1)) {
 224:	2101      	movs	r1, #1
 226:	4620      	mov	r0, r4
 228:	f7ff fffe 	bl	0 <SendCertificate>
            int   inputSz = i; /* build msg adds rec hdr */
 22c:	4635      	mov	r5, r6
        if (IsEncryptionOn(ssl, 1)) {
 22e:	b380      	cbz	r0, 292 <SendCertificate+0x292>
            if (ssl->options.dtls)
 230:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
                recordHeaderSz += DTLS_RECORD_EXTRA;
 234:	f013 0f04 	tst.w	r3, #4
 238:	bf0c      	ite	eq
 23a:	2105      	moveq	r1, #5
 23c:	210d      	movne	r1, #13
            inputSz -= recordHeaderSz;
 23e:	1a75      	subs	r5, r6, r1
            if (inputSz < 0) {
 240:	2d00      	cmp	r5, #0
            inputSz -= recordHeaderSz;
 242:	9111      	str	r1, [sp, #68]	; 0x44
            if (inputSz < 0) {
 244:	f2c0 80a9 	blt.w	39a <SendCertificate+0x39a>
            if (inputSz > 0) {  /* clang thinks could be zero, let's help */
 248:	f000 809f 	beq.w	38a <SendCertificate+0x38a>
                input = (byte*)XMALLOC(inputSz, ssl->heap,
 24c:	4628      	mov	r0, r5
 24e:	f7ff fffe 	bl	0 <malloc>
                if (input == NULL)
 252:	4606      	mov	r6, r0
 254:	2800      	cmp	r0, #0
 256:	f000 80a3 	beq.w	3a0 <SendCertificate+0x3a0>
                XMEMCPY(input, output + recordHeaderSz, inputSz);
 25a:	9911      	ldr	r1, [sp, #68]	; 0x44
 25c:	462a      	mov	r2, r5
 25e:	4449      	add	r1, r9
 260:	f7ff fffe 	bl	0 <memcpy>
            sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
 264:	2300      	movs	r3, #0
 266:	e9cd 3304 	strd	r3, r3, [sp, #16]
 26a:	9303      	str	r3, [sp, #12]
 26c:	2201      	movs	r2, #1
 26e:	2316      	movs	r3, #22
 270:	e9cd 3201 	strd	r3, r2, [sp, #4]
 274:	9500      	str	r5, [sp, #0]
 276:	4633      	mov	r3, r6
 278:	465a      	mov	r2, fp
 27a:	4649      	mov	r1, r9
 27c:	4620      	mov	r0, r4
 27e:	f7ff fffe 	bl	0 <SendCertificate>
 282:	4605      	mov	r5, r0
            XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 284:	b116      	cbz	r6, 28c <SendCertificate+0x28c>
 286:	4630      	mov	r0, r6
 288:	f7ff fffe 	bl	0 <free>
            if (sendSz < 0)
 28c:	2d00      	cmp	r5, #0
 28e:	f6ff af1b 	blt.w	c8 <SendCertificate+0xc8>
        ssl->buffers.outputBuffer.length += sendSz;
 292:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
        if (!ssl->options.groupMessages)
 296:	f994 3274 	ldrsb.w	r3, [r4, #628]	; 0x274
        ssl->buffers.outputBuffer.length += sendSz;
 29a:	4415      	add	r5, r2
        if (!ssl->options.groupMessages)
 29c:	2b00      	cmp	r3, #0
        ssl->buffers.outputBuffer.length += sendSz;
 29e:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
        if (!ssl->options.groupMessages)
 2a2:	db03      	blt.n	2ac <SendCertificate+0x2ac>
            ret = SendBuffered(ssl);
 2a4:	4620      	mov	r0, r4
 2a6:	f7ff fffe 	bl	0 <SendCertificate>
 2aa:	9009      	str	r0, [sp, #36]	; 0x24
    out[1] = (byte)((in >>  8) & 0xff);
 2ac:	9d09      	ldr	r5, [sp, #36]	; 0x24
 2ae:	e6f4      	b.n	9a <SendCertificate+0x9a>
        return a > b ? b : a;
 2b0:	f5b7 4f80 	cmp.w	r7, #16384	; 0x4000
 2b4:	463d      	mov	r5, r7
 2b6:	bf28      	it	cs
 2b8:	f44f 4580 	movcs.w	r5, #16384	; 0x4000
                sendSz += fragSz;
 2bc:	f105 0b05 	add.w	fp, r5, #5
        word32 i = RECORD_HEADER_SZ;
 2c0:	2605      	movs	r6, #5
 2c2:	e735      	b.n	130 <SendCertificate+0x130>
        int    sendSz = RECORD_HEADER_SZ;
 2c4:	f04f 0b05 	mov.w	fp, #5
        word32 i = RECORD_HEADER_SZ;
 2c8:	465e      	mov	r6, fp
 2ca:	e738      	b.n	13e <SendCertificate+0x13e>
                c32to24(certSz, output + i);
 2cc:	eb09 0302 	add.w	r3, r9, r2
    out[0] = (byte)((in >> 16) & 0xff);
 2d0:	990f      	ldr	r1, [sp, #60]	; 0x3c
 2d2:	f809 1002 	strb.w	r1, [r9, r2]
    out[1] = (byte)((in >>  8) & 0xff);
 2d6:	9a10      	ldr	r2, [sp, #64]	; 0x40
 2d8:	705a      	strb	r2, [r3, #1]
    out[2] =  (byte)(in        & 0xff);
 2da:	f883 8002 	strb.w	r8, [r3, #2]
                if (ssl->options.dtls || !IsEncryptionOn(ssl, 1))
 2de:	f894 2272 	ldrb.w	r2, [r4, #626]	; 0x272
 2e2:	0750      	lsls	r0, r2, #29
 2e4:	d406      	bmi.n	2f4 <SendCertificate+0x2f4>
 2e6:	2101      	movs	r1, #1
 2e8:	4620      	mov	r0, r4
 2ea:	9311      	str	r3, [sp, #68]	; 0x44
 2ec:	f7ff fffe 	bl	0 <SendCertificate>
 2f0:	9b11      	ldr	r3, [sp, #68]	; 0x44
 2f2:	b920      	cbnz	r0, 2fe <SendCertificate+0x2fe>
                    HashRaw(ssl, output + i, CERT_HEADER_SZ);
 2f4:	2203      	movs	r2, #3
 2f6:	4619      	mov	r1, r3
 2f8:	4620      	mov	r0, r4
 2fa:	f7ff fffe 	bl	0 <SendCertificate>
                if (ssl->options.dtls || !IsEncryptionOn(ssl, 1)) {
 2fe:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 302:	0759      	lsls	r1, r3, #29
                i += CERT_HEADER_SZ;
 304:	f106 0606 	add.w	r6, r6, #6
                length -= CERT_HEADER_SZ;
 308:	f1a7 0706 	sub.w	r7, r7, #6
                fragSz -= CERT_HEADER_SZ;
 30c:	f1a5 0506 	sub.w	r5, r5, #6
                if (ssl->options.dtls || !IsEncryptionOn(ssl, 1)) {
 310:	d404      	bmi.n	31c <SendCertificate+0x31c>
 312:	2101      	movs	r1, #1
 314:	4620      	mov	r0, r4
 316:	f7ff fffe 	bl	0 <SendCertificate>
 31a:	b978      	cbnz	r0, 33c <SendCertificate+0x33c>
                    HashRaw(ssl, ssl->buffers.certificate->buffer, certSz);
 31c:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 320:	4642      	mov	r2, r8
 322:	6819      	ldr	r1, [r3, #0]
 324:	4620      	mov	r0, r4
 326:	f7ff fffe 	bl	0 <SendCertificate>
                    if (certChainSz)
 32a:	9b06      	ldr	r3, [sp, #24]
 32c:	b133      	cbz	r3, 33c <SendCertificate+0x33c>
                        HashRaw(ssl, ssl->buffers.certChain->buffer,
 32e:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 332:	9a06      	ldr	r2, [sp, #24]
 334:	6819      	ldr	r1, [r3, #0]
 336:	4620      	mov	r0, r4
 338:	f7ff fffe 	bl	0 <SendCertificate>
        if (certSz && ssl->fragOffset < certSz) {
 33c:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
 340:	4543      	cmp	r3, r8
 342:	f4bf af53 	bcs.w	1ec <SendCertificate+0x1ec>
            XMEMCPY(output + i,
 346:	f8d4 10dc 	ldr.w	r1, [r4, #220]	; 0xdc
            word32 copySz = min(certSz - ssl->fragOffset, fragSz);
 34a:	eba8 0203 	sub.w	r2, r8, r3
            XMEMCPY(output + i,
 34e:	6809      	ldr	r1, [r1, #0]
        return a > b ? b : a;
 350:	42aa      	cmp	r2, r5
 352:	bf28      	it	cs
 354:	462a      	movcs	r2, r5
 356:	4419      	add	r1, r3
 358:	eb09 0006 	add.w	r0, r9, r6
 35c:	9211      	str	r2, [sp, #68]	; 0x44
 35e:	f7ff fffe 	bl	0 <memcpy>
            i += copySz;
 362:	9a11      	ldr	r2, [sp, #68]	; 0x44
            ssl->fragOffset += copySz;
 364:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
 368:	4413      	add	r3, r2
            i += copySz;
 36a:	4416      	add	r6, r2
            ssl->fragOffset += copySz;
 36c:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
            length -= copySz;
 370:	1abf      	subs	r7, r7, r2
            fragSz -= copySz;
 372:	1aad      	subs	r5, r5, r2
 374:	e73a      	b.n	1ec <SendCertificate+0x1ec>
            if (!ssl->options.dtls) {
 376:	b923      	cbnz	r3, 382 <SendCertificate+0x382>
                AddRecordHeader(output, fragSz, handshake, ssl, CUR_ORDER);
 378:	4623      	mov	r3, r4
 37a:	2216      	movs	r2, #22
 37c:	4629      	mov	r1, r5
 37e:	f7ff fffe 	bl	0 <SendCertificate>
        if (certSz && ssl->fragOffset < certSz) {
 382:	f1b8 0f00 	cmp.w	r8, #0
 386:	d1d9      	bne.n	33c <SendCertificate+0x33c>
 388:	e730      	b.n	1ec <SendCertificate+0x1ec>
            byte* input = NULL;
 38a:	462e      	mov	r6, r5
 38c:	e76a      	b.n	264 <SendCertificate+0x264>
        return 0;  /* not needed */
 38e:	2500      	movs	r5, #0
 390:	e69a      	b.n	c8 <SendCertificate+0xc8>
            return BUFFER_ERROR;
 392:	4d05      	ldr	r5, [pc, #20]	; (3a8 <SendCertificate+0x3a8>)
 394:	e698      	b.n	c8 <SendCertificate+0xc8>
 396:	9d09      	ldr	r5, [sp, #36]	; 0x24
 398:	e696      	b.n	c8 <SendCertificate+0xc8>
                return BUFFER_E;
 39a:	f06f 0583 	mvn.w	r5, #131	; 0x83
 39e:	e693      	b.n	c8 <SendCertificate+0xc8>
                    return MEMORY_E;
 3a0:	f06f 057c 	mvn.w	r5, #124	; 0x7c
 3a4:	e690      	b.n	c8 <SendCertificate+0xc8>
 3a6:	bf00      	nop
 3a8:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.SendCertificateRequest:

00000000 <SendCertificateRequest>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    const Suites* suites = WOLFSSL_SUITES(ssl);
   4:	6845      	ldr	r5, [r0, #4]
{
   6:	b087      	sub	sp, #28
   8:	4604      	mov	r4, r0
    const Suites* suites = WOLFSSL_SUITES(ssl);
   a:	b90d      	cbnz	r5, 10 <SendCertificateRequest+0x10>
   c:	6803      	ldr	r3, [r0, #0]
   e:	6add      	ldr	r5, [r3, #44]	; 0x2c
    if (IsAtLeastTLSv1_2(ssl))
  10:	4620      	mov	r0, r4
  12:	f7ff fffe 	bl	0 <SendCertificateRequest>
  16:	b1d8      	cbz	r0, 50 <SendCertificateRequest+0x50>
        reqSz += LENGTH_SZ + suites->hashSigAlgoSz;
  18:	f8b5 9002 	ldrh.w	r9, [r5, #2]
  1c:	f109 0906 	add.w	r9, r9, #6
    if (ssl->options.usingPSK_cipher || ssl->options.usingAnon_cipher)
  20:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
  24:	f013 0f0c 	tst.w	r3, #12
  28:	f040 80aa 	bne.w	180 <SendCertificateRequest+0x180>
        if (IsEncryptionOn(ssl, 1))
  2c:	2101      	movs	r1, #1
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <SendCertificateRequest>
    if (!ssl->options.dtls) {
  34:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  38:	0759      	lsls	r1, r3, #29
    sendSz = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ + reqSz;
  3a:	f109 0809 	add.w	r8, r9, #9
    if (!ssl->options.dtls) {
  3e:	d40a      	bmi.n	56 <SendCertificateRequest+0x56>
        if (IsEncryptionOn(ssl, 1))
  40:	b158      	cbz	r0, 5a <SendCertificateRequest+0x5a>
            sendSz += MAX_MSG_EXTRA;
  42:	f109 086f 	add.w	r8, r9, #111	; 0x6f
        sendSz += cipherExtraData(ssl);
  46:	4620      	mov	r0, r4
  48:	f7ff fffe 	bl	0 <SendCertificateRequest>
  4c:	4480      	add	r8, r0
  4e:	e004      	b.n	5a <SendCertificateRequest+0x5a>
    int  reqSz = ENUM_LEN + typeTotal + REQ_HEADER_SZ;  /* add auth later */
  50:	f04f 0904 	mov.w	r9, #4
  54:	e7e4      	b.n	20 <SendCertificateRequest+0x20>
    if (IsEncryptionOn(ssl, 1))
  56:	2800      	cmp	r0, #0
  58:	d1f5      	bne.n	46 <SendCertificateRequest+0x46>
    ssl->options.buildingMsg = 1;
  5a:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  5e:	f043 0308 	orr.w	r3, r3, #8
  62:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
    if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
  66:	4641      	mov	r1, r8
  68:	4620      	mov	r0, r4
  6a:	f7ff fffe 	bl	0 <SendCertificateRequest>
  6e:	4607      	mov	r7, r0
  70:	2800      	cmp	r0, #0
  72:	f040 8083 	bne.w	17c <SendCertificateRequest+0x17c>
    output = GetOutputBuffer(ssl);
  76:	4620      	mov	r0, r4
  78:	f7ff fffe 	bl	0 <SendCertificateRequest>
    AddHeaders(output, reqSz, certificate_request, ssl);
  7c:	4649      	mov	r1, r9
  7e:	4623      	mov	r3, r4
  80:	220d      	movs	r2, #13
  82:	f7ff fffe 	bl	0 <SendCertificateRequest>
    output[i++] = (byte)typeTotal;  /* # of types */
  86:	2301      	movs	r3, #1
  88:	7243      	strb	r3, [r0, #9]
    if ((ssl->options.cipherSuite0 == ECC_BYTE ||
  8a:	f894 2278 	ldrb.w	r2, [r4, #632]	; 0x278
  8e:	2ac0      	cmp	r2, #192	; 0xc0
    output = GetOutputBuffer(ssl);
  90:	4606      	mov	r6, r0
    if ((ssl->options.cipherSuite0 == ECC_BYTE ||
  92:	d001      	beq.n	98 <SendCertificateRequest+0x98>
  94:	2acc      	cmp	r2, #204	; 0xcc
  96:	d105      	bne.n	a4 <SendCertificateRequest+0xa4>
         ssl->options.cipherSuite0 == CHACHA_BYTE) &&
  98:	f894 314c 	ldrb.w	r3, [r4, #332]	; 0x14c
        output[i++] = ecdsa_sign;
  9c:	2b03      	cmp	r3, #3
  9e:	bf14      	ite	ne
  a0:	2301      	movne	r3, #1
  a2:	2340      	moveq	r3, #64	; 0x40
  a4:	72b3      	strb	r3, [r6, #10]
    if (IsAtLeastTLSv1_2(ssl)) {
  a6:	4620      	mov	r0, r4
  a8:	f7ff fffe 	bl	0 <SendCertificateRequest>
  ac:	2800      	cmp	r0, #0
  ae:	d04a      	beq.n	146 <SendCertificateRequest+0x146>
        c16toa(suites->hashSigAlgoSz, &output[i]);
  b0:	886b      	ldrh	r3, [r5, #2]
    c[1] =  (byte)(wc_u16       & 0xff);
  b2:	7333      	strb	r3, [r6, #12]
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  b4:	0a1a      	lsrs	r2, r3, #8
  b6:	72f2      	strb	r2, [r6, #11]
        XMEMCPY(&output[i], suites->hashSigAlgo, suites->hashSigAlgoSz);
  b8:	886a      	ldrh	r2, [r5, #2]
  ba:	f505 7198 	add.w	r1, r5, #304	; 0x130
  be:	f106 000d 	add.w	r0, r6, #13
  c2:	f7ff fffe 	bl	0 <memcpy>
        i += suites->hashSigAlgoSz;
  c6:	886d      	ldrh	r5, [r5, #2]
  c8:	350d      	adds	r5, #13
    c16toa((word16)dnLen, &output[i]);  /* auth's */
  ca:	1973      	adds	r3, r6, r5
  cc:	f04f 0a00 	mov.w	sl, #0
  d0:	f806 a005 	strb.w	sl, [r6, r5]
        if (IsEncryptionOn(ssl, 1)) {
  d4:	2101      	movs	r1, #1
    c[1] =  (byte)(wc_u16       & 0xff);
  d6:	f883 a001 	strb.w	sl, [r3, #1]
  da:	4620      	mov	r0, r4
  dc:	f7ff fffe 	bl	0 <SendCertificateRequest>
    i += REQ_HEADER_SZ;
  e0:	3502      	adds	r5, #2
        if (IsEncryptionOn(ssl, 1)) {
  e2:	4603      	mov	r3, r0
  e4:	b388      	cbz	r0, 14a <SendCertificateRequest+0x14a>
            if (ssl->options.dtls)
  e6:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
                recordHeaderSz += DTLS_RECORD_EXTRA;
  ea:	f013 0f04 	tst.w	r3, #4
  ee:	bf0c      	ite	eq
  f0:	f04f 0b05 	moveq.w	fp, #5
  f4:	f04f 0b0d 	movne.w	fp, #13
            if (inputSz <= 0) {
  f8:	ebb5 050b 	subs.w	r5, r5, fp
  fc:	d042      	beq.n	184 <SendCertificateRequest+0x184>
            input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
  fe:	4628      	mov	r0, r5
 100:	f7ff fffe 	bl	0 <malloc>
            if (input == NULL)
 104:	4681      	mov	r9, r0
 106:	2800      	cmp	r0, #0
 108:	d03f      	beq.n	18a <SendCertificateRequest+0x18a>
            XMEMCPY(input, output + recordHeaderSz, inputSz);
 10a:	462a      	mov	r2, r5
 10c:	eb06 010b 	add.w	r1, r6, fp
 110:	f7ff fffe 	bl	0 <memcpy>
            sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
 114:	2316      	movs	r3, #22
 116:	2201      	movs	r2, #1
 118:	e9cd 3201 	strd	r3, r2, [sp, #4]
 11c:	9500      	str	r5, [sp, #0]
 11e:	464b      	mov	r3, r9
 120:	4642      	mov	r2, r8
 122:	4631      	mov	r1, r6
 124:	e9cd aa04 	strd	sl, sl, [sp, #16]
 128:	f8cd a00c 	str.w	sl, [sp, #12]
 12c:	4620      	mov	r0, r4
 12e:	f7ff fffe 	bl	0 <SendCertificateRequest>
 132:	4605      	mov	r5, r0
            XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 134:	4648      	mov	r0, r9
 136:	f7ff fffe 	bl	0 <free>
            if (sendSz < 0)
 13a:	4555      	cmp	r5, sl
 13c:	da0b      	bge.n	156 <SendCertificateRequest+0x156>
}
 13e:	4628      	mov	r0, r5
 140:	b007      	add	sp, #28
 142:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 146:	250b      	movs	r5, #11
 148:	e7bf      	b.n	ca <SendCertificateRequest+0xca>
            ret = HashOutput(ssl, output, sendSz, 0);
 14a:	462a      	mov	r2, r5
 14c:	4631      	mov	r1, r6
 14e:	4620      	mov	r0, r4
 150:	f7ff fffe 	bl	0 <SendCertificateRequest>
            if (ret != 0)
 154:	b9e0      	cbnz	r0, 190 <SendCertificateRequest+0x190>
    ssl->buffers.outputBuffer.length += sendSz;
 156:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
    if (ssl->options.groupMessages)
 15a:	f994 3274 	ldrsb.w	r3, [r4, #628]	; 0x274
    ssl->buffers.outputBuffer.length += sendSz;
 15e:	442a      	add	r2, r5
    if (ssl->options.groupMessages)
 160:	2b00      	cmp	r3, #0
    ssl->buffers.outputBuffer.length += sendSz;
 162:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
    if (ssl->options.groupMessages)
 166:	db03      	blt.n	170 <SendCertificateRequest+0x170>
        ret = SendBuffered(ssl);
 168:	4620      	mov	r0, r4
 16a:	f7ff fffe 	bl	0 <SendCertificateRequest>
 16e:	4607      	mov	r7, r0
    ssl->options.buildingMsg = 0;
 170:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
 174:	f36f 03c3 	bfc	r3, #3, #1
 178:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
    return ret;
 17c:	463d      	mov	r5, r7
 17e:	e7de      	b.n	13e <SendCertificateRequest+0x13e>
        return 0;  /* not needed */
 180:	2500      	movs	r5, #0
 182:	e7dc      	b.n	13e <SendCertificateRequest+0x13e>
                return BUFFER_E;
 184:	f06f 0583 	mvn.w	r5, #131	; 0x83
 188:	e7d9      	b.n	13e <SendCertificateRequest+0x13e>
                return MEMORY_E;
 18a:	f06f 057c 	mvn.w	r5, #124	; 0x7c
 18e:	e7d6      	b.n	13e <SendCertificateRequest+0x13e>
 190:	4605      	mov	r5, r0
 192:	e7d4      	b.n	13e <SendCertificateRequest+0x13e>

Disassembly of section .text.SendCertificateStatus:

00000000 <SendCertificateStatus>:
}
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.IsSCR:

00000000 <IsSCR>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.RetrySendAlert:

00000000 <RetrySendAlert>:
    int severity = ssl->pendingAlert.level;
   0:	f8d0 1110 	ldr.w	r1, [r0, #272]	; 0x110
{
   4:	b410      	push	{r4}
    if (severity == alert_none)
   6:	b139      	cbz	r1, 18 <RetrySendAlert+0x18>
    ssl->pendingAlert.code = 0;
   8:	2400      	movs	r4, #0
    int type = ssl->pendingAlert.code;
   a:	f8d0 210c 	ldr.w	r2, [r0, #268]	; 0x10c
    ssl->pendingAlert.level = alert_none;
   e:	e9c0 4443 	strd	r4, r4, [r0, #268]	; 0x10c
}
  12:	bc10      	pop	{r4}
    return SendAlert_ex(ssl, severity, type);
  14:	f7ff bffe 	b.w	0 <RetrySendAlert>
}
  18:	4608      	mov	r0, r1
  1a:	bc10      	pop	{r4}
  1c:	4770      	bx	lr

Disassembly of section .text.SendData:

00000000 <SendData>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4617      	mov	r7, r2
    if (ssl->error == WANT_WRITE
   6:	f8d0 2114 	ldr.w	r2, [r0, #276]	; 0x114
   a:	f46f 73a3 	mvn.w	r3, #326	; 0x146
   e:	429a      	cmp	r2, r3
        ssl->error = 0;
  10:	bf04      	itt	eq
  12:	2300      	moveq	r3, #0
  14:	f8c0 3114 	streq.w	r3, [r0, #276]	; 0x114
    if (ssl->error == VERIFY_MAC_ERROR || ssl->error == DECRYPT_ERROR) {
  18:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
  1c:	f46f 7298 	mvn.w	r2, #304	; 0x130
  20:	4293      	cmp	r3, r2
{
  22:	b087      	sub	sp, #28
  24:	4604      	mov	r4, r0
  26:	4689      	mov	r9, r1
    if (ssl->error == VERIFY_MAC_ERROR || ssl->error == DECRYPT_ERROR) {
  28:	d002      	beq.n	30 <SendData+0x30>
  2a:	f513 7f9c 	cmn.w	r3, #312	; 0x138
  2e:	d106      	bne.n	3e <SendData+0x3e>
        if (ssl->options.dtls) {
  30:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  34:	0759      	lsls	r1, r3, #29
  36:	d563      	bpl.n	100 <SendData+0x100>
            ssl->error = 0;
  38:	2300      	movs	r3, #0
  3a:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
    if (ssl->options.handShakeState != HANDSHAKE_DONE && !IsSCR(ssl)) {
  3e:	f894 327e 	ldrb.w	r3, [r4, #638]	; 0x27e
  42:	2b10      	cmp	r3, #16
  44:	d132      	bne.n	ac <SendData+0xac>
    if (ssl->buffers.outputBuffer.length > 0
  46:	f8d4 50a0 	ldr.w	r5, [r4, #160]	; 0xa0
  4a:	bbbd      	cbnz	r5, bc <SendData+0xbc>
    ret = RetrySendAlert(ssl);
  4c:	4620      	mov	r0, r4
  4e:	f7ff fffe 	bl	0 <SendData>
    if (ret != 0) {
  52:	2800      	cmp	r0, #0
  54:	d152      	bne.n	fc <SendData+0xfc>
            sendSz = BuildMessage(ssl, out, outputSz, sendBuffer, buffSz,
  56:	f04f 0a17 	mov.w	sl, #23
            buffSz = wolfSSL_GetMaxFragSize(ssl, sz - sent);
  5a:	1b7e      	subs	r6, r7, r5
  5c:	f5b6 4f80 	cmp.w	r6, #16384	; 0x4000
  60:	bfa8      	it	ge
  62:	f44f 4680 	movge.w	r6, #16384	; 0x4000
        if (sent == sz) break;
  66:	42bd      	cmp	r5, r7
        byte* sendBuffer = (byte*)data + sent;  /* may switch on comp */
  68:	eb09 0b05 	add.w	fp, r9, r5
        if (sent == sz) break;
  6c:	d070      	beq.n	150 <SendData+0x150>
        if (IsEncryptionOn(ssl, 1) || ssl->options.tls1_3)
  6e:	2101      	movs	r1, #1
  70:	4620      	mov	r0, r4
        outputSz = buffSz + COMP_EXTRA + DTLS_RECORD_HEADER_SZ;
  72:	f106 080d 	add.w	r8, r6, #13
        if (IsEncryptionOn(ssl, 1) || ssl->options.tls1_3)
  76:	f7ff fffe 	bl	0 <SendData>
  7a:	b918      	cbnz	r0, 84 <SendData+0x84>
  7c:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  80:	07da      	lsls	r2, r3, #31
  82:	d503      	bpl.n	8c <SendData+0x8c>
            outputSz += cipherExtraData(ssl);
  84:	4620      	mov	r0, r4
  86:	f7ff fffe 	bl	0 <SendData>
  8a:	4480      	add	r8, r0
        if ((ret = CheckAvailableSize(ssl, outputSz)) != 0)
  8c:	4641      	mov	r1, r8
  8e:	4620      	mov	r0, r4
  90:	f7ff fffe 	bl	0 <SendData>
  94:	bb78      	cbnz	r0, f6 <SendData+0xf6>
        out = GetOutputBuffer(ssl);
  96:	4620      	mov	r0, r4
  98:	f7ff fffe 	bl	0 <SendData>
        if (!ssl->options.tls1_3) {
  9c:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  a0:	f013 0301 	ands.w	r3, r3, #1
        out = GetOutputBuffer(ssl);
  a4:	4601      	mov	r1, r0
        if (!ssl->options.tls1_3) {
  a6:	d02e      	beq.n	106 <SendData+0x106>
            return BUILD_MSG_ERROR;
  a8:	482a      	ldr	r0, [pc, #168]	; (154 <SendData+0x154>)
  aa:	e004      	b.n	b6 <SendData+0xb6>
        if ( (err = wolfSSL_negotiate(ssl)) != WOLFSSL_SUCCESS) {
  ac:	4620      	mov	r0, r4
  ae:	f7ff fffe 	bl	0 <wolfSSL_negotiate>
  b2:	2801      	cmp	r0, #1
  b4:	d0c7      	beq.n	46 <SendData+0x46>
}
  b6:	b007      	add	sp, #28
  b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ( (ssl->error = SendBuffered(ssl)) < 0) {
  bc:	4620      	mov	r0, r4
  be:	f7ff fffe 	bl	0 <SendData>
  c2:	2800      	cmp	r0, #0
  c4:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
  c8:	da0e      	bge.n	e8 <SendData+0xe8>
            if (ssl->error == SOCKET_ERROR_E && (ssl->options.connReset ||
  ca:	f510 7f9a 	cmn.w	r0, #308	; 0x134
  ce:	d1f2      	bne.n	b6 <SendData+0xb6>
  d0:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  d4:	f013 0f18 	tst.w	r3, #24
                ssl->error = SOCKET_PEER_CLOSED_E;
  d8:	bf17      	itett	ne
  da:	f46f 73c6 	mvnne.w	r3, #396	; 0x18c
        return WOLFSSL_FATAL_ERROR;
  de:	481e      	ldreq	r0, [pc, #120]	; (158 <SendData+0x158>)
                ssl->error = SOCKET_PEER_CLOSED_E;
  e0:	f8c4 3114 	strne.w	r3, [r4, #276]	; 0x114
                return 0;  /* peer reset or closed */
  e4:	2000      	movne	r0, #0
  e6:	e7e6      	b.n	b6 <SendData+0xb6>
            sent = ssl->buffers.prevSent + ssl->buffers.plainSz;
  e8:	e9d4 5334 	ldrd	r5, r3, [r4, #208]	; 0xd0
  ec:	441d      	add	r5, r3
            if (sent > sz) {
  ee:	42bd      	cmp	r5, r7
  f0:	ddac      	ble.n	4c <SendData+0x4c>
                return ssl->error = BAD_FUNC_ARG;
  f2:	f06f 00ac 	mvn.w	r0, #172	; 0xac
            return ssl->error = ret;
  f6:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
  fa:	e7dc      	b.n	b6 <SendData+0xb6>
        ssl->error = ret;
  fc:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
            return WOLFSSL_FATAL_ERROR;
 100:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 104:	e7d7      	b.n	b6 <SendData+0xb6>
            sendSz = BuildMessage(ssl, out, outputSz, sendBuffer, buffSz,
 106:	2201      	movs	r2, #1
 108:	e9cd 3203 	strd	r3, r2, [sp, #12]
 10c:	e9cd a301 	strd	sl, r3, [sp, #4]
 110:	9305      	str	r3, [sp, #20]
 112:	9600      	str	r6, [sp, #0]
 114:	465b      	mov	r3, fp
 116:	4642      	mov	r2, r8
 118:	4620      	mov	r0, r4
 11a:	f7ff fffe 	bl	0 <SendData>
        if (sendSz < 0) {
 11e:	2800      	cmp	r0, #0
 120:	dbc2      	blt.n	a8 <SendData+0xa8>
        ssl->buffers.outputBuffer.length += sendSz;
 122:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 126:	4418      	add	r0, r3
 128:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
        if ( (ssl->error = SendBuffered(ssl)) < 0) {
 12c:	4620      	mov	r0, r4
 12e:	f7ff fffe 	bl	0 <SendData>
 132:	2800      	cmp	r0, #0
 134:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 138:	da02      	bge.n	140 <SendData+0x140>
            ssl->buffers.prevSent = sent;
 13a:	e9c4 5634 	strd	r5, r6, [r4, #208]	; 0xd0
            if (ssl->error == SOCKET_ERROR_E && (ssl->options.connReset ||
 13e:	e7c4      	b.n	ca <SendData+0xca>
        if (ssl->options.partialWrite == 1) {
 140:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 144:	06db      	lsls	r3, r3, #27
        sent += buffSz;
 146:	eb05 0006 	add.w	r0, r5, r6
        if (ssl->options.partialWrite == 1) {
 14a:	d4b4      	bmi.n	b6 <SendData+0xb6>
        sent += buffSz;
 14c:	4605      	mov	r5, r0
 14e:	e784      	b.n	5a <SendData+0x5a>
 150:	4628      	mov	r0, r5
 152:	e7b0      	b.n	b6 <SendData+0xb6>
 154:	fffffec0 	.word	0xfffffec0
 158:	fffffecc 	.word	0xfffffecc

Disassembly of section .text.SendAlert:

00000000 <SendAlert>:
    if (ssl->pendingAlert.level != alert_none) {
   0:	f8d0 3110 	ldr.w	r3, [r0, #272]	; 0x110
{
   4:	b570      	push	{r4, r5, r6, lr}
   6:	4604      	mov	r4, r0
   8:	460d      	mov	r5, r1
   a:	4616      	mov	r6, r2
    if (ssl->pendingAlert.level != alert_none) {
   c:	b163      	cbz	r3, 28 <SendAlert+0x28>
        int ret = RetrySendAlert(ssl);
   e:	f7ff fffe 	bl	0 <SendAlert>
        if (ret != 0) {
  12:	b148      	cbz	r0, 28 <SendAlert+0x28>
            if (ssl->pendingAlert.level == alert_none ||
  14:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
  18:	b11b      	cbz	r3, 22 <SendAlert+0x22>
  1a:	2b02      	cmp	r3, #2
  1c:	d003      	beq.n	26 <SendAlert+0x26>
                    (ssl->pendingAlert.level != alert_fatal &&
  1e:	2d02      	cmp	r5, #2
  20:	d101      	bne.n	26 <SendAlert+0x26>
                ssl->pendingAlert.level = severity;
  22:	e9c4 6543 	strd	r6, r5, [r4, #268]	; 0x10c
}
  26:	bd70      	pop	{r4, r5, r6, pc}
    return SendAlert_ex(ssl, severity, type);
  28:	4632      	mov	r2, r6
  2a:	4629      	mov	r1, r5
  2c:	4620      	mov	r0, r4
}
  2e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return SendAlert_ex(ssl, severity, type);
  32:	f7ff bffe 	b.w	0 <SendAlert>

Disassembly of section .text.DoCertFatalAlert:

00000000 <DoCertFatalAlert>:
{
   0:	b510      	push	{r4, lr}
    if (ssl == NULL || ret == 0) {
   2:	4604      	mov	r4, r0
   4:	b1d8      	cbz	r0, 3e <DoCertFatalAlert+0x3e>
   6:	b1d1      	cbz	r1, 3e <DoCertFatalAlert+0x3e>
    if (ret == ASN_AFTER_DATE_E || ret == ASN_BEFORE_DATE_E) {
   8:	f101 0397 	add.w	r3, r1, #151	; 0x97
   c:	2b01      	cmp	r3, #1
   e:	d917      	bls.n	40 <DoCertFatalAlert+0x40>
    else if (ret == ASN_NO_SIGNER_E || ret == ASN_PATHLEN_INV_E ||
  10:	f111 0fbc 	cmn.w	r1, #188	; 0xbc
  14:	d016      	beq.n	44 <DoCertFatalAlert+0x44>
  16:	f101 03ee 	add.w	r3, r1, #238	; 0xee
  1a:	2b01      	cmp	r3, #1
  1c:	d912      	bls.n	44 <DoCertFatalAlert+0x44>
            alertWhy = handshake_failure;
  1e:	f46f 72ac 	mvn.w	r2, #344	; 0x158
  22:	4291      	cmp	r1, r2
  24:	bf14      	ite	ne
  26:	222a      	movne	r2, #42	; 0x2a
  28:	2228      	moveq	r2, #40	; 0x28
    SendAlert(ssl, alert_fatal, alertWhy); /* try to send */
  2a:	2102      	movs	r1, #2
  2c:	4620      	mov	r0, r4
  2e:	f7ff fffe 	bl	0 <DoCertFatalAlert>
    ssl->options.isClosed = 1;
  32:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  36:	f043 0310 	orr.w	r3, r3, #16
  3a:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
}
  3e:	bd10      	pop	{r4, pc}
        alertWhy = certificate_expired;
  40:	222d      	movs	r2, #45	; 0x2d
  42:	e7f2      	b.n	2a <DoCertFatalAlert+0x2a>
        alertWhy = unknown_ca;
  44:	2230      	movs	r2, #48	; 0x30
  46:	e7f0      	b.n	2a <DoCertFatalAlert+0x2a>

Disassembly of section .text.ProcessPeerCerts:

00000000 <ProcessPeerCerts>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4605      	mov	r5, r0
   6:	b087      	sub	sp, #28
    byte* subjectHash = NULL;
   8:	2400      	movs	r4, #0
    args = (ProcPeerCertArgs*)XMALLOC(
   a:	2024      	movs	r0, #36	; 0x24
    int alreadySigner = 0;
   c:	e9cd 4402 	strd	r4, r4, [sp, #8]
{
  10:	4689      	mov	r9, r1
  12:	4690      	mov	r8, r2
  14:	461f      	mov	r7, r3
    args = (ProcPeerCertArgs*)XMALLOC(
  16:	f7ff fffe 	bl	0 <malloc>
    if (args == NULL) {
  1a:	4606      	mov	r6, r0
  1c:	2800      	cmp	r0, #0
  1e:	f000 8337 	beq.w	690 <ProcessPeerCerts+0x690>
        ssl->options.asyncState = TLS_ASYNC_BEGIN;
  22:	f885 4283 	strb.w	r4, [r5, #643]	; 0x283
        XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
  26:	2224      	movs	r2, #36	; 0x24
  28:	4621      	mov	r1, r4
  2a:	f7ff fffe 	bl	0 <memset>
        args->idx = *inOutIdx;
  2e:	f8d8 3000 	ldr.w	r3, [r8]
        args->begin = *inOutIdx;
  32:	e9c6 3302 	strd	r3, r3, [r6, #8]
    switch (ssl->options.asyncState)
  36:	f895 3283 	ldrb.w	r3, [r5, #643]	; 0x283
  3a:	2b05      	cmp	r3, #5
  3c:	f200 8325 	bhi.w	68a <ProcessPeerCerts+0x68a>
  40:	e8df f013 	tbh	[pc, r3, lsl #1]
  44:	01430006 	.word	0x01430006
  48:	0220008e 	.word	0x0220008e
  4c:	0321031f 	.word	0x0321031f
            args->certs = (buffer*)XMALLOC(sizeof(buffer) * MAX_CHAIN_DEPTH,
  50:	2048      	movs	r0, #72	; 0x48
  52:	f7ff fffe 	bl	0 <malloc>
  56:	6030      	str	r0, [r6, #0]
            if (args->certs == NULL) {
  58:	2800      	cmp	r0, #0
  5a:	f000 8133 	beq.w	2c4 <ProcessPeerCerts+0x2c4>
            XMEMSET(args->certs, 0, sizeof(buffer) * MAX_CHAIN_DEPTH);
  5e:	2248      	movs	r2, #72	; 0x48
  60:	2100      	movs	r1, #0
  62:	f7ff fffe 	bl	0 <memset>
            if ((args->idx - args->begin) + OPAQUE24_LEN > totalSz) {
  66:	68b0      	ldr	r0, [r6, #8]
  68:	68f2      	ldr	r2, [r6, #12]
  6a:	1cc3      	adds	r3, r0, #3
  6c:	1a9b      	subs	r3, r3, r2
  6e:	42bb      	cmp	r3, r7
  70:	d91e      	bls.n	b0 <ProcessPeerCerts+0xb0>
                    ERROR_OUT(BUFFER_ERROR, exit_ppc);
  72:	4c97      	ldr	r4, [pc, #604]	; (2d0 <ProcessPeerCerts+0x2d0>)
    if (args->certs) {
  74:	6830      	ldr	r0, [r6, #0]
  76:	b118      	cbz	r0, 80 <ProcessPeerCerts+0x80>
        XFREE(args->certs, ssl->heap, DYNAMIC_TYPE_DER);
  78:	f7ff fffe 	bl	0 <free>
        args->certs = NULL;
  7c:	2300      	movs	r3, #0
  7e:	6033      	str	r3, [r6, #0]
    if (args->dCert) {
  80:	6870      	ldr	r0, [r6, #4]
  82:	b188      	cbz	r0, a8 <ProcessPeerCerts+0xa8>
        if (args->dCertInit) {
  84:	f896 3020 	ldrb.w	r3, [r6, #32]
  88:	075b      	lsls	r3, r3, #29
  8a:	d507      	bpl.n	9c <ProcessPeerCerts+0x9c>
            FreeDecodedCert(args->dCert);
  8c:	f7ff fffe 	bl	0 <FreeDecodedCert>
            args->dCertInit = 0;
  90:	f896 3020 	ldrb.w	r3, [r6, #32]
  94:	f36f 0382 	bfc	r3, #2, #1
  98:	f886 3020 	strb.w	r3, [r6, #32]
        XFREE(args->dCert, ssl->heap, DYNAMIC_TYPE_DCERT);
  9c:	6870      	ldr	r0, [r6, #4]
  9e:	b108      	cbz	r0, a4 <ProcessPeerCerts+0xa4>
  a0:	f7ff fffe 	bl	0 <free>
        args->dCert = NULL;
  a4:	2300      	movs	r3, #0
  a6:	6073      	str	r3, [r6, #4]
    XFREE(args, ssl->heap, DYNAMIC_TYPE_TMP_BUFFER);
  a8:	4630      	mov	r0, r6
  aa:	f7ff fffe 	bl	0 <free>
  ae:	e2f1      	b.n	694 <ProcessPeerCerts+0x694>
            c24to32(input + args->idx, &listSz);
  b0:	a904      	add	r1, sp, #16
  b2:	4448      	add	r0, r9
  b4:	f7ff fffe 	bl	0 <ProcessPeerCerts>
            args->idx += OPAQUE24_LEN;
  b8:	68b3      	ldr	r3, [r6, #8]
            if (listSz > MAX_CERTIFICATE_SZ) {
  ba:	9a04      	ldr	r2, [sp, #16]
  bc:	f644 011e 	movw	r1, #18462	; 0x481e
            args->idx += OPAQUE24_LEN;
  c0:	3303      	adds	r3, #3
            if (listSz > MAX_CERTIFICATE_SZ) {
  c2:	428a      	cmp	r2, r1
            args->idx += OPAQUE24_LEN;
  c4:	60b3      	str	r3, [r6, #8]
            if (listSz > MAX_CERTIFICATE_SZ) {
  c6:	d8d4      	bhi.n	72 <ProcessPeerCerts+0x72>
            if ((args->idx - args->begin) + listSz != totalSz) {
  c8:	68f1      	ldr	r1, [r6, #12]
  ca:	1a5b      	subs	r3, r3, r1
  cc:	4413      	add	r3, r2
  ce:	42bb      	cmp	r3, r7
  d0:	d1cf      	bne.n	72 <ProcessPeerCerts+0x72>
            while (listSz) {
  d2:	9b04      	ldr	r3, [sp, #16]
                if (args->totalCerts >= ssl->verifyDepth ||
  d4:	6934      	ldr	r4, [r6, #16]
            while (listSz) {
  d6:	2b00      	cmp	r3, #0
  d8:	f040 80b2 	bne.w	240 <ProcessPeerCerts+0x240>
            args->certIdx = 0; /* select peer cert (first one) */
  dc:	e9c6 4305 	strd	r4, r3, [r6, #20]
            if (args->count == 0) {
  e0:	2c00      	cmp	r4, #0
  e2:	f040 80ed 	bne.w	2c0 <ProcessPeerCerts+0x2c0>
                if ((ssl->options.side == WOLFSSL_SERVER_END) &&
  e6:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
  ea:	f013 0330 	ands.w	r3, r3, #48	; 0x30
  ee:	f040 80d6 	bne.w	29e <ProcessPeerCerts+0x29e>
                    (ssl->options.mutualAuth || (ssl->options.failNoCert &&
  f2:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
                if ((ssl->options.side == WOLFSSL_SERVER_END) &&
  f6:	07db      	lsls	r3, r3, #31
  f8:	d409      	bmi.n	10e <ProcessPeerCerts+0x10e>
                    (ssl->options.mutualAuth || (ssl->options.failNoCert &&
  fa:	f895 3271 	ldrb.w	r3, [r5, #625]	; 0x271
  fe:	07df      	lsls	r7, r3, #31
 100:	d50c      	bpl.n	11c <ProcessPeerCerts+0x11c>
                                             IsAtLeastTLSv1_3(ssl->version)))) {
 102:	f8d5 013c 	ldr.w	r0, [r5, #316]	; 0x13c
 106:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                    (ssl->options.mutualAuth || (ssl->options.failNoCert &&
 10a:	4604      	mov	r4, r0
 10c:	b130      	cbz	r0, 11c <ProcessPeerCerts+0x11c>
                    DoCertFatalAlert(ssl, ret);
 10e:	f46f 71ac 	mvn.w	r1, #344	; 0x158
 112:	4628      	mov	r0, r5
 114:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                    ret = NO_PEER_CERT;
 118:	f46f 74ac 	mvn.w	r4, #344	; 0x158
            args->dCertInit = 0;
 11c:	f896 3020 	ldrb.w	r3, [r6, #32]
 120:	f36f 0382 	bfc	r3, #2, #1
 124:	f886 3020 	strb.w	r3, [r6, #32]
            args->dCert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), ssl->heap,
 128:	f44f 7056 	mov.w	r0, #856	; 0x358
 12c:	f7ff fffe 	bl	0 <malloc>
 130:	6070      	str	r0, [r6, #4]
            if (args->dCert == NULL) {
 132:	2800      	cmp	r0, #0
 134:	f000 80c6 	beq.w	2c4 <ProcessPeerCerts+0x2c4>
            XMEMSET(args->dCert, 0, sizeof(DecodedCert));
 138:	f44f 7256 	mov.w	r2, #856	; 0x358
 13c:	2100      	movs	r1, #0
 13e:	f7ff fffe 	bl	0 <memset>
            ssl->options.asyncState = TLS_ASYNC_BUILD;
 142:	2301      	movs	r3, #1
 144:	f885 3283 	strb.w	r3, [r5, #643]	; 0x283
            if (args->count > 0) {
 148:	6973      	ldr	r3, [r6, #20]
 14a:	2b00      	cmp	r3, #0
 14c:	dd03      	ble.n	156 <ProcessPeerCerts+0x156>
                while (args->count > 1
 14e:	6973      	ldr	r3, [r6, #20]
 150:	2b01      	cmp	r3, #1
 152:	f300 80c3 	bgt.w	2dc <ProcessPeerCerts+0x2dc>
            if (ret != 0) {
 156:	2c00      	cmp	r4, #0
 158:	d18c      	bne.n	74 <ProcessPeerCerts+0x74>
            ssl->options.asyncState = TLS_ASYNC_DO;
 15a:	2302      	movs	r3, #2
 15c:	f885 3283 	strb.w	r3, [r5, #643]	; 0x283
            if (args->count > 0) {
 160:	6973      	ldr	r3, [r6, #20]
 162:	2b00      	cmp	r3, #0
 164:	f04f 0400 	mov.w	r4, #0
 168:	dd2b      	ble.n	1c2 <ProcessPeerCerts+0x1c2>
                ret = ProcessPeerCertParse(ssl, args, CERT_TYPE,
 16a:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
                args->certIdx = 0;
 16e:	61b4      	str	r4, [r6, #24]
                ret = ProcessPeerCertParse(ssl, args, CERT_TYPE,
 170:	aa03      	add	r2, sp, #12
 172:	42a3      	cmp	r3, r4
 174:	9201      	str	r2, [sp, #4]
 176:	aa02      	add	r2, sp, #8
 178:	9200      	str	r2, [sp, #0]
 17a:	bfb8      	it	lt
 17c:	2300      	movlt	r3, #0
 17e:	4622      	mov	r2, r4
 180:	bfa8      	it	ge
 182:	2301      	movge	r3, #1
 184:	4631      	mov	r1, r6
 186:	4628      	mov	r0, r5
 188:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                if (ret == 0) {
 18c:	4604      	mov	r4, r0
 18e:	2800      	cmp	r0, #0
 190:	f040 8154 	bne.w	43c <ProcessPeerCerts+0x43c>
                    if (ssl->options.side == WOLFSSL_SERVER_END) {
 194:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
 198:	f013 0f30 	tst.w	r3, #48	; 0x30
 19c:	d106      	bne.n	1ac <ProcessPeerCerts+0x1ac>
                        if (args->dCert->version != WOLFSSL_X509_V3) {
 19e:	6873      	ldr	r3, [r6, #4]
 1a0:	6a1b      	ldr	r3, [r3, #32]
 1a2:	2b02      	cmp	r3, #2
                            args->lastErr = ASN_VERSION_E;
 1a4:	bf1c      	itt	ne
 1a6:	f06f 038c 	mvnne.w	r3, #140	; 0x8c
 1aa:	61f3      	strne	r3, [r6, #28]
                    if (args->verifyErr) {
 1ac:	f896 3020 	ldrb.w	r3, [r6, #32]
 1b0:	f013 0202 	ands.w	r2, r3, #2
 1b4:	f000 813d 	beq.w	432 <ProcessPeerCerts+0x432>
                        args->fatal = 1;
 1b8:	f043 0301 	orr.w	r3, r3, #1
                        ret = args->lastErr;
 1bc:	69f4      	ldr	r4, [r6, #28]
                        args->fatal = 1;
 1be:	f886 3020 	strb.w	r3, [r6, #32]
            if (args->fatal && ret != 0) {
 1c2:	f896 3020 	ldrb.w	r3, [r6, #32]
 1c6:	07da      	lsls	r2, r3, #31
 1c8:	d502      	bpl.n	1d0 <ProcessPeerCerts+0x1d0>
 1ca:	2c00      	cmp	r4, #0
 1cc:	f47f af52 	bne.w	74 <ProcessPeerCerts+0x74>
            ssl->options.asyncState = TLS_ASYNC_VERIFY;
 1d0:	2303      	movs	r3, #3
 1d2:	f885 3283 	strb.w	r3, [r5, #643]	; 0x283
            if (args->count > 0) {
 1d6:	6973      	ldr	r3, [r6, #20]
 1d8:	2b00      	cmp	r3, #0
 1da:	f340 81a4 	ble.w	526 <ProcessPeerCerts+0x526>
                if (args->dCert->extKeyUsageSet) {
 1de:	6870      	ldr	r0, [r6, #4]
 1e0:	f990 3354 	ldrsb.w	r3, [r0, #852]	; 0x354
 1e4:	2b00      	cmp	r3, #0
 1e6:	da11      	bge.n	20c <ProcessPeerCerts+0x20c>
                    if ((ssl->specs.kea == rsa_kea) &&
 1e8:	f895 314b 	ldrb.w	r3, [r5, #331]	; 0x14b
 1ec:	2b01      	cmp	r3, #1
 1ee:	f040 8275 	bne.w	6dc <ProcessPeerCerts+0x6dc>
                        (ssl->options.side == WOLFSSL_CLIENT_END) &&
 1f2:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
                    if ((ssl->specs.kea == rsa_kea) &&
 1f6:	f003 0330 	and.w	r3, r3, #48	; 0x30
 1fa:	2b10      	cmp	r3, #16
 1fc:	d106      	bne.n	20c <ProcessPeerCerts+0x20c>
                        (ssl->options.side == WOLFSSL_CLIENT_END) &&
 1fe:	f8b0 32f8 	ldrh.w	r3, [r0, #760]	; 0x2f8
                        ret = KEYUSE_ENCIPHER_E;
 202:	f013 0f20 	tst.w	r3, #32
 206:	bf08      	it	eq
 208:	f46f 74c0 	mvneq.w	r4, #384	; 0x180
                if (args->dCert->extExtKeyUsageSet) {
 20c:	f890 3355 	ldrb.w	r3, [r0, #853]	; 0x355
 210:	07db      	lsls	r3, r3, #31
 212:	d50d      	bpl.n	230 <ProcessPeerCerts+0x230>
                    if (ssl->options.side == WOLFSSL_CLIENT_END) {
 214:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
                        if ((args->dCert->extExtKeyUsage &
 218:	f890 22fa 	ldrb.w	r2, [r0, #762]	; 0x2fa
                    if (ssl->options.side == WOLFSSL_CLIENT_END) {
 21c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 220:	2b10      	cmp	r3, #16
 222:	f040 8131 	bne.w	488 <ProcessPeerCerts+0x488>
                            ret = EXTKEYUSE_AUTH_E;
 226:	f012 0f03 	tst.w	r2, #3
 22a:	4b2a      	ldr	r3, [pc, #168]	; (2d4 <ProcessPeerCerts+0x2d4>)
 22c:	bf08      	it	eq
 22e:	461c      	moveq	r4, r3
                if (args->fatal) {
 230:	f896 3020 	ldrb.w	r3, [r6, #32]
 234:	07df      	lsls	r7, r3, #31
 236:	f140 812a 	bpl.w	48e <ProcessPeerCerts+0x48e>
                    ssl->error = ret;
 23a:	f8c5 4114 	str.w	r4, [r5, #276]	; 0x114
                    goto exit_ppc;
 23e:	e719      	b.n	74 <ProcessPeerCerts+0x74>
                if (args->totalCerts >= ssl->verifyDepth ||
 240:	f895 3132 	ldrb.w	r3, [r5, #306]	; 0x132
 244:	42a3      	cmp	r3, r4
 246:	dd28      	ble.n	29a <ProcessPeerCerts+0x29a>
 248:	2c08      	cmp	r4, #8
 24a:	dc26      	bgt.n	29a <ProcessPeerCerts+0x29a>
                if ((args->idx - args->begin) + OPAQUE24_LEN > totalSz) {
 24c:	68b0      	ldr	r0, [r6, #8]
 24e:	68f2      	ldr	r2, [r6, #12]
 250:	1cc3      	adds	r3, r0, #3
 252:	1a9b      	subs	r3, r3, r2
 254:	42bb      	cmp	r3, r7
 256:	f63f af0c 	bhi.w	72 <ProcessPeerCerts+0x72>
                c24to32(input + args->idx, &certSz);
 25a:	a905      	add	r1, sp, #20
 25c:	4448      	add	r0, r9
 25e:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                args->idx += OPAQUE24_LEN;
 262:	68b2      	ldr	r2, [r6, #8]
                if ((args->idx - args->begin) + certSz > totalSz) {
 264:	68f3      	ldr	r3, [r6, #12]
 266:	9905      	ldr	r1, [sp, #20]
                args->idx += OPAQUE24_LEN;
 268:	3203      	adds	r2, #3
                if ((args->idx - args->begin) + certSz > totalSz) {
 26a:	1ad3      	subs	r3, r2, r3
 26c:	440b      	add	r3, r1
 26e:	42bb      	cmp	r3, r7
                args->idx += OPAQUE24_LEN;
 270:	60b2      	str	r2, [r6, #8]
                if ((args->idx - args->begin) + certSz > totalSz) {
 272:	f63f aefe 	bhi.w	72 <ProcessPeerCerts+0x72>
                args->certs[args->totalCerts].length = certSz;
 276:	6933      	ldr	r3, [r6, #16]
 278:	6830      	ldr	r0, [r6, #0]
 27a:	eb00 04c3 	add.w	r4, r0, r3, lsl #3
 27e:	6061      	str	r1, [r4, #4]
                args->certs[args->totalCerts].buffer = input + args->idx;
 280:	eb09 0402 	add.w	r4, r9, r2
                args->idx += certSz;
 284:	440a      	add	r2, r1
                args->certs[args->totalCerts].buffer = input + args->idx;
 286:	f840 4033 	str.w	r4, [r0, r3, lsl #3]
                args->idx += certSz;
 28a:	60b2      	str	r2, [r6, #8]
                listSz -= certSz + CERT_HEADER_SZ;
 28c:	9a04      	ldr	r2, [sp, #16]
 28e:	3a03      	subs	r2, #3
 290:	1a52      	subs	r2, r2, r1
                args->totalCerts++;
 292:	3301      	adds	r3, #1
                listSz -= certSz + CERT_HEADER_SZ;
 294:	9204      	str	r2, [sp, #16]
                args->totalCerts++;
 296:	6133      	str	r3, [r6, #16]
                WOLFSSL_MSG("\tPut another cert into chain");
 298:	e71b      	b.n	d2 <ProcessPeerCerts+0xd2>
                    ERROR_OUT(MAX_CHAIN_ERROR, exit_ppc);
 29a:	4c0f      	ldr	r4, [pc, #60]	; (2d8 <ProcessPeerCerts+0x2d8>)
 29c:	e6ea      	b.n	74 <ProcessPeerCerts+0x74>
                else if ((ssl->options.side == WOLFSSL_CLIENT_END) &&
 29e:	2b10      	cmp	r3, #16
 2a0:	f47f af3c 	bne.w	11c <ProcessPeerCerts+0x11c>
                         IsAtLeastTLSv1_3(ssl->version)) {
 2a4:	f8d5 013c 	ldr.w	r0, [r5, #316]	; 0x13c
 2a8:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                else if ((ssl->options.side == WOLFSSL_CLIENT_END) &&
 2ac:	4604      	mov	r4, r0
 2ae:	2800      	cmp	r0, #0
 2b0:	f43f af34 	beq.w	11c <ProcessPeerCerts+0x11c>
                    SendAlert(ssl, alert_fatal, decode_error);
 2b4:	2232      	movs	r2, #50	; 0x32
 2b6:	2102      	movs	r1, #2
 2b8:	4628      	mov	r0, r5
 2ba:	f7ff fffe 	bl	0 <ProcessPeerCerts>
 2be:	e72b      	b.n	118 <ProcessPeerCerts+0x118>
        ret = 0;
 2c0:	461c      	mov	r4, r3
 2c2:	e72b      	b.n	11c <ProcessPeerCerts+0x11c>
                ERROR_OUT(MEMORY_E, exit_ppc);
 2c4:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 2c8:	e6d4      	b.n	74 <ProcessPeerCerts+0x74>
    switch (ssl->options.asyncState)
 2ca:	2400      	movs	r4, #0
 2cc:	e73c      	b.n	148 <ProcessPeerCerts+0x148>
 2ce:	bf00      	nop
 2d0:	fffffeb8 	.word	0xfffffeb8
 2d4:	fffffe7e 	.word	0xfffffe7e
 2d8:	fffffe90 	.word	0xfffffe90
                    args->certIdx = args->count - 1;
 2dc:	3b01      	subs	r3, #1
 2de:	61b3      	str	r3, [r6, #24]
                    ret = ProcessPeerCertParse(ssl, args, CHAIN_CERT_TYPE,
 2e0:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
 2e4:	aa03      	add	r2, sp, #12
 2e6:	9201      	str	r2, [sp, #4]
 2e8:	43db      	mvns	r3, r3
 2ea:	aa02      	add	r2, sp, #8
 2ec:	9200      	str	r2, [sp, #0]
 2ee:	0fdb      	lsrs	r3, r3, #31
 2f0:	2225      	movs	r2, #37	; 0x25
 2f2:	4631      	mov	r1, r6
 2f4:	4628      	mov	r0, r5
 2f6:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                    if (ret == 0) {
 2fa:	4604      	mov	r4, r0
 2fc:	2800      	cmp	r0, #0
 2fe:	d148      	bne.n	392 <ProcessPeerCerts+0x392>
    if (ssl->options.verifyNone) {
 300:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
 304:	2b00      	cmp	r3, #0
 306:	db12      	blt.n	32e <ProcessPeerCerts+0x32e>
    switch (args->dCert->keyOID) {
 308:	6872      	ldr	r2, [r6, #4]
 30a:	69d3      	ldr	r3, [r2, #28]
 30c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 310:	d038      	beq.n	384 <ProcessPeerCerts+0x384>
 312:	f240 2106 	movw	r1, #518	; 0x206
 316:	428b      	cmp	r3, r1
 318:	d109      	bne.n	32e <ProcessPeerCerts+0x32e>
            if (ssl->options.minEccKeySz < 0 ||
 31a:	f9b5 3286 	ldrsh.w	r3, [r5, #646]	; 0x286
 31e:	2b00      	cmp	r3, #0
 320:	db43      	blt.n	3aa <ProcessPeerCerts+0x3aa>
 322:	6852      	ldr	r2, [r2, #4]
                ret = ECC_KEY_SIZE_E;
 324:	f5a1 7168 	sub.w	r1, r1, #928	; 0x3a0
 328:	429a      	cmp	r2, r3
 32a:	bf38      	it	cc
 32c:	460c      	movcc	r4, r1
                    ret = DoVerifyCallback(SSL_CM(ssl), ssl, ret, args);
 32e:	6828      	ldr	r0, [r5, #0]
 330:	4633      	mov	r3, r6
 332:	4622      	mov	r2, r4
 334:	6a80      	ldr	r0, [r0, #40]	; 0x28
 336:	4629      	mov	r1, r5
 338:	f7ff fffe 	bl	0 <ProcessPeerCerts>
 33c:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
                    if (ssl->options.verifyNone &&
 340:	2b00      	cmp	r3, #0
                    ret = DoVerifyCallback(SSL_CM(ssl), ssl, ret, args);
 342:	4604      	mov	r4, r0
                    if (ssl->options.verifyNone &&
 344:	da33      	bge.n	3ae <ProcessPeerCerts+0x3ae>
                              (ret == CRL_MISSING || ret == CRL_CERT_REVOKED ||
 346:	f500 72b5 	add.w	r2, r0, #362	; 0x16a
                    if (ssl->options.verifyNone &&
 34a:	2a01      	cmp	r2, #1
 34c:	d902      	bls.n	354 <ProcessPeerCerts+0x354>
                              (ret == CRL_MISSING || ret == CRL_CERT_REVOKED ||
 34e:	f110 0fb3 	cmn.w	r0, #179	; 0xb3
 352:	d12c      	bne.n	3ae <ProcessPeerCerts+0x3ae>
                        ret = ssl->error = 0;
 354:	2200      	movs	r2, #0
 356:	f8c5 2114 	str.w	r2, [r5, #276]	; 0x114
                    if (ret == 0 && args->dCert->isCA &&
 35a:	6872      	ldr	r2, [r6, #4]
 35c:	f892 2354 	ldrb.w	r2, [r2, #852]	; 0x354
 360:	06d0      	lsls	r0, r2, #27
 362:	d434      	bmi.n	3ce <ProcessPeerCerts+0x3ce>
                    ssl->error = ret; /* Report SSL error or clear error if
 364:	2400      	movs	r4, #0
 366:	f8c5 4114 	str.w	r4, [r5, #276]	; 0x114
                    FreeDecodedCert(args->dCert);
 36a:	6870      	ldr	r0, [r6, #4]
 36c:	f7ff fffe 	bl	0 <FreeDecodedCert>
                    args->dCertInit = 0;
 370:	f896 3020 	ldrb.w	r3, [r6, #32]
 374:	f36f 0382 	bfc	r3, #2, #1
 378:	f886 3020 	strb.w	r3, [r6, #32]
                    args->count--;
 37c:	6973      	ldr	r3, [r6, #20]
 37e:	3b01      	subs	r3, #1
 380:	6173      	str	r3, [r6, #20]
 382:	e6e4      	b.n	14e <ProcessPeerCerts+0x14e>
            if (ssl->options.minEccKeySz < 0 ||
 384:	f8b5 3286 	ldrh.w	r3, [r5, #646]	; 0x286
                ret = ECC_KEY_SIZE_E;
 388:	4aa6      	ldr	r2, [pc, #664]	; (624 <ProcessPeerCerts+0x624>)
 38a:	2b20      	cmp	r3, #32
 38c:	bf88      	it	hi
 38e:	4614      	movhi	r4, r2
 390:	e7cd      	b.n	32e <ProcessPeerCerts+0x32e>
                    else if (ret == ASN_PARSE_E || ret == BUFFER_E ||
 392:	f110 0f8c 	cmn.w	r0, #140	; 0x8c
 396:	f43f ae6d 	beq.w	74 <ProcessPeerCerts+0x74>
 39a:	f110 0f84 	cmn.w	r0, #132	; 0x84
 39e:	f43f ae69 	beq.w	74 <ProcessPeerCerts+0x74>
 3a2:	f110 0f7d 	cmn.w	r0, #125	; 0x7d
 3a6:	d1c2      	bne.n	32e <ProcessPeerCerts+0x32e>
 3a8:	e664      	b.n	74 <ProcessPeerCerts+0x74>
                ret = ECC_KEY_SIZE_E;
 3aa:	4c9e      	ldr	r4, [pc, #632]	; (624 <ProcessPeerCerts+0x624>)
 3ac:	e7bf      	b.n	32e <ProcessPeerCerts+0x32e>
                    if (ret == 0 && args->dCert->isCA &&
 3ae:	2c00      	cmp	r4, #0
 3b0:	d0d3      	beq.n	35a <ProcessPeerCerts+0x35a>
                    ssl->error = ret; /* Report SSL error or clear error if
 3b2:	f8c5 4114 	str.w	r4, [r5, #276]	; 0x114
                    if (ret != 0) {
 3b6:	2c00      	cmp	r4, #0
 3b8:	d0d7      	beq.n	36a <ProcessPeerCerts+0x36a>
                        if (!ssl->options.verifyNone) {
 3ba:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
 3be:	2b00      	cmp	r3, #0
 3c0:	db31      	blt.n	426 <ProcessPeerCerts+0x426>
                            DoCertFatalAlert(ssl, ret);
 3c2:	4621      	mov	r1, r4
 3c4:	4628      	mov	r0, r5
 3c6:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                            args->lastErr = ret;
 3ca:	61f4      	str	r4, [r6, #28]
            if (ret != 0) {
 3cc:	e652      	b.n	74 <ProcessPeerCerts+0x74>
                    if (ret == 0 && args->dCert->isCA &&
 3ce:	2b00      	cmp	r3, #0
 3d0:	dbc8      	blt.n	364 <ProcessPeerCerts+0x364>
                        if (!alreadySigner) {
 3d2:	9f03      	ldr	r7, [sp, #12]
 3d4:	2f00      	cmp	r7, #0
 3d6:	d1c5      	bne.n	364 <ProcessPeerCerts+0x364>
                        buffer* cert = &args->certs[args->certIdx];
 3d8:	f8d6 a018 	ldr.w	sl, [r6, #24]
 3dc:	f8d6 9000 	ldr.w	r9, [r6]
                            ret = AllocDer(&add, cert->length, CA_TYPE, ssl->heap);
 3e0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
                            DerBuffer* add = NULL;
 3e2:	9705      	str	r7, [sp, #20]
                        buffer* cert = &args->certs[args->certIdx];
 3e4:	eb09 0bca 	add.w	fp, r9, sl, lsl #3
                            ret = AllocDer(&add, cert->length, CA_TYPE, ssl->heap);
 3e8:	2205      	movs	r2, #5
 3ea:	f8db 1004 	ldr.w	r1, [fp, #4]
 3ee:	a805      	add	r0, sp, #20
 3f0:	f7ff fffe 	bl	0 <AllocDer>
                            if (ret < 0)
 3f4:	1e04      	subs	r4, r0, #0
 3f6:	f6ff ae3d 	blt.w	74 <ProcessPeerCerts+0x74>
                            XMEMCPY(add->buffer, cert->buffer, cert->length);
 3fa:	9b05      	ldr	r3, [sp, #20]
 3fc:	f8db 2004 	ldr.w	r2, [fp, #4]
 400:	f859 103a 	ldr.w	r1, [r9, sl, lsl #3]
 404:	6818      	ldr	r0, [r3, #0]
 406:	f7ff fffe 	bl	0 <memcpy>
                            ret = AddCA(SSL_CM(ssl), &add, WOLFSSL_CHAIN_CA,
 40a:	6828      	ldr	r0, [r5, #0]
 40c:	463b      	mov	r3, r7
 40e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 410:	2202      	movs	r2, #2
 412:	a905      	add	r1, sp, #20
 414:	f7ff fffe 	bl	0 <AddCA>
                            if (ret == WOLFSSL_SUCCESS) {
 418:	2801      	cmp	r0, #1
                            ret = AddCA(SSL_CM(ssl), &add, WOLFSSL_CHAIN_CA,
 41a:	4604      	mov	r4, r0
                            if (ret == WOLFSSL_SUCCESS) {
 41c:	d1c9      	bne.n	3b2 <ProcessPeerCerts+0x3b2>
                    ssl->error = ret; /* Report SSL error or clear error if
 41e:	f8c5 7114 	str.w	r7, [r5, #276]	; 0x114
                                ret = 0;
 422:	463c      	mov	r4, r7
 424:	e7a1      	b.n	36a <ProcessPeerCerts+0x36a>
                        if (args->lastErr == 0) {
 426:	69f3      	ldr	r3, [r6, #28]
 428:	2b00      	cmp	r3, #0
 42a:	d19e      	bne.n	36a <ProcessPeerCerts+0x36a>
                            args->lastErr = ret; /* save error from last time */
 42c:	61f4      	str	r4, [r6, #28]
                            ret = 0; /* reset error */
 42e:	461c      	mov	r4, r3
 430:	e79b      	b.n	36a <ProcessPeerCerts+0x36a>
                        args->fatal = 0;
 432:	f362 0300 	bfi	r3, r2, #0, #1
                    args->fatal = 1;
 436:	f886 3020 	strb.w	r3, [r6, #32]
 43a:	e6c2      	b.n	1c2 <ProcessPeerCerts+0x1c2>
                else if (ret == ASN_PARSE_E || ret == BUFFER_E ||
 43c:	f020 0308 	bic.w	r3, r0, #8
 440:	338c      	adds	r3, #140	; 0x8c
 442:	d002      	beq.n	44a <ProcessPeerCerts+0x44a>
 444:	f110 0f7d 	cmn.w	r0, #125	; 0x7d
 448:	d104      	bne.n	454 <ProcessPeerCerts+0x454>
                    args->fatal = 1;
 44a:	f896 3020 	ldrb.w	r3, [r6, #32]
 44e:	f043 0301 	orr.w	r3, r3, #1
 452:	e7f0      	b.n	436 <ProcessPeerCerts+0x436>
                    if (ssl->verifyCallback) {
 454:	6a2b      	ldr	r3, [r5, #32]
 456:	b173      	cbz	r3, 476 <ProcessPeerCerts+0x476>
                        args->fatal = (args->verifyErr) ? 1 : 0;
 458:	f896 3020 	ldrb.w	r3, [r6, #32]
 45c:	085a      	lsrs	r2, r3, #1
 45e:	f362 0300 	bfi	r3, r2, #0, #1
                        if (args->fatal)
 462:	07d9      	lsls	r1, r3, #31
                        args->fatal = (args->verifyErr) ? 1 : 0;
 464:	f886 3020 	strb.w	r3, [r6, #32]
                        if (args->fatal)
 468:	f57f aeab 	bpl.w	1c2 <ProcessPeerCerts+0x1c2>
                        DoCertFatalAlert(ssl, ret);
 46c:	4621      	mov	r1, r4
 46e:	4628      	mov	r0, r5
 470:	f7ff fffe 	bl	0 <ProcessPeerCerts>
 474:	e6a5      	b.n	1c2 <ProcessPeerCerts+0x1c2>
                        args->fatal = 1;
 476:	f896 3020 	ldrb.w	r3, [r6, #32]
 47a:	f043 0301 	orr.w	r3, r3, #1
 47e:	f886 3020 	strb.w	r3, [r6, #32]
 482:	e7f3      	b.n	46c <ProcessPeerCerts+0x46c>
    switch (ssl->options.asyncState)
 484:	2400      	movs	r4, #0
 486:	e6a6      	b.n	1d6 <ProcessPeerCerts+0x1d6>
                            ret = EXTKEYUSE_AUTH_E;
 488:	f012 0f05 	tst.w	r2, #5
 48c:	e6cd      	b.n	22a <ProcessPeerCerts+0x22a>
                ssl->options.havePeerCert = 1;
 48e:	f895 3274 	ldrb.w	r3, [r5, #628]	; 0x274
                if (ssl->options.side == WOLFSSL_CLIENT_END &&
 492:	f895 2270 	ldrb.w	r2, [r5, #624]	; 0x270
                ssl->options.havePeerCert = 1;
 496:	f043 0301 	orr.w	r3, r3, #1
 49a:	f885 3274 	strb.w	r3, [r5, #628]	; 0x274
                if (ssl->options.side == WOLFSSL_CLIENT_END &&
 49e:	f002 0330 	and.w	r3, r2, #48	; 0x30
 4a2:	2b10      	cmp	r3, #16
 4a4:	d108      	bne.n	4b8 <ProcessPeerCerts+0x4b8>
 4a6:	f895 314f 	ldrb.w	r3, [r5, #335]	; 0x14f
 4aa:	b12b      	cbz	r3, 4b8 <ProcessPeerCerts+0x4b8>
                    ssl->options.peerAuthGood = 1;
 4ac:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
 4b0:	f043 0302 	orr.w	r3, r3, #2
 4b4:	f885 3276 	strb.w	r3, [r5, #630]	; 0x276
                if (!ssl->options.verifyNone && ssl->buffers.domainName.buffer) {
 4b8:	0611      	lsls	r1, r2, #24
 4ba:	d40b      	bmi.n	4d4 <ProcessPeerCerts+0x4d4>
 4bc:	f8d5 10b0 	ldr.w	r1, [r5, #176]	; 0xb0
 4c0:	b141      	cbz	r1, 4d4 <ProcessPeerCerts+0x4d4>
                    if (args->dCert->altNames) {
 4c2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 4c4:	2b00      	cmp	r3, #0
 4c6:	d060      	beq.n	58a <ProcessPeerCerts+0x58a>
                        if (CheckForAltNames(args->dCert,
 4c8:	2200      	movs	r2, #0
 4ca:	f7ff fffe 	bl	0 <ProcessPeerCerts>
 4ce:	2801      	cmp	r0, #1
 4d0:	d000      	beq.n	4d4 <ProcessPeerCerts+0x4d4>
                            ret = DOMAIN_NAME_MISMATCH;
 4d2:	4c55      	ldr	r4, [pc, #340]	; (628 <ProcessPeerCerts+0x628>)
                switch (args->dCert->keyOID) {
 4d4:	6873      	ldr	r3, [r6, #4]
 4d6:	69db      	ldr	r3, [r3, #28]
 4d8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 4dc:	f000 808a 	beq.w	5f4 <ProcessPeerCerts+0x5f4>
 4e0:	f240 2206 	movw	r2, #518	; 0x206
 4e4:	4293      	cmp	r3, r2
 4e6:	d11e      	bne.n	526 <ProcessPeerCerts+0x526>
                        if (ssl->peerEccDsaKey == NULL) {
 4e8:	f8d5 72a0 	ldr.w	r7, [r5, #672]	; 0x2a0
                        word32 idx = 0;
 4ec:	f04f 0900 	mov.w	r9, #0
 4f0:	f8cd 9014 	str.w	r9, [sp, #20]
                        if (ssl->peerEccDsaKey == NULL) {
 4f4:	2f00      	cmp	r7, #0
 4f6:	d150      	bne.n	59a <ProcessPeerCerts+0x59a>
                            keyRet = AllocKey(ssl, DYNAMIC_TYPE_ECC,
 4f8:	f505 7228 	add.w	r2, r5, #672	; 0x2a0
 4fc:	2125      	movs	r1, #37	; 0x25
 4fe:	4628      	mov	r0, r5
 500:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                        if (keyRet != 0 ||
 504:	2800      	cmp	r0, #0
 506:	d04b      	beq.n	5a0 <ProcessPeerCerts+0x5a0>
                            ret = PEER_KEY_ERROR;
 508:	4c48      	ldr	r4, [pc, #288]	; (62c <ProcessPeerCerts+0x62c>)
                        if (ssl->options.side == WOLFSSL_CLIENT_END && ssl->ecdhCurveOID == 0)
 50a:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
 50e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 512:	2b10      	cmp	r3, #16
 514:	d107      	bne.n	526 <ProcessPeerCerts+0x526>
 516:	f8d5 3290 	ldr.w	r3, [r5, #656]	; 0x290
 51a:	b923      	cbnz	r3, 526 <ProcessPeerCerts+0x526>
                            ssl->ecdhCurveOID = args->dCert->pkCurveOID;
 51c:	6873      	ldr	r3, [r6, #4]
 51e:	f8d3 32fc 	ldr.w	r3, [r3, #764]	; 0x2fc
                            ssl->ecdhCurveOID = ECC_X25519_OID;
 522:	f8c5 3290 	str.w	r3, [r5, #656]	; 0x290
            if (args->fatal && ret != 0) {
 526:	f896 3020 	ldrb.w	r3, [r6, #32]
 52a:	07da      	lsls	r2, r3, #31
 52c:	d502      	bpl.n	534 <ProcessPeerCerts+0x534>
 52e:	2c00      	cmp	r4, #0
 530:	f47f ada0 	bne.w	74 <ProcessPeerCerts+0x74>
            ssl->options.asyncState = TLS_ASYNC_FINALIZE;
 534:	2304      	movs	r3, #4
 536:	f885 3283 	strb.w	r3, [r5, #643]	; 0x283
            if (args->lastErr != 0 && ret == 0) {
 53a:	69f3      	ldr	r3, [r6, #28]
 53c:	b113      	cbz	r3, 544 <ProcessPeerCerts+0x544>
 53e:	2c00      	cmp	r4, #0
 540:	bf08      	it	eq
 542:	461c      	moveq	r4, r3
            ret = DoVerifyCallback(SSL_CM(ssl), ssl, ret, args);
 544:	6828      	ldr	r0, [r5, #0]
 546:	4622      	mov	r2, r4
 548:	4633      	mov	r3, r6
 54a:	6a80      	ldr	r0, [r0, #40]	; 0x28
 54c:	4629      	mov	r1, r5
 54e:	f7ff fffe 	bl	0 <ProcessPeerCerts>
            if (ssl->options.verifyNone &&
 552:	f995 2270 	ldrsb.w	r2, [r5, #624]	; 0x270
 556:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
 55a:	2a00      	cmp	r2, #0
            ret = DoVerifyCallback(SSL_CM(ssl), ssl, ret, args);
 55c:	4604      	mov	r4, r0
            if (ssl->options.verifyNone &&
 55e:	f280 80a0 	bge.w	6a2 <ProcessPeerCerts+0x6a2>
                              (ret == CRL_MISSING || ret == CRL_CERT_REVOKED ||
 562:	f500 72b5 	add.w	r2, r0, #362	; 0x16a
            if (ssl->options.verifyNone &&
 566:	2a01      	cmp	r2, #1
 568:	d903      	bls.n	572 <ProcessPeerCerts+0x572>
                              (ret == CRL_MISSING || ret == CRL_CERT_REVOKED ||
 56a:	f110 0fb3 	cmn.w	r0, #179	; 0xb3
 56e:	f040 80b2 	bne.w	6d6 <ProcessPeerCerts+0x6d6>
                ret = ssl->error = 0;
 572:	2200      	movs	r2, #0
 574:	f8c5 2114 	str.w	r2, [r5, #276]	; 0x114
            if (ret == 0 && ssl->options.side == WOLFSSL_CLIENT_END) {
 578:	f003 0330 	and.w	r3, r3, #48	; 0x30
 57c:	2b10      	cmp	r3, #16
 57e:	d102      	bne.n	586 <ProcessPeerCerts+0x586>
                ssl->options.serverState = SERVER_CERT_COMPLETE;
 580:	2305      	movs	r3, #5
 582:	f885 327c 	strb.w	r3, [r5, #636]	; 0x27c
 586:	2400      	movs	r4, #0
 588:	e094      	b.n	6b4 <ProcessPeerCerts+0x6b4>
                        if (MatchDomainName(
 58a:	460a      	mov	r2, r1
 58c:	e9d0 0119 	ldrd	r0, r1, [r0, #100]	; 0x64
 590:	f7ff fffe 	bl	0 <ProcessPeerCerts>
 594:	2800      	cmp	r0, #0
 596:	d09c      	beq.n	4d2 <ProcessPeerCerts+0x4d2>
 598:	e79c      	b.n	4d4 <ProcessPeerCerts+0x4d4>
                        } else if (ssl->peerEccDsaKeyPresent) {
 59a:	f895 32a6 	ldrb.w	r3, [r5, #678]	; 0x2a6
 59e:	b9eb      	cbnz	r3, 5dc <ProcessPeerCerts+0x5dc>
                            wc_EccPublicKeyDecode(args->dCert->publicKey, &idx,
 5a0:	6870      	ldr	r0, [r6, #4]
 5a2:	f8d5 22a0 	ldr.w	r2, [r5, #672]	; 0x2a0
 5a6:	6843      	ldr	r3, [r0, #4]
 5a8:	6800      	ldr	r0, [r0, #0]
 5aa:	a905      	add	r1, sp, #20
 5ac:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
                        if (keyRet != 0 ||
 5b0:	2800      	cmp	r0, #0
 5b2:	d1a9      	bne.n	508 <ProcessPeerCerts+0x508>
                            ssl->peerEccDsaKeyPresent = 1;
 5b4:	2301      	movs	r3, #1
 5b6:	f885 32a6 	strb.w	r3, [r5, #678]	; 0x2a6
                        if (ret == 0 && ssl->peerEccDsaKeyPresent &&
 5ba:	2c00      	cmp	r4, #0
 5bc:	d1a5      	bne.n	50a <ProcessPeerCerts+0x50a>
 5be:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
 5c2:	2b00      	cmp	r3, #0
 5c4:	dba1      	blt.n	50a <ProcessPeerCerts+0x50a>
                                              wc_ecc_size(ssl->peerEccDsaKey)
 5c6:	f8d5 02a0 	ldr.w	r0, [r5, #672]	; 0x2a0
 5ca:	f7ff fffe 	bl	0 <wc_ecc_size>
                                              < ssl->options.minEccKeySz) {
 5ce:	f9b5 2286 	ldrsh.w	r2, [r5, #646]	; 0x286
                            ret = ECC_KEY_SIZE_E;
 5d2:	4b14      	ldr	r3, [pc, #80]	; (624 <ProcessPeerCerts+0x624>)
 5d4:	4290      	cmp	r0, r2
 5d6:	bfb8      	it	lt
 5d8:	461c      	movlt	r4, r3
 5da:	e796      	b.n	50a <ProcessPeerCerts+0x50a>
            wc_ecc_free((ecc_key*)pKey);
 5dc:	4638      	mov	r0, r7
 5de:	f7ff fffe 	bl	0 <wc_ecc_free>
            ret = wc_ecc_init_ex((ecc_key*)pKey, ssl->heap, ssl->devId);
 5e2:	f8d5 22bc 	ldr.w	r2, [r5, #700]	; 0x2bc
 5e6:	6a69      	ldr	r1, [r5, #36]	; 0x24
 5e8:	4638      	mov	r0, r7
 5ea:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
                            ssl->peerEccDsaKeyPresent = 0;
 5ee:	f885 92a6 	strb.w	r9, [r5, #678]	; 0x2a6
 5f2:	e787      	b.n	504 <ProcessPeerCerts+0x504>
                        if (ssl->peerEd25519Key == NULL) {
 5f4:	f8d5 72ac 	ldr.w	r7, [r5, #684]	; 0x2ac
 5f8:	b9d7      	cbnz	r7, 630 <ProcessPeerCerts+0x630>
                            keyRet = AllocKey(ssl, DYNAMIC_TYPE_ED25519,
 5fa:	f505 722b 	add.w	r2, r5, #684	; 0x2ac
 5fe:	2146      	movs	r1, #70	; 0x46
 600:	4628      	mov	r0, r5
 602:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                        if (keyRet != 0 ||
 606:	b1b0      	cbz	r0, 636 <ProcessPeerCerts+0x636>
                            ret = PEER_KEY_ERROR;
 608:	4c08      	ldr	r4, [pc, #32]	; (62c <ProcessPeerCerts+0x62c>)
                        if (ssl->options.side == WOLFSSL_CLIENT_END && ssl->ecdhCurveOID == 0)
 60a:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
 60e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 612:	2b10      	cmp	r3, #16
 614:	d187      	bne.n	526 <ProcessPeerCerts+0x526>
 616:	f8d5 3290 	ldr.w	r3, [r5, #656]	; 0x290
 61a:	2b00      	cmp	r3, #0
 61c:	d183      	bne.n	526 <ProcessPeerCerts+0x526>
                            ssl->ecdhCurveOID = ECC_X25519_OID;
 61e:	f240 136d 	movw	r3, #365	; 0x16d
 622:	e77e      	b.n	522 <ProcessPeerCerts+0x522>
 624:	fffffe66 	.word	0xfffffe66
 628:	fffffebe 	.word	0xfffffebe
 62c:	fffffeaa 	.word	0xfffffeaa
                        } else if (ssl->peerEd25519KeyPresent) {
 630:	f895 32b0 	ldrb.w	r3, [r5, #688]	; 0x2b0
 634:	b9c3      	cbnz	r3, 668 <ProcessPeerCerts+0x668>
                            wc_ed25519_import_public(args->dCert->publicKey,
 636:	6873      	ldr	r3, [r6, #4]
 638:	f8d5 22ac 	ldr.w	r2, [r5, #684]	; 0x2ac
 63c:	e9d3 0100 	ldrd	r0, r1, [r3]
 640:	f7ff fffe 	bl	0 <wc_ed25519_import_public>
                        if (keyRet != 0 ||
 644:	2800      	cmp	r0, #0
 646:	d1df      	bne.n	608 <ProcessPeerCerts+0x608>
                            ssl->peerEd25519KeyPresent = 1;
 648:	2301      	movs	r3, #1
 64a:	f885 32b0 	strb.w	r3, [r5, #688]	; 0x2b0
                        if (ret == 0 && ssl->peerEd25519KeyPresent &&
 64e:	2c00      	cmp	r4, #0
 650:	d1db      	bne.n	60a <ProcessPeerCerts+0x60a>
 652:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
 656:	2b00      	cmp	r3, #0
 658:	dbd7      	blt.n	60a <ProcessPeerCerts+0x60a>
                                  !ssl->options.verifyNone &&
 65a:	f9b5 2286 	ldrsh.w	r2, [r5, #646]	; 0x286
                            ret = ECC_KEY_SIZE_E;
 65e:	4b2a      	ldr	r3, [pc, #168]	; (708 <ProcessPeerCerts+0x708>)
 660:	2a20      	cmp	r2, #32
 662:	bfc8      	it	gt
 664:	461c      	movgt	r4, r3
 666:	e7d0      	b.n	60a <ProcessPeerCerts+0x60a>
            wc_ed25519_free((ed25519_key*)pKey);
 668:	4638      	mov	r0, r7
 66a:	f7ff fffe 	bl	0 <wc_ed25519_free>
            ret = wc_ed25519_init_ex((ed25519_key*)pKey, ssl->heap,
 66e:	f8d5 22bc 	ldr.w	r2, [r5, #700]	; 0x2bc
 672:	6a69      	ldr	r1, [r5, #36]	; 0x24
 674:	4638      	mov	r0, r7
 676:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
                            ssl->peerEd25519KeyPresent = 0;
 67a:	2300      	movs	r3, #0
 67c:	f885 32b0 	strb.w	r3, [r5, #688]	; 0x2b0
 680:	e7c1      	b.n	606 <ProcessPeerCerts+0x606>
    switch (ssl->options.asyncState)
 682:	2400      	movs	r4, #0
 684:	e759      	b.n	53a <ProcessPeerCerts+0x53a>
 686:	2400      	movs	r4, #0
 688:	e021      	b.n	6ce <ProcessPeerCerts+0x6ce>
 68a:	f46f 7496 	mvn.w	r4, #300	; 0x12c
 68e:	e4f1      	b.n	74 <ProcessPeerCerts+0x74>
        ERROR_OUT(MEMORY_E, exit_ppc);
 690:	f06f 047c 	mvn.w	r4, #124	; 0x7c
    FreeKeyExchange(ssl);
 694:	4628      	mov	r0, r5
 696:	f7ff fffe 	bl	0 <ProcessPeerCerts>
}
 69a:	4620      	mov	r0, r4
 69c:	b007      	add	sp, #28
 69e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if (ret != 0) {
 6a2:	2800      	cmp	r0, #0
 6a4:	f43f af68 	beq.w	578 <ProcessPeerCerts+0x578>
                    DoCertFatalAlert(ssl, ret);
 6a8:	4621      	mov	r1, r4
 6aa:	4628      	mov	r0, r5
 6ac:	f7ff fffe 	bl	0 <ProcessPeerCerts>
                ssl->error = ret; /* Report SSL error */
 6b0:	f8c5 4114 	str.w	r4, [r5, #276]	; 0x114
            if (IsEncryptionOn(ssl, 0)) {
 6b4:	2100      	movs	r1, #0
 6b6:	4628      	mov	r0, r5
 6b8:	f7ff fffe 	bl	0 <ProcessPeerCerts>
 6bc:	b120      	cbz	r0, 6c8 <ProcessPeerCerts+0x6c8>
                args->idx += ssl->keys.padSz;
 6be:	68b3      	ldr	r3, [r6, #8]
 6c0:	f8d5 2264 	ldr.w	r2, [r5, #612]	; 0x264
 6c4:	4413      	add	r3, r2
 6c6:	60b3      	str	r3, [r6, #8]
            ssl->options.asyncState = TLS_ASYNC_END;
 6c8:	2305      	movs	r3, #5
 6ca:	f885 3283 	strb.w	r3, [r5, #643]	; 0x283
            *inOutIdx = args->idx;
 6ce:	68b3      	ldr	r3, [r6, #8]
 6d0:	f8c8 3000 	str.w	r3, [r8]
            break;
 6d4:	e4ce      	b.n	74 <ProcessPeerCerts+0x74>
            if (ret != 0) {
 6d6:	2800      	cmp	r0, #0
 6d8:	d1ea      	bne.n	6b0 <ProcessPeerCerts+0x6b0>
 6da:	e74d      	b.n	578 <ProcessPeerCerts+0x578>
                    if ((ssl->specs.kea != rsa_kea) &&
 6dc:	f895 314c 	ldrb.w	r3, [r5, #332]	; 0x14c
 6e0:	2b01      	cmp	r3, #1
 6e2:	d008      	beq.n	6f6 <ProcessPeerCerts+0x6f6>
                            (ssl->specs.sig_algo == ecc_dsa_sa_algo &&
 6e4:	f8d5 314c 	ldr.w	r3, [r5, #332]	; 0x14c
 6e8:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 6ec:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
                        (ssl->specs.sig_algo == rsa_sa_algo ||
 6f0:	2b03      	cmp	r3, #3
 6f2:	f47f ad8b 	bne.w	20c <ProcessPeerCerts+0x20c>
                                 !ssl->specs.static_ecdh)) &&
 6f6:	f8b0 32f8 	ldrh.w	r3, [r0, #760]	; 0x2f8
                        ret = KEYUSE_SIGNATURE_E;
 6fa:	f013 0f80 	tst.w	r3, #128	; 0x80
 6fe:	bf08      	it	eq
 700:	f46f 74bf 	mvneq.w	r4, #382	; 0x17e
 704:	e582      	b.n	20c <ProcessPeerCerts+0x20c>
 706:	bf00      	nop
 708:	fffffe66 	.word	0xfffffe66

Disassembly of section .text.DoApplicationData:

00000000 <DoApplicationData>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (ssl->options.handShakeDone == 0) {
   2:	f890 627f 	ldrb.w	r6, [r0, #639]	; 0x27f
    word32 msgSz   = WOLFSSL_IS_QUIC(ssl)? ssl->curSize : ssl->keys.encryptSz;
   6:	f8d0 5260 	ldr.w	r5, [r0, #608]	; 0x260
    word32 idx     = *inOutIdx;
   a:	6817      	ldr	r7, [r2, #0]
{
   c:	4604      	mov	r4, r0
    if (ssl->options.handShakeDone == 0) {
   e:	b93e      	cbnz	r6, 20 <DoApplicationData+0x20>
        if (sniff == NO_SNIFF) {
  10:	b91b      	cbnz	r3, 1a <DoApplicationData+0x1a>
            SendAlert(ssl, alert_fatal, unexpected_message);
  12:	220a      	movs	r2, #10
  14:	2102      	movs	r1, #2
  16:	f7ff fffe 	bl	0 <DoApplicationData>
        return OUT_OF_ORDER_E;
  1a:	f46f 70ba 	mvn.w	r0, #372	; 0x174
  1e:	e02f      	b.n	80 <DoApplicationData+0x80>
    if (ssl->specs.cipher_type == block) {
  20:	f890 0149 	ldrb.w	r0, [r0, #329]	; 0x149
  24:	2801      	cmp	r0, #1
  26:	d114      	bne.n	52 <DoApplicationData+0x52>
        if (ssl->options.tls1_1)
  28:	f994 0271 	ldrsb.w	r0, [r4, #625]	; 0x271
  2c:	2800      	cmp	r0, #0
  2e:	da1b      	bge.n	68 <DoApplicationData+0x68>
            ivExtra = ssl->specs.block_size;
  30:	f8b4 c144 	ldrh.w	ip, [r4, #324]	; 0x144
    dataSz = msgSz - ivExtra - ssl->keys.padSz;
  34:	f8d4 6264 	ldr.w	r6, [r4, #612]	; 0x264
  38:	1ba8      	subs	r0, r5, r6
  3a:	eba0 000c 	sub.w	r0, r0, ip
    if (dataSz < 0) {
  3e:	2800      	cmp	r0, #0
  40:	da15      	bge.n	6e <DoApplicationData+0x6e>
        if (sniff == NO_SNIFF) {
  42:	b923      	cbnz	r3, 4e <DoApplicationData+0x4e>
            SendAlert(ssl, alert_fatal, unexpected_message);
  44:	220a      	movs	r2, #10
  46:	2102      	movs	r1, #2
  48:	4620      	mov	r0, r4
  4a:	f7ff fffe 	bl	0 <DoApplicationData>
        return BUFFER_ERROR;
  4e:	480d      	ldr	r0, [pc, #52]	; (84 <DoApplicationData+0x84>)
  50:	e016      	b.n	80 <DoApplicationData+0x80>
    if (ssl->specs.cipher_type == aead) {
  52:	2802      	cmp	r0, #2
  54:	d108      	bne.n	68 <DoApplicationData+0x68>
    return (ssl->specs.cipher_type == aead) &&
  56:	f894 0148 	ldrb.w	r0, [r4, #328]	; 0x148
            ivExtra = AESGCM_EXP_IV_SZ;
  5a:	2809      	cmp	r0, #9
  5c:	bf0c      	ite	eq
  5e:	f04f 0c00 	moveq.w	ip, #0
  62:	f04f 0c08 	movne.w	ip, #8
  66:	e7e5      	b.n	34 <DoApplicationData+0x34>
    int    ivExtra = 0;
  68:	f04f 0c00 	mov.w	ip, #0
  6c:	e7e2      	b.n	34 <DoApplicationData+0x34>
    byte*  rawData = input + idx;  /* keep current  for hmac */
  6e:	bf1c      	itt	ne
  70:	19c9      	addne	r1, r1, r7
        idx += rawSz;
  72:	183f      	addne	r7, r7, r0
    idx += ssl->keys.padSz;
  74:	443e      	add	r6, r7
        ssl->buffers.clearOutputBuffer.length = dataSz;
  76:	bf18      	it	ne
  78:	e9c4 102e 	strdne	r1, r0, [r4, #184]	; 0xb8
    *inOutIdx = idx;
  7c:	6016      	str	r6, [r2, #0]
    return 0;
  7e:	2000      	movs	r0, #0
}
  80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  82:	bf00      	nop
  84:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.wolfSSL_ERR_reason_error_string:

00000000 <wolfSSL_ERR_reason_error_string>:
        error = -error;
   0:	2800      	cmp	r0, #0
   2:	bfc8      	it	gt
   4:	4240      	neggt	r0, r0
    if (error < MAX_CODE_E && error > MIN_CODE_E) {
   6:	f200 132b 	addw	r3, r0, #299	; 0x12b
   a:	2bc6      	cmp	r3, #198	; 0xc6
   c:	d801      	bhi.n	12 <wolfSSL_ERR_reason_error_string+0x12>
        return wc_GetErrorString(error);
   e:	f7ff bffe 	b.w	0 <wc_GetErrorString>
    switch (error) {
  12:	f500 70fd 	add.w	r0, r0, #506	; 0x1fa
  16:	f5b0 7ffc 	cmp.w	r0, #504	; 0x1f8
  1a:	bf9a      	itte	ls
  1c:	4b02      	ldrls	r3, [pc, #8]	; (28 <wolfSSL_ERR_reason_error_string+0x28>)
  1e:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
    if (error < MAX_CODE_E && error > MIN_CODE_E) {
  22:	4802      	ldrhi	r0, [pc, #8]	; (2c <wolfSSL_ERR_reason_error_string+0x2c>)
}
  24:	4770      	bx	lr
  26:	bf00      	nop
	...

Disassembly of section .text.wolfSSL_ERR_func_error_string:

00000000 <wolfSSL_ERR_func_error_string>:
}
   0:	4800      	ldr	r0, [pc, #0]	; (4 <wolfSSL_ERR_func_error_string+0x4>)
   2:	4770      	bx	lr
   4:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_ERR_lib_error_string:

00000000 <wolfSSL_ERR_lib_error_string>:
   0:	4800      	ldr	r0, [pc, #0]	; (4 <wolfSSL_ERR_lib_error_string+0x4>)
   2:	4770      	bx	lr
   4:	00000000 	.word	0x00000000

Disassembly of section .text.SetErrorString:

00000000 <SetErrorString>:
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
    XSTRNCPY(str, wolfSSL_ERR_reason_error_string(error), WOLFSSL_MAX_ERROR_SZ);
   4:	f7ff fffe 	bl	0 <SetErrorString>
   8:	2250      	movs	r2, #80	; 0x50
   a:	4601      	mov	r1, r0
   c:	4620      	mov	r0, r4
   e:	f7ff fffe 	bl	0 <strncpy>
    str[WOLFSSL_MAX_ERROR_SZ-1] = 0;
  12:	2300      	movs	r3, #0
  14:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
}
  18:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetCipherNames:

00000000 <GetCipherNames>:
}
   0:	4800      	ldr	r0, [pc, #0]	; (4 <GetCipherNames+0x4>)
   2:	4770      	bx	lr
   4:	00000000 	.word	0x00000000

Disassembly of section .text.GetCipherNamesSize:

00000000 <GetCipherNamesSize>:
}
   0:	2005      	movs	r0, #5
   2:	4770      	bx	lr

Disassembly of section .text.GetCipherNameInternal:

00000000 <GetCipherNameInternal>:
    return (int)(sizeof(cipher_names) / sizeof(CipherSuiteInfo));
   0:	4a0b      	ldr	r2, [pc, #44]	; (30 <GetCipherNameInternal+0x30>)
{
   2:	b530      	push	{r4, r5, lr}
    for (i = 0; i < GetCipherNamesSize(); i++) {
   4:	2300      	movs	r3, #0
   6:	4614      	mov	r4, r2
        if ((cipher_names[i].cipherSuite0 == cipherSuite0) &&
   8:	7a15      	ldrb	r5, [r2, #8]
   a:	4285      	cmp	r5, r0
   c:	d109      	bne.n	22 <GetCipherNameInternal+0x22>
   e:	7a55      	ldrb	r5, [r2, #9]
  10:	428d      	cmp	r5, r1
  12:	d106      	bne.n	22 <GetCipherNameInternal+0x22>
            && (! (cipher_names[i].flags & WOLFSSL_CIPHER_SUITE_FLAG_NAMEALIAS))
  14:	7a95      	ldrb	r5, [r2, #10]
  16:	07ed      	lsls	r5, r5, #31
  18:	d403      	bmi.n	22 <GetCipherNameInternal+0x22>
            nameInternal = cipher_names[i].name;
  1a:	220c      	movs	r2, #12
  1c:	4353      	muls	r3, r2
  1e:	58e0      	ldr	r0, [r4, r3]
}
  20:	bd30      	pop	{r4, r5, pc}
    for (i = 0; i < GetCipherNamesSize(); i++) {
  22:	3301      	adds	r3, #1
  24:	2b05      	cmp	r3, #5
  26:	f102 020c 	add.w	r2, r2, #12
  2a:	d1ed      	bne.n	8 <GetCipherNameInternal+0x8>
    const char* nameInternal = "None";
  2c:	4801      	ldr	r0, [pc, #4]	; (34 <GetCipherNameInternal+0x34>)
    return nameInternal;
  2e:	e7f7      	b.n	20 <GetCipherNameInternal+0x20>
	...

Disassembly of section .text.GetCipherNameIana:

00000000 <GetCipherNameIana>:
    return (int)(sizeof(cipher_names) / sizeof(CipherSuiteInfo));
   0:	4b0c      	ldr	r3, [pc, #48]	; (34 <GetCipherNameIana+0x34>)
{
   2:	b530      	push	{r4, r5, lr}
    for (i = 0; i < GetCipherNamesSize(); i++) {
   4:	2200      	movs	r2, #0
   6:	461c      	mov	r4, r3
        if ((cipher_names[i].cipherSuite0 == cipherSuite0) &&
   8:	7a1d      	ldrb	r5, [r3, #8]
   a:	4285      	cmp	r5, r0
   c:	d10a      	bne.n	24 <GetCipherNameIana+0x24>
   e:	7a5d      	ldrb	r5, [r3, #9]
  10:	428d      	cmp	r5, r1
  12:	d107      	bne.n	24 <GetCipherNameIana+0x24>
            && (! (cipher_names[i].flags & WOLFSSL_CIPHER_SUITE_FLAG_NAMEALIAS))
  14:	7a9d      	ldrb	r5, [r3, #10]
  16:	07ed      	lsls	r5, r5, #31
  18:	d404      	bmi.n	24 <GetCipherNameIana+0x24>
            nameIana = cipher_names[i].name_iana;
  1a:	230c      	movs	r3, #12
  1c:	fb03 4202 	mla	r2, r3, r2, r4
  20:	6850      	ldr	r0, [r2, #4]
}
  22:	bd30      	pop	{r4, r5, pc}
    for (i = 0; i < GetCipherNamesSize(); i++) {
  24:	3201      	adds	r2, #1
  26:	2a05      	cmp	r2, #5
  28:	f103 030c 	add.w	r3, r3, #12
  2c:	d1ec      	bne.n	8 <GetCipherNameIana+0x8>
    const char* nameIana = "NONE";
  2e:	4802      	ldr	r0, [pc, #8]	; (38 <GetCipherNameIana+0x38>)
    return nameIana;
  30:	e7f7      	b.n	22 <GetCipherNameIana+0x22>
  32:	bf00      	nop
	...

Disassembly of section .text.wolfSSL_get_cipher_name_internal:

00000000 <wolfSSL_get_cipher_name_internal>:
    if (ssl == NULL) {
   0:	b128      	cbz	r0, e <wolfSSL_get_cipher_name_internal+0xe>
    return GetCipherNameInternal(ssl->options.cipherSuite0, ssl->options.cipherSuite);
   2:	f890 1279 	ldrb.w	r1, [r0, #633]	; 0x279
   6:	f890 0278 	ldrb.w	r0, [r0, #632]	; 0x278
   a:	f7ff bffe 	b.w	0 <wolfSSL_get_cipher_name_internal>
}
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_cipher_name_iana:

00000000 <wolfSSL_get_cipher_name_iana>:
    if (ssl == NULL) {
   0:	b128      	cbz	r0, e <wolfSSL_get_cipher_name_iana+0xe>
    return GetCipherNameIana(ssl->options.cipherSuite0, ssl->options.cipherSuite);
   2:	f890 1279 	ldrb.w	r1, [r0, #633]	; 0x279
   6:	f890 0278 	ldrb.w	r0, [r0, #632]	; 0x278
   a:	f7ff bffe 	b.w	0 <wolfSSL_get_cipher_name_iana>
}
   e:	4770      	bx	lr

Disassembly of section .text.GetCipherSuiteFromName:

00000000 <GetCipherSuiteFromName>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	460d      	mov	r5, r1
    nameDelim = XSTRSTR(name, ":");
   6:	4920      	ldr	r1, [pc, #128]	; (88 <GetCipherSuiteFromName+0x88>)
{
   8:	4680      	mov	r8, r0
   a:	4616      	mov	r6, r2
   c:	461f      	mov	r7, r3
    nameDelim = XSTRSTR(name, ":");
   e:	f7ff fffe 	bl	0 <strstr>
    if (nameDelim)
  12:	b1f0      	cbz	r0, 52 <GetCipherSuiteFromName+0x52>
        len = (unsigned long)(nameDelim - name);
  14:	eba0 0408 	sub.w	r4, r0, r8
    return (int)(sizeof(cipher_names) / sizeof(CipherSuiteInfo));
  18:	f8df 9070 	ldr.w	r9, [pc, #112]	; 8c <GetCipherSuiteFromName+0x8c>
    for (i = 0; i < GetCipherNamesSize(); i++) {
  1c:	f04f 0b00 	mov.w	fp, #0
  20:	46ca      	mov	sl, r9
        int found = (XSTRNCMP(name, cipher_names[i].name, len) == 0) &&
  22:	f8d9 1000 	ldr.w	r1, [r9]
  26:	9101      	str	r1, [sp, #4]
  28:	4622      	mov	r2, r4
  2a:	4640      	mov	r0, r8
  2c:	f7ff fffe 	bl	0 <strncmp>
  30:	b9a0      	cbnz	r0, 5c <GetCipherSuiteFromName+0x5c>
  32:	9901      	ldr	r1, [sp, #4]
  34:	5d0b      	ldrb	r3, [r1, r4]
  36:	b98b      	cbnz	r3, 5c <GetCipherSuiteFromName+0x5c>
            *cipherSuite0 = cipher_names[i].cipherSuite0;
  38:	200c      	movs	r0, #12
  3a:	fb00 a00b 	mla	r0, r0, fp, sl
  3e:	7a03      	ldrb	r3, [r0, #8]
  40:	702b      	strb	r3, [r5, #0]
            *cipherSuite  = cipher_names[i].cipherSuite;
  42:	7a43      	ldrb	r3, [r0, #9]
  44:	7033      	strb	r3, [r6, #0]
            *flags = cipher_names[i].flags;
  46:	7a83      	ldrb	r3, [r0, #10]
  48:	603b      	str	r3, [r7, #0]
            ret = 0;
  4a:	2000      	movs	r0, #0
}
  4c:	b003      	add	sp, #12
  4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        len = (unsigned long)XSTRLEN(name);
  52:	4640      	mov	r0, r8
  54:	f7ff fffe 	bl	0 <strlen>
  58:	4604      	mov	r4, r0
  5a:	e7dd      	b.n	18 <GetCipherSuiteFromName+0x18>
            found = (XSTRNCMP(name, cipher_names[i].name_iana, len) == 0) &&
  5c:	f8d9 1004 	ldr.w	r1, [r9, #4]
  60:	9101      	str	r1, [sp, #4]
  62:	4622      	mov	r2, r4
  64:	4640      	mov	r0, r8
  66:	f7ff fffe 	bl	0 <strncmp>
  6a:	b918      	cbnz	r0, 74 <GetCipherSuiteFromName+0x74>
  6c:	9901      	ldr	r1, [sp, #4]
  6e:	5d0b      	ldrb	r3, [r1, r4]
  70:	2b00      	cmp	r3, #0
  72:	d0e1      	beq.n	38 <GetCipherSuiteFromName+0x38>
    for (i = 0; i < GetCipherNamesSize(); i++) {
  74:	f10b 0b01 	add.w	fp, fp, #1
  78:	f1bb 0f05 	cmp.w	fp, #5
  7c:	f109 090c 	add.w	r9, r9, #12
  80:	d1cf      	bne.n	22 <GetCipherSuiteFromName+0x22>
    int           ret = BAD_FUNC_ARG;
  82:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    return ret;
  86:	e7e1      	b.n	4c <GetCipherSuiteFromName+0x4c>
	...

Disassembly of section .text.SetCipherList:

00000000 <SetCipherList>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4682      	mov	sl, r0
   6:	b09b      	sub	sp, #108	; 0x6c
   8:	4616      	mov	r6, r2
    if (suites == NULL || list == NULL) {
   a:	460d      	mov	r5, r1
   c:	b909      	cbnz	r1, 12 <SetCipherList+0x12>
                    return 0; /* suites buffer not large enough, error out */
   e:	2400      	movs	r4, #0
  10:	e01c      	b.n	4c <SetCipherList+0x4c>
    if (suites == NULL || list == NULL) {
  12:	2a00      	cmp	r2, #0
  14:	d0fb      	beq.n	e <SetCipherList+0xe>
    if (next[0] == 0 || XSTRCMP(next, "ALL") == 0 ||
  16:	7813      	ldrb	r3, [r2, #0]
  18:	b9e3      	cbnz	r3, 54 <SetCipherList+0x54>
        InitSuites(suites, ctx->method->version,
  1a:	f8da 2000 	ldr.w	r2, [sl]
  1e:	7893      	ldrb	r3, [r2, #2]
  20:	930a      	str	r3, [sp, #40]	; 0x28
  22:	2401      	movs	r4, #1
  24:	2300      	movs	r3, #0
  26:	e9cd 3308 	strd	r3, r3, [sp, #32]
  2a:	e9cd 4406 	strd	r4, r4, [sp, #24]
  2e:	e9cd 3404 	strd	r3, r4, [sp, #16]
  32:	e9cd 4402 	strd	r4, r4, [sp, #8]
  36:	e9cd 4400 	strd	r4, r4, [sp]
  3a:	7850      	ldrb	r0, [r2, #1]
  3c:	7811      	ldrb	r1, [r2, #0]
  3e:	f8da 2020 	ldr.w	r2, [sl, #32]
  42:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  46:	4628      	mov	r0, r5
  48:	f7ff fffe 	bl	0 <SetCipherList>
}
  4c:	4620      	mov	r0, r4
  4e:	b01b      	add	sp, #108	; 0x6c
  50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (next[0] == 0 || XSTRCMP(next, "ALL") == 0 ||
  54:	494a      	ldr	r1, [pc, #296]	; (180 <SetCipherList+0x180>)
  56:	4610      	mov	r0, r2
  58:	f7ff fffe 	bl	0 <strcmp>
  5c:	2800      	cmp	r0, #0
  5e:	d0dc      	beq.n	1a <SetCipherList+0x1a>
        XSTRCMP(next, "DEFAULT") == 0 || XSTRCMP(next, "HIGH") == 0) {
  60:	4948      	ldr	r1, [pc, #288]	; (184 <SetCipherList+0x184>)
  62:	4630      	mov	r0, r6
  64:	f7ff fffe 	bl	0 <strcmp>
    if (next[0] == 0 || XSTRCMP(next, "ALL") == 0 ||
  68:	2800      	cmp	r0, #0
  6a:	d0d6      	beq.n	1a <SetCipherList+0x1a>
        XSTRCMP(next, "DEFAULT") == 0 || XSTRCMP(next, "HIGH") == 0) {
  6c:	4946      	ldr	r1, [pc, #280]	; (188 <SetCipherList+0x188>)
  6e:	4630      	mov	r0, r6
  70:	f7ff fffe 	bl	0 <strcmp>
  74:	2800      	cmp	r0, #0
  76:	d0d0      	beq.n	1a <SetCipherList+0x1a>
    int       haveSig          = 0;
  78:	2700      	movs	r7, #0
    int       idx              = 0;
  7a:	46b8      	mov	r8, r7
    int       ret              = 0;
  7c:	463c      	mov	r4, r7
        next = XSTRSTR(next, ":");
  7e:	4943      	ldr	r1, [pc, #268]	; (18c <SetCipherList+0x18c>)
  80:	4630      	mov	r0, r6
  82:	f7ff fffe 	bl	0 <strstr>
        if (next != NULL) {
  86:	4681      	mov	r9, r0
  88:	2800      	cmp	r0, #0
  8a:	d058      	beq.n	13e <SetCipherList+0x13e>
            word32 currLen = (word32)(next - current);
  8c:	eba0 0b06 	sub.w	fp, r0, r6
        length = MAX_SUITE_NAME;
  90:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
  94:	bf28      	it	cs
  96:	f04f 0b30 	movcs.w	fp, #48	; 0x30
        XSTRNCPY(name, current, length);
  9a:	465a      	mov	r2, fp
  9c:	4631      	mov	r1, r6
  9e:	a80d      	add	r0, sp, #52	; 0x34
  a0:	f7ff fffe 	bl	0 <strncpy>
        name[(length == sizeof(name)) ? length - 1 : length] = 0;
  a4:	f10b 0368 	add.w	r3, fp, #104	; 0x68
  a8:	eb0d 0b03 	add.w	fp, sp, r3
  ac:	2600      	movs	r6, #0
  ae:	f80b 6c34 	strb.w	r6, [fp, #-52]
        for (i = 0; i < suiteSz; i++) {
  b2:	f8df b0dc 	ldr.w	fp, [pc, #220]	; 190 <SetCipherList+0x190>
            if (XSTRNCMP(name, cipher_names[i].name, sizeof(name)) == 0
  b6:	f8db 1000 	ldr.w	r1, [fp]
  ba:	2231      	movs	r2, #49	; 0x31
  bc:	a80d      	add	r0, sp, #52	; 0x34
  be:	f7ff fffe 	bl	0 <strncmp>
  c2:	2800      	cmp	r0, #0
  c4:	d13e      	bne.n	144 <SetCipherList+0x144>
                    if ((suites->suites[j+0] == cipher_names[i].cipherSuite0) &&
  c6:	4832      	ldr	r0, [pc, #200]	; (190 <SetCipherList+0x190>)
  c8:	220c      	movs	r2, #12
  ca:	462b      	mov	r3, r5
                for (j = 0; j < idx; j += 2) {
  cc:	2100      	movs	r1, #0
                    if ((suites->suites[j+0] == cipher_names[i].cipherSuite0) &&
  ce:	fb02 0206 	mla	r2, r2, r6, r0
                for (j = 0; j < idx; j += 2) {
  d2:	4588      	cmp	r8, r1
  d4:	dc44      	bgt.n	160 <SetCipherList+0x160>
                if (j != idx) {
  d6:	d11a      	bne.n	10e <SetCipherList+0x10e>
                if (idx + 1 >= WOLFSSL_MAX_SUITE_SZ) {
  d8:	f5b8 7f95 	cmp.w	r8, #298	; 0x12a
  dc:	dc97      	bgt.n	e <SetCipherList+0xe>
                suites->suites[idx++] = cipher_names[i].cipherSuite0;
  de:	482c      	ldr	r0, [pc, #176]	; (190 <SetCipherList+0x190>)
  e0:	220c      	movs	r2, #12
  e2:	fb02 0606 	mla	r6, r2, r6, r0
  e6:	eb05 0108 	add.w	r1, r5, r8
  ea:	f108 0301 	add.w	r3, r8, #1
  ee:	7a32      	ldrb	r2, [r6, #8]
  f0:	710a      	strb	r2, [r1, #4]
                suites->suites[idx++] = cipher_names[i].cipherSuite;
  f2:	442b      	add	r3, r5
  f4:	7a72      	ldrb	r2, [r6, #9]
                if (XSTRSTR(name, "ECDSA"))
  f6:	4927      	ldr	r1, [pc, #156]	; (194 <SetCipherList+0x194>)
                suites->suites[idx++] = cipher_names[i].cipherSuite;
  f8:	711a      	strb	r2, [r3, #4]
                if (XSTRSTR(name, "ECDSA"))
  fa:	a80d      	add	r0, sp, #52	; 0x34
                suites->suites[idx++] = cipher_names[i].cipherSuite;
  fc:	f108 0802 	add.w	r8, r8, #2
                if (XSTRSTR(name, "ECDSA"))
 100:	f7ff fffe 	bl	0 <strstr>
 104:	2800      	cmp	r0, #0
 106:	d038      	beq.n	17a <SetCipherList+0x17a>
                    haveSig |= SIG_ECDSA;
 108:	f047 0701 	orr.w	r7, r7, #1
                ret = 1; /* found at least one */
 10c:	2401      	movs	r4, #1
    while (next++); /* ++ needed to skip ':' */
 10e:	f109 0601 	add.w	r6, r9, #1
 112:	f1b9 0f00 	cmp.w	r9, #0
 116:	d1b2      	bne.n	7e <SetCipherList+0x7e>
    if (ret) {
 118:	2c00      	cmp	r4, #0
 11a:	f43f af78 	beq.w	e <SetCipherList+0xe>
            InitSuitesHashSigAlgo_ex2(suites->hashSigAlgo, haveSig, 1, keySz,
 11e:	1caa      	adds	r2, r5, #2
        keySz = ctx->privateKeySz;
 120:	f8da 3020 	ldr.w	r3, [sl, #32]
            suites->suiteSz   = (word16)idx;
 124:	f8a5 8000 	strh.w	r8, [r5]
            InitSuitesHashSigAlgo_ex2(suites->hashSigAlgo, haveSig, 1, keySz,
 128:	4639      	mov	r1, r7
 12a:	9200      	str	r2, [sp, #0]
 12c:	f505 7098 	add.w	r0, r5, #304	; 0x130
 130:	2201      	movs	r2, #1
 132:	f7ff fffe 	bl	0 <SetCipherList>
        suites->setSuites = 1;
 136:	2301      	movs	r3, #1
 138:	f885 3156 	strb.w	r3, [r5, #342]	; 0x156
 13c:	e786      	b.n	4c <SetCipherList+0x4c>
        length = MAX_SUITE_NAME;
 13e:	f04f 0b30 	mov.w	fp, #48	; 0x30
 142:	e7aa      	b.n	9a <SetCipherList+0x9a>
                || XSTRNCMP(name, cipher_names[i].name_iana, sizeof(name)) == 0
 144:	f8db 1004 	ldr.w	r1, [fp, #4]
 148:	2231      	movs	r2, #49	; 0x31
 14a:	a80d      	add	r0, sp, #52	; 0x34
 14c:	f7ff fffe 	bl	0 <strncmp>
 150:	2800      	cmp	r0, #0
 152:	d0b8      	beq.n	c6 <SetCipherList+0xc6>
        for (i = 0; i < suiteSz; i++) {
 154:	3601      	adds	r6, #1
 156:	2e05      	cmp	r6, #5
 158:	f10b 0b0c 	add.w	fp, fp, #12
 15c:	d1ab      	bne.n	b6 <SetCipherList+0xb6>
 15e:	e7d6      	b.n	10e <SetCipherList+0x10e>
                    if ((suites->suites[j+0] == cipher_names[i].cipherSuite0) &&
 160:	f893 c004 	ldrb.w	ip, [r3, #4]
 164:	7a10      	ldrb	r0, [r2, #8]
 166:	4584      	cmp	ip, r0
 168:	d104      	bne.n	174 <SetCipherList+0x174>
 16a:	f893 c005 	ldrb.w	ip, [r3, #5]
 16e:	7a50      	ldrb	r0, [r2, #9]
 170:	4584      	cmp	ip, r0
 172:	d0cc      	beq.n	10e <SetCipherList+0x10e>
                for (j = 0; j < idx; j += 2) {
 174:	3102      	adds	r1, #2
 176:	3302      	adds	r3, #2
 178:	e7ab      	b.n	d2 <SetCipherList+0xd2>
                    haveSig |= SIG_RSA;
 17a:	f047 0702 	orr.w	r7, r7, #2
 17e:	e7c5      	b.n	10c <SetCipherList+0x10c>
 180:	00000000 	.word	0x00000000
 184:	00000004 	.word	0x00000004
 188:	0000000c 	.word	0x0000000c
	...
 194:	00000011 	.word	0x00000011

Disassembly of section .text.PickHashSigAlgo:

00000000 <PickHashSigAlgo>:
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4604      	mov	r4, r0
    if (IsAtLeastTLSv1_3(ssl->version)) {
   6:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
{
   a:	460e      	mov	r6, r1
   c:	4615      	mov	r5, r2
    if (IsAtLeastTLSv1_3(ssl->version)) {
   e:	f7ff fffe 	bl	0 <PickHashSigAlgo>
  12:	b178      	cbz	r0, 34 <PickHashSigAlgo+0x34>
        ssl->options.sigAlgo = ssl->buffers.keyType;
  14:	f894 20e4 	ldrb.w	r2, [r4, #228]	; 0xe4
  18:	f002 023f 	and.w	r2, r2, #63	; 0x3f
  1c:	f884 227b 	strb.w	r2, [r4, #635]	; 0x27b
    if (ssl->options.sigAlgo == anonymous_sa_algo) {
  20:	b95a      	cbnz	r2, 3a <PickHashSigAlgo+0x3a>
        ssl->options.hashAlgo = ssl->specs.mac_algorithm;
  22:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
  26:	f884 327a 	strb.w	r3, [r4, #634]	; 0x27a
            ret = 0;
  2a:	2500      	movs	r5, #0
}
  2c:	4628      	mov	r0, r5
  2e:	b003      	add	sp, #12
  30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        ssl->options.sigAlgo = ssl->specs.sig_algo;
  34:	f894 214c 	ldrb.w	r2, [r4, #332]	; 0x14c
  38:	e7f0      	b.n	1c <PickHashSigAlgo+0x1c>
    if (IsAtLeastTLSv1_2(ssl)) {
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <PickHashSigAlgo>
        return sha256_mac;
  40:	2800      	cmp	r0, #0
  42:	bf0c      	ite	eq
  44:	2702      	moveq	r7, #2
  46:	2704      	movne	r7, #4
    ssl->options.hashAlgo = minHash = MinHashAlgo(ssl);
  48:	f884 727a 	strb.w	r7, [r4, #634]	; 0x27a
    if (hashSigAlgoSz == 0)
  4c:	2d00      	cmp	r5, #0
  4e:	d0ed      	beq.n	2c <PickHashSigAlgo+0x2c>
  50:	f025 0501 	bic.w	r5, r5, #1
  54:	eb06 0905 	add.w	r9, r6, r5
        byte hashAlgo = 0, sigAlgo = 0;
  58:	f04f 0800 	mov.w	r8, #0
    int ret = MATCH_SUITE_ERROR;
  5c:	f46f 75fa 	mvn.w	r5, #500	; 0x1f4
    for (i = 0; (i+1) < hashSigAlgoSz; i += HELLO_EXT_SIGALGO_SZ) {
  60:	454e      	cmp	r6, r9
  62:	d0e3      	beq.n	2c <PickHashSigAlgo+0x2c>
        DecodeSigAlg(&hashSigAlgo[i], &hashAlgo, &sigAlgo);
  64:	f10d 0207 	add.w	r2, sp, #7
  68:	f10d 0106 	add.w	r1, sp, #6
  6c:	4630      	mov	r0, r6
        byte hashAlgo = 0, sigAlgo = 0;
  6e:	f88d 8006 	strb.w	r8, [sp, #6]
  72:	f88d 8007 	strb.w	r8, [sp, #7]
        DecodeSigAlg(&hashSigAlgo[i], &hashAlgo, &sigAlgo);
  76:	f7ff fffe 	bl	0 <PickHashSigAlgo>
        if (hashAlgo < minHash)
  7a:	f89d 2006 	ldrb.w	r2, [sp, #6]
  7e:	42ba      	cmp	r2, r7
  80:	d311      	bcc.n	a6 <PickHashSigAlgo+0xa6>
    if (ssl->pkCurveOID == ECC_ED25519_OID) {
  82:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
        if (!MatchSigAlgo(ssl, sigAlgo))
  86:	f89d 1007 	ldrb.w	r1, [sp, #7]
    if (ssl->pkCurveOID == ECC_ED25519_OID) {
  8a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  8e:	d106      	bne.n	9e <PickHashSigAlgo+0x9e>
        if (!MatchSigAlgo(ssl, sigAlgo))
  90:	2909      	cmp	r1, #9
  92:	d108      	bne.n	a6 <PickHashSigAlgo+0xa6>
            ssl->options.sigAlgo = sigAlgo;
  94:	f884 127b 	strb.w	r1, [r4, #635]	; 0x27b
            ssl->options.hashAlgo = hashAlgo;
  98:	f884 227a 	strb.w	r2, [r4, #634]	; 0x27a
  9c:	e7c5      	b.n	2a <PickHashSigAlgo+0x2a>
    return sigAlgo == ssl->options.sigAlgo;
  9e:	f894 327b 	ldrb.w	r3, [r4, #635]	; 0x27b
        if (!MatchSigAlgo(ssl, sigAlgo))
  a2:	4299      	cmp	r1, r3
  a4:	d001      	beq.n	aa <PickHashSigAlgo+0xaa>
    for (i = 0; (i+1) < hashSigAlgoSz; i += HELLO_EXT_SIGALGO_SZ) {
  a6:	3602      	adds	r6, #2
  a8:	e7da      	b.n	60 <PickHashSigAlgo+0x60>
        switch (hashAlgo) {
  aa:	2a06      	cmp	r2, #6
  ac:	d8fb      	bhi.n	a6 <PickHashSigAlgo+0xa6>
  ae:	2301      	movs	r3, #1
  b0:	4093      	lsls	r3, r2
  b2:	f013 0f54 	tst.w	r3, #84	; 0x54
  b6:	d0f6      	beq.n	a6 <PickHashSigAlgo+0xa6>
                if (ret == 0 && hashAlgo > ssl->options.hashAlgo)
  b8:	b91d      	cbnz	r5, c2 <PickHashSigAlgo+0xc2>
  ba:	f894 327a 	ldrb.w	r3, [r4, #634]	; 0x27a
  be:	4293      	cmp	r3, r2
  c0:	d3f1      	bcc.n	a6 <PickHashSigAlgo+0xa6>
                if (IsAtLeastTLSv1_2(ssl) && !IsAtLeastTLSv1_3(ssl->version) &&
  c2:	4620      	mov	r0, r4
  c4:	f7ff fffe 	bl	0 <PickHashSigAlgo>
  c8:	b180      	cbz	r0, ec <PickHashSigAlgo+0xec>
  ca:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
  ce:	f7ff fffe 	bl	0 <PickHashSigAlgo>
  d2:	b958      	cbnz	r0, ec <PickHashSigAlgo+0xec>
                        (ssl->options.side == WOLFSSL_CLIENT_END)) {
  d4:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
                if (IsAtLeastTLSv1_2(ssl) && !IsAtLeastTLSv1_3(ssl->version) &&
  d8:	f003 0330 	and.w	r3, r3, #48	; 0x30
  dc:	2b10      	cmp	r3, #16
  de:	d105      	bne.n	ec <PickHashSigAlgo+0xec>
                    if (1
  e0:	f002 03fb 	and.w	r3, r2, #251	; 0xfb
  e4:	2b02      	cmp	r3, #2
  e6:	d001      	beq.n	ec <PickHashSigAlgo+0xec>
                        && (hashAlgo != sha256_mac)
  e8:	2a04      	cmp	r2, #4
  ea:	d1dc      	bne.n	a6 <PickHashSigAlgo+0xa6>
                ssl->options.hashAlgo = hashAlgo;
  ec:	f884 227a 	strb.w	r2, [r4, #634]	; 0x27a
                ssl->options.sigAlgo = sigAlgo;
  f0:	f884 127b 	strb.w	r1, [r4, #635]	; 0x27b
                ret = 0;
  f4:	2500      	movs	r5, #0
                break;
  f6:	e7d6      	b.n	a6 <PickHashSigAlgo+0xa6>

Disassembly of section .text.DecodePrivateKey:

00000000 <DecodePrivateKey>:
    if (ssl->buffers.key == NULL || ssl->buffers.key->buffer == NULL) {
   0:	f8d0 30e0 	ldr.w	r3, [r0, #224]	; 0xe0
{
   4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   6:	4605      	mov	r5, r0
   8:	460e      	mov	r6, r1
    if (ssl->buffers.key == NULL || ssl->buffers.key->buffer == NULL) {
   a:	2b00      	cmp	r3, #0
   c:	d059      	beq.n	c2 <DecodePrivateKey+0xc2>
   e:	681b      	ldr	r3, [r3, #0]
  10:	2b00      	cmp	r3, #0
  12:	d056      	beq.n	c2 <DecodePrivateKey+0xc2>
    if (ssl->buffers.keyType == ecc_dsa_sa_algo || ssl->buffers.keyType == 0
  14:	f890 30e4 	ldrb.w	r3, [r0, #228]	; 0xe4
  18:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  1c:	2b03      	cmp	r3, #3
  1e:	f100 073c 	add.w	r7, r0, #60	; 0x3c
  22:	d000      	beq.n	26 <DecodePrivateKey+0x26>
  24:	bb13      	cbnz	r3, 6c <DecodePrivateKey+0x6c>
        ssl->hsType = DYNAMIC_TYPE_ECC;
  26:	2125      	movs	r1, #37	; 0x25
  28:	6429      	str	r1, [r5, #64]	; 0x40
        ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
  2a:	463a      	mov	r2, r7
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <DecodePrivateKey>
        if (ret != 0) {
  32:	4604      	mov	r4, r0
  34:	b990      	cbnz	r0, 5c <DecodePrivateKey+0x5c>
        idx = 0;
  36:	9001      	str	r0, [sp, #4]
        ret = wc_EccPrivateKeyDecode(ssl->buffers.key->buffer, &idx,
  38:	f8d5 00e0 	ldr.w	r0, [r5, #224]	; 0xe0
  3c:	6bea      	ldr	r2, [r5, #60]	; 0x3c
  3e:	6883      	ldr	r3, [r0, #8]
  40:	6800      	ldr	r0, [r0, #0]
  42:	a901      	add	r1, sp, #4
  44:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
        if (ret == 0) {
  48:	4604      	mov	r4, r0
  4a:	b988      	cbnz	r0, 70 <DecodePrivateKey+0x70>
            keySz = wc_ecc_size((ecc_key*)ssl->hsKey);
  4c:	6be8      	ldr	r0, [r5, #60]	; 0x3c
  4e:	f7ff fffe 	bl	0 <wc_ecc_size>
            if (keySz < ssl->options.minEccKeySz) {
  52:	f9b5 3286 	ldrsh.w	r3, [r5, #646]	; 0x286
  56:	4283      	cmp	r3, r0
  58:	dd03      	ble.n	62 <DecodePrivateKey+0x62>
                ERROR_OUT(ECC_KEY_SIZE_E, exit_dpk);
  5a:	4c1b      	ldr	r4, [pc, #108]	; (c8 <DecodePrivateKey+0xc8>)
}
  5c:	4620      	mov	r0, r4
  5e:	b003      	add	sp, #12
  60:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *length = (word16)wc_ecc_sig_size((ecc_key*)ssl->hsKey);
  62:	6be8      	ldr	r0, [r5, #60]	; 0x3c
  64:	f7ff fffe 	bl	0 <wc_ecc_sig_size>
  68:	8030      	strh	r0, [r6, #0]
            goto exit_dpk;
  6a:	e7f7      	b.n	5c <DecodePrivateKey+0x5c>
    int      ret = BAD_FUNC_ARG;
  6c:	f06f 04ac 	mvn.w	r4, #172	; 0xac
        FreeKey(ssl, ssl->hsType, (void**)&ssl->hsKey);
  70:	6c29      	ldr	r1, [r5, #64]	; 0x40
  72:	463a      	mov	r2, r7
  74:	4628      	mov	r0, r5
  76:	f7ff fffe 	bl	0 <DecodePrivateKey>
    if (ssl->buffers.keyType == ed25519_sa_algo || ssl->buffers.keyType == 0) {
  7a:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
  7e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  82:	2b09      	cmp	r3, #9
  84:	d001      	beq.n	8a <DecodePrivateKey+0x8a>
  86:	2b00      	cmp	r3, #0
  88:	d1e8      	bne.n	5c <DecodePrivateKey+0x5c>
        ssl->hsType = DYNAMIC_TYPE_ED25519;
  8a:	2146      	movs	r1, #70	; 0x46
  8c:	6429      	str	r1, [r5, #64]	; 0x40
        ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
  8e:	463a      	mov	r2, r7
  90:	4628      	mov	r0, r5
  92:	f7ff fffe 	bl	0 <DecodePrivateKey>
        if (ret != 0) {
  96:	4604      	mov	r4, r0
  98:	2800      	cmp	r0, #0
  9a:	d1df      	bne.n	5c <DecodePrivateKey+0x5c>
        idx = 0;
  9c:	9001      	str	r0, [sp, #4]
        ret = wc_Ed25519PrivateKeyDecode(ssl->buffers.key->buffer, &idx,
  9e:	f8d5 00e0 	ldr.w	r0, [r5, #224]	; 0xe0
  a2:	6bea      	ldr	r2, [r5, #60]	; 0x3c
  a4:	6883      	ldr	r3, [r0, #8]
  a6:	6800      	ldr	r0, [r0, #0]
  a8:	a901      	add	r1, sp, #4
  aa:	f7ff fffe 	bl	0 <wc_Ed25519PrivateKeyDecode>
        if (ret == 0) {
  ae:	4604      	mov	r4, r0
  b0:	2800      	cmp	r0, #0
  b2:	d1d3      	bne.n	5c <DecodePrivateKey+0x5c>
            if (ED25519_KEY_SIZE < ssl->options.minEccKeySz) {
  b4:	f9b5 3286 	ldrsh.w	r3, [r5, #646]	; 0x286
  b8:	2b20      	cmp	r3, #32
  ba:	dcce      	bgt.n	5a <DecodePrivateKey+0x5a>
            *length = ED25519_SIG_SIZE;
  bc:	2340      	movs	r3, #64	; 0x40
  be:	8033      	strh	r3, [r6, #0]
            goto exit_dpk;
  c0:	e7cc      	b.n	5c <DecodePrivateKey+0x5c>
            ERROR_OUT(NO_PRIVATE_KEY, exit_dpk);
  c2:	f46f 749e 	mvn.w	r4, #316	; 0x13c
    return ret;
  c6:	e7c9      	b.n	5c <DecodePrivateKey+0x5c>
  c8:	fffffe66 	.word	0xfffffe66

Disassembly of section .text.HaveUniqueSessionObj:

00000000 <HaveUniqueSessionObj>:
    {
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4605      	mov	r5, r0
        if (ssl->session->ref.count > 1) {
   4:	f8d0 00f4 	ldr.w	r0, [r0, #244]	; 0xf4
   8:	6843      	ldr	r3, [r0, #4]
   a:	2b01      	cmp	r3, #1
   c:	dd0a      	ble.n	24 <HaveUniqueSessionObj+0x24>
            WOLFSSL_SESSION* newSession = wolfSSL_SESSION_dup(ssl->session);
   e:	f7ff fffe 	bl	0 <wolfSSL_SESSION_dup>
            if (newSession == NULL) {
  12:	4604      	mov	r4, r0
  14:	b138      	cbz	r0, 26 <HaveUniqueSessionObj+0x26>
            wolfSSL_FreeSession(ssl->ctx, ssl->session);
  16:	f8d5 10f4 	ldr.w	r1, [r5, #244]	; 0xf4
  1a:	6828      	ldr	r0, [r5, #0]
  1c:	f7ff fffe 	bl	0 <wolfSSL_FreeSession>
            ssl->session = newSession;
  20:	f8c5 40f4 	str.w	r4, [r5, #244]	; 0xf4
        return 1;
  24:	2001      	movs	r0, #1
    }
  26:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.SendClientHello:

00000000 <SendClientHello>:
    {
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	b088      	sub	sp, #32
        word16             extSz = 0;
   6:	2300      	movs	r3, #0
   8:	f8ad 301e 	strh.w	r3, [sp, #30]
        if (ssl == NULL) {
   c:	4605      	mov	r5, r0
   e:	b928      	cbnz	r0, 1c <SendClientHello+0x1c>
            return BAD_FUNC_ARG;
  10:	f06f 04ac 	mvn.w	r4, #172	; 0xac
    }
  14:	4620      	mov	r0, r4
  16:	b008      	add	sp, #32
  18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        idSz = ssl->options.resuming ? ssl->session->sessionIDSz : 0;
  1c:	f890 9271 	ldrb.w	r9, [r0, #625]	; 0x271
        suites = WOLFSSL_SUITES(ssl);
  20:	6847      	ldr	r7, [r0, #4]
        idSz = ssl->options.resuming ? ssl->session->sessionIDSz : 0;
  22:	f019 0908 	ands.w	r9, r9, #8
  26:	bf1c      	itt	ne
  28:	f8d0 30f4 	ldrne.w	r3, [r0, #244]	; 0xf4
  2c:	f893 905c 	ldrbne.w	r9, [r3, #92]	; 0x5c
        suites = WOLFSSL_SUITES(ssl);
  30:	b927      	cbnz	r7, 3c <SendClientHello+0x3c>
  32:	6803      	ldr	r3, [r0, #0]
  34:	6adf      	ldr	r7, [r3, #44]	; 0x2c
        if (suites == NULL) {
  36:	2f00      	cmp	r7, #0
  38:	f000 80f1 	beq.w	21e <SendClientHello+0x21e>
        if ((ret = TLSX_PopulateExtensions(ssl, 0)) != 0)
  3c:	2100      	movs	r1, #0
  3e:	4628      	mov	r0, r5
            length += suites->suiteSz;
  40:	f8b7 a000 	ldrh.w	sl, [r7]
        if ((ret = TLSX_PopulateExtensions(ssl, 0)) != 0)
  44:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
  48:	4604      	mov	r4, r0
  4a:	2800      	cmp	r0, #0
  4c:	d1e2      	bne.n	14 <SendClientHello+0x14>
        extSz = 0;
  4e:	f8ad 001e 	strh.w	r0, [sp, #30]
        ret = TLSX_GetRequestSize(ssl, client_hello, &extSz);
  52:	f10d 021e 	add.w	r2, sp, #30
  56:	2101      	movs	r1, #1
  58:	4628      	mov	r0, r5
  5a:	f7ff fffe 	bl	0 <TLSX_GetRequestSize>
        if (ret != 0)
  5e:	4604      	mov	r4, r0
  60:	2800      	cmp	r0, #0
  62:	d1d7      	bne.n	14 <SendClientHello+0x14>
        length += extSz;
  64:	f8bd 301e 	ldrh.w	r3, [sp, #30]
               + COMP_LEN + ENUM_LEN;
  68:	f109 0227 	add.w	r2, r9, #39	; 0x27
  6c:	4413      	add	r3, r2
        length += extSz;
  6e:	449a      	add	sl, r3
        if (ssl->arrays == NULL) {
  70:	68ab      	ldr	r3, [r5, #8]
  72:	2b00      	cmp	r3, #0
  74:	d0cc      	beq.n	10 <SendClientHello+0x10>
        if (IsEncryptionOn(ssl, 1))
  76:	2101      	movs	r1, #1
  78:	4628      	mov	r0, r5
  7a:	f7ff fffe 	bl	0 <SendClientHello>
  7e:	2800      	cmp	r0, #0
  80:	f040 80bc 	bne.w	1fc <SendClientHello+0x1fc>
        sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
  84:	f10a 0809 	add.w	r8, sl, #9
        ssl->options.buildingMsg = 1;
  88:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
  8c:	f043 0308 	orr.w	r3, r3, #8
  90:	f885 3276 	strb.w	r3, [r5, #630]	; 0x276
        if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
  94:	4641      	mov	r1, r8
  96:	4628      	mov	r0, r5
  98:	f7ff fffe 	bl	0 <SendClientHello>
  9c:	4604      	mov	r4, r0
  9e:	2800      	cmp	r0, #0
  a0:	d1b8      	bne.n	14 <SendClientHello+0x14>
        output = GetOutputBuffer(ssl);
  a2:	4628      	mov	r0, r5
  a4:	f7ff fffe 	bl	0 <SendClientHello>
        AddHeaders(output, length, client_hello, ssl);
  a8:	4651      	mov	r1, sl
  aa:	462b      	mov	r3, r5
  ac:	2201      	movs	r2, #1
  ae:	f7ff fffe 	bl	0 <SendClientHello>
        output[idx++] = ssl->version.major;
  b2:	f895 313c 	ldrb.w	r3, [r5, #316]	; 0x13c
  b6:	7243      	strb	r3, [r0, #9]
        output[idx++] = ssl->version.minor;
  b8:	f895 313d 	ldrb.w	r3, [r5, #317]	; 0x13d
  bc:	7283      	strb	r3, [r0, #10]
        ssl->chVersion = ssl->version;  /* store in case changed */
  be:	f8b5 313c 	ldrh.w	r3, [r5, #316]	; 0x13c
  c2:	f8a5 313e 	strh.w	r3, [r5, #318]	; 0x13e
        if (ssl->options.connectState == CONNECT_BEGIN) {
  c6:	f895 3281 	ldrb.w	r3, [r5, #641]	; 0x281
        output = GetOutputBuffer(ssl);
  ca:	4606      	mov	r6, r0
        if (ssl->options.connectState == CONNECT_BEGIN) {
  cc:	b97b      	cbnz	r3, ee <SendClientHello+0xee>
            ret = wc_RNG_GenerateBlock(ssl->rng, output + idx, RAN_LEN);
  ce:	f100 0a0b 	add.w	sl, r0, #11
  d2:	2220      	movs	r2, #32
  d4:	69a8      	ldr	r0, [r5, #24]
  d6:	4651      	mov	r1, sl
  d8:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
            if (ret != 0)
  dc:	4604      	mov	r4, r0
  de:	2800      	cmp	r0, #0
  e0:	d198      	bne.n	14 <SendClientHello+0x14>
            XMEMCPY(ssl->arrays->clientRandom, output + idx, RAN_LEN);
  e2:	68a8      	ldr	r0, [r5, #8]
  e4:	2220      	movs	r2, #32
  e6:	4651      	mov	r1, sl
  e8:	3014      	adds	r0, #20
  ea:	f7ff fffe 	bl	0 <memcpy>
        output[idx++] = (byte)idSz;
  ee:	f886 902b 	strb.w	r9, [r6, #43]	; 0x2b
        if (idSz) {
  f2:	f1b9 0f00 	cmp.w	r9, #0
  f6:	f000 8084 	beq.w	202 <SendClientHello+0x202>
            XMEMCPY(output + idx, ssl->session->sessionID,
  fa:	f8d5 10f4 	ldr.w	r1, [r5, #244]	; 0xf4
  fe:	f106 002c 	add.w	r0, r6, #44	; 0x2c
 102:	f891 205c 	ldrb.w	r2, [r1, #92]	; 0x5c
 106:	313c      	adds	r1, #60	; 0x3c
 108:	f7ff fffe 	bl	0 <memcpy>
            idx += ssl->session->sessionIDSz;
 10c:	f8d5 30f4 	ldr.w	r3, [r5, #244]	; 0xf4
 110:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 114:	332c      	adds	r3, #44	; 0x2c
            c16toa(suites->suiteSz, output + idx);
 116:	883a      	ldrh	r2, [r7, #0]
 118:	18f1      	adds	r1, r6, r3
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 11a:	0a10      	lsrs	r0, r2, #8
 11c:	54f0      	strb	r0, [r6, r3]
    c[1] =  (byte)(wc_u16       & 0xff);
 11e:	704a      	strb	r2, [r1, #1]
            XMEMCPY(output + idx, &suites->suites, suites->suiteSz);
 120:	4639      	mov	r1, r7
            idx += OPAQUE16_LEN;
 122:	1c9c      	adds	r4, r3, #2
            XMEMCPY(output + idx, &suites->suites, suites->suiteSz);
 124:	f831 2b04 	ldrh.w	r2, [r1], #4
 128:	1930      	adds	r0, r6, r4
 12a:	f7ff fffe 	bl	0 <memcpy>
            idx += suites->suiteSz;
 12e:	883b      	ldrh	r3, [r7, #0]
 130:	4423      	add	r3, r4
        output[idx++] = COMP_LEN;
 132:	2201      	movs	r2, #1
 134:	54f2      	strb	r2, [r6, r3]
 136:	1899      	adds	r1, r3, r2
        if (ssl->options.usingCompression)
 138:	f895 2273 	ldrb.w	r2, [r5, #627]	; 0x273
 13c:	f012 0201 	ands.w	r2, r2, #1
 140:	f103 0902 	add.w	r9, r3, #2
            output[idx++] = ZLIB_COMPRESSION;
 144:	bf1c      	itt	ne
 146:	23dd      	movne	r3, #221	; 0xdd
 148:	5473      	strbne	r3, [r6, r1]
        extSz = 0;
 14a:	f04f 0300 	mov.w	r3, #0
            output[idx++] = NO_COMPRESSION;
 14e:	bf08      	it	eq
 150:	5472      	strbeq	r2, [r6, r1]
        ret = TLSX_WriteRequest(ssl, output + idx, client_hello, &extSz);
 152:	4628      	mov	r0, r5
        extSz = 0;
 154:	f8ad 301e 	strh.w	r3, [sp, #30]
        ret = TLSX_WriteRequest(ssl, output + idx, client_hello, &extSz);
 158:	2201      	movs	r2, #1
 15a:	f10d 031e 	add.w	r3, sp, #30
 15e:	eb06 0109 	add.w	r1, r6, r9
 162:	f7ff fffe 	bl	0 <TLSX_WriteRequest>
        if (ret != 0)
 166:	4604      	mov	r4, r0
 168:	2800      	cmp	r0, #0
 16a:	f47f af53 	bne.w	14 <SendClientHello+0x14>
        if (IsEncryptionOn(ssl, 1)) {
 16e:	2101      	movs	r1, #1
 170:	4628      	mov	r0, r5
 172:	f7ff fffe 	bl	0 <SendClientHello>
 176:	2800      	cmp	r0, #0
 178:	d045      	beq.n	206 <SendClientHello+0x206>
            if (ssl->options.dtls)
 17a:	f895 3272 	ldrb.w	r3, [r5, #626]	; 0x272
        idx += extSz;
 17e:	f8bd 701e 	ldrh.w	r7, [sp, #30]
                recordHeaderSz += DTLS_RECORD_EXTRA;
 182:	f013 0f04 	tst.w	r3, #4
        idx += extSz;
 186:	444f      	add	r7, r9
                recordHeaderSz += DTLS_RECORD_EXTRA;
 188:	bf0c      	ite	eq
 18a:	f04f 0a05 	moveq.w	sl, #5
 18e:	f04f 0a0d 	movne.w	sl, #13
            inputSz -= recordHeaderSz;
 192:	eba7 070a 	sub.w	r7, r7, sl
            input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 196:	4638      	mov	r0, r7
 198:	f7ff fffe 	bl	0 <malloc>
            if (input == NULL)
 19c:	4681      	mov	r9, r0
 19e:	2800      	cmp	r0, #0
 1a0:	d040      	beq.n	224 <SendClientHello+0x224>
            XMEMCPY(input, output + recordHeaderSz, inputSz);
 1a2:	463a      	mov	r2, r7
 1a4:	eb06 010a 	add.w	r1, r6, sl
 1a8:	f7ff fffe 	bl	0 <memcpy>
            sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
 1ac:	2316      	movs	r3, #22
 1ae:	2201      	movs	r2, #1
 1b0:	e9cd 3201 	strd	r3, r2, [sp, #4]
 1b4:	e9cd 4404 	strd	r4, r4, [sp, #16]
 1b8:	9403      	str	r4, [sp, #12]
 1ba:	464b      	mov	r3, r9
 1bc:	4642      	mov	r2, r8
 1be:	4631      	mov	r1, r6
 1c0:	9700      	str	r7, [sp, #0]
 1c2:	4628      	mov	r0, r5
 1c4:	f7ff fffe 	bl	0 <SendClientHello>
 1c8:	4604      	mov	r4, r0
            XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 1ca:	4648      	mov	r0, r9
 1cc:	f7ff fffe 	bl	0 <free>
            if (sendSz < 0)
 1d0:	2c00      	cmp	r4, #0
 1d2:	f6ff af1f 	blt.w	14 <SendClientHello+0x14>
        ssl->options.clientState = CLIENT_HELLO_COMPLETE;
 1d6:	230c      	movs	r3, #12
        ssl->buffers.outputBuffer.length += sendSz;
 1d8:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
        ssl->options.clientState = CLIENT_HELLO_COMPLETE;
 1dc:	f885 327d 	strb.w	r3, [r5, #637]	; 0x27d
        ssl->options.buildingMsg = 0;
 1e0:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
        ssl->buffers.outputBuffer.length += sendSz;
 1e4:	4420      	add	r0, r4
        ssl->options.buildingMsg = 0;
 1e6:	f36f 03c3 	bfc	r3, #3, #1
        ssl->buffers.outputBuffer.length += sendSz;
 1ea:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
        ssl->options.buildingMsg = 0;
 1ee:	f885 3276 	strb.w	r3, [r5, #630]	; 0x276
        ret = SendBuffered(ssl);
 1f2:	4628      	mov	r0, r5
 1f4:	f7ff fffe 	bl	0 <SendClientHello>
 1f8:	4604      	mov	r4, r0
        return ret;
 1fa:	e70b      	b.n	14 <SendClientHello+0x14>
            sendSz += MAX_MSG_EXTRA;
 1fc:	f10a 086f 	add.w	r8, sl, #111	; 0x6f
 200:	e742      	b.n	88 <SendClientHello+0x88>
        output[idx++] = (byte)idSz;
 202:	232c      	movs	r3, #44	; 0x2c
 204:	e787      	b.n	116 <SendClientHello+0x116>
            ret = HashOutput(ssl, output, sendSz, 0);
 206:	4623      	mov	r3, r4
 208:	4642      	mov	r2, r8
 20a:	4631      	mov	r1, r6
 20c:	4628      	mov	r0, r5
 20e:	f7ff fffe 	bl	0 <SendClientHello>
            if (ret != 0)
 212:	4604      	mov	r4, r0
 214:	2800      	cmp	r0, #0
 216:	f47f aefd 	bne.w	14 <SendClientHello+0x14>
 21a:	4644      	mov	r4, r8
 21c:	e7db      	b.n	1d6 <SendClientHello+0x1d6>
            return SUITES_ERROR;
 21e:	f46f 74b9 	mvn.w	r4, #370	; 0x172
 222:	e6f7      	b.n	14 <SendClientHello+0x14>
                return MEMORY_E;
 224:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 228:	e6f4      	b.n	14 <SendClientHello+0x14>

Disassembly of section .text.DoHelloVerifyRequest:

00000000 <DoHelloVerifyRequest>:
        if (OPAQUE16_LEN + OPAQUE8_LEN > size)
   0:	2b02      	cmp	r3, #2
    {
   2:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
        word32          begin = *inOutIdx;
   6:	6816      	ldr	r6, [r2, #0]
    {
   8:	4607      	mov	r7, r0
   a:	4689      	mov	r9, r1
   c:	4615      	mov	r5, r2
   e:	4698      	mov	r8, r3
        if (OPAQUE16_LEN + OPAQUE8_LEN > size)
  10:	d803      	bhi.n	1a <DoHelloVerifyRequest+0x1a>
            return BUFFER_ERROR;
  12:	4814      	ldr	r0, [pc, #80]	; (64 <DoHelloVerifyRequest+0x64>)
    }
  14:	b003      	add	sp, #12
  16:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        XMEMCPY(&pv, input + *inOutIdx, OPAQUE16_LEN);
  1a:	2202      	movs	r2, #2
  1c:	4431      	add	r1, r6
  1e:	a801      	add	r0, sp, #4
  20:	f7ff fffe 	bl	0 <memcpy>
        *inOutIdx += OPAQUE16_LEN;
  24:	682c      	ldr	r4, [r5, #0]
        if (pv.major != DTLS_MAJOR ||
  26:	f89d 3004 	ldrb.w	r3, [sp, #4]
        *inOutIdx += OPAQUE16_LEN;
  2a:	1ca2      	adds	r2, r4, #2
        if (pv.major != DTLS_MAJOR ||
  2c:	2bfe      	cmp	r3, #254	; 0xfe
        *inOutIdx += OPAQUE16_LEN;
  2e:	602a      	str	r2, [r5, #0]
        if (pv.major != DTLS_MAJOR ||
  30:	d115      	bne.n	5e <DoHelloVerifyRequest+0x5e>
                         (pv.minor != DTLS_MINOR && pv.minor != DTLSv1_2_MINOR))
  32:	f89d 3005 	ldrb.w	r3, [sp, #5]
  36:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
  3a:	2bfd      	cmp	r3, #253	; 0xfd
  3c:	d10f      	bne.n	5e <DoHelloVerifyRequest+0x5e>
        cookieSz = input[(*inOutIdx)++];
  3e:	3403      	adds	r4, #3
  40:	602c      	str	r4, [r5, #0]
  42:	f819 3002 	ldrb.w	r3, [r9, r2]
        if (cookieSz) {
  46:	b12b      	cbz	r3, 54 <DoHelloVerifyRequest+0x54>
            if ((*inOutIdx - begin) + cookieSz > size)
  48:	1ba6      	subs	r6, r4, r6
  4a:	441e      	add	r6, r3
  4c:	4546      	cmp	r6, r8
  4e:	d8e0      	bhi.n	12 <DoHelloVerifyRequest+0x12>
            *inOutIdx += cookieSz;
  50:	441c      	add	r4, r3
  52:	602c      	str	r4, [r5, #0]
        ssl->options.serverState = SERVER_HELLOVERIFYREQUEST_COMPLETE;
  54:	2301      	movs	r3, #1
  56:	f887 327c 	strb.w	r3, [r7, #636]	; 0x27c
        return 0;
  5a:	2000      	movs	r0, #0
  5c:	e7da      	b.n	14 <DoHelloVerifyRequest+0x14>
            return VERSION_ERROR;
  5e:	4802      	ldr	r0, [pc, #8]	; (68 <DoHelloVerifyRequest+0x68>)
  60:	e7d8      	b.n	14 <DoHelloVerifyRequest+0x14>
  62:	bf00      	nop
  64:	fffffeb8 	.word	0xfffffeb8
  68:	fffffeba 	.word	0xfffffeba

Disassembly of section .text.CheckVersion:

00000000 <CheckVersion>:
        if (ssl->options.dtls) {
   0:	f890 3272 	ldrb.w	r3, [r0, #626]	; 0x272
   4:	f013 0304 	ands.w	r3, r3, #4
   8:	b2ca      	uxtb	r2, r1
    {
   a:	b082      	sub	sp, #8
   c:	f3c1 2107 	ubfx	r1, r1, #8, #8
        if (ssl->options.dtls) {
  10:	d053      	beq.n	ba <CheckVersion+0xba>
            if (pv.major != DTLS_MAJOR || pv.minor == DTLS_BOGUS_MINOR) {
  12:	2afe      	cmp	r2, #254	; 0xfe
  14:	d001      	beq.n	1a <CheckVersion+0x1a>
                switch(pv.minor) {
  16:	483f      	ldr	r0, [pc, #252]	; (114 <CheckVersion+0x114>)
  18:	e079      	b.n	10e <CheckVersion+0x10e>
            if (pv.major != DTLS_MAJOR || pv.minor == DTLS_BOGUS_MINOR) {
  1a:	29fe      	cmp	r1, #254	; 0xfe
  1c:	d0fb      	beq.n	16 <CheckVersion+0x16>
            lowerVersion = pv.minor > ssl->version.minor;
  1e:	f890 213d 	ldrb.w	r2, [r0, #317]	; 0x13d
  22:	428a      	cmp	r2, r1
  24:	bf34      	ite	cc
  26:	2201      	movcc	r2, #1
  28:	2200      	movcs	r2, #0
        if (higherVersion) {
  2a:	d8f4      	bhi.n	16 <CheckVersion+0x16>
        if (lowerVersion) {
  2c:	b1a2      	cbz	r2, 58 <CheckVersion+0x58>
            if (!ssl->options.downgrade) {
  2e:	f890 2271 	ldrb.w	r2, [r0, #625]	; 0x271
  32:	0752      	lsls	r2, r2, #29
  34:	d5ef      	bpl.n	16 <CheckVersion+0x16>
            if ((!ssl->options.dtls && pv.minor < ssl->options.minDowngrade) ||
  36:	f890 2280 	ldrb.w	r2, [r0, #640]	; 0x280
  3a:	2b00      	cmp	r3, #0
  3c:	d147      	bne.n	ce <CheckVersion+0xce>
  3e:	428a      	cmp	r2, r1
  40:	d8e9      	bhi.n	16 <CheckVersion+0x16>
                switch(pv.minor) {
  42:	2901      	cmp	r1, #1
                ssl->version.minor = pv.minor;
  44:	f880 113d 	strb.w	r1, [r0, #317]	; 0x13d
                switch(pv.minor) {
  48:	d04e      	beq.n	e8 <CheckVersion+0xe8>
  4a:	d946      	bls.n	da <CheckVersion+0xda>
  4c:	29fd      	cmp	r1, #253	; 0xfd
  4e:	d003      	beq.n	58 <CheckVersion+0x58>
  50:	d840      	bhi.n	d4 <CheckVersion+0xd4>
  52:	3902      	subs	r1, #2
  54:	2901      	cmp	r1, #1
  56:	d8de      	bhi.n	16 <CheckVersion+0x16>
        if (!ssl->options.dtls && ssl->options.downgrade &&
  58:	f8d0 3270 	ldr.w	r3, [r0, #624]	; 0x270
  5c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  60:	f423 037b 	bic.w	r3, r3, #16449536	; 0xfb0000
  64:	f423 437b 	bic.w	r3, r3, #64256	; 0xfb00
  68:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  6c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  70:	d14c      	bne.n	10c <CheckVersion+0x10c>
            ssl->options.mask > 0) {
  72:	f8d0 326c 	ldr.w	r3, [r0, #620]	; 0x26c
        if (!ssl->options.dtls && ssl->options.downgrade &&
  76:	2b00      	cmp	r3, #0
  78:	d048      	beq.n	10c <CheckVersion+0x10c>
            if (ssl->version.minor == TLSv1_2_MINOR &&
  7a:	f890 213d 	ldrb.w	r2, [r0, #317]	; 0x13d
  7e:	2a03      	cmp	r2, #3
  80:	d137      	bne.n	f2 <CheckVersion+0xf2>
  82:	011a      	lsls	r2, r3, #4
  84:	d539      	bpl.n	fa <CheckVersion+0xfa>
                ssl->version.minor = TLSv1_1_MINOR;
  86:	2202      	movs	r2, #2
  88:	f880 213d 	strb.w	r2, [r0, #317]	; 0x13d
            if (ssl->version.minor == TLSv1_1_MINOR &&
  8c:	0159      	lsls	r1, r3, #5
  8e:	d534      	bpl.n	fa <CheckVersion+0xfa>
                ssl->options.tls1_1 = 0;
  90:	f890 2271 	ldrb.w	r2, [r0, #625]	; 0x271
  94:	f36f 12c7 	bfc	r2, #7, #1
  98:	f880 2271 	strb.w	r2, [r0, #625]	; 0x271
                ssl->version.minor = TLSv1_MINOR;
  9c:	2201      	movs	r2, #1
  9e:	f880 213d 	strb.w	r2, [r0, #317]	; 0x13d
            if (ssl->version.minor == TLSv1_MINOR &&
  a2:	049a      	lsls	r2, r3, #18
  a4:	d529      	bpl.n	fa <CheckVersion+0xfa>
                ssl->options.tls    = 0;
  a6:	f890 2271 	ldrb.w	r2, [r0, #625]	; 0x271
  aa:	f002 023f 	and.w	r2, r2, #63	; 0x3f
  ae:	f880 2271 	strb.w	r2, [r0, #625]	; 0x271
                ssl->version.minor = SSLv3_MINOR;
  b2:	2200      	movs	r2, #0
  b4:	f880 213d 	strb.w	r2, [r0, #317]	; 0x13d
  b8:	e01f      	b.n	fa <CheckVersion+0xfa>
            if (pv.major != SSLv3_MAJOR) {
  ba:	2a03      	cmp	r2, #3
  bc:	d1ab      	bne.n	16 <CheckVersion+0x16>
            lowerVersion = pv.minor < ssl->version.minor;
  be:	f890 213d 	ldrb.w	r2, [r0, #317]	; 0x13d
  c2:	428a      	cmp	r2, r1
  c4:	bf8c      	ite	hi
  c6:	2201      	movhi	r2, #1
  c8:	2200      	movls	r2, #0
        if (higherVersion) {
  ca:	d2af      	bcs.n	2c <CheckVersion+0x2c>
  cc:	e7a3      	b.n	16 <CheckVersion+0x16>
                (ssl->options.dtls && pv.minor > ssl->options.minDowngrade)) {
  ce:	428a      	cmp	r2, r1
  d0:	d2b7      	bcs.n	42 <CheckVersion+0x42>
  d2:	e7a0      	b.n	16 <CheckVersion+0x16>
                switch(pv.minor) {
  d4:	29ff      	cmp	r1, #255	; 0xff
  d6:	d0bf      	beq.n	58 <CheckVersion+0x58>
  d8:	e79d      	b.n	16 <CheckVersion+0x16>
                    ssl->options.tls    = 0;
  da:	f890 3271 	ldrb.w	r3, [r0, #625]	; 0x271
  de:	f003 033f 	and.w	r3, r3, #63	; 0x3f
                    ssl->options.tls1_1 = 0;
  e2:	f880 3271 	strb.w	r3, [r0, #625]	; 0x271
                    break;
  e6:	e7b7      	b.n	58 <CheckVersion+0x58>
                    ssl->options.tls1_1 = 0;
  e8:	f890 3271 	ldrb.w	r3, [r0, #625]	; 0x271
  ec:	f36f 13c7 	bfc	r3, #7, #1
  f0:	e7f7      	b.n	e2 <CheckVersion+0xe2>
            if (ssl->version.minor == TLSv1_1_MINOR &&
  f2:	2a02      	cmp	r2, #2
  f4:	d0ca      	beq.n	8c <CheckVersion+0x8c>
            if (ssl->version.minor == TLSv1_MINOR &&
  f6:	2a01      	cmp	r2, #1
  f8:	d0d3      	beq.n	a2 <CheckVersion+0xa2>
            if (ssl->version.minor == SSLv3_MINOR &&
  fa:	f890 213d 	ldrb.w	r2, [r0, #317]	; 0x13d
  fe:	b90a      	cbnz	r2, 104 <CheckVersion+0x104>
 100:	04db      	lsls	r3, r3, #19
 102:	d488      	bmi.n	16 <CheckVersion+0x16>
            if (ssl->version.minor < ssl->options.minDowngrade) {
 104:	f890 3280 	ldrb.w	r3, [r0, #640]	; 0x280
 108:	4293      	cmp	r3, r2
 10a:	d884      	bhi.n	16 <CheckVersion+0x16>
        return 0;
 10c:	2000      	movs	r0, #0
    }
 10e:	b002      	add	sp, #8
 110:	4770      	bx	lr
 112:	bf00      	nop
 114:	fffffeba 	.word	0xfffffeba

Disassembly of section .text.CompleteServerHello:

00000000 <CompleteServerHello>:
        if (!ssl->options.resuming) {
   0:	f890 3271 	ldrb.w	r3, [r0, #625]	; 0x271
   4:	0719      	lsls	r1, r3, #28
    {
   6:	b570      	push	{r4, r5, r6, lr}
   8:	4604      	mov	r4, r0
        if (!ssl->options.resuming) {
   a:	d41d      	bmi.n	48 <CompleteServerHello+0x48>
            if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
   c:	6803      	ldr	r3, [r0, #0]
   e:	681b      	ldr	r3, [r3, #0]
  10:	781a      	ldrb	r2, [r3, #0]
  12:	2a03      	cmp	r2, #3
  14:	d149      	bne.n	aa <CompleteServerHello+0xaa>
  16:	785b      	ldrb	r3, [r3, #1]
  18:	2b03      	cmp	r3, #3
  1a:	d146      	bne.n	aa <CompleteServerHello+0xaa>
            byte* down = ssl->arrays->serverRandom + RAN_LEN -
  1c:	6885      	ldr	r5, [r0, #8]
            byte  vers = ssl->arrays->serverRandom[RAN_LEN - 1];
  1e:	f895 6053 	ldrb.w	r6, [r5, #83]	; 0x53
                (wolfSSL_get_options(ssl) & WOLFSSL_OP_NO_TLSv1_2) == 0) {
  22:	f7ff fffe 	bl	0 <wolfSSL_get_options>
                ssl->ctx->method->version.minor == TLSv1_2_MINOR &&
  26:	0102      	lsls	r2, r0, #4
  28:	d43f      	bmi.n	aa <CompleteServerHello+0xaa>
                if (XMEMCMP(down, tls13Downgrade, TLS13_DOWNGRADE_SZ) == 0 &&
  2a:	4925      	ldr	r1, [pc, #148]	; (c0 <CompleteServerHello+0xc0>)
  2c:	2207      	movs	r2, #7
  2e:	f105 004c 	add.w	r0, r5, #76	; 0x4c
  32:	f7ff fffe 	bl	0 <memcmp>
  36:	bbc0      	cbnz	r0, aa <CompleteServerHello+0xaa>
  38:	bbbe      	cbnz	r6, aa <CompleteServerHello+0xaa>
                    SendAlert(ssl, alert_fatal, illegal_parameter);
  3a:	222f      	movs	r2, #47	; 0x2f
  3c:	2102      	movs	r1, #2
  3e:	4620      	mov	r0, r4
  40:	f7ff fffe 	bl	0 <CompleteServerHello>
                    return VERSION_ERROR;
  44:	481f      	ldr	r0, [pc, #124]	; (c4 <CompleteServerHello+0xc4>)
    }
  46:	bd70      	pop	{r4, r5, r6, pc}
        ret = ret ||
  48:	069b      	lsls	r3, r3, #26
  4a:	d528      	bpl.n	9e <CompleteServerHello+0x9e>
              (ssl->options.haveSessionId && XMEMCMP(ssl->arrays->sessionID,
  4c:	f8d0 10f4 	ldr.w	r1, [r0, #244]	; 0xf4
  50:	6880      	ldr	r0, [r0, #8]
  52:	2220      	movs	r2, #32
  54:	313c      	adds	r1, #60	; 0x3c
  56:	3054      	adds	r0, #84	; 0x54
  58:	f7ff fffe 	bl	0 <memcmp>
  5c:	b9f8      	cbnz	r0, 9e <CompleteServerHello+0x9e>
                if (SetCipherSpecs(ssl) == 0) {
  5e:	4620      	mov	r0, r4
  60:	f7ff fffe 	bl	0 <SetCipherSpecs>
  64:	bb30      	cbnz	r0, b4 <CompleteServerHello+0xb4>
                    if (!HaveUniqueSessionObj(ssl)) {
  66:	4620      	mov	r0, r4
  68:	f7ff fffe 	bl	0 <CompleteServerHello>
  6c:	b320      	cbz	r0, b8 <CompleteServerHello+0xb8>
                    XMEMCPY(ssl->arrays->masterSecret,
  6e:	f8d4 10f4 	ldr.w	r1, [r4, #244]	; 0xf4
  72:	68a0      	ldr	r0, [r4, #8]
  74:	2230      	movs	r2, #48	; 0x30
  76:	315d      	adds	r1, #93	; 0x5d
  78:	3075      	adds	r0, #117	; 0x75
  7a:	f7ff fffe 	bl	0 <memcpy>
                    ret = DeriveTlsKeys(ssl);
  7e:	4620      	mov	r0, r4
  80:	f7ff fffe 	bl	0 <DeriveTlsKeys>
                    ssl->options.peerAuthGood = (ret == 0);
  84:	f894 2276 	ldrb.w	r2, [r4, #630]	; 0x276
  88:	fab0 f380 	clz	r3, r0
  8c:	095b      	lsrs	r3, r3, #5
  8e:	f363 0241 	bfi	r2, r3, #1, #1
                    ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
  92:	2308      	movs	r3, #8
                    ssl->options.peerAuthGood = (ret == 0);
  94:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
                    ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
  98:	f884 327c 	strb.w	r3, [r4, #636]	; 0x27c
                    return ret;
  9c:	e7d3      	b.n	46 <CompleteServerHello+0x46>
                ssl->options.resuming = 0; /* server denied resumption try */
  9e:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  a2:	f36f 03c3 	bfc	r3, #3, #1
  a6:	f884 3271 	strb.w	r3, [r4, #625]	; 0x271
        return SetCipherSpecs(ssl);
  aa:	4620      	mov	r0, r4
    }
  ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return SetCipherSpecs(ssl);
  b0:	f7ff bffe 	b.w	0 <SetCipherSpecs>
                    return UNSUPPORTED_SUITE;
  b4:	4804      	ldr	r0, [pc, #16]	; (c8 <CompleteServerHello+0xc8>)
  b6:	e7c6      	b.n	46 <CompleteServerHello+0x46>
                        return MEMORY_ERROR;
  b8:	f46f 7097 	mvn.w	r0, #302	; 0x12e
  bc:	e7c3      	b.n	46 <CompleteServerHello+0x46>
  be:	bf00      	nop
  c0:	00000000 	.word	0x00000000
  c4:	fffffeba 	.word	0xfffffeba
  c8:	fffffe0c 	.word	0xfffffe0c

Disassembly of section .text.DoServerHello:

00000000 <DoServerHello>:
    {
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
   4:	2b22      	cmp	r3, #34	; 0x22
        word32          i = *inOutIdx;
   6:	6817      	ldr	r7, [r2, #0]
    {
   8:	b085      	sub	sp, #20
   a:	4604      	mov	r4, r0
   c:	4688      	mov	r8, r1
   e:	4692      	mov	sl, r2
  10:	4699      	mov	r9, r3
        if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
  12:	d801      	bhi.n	18 <DoServerHello+0x18>
                    return BUFFER_ERROR;
  14:	4d65      	ldr	r5, [pc, #404]	; (1ac <DoServerHello+0x1ac>)
  16:	e011      	b.n	3c <DoServerHello+0x3c>
        XMEMCPY(&pv, input + i, OPAQUE16_LEN);
  18:	eb01 0b07 	add.w	fp, r1, r7
  1c:	2202      	movs	r2, #2
  1e:	4659      	mov	r1, fp
  20:	a803      	add	r0, sp, #12
  22:	f7ff fffe 	bl	0 <memcpy>
        ret = CheckVersion(ssl, pv);
  26:	9903      	ldr	r1, [sp, #12]
  28:	4620      	mov	r0, r4
  2a:	f7ff fffe 	bl	0 <DoServerHello>
        if (ret != 0) {
  2e:	4605      	mov	r5, r0
  30:	b140      	cbz	r0, 44 <DoServerHello+0x44>
            SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);
  32:	2246      	movs	r2, #70	; 0x46
  34:	2102      	movs	r1, #2
  36:	4620      	mov	r0, r4
  38:	f7ff fffe 	bl	0 <DoServerHello>
    }
  3c:	4628      	mov	r0, r5
  3e:	b005      	add	sp, #20
  40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        XMEMCPY(ssl->arrays->serverRandom, input + i, RAN_LEN);
  44:	68a0      	ldr	r0, [r4, #8]
        i += OPAQUE16_LEN;
  46:	1cb9      	adds	r1, r7, #2
        XMEMCPY(ssl->arrays->serverRandom, input + i, RAN_LEN);
  48:	2220      	movs	r2, #32
  4a:	4441      	add	r1, r8
  4c:	3034      	adds	r0, #52	; 0x34
  4e:	f7ff fffe 	bl	0 <memcpy>
        ssl->arrays->sessionIDSz = input[i++];
  52:	f89b 2022 	ldrb.w	r2, [fp, #34]	; 0x22
  56:	68a0      	ldr	r0, [r4, #8]
        if (ssl->arrays->sessionIDSz > ID_LEN) {
  58:	2a20      	cmp	r2, #32
        ssl->arrays->sessionIDSz = input[i++];
  5a:	f107 0623 	add.w	r6, r7, #35	; 0x23
  5e:	f880 2074 	strb.w	r2, [r0, #116]	; 0x74
        if (ssl->arrays->sessionIDSz > ID_LEN) {
  62:	d902      	bls.n	6a <DoServerHello+0x6a>
            ssl->arrays->sessionIDSz = 0;
  64:	f880 5074 	strb.w	r5, [r0, #116]	; 0x74
            return BUFFER_ERROR;
  68:	e7d4      	b.n	14 <DoServerHello+0x14>
        else if (ssl->arrays->sessionIDSz) {
  6a:	b192      	cbz	r2, 92 <DoServerHello+0x92>
            if ((i - begin) + ssl->arrays->sessionIDSz > helloSz)
  6c:	f102 0323 	add.w	r3, r2, #35	; 0x23
  70:	454b      	cmp	r3, r9
  72:	d8cf      	bhi.n	14 <DoServerHello+0x14>
            XMEMCPY(ssl->arrays->sessionID, input + i,
  74:	eb08 0106 	add.w	r1, r8, r6
  78:	3054      	adds	r0, #84	; 0x54
  7a:	f7ff fffe 	bl	0 <memcpy>
            i += ssl->arrays->sessionIDSz;
  7e:	68a3      	ldr	r3, [r4, #8]
  80:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
  84:	441e      	add	r6, r3
            ssl->options.haveSessionId = 1;
  86:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  8a:	f043 0320 	orr.w	r3, r3, #32
  8e:	f884 3271 	strb.w	r3, [r4, #625]	; 0x271
        if ((i - begin) + OPAQUE16_LEN + OPAQUE8_LEN > helloSz)
  92:	f1c7 0303 	rsb	r3, r7, #3
  96:	4433      	add	r3, r6
  98:	454b      	cmp	r3, r9
  9a:	d8bb      	bhi.n	14 <DoServerHello+0x14>
        cs1 = input[i++];
  9c:	eb08 0306 	add.w	r3, r8, r6
        cs0 = input[i++];
  a0:	f818 0006 	ldrb.w	r0, [r8, r6]
        cs1 = input[i++];
  a4:	7859      	ldrb	r1, [r3, #1]
            const Suites* suites = WOLFSSL_SUITES(ssl);
  a6:	6863      	ldr	r3, [r4, #4]
        cs1 = input[i++];
  a8:	1cb5      	adds	r5, r6, #2
            const Suites* suites = WOLFSSL_SUITES(ssl);
  aa:	b90b      	cbnz	r3, b0 <DoServerHello+0xb0>
  ac:	6823      	ldr	r3, [r4, #0]
  ae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
            for (idx = 0; idx < suites->suiteSz; idx += 2) {
  b0:	f8b3 e000 	ldrh.w	lr, [r3]
  b4:	461a      	mov	r2, r3
  b6:	eba2 0c03 	sub.w	ip, r2, r3
  ba:	45e6      	cmp	lr, ip
  bc:	d802      	bhi.n	c4 <DoServerHello+0xc4>
                return MATCH_SUITE_ERROR;
  be:	f46f 75fa 	mvn.w	r5, #500	; 0x1f4
  c2:	e7bb      	b.n	3c <DoServerHello+0x3c>
                if (suites->suites[idx]   == cs0 &&
  c4:	f892 c004 	ldrb.w	ip, [r2, #4]
  c8:	4584      	cmp	ip, r0
  ca:	d103      	bne.n	d4 <DoServerHello+0xd4>
  cc:	f892 c005 	ldrb.w	ip, [r2, #5]
  d0:	458c      	cmp	ip, r1
  d2:	d018      	beq.n	106 <DoServerHello+0x106>
            for (idx = 0; idx < suites->suiteSz; idx += 2) {
  d4:	3202      	adds	r2, #2
  d6:	e7ee      	b.n	b6 <DoServerHello+0xb6>
        if (compression != NO_COMPRESSION && !ssl->options.usingCompression) {
  d8:	b19b      	cbz	r3, 102 <DoServerHello+0x102>
        if (compression != ZLIB_COMPRESSION && ssl->options.usingCompression) {
  da:	2add      	cmp	r2, #221	; 0xdd
  dc:	d023      	beq.n	126 <DoServerHello+0x126>
            ssl->options.usingCompression = 0;  /* turn off if server refused */
  de:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
  e2:	f36f 0300 	bfc	r3, #0, #1
  e6:	f884 3273 	strb.w	r3, [r4, #627]	; 0x273
  ea:	e01c      	b.n	126 <DoServerHello+0x126>
                *inOutIdx = begin + helloSz; /* skip extensions */
  ec:	444f      	add	r7, r9
  ee:	f8ca 7000 	str.w	r7, [sl]
  f2:	e046      	b.n	182 <DoServerHello+0x182>
            ssl->options.haveEMS = 0; /* If no extensions, no EMS */
  f4:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
  f8:	f36f 03c3 	bfc	r3, #3, #1
  fc:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
 100:	e03f      	b.n	182 <DoServerHello+0x182>
            return COMPRESSION_ERROR;
 102:	4d2b      	ldr	r5, [pc, #172]	; (1b0 <DoServerHello+0x1b0>)
 104:	e79a      	b.n	3c <DoServerHello+0x3c>
        ssl->options.cipherSuite0 = cs0;
 106:	f884 0278 	strb.w	r0, [r4, #632]	; 0x278
        ssl->options.cipherSuite  = cs1;
 10a:	f884 1279 	strb.w	r1, [r4, #633]	; 0x279
        if (compression != NO_COMPRESSION && !ssl->options.usingCompression) {
 10e:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
        compression = input[i++];
 112:	f818 2005 	ldrb.w	r2, [r8, r5]
 116:	f106 0b03 	add.w	fp, r6, #3
        if (compression != NO_COMPRESSION && !ssl->options.usingCompression) {
 11a:	f003 0301 	and.w	r3, r3, #1
 11e:	2a00      	cmp	r2, #0
 120:	d1da      	bne.n	d8 <DoServerHello+0xd8>
        if (compression != ZLIB_COMPRESSION && ssl->options.usingCompression) {
 122:	2b00      	cmp	r3, #0
 124:	d1db      	bne.n	de <DoServerHello+0xde>
        if ( (i - begin) < helloSz) {
 126:	ebab 0507 	sub.w	r5, fp, r7
 12a:	454d      	cmp	r5, r9
        *inOutIdx = i;
 12c:	f8ca b000 	str.w	fp, [sl]
        if ( (i - begin) < helloSz) {
 130:	d2e0      	bcs.n	f4 <DoServerHello+0xf4>
            if (TLSX_SupportExtensions(ssl)) {
 132:	4620      	mov	r0, r4
 134:	f7ff fffe 	bl	0 <TLSX_SupportExtensions>
 138:	2800      	cmp	r0, #0
 13a:	d0d7      	beq.n	ec <DoServerHello+0xec>
                if ((i - begin) + OPAQUE16_LEN > helloSz)
 13c:	3502      	adds	r5, #2
 13e:	454d      	cmp	r5, r9
 140:	f63f af68 	bhi.w	14 <DoServerHello+0x14>
                ato16(&input[i], &totalExtSz);
 144:	f10d 010e 	add.w	r1, sp, #14
 148:	eb08 000b 	add.w	r0, r8, fp
 14c:	f7ff fffe 	bl	0 <DoServerHello>
                if ((i - begin) + totalExtSz > helloSz)
 150:	f8bd 200e 	ldrh.w	r2, [sp, #14]
                i += OPAQUE16_LEN;
 154:	3605      	adds	r6, #5
                if ((i - begin) + totalExtSz > helloSz)
 156:	1bd7      	subs	r7, r2, r7
 158:	4437      	add	r7, r6
 15a:	454f      	cmp	r7, r9
 15c:	f63f af5a 	bhi.w	14 <DoServerHello+0x14>
                if ((ret = TLSX_Parse(ssl, (byte *) input + i, totalExtSz,
 160:	2300      	movs	r3, #0
 162:	9300      	str	r3, [sp, #0]
 164:	eb08 0106 	add.w	r1, r8, r6
 168:	2302      	movs	r3, #2
 16a:	4620      	mov	r0, r4
 16c:	f7ff fffe 	bl	0 <TLSX_Parse>
 170:	4605      	mov	r5, r0
 172:	2800      	cmp	r0, #0
 174:	f47f af62 	bne.w	3c <DoServerHello+0x3c>
                i += totalExtSz;
 178:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 17c:	441e      	add	r6, r3
                *inOutIdx = i;
 17e:	f8ca 6000 	str.w	r6, [sl]
        ssl->options.serverState = SERVER_HELLO_COMPLETE;
 182:	2303      	movs	r3, #3
 184:	f884 327c 	strb.w	r3, [r4, #636]	; 0x27c
        if (IsEncryptionOn(ssl, 0)) {
 188:	2100      	movs	r1, #0
 18a:	4620      	mov	r0, r4
 18c:	f7ff fffe 	bl	0 <DoServerHello>
 190:	b130      	cbz	r0, 1a0 <DoServerHello+0x1a0>
            *inOutIdx += ssl->keys.padSz;
 192:	f8da 3000 	ldr.w	r3, [sl]
 196:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 19a:	4413      	add	r3, r2
 19c:	f8ca 3000 	str.w	r3, [sl]
        ret = CompleteServerHello(ssl);
 1a0:	4620      	mov	r0, r4
 1a2:	f7ff fffe 	bl	0 <DoServerHello>
 1a6:	4605      	mov	r5, r0
        return ret;
 1a8:	e748      	b.n	3c <DoServerHello+0x3c>
 1aa:	bf00      	nop
 1ac:	fffffeb8 	.word	0xfffffeb8
 1b0:	fffffe0a 	.word	0xfffffe0a

Disassembly of section .text.VerifyClientSuite:

00000000 <VerifyClientSuite>:
    {
   0:	b508      	push	{r3, lr}
   2:	4608      	mov	r0, r1
   4:	4611      	mov	r1, r2
        if (CipherRequires(cipherSuite0, cipherSuite, REQUIRES_PSK)) {
   6:	2204      	movs	r2, #4
   8:	f7ff fffe 	bl	0 <VerifyClientSuite>
    }
   c:	fab0 f080 	clz	r0, r0
  10:	0940      	lsrs	r0, r0, #5
  12:	bd08      	pop	{r3, pc}

Disassembly of section .text.SendClientKeyExchange:

00000000 <SendClientKeyExchange>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if (ssl->async == NULL) {
   4:	6b85      	ldr	r5, [r0, #56]	; 0x38
{
   6:	b086      	sub	sp, #24
   8:	4604      	mov	r4, r0
    if (ssl->async == NULL) {
   a:	b9d5      	cbnz	r5, 42 <SendClientKeyExchange+0x42>
                XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,
   c:	204c      	movs	r0, #76	; 0x4c
   e:	f7ff fffe 	bl	0 <malloc>
        ssl->async = (struct WOLFSSL_ASYNC*)
  12:	63a0      	str	r0, [r4, #56]	; 0x38
        if (ssl->async == NULL)
  14:	b988      	cbnz	r0, 3a <SendClientKeyExchange+0x3a>
            ERROR_OUT(MEMORY_E, exit_scke);
  16:	f06f 057c 	mvn.w	r5, #124	; 0x7c
    if (ssl->arrays->preMasterSecret != NULL) {
  1a:	68a3      	ldr	r3, [r4, #8]
  1c:	6858      	ldr	r0, [r3, #4]
  1e:	b110      	cbz	r0, 26 <SendClientKeyExchange+0x26>
        ForceZero(ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz);
  20:	6899      	ldr	r1, [r3, #8]
  22:	f7ff fffe 	bl	0 <SendClientKeyExchange>
    ssl->arrays->preMasterSz = 0;
  26:	68a3      	ldr	r3, [r4, #8]
  28:	2100      	movs	r1, #0
    FreeAsyncCtx(ssl, 0);
  2a:	4620      	mov	r0, r4
    ssl->arrays->preMasterSz = 0;
  2c:	6099      	str	r1, [r3, #8]
    FreeAsyncCtx(ssl, 0);
  2e:	f7ff fffe 	bl	0 <SendClientKeyExchange>
    FreeKeyExchange(ssl);
  32:	4620      	mov	r0, r4
  34:	f7ff fffe 	bl	0 <SendClientKeyExchange>
    return ret;
  38:	e1e0      	b.n	3fc <SendClientKeyExchange+0x3fc>
        XMEMSET(ssl->async, 0, sizeof(struct WOLFSSL_ASYNC));
  3a:	224c      	movs	r2, #76	; 0x4c
  3c:	4629      	mov	r1, r5
  3e:	f7ff fffe 	bl	0 <memset>
    if (ssl->options.buildingMsg) {
  42:	f894 1276 	ldrb.w	r1, [r4, #630]	; 0x276
    args = (SckeArgs*)ssl->async->args;
  46:	6ba6      	ldr	r6, [r4, #56]	; 0x38
    if (ssl->options.buildingMsg) {
  48:	f011 0108 	ands.w	r1, r1, #8
  4c:	d10e      	bne.n	6c <SendClientKeyExchange+0x6c>
        XMEMSET(args, 0, sizeof(SckeArgs));
  4e:	221c      	movs	r2, #28
        ssl->options.asyncState = TLS_ASYNC_BEGIN;
  50:	f884 1283 	strb.w	r1, [r4, #643]	; 0x283
        XMEMSET(args, 0, sizeof(SckeArgs));
  54:	1d30      	adds	r0, r6, #4
  56:	f7ff fffe 	bl	0 <memset>
        ssl->options.buildingMsg = 1;
  5a:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
        ssl->async->freeArgs = FreeSckeArgs;
  5e:	4a6d      	ldr	r2, [pc, #436]	; (214 <SendClientKeyExchange+0x214>)
        ssl->options.buildingMsg = 1;
  60:	f043 0308 	orr.w	r3, r3, #8
  64:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
        ssl->async->freeArgs = FreeSckeArgs;
  68:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  6a:	601a      	str	r2, [r3, #0]
    switch(ssl->options.asyncState)
  6c:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
  70:	2b05      	cmp	r3, #5
  72:	f200 80c8 	bhi.w	206 <SendClientKeyExchange+0x206>
  76:	e8df f013 	tbh	[pc, r3, lsl #1]
  7a:	0006      	.short	0x0006
  7c:	00d80032 	.word	0x00d80032
  80:	010d00fd 	.word	0x010d00fd
  84:	0167      	.short	0x0167
            switch (ssl->specs.kea) {
  86:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
  8a:	2b07      	cmp	r3, #7
  8c:	d001      	beq.n	92 <SendClientKeyExchange+0x92>
                            ERROR_OUT(NO_PEER_KEY, exit_scke);
  8e:	4d62      	ldr	r5, [pc, #392]	; (218 <SendClientKeyExchange+0x218>)
  90:	e7c3      	b.n	1a <SendClientKeyExchange+0x1a>
                    if (ssl->peerX25519KeyPresent) {
  92:	f894 32b8 	ldrb.w	r3, [r4, #696]	; 0x2b8
  96:	2b00      	cmp	r3, #0
  98:	d053      	beq.n	142 <SendClientKeyExchange+0x142>
                        if (!ssl->peerX25519Key || !ssl->peerX25519Key->dp) {
  9a:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
  9e:	2b00      	cmp	r3, #0
  a0:	d05a      	beq.n	158 <SendClientKeyExchange+0x158>
  a2:	685b      	ldr	r3, [r3, #4]
  a4:	2b00      	cmp	r3, #0
  a6:	d057      	beq.n	158 <SendClientKeyExchange+0x158>
                        ssl->hsType = DYNAMIC_TYPE_CURVE25519;
  a8:	2145      	movs	r1, #69	; 0x45
  aa:	6421      	str	r1, [r4, #64]	; 0x40
                        ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
  ac:	f104 023c 	add.w	r2, r4, #60	; 0x3c
  b0:	4620      	mov	r0, r4
  b2:	f7ff fffe 	bl	0 <SendClientKeyExchange>
                        if (ret != 0) {
  b6:	4605      	mov	r5, r0
  b8:	2800      	cmp	r0, #0
  ba:	f040 8194 	bne.w	3e6 <SendClientKeyExchange+0x3e6>
        ret = wc_curve25519_make_key(ssl->rng, CURVE25519_KEYSIZE, key);
  be:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  c0:	69a0      	ldr	r0, [r4, #24]
  c2:	2120      	movs	r1, #32
  c4:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret == 0) {
  c8:	4605      	mov	r5, r0
  ca:	2800      	cmp	r0, #0
  cc:	f040 818b 	bne.w	3e6 <SendClientKeyExchange+0x3e6>
        ssl->ecdhCurveOID = ECC_X25519_OID;
  d0:	f240 136d 	movw	r3, #365	; 0x16d
  d4:	f8c4 3290 	str.w	r3, [r4, #656]	; 0x290
            ssl->options.asyncState = TLS_ASYNC_BUILD;
  d8:	2301      	movs	r3, #1
  da:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            args->encSz = MAX_ENCRYPT_SZ;
  de:	258b      	movs	r5, #139	; 0x8b
  e0:	6135      	str	r5, [r6, #16]
            args->encSecret = (byte*)XMALLOC(MAX_ENCRYPT_SZ, ssl->heap,
  e2:	4628      	mov	r0, r5
  e4:	f7ff fffe 	bl	0 <malloc>
  e8:	60b0      	str	r0, [r6, #8]
            if (args->encSecret == NULL) {
  ea:	2800      	cmp	r0, #0
  ec:	d093      	beq.n	16 <SendClientKeyExchange+0x16>
            if (ssl->arrays->preMasterSecret == NULL) {
  ee:	68a7      	ldr	r7, [r4, #8]
  f0:	f8d7 8004 	ldr.w	r8, [r7, #4]
  f4:	f1b8 0f00 	cmp.w	r8, #0
  f8:	d10c      	bne.n	114 <SendClientKeyExchange+0x114>
                ssl->arrays->preMasterSz = ENCRYPT_LEN;
  fa:	60bd      	str	r5, [r7, #8]
                ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
  fc:	4628      	mov	r0, r5
  fe:	f7ff fffe 	bl	0 <malloc>
                if (ssl->arrays->preMasterSecret == NULL) {
 102:	68a3      	ldr	r3, [r4, #8]
                ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
 104:	6078      	str	r0, [r7, #4]
                if (ssl->arrays->preMasterSecret == NULL) {
 106:	6858      	ldr	r0, [r3, #4]
 108:	2800      	cmp	r0, #0
 10a:	d084      	beq.n	16 <SendClientKeyExchange+0x16>
                XMEMSET(ssl->arrays->preMasterSecret, 0, ENCRYPT_LEN);
 10c:	462a      	mov	r2, r5
 10e:	4641      	mov	r1, r8
 110:	f7ff fffe 	bl	0 <memset>
            switch(ssl->specs.kea)
 114:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 118:	2b07      	cmp	r3, #7
 11a:	d1b8      	bne.n	8e <SendClientKeyExchange+0x8e>
                    ssl->arrays->preMasterSz = ENCRYPT_LEN;
 11c:	68a3      	ldr	r3, [r4, #8]
                        ret = wc_curve25519_export_public_ex(
 11e:	68b1      	ldr	r1, [r6, #8]
                                (curve25519_key*)ssl->hsKey,
 120:	6be0      	ldr	r0, [r4, #60]	; 0x3c
                    ssl->arrays->preMasterSz = ENCRYPT_LEN;
 122:	228b      	movs	r2, #139	; 0x8b
 124:	609a      	str	r2, [r3, #8]
                    if (ssl->hsType == DYNAMIC_TYPE_CURVE25519) {
 126:	6c23      	ldr	r3, [r4, #64]	; 0x40
 128:	2b45      	cmp	r3, #69	; 0x45
                        ret = wc_curve25519_export_public_ex(
 12a:	f101 0101 	add.w	r1, r1, #1
 12e:	f106 0210 	add.w	r2, r6, #16
                    if (ssl->hsType == DYNAMIC_TYPE_CURVE25519) {
 132:	d11a      	bne.n	16a <SendClientKeyExchange+0x16a>
                        ret = wc_curve25519_export_public_ex(
 134:	2300      	movs	r3, #0
 136:	f7ff fffe 	bl	0 <wc_curve25519_export_public_ex>
                        if (ret != 0) {
 13a:	2800      	cmp	r0, #0
 13c:	d072      	beq.n	224 <SendClientKeyExchange+0x224>
                            ERROR_OUT(ECC_EXPORT_ERROR, exit_scke);
 13e:	4d37      	ldr	r5, [pc, #220]	; (21c <SendClientKeyExchange+0x21c>)
 140:	e76b      	b.n	1a <SendClientKeyExchange+0x1a>
                    if (ssl->specs.static_ecdh) {
 142:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
 146:	b14b      	cbz	r3, 15c <SendClientKeyExchange+0x15c>
                        if (!ssl->peerEccDsaKey || !ssl->peerEccDsaKeyPresent) {
 148:	f8d4 72a0 	ldr.w	r7, [r4, #672]	; 0x2a0
 14c:	b127      	cbz	r7, 158 <SendClientKeyExchange+0x158>
 14e:	f894 32a6 	ldrb.w	r3, [r4, #678]	; 0x2a6
                        if (!ssl->peerEccKey || !ssl->peerEccKeyPresent) {
 152:	2b00      	cmp	r3, #0
 154:	f040 8135 	bne.w	3c2 <SendClientKeyExchange+0x3c2>
                            ERROR_OUT(NO_PEER_KEY, exit_scke);
 158:	4d31      	ldr	r5, [pc, #196]	; (220 <SendClientKeyExchange+0x220>)
 15a:	e75e      	b.n	1a <SendClientKeyExchange+0x1a>
                        if (!ssl->peerEccKey || !ssl->peerEccKeyPresent) {
 15c:	f8d4 729c 	ldr.w	r7, [r4, #668]	; 0x29c
 160:	2f00      	cmp	r7, #0
 162:	d0f9      	beq.n	158 <SendClientKeyExchange+0x158>
 164:	f894 3299 	ldrb.w	r3, [r4, #665]	; 0x299
 168:	e7f3      	b.n	152 <SendClientKeyExchange+0x152>
                    ret = wc_ecc_export_x963((ecc_key*)ssl->hsKey,
 16a:	f7ff fffe 	bl	0 <wc_ecc_export_x963>
 16e:	e7e4      	b.n	13a <SendClientKeyExchange+0x13a>
                    ret = EccSharedSecret(ssl,
 170:	68b1      	ldr	r1, [r6, #8]
 172:	9201      	str	r2, [sp, #4]
 174:	2501      	movs	r5, #1
 176:	e9cd 3502 	strd	r3, r5, [sp, #8]
 17a:	f106 0310 	add.w	r3, r6, #16
 17e:	9300      	str	r3, [sp, #0]
 180:	194b      	adds	r3, r1, r5
 182:	e9d4 12a7 	ldrd	r1, r2, [r4, #668]	; 0x29c
                              ssl->peerEccDsaKey : ssl->peerEccKey;
 186:	f894 714f 	ldrb.w	r7, [r4, #335]	; 0x14f
                    ret = EccSharedSecret(ssl,
 18a:	2f00      	cmp	r7, #0
 18c:	bf08      	it	eq
 18e:	460a      	moveq	r2, r1
 190:	4601      	mov	r1, r0
 192:	4620      	mov	r0, r4
 194:	f7ff fffe 	bl	0 <SendClientKeyExchange>
                    if (!ssl->specs.static_ecdh
 198:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
                    ret = EccSharedSecret(ssl,
 19c:	4605      	mov	r5, r0
                    if (!ssl->specs.static_ecdh
 19e:	2b00      	cmp	r3, #0
 1a0:	d162      	bne.n	268 <SendClientKeyExchange+0x268>
                     && !ssl->options.keepResources) {
 1a2:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
 1a6:	f013 0740 	ands.w	r7, r3, #64	; 0x40
 1aa:	d15d      	bne.n	268 <SendClientKeyExchange+0x268>
                        FreeKey(ssl, DYNAMIC_TYPE_ECC,
 1ac:	f504 7227 	add.w	r2, r4, #668	; 0x29c
 1b0:	2125      	movs	r1, #37	; 0x25
 1b2:	4620      	mov	r0, r4
 1b4:	f7ff fffe 	bl	0 <SendClientKeyExchange>
                        ssl->peerEccKeyPresent = 0;
 1b8:	f884 7299 	strb.w	r7, [r4, #665]	; 0x299
 1bc:	e054      	b.n	268 <SendClientKeyExchange+0x268>
                tlsSz = 2;
 1be:	2702      	movs	r7, #2
 1c0:	e072      	b.n	2a8 <SendClientKeyExchange+0x2a8>
            idx = HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 1c2:	2509      	movs	r5, #9
 1c4:	e09c      	b.n	300 <SendClientKeyExchange+0x300>
                ret = HashOutput(ssl, args->output, args->sendSz, 0);
 1c6:	4629      	mov	r1, r5
 1c8:	4620      	mov	r0, r4
 1ca:	f7ff fffe 	bl	0 <SendClientKeyExchange>
            if (ret != 0) {
 1ce:	4605      	mov	r5, r0
 1d0:	2800      	cmp	r0, #0
 1d2:	f000 80da 	beq.w	38a <SendClientKeyExchange+0x38a>
 1d6:	e106      	b.n	3e6 <SendClientKeyExchange+0x3e6>
                ret = SendBuffered(ssl);
 1d8:	4620      	mov	r0, r4
 1da:	f7ff fffe 	bl	0 <SendClientKeyExchange>
            if (ret == 0 || ret == WANT_WRITE) {
 1de:	4605      	mov	r5, r0
 1e0:	2800      	cmp	r0, #0
 1e2:	f000 80dd 	beq.w	3a0 <SendClientKeyExchange+0x3a0>
 1e6:	f46f 73a3 	mvn.w	r3, #326	; 0x146
 1ea:	4298      	cmp	r0, r3
 1ec:	f000 80d9 	beq.w	3a2 <SendClientKeyExchange+0x3a2>
    if (ret == WC_PENDING_E || ret == WANT_WRITE) {
 1f0:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
 1f4:	f000 80fb 	beq.w	3ee <SendClientKeyExchange+0x3ee>
 1f8:	e70f      	b.n	1a <SendClientKeyExchange+0x1a>
 1fa:	f46f 73a3 	mvn.w	r3, #326	; 0x146
 1fe:	429d      	cmp	r5, r3
 200:	f000 80f7 	beq.w	3f2 <SendClientKeyExchange+0x3f2>
 204:	e709      	b.n	1a <SendClientKeyExchange+0x1a>
    switch(ssl->options.asyncState)
 206:	f46f 7596 	mvn.w	r5, #300	; 0x12c
 20a:	e706      	b.n	1a <SendClientKeyExchange+0x1a>
                        ret = BAD_STATE_E;
 20c:	f06f 05bf 	mvn.w	r5, #191	; 0xbf
 210:	e703      	b.n	1a <SendClientKeyExchange+0x1a>
 212:	bf00      	nop
 214:	00000000 	.word	0x00000000
 218:	fffffe8a 	.word	0xfffffe8a
 21c:	fffffe9e 	.word	0xfffffe9e
 220:	fffffec4 	.word	0xfffffec4
            ssl->options.asyncState = TLS_ASYNC_DO;
 224:	2302      	movs	r3, #2
 226:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            switch(ssl->specs.kea)
 22a:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 22e:	2b07      	cmp	r3, #7
 230:	f47f af2d 	bne.w	8e <SendClientKeyExchange+0x8e>
                            ssl->arrays->preMasterSecret,
 234:	68a3      	ldr	r3, [r4, #8]
                    if (ssl->peerX25519KeyPresent) {
 236:	f894 12b8 	ldrb.w	r1, [r4, #696]	; 0x2b8
                        ret = X25519SharedSecret(ssl,
 23a:	685a      	ldr	r2, [r3, #4]
                            (curve25519_key*)ssl->hsKey, ssl->peerX25519Key,
 23c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
                        ret = X25519SharedSecret(ssl,
 23e:	3308      	adds	r3, #8
                    if (ssl->peerX25519KeyPresent) {
 240:	2900      	cmp	r1, #0
 242:	d095      	beq.n	170 <SendClientKeyExchange+0x170>
        ret = wc_curve25519_shared_secret_ex(priv_key, pub_key, out, outlen,
 244:	2100      	movs	r1, #0
 246:	9100      	str	r1, [sp, #0]
 248:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
 24c:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret_ex>
                        if (!ssl->specs.static_ecdh
 250:	f894 714f 	ldrb.w	r7, [r4, #335]	; 0x14f
        ret = wc_curve25519_shared_secret_ex(priv_key, pub_key, out, outlen,
 254:	4605      	mov	r5, r0
                        if (!ssl->specs.static_ecdh
 256:	b93f      	cbnz	r7, 268 <SendClientKeyExchange+0x268>
                            FreeKey(ssl, DYNAMIC_TYPE_CURVE25519,
 258:	f504 722d 	add.w	r2, r4, #692	; 0x2b4
 25c:	2145      	movs	r1, #69	; 0x45
 25e:	4620      	mov	r0, r4
 260:	f7ff fffe 	bl	0 <SendClientKeyExchange>
                            ssl->peerX25519KeyPresent = 0;
 264:	f884 72b8 	strb.w	r7, [r4, #696]	; 0x2b8
            if (ret != 0) {
 268:	2d00      	cmp	r5, #0
 26a:	f040 80bc 	bne.w	3e6 <SendClientKeyExchange+0x3e6>
            ssl->options.asyncState = TLS_ASYNC_VERIFY;
 26e:	2303      	movs	r3, #3
 270:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            switch(ssl->specs.kea)
 274:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 278:	2b07      	cmp	r3, #7
 27a:	f47f af08 	bne.w	8e <SendClientKeyExchange+0x8e>
                    if (args->encSecret == NULL) {
 27e:	68b3      	ldr	r3, [r6, #8]
 280:	2b00      	cmp	r3, #0
 282:	d0c3      	beq.n	20c <SendClientKeyExchange+0x20c>
                        *args->encSecret = (byte)args->encSz;
 284:	6932      	ldr	r2, [r6, #16]
 286:	701a      	strb	r2, [r3, #0]
                        args->encSz += OPAQUE8_LEN;
 288:	6933      	ldr	r3, [r6, #16]
 28a:	3301      	adds	r3, #1
 28c:	6133      	str	r3, [r6, #16]
            ssl->options.asyncState = TLS_ASYNC_FINALIZE;
 28e:	2304      	movs	r3, #4
 290:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            if (ssl->options.tls || ssl->specs.kea == diffie_hellman_kea) {
 294:	f894 2271 	ldrb.w	r2, [r4, #625]	; 0x271
 298:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 29c:	0652      	lsls	r2, r2, #25
 29e:	d48e      	bmi.n	1be <SendClientKeyExchange+0x1be>
            word32 tlsSz = 0;
 2a0:	2b02      	cmp	r3, #2
 2a2:	bf0c      	ite	eq
 2a4:	2702      	moveq	r7, #2
 2a6:	2700      	movne	r7, #0
            if (ssl->specs.kea == ecc_diffie_hellman_kea ||
 2a8:	3b05      	subs	r3, #5
                tlsSz = 0;
 2aa:	2b02      	cmp	r3, #2
            args->sendSz = args->encSz + tlsSz + idx;
 2ac:	6932      	ldr	r2, [r6, #16]
                tlsSz = 0;
 2ae:	bf98      	it	ls
 2b0:	2700      	movls	r7, #0
            args->sendSz = args->encSz + tlsSz + idx;
 2b2:	443a      	add	r2, r7
 2b4:	f102 0309 	add.w	r3, r2, #9
 2b8:	61b3      	str	r3, [r6, #24]
            if (IsEncryptionOn(ssl, 1)) {
 2ba:	2101      	movs	r1, #1
 2bc:	4620      	mov	r0, r4
 2be:	f7ff fffe 	bl	0 <SendClientKeyExchange>
 2c2:	b108      	cbz	r0, 2c8 <SendClientKeyExchange+0x2c8>
                args->sendSz += MAX_MSG_EXTRA;
 2c4:	326f      	adds	r2, #111	; 0x6f
 2c6:	61b2      	str	r2, [r6, #24]
            if ((ret = CheckAvailableSize(ssl, args->sendSz)) != 0)
 2c8:	69b1      	ldr	r1, [r6, #24]
 2ca:	4620      	mov	r0, r4
 2cc:	f7ff fffe 	bl	0 <SendClientKeyExchange>
 2d0:	4605      	mov	r5, r0
 2d2:	2800      	cmp	r0, #0
 2d4:	f040 8087 	bne.w	3e6 <SendClientKeyExchange+0x3e6>
            args->output = GetOutputBuffer(ssl);
 2d8:	4620      	mov	r0, r4
 2da:	f7ff fffe 	bl	0 <SendClientKeyExchange>
            AddHeaders(args->output, args->encSz + tlsSz, client_key_exchange, ssl);
 2de:	6931      	ldr	r1, [r6, #16]
            args->output = GetOutputBuffer(ssl);
 2e0:	6070      	str	r0, [r6, #4]
            AddHeaders(args->output, args->encSz + tlsSz, client_key_exchange, ssl);
 2e2:	4623      	mov	r3, r4
 2e4:	2210      	movs	r2, #16
 2e6:	4439      	add	r1, r7
 2e8:	f7ff fffe 	bl	0 <SendClientKeyExchange>
            if (tlsSz) {
 2ec:	2f00      	cmp	r7, #0
 2ee:	f43f af68 	beq.w	1c2 <SendClientKeyExchange+0x1c2>
                c16toa((word16)args->encSz, &args->output[idx]);
 2f2:	6932      	ldr	r2, [r6, #16]
 2f4:	6873      	ldr	r3, [r6, #4]
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 2f6:	f3c2 2107 	ubfx	r1, r2, #8, #8
 2fa:	7259      	strb	r1, [r3, #9]
    c[1] =  (byte)(wc_u16       & 0xff);
 2fc:	729a      	strb	r2, [r3, #10]
                idx += OPAQUE16_LEN;
 2fe:	250b      	movs	r5, #11
            XMEMCPY(args->output + idx, args->encSecret, args->encSz);
 300:	6870      	ldr	r0, [r6, #4]
 302:	68b1      	ldr	r1, [r6, #8]
 304:	6932      	ldr	r2, [r6, #16]
 306:	4428      	add	r0, r5
 308:	f7ff fffe 	bl	0 <memcpy>
            if (IsEncryptionOn(ssl, 1)) {
 30c:	2101      	movs	r1, #1
 30e:	4620      	mov	r0, r4
 310:	f7ff fffe 	bl	0 <SendClientKeyExchange>
 314:	b1a8      	cbz	r0, 342 <SendClientKeyExchange+0x342>
                if (ssl->options.dtls)
 316:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
            idx += args->encSz;
 31a:	6930      	ldr	r0, [r6, #16]
                    recordHeaderSz += DTLS_RECORD_EXTRA;
 31c:	f013 0f04 	tst.w	r3, #4
 320:	bf0c      	ite	eq
 322:	2705      	moveq	r7, #5
 324:	270d      	movne	r7, #13
            idx += args->encSz;
 326:	4428      	add	r0, r5
                args->inputSz = idx - recordHeaderSz; /* buildmsg adds rechdr */
 328:	1bc0      	subs	r0, r0, r7
 32a:	61f0      	str	r0, [r6, #28]
                args->input = (byte*)XMALLOC(args->inputSz, ssl->heap,
 32c:	f7ff fffe 	bl	0 <malloc>
 330:	60f0      	str	r0, [r6, #12]
                if (args->input == NULL) {
 332:	2800      	cmp	r0, #0
 334:	f43f ae6f 	beq.w	16 <SendClientKeyExchange+0x16>
                XMEMCPY(args->input, args->output + recordHeaderSz,
 338:	6871      	ldr	r1, [r6, #4]
 33a:	69f2      	ldr	r2, [r6, #28]
 33c:	4439      	add	r1, r7
 33e:	f7ff fffe 	bl	0 <memcpy>
            ssl->options.asyncState = TLS_ASYNC_END;
 342:	2305      	movs	r3, #5
 344:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            if (IsEncryptionOn(ssl, 1)) {
 348:	2101      	movs	r1, #1
 34a:	4620      	mov	r0, r4
 34c:	f7ff fffe 	bl	0 <SendClientKeyExchange>
                ret = BuildMessage(ssl, args->output, args->sendSz,
 350:	6875      	ldr	r5, [r6, #4]
 352:	69b2      	ldr	r2, [r6, #24]
            if (IsEncryptionOn(ssl, 1)) {
 354:	4603      	mov	r3, r0
 356:	2800      	cmp	r0, #0
 358:	f43f af35 	beq.w	1c6 <SendClientKeyExchange+0x1c6>
                ret = BuildMessage(ssl, args->output, args->sendSz,
 35c:	2700      	movs	r7, #0
 35e:	e9cd 1702 	strd	r1, r7, [sp, #8]
 362:	e9cd 7704 	strd	r7, r7, [sp, #16]
 366:	2316      	movs	r3, #22
 368:	9301      	str	r3, [sp, #4]
 36a:	69f3      	ldr	r3, [r6, #28]
 36c:	9300      	str	r3, [sp, #0]
 36e:	4629      	mov	r1, r5
 370:	68f3      	ldr	r3, [r6, #12]
 372:	4620      	mov	r0, r4
 374:	f7ff fffe 	bl	0 <SendClientKeyExchange>
 378:	4605      	mov	r5, r0
                XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 37a:	68f0      	ldr	r0, [r6, #12]
 37c:	b108      	cbz	r0, 382 <SendClientKeyExchange+0x382>
 37e:	f7ff fffe 	bl	0 <free>
                if (ret >= 0) {
 382:	2d00      	cmp	r5, #0
                args->input = NULL; /* make sure its not double free'd on cleanup */
 384:	60f7      	str	r7, [r6, #12]
                if (ret >= 0) {
 386:	db2e      	blt.n	3e6 <SendClientKeyExchange+0x3e6>
                    args->sendSz = ret;
 388:	61b5      	str	r5, [r6, #24]
            ssl->buffers.outputBuffer.length += args->sendSz;
 38a:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 38e:	69b2      	ldr	r2, [r6, #24]
 390:	4413      	add	r3, r2
 392:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
            if (!ssl->options.groupMessages) {
 396:	f994 3274 	ldrsb.w	r3, [r4, #628]	; 0x274
 39a:	2b00      	cmp	r3, #0
 39c:	f6bf af1c 	bge.w	1d8 <SendClientKeyExchange+0x1d8>
                    recordHeaderSz += DTLS_RECORD_EXTRA;
 3a0:	2500      	movs	r5, #0
                int tmpRet = MakeMasterSecret(ssl);
 3a2:	4620      	mov	r0, r4
 3a4:	f7ff fffe 	bl	0 <MakeMasterSecret>
                ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
 3a8:	230d      	movs	r3, #13
 3aa:	f884 327d 	strb.w	r3, [r4, #637]	; 0x27d
                ssl->options.buildingMsg = 0;
 3ae:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
 3b2:	f36f 03c3 	bfc	r3, #3, #1
                if (tmpRet != 0) {
 3b6:	2800      	cmp	r0, #0
 3b8:	bf18      	it	ne
 3ba:	4605      	movne	r5, r0
                ssl->options.buildingMsg = 0;
 3bc:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
 3c0:	e011      	b.n	3e6 <SendClientKeyExchange+0x3e6>
                    ssl->hsType = DYNAMIC_TYPE_ECC;
 3c2:	2125      	movs	r1, #37	; 0x25
 3c4:	6421      	str	r1, [r4, #64]	; 0x40
                    ret = AllocKey(ssl, ssl->hsType, &ssl->hsKey);
 3c6:	f104 023c 	add.w	r2, r4, #60	; 0x3c
 3ca:	4620      	mov	r0, r4
 3cc:	f7ff fffe 	bl	0 <SendClientKeyExchange>
                    if (ret != 0) {
 3d0:	4605      	mov	r5, r0
 3d2:	b940      	cbnz	r0, 3e6 <SendClientKeyExchange+0x3e6>
                    ret = EccMakeKey(ssl, (ecc_key*)ssl->hsKey, peerKey);
 3d4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 3d6:	463a      	mov	r2, r7
 3d8:	4620      	mov	r0, r4
 3da:	f7ff fffe 	bl	0 <SendClientKeyExchange>
            if (ret != 0) {
 3de:	4605      	mov	r5, r0
 3e0:	2800      	cmp	r0, #0
 3e2:	f43f ae79 	beq.w	d8 <SendClientKeyExchange+0xd8>
    if (ret == WC_PENDING_E || ret == WANT_WRITE) {
 3e6:	f115 0f6c 	cmn.w	r5, #108	; 0x6c
 3ea:	f47f af06 	bne.w	1fa <SendClientKeyExchange+0x1fa>
                if (tmpRet != 0) {
 3ee:	f06f 056b 	mvn.w	r5, #107	; 0x6b
        if (ssl->options.buildingMsg)
 3f2:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
 3f6:	071b      	lsls	r3, r3, #28
 3f8:	f57f ae0f 	bpl.w	1a <SendClientKeyExchange+0x1a>
}
 3fc:	4628      	mov	r0, r5
 3fe:	b006      	add	sp, #24
 400:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.SendCertificateVerify:

00000000 <SendCertificateVerify>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if (ssl->async == NULL) {
   2:	6b85      	ldr	r5, [r0, #56]	; 0x38
{
   4:	4604      	mov	r4, r0
    if (ssl->async == NULL) {
   6:	bb1d      	cbnz	r5, 50 <SendCertificateVerify+0x50>
                XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,
   8:	204c      	movs	r0, #76	; 0x4c
   a:	f7ff fffe 	bl	0 <malloc>
        ssl->async = (struct WOLFSSL_ASYNC*)
   e:	63a0      	str	r0, [r4, #56]	; 0x38
        if (ssl->async == NULL)
  10:	b9d0      	cbnz	r0, 48 <SendCertificateVerify+0x48>
            ERROR_OUT(MEMORY_E, exit_scv);
  12:	f06f 067c 	mvn.w	r6, #124	; 0x7c
    if(ssl->buffers.digest.buffer) {
  16:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
  1a:	b128      	cbz	r0, 28 <SendCertificateVerify+0x28>
        if (!ssl->options.dontFreeDigest) {
  1c:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
  20:	075b      	lsls	r3, r3, #29
  22:	d401      	bmi.n	28 <SendCertificateVerify+0x28>
            XFREE(ssl->buffers.digest.buffer,
  24:	f7ff fffe 	bl	0 <free>
    ssl->options.dontFreeDigest = 0;
  28:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
    ssl->buffers.digest.buffer = NULL;
  2c:	2100      	movs	r1, #0
    ssl->options.dontFreeDigest = 0;
  2e:	f361 0382 	bfi	r3, r1, #2, #1
    FreeAsyncCtx(ssl, 0);
  32:	4620      	mov	r0, r4
    ssl->buffers.digest.length = 0;
  34:	e9c4 1132 	strd	r1, r1, [r4, #200]	; 0xc8
    ssl->options.dontFreeDigest = 0;
  38:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
    FreeAsyncCtx(ssl, 0);
  3c:	f7ff fffe 	bl	0 <SendCertificateVerify>
    FreeKeyExchange(ssl);
  40:	4620      	mov	r0, r4
  42:	f7ff fffe 	bl	0 <SendCertificateVerify>
    return ret;
  46:	e122      	b.n	28e <SendCertificateVerify+0x28e>
        XMEMSET(ssl->async, 0, sizeof(struct WOLFSSL_ASYNC));
  48:	224c      	movs	r2, #76	; 0x4c
  4a:	4629      	mov	r1, r5
  4c:	f7ff fffe 	bl	0 <memset>
    if (ssl->options.buildingMsg) {
  50:	f894 1276 	ldrb.w	r1, [r4, #630]	; 0x276
    args = (ScvArgs*)ssl->async->args;
  54:	6ba5      	ldr	r5, [r4, #56]	; 0x38
    if (ssl->options.buildingMsg) {
  56:	f011 0108 	ands.w	r1, r1, #8
  5a:	d00e      	beq.n	7a <SendCertificateVerify+0x7a>
        if (ssl->options.asyncState != TLS_ASYNC_END) {
  5c:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
  60:	2b05      	cmp	r3, #5
  62:	f040 8119 	bne.w	298 <SendCertificateVerify+0x298>
            ret = SendHandshakeMsg(ssl, args->output,
  66:	696a      	ldr	r2, [r5, #20]
                (word32)args->length + args->extraSz + VERIFY_HEADER,
  68:	8cab      	ldrh	r3, [r5, #36]	; 0x24
            ret = SendHandshakeMsg(ssl, args->output,
  6a:	6869      	ldr	r1, [r5, #4]
  6c:	3202      	adds	r2, #2
  6e:	441a      	add	r2, r3
  70:	4620      	mov	r0, r4
  72:	f7ff fffe 	bl	0 <SendCertificateVerify>
  76:	4606      	mov	r6, r0
            if (ret != 0)
  78:	e104      	b.n	284 <SendCertificateVerify+0x284>
        XMEMSET(args, 0, sizeof(ScvArgs));
  7a:	2224      	movs	r2, #36	; 0x24
        ssl->options.asyncState = TLS_ASYNC_BEGIN;
  7c:	f884 1283 	strb.w	r1, [r4, #643]	; 0x283
        XMEMSET(args, 0, sizeof(ScvArgs));
  80:	1d28      	adds	r0, r5, #4
  82:	f7ff fffe 	bl	0 <memset>
        ssl->async->freeArgs = FreeScvArgs;
  86:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  88:	4a88      	ldr	r2, [pc, #544]	; (2ac <SendCertificateVerify+0x2ac>)
  8a:	601a      	str	r2, [r3, #0]
    switch(ssl->options.asyncState)
  8c:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
  90:	2b05      	cmp	r3, #5
  92:	f200 8104 	bhi.w	29e <SendCertificateVerify+0x29e>
  96:	a201      	add	r2, pc, #4	; (adr r2, 9c <SendCertificateVerify+0x9c>)
  98:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  9c:	000000b5 	.word	0x000000b5
  a0:	000000eb 	.word	0x000000eb
  a4:	000001a3 	.word	0x000001a3
  a8:	000001eb 	.word	0x000001eb
  ac:	00000225 	.word	0x00000225
  b0:	00000067 	.word	0x00000067
            if (ssl->options.sendVerify == SEND_BLANK_CERT) {
  b4:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  b8:	f003 0303 	and.w	r3, r3, #3
  bc:	2b02      	cmp	r3, #2
  be:	f000 80f3 	beq.w	2a8 <SendCertificateVerify+0x2a8>
            args->sendSz = MAX_CERT_VERIFY_SZ + MAX_MSG_EXTRA;
  c2:	23af      	movs	r3, #175	; 0xaf
  c4:	61eb      	str	r3, [r5, #28]
            if (IsEncryptionOn(ssl, 1)) {
  c6:	2101      	movs	r1, #1
  c8:	4620      	mov	r0, r4
  ca:	f7ff fffe 	bl	0 <SendCertificateVerify>
  ce:	b110      	cbz	r0, d6 <SendCertificateVerify+0xd6>
                args->sendSz += MAX_MSG_EXTRA;
  d0:	f240 1315 	movw	r3, #277	; 0x115
  d4:	61eb      	str	r3, [r5, #28]
            args->input = (byte*)XMALLOC(args->sendSz,
  d6:	69e8      	ldr	r0, [r5, #28]
  d8:	f7ff fffe 	bl	0 <malloc>
  dc:	60e8      	str	r0, [r5, #12]
            if (args->input == NULL)
  de:	2800      	cmp	r0, #0
  e0:	d097      	beq.n	12 <SendCertificateVerify+0x12>
            ssl->options.asyncState = TLS_ASYNC_BUILD;
  e2:	2301      	movs	r3, #1
            args->output = args->input;
  e4:	6068      	str	r0, [r5, #4]
            ssl->options.asyncState = TLS_ASYNC_BUILD;
  e6:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            ret = BuildCertHashes(ssl, &ssl->hsHashes->certHashes);
  ea:	68e1      	ldr	r1, [r4, #12]
  ec:	4620      	mov	r0, r4
  ee:	3174      	adds	r1, #116	; 0x74
  f0:	f7ff fffe 	bl	0 <SendCertificateVerify>
            if (ret != 0) {
  f4:	4606      	mov	r6, r0
  f6:	2800      	cmp	r0, #0
  f8:	f040 80c4 	bne.w	284 <SendCertificateVerify+0x284>
            if (ssl->buffers.key == NULL) {
  fc:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 100:	b913      	cbnz	r3, 108 <SendCertificateVerify+0x108>
                    ERROR_OUT(NO_PRIVATE_KEY, exit_scv);
 102:	f46f 769e 	mvn.w	r6, #316	; 0x13c
 106:	e786      	b.n	16 <SendCertificateVerify+0x16>
                ret = DecodePrivateKey(ssl, &args->length);
 108:	f105 0124 	add.w	r1, r5, #36	; 0x24
 10c:	4620      	mov	r0, r4
 10e:	f7ff fffe 	bl	0 <SendCertificateVerify>
                if (ret != 0) {
 112:	4606      	mov	r6, r0
 114:	2800      	cmp	r0, #0
 116:	f040 80b5 	bne.w	284 <SendCertificateVerify+0x284>
            if (args->length == 0) {
 11a:	8cab      	ldrh	r3, [r5, #36]	; 0x24
 11c:	2b00      	cmp	r3, #0
 11e:	d0f0      	beq.n	102 <SendCertificateVerify+0x102>
            args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 120:	2309      	movs	r3, #9
 122:	612b      	str	r3, [r5, #16]
            args->verify = &args->output[RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ];
 124:	686b      	ldr	r3, [r5, #4]
            args->extraSz = 0;  /* tls 1.2 hash/sig */
 126:	6168      	str	r0, [r5, #20]
            args->verify = &args->output[RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ];
 128:	3309      	adds	r3, #9
            ssl->buffers.sig.length = MAX_ENCODED_SIG_SZ;
 12a:	208c      	movs	r0, #140	; 0x8c
            args->verify = &args->output[RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ];
 12c:	60ab      	str	r3, [r5, #8]
            ssl->buffers.sig.length = MAX_ENCODED_SIG_SZ;
 12e:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
            ssl->buffers.sig.buffer = (byte*)XMALLOC(MAX_ENCODED_SIG_SZ,
 132:	f7ff fffe 	bl	0 <malloc>
 136:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
            if (ssl->buffers.sig.buffer == NULL) {
 13a:	2800      	cmp	r0, #0
 13c:	f43f af69 	beq.w	12 <SendCertificateVerify+0x12>
            if (!IsAtLeastTLSv1_2(ssl)) {
 140:	4620      	mov	r0, r4
 142:	f7ff fffe 	bl	0 <SendCertificateVerify>
 146:	2800      	cmp	r0, #0
 148:	d17b      	bne.n	242 <SendCertificateVerify+0x242>
            ssl->options.dontFreeDigest = 1;
 14a:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
 14e:	f043 0304 	orr.w	r3, r3, #4
 152:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
            ssl->buffers.digest.buffer = ssl->hsHashes->certHashes.sha256;
 156:	68e3      	ldr	r3, [r4, #12]
 158:	3388      	adds	r3, #136	; 0x88
 15a:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
            ssl->buffers.digest.length = WC_SHA256_DIGEST_SIZE;
 15e:	2320      	movs	r3, #32
 160:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
            if (ssl->hsType == DYNAMIC_TYPE_RSA) {
 164:	6c23      	ldr	r3, [r4, #64]	; 0x40
 166:	2b0a      	cmp	r3, #10
 168:	d171      	bne.n	24e <SendCertificateVerify+0x24e>
                    args->sigAlgo = rsa_sa_algo;
 16a:	2301      	movs	r3, #1
                args->sigAlgo = ed448_sa_algo;
 16c:	f885 3026 	strb.w	r3, [r5, #38]	; 0x26
            if (IsAtLeastTLSv1_2(ssl)) {
 170:	4620      	mov	r0, r4
 172:	f7ff fffe 	bl	0 <SendCertificateVerify>
 176:	b168      	cbz	r0, 194 <SendCertificateVerify+0x194>
                EncodeSigAlg(ssl->options.hashAlgo, args->sigAlgo,
 178:	f895 2026 	ldrb.w	r2, [r5, #38]	; 0x26
 17c:	68ab      	ldr	r3, [r5, #8]
    switch (hsType) {
 17e:	2a03      	cmp	r2, #3
 180:	d071      	beq.n	266 <SendCertificateVerify+0x266>
 182:	2a09      	cmp	r2, #9
 184:	d074      	beq.n	270 <SendCertificateVerify+0x270>
                args->extraSz = HASH_SIG_SIZE;
 186:	2302      	movs	r3, #2
 188:	616b      	str	r3, [r5, #20]
                SetDigest(ssl, ssl->options.hashAlgo);
 18a:	f894 127a 	ldrb.w	r1, [r4, #634]	; 0x27a
 18e:	4620      	mov	r0, r4
 190:	f7ff fffe 	bl	0 <SendCertificateVerify>
            if (args->sigAlgo == ed25519_sa_algo) {
 194:	f895 3026 	ldrb.w	r3, [r5, #38]	; 0x26
 198:	2b09      	cmp	r3, #9
 19a:	d06d      	beq.n	278 <SendCertificateVerify+0x278>
            ssl->options.asyncState = TLS_ASYNC_DO;
 19c:	2302      	movs	r3, #2
 19e:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            if (ssl->hsType == DYNAMIC_TYPE_ECC) {
 1a2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 1a4:	2b25      	cmp	r3, #37	; 0x25
 1a6:	d175      	bne.n	294 <SendCertificateVerify+0x294>
        ret = wc_ecc_sign_hash(in, inSz, out, outSz, ssl->rng, key);
 1a8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 1aa:	9301      	str	r3, [sp, #4]
 1ac:	69a3      	ldr	r3, [r4, #24]
 1ae:	9300      	str	r3, [sp, #0]
 1b0:	e9d4 0132 	ldrd	r0, r1, [r4, #200]	; 0xc8
 1b4:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 1b8:	f104 03c4 	add.w	r3, r4, #196	; 0xc4
 1bc:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
 1c0:	4606      	mov	r6, r0
           if (ssl->hsType == DYNAMIC_TYPE_ED25519) {
 1c2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 1c4:	2b46      	cmp	r3, #70	; 0x46
 1c6:	d10b      	bne.n	1e0 <SendCertificateVerify+0x1e0>
        ret = wc_ed25519_sign_msg(in, inSz, out, outSz, key);
 1c8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
                    ssl->hsHashes->messages, ssl->hsHashes->length,
 1ca:	68e0      	ldr	r0, [r4, #12]
        ret = wc_ed25519_sign_msg(in, inSz, out, outSz, key);
 1cc:	9300      	str	r3, [sp, #0]
 1ce:	e9d0 01a8 	ldrd	r0, r1, [r0, #672]	; 0x2a0
 1d2:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 1d6:	f104 03c4 	add.w	r3, r4, #196	; 0xc4
 1da:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
 1de:	4606      	mov	r6, r0
            if (ret != 0) {
 1e0:	2e00      	cmp	r6, #0
 1e2:	d14f      	bne.n	284 <SendCertificateVerify+0x284>
            ssl->options.asyncState = TLS_ASYNC_VERIFY;
 1e4:	2303      	movs	r3, #3
 1e6:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            args->verify = &args->output[args->idx];
 1ea:	692a      	ldr	r2, [r5, #16]
 1ec:	686b      	ldr	r3, [r5, #4]
 1ee:	4413      	add	r3, r2
            switch (ssl->hsType) {
 1f0:	6c22      	ldr	r2, [r4, #64]	; 0x40
            args->verify = &args->output[args->idx];
 1f2:	60ab      	str	r3, [r5, #8]
            switch (ssl->hsType) {
 1f4:	2a25      	cmp	r2, #37	; 0x25
 1f6:	d001      	beq.n	1fc <SendCertificateVerify+0x1fc>
 1f8:	2a46      	cmp	r2, #70	; 0x46
 1fa:	d110      	bne.n	21e <SendCertificateVerify+0x21e>
                    args->length = (word16)ssl->buffers.sig.length;
 1fc:	f8d4 10c4 	ldr.w	r1, [r4, #196]	; 0xc4
                    c16toa(args->length, args->verify + args->extraSz);
 200:	6968      	ldr	r0, [r5, #20]
                    args->length = (word16)ssl->buffers.sig.length;
 202:	b28a      	uxth	r2, r1
 204:	84aa      	strh	r2, [r5, #36]	; 0x24
                    c16toa(args->length, args->verify + args->extraSz);
 206:	181e      	adds	r6, r3, r0
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 208:	0a12      	lsrs	r2, r2, #8
 20a:	541a      	strb	r2, [r3, r0]
    c[1] =  (byte)(wc_u16       & 0xff);
 20c:	7071      	strb	r1, [r6, #1]
                    XMEMCPY(args->verify + args->extraSz + VERIFY_HEADER,
 20e:	6968      	ldr	r0, [r5, #20]
 210:	68ab      	ldr	r3, [r5, #8]
 212:	3002      	adds	r0, #2
 214:	e9d4 1230 	ldrd	r1, r2, [r4, #192]	; 0xc0
 218:	4418      	add	r0, r3
 21a:	f7ff fffe 	bl	0 <memcpy>
            ssl->options.asyncState = TLS_ASYNC_FINALIZE;
 21e:	2304      	movs	r3, #4
 220:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            if (args->output == NULL) {
 224:	6868      	ldr	r0, [r5, #4]
 226:	2800      	cmp	r0, #0
 228:	d03c      	beq.n	2a4 <SendCertificateVerify+0x2a4>
            AddHeaders(args->output, (word32)args->length + args->extraSz +
 22a:	6969      	ldr	r1, [r5, #20]
 22c:	8cae      	ldrh	r6, [r5, #36]	; 0x24
 22e:	3102      	adds	r1, #2
 230:	4623      	mov	r3, r4
 232:	220f      	movs	r2, #15
 234:	4431      	add	r1, r6
 236:	f7ff fffe 	bl	0 <SendCertificateVerify>
            ssl->options.asyncState = TLS_ASYNC_END;
 23a:	2305      	movs	r3, #5
 23c:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
 240:	e711      	b.n	66 <SendCertificateVerify+0x66>
                SetDigest(ssl, ssl->options.hashAlgo);
 242:	f894 127a 	ldrb.w	r1, [r4, #634]	; 0x27a
 246:	4620      	mov	r0, r4
 248:	f7ff fffe 	bl	0 <SendCertificateVerify>
 24c:	e78a      	b.n	164 <SendCertificateVerify+0x164>
            else if (ssl->hsType == DYNAMIC_TYPE_ECC)
 24e:	2b25      	cmp	r3, #37	; 0x25
 250:	d101      	bne.n	256 <SendCertificateVerify+0x256>
                    args->sigAlgo = ecc_dsa_sa_algo;
 252:	2303      	movs	r3, #3
 254:	e78a      	b.n	16c <SendCertificateVerify+0x16c>
            else if (ssl->hsType == DYNAMIC_TYPE_ED25519)
 256:	2b46      	cmp	r3, #70	; 0x46
 258:	d101      	bne.n	25e <SendCertificateVerify+0x25e>
                args->sigAlgo = ed25519_sa_algo;
 25a:	2309      	movs	r3, #9
 25c:	e786      	b.n	16c <SendCertificateVerify+0x16c>
            else if (ssl->hsType == DYNAMIC_TYPE_ED448)
 25e:	2b5c      	cmp	r3, #92	; 0x5c
 260:	d186      	bne.n	170 <SendCertificateVerify+0x170>
                args->sigAlgo = ed448_sa_algo;
 262:	230b      	movs	r3, #11
 264:	e782      	b.n	16c <SendCertificateVerify+0x16c>
                EncodeSigAlg(ssl->options.hashAlgo, args->sigAlgo,
 266:	f894 127a 	ldrb.w	r1, [r4, #634]	; 0x27a
            output[0] = hashAlgo;
 26a:	7019      	strb	r1, [r3, #0]
            output[1] = ED25519_SA_MINOR;
 26c:	705a      	strb	r2, [r3, #1]
            break;
 26e:	e78a      	b.n	186 <SendCertificateVerify+0x186>
            output[0] = ED25519_SA_MAJOR;
 270:	2208      	movs	r2, #8
 272:	701a      	strb	r2, [r3, #0]
            output[1] = ED25519_SA_MINOR;
 274:	2207      	movs	r2, #7
 276:	e7f9      	b.n	26c <SendCertificateVerify+0x26c>
                ret = Ed25519CheckPubKey(ssl);
 278:	4620      	mov	r0, r4
 27a:	f7ff fffe 	bl	0 <SendCertificateVerify>
                if (ret != 0)
 27e:	4606      	mov	r6, r0
 280:	2800      	cmp	r0, #0
 282:	d08b      	beq.n	19c <SendCertificateVerify+0x19c>
    if (ret == WANT_WRITE
 284:	f46f 73a3 	mvn.w	r3, #326	; 0x146
 288:	429e      	cmp	r6, r3
 28a:	f47f aec4 	bne.w	16 <SendCertificateVerify+0x16>
}
 28e:	4630      	mov	r0, r6
 290:	b002      	add	sp, #8
 292:	bd70      	pop	{r4, r5, r6, pc}
 294:	2600      	movs	r6, #0
 296:	e794      	b.n	1c2 <SendCertificateVerify+0x1c2>
            ret = BAD_STATE_E;
 298:	f06f 06bf 	mvn.w	r6, #191	; 0xbf
 29c:	e6bb      	b.n	16 <SendCertificateVerify+0x16>
    switch(ssl->options.asyncState)
 29e:	f46f 7696 	mvn.w	r6, #300	; 0x12c
 2a2:	e6b8      	b.n	16 <SendCertificateVerify+0x16>
                ERROR_OUT(BUFFER_ERROR, exit_scv);
 2a4:	4e02      	ldr	r6, [pc, #8]	; (2b0 <SendCertificateVerify+0x2b0>)
 2a6:	e6b6      	b.n	16 <SendCertificateVerify+0x16>
                return 0;  /* sent blank cert, can't verify */
 2a8:	2600      	movs	r6, #0
 2aa:	e7f0      	b.n	28e <SendCertificateVerify+0x28e>
 2ac:	00000000 	.word	0x00000000
 2b0:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.GetCurveByOID:

00000000 <GetCurveByOID>:
    }
   0:	f240 230e 	movw	r3, #526	; 0x20e
   4:	4298      	cmp	r0, r3
   6:	bf0c      	ite	eq
   8:	2017      	moveq	r0, #23
   a:	2000      	movne	r0, #0
   c:	4770      	bx	lr

Disassembly of section .text.TranslateErrorToAlert:

00000000 <TranslateErrorToAlert>:
        switch (err) {
   0:	f510 7fa4 	cmn.w	r0, #328	; 0x148
   4:	d03a      	beq.n	7c <TranslateErrorToAlert+0x7c>
   6:	dc2f      	bgt.n	68 <TranslateErrorToAlert+0x68>
   8:	f510 7fd3 	cmn.w	r0, #422	; 0x1a6
   c:	d038      	beq.n	80 <TranslateErrorToAlert+0x80>
   e:	dc20      	bgt.n	52 <TranslateErrorToAlert+0x52>
  10:	f46f 73fa 	mvn.w	r3, #500	; 0x1f4
  14:	4298      	cmp	r0, r3
  16:	d033      	beq.n	80 <TranslateErrorToAlert+0x80>
  18:	f510 7ffa 	cmn.w	r0, #500	; 0x1f4
  1c:	da11      	bge.n	42 <TranslateErrorToAlert+0x42>
  1e:	f46f 73fc 	mvn.w	r3, #504	; 0x1f8
  22:	4298      	cmp	r0, r3
  24:	bf14      	ite	ne
  26:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  2a:	202f      	moveq	r0, #47	; 0x2f
  2c:	4770      	bx	lr
  2e:	2301      	movs	r3, #1
  30:	fa03 f000 	lsl.w	r0, r3, r0
  34:	4b15      	ldr	r3, [pc, #84]	; (8c <TranslateErrorToAlert+0x8c>)
  36:	4218      	tst	r0, r3
  38:	bf0c      	ite	eq
  3a:	f04f 30ff 	moveq.w	r0, #4294967295	; 0xffffffff
  3e:	202f      	movne	r0, #47	; 0x2f
  40:	4770      	bx	lr
  42:	f200 10a9 	addw	r0, r0, #425	; 0x1a9
                return invalid_alert;
  46:	2802      	cmp	r0, #2
  48:	bf34      	ite	cc
  4a:	202f      	movcc	r0, #47	; 0x2f
  4c:	f04f 30ff 	movcs.w	r0, #4294967295	; 0xffffffff
  50:	4770      	bx	lr
        switch (err) {
  52:	f46f 73d2 	mvn.w	r3, #420	; 0x1a4
  56:	4298      	cmp	r0, r3
  58:	d014      	beq.n	84 <TranslateErrorToAlert+0x84>
  5a:	f500 70b0 	add.w	r0, r0, #352	; 0x160
  5e:	2813      	cmp	r0, #19
  60:	d9e5      	bls.n	2e <TranslateErrorToAlert+0x2e>
                return invalid_alert;
  62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  66:	4770      	bx	lr
        switch (err) {
  68:	f510 7fa3 	cmn.w	r0, #326	; 0x146
  6c:	d00c      	beq.n	88 <TranslateErrorToAlert+0x88>
                return missing_extension;
  6e:	f510 7f9b 	cmn.w	r0, #310	; 0x136
  72:	bf14      	ite	ne
  74:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  78:	206d      	moveq	r0, #109	; 0x6d
  7a:	4770      	bx	lr
                return decode_error;
  7c:	2032      	movs	r0, #50	; 0x32
  7e:	4770      	bx	lr
                return handshake_failure;
  80:	2028      	movs	r0, #40	; 0x28
  82:	4770      	bx	lr
        switch (err) {
  84:	202f      	movs	r0, #47	; 0x2f
  86:	4770      	bx	lr
                return wolfssl_alert_protocol_version;
  88:	2046      	movs	r0, #70	; 0x46
    }
  8a:	4770      	bx	lr
  8c:	00080401 	.word	0x00080401

Disassembly of section .text.SendServerHello:

00000000 <SendServerHello>:
    {
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	b088      	sub	sp, #32
        length = VERSION_SZ + RAN_LEN
   6:	2346      	movs	r3, #70	; 0x46
        ret = TLSX_GetResponseSize(ssl, server_hello, &length);
   8:	aa07      	add	r2, sp, #28
   a:	2102      	movs	r1, #2
    {
   c:	4604      	mov	r4, r0
        length = VERSION_SZ + RAN_LEN
   e:	f8ad 301c 	strh.w	r3, [sp, #28]
        ret = TLSX_GetResponseSize(ssl, server_hello, &length);
  12:	f7ff fffe 	bl	0 <TLSX_GetResponseSize>
        if (ret != 0)
  16:	4605      	mov	r5, r0
  18:	2800      	cmp	r0, #0
  1a:	f040 80ee 	bne.w	1fa <SendServerHello+0x1fa>
            length -= ID_LEN;    /* adjust ID_LEN assumption */
  1e:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  22:	3e20      	subs	r6, #32
  24:	b2b6      	uxth	r6, r6
        if (IsEncryptionOn(ssl, 1))
  26:	2101      	movs	r1, #1
  28:	4620      	mov	r0, r4
            length -= ID_LEN;    /* adjust ID_LEN assumption */
  2a:	f8ad 601c 	strh.w	r6, [sp, #28]
        if (IsEncryptionOn(ssl, 1))
  2e:	f7ff fffe 	bl	0 <SendServerHello>
  32:	2800      	cmp	r0, #0
  34:	f040 80af 	bne.w	196 <SendServerHello+0x196>
        sendSz = length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
  38:	3609      	adds	r6, #9
        ssl->options.buildingMsg = 1;
  3a:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  3e:	f043 0308 	orr.w	r3, r3, #8
  42:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
        if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
  46:	4631      	mov	r1, r6
  48:	4620      	mov	r0, r4
  4a:	f7ff fffe 	bl	0 <SendServerHello>
  4e:	4605      	mov	r5, r0
  50:	2800      	cmp	r0, #0
  52:	f040 80d2 	bne.w	1fa <SendServerHello+0x1fa>
        output = GetOutputBuffer(ssl);
  56:	4620      	mov	r0, r4
  58:	f7ff fffe 	bl	0 <SendServerHello>
        AddHeaders(output, length, server_hello, ssl);
  5c:	4623      	mov	r3, r4
  5e:	f8bd 101c 	ldrh.w	r1, [sp, #28]
  62:	2202      	movs	r2, #2
  64:	f7ff fffe 	bl	0 <SendServerHello>
        output[idx++] = (byte)ssl->version.major;
  68:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
  6c:	7243      	strb	r3, [r0, #9]
        output[idx++] = (byte)ssl->version.minor;
  6e:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
  72:	7283      	strb	r3, [r0, #10]
        if (!ssl->options.resuming) {
  74:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
        output = GetOutputBuffer(ssl);
  78:	4680      	mov	r8, r0
            ret = wc_RNG_GenerateBlock(ssl->rng, output + idx,
  7a:	f100 070b 	add.w	r7, r0, #11
        if (!ssl->options.resuming) {
  7e:	0718      	lsls	r0, r3, #28
  80:	f100 808b 	bmi.w	19a <SendServerHello+0x19a>
            ret = wc_RNG_GenerateBlock(ssl->rng, output + idx,
  84:	69a0      	ldr	r0, [r4, #24]
  86:	2221      	movs	r2, #33	; 0x21
  88:	4639      	mov	r1, r7
  8a:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
            if (ret != 0)
  8e:	4605      	mov	r5, r0
  90:	2800      	cmp	r0, #0
  92:	f040 80b2 	bne.w	1fa <SendServerHello+0x1fa>
            if (ssl->ctx->method->version.major == SSLv3_MAJOR &&
  96:	6823      	ldr	r3, [r4, #0]
  98:	681b      	ldr	r3, [r3, #0]
  9a:	781a      	ldrb	r2, [r3, #0]
  9c:	2a03      	cmp	r2, #3
  9e:	d114      	bne.n	ca <SendServerHello+0xca>
  a0:	785b      	ldrb	r3, [r3, #1]
  a2:	2b03      	cmp	r3, #3
  a4:	d111      	bne.n	ca <SendServerHello+0xca>
                (wolfSSL_get_options(ssl) & WOLFSSL_OP_NO_TLSv1_2) == 0 &&
  a6:	4620      	mov	r0, r4
  a8:	f7ff fffe 	bl	0 <wolfSSL_get_options>
                ssl->ctx->method->version.minor == TLSv1_2_MINOR &&
  ac:	0101      	lsls	r1, r0, #4
  ae:	d40c      	bmi.n	ca <SendServerHello+0xca>
                !IsAtLeastTLSv1_2(ssl)) {
  b0:	4620      	mov	r0, r4
  b2:	f7ff fffe 	bl	0 <SendServerHello>
                (wolfSSL_get_options(ssl) & WOLFSSL_OP_NO_TLSv1_2) == 0 &&
  b6:	4605      	mov	r5, r0
  b8:	b938      	cbnz	r0, ca <SendServerHello+0xca>
                XMEMCPY(output + idx + RAN_LEN - (TLS13_DOWNGRADE_SZ + 1),
  ba:	4952      	ldr	r1, [pc, #328]	; (204 <SendServerHello+0x204>)
  bc:	2207      	movs	r2, #7
  be:	f108 0023 	add.w	r0, r8, #35	; 0x23
  c2:	f7ff fffe 	bl	0 <memcpy>
                output[idx + RAN_LEN - 1] = 0;
  c6:	f888 502a 	strb.w	r5, [r8, #42]	; 0x2a
            XMEMCPY(ssl->arrays->serverRandom, output + idx, RAN_LEN);
  ca:	68a0      	ldr	r0, [r4, #8]
            output[idx++] = sessIdSz;
  cc:	2500      	movs	r5, #0
            XMEMCPY(ssl->arrays->serverRandom, output + idx, RAN_LEN);
  ce:	2220      	movs	r2, #32
  d0:	4639      	mov	r1, r7
  d2:	3034      	adds	r0, #52	; 0x34
  d4:	f7ff fffe 	bl	0 <memcpy>
            output[idx++] = sessIdSz;
  d8:	f888 502b 	strb.w	r5, [r8, #43]	; 0x2b
            XMEMCPY(ssl->arrays->sessionID, output + idx, sessIdSz);
  dc:	68a0      	ldr	r0, [r4, #8]
  de:	462a      	mov	r2, r5
  e0:	f108 012c 	add.w	r1, r8, #44	; 0x2c
  e4:	3054      	adds	r0, #84	; 0x54
  e6:	f7ff fffe 	bl	0 <memcpy>
            ssl->arrays->sessionIDSz = sessIdSz;
  ea:	68a3      	ldr	r3, [r4, #8]
  ec:	f883 5074 	strb.w	r5, [r3, #116]	; 0x74
        output[idx++] = ssl->options.cipherSuite0;
  f0:	f894 3278 	ldrb.w	r3, [r4, #632]	; 0x278
  f4:	f888 302c 	strb.w	r3, [r8, #44]	; 0x2c
        output[idx++] = ssl->options.cipherSuite;
  f8:	f894 3279 	ldrb.w	r3, [r4, #633]	; 0x279
  fc:	f888 302d 	strb.w	r3, [r8, #45]	; 0x2d
        if (ssl->options.usingCompression)
 100:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
            output[idx++] = ZLIB_COMPRESSION;
 104:	f013 0301 	ands.w	r3, r3, #1
 108:	bf18      	it	ne
 10a:	23dd      	movne	r3, #221	; 0xdd
 10c:	f888 302e 	strb.w	r3, [r8, #46]	; 0x2e
            word16 offset = 0;
 110:	2300      	movs	r3, #0
 112:	f8ad 301e 	strh.w	r3, [sp, #30]
            ret = TLSX_WriteResponse(ssl, output + idx, server_hello, &offset);
 116:	2202      	movs	r2, #2
 118:	f10d 031e 	add.w	r3, sp, #30
 11c:	f108 012f 	add.w	r1, r8, #47	; 0x2f
 120:	4620      	mov	r0, r4
 122:	f7ff fffe 	bl	0 <TLSX_WriteResponse>
            if (ret != 0)
 126:	4605      	mov	r5, r0
 128:	2800      	cmp	r0, #0
 12a:	d166      	bne.n	1fa <SendServerHello+0x1fa>
        if (IsEncryptionOn(ssl, 1)) {
 12c:	2101      	movs	r1, #1
 12e:	4620      	mov	r0, r4
            idx += offset;
 130:	f8bd 701e 	ldrh.w	r7, [sp, #30]
        if (IsEncryptionOn(ssl, 1)) {
 134:	f7ff fffe 	bl	0 <SendServerHello>
 138:	2800      	cmp	r0, #0
 13a:	d03e      	beq.n	1ba <SendServerHello+0x1ba>
            if (ssl->options.dtls)
 13c:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
                recordHeaderSz += DTLS_RECORD_EXTRA;
 140:	f013 0f04 	tst.w	r3, #4
 144:	bf0c      	ite	eq
 146:	f04f 0a05 	moveq.w	sl, #5
 14a:	f04f 0a0d 	movne.w	sl, #13
            idx += offset;
 14e:	372f      	adds	r7, #47	; 0x2f
            inputSz -= recordHeaderSz;
 150:	eba7 070a 	sub.w	r7, r7, sl
            input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 154:	4638      	mov	r0, r7
 156:	f7ff fffe 	bl	0 <malloc>
            if (input == NULL)
 15a:	4681      	mov	r9, r0
 15c:	2800      	cmp	r0, #0
 15e:	d04a      	beq.n	1f6 <SendServerHello+0x1f6>
            XMEMCPY(input, output + recordHeaderSz, inputSz);
 160:	463a      	mov	r2, r7
 162:	eb08 010a 	add.w	r1, r8, sl
 166:	f7ff fffe 	bl	0 <memcpy>
            sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
 16a:	2316      	movs	r3, #22
 16c:	2201      	movs	r2, #1
 16e:	e9cd 3201 	strd	r3, r2, [sp, #4]
 172:	4641      	mov	r1, r8
 174:	4632      	mov	r2, r6
 176:	464b      	mov	r3, r9
 178:	e9cd 5504 	strd	r5, r5, [sp, #16]
 17c:	9503      	str	r5, [sp, #12]
 17e:	9700      	str	r7, [sp, #0]
 180:	4620      	mov	r0, r4
 182:	f7ff fffe 	bl	0 <SendServerHello>
 186:	4606      	mov	r6, r0
            XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 188:	4648      	mov	r0, r9
 18a:	f7ff fffe 	bl	0 <free>
            if (sendSz < 0)
 18e:	2e00      	cmp	r6, #0
 190:	da1a      	bge.n	1c8 <SendServerHello+0x1c8>
 192:	4635      	mov	r5, r6
 194:	e031      	b.n	1fa <SendServerHello+0x1fa>
            sendSz += MAX_MSG_EXTRA;
 196:	366f      	adds	r6, #111	; 0x6f
 198:	e74f      	b.n	3a <SendServerHello+0x3a>
            XMEMCPY(output + idx, ssl->arrays->serverRandom, RAN_LEN);
 19a:	68a1      	ldr	r1, [r4, #8]
 19c:	2220      	movs	r2, #32
 19e:	3134      	adds	r1, #52	; 0x34
 1a0:	4638      	mov	r0, r7
 1a2:	f7ff fffe 	bl	0 <memcpy>
            output[idx++] = sessIdSz;
 1a6:	f888 502b 	strb.w	r5, [r8, #43]	; 0x2b
            XMEMCPY(output + idx, ssl->arrays->sessionID, sessIdSz);
 1aa:	68a1      	ldr	r1, [r4, #8]
 1ac:	462a      	mov	r2, r5
 1ae:	3154      	adds	r1, #84	; 0x54
 1b0:	f108 002c 	add.w	r0, r8, #44	; 0x2c
 1b4:	f7ff fffe 	bl	0 <memcpy>
 1b8:	e79a      	b.n	f0 <SendServerHello+0xf0>
            ret = HashOutput(ssl, output, sendSz, 0);
 1ba:	462b      	mov	r3, r5
 1bc:	4632      	mov	r2, r6
 1be:	4641      	mov	r1, r8
 1c0:	4620      	mov	r0, r4
 1c2:	f7ff fffe 	bl	0 <SendServerHello>
            if (ret != 0)
 1c6:	b9a0      	cbnz	r0, 1f2 <SendServerHello+0x1f2>
        ssl->options.serverState = SERVER_HELLO_COMPLETE;
 1c8:	2303      	movs	r3, #3
 1ca:	f884 327c 	strb.w	r3, [r4, #636]	; 0x27c
        ssl->options.buildingMsg = 0;
 1ce:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
        ssl->buffers.outputBuffer.length += sendSz;
 1d2:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
        ssl->options.buildingMsg = 0;
 1d6:	f36f 03c3 	bfc	r3, #3, #1
 1da:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
        if (ssl->options.groupMessages)
 1de:	f994 3274 	ldrsb.w	r3, [r4, #628]	; 0x274
        ssl->buffers.outputBuffer.length += sendSz;
 1e2:	4430      	add	r0, r6
        if (ssl->options.groupMessages)
 1e4:	2b00      	cmp	r3, #0
        ssl->buffers.outputBuffer.length += sendSz;
 1e6:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
        if (ssl->options.groupMessages)
 1ea:	db06      	blt.n	1fa <SendServerHello+0x1fa>
            ret = SendBuffered(ssl);
 1ec:	4620      	mov	r0, r4
 1ee:	f7ff fffe 	bl	0 <SendServerHello>
 1f2:	4605      	mov	r5, r0
 1f4:	e001      	b.n	1fa <SendServerHello+0x1fa>
                return MEMORY_E;
 1f6:	f06f 057c 	mvn.w	r5, #124	; 0x7c
    }
 1fa:	4628      	mov	r0, r5
 1fc:	b008      	add	sp, #32
 1fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 202:	bf00      	nop
 204:	00000000 	.word	0x00000000

Disassembly of section .text.SendServerKeyExchange:

00000000 <SendServerKeyExchange>:
    {
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        if (ssl->async == NULL) {
   4:	6b85      	ldr	r5, [r0, #56]	; 0x38
    {
   6:	b085      	sub	sp, #20
   8:	4604      	mov	r4, r0
        if (ssl->async == NULL) {
   a:	b955      	cbnz	r5, 22 <SendServerKeyExchange+0x22>
                    XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,
   c:	204c      	movs	r0, #76	; 0x4c
   e:	f7ff fffe 	bl	0 <malloc>
            ssl->async = (struct WOLFSSL_ASYNC*)
  12:	63a0      	str	r0, [r4, #56]	; 0x38
            if (ssl->async == NULL)
  14:	2800      	cmp	r0, #0
  16:	f000 8205 	beq.w	424 <SendServerKeyExchange+0x424>
            XMEMSET(ssl->async, 0, sizeof(struct WOLFSSL_ASYNC));
  1a:	224c      	movs	r2, #76	; 0x4c
  1c:	4629      	mov	r1, r5
  1e:	f7ff fffe 	bl	0 <memset>
        if (ssl->options.buildingMsg) {
  22:	f894 7276 	ldrb.w	r7, [r4, #630]	; 0x276
        args = (SskeArgs*)ssl->async->args;
  26:	6ba5      	ldr	r5, [r4, #56]	; 0x38
        if (ssl->options.buildingMsg) {
  28:	f017 0708 	ands.w	r7, r7, #8
  2c:	d011      	beq.n	52 <SendServerKeyExchange+0x52>
            if (ssl->options.asyncState != TLS_ASYNC_END) {
  2e:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
  32:	2b05      	cmp	r3, #5
  34:	f040 81ec 	bne.w	410 <SendServerKeyExchange+0x410>
                ret = SendHandshakeMsg(ssl, args->output, args->length,
  38:	69aa      	ldr	r2, [r5, #24]
  3a:	6869      	ldr	r1, [r5, #4]
  3c:	4620      	mov	r0, r4
  3e:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                if (ret != 0)
  42:	4606      	mov	r6, r0
  44:	2800      	cmp	r0, #0
  46:	f040 8097 	bne.w	178 <SendServerKeyExchange+0x178>
                ssl->options.serverState = SERVER_KEYEXCHANGE_COMPLETE;
  4a:	2307      	movs	r3, #7
  4c:	f884 327c 	strb.w	r3, [r4, #636]	; 0x27c
        if (ret == WANT_WRITE
  50:	e0c3      	b.n	1da <SendServerKeyExchange+0x1da>
            XMEMSET(args, 0, sizeof(SskeArgs));
  52:	222c      	movs	r2, #44	; 0x2c
            ssl->options.asyncState = TLS_ASYNC_BEGIN;
  54:	f884 7283 	strb.w	r7, [r4, #643]	; 0x283
            XMEMSET(args, 0, sizeof(SskeArgs));
  58:	4639      	mov	r1, r7
  5a:	1d28      	adds	r0, r5, #4
  5c:	f7ff fffe 	bl	0 <memset>
            ssl->async->freeArgs = FreeSskeArgs;
  60:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  62:	4a7a      	ldr	r2, [pc, #488]	; (24c <SendServerKeyExchange+0x24c>)
  64:	601a      	str	r2, [r3, #0]
        switch(ssl->options.asyncState)
  66:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
  6a:	2b05      	cmp	r3, #5
  6c:	f200 81d3 	bhi.w	416 <SendServerKeyExchange+0x416>
  70:	a201      	add	r2, pc, #4	; (adr r2, 78 <SendServerKeyExchange+0x78>)
  72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  76:	bf00      	nop
  78:	00000091 	.word	0x00000091
  7c:	000000e7 	.word	0x000000e7
  80:	000000f5 	.word	0x000000f5
  84:	00000105 	.word	0x00000105
  88:	00000143 	.word	0x00000143
  8c:	00000039 	.word	0x00000039
                switch(ssl->specs.kea)
  90:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
  94:	2b07      	cmp	r3, #7
  96:	f040 81c1 	bne.w	41c <SendServerKeyExchange+0x41c>
                        if (ssl->specs.static_ecdh) {
  9a:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
  9e:	2b00      	cmp	r3, #0
  a0:	f040 81bc 	bne.w	41c <SendServerKeyExchange+0x41c>
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
  a4:	e9d4 13a4 	ldrd	r1, r3, [r4, #656]	; 0x290
  a8:	f240 126d 	movw	r2, #365	; 0x16d
  ac:	4291      	cmp	r1, r2
  ae:	d16b      	bne.n	188 <SendServerKeyExchange+0x188>
                            if (ssl->eccTempKey == NULL) {
  b0:	2b00      	cmp	r3, #0
  b2:	d058      	beq.n	166 <SendServerKeyExchange+0x166>
                            if (ssl->eccTempKeyPresent == 0) {
  b4:	f894 3298 	ldrb.w	r3, [r4, #664]	; 0x298
  b8:	b993      	cbnz	r3, e0 <SendServerKeyExchange+0xe0>
        ret = wc_curve25519_make_key(ssl->rng, CURVE25519_KEYSIZE, key);
  ba:	f8d4 2294 	ldr.w	r2, [r4, #660]	; 0x294
  be:	69a0      	ldr	r0, [r4, #24]
  c0:	2120      	movs	r1, #32
  c2:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret == 0) {
  c6:	4606      	mov	r6, r0
  c8:	2800      	cmp	r0, #0
  ca:	f040 81ae 	bne.w	42a <SendServerKeyExchange+0x42a>
        ssl->ecdhCurveOID = ECC_X25519_OID;
  ce:	f240 136d 	movw	r3, #365	; 0x16d
  d2:	f8c4 3290 	str.w	r3, [r4, #656]	; 0x290
                                    ssl->eccTempKeyPresent =
  d6:	2345      	movs	r3, #69	; 0x45
                                ssl->eccTempKeyPresent = DYNAMIC_TYPE_ECC;
  d8:	f884 3298 	strb.w	r3, [r4, #664]	; 0x298
                if (ret != 0) {
  dc:	2e00      	cmp	r6, #0
  de:	d14b      	bne.n	178 <SendServerKeyExchange+0x178>
                ssl->options.asyncState = TLS_ASYNC_BUILD;
  e0:	2301      	movs	r3, #1
  e2:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                switch(ssl->specs.kea)
  e6:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
  ea:	2b07      	cmp	r3, #7
  ec:	d067      	beq.n	1be <SendServerKeyExchange+0x1be>
                ssl->options.asyncState = TLS_ASYNC_DO;
  ee:	2302      	movs	r3, #2
  f0:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                switch(ssl->specs.kea)
  f4:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
  f8:	2b07      	cmp	r3, #7
  fa:	f000 8162 	beq.w	3c2 <SendServerKeyExchange+0x3c2>
                ssl->options.asyncState = TLS_ASYNC_VERIFY;
  fe:	2303      	movs	r3, #3
 100:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                switch(ssl->specs.kea)
 104:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 108:	2b07      	cmp	r3, #7
 10a:	d117      	bne.n	13c <SendServerKeyExchange+0x13c>
                        switch(ssl->options.sigAlgo)
 10c:	f894 327b 	ldrb.w	r3, [r4, #635]	; 0x27b
 110:	2b03      	cmp	r3, #3
 112:	d002      	beq.n	11a <SendServerKeyExchange+0x11a>
 114:	2b09      	cmp	r3, #9
 116:	f040 8096 	bne.w	246 <SendServerKeyExchange+0x246>
                                c16toa((word16)args->sigSz,
 11a:	69eb      	ldr	r3, [r5, #28]
 11c:	692a      	ldr	r2, [r5, #16]
 11e:	6869      	ldr	r1, [r5, #4]
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 120:	f3c3 2607 	ubfx	r6, r3, #8, #8
 124:	1888      	adds	r0, r1, r2
 126:	548e      	strb	r6, [r1, r2]
    c[1] =  (byte)(wc_u16       & 0xff);
 128:	7043      	strb	r3, [r0, #1]
                                args->length += args->sigSz - args->tmpSigSz;
 12a:	696a      	ldr	r2, [r5, #20]
 12c:	69eb      	ldr	r3, [r5, #28]
 12e:	1a9b      	subs	r3, r3, r2
 130:	69aa      	ldr	r2, [r5, #24]
 132:	441a      	add	r2, r3
 134:	61aa      	str	r2, [r5, #24]
                                args->sendSz += args->sigSz - args->tmpSigSz;
 136:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 138:	4413      	add	r3, r2
 13a:	62ab      	str	r3, [r5, #40]	; 0x28
                ssl->options.asyncState = TLS_ASYNC_FINALIZE;
 13c:	2304      	movs	r3, #4
 13e:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                if (ssl->specs.kea == ecdhe_psk_kea ||
 142:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 146:	3b06      	subs	r3, #6
 148:	2b01      	cmp	r3, #1
 14a:	d808      	bhi.n	15e <SendServerKeyExchange+0x15e>
                    if (args->output) {
 14c:	6868      	ldr	r0, [r5, #4]
 14e:	2800      	cmp	r0, #0
 150:	f000 8166 	beq.w	420 <SendServerKeyExchange+0x420>
                        AddHeaders(args->output, args->length,
 154:	69a9      	ldr	r1, [r5, #24]
 156:	4623      	mov	r3, r4
 158:	220c      	movs	r2, #12
 15a:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                ssl->options.asyncState = TLS_ASYNC_END;
 15e:	2305      	movs	r3, #5
 160:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
 164:	e768      	b.n	38 <SendServerKeyExchange+0x38>
                                ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
 166:	f504 7225 	add.w	r2, r4, #660	; 0x294
 16a:	2145      	movs	r1, #69	; 0x45
 16c:	4620      	mov	r0, r4
 16e:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                                if (ret != 0) {
 172:	4606      	mov	r6, r0
 174:	2800      	cmp	r0, #0
 176:	d09d      	beq.n	b4 <SendServerKeyExchange+0xb4>
        if (ret == WANT_WRITE
 178:	f46f 73a3 	mvn.w	r3, #326	; 0x146
 17c:	429e      	cmp	r6, r3
 17e:	d12c      	bne.n	1da <SendServerKeyExchange+0x1da>
    }
 180:	4630      	mov	r0, r6
 182:	b005      	add	sp, #20
 184:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                        if (ssl->eccTempKey == NULL) {
 188:	b17b      	cbz	r3, 1aa <SendServerKeyExchange+0x1aa>
                        if (ssl->eccTempKeyPresent == 0) {
 18a:	f894 2298 	ldrb.w	r2, [r4, #664]	; 0x298
 18e:	2a00      	cmp	r2, #0
 190:	d1a6      	bne.n	e0 <SendServerKeyExchange+0xe0>
                            ret = EccMakeKey(ssl, ssl->eccTempKey, NULL);
 192:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
 196:	4620      	mov	r0, r4
 198:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                            if (ret == 0 || ret == WC_PENDING_E) {
 19c:	4606      	mov	r6, r0
 19e:	b110      	cbz	r0, 1a6 <SendServerKeyExchange+0x1a6>
 1a0:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
 1a4:	d1e8      	bne.n	178 <SendServerKeyExchange+0x178>
                                ssl->eccTempKeyPresent = DYNAMIC_TYPE_ECC;
 1a6:	2325      	movs	r3, #37	; 0x25
 1a8:	e796      	b.n	d8 <SendServerKeyExchange+0xd8>
                            ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
 1aa:	f504 7225 	add.w	r2, r4, #660	; 0x294
 1ae:	2125      	movs	r1, #37	; 0x25
 1b0:	4620      	mov	r0, r4
 1b2:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                            if (ret != 0) {
 1b6:	4606      	mov	r6, r0
 1b8:	2800      	cmp	r0, #0
 1ba:	d0e6      	beq.n	18a <SendServerKeyExchange+0x18a>
 1bc:	e7dc      	b.n	178 <SendServerKeyExchange+0x178>
                        args->idx = RECORD_HEADER_SZ + HANDSHAKE_HEADER_SZ;
 1be:	2309      	movs	r3, #9
 1c0:	612b      	str	r3, [r5, #16]
                        args->exportSz = MAX_EXPORT_ECC_SZ;
 1c2:	f44f 7080 	mov.w	r0, #256	; 0x100
                        args->length = ENUM_LEN + CURVE_LEN + ENUM_LEN;
 1c6:	2304      	movs	r3, #4
 1c8:	61ab      	str	r3, [r5, #24]
                        args->exportSz = MAX_EXPORT_ECC_SZ;
 1ca:	6268      	str	r0, [r5, #36]	; 0x24
                        args->exportBuf = (byte*)XMALLOC(MAX_EXPORT_ECC_SZ,
 1cc:	f7ff fffe 	bl	0 <malloc>
 1d0:	4601      	mov	r1, r0
 1d2:	60a8      	str	r0, [r5, #8]
                        if (args->exportBuf == NULL) {
 1d4:	b978      	cbnz	r0, 1f6 <SendServerKeyExchange+0x1f6>
                            ERROR_OUT(MEMORY_E, exit_sske);
 1d6:	f06f 067c 	mvn.w	r6, #124	; 0x7c
            args->input != NULL) {
 1da:	68e8      	ldr	r0, [r5, #12]
            args != NULL &&
 1dc:	b118      	cbz	r0, 1e6 <SendServerKeyExchange+0x1e6>
            XFREE(args->input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
 1de:	f7ff fffe 	bl	0 <free>
            args->input = NULL;
 1e2:	2300      	movs	r3, #0
 1e4:	60eb      	str	r3, [r5, #12]
        FreeAsyncCtx(ssl, 0);
 1e6:	4620      	mov	r0, r4
 1e8:	2100      	movs	r1, #0
 1ea:	f7ff fffe 	bl	0 <SendServerKeyExchange>
        FreeKeyExchange(ssl);
 1ee:	4620      	mov	r0, r4
 1f0:	f7ff fffe 	bl	0 <SendServerKeyExchange>
        return ret;
 1f4:	e7c4      	b.n	180 <SendServerKeyExchange+0x180>
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 1f6:	f8d4 6290 	ldr.w	r6, [r4, #656]	; 0x290
                                        (curve25519_key*)ssl->eccTempKey,
 1fa:	f8d4 0294 	ldr.w	r0, [r4, #660]	; 0x294
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 1fe:	f240 136d 	movw	r3, #365	; 0x16d
 202:	429e      	cmp	r6, r3
                            if (wc_curve25519_export_public_ex(
 204:	f105 0224 	add.w	r2, r5, #36	; 0x24
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 208:	d111      	bne.n	22e <SendServerKeyExchange+0x22e>
                            if (wc_curve25519_export_public_ex(
 20a:	2300      	movs	r3, #0
 20c:	f7ff fffe 	bl	0 <wc_curve25519_export_public_ex>
 210:	b958      	cbnz	r0, 22a <SendServerKeyExchange+0x22a>
                        args->length += args->exportSz;
 212:	69aa      	ldr	r2, [r5, #24]
 214:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 216:	eb02 0803 	add.w	r8, r2, r3
                        if (ssl->buffers.key == NULL) {
 21a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
                        args->length += args->exportSz;
 21e:	f8c5 8018 	str.w	r8, [r5, #24]
                        if (ssl->buffers.key == NULL) {
 222:	b93b      	cbnz	r3, 234 <SendServerKeyExchange+0x234>
                                ERROR_OUT(NO_PRIVATE_KEY, exit_sske);
 224:	f46f 769e 	mvn.w	r6, #316	; 0x13c
 228:	e7d7      	b.n	1da <SendServerKeyExchange+0x1da>
                                ERROR_OUT(ECC_EXPORT_ERROR, exit_sske);
 22a:	4e09      	ldr	r6, [pc, #36]	; (250 <SendServerKeyExchange+0x250>)
 22c:	e7d5      	b.n	1da <SendServerKeyExchange+0x1da>
                            ret = wc_ecc_export_x963(ssl->eccTempKey,
 22e:	f7ff fffe 	bl	0 <wc_ecc_export_x963>
 232:	e7ed      	b.n	210 <SendServerKeyExchange+0x210>
                            switch(ssl->options.sigAlgo) {
 234:	f894 327b 	ldrb.w	r3, [r4, #635]	; 0x27b
                        preSigIdx = args->idx;
 238:	f8d5 9010 	ldr.w	r9, [r5, #16]
                            switch(ssl->options.sigAlgo) {
 23c:	2b03      	cmp	r3, #3
 23e:	d009      	beq.n	254 <SendServerKeyExchange+0x254>
 240:	2b09      	cmp	r3, #9
 242:	f000 8091 	beq.w	368 <SendServerKeyExchange+0x368>
                            ERROR_OUT(ALGO_ID_E, exit_sske);
 246:	f06f 0684 	mvn.w	r6, #132	; 0x84
 24a:	e7c6      	b.n	1da <SendServerKeyExchange+0x1da>
 24c:	00000000 	.word	0x00000000
 250:	fffffe9e 	.word	0xfffffe9e
                                ssl->buffers.keyType = ecc_dsa_sa_algo;
 254:	f894 20e4 	ldrb.w	r2, [r4, #228]	; 0xe4
 258:	f363 0205 	bfi	r2, r3, #0, #6
 25c:	f884 20e4 	strb.w	r2, [r4, #228]	; 0xe4
                                ret = DecodePrivateKey(ssl, &keySz);
 260:	f10d 010e 	add.w	r1, sp, #14
 264:	4620      	mov	r0, r4
 266:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                                if (ret != 0) {
 26a:	4606      	mov	r6, r0
 26c:	2800      	cmp	r0, #0
 26e:	d183      	bne.n	178 <SendServerKeyExchange+0x178>
                                args->tmpSigSz = keySz;
 270:	f8bd 300e 	ldrh.w	r3, [sp, #14]
                                args->tmpSigSz = ED25519_SIG_SIZE;
 274:	616b      	str	r3, [r5, #20]
                        args->length += args->tmpSigSz;
 276:	e9d5 3205 	ldrd	r3, r2, [r5, #20]
 27a:	441a      	add	r2, r3
 27c:	1c93      	adds	r3, r2, #2
 27e:	61ab      	str	r3, [r5, #24]
                        if (IsAtLeastTLSv1_2(ssl)) {
 280:	4620      	mov	r0, r4
 282:	f7ff fffe 	bl	0 <SendServerKeyExchange>
 286:	b108      	cbz	r0, 28c <SendServerKeyExchange+0x28c>
                            args->length += HASH_SIG_SIZE;
 288:	3204      	adds	r2, #4
 28a:	61aa      	str	r2, [r5, #24]
                        args->sendSz = args->length + HANDSHAKE_HEADER_SZ + RECORD_HEADER_SZ;
 28c:	69aa      	ldr	r2, [r5, #24]
 28e:	f102 0309 	add.w	r3, r2, #9
 292:	62ab      	str	r3, [r5, #40]	; 0x28
                        if (IsEncryptionOn(ssl, 1)) {
 294:	2101      	movs	r1, #1
 296:	4620      	mov	r0, r4
 298:	f7ff fffe 	bl	0 <SendServerKeyExchange>
 29c:	b108      	cbz	r0, 2a2 <SendServerKeyExchange+0x2a2>
                            args->sendSz += MAX_MSG_EXTRA;
 29e:	326f      	adds	r2, #111	; 0x6f
 2a0:	62aa      	str	r2, [r5, #40]	; 0x28
                        args->input = (byte*)XMALLOC(args->sendSz,
 2a2:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 2a4:	f7ff fffe 	bl	0 <malloc>
 2a8:	60e8      	str	r0, [r5, #12]
                        if (args->input == NULL)
 2aa:	2800      	cmp	r0, #0
 2ac:	d093      	beq.n	1d6 <SendServerKeyExchange+0x1d6>
                        args->output[args->idx++] = named_curve;
 2ae:	692b      	ldr	r3, [r5, #16]
                        args->output = args->input;
 2b0:	6068      	str	r0, [r5, #4]
                        args->output[args->idx++] = named_curve;
 2b2:	1c5a      	adds	r2, r3, #1
 2b4:	612a      	str	r2, [r5, #16]
 2b6:	2203      	movs	r2, #3
 2b8:	54c2      	strb	r2, [r0, r3]
                        args->output[args->idx++] = 0x00;          /* leading zero */
 2ba:	692b      	ldr	r3, [r5, #16]
 2bc:	686a      	ldr	r2, [r5, #4]
 2be:	1c59      	adds	r1, r3, #1
 2c0:	6129      	str	r1, [r5, #16]
 2c2:	2100      	movs	r1, #0
 2c4:	54d1      	strb	r1, [r2, r3]
                        if (ssl->ecdhCurveOID == ECC_X25519_OID)
 2c6:	f8d4 2290 	ldr.w	r2, [r4, #656]	; 0x290
 2ca:	f240 136d 	movw	r3, #365	; 0x16d
 2ce:	429a      	cmp	r2, r3
 2d0:	692b      	ldr	r3, [r5, #16]
 2d2:	686a      	ldr	r2, [r5, #4]
 2d4:	d159      	bne.n	38a <SendServerKeyExchange+0x38a>
                            args->output[args->idx++] = WOLFSSL_ECC_X25519;
 2d6:	1c59      	adds	r1, r3, #1
 2d8:	6129      	str	r1, [r5, #16]
 2da:	211d      	movs	r1, #29
 2dc:	54d1      	strb	r1, [r2, r3]
                        args->output[args->idx++] = (byte)args->exportSz;
 2de:	692b      	ldr	r3, [r5, #16]
 2e0:	686a      	ldr	r2, [r5, #4]
 2e2:	6a69      	ldr	r1, [r5, #36]	; 0x24
 2e4:	1c58      	adds	r0, r3, #1
 2e6:	6128      	str	r0, [r5, #16]
 2e8:	54d1      	strb	r1, [r2, r3]
                        XMEMCPY(args->output + args->idx, args->exportBuf, args->exportSz);
 2ea:	692b      	ldr	r3, [r5, #16]
 2ec:	6868      	ldr	r0, [r5, #4]
 2ee:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 2f0:	68a9      	ldr	r1, [r5, #8]
 2f2:	4418      	add	r0, r3
 2f4:	f7ff fffe 	bl	0 <memcpy>
                        args->idx += args->exportSz;
 2f8:	692a      	ldr	r2, [r5, #16]
 2fa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 2fc:	441a      	add	r2, r3
 2fe:	612a      	str	r2, [r5, #16]
                        if (IsAtLeastTLSv1_2(ssl)) {
 300:	4620      	mov	r0, r4
 302:	f7ff fffe 	bl	0 <SendServerKeyExchange>
 306:	2800      	cmp	r0, #0
 308:	d09d      	beq.n	246 <SendServerKeyExchange+0x246>
                            EncodeSigAlg(ssl->options.hashAlgo,
 30a:	f894 127b 	ldrb.w	r1, [r4, #635]	; 0x27b
 30e:	686b      	ldr	r3, [r5, #4]
    switch (hsType) {
 310:	2903      	cmp	r1, #3
                            EncodeSigAlg(ssl->options.hashAlgo,
 312:	eb03 0002 	add.w	r0, r3, r2
    switch (hsType) {
 316:	d048      	beq.n	3aa <SendServerKeyExchange+0x3aa>
 318:	2909      	cmp	r1, #9
 31a:	d04b      	beq.n	3b4 <SendServerKeyExchange+0x3b4>
                            args->idx += 2;
 31c:	692b      	ldr	r3, [r5, #16]
 31e:	3302      	adds	r3, #2
 320:	612b      	str	r3, [r5, #16]
                            hashType = HashAlgoToType(ssl->options.hashAlgo);
 322:	f894 327a 	ldrb.w	r3, [r4, #634]	; 0x27a
    switch (hashAlgo) {
 326:	2b04      	cmp	r3, #4
 328:	d049      	beq.n	3be <SendServerKeyExchange+0x3be>
 32a:	2b06      	cmp	r3, #6
 32c:	d18b      	bne.n	246 <SendServerKeyExchange+0x246>
            return WC_HASH_TYPE_SHA512;
 32e:	2108      	movs	r1, #8
                            args->output + preSigIdx, preSigSz,
 330:	686a      	ldr	r2, [r5, #4]
                        ret = HashSkeData(ssl, hashType,
 332:	f894 327b 	ldrb.w	r3, [r4, #635]	; 0x27b
 336:	9300      	str	r3, [sp, #0]
 338:	444a      	add	r2, r9
 33a:	4643      	mov	r3, r8
 33c:	4620      	mov	r0, r4
 33e:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                        if (ret != 0) {
 342:	4606      	mov	r6, r0
 344:	2800      	cmp	r0, #0
 346:	f47f af17 	bne.w	178 <SendServerKeyExchange+0x178>
                        args->sigSz = args->tmpSigSz;
 34a:	696b      	ldr	r3, [r5, #20]
 34c:	61eb      	str	r3, [r5, #28]
                        switch (ssl->options.sigAlgo)
 34e:	f894 327b 	ldrb.w	r3, [r4, #635]	; 0x27b
 352:	2b09      	cmp	r3, #9
 354:	f47f aecb 	bne.w	ee <SendServerKeyExchange+0xee>
                                ret = Ed25519CheckPubKey(ssl);
 358:	4620      	mov	r0, r4
 35a:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                                if (ret != 0)
 35e:	4606      	mov	r6, r0
 360:	2800      	cmp	r0, #0
 362:	f43f aec4 	beq.w	ee <SendServerKeyExchange+0xee>
 366:	e707      	b.n	178 <SendServerKeyExchange+0x178>
                                ssl->buffers.keyType = ed25519_sa_algo;
 368:	f894 20e4 	ldrb.w	r2, [r4, #228]	; 0xe4
 36c:	f363 0205 	bfi	r2, r3, #0, #6
 370:	f884 20e4 	strb.w	r2, [r4, #228]	; 0xe4
                                ret = DecodePrivateKey(ssl, &keySz);
 374:	f10d 010e 	add.w	r1, sp, #14
 378:	4620      	mov	r0, r4
 37a:	f7ff fffe 	bl	0 <SendServerKeyExchange>
                                if (ret != 0) {
 37e:	4606      	mov	r6, r0
 380:	2800      	cmp	r0, #0
 382:	f47f aef9 	bne.w	178 <SendServerKeyExchange+0x178>
                                args->tmpSigSz = ED25519_SIG_SIZE;
 386:	2340      	movs	r3, #64	; 0x40
 388:	e774      	b.n	274 <SendServerKeyExchange+0x274>
                                                    SetCurveId(ssl->eccTempKey);
 38a:	f8d4 1294 	ldr.w	r1, [r4, #660]	; 0x294
                            args->output[args->idx++] =
 38e:	1c58      	adds	r0, r3, #1
 390:	6128      	str	r0, [r5, #16]
        if (key == NULL || key->dp == NULL) {
 392:	b141      	cbz	r1, 3a6 <SendServerKeyExchange+0x3a6>
 394:	6909      	ldr	r1, [r1, #16]
 396:	b131      	cbz	r1, 3a6 <SendServerKeyExchange+0x3a6>
        switch(oidSum) {
 398:	6acf      	ldr	r7, [r1, #44]	; 0x2c
        return (byte)GetCurveByOID(key->dp->oidSum);
 39a:	f240 210e 	movw	r1, #526	; 0x20e
 39e:	428f      	cmp	r7, r1
 3a0:	bf0c      	ite	eq
 3a2:	2717      	moveq	r7, #23
 3a4:	2700      	movne	r7, #0
                            args->output[args->idx++] =
 3a6:	54d7      	strb	r7, [r2, r3]
 3a8:	e799      	b.n	2de <SendServerKeyExchange+0x2de>
                            EncodeSigAlg(ssl->options.hashAlgo,
 3aa:	f894 627a 	ldrb.w	r6, [r4, #634]	; 0x27a
            output[0] = hashAlgo;
 3ae:	549e      	strb	r6, [r3, r2]
            output[1] = ecc_dsa_sa_algo;
 3b0:	7041      	strb	r1, [r0, #1]
            break;
 3b2:	e7b3      	b.n	31c <SendServerKeyExchange+0x31c>
            output[0] = ED25519_SA_MAJOR;
 3b4:	2108      	movs	r1, #8
 3b6:	5499      	strb	r1, [r3, r2]
            output[1] = ED25519_SA_MINOR;
 3b8:	2307      	movs	r3, #7
 3ba:	7043      	strb	r3, [r0, #1]
            break;
 3bc:	e7ae      	b.n	31c <SendServerKeyExchange+0x31c>
    switch (hashAlgo) {
 3be:	2106      	movs	r1, #6
 3c0:	e7b6      	b.n	330 <SendServerKeyExchange+0x330>
                        switch (ssl->options.sigAlgo)
 3c2:	f894 327b 	ldrb.w	r3, [r4, #635]	; 0x27b
 3c6:	2b03      	cmp	r3, #3
 3c8:	d00f      	beq.n	3ea <SendServerKeyExchange+0x3ea>
 3ca:	2b09      	cmp	r3, #9
 3cc:	f47f af3b 	bne.w	246 <SendServerKeyExchange+0x246>
                                    args->output + LENGTH_SZ + args->idx,
 3d0:	692a      	ldr	r2, [r5, #16]
                                ret = Ed25519Sign(ssl,
 3d2:	6869      	ldr	r1, [r5, #4]
        ret = wc_ed25519_sign_msg(in, inSz, out, outSz, key);
 3d4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 3d6:	9300      	str	r3, [sp, #0]
                                    args->output + LENGTH_SZ + args->idx,
 3d8:	3202      	adds	r2, #2
        ret = wc_ed25519_sign_msg(in, inSz, out, outSz, key);
 3da:	440a      	add	r2, r1
 3dc:	f105 031c 	add.w	r3, r5, #28
 3e0:	e9d4 0130 	ldrd	r0, r1, [r4, #192]	; 0xc0
 3e4:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
 3e8:	e00d      	b.n	406 <SendServerKeyExchange+0x406>
                                    args->output + LENGTH_SZ + args->idx,
 3ea:	692a      	ldr	r2, [r5, #16]
                                ret = EccSign(ssl,
 3ec:	6869      	ldr	r1, [r5, #4]
        ret = wc_ecc_sign_hash(in, inSz, out, outSz, ssl->rng, key);
 3ee:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 3f0:	9301      	str	r3, [sp, #4]
                                    args->output + LENGTH_SZ + args->idx,
 3f2:	3202      	adds	r2, #2
        ret = wc_ecc_sign_hash(in, inSz, out, outSz, ssl->rng, key);
 3f4:	69a3      	ldr	r3, [r4, #24]
 3f6:	9300      	str	r3, [sp, #0]
 3f8:	440a      	add	r2, r1
 3fa:	f105 031c 	add.w	r3, r5, #28
 3fe:	e9d4 0132 	ldrd	r0, r1, [r4, #200]	; 0xc8
 402:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
        ret = wc_ed25519_sign_msg(in, inSz, out, outSz, key);
 406:	4606      	mov	r6, r0
                if (ret != 0) {
 408:	2800      	cmp	r0, #0
 40a:	f47f aeb5 	bne.w	178 <SendServerKeyExchange+0x178>
 40e:	e676      	b.n	fe <SendServerKeyExchange+0xfe>
                ret = BAD_STATE_E;
 410:	f06f 06bf 	mvn.w	r6, #191	; 0xbf
 414:	e6e1      	b.n	1da <SendServerKeyExchange+0x1da>
        switch(ssl->options.asyncState)
 416:	f46f 7696 	mvn.w	r6, #300	; 0x12c
 41a:	e6de      	b.n	1da <SendServerKeyExchange+0x1da>
 41c:	2600      	movs	r6, #0
 41e:	e6dc      	b.n	1da <SendServerKeyExchange+0x1da>
                        ERROR_OUT(BUFFER_ERROR, exit_sske);
 420:	4e04      	ldr	r6, [pc, #16]	; (434 <SendServerKeyExchange+0x434>)
 422:	e6da      	b.n	1da <SendServerKeyExchange+0x1da>
                ERROR_OUT(MEMORY_E, exit_sske);
 424:	f06f 067c 	mvn.w	r6, #124	; 0x7c
 428:	e6dd      	b.n	1e6 <SendServerKeyExchange+0x1e6>
                                if (ret == 0 || ret == WC_PENDING_E) {
 42a:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
 42e:	f47f aea3 	bne.w	178 <SendServerKeyExchange+0x178>
 432:	e650      	b.n	d6 <SendServerKeyExchange+0xd6>
 434:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.MatchSuite_ex:

00000000 <MatchSuite_ex>:

    int MatchSuite_ex(const WOLFSSL* ssl, Suites* peerSuites, CipherSuite* cs,
                      TLSX* extensions)
    {
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
        int ret;
        word16 i, j;
        const Suites* suites = WOLFSSL_SUITES(ssl);
   4:	6846      	ldr	r6, [r0, #4]
    {
   6:	4607      	mov	r7, r0
   8:	460d      	mov	r5, r1
   a:	4690      	mov	r8, r2
        const Suites* suites = WOLFSSL_SUITES(ssl);
   c:	b90e      	cbnz	r6, 12 <MatchSuite_ex+0x12>
   e:	6803      	ldr	r3, [r0, #0]
  10:	6ade      	ldr	r6, [r3, #44]	; 0x2c

        WOLFSSL_ENTER("MatchSuite");

        /* & 0x1 equivalent % 2 */
        if (peerSuites->suiteSz == 0 || peerSuites->suiteSz & 0x1)
  12:	882c      	ldrh	r4, [r5, #0]
  14:	2c00      	cmp	r4, #0
  16:	d046      	beq.n	a6 <MatchSuite_ex+0xa6>
  18:	f014 0401 	ands.w	r4, r4, #1
  1c:	d143      	bne.n	a6 <MatchSuite_ex+0xa6>
            return BUFFER_ERROR;

        if (suites == NULL)
  1e:	2e00      	cmp	r6, #0
  20:	d043      	beq.n	aa <MatchSuite_ex+0xaa>
            return SUITES_ERROR;

        if (!ssl->options.useClientOrder) {
  22:	f997 3275 	ldrsb.w	r3, [r7, #629]	; 0x275
  26:	2b00      	cmp	r3, #0
  28:	da2b      	bge.n	82 <MatchSuite_ex+0x82>
            }
        }
        else {
            /* Client order */
            for (j = 0; j < peerSuites->suiteSz; j += 2) {
                for (i = 0; i < suites->suiteSz; i += 2) {
  2a:	46a2      	mov	sl, r4
                    ret = CompareSuites(ssl, suites, peerSuites, i, j, cs, extensions);
                    if (ret != MATCH_SUITE_ERROR)
  2c:	f46f 79fa 	mvn.w	r9, #500	; 0x1f4
                for (i = 0; i < suites->suiteSz; i += 2) {
  30:	8833      	ldrh	r3, [r6, #0]
  32:	4553      	cmp	r3, sl
  34:	d828      	bhi.n	88 <MatchSuite_ex+0x88>
            for (j = 0; j < peerSuites->suiteSz; j += 2) {
  36:	882b      	ldrh	r3, [r5, #0]
  38:	3402      	adds	r4, #2
  3a:	b2a4      	uxth	r4, r4
  3c:	42a3      	cmp	r3, r4
  3e:	d918      	bls.n	72 <MatchSuite_ex+0x72>
                for (i = 0; i < suites->suiteSz; i += 2) {
  40:	f04f 0a00 	mov.w	sl, #0
  44:	e7f4      	b.n	30 <MatchSuite_ex+0x30>
                    ret = CompareSuites(ssl, suites, peerSuites, i, j, cs, extensions);
  46:	e9cd 9800 	strd	r9, r8, [sp]
  4a:	4623      	mov	r3, r4
  4c:	462a      	mov	r2, r5
  4e:	4631      	mov	r1, r6
  50:	4638      	mov	r0, r7
  52:	f7ff fffe 	bl	0 <MatchSuite_ex>
                    if (ret != MATCH_SUITE_ERROR)
  56:	4550      	cmp	r0, sl
  58:	d10d      	bne.n	76 <MatchSuite_ex+0x76>
                for (j = 0; j < peerSuites->suiteSz; j += 2) {
  5a:	f109 0902 	add.w	r9, r9, #2
  5e:	fa1f f989 	uxth.w	r9, r9
  62:	882b      	ldrh	r3, [r5, #0]
  64:	454b      	cmp	r3, r9
  66:	d8ee      	bhi.n	46 <MatchSuite_ex+0x46>
            for (i = 0; i < suites->suiteSz; i += 2) {
  68:	3402      	adds	r4, #2
  6a:	b2a4      	uxth	r4, r4
  6c:	8833      	ldrh	r3, [r6, #0]
  6e:	42a3      	cmp	r3, r4
  70:	d804      	bhi.n	7c <MatchSuite_ex+0x7c>
                }
            }
        }

        WOLFSSL_ERROR_VERBOSE(MATCH_SUITE_ERROR);
        return MATCH_SUITE_ERROR;
  72:	f46f 70fa 	mvn.w	r0, #500	; 0x1f4

    }
  76:	b002      	add	sp, #8
  78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                for (j = 0; j < peerSuites->suiteSz; j += 2) {
  7c:	f04f 0900 	mov.w	r9, #0
  80:	e7ef      	b.n	62 <MatchSuite_ex+0x62>
                    if (ret != MATCH_SUITE_ERROR)
  82:	f46f 7afa 	mvn.w	sl, #500	; 0x1f4
  86:	e7f1      	b.n	6c <MatchSuite_ex+0x6c>
                    ret = CompareSuites(ssl, suites, peerSuites, i, j, cs, extensions);
  88:	e9cd 4800 	strd	r4, r8, [sp]
  8c:	4653      	mov	r3, sl
  8e:	462a      	mov	r2, r5
  90:	4631      	mov	r1, r6
  92:	4638      	mov	r0, r7
  94:	f7ff fffe 	bl	0 <MatchSuite_ex>
                    if (ret != MATCH_SUITE_ERROR)
  98:	4548      	cmp	r0, r9
  9a:	d1ec      	bne.n	76 <MatchSuite_ex+0x76>
                for (i = 0; i < suites->suiteSz; i += 2) {
  9c:	f10a 0a02 	add.w	sl, sl, #2
  a0:	fa1f fa8a 	uxth.w	sl, sl
  a4:	e7c4      	b.n	30 <MatchSuite_ex+0x30>
            return BUFFER_ERROR;
  a6:	4802      	ldr	r0, [pc, #8]	; (b0 <MatchSuite_ex+0xb0>)
  a8:	e7e5      	b.n	76 <MatchSuite_ex+0x76>
            return SUITES_ERROR;
  aa:	f46f 70b9 	mvn.w	r0, #370	; 0x172
  ae:	e7e2      	b.n	76 <MatchSuite_ex+0x76>
  b0:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.MatchSuite:

00000000 <MatchSuite>:

    int MatchSuite(WOLFSSL* ssl, Suites* peerSuites)
    {
   0:	b530      	push	{r4, r5, lr}
   2:	4604      	mov	r4, r0
   4:	b085      	sub	sp, #20
   6:	460d      	mov	r5, r1
        int ret;
        CipherSuite cs;

        XMEMSET(&cs, 0, sizeof(cs));
   8:	220c      	movs	r2, #12
   a:	2100      	movs	r1, #0
   c:	a801      	add	r0, sp, #4
   e:	f7ff fffe 	bl	0 <memset>

        ret = MatchSuite_ex(ssl, peerSuites, &cs,
  12:	f8d4 32c0 	ldr.w	r3, [r4, #704]	; 0x2c0
  16:	aa01      	add	r2, sp, #4
  18:	4629      	mov	r1, r5
  1a:	4620      	mov	r0, r4
  1c:	f7ff fffe 	bl	0 <MatchSuite>
                ssl->extensions
#else
                NULL
#endif
                );
        if (ret != 0)
  20:	b980      	cbnz	r0, 44 <MatchSuite+0x44>
            return ret;

        ssl->options.cipherSuite0 = cs.cipherSuite0;
  22:	f8bd 3004 	ldrh.w	r3, [sp, #4]
  26:	f8a4 3278 	strh.w	r3, [r4, #632]	; 0x278
        ssl->options.cipherSuite  = cs.cipherSuite;
#if defined(HAVE_ECC) || defined(HAVE_ED25519) || defined(HAVE_CURVE25519) || \
    defined(HAVE_ED448) || defined(HAVE_CURVE448)
        ssl->ecdhCurveOID = cs.ecdhCurveOID;
  2a:	9b02      	ldr	r3, [sp, #8]
  2c:	f8c4 3290 	str.w	r3, [r4, #656]	; 0x290
#endif

        ret = SetCipherSpecs(ssl);
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <SetCipherSpecs>
        if (ret != 0)
  36:	b928      	cbnz	r0, 44 <MatchSuite+0x44>
            return ret;
        ret = PickHashSigAlgo(ssl, peerSuites->hashSigAlgo,
  38:	886a      	ldrh	r2, [r5, #2]
  3a:	f505 7198 	add.w	r1, r5, #304	; 0x130
  3e:	4620      	mov	r0, r4
  40:	f7ff fffe 	bl	0 <MatchSuite>
            if (ret != 0)
                return ret;
        }
#endif
        return ret;
    }
  44:	b005      	add	sp, #20
  46:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.HandleTlsResumption:

00000000 <HandleTlsResumption>:
     *  judged expired, falls back to full-handshake. If you want disable this
     *  session ticket validation check in TLS1.2 and below, define
     *  WOLFSSL_NO_TICKET_EXPIRE.
     */
    int HandleTlsResumption(WOLFSSL* ssl, Suites* clSuites)
    {
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460e      	mov	r6, r1
            session = ssl->session;
        }
        else
    #endif
        {
            session = wolfSSL_GetSession(ssl, ssl->arrays->masterSecret, 1);
   4:	6881      	ldr	r1, [r0, #8]
   6:	2201      	movs	r2, #1
   8:	3175      	adds	r1, #117	; 0x75
    {
   a:	4604      	mov	r4, r0
            session = wolfSSL_GetSession(ssl, ssl->arrays->masterSecret, 1);
   c:	f7ff fffe 	bl	0 <wolfSSL_GetSession>
        }
        if (!session) {
  10:	4605      	mov	r5, r0
  12:	b938      	cbnz	r0, 24 <HandleTlsResumption+0x24>
            WOLFSSL_MSG("Session lookup for resume failed");
            ssl->options.resuming = 0;
  14:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  18:	f36f 03c3 	bfc	r3, #3, #1
  1c:	f884 3271 	strb.w	r3, [r4, #625]	; 0x271
            return ret;
  20:	2000      	movs	r0, #0
            }
        }


        return ret;
    }
  22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (LowResTimer() > session->bornOn + ssl->timeout) {
  24:	f7ff fffe 	bl	0 <LowResTimer>
  28:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  2a:	f8d4 2128 	ldr.w	r2, [r4, #296]	; 0x128
  2e:	4413      	add	r3, r2
  30:	4298      	cmp	r0, r3
  32:	d8ef      	bhi.n	14 <HandleTlsResumption+0x14>
        else if (session->haveEMS != ssl->options.haveEMS) {
  34:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
  38:	f8b5 208e 	ldrh.w	r2, [r5, #142]	; 0x8e
  3c:	f3c3 01c0 	ubfx	r1, r3, #3, #1
  40:	4291      	cmp	r1, r2
  42:	d107      	bne.n	54 <HandleTlsResumption+0x54>
            for (j = 0; j < clSuites->suiteSz; j += 2) {
  44:	8831      	ldrh	r1, [r6, #0]
  46:	4633      	mov	r3, r6
  48:	2200      	movs	r2, #0
  4a:	4291      	cmp	r1, r2
  4c:	dc0d      	bgt.n	6a <HandleTlsResumption+0x6a>
            if (j == clSuites->suiteSz) {
  4e:	d119      	bne.n	84 <HandleTlsResumption+0x84>
                ret = UNSUPPORTED_SUITE;
  50:	4828      	ldr	r0, [pc, #160]	; (f4 <HandleTlsResumption+0xf4>)
  52:	e7e6      	b.n	22 <HandleTlsResumption+0x22>
            if (!session->haveEMS && ssl->options.haveEMS) {
  54:	f003 0008 	and.w	r0, r3, #8
  58:	b912      	cbnz	r2, 60 <HandleTlsResumption+0x60>
  5a:	2800      	cmp	r0, #0
  5c:	d1da      	bne.n	14 <HandleTlsResumption+0x14>
  5e:	e7e0      	b.n	22 <HandleTlsResumption+0x22>
                ret = EXT_MASTER_SECRET_NEEDED_E;
  60:	2800      	cmp	r0, #0
  62:	4825      	ldr	r0, [pc, #148]	; (f8 <HandleTlsResumption+0xf8>)
  64:	bf18      	it	ne
  66:	2000      	movne	r0, #0
  68:	e7db      	b.n	22 <HandleTlsResumption+0x22>
                if (clSuites->suites[j] == session->cipherSuite0 &&
  6a:	791f      	ldrb	r7, [r3, #4]
  6c:	f895 0090 	ldrb.w	r0, [r5, #144]	; 0x90
  70:	4287      	cmp	r7, r0
  72:	d104      	bne.n	7e <HandleTlsResumption+0x7e>
  74:	795f      	ldrb	r7, [r3, #5]
  76:	f895 0091 	ldrb.w	r0, [r5, #145]	; 0x91
  7a:	4287      	cmp	r7, r0
  7c:	d002      	beq.n	84 <HandleTlsResumption+0x84>
            for (j = 0; j < clSuites->suiteSz; j += 2) {
  7e:	3202      	adds	r2, #2
  80:	3302      	adds	r3, #2
  82:	e7e2      	b.n	4a <HandleTlsResumption+0x4a>
            if (ret == 0 && ssl->options.resuming) {
  84:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  88:	071b      	lsls	r3, r3, #28
  8a:	d52c      	bpl.n	e6 <HandleTlsResumption+0xe6>
                ssl->options.cipherSuite0 = session->cipherSuite0;
  8c:	f895 3090 	ldrb.w	r3, [r5, #144]	; 0x90
  90:	f884 3278 	strb.w	r3, [r4, #632]	; 0x278
                ssl->options.cipherSuite =  session->cipherSuite;
  94:	f895 3091 	ldrb.w	r3, [r5, #145]	; 0x91
  98:	f884 3279 	strb.w	r3, [r4, #633]	; 0x279
                ret = SetCipherSpecs(ssl);
  9c:	4620      	mov	r0, r4
  9e:	f7ff fffe 	bl	0 <SetCipherSpecs>
                if (ret == 0) {
  a2:	2800      	cmp	r0, #0
  a4:	d1bd      	bne.n	22 <HandleTlsResumption+0x22>
                    ret = PickHashSigAlgo(ssl, clSuites->hashSigAlgo,
  a6:	8872      	ldrh	r2, [r6, #2]
  a8:	f506 7198 	add.w	r1, r6, #304	; 0x130
  ac:	4620      	mov	r0, r4
  ae:	f7ff fffe 	bl	0 <HandleTlsResumption>
            if (ret == 0) {
  b2:	2800      	cmp	r0, #0
  b4:	d1b5      	bne.n	22 <HandleTlsResumption+0x22>
                                           ssl->arrays->serverRandom, RAN_LEN);
  b6:	68a1      	ldr	r1, [r4, #8]
                ret = wc_RNG_GenerateBlock(ssl->rng,
  b8:	69a0      	ldr	r0, [r4, #24]
  ba:	2220      	movs	r2, #32
  bc:	3134      	adds	r1, #52	; 0x34
  be:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
            if (ret == 0) {
  c2:	2800      	cmp	r0, #0
  c4:	d1ad      	bne.n	22 <HandleTlsResumption+0x22>
                    ret = DeriveTlsKeys(ssl);
  c6:	4620      	mov	r0, r4
  c8:	f7ff fffe 	bl	0 <DeriveTlsKeys>
                ssl->options.peerAuthGood = (ret == 0);
  cc:	f894 2276 	ldrb.w	r2, [r4, #630]	; 0x276
  d0:	fab0 f380 	clz	r3, r0
  d4:	095b      	lsrs	r3, r3, #5
  d6:	f363 0241 	bfi	r2, r3, #1, #1
                ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
  da:	230d      	movs	r3, #13
                ssl->options.peerAuthGood = (ret == 0);
  dc:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
                ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
  e0:	f884 327d 	strb.w	r3, [r4, #637]	; 0x27d
  e4:	e79d      	b.n	22 <HandleTlsResumption+0x22>
                if (MatchSuite(ssl, clSuites) < 0) {
  e6:	4631      	mov	r1, r6
  e8:	4620      	mov	r0, r4
  ea:	f7ff fffe 	bl	0 <HandleTlsResumption>
  ee:	2800      	cmp	r0, #0
  f0:	dae1      	bge.n	b6 <HandleTlsResumption+0xb6>
  f2:	e7ad      	b.n	50 <HandleTlsResumption+0x50>
  f4:	fffffe0c 	.word	0xfffffe0c
  f8:	fffffe62 	.word	0xfffffe62

Disassembly of section .text.DoClientHello:

00000000 <DoClientHello>:


    /* handle processing of client_hello (1) */
    int DoClientHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,
                             word32 helloSz)
    {
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4698      	mov	r8, r3
        }
        ssl->options.dtlsStateful = 1;
#endif /* WOLFSSL_DTLS */

        /* Reset to sane value for SCR */
        ssl->options.resuming = 0;
   6:	f890 3271 	ldrb.w	r3, [r0, #625]	; 0x271
        word32          i = *inOutIdx;
   a:	6815      	ldr	r5, [r2, #0]
        ssl->options.resuming = 0;
   c:	f36f 03c3 	bfc	r3, #3, #1
  10:	f880 3271 	strb.w	r3, [r0, #625]	; 0x271
        ssl->arrays->sessionIDSz = 0;
  14:	6883      	ldr	r3, [r0, #8]
    {
  16:	4692      	mov	sl, r2

        /* protocol version, random and session id length check */
        if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
  18:	f1b8 0f22 	cmp.w	r8, #34	; 0x22
        ssl->arrays->sessionIDSz = 0;
  1c:	f04f 0200 	mov.w	r2, #0
    {
  20:	b091      	sub	sp, #68	; 0x44
  22:	4604      	mov	r4, r0
  24:	460f      	mov	r7, r1
        ssl->arrays->sessionIDSz = 0;
  26:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
        if (OPAQUE16_LEN + RAN_LEN + OPAQUE8_LEN > helloSz)
  2a:	f240 81d6 	bls.w	3da <DoClientHello+0x3da>
            return BUFFER_ERROR;

        /* protocol version */
        XMEMCPY(&pv, input + i, OPAQUE16_LEN);
  2e:	194e      	adds	r6, r1, r5
  30:	2202      	movs	r2, #2
  32:	4631      	mov	r1, r6
  34:	a80f      	add	r0, sp, #60	; 0x3c
  36:	f7ff fffe 	bl	0 <memcpy>
        ssl->chVersion = pv;   /* store */
  3a:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
  3e:	f8a4 313e 	strh.w	r3, [r4, #318]	; 0x13e
        i += OPAQUE16_LEN;

        /* Legacy protocol version cannot negotiate TLS 1.3 or higher. */
        if (pv.major == SSLv3_MAJOR && pv.minor >= TLSv1_3_MINOR)
  42:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
  46:	2b03      	cmp	r3, #3
  48:	d105      	bne.n	56 <DoClientHello+0x56>
  4a:	f89d 203d 	ldrb.w	r2, [sp, #61]	; 0x3d
  4e:	2a03      	cmp	r2, #3
            pv.minor = TLSv1_2_MINOR;
  50:	bf88      	it	hi
  52:	f88d 303d 	strbhi.w	r3, [sp, #61]	; 0x3d

        lesserVersion = !ssl->options.dtls && ssl->version.minor > pv.minor;
  56:	f894 1272 	ldrb.w	r1, [r4, #626]	; 0x272
  5a:	f894 213d 	ldrb.w	r2, [r4, #317]	; 0x13d
  5e:	f89d 303d 	ldrb.w	r3, [sp, #61]	; 0x3d
  62:	f011 0104 	ands.w	r1, r1, #4
  66:	f040 80f0 	bne.w	24a <DoClientHello+0x24a>
        lesserVersion |= ssl->options.dtls && ssl->version.minor < pv.minor;

        if (lesserVersion) {
  6a:	4293      	cmp	r3, r2
  6c:	f0c0 80f0 	bcc.w	250 <DoClientHello+0x250>
                       TRUE, ssl->options.side);
        }

        /* check if option is set to not allow the current version
         * set from either wolfSSL_set_options or wolfSSL_CTX_set_options */
        if (!ssl->options.dtls && ssl->options.downgrade &&
  70:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
  74:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  78:	f423 037b 	bic.w	r3, r3, #16449536	; 0xfb0000
  7c:	f423 437b 	bic.w	r3, r3, #64256	; 0xfb00
  80:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  84:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  88:	d16a      	bne.n	160 <DoClientHello+0x160>
            ssl->options.mask > 0) {
  8a:	f8d4 226c 	ldr.w	r2, [r4, #620]	; 0x26c
        if (!ssl->options.dtls && ssl->options.downgrade &&
  8e:	2a00      	cmp	r2, #0
  90:	d066      	beq.n	160 <DoClientHello+0x160>

            int reset = 0;

            if (ssl->version.minor == TLSv1_2_MINOR &&
  92:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
  96:	2b03      	cmp	r3, #3
  98:	f040 8131 	bne.w	2fe <DoClientHello+0x2fe>
  9c:	f012 6300 	ands.w	r3, r2, #134217728	; 0x8000000
  a0:	d003      	beq.n	aa <DoClientHello+0xaa>
               (ssl->options.mask & WOLFSSL_OP_NO_TLSv1_2) ==
                WOLFSSL_OP_NO_TLSv1_2) {
                WOLFSSL_MSG("\tOption set to not allow TLSv1.2, Downgrading");
                ssl->version.minor = TLSv1_1_MINOR;
  a2:	2302      	movs	r3, #2
  a4:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
                reset = 1;
  a8:	2301      	movs	r3, #1
            }

            if (ssl->version.minor == TLSv1_1_MINOR &&
  aa:	f894 113d 	ldrb.w	r1, [r4, #317]	; 0x13d
  ae:	2902      	cmp	r1, #2
  b0:	d10a      	bne.n	c8 <DoClientHello+0xc8>
  b2:	0151      	lsls	r1, r2, #5
  b4:	d508      	bpl.n	c8 <DoClientHello+0xc8>
               (ssl->options.mask & WOLFSSL_OP_NO_TLSv1_1) ==
                WOLFSSL_OP_NO_TLSv1_1) {
                WOLFSSL_MSG("\tOption set to not allow TLSv1.1, Downgrading");
                ssl->options.tls1_1 = 0;
  b6:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  ba:	f36f 13c7 	bfc	r3, #7, #1
  be:	f884 3271 	strb.w	r3, [r4, #625]	; 0x271
                ssl->version.minor = TLSv1_MINOR;
  c2:	2301      	movs	r3, #1
  c4:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
                reset = 1;
            }

            if (ssl->version.minor == TLSv1_MINOR &&
  c8:	f894 113d 	ldrb.w	r1, [r4, #317]	; 0x13d
  cc:	2901      	cmp	r1, #1
  ce:	d10b      	bne.n	e8 <DoClientHello+0xe8>
  d0:	0490      	lsls	r0, r2, #18
  d2:	d509      	bpl.n	e8 <DoClientHello+0xe8>
               (ssl->options.mask & WOLFSSL_OP_NO_TLSv1) ==
                WOLFSSL_OP_NO_TLSv1) {
                WOLFSSL_MSG("\tOption set to not allow TLSv1, Downgrading");
                ssl->options.tls    = 0;
  d4:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  d8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  dc:	f884 3271 	strb.w	r3, [r4, #625]	; 0x271
                ssl->options.tls1_1 = 0;
                ssl->version.minor = SSLv3_MINOR;
  e0:	2300      	movs	r3, #0
  e2:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
                reset = 1;
  e6:	460b      	mov	r3, r1
            }

            if (ssl->version.minor == SSLv3_MINOR &&
  e8:	f894 113d 	ldrb.w	r1, [r4, #317]	; 0x13d
  ec:	b911      	cbnz	r1, f4 <DoClientHello+0xf4>
  ee:	04d0      	lsls	r0, r2, #19
  f0:	f100 80b2 	bmi.w	258 <DoClientHello+0x258>
                SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);
#endif
                goto out;
            }

            if (ssl->version.minor < ssl->options.minDowngrade) {
  f4:	f894 2280 	ldrb.w	r2, [r4, #640]	; 0x280
  f8:	428a      	cmp	r2, r1
  fa:	f200 80ad 	bhi.w	258 <DoClientHello+0x258>
                WOLFSSL_MSG("\tversion below minimum allowed, fatal error");
                ret = VERSION_ERROR;
                goto out;
            }

            if (reset) {
  fe:	b37b      	cbz	r3, 160 <DoClientHello+0x160>
            #endif
            #ifndef NO_CERTS
                keySz = ssl->buffers.keySz;
            #endif

                ret = AllocateSuites(ssl);
 100:	4620      	mov	r0, r4
                keySz = ssl->buffers.keySz;
 102:	f8d4 90e8 	ldr.w	r9, [r4, #232]	; 0xe8
                ret = AllocateSuites(ssl);
 106:	f7ff fffe 	bl	0 <DoClientHello>
                if (ret != 0)
 10a:	4603      	mov	r3, r0
 10c:	2800      	cmp	r0, #0
 10e:	f040 80a4 	bne.w	25a <DoClientHello+0x25a>
                InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
                           ssl->options.haveDH, ssl->options.haveECDSAsig,
                           ssl->options.haveECC, TRUE, ssl->options.haveStaticECC,
                           ssl->options.haveFalconSig,
                           ssl->options.haveDilithiumSig, ssl->options.haveAnon,
                           TRUE, ssl->options.side);
 112:	f894 2270 	ldrb.w	r2, [r4, #624]	; 0x270
                           ssl->options.haveDilithiumSig, ssl->options.haveAnon,
 116:	f894 1273 	ldrb.w	r1, [r4, #627]	; 0x273
                InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
 11a:	f3c2 1201 	ubfx	r2, r2, #4, #2
 11e:	920a      	str	r2, [sp, #40]	; 0x28
                           ssl->options.haveDilithiumSig, ssl->options.haveAnon,
 120:	f894 2275 	ldrb.w	r2, [r4, #629]	; 0x275
                InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
 124:	f3c2 1200 	ubfx	r2, r2, #4, #1
 128:	9208      	str	r2, [sp, #32]
 12a:	09ca      	lsrs	r2, r1, #7
 12c:	9207      	str	r2, [sp, #28]
 12e:	f3c1 1280 	ubfx	r2, r1, #6, #1
 132:	2001      	movs	r0, #1
 134:	9206      	str	r2, [sp, #24]
 136:	f3c1 1240 	ubfx	r2, r1, #5, #1
 13a:	e9cd 0204 	strd	r0, r2, [sp, #16]
 13e:	f3c1 0280 	ubfx	r2, r1, #2, #1
 142:	9203      	str	r2, [sp, #12]
 144:	f3c1 1200 	ubfx	r2, r1, #4, #1
 148:	f3c1 01c0 	ubfx	r1, r1, #3, #1
 14c:	e9cd 3100 	strd	r3, r1, [sp]
 150:	9009      	str	r0, [sp, #36]	; 0x24
 152:	9202      	str	r2, [sp, #8]
 154:	f8d4 113c 	ldr.w	r1, [r4, #316]	; 0x13c
 158:	6860      	ldr	r0, [r4, #4]
 15a:	464a      	mov	r2, r9
 15c:	f7ff fffe 	bl	0 <DoClientHello>
            }
        }

        /* random */
        XMEMCPY(ssl->arrays->clientRandom, input + i, RAN_LEN);
 160:	68a0      	ldr	r0, [r4, #8]
        i += OPAQUE16_LEN;
 162:	1ca9      	adds	r1, r5, #2
        XMEMCPY(ssl->arrays->clientRandom, input + i, RAN_LEN);
 164:	2220      	movs	r2, #32
 166:	4439      	add	r1, r7
 168:	3014      	adds	r0, #20
 16a:	f7ff fffe 	bl	0 <memcpy>
            printf("\n");
        }
#endif

        /* session id */
        b = input[i++];
 16e:	f896 6022 	ldrb.w	r6, [r6, #34]	; 0x22
        if (b > ID_LEN) {
 172:	2e20      	cmp	r6, #32
        b = input[i++];
 174:	f105 0923 	add.w	r9, r5, #35	; 0x23
        if (b > ID_LEN) {
 178:	f200 812f 	bhi.w	3da <DoClientHello+0x3da>
            WOLFSSL_MSG("Invalid session ID size");
            ret = BUFFER_ERROR; /* session ID greater than 32 bytes long */
            goto out;
        }
        else if (b > 0 && !IsSCR(ssl)) {
 17c:	b1b6      	cbz	r6, 1ac <DoClientHello+0x1ac>
            if ((i - begin) + b > helloSz) {
 17e:	f106 0323 	add.w	r3, r6, #35	; 0x23
 182:	4543      	cmp	r3, r8
 184:	f200 8129 	bhi.w	3da <DoClientHello+0x3da>
                ret = BUFFER_ERROR;
                goto out;
            }

            /* Always save session ID in case we want to echo it. */
            XMEMCPY(ssl->arrays->sessionID, input + i, b);
 188:	68a0      	ldr	r0, [r4, #8]
 18a:	4632      	mov	r2, r6
 18c:	eb07 0109 	add.w	r1, r7, r9
 190:	3054      	adds	r0, #84	; 0x54
 192:	f7ff fffe 	bl	0 <memcpy>
            ssl->arrays->sessionIDSz = b;
 196:	68a3      	ldr	r3, [r4, #8]

            if (b == ID_LEN)
 198:	2e20      	cmp	r6, #32
            ssl->arrays->sessionIDSz = b;
 19a:	f883 6074 	strb.w	r6, [r3, #116]	; 0x74
                ssl->options.resuming = 1; /* client wants to resume */
 19e:	bf02      	ittt	eq
 1a0:	f894 3271 	ldrbeq.w	r3, [r4, #625]	; 0x271
 1a4:	f043 0308 	orreq.w	r3, r3, #8
 1a8:	f884 3271 	strbeq.w	r3, [r4, #625]	; 0x271
            WOLFSSL_MSG("Client wants to resume session");
        }
        i += b;
 1ac:	44b1      	add	r9, r6
                }
            }
#endif /* WOLFSSL_DTLS */

        /* suites */
        if ((i - begin) + OPAQUE16_LEN > helloSz) {
 1ae:	f1c5 0302 	rsb	r3, r5, #2
 1b2:	444b      	add	r3, r9
 1b4:	4543      	cmp	r3, r8
 1b6:	f200 8110 	bhi.w	3da <DoClientHello+0x3da>
            ret = BUFFER_ERROR;
            goto out;
        }

#ifdef WOLFSSL_SMALL_STACK
        clSuites = (Suites*)XMALLOC(sizeof(Suites), ssl->heap,
 1ba:	f44f 70ac 	mov.w	r0, #344	; 0x158
 1be:	f7ff fffe 	bl	0 <malloc>
                                       DYNAMIC_TYPE_SUITES);
        if (clSuites == NULL) {
 1c2:	4606      	mov	r6, r0
 1c4:	2800      	cmp	r0, #0
 1c6:	f000 810a 	beq.w	3de <DoClientHello+0x3de>
            ret = MEMORY_E;
            goto out;
        }
#endif
        XMEMSET(clSuites, 0, sizeof(Suites));
 1ca:	f44f 72ac 	mov.w	r2, #344	; 0x158
 1ce:	2100      	movs	r1, #0
 1d0:	f7ff fffe 	bl	0 <memset>
        ato16(&input[i], &clSuites->suiteSz);
 1d4:	4631      	mov	r1, r6
 1d6:	eb07 0009 	add.w	r0, r7, r9
 1da:	f7ff fffe 	bl	0 <DoClientHello>
        i += OPAQUE16_LEN;

        /* Cipher suite lists are always multiples of two in length. */
        if (clSuites->suiteSz % 2 != 0) {
 1de:	8832      	ldrh	r2, [r6, #0]
 1e0:	f012 0b01 	ands.w	fp, r2, #1
 1e4:	f040 80b5 	bne.w	352 <DoClientHello+0x352>
        i += OPAQUE16_LEN;
 1e8:	f109 0902 	add.w	r9, r9, #2
            ret = BUFFER_ERROR;
            goto out;
        }

        /* suites and compression length check */
        if ((i - begin) + clSuites->suiteSz + OPAQUE8_LEN > helloSz) {
 1ec:	f1c5 0301 	rsb	r3, r5, #1
 1f0:	444b      	add	r3, r9
 1f2:	4413      	add	r3, r2
 1f4:	4543      	cmp	r3, r8
 1f6:	f200 80ac 	bhi.w	352 <DoClientHello+0x352>
            ret = BUFFER_ERROR;
            goto out;
        }

        if (clSuites->suiteSz > WOLFSSL_MAX_SUITE_SZ) {
 1fa:	f5b2 7f96 	cmp.w	r2, #300	; 0x12c
 1fe:	f200 80a8 	bhi.w	352 <DoClientHello+0x352>
            ret = BUFFER_ERROR;
            goto out;
        }

        XMEMCPY(clSuites->suites, input + i, clSuites->suiteSz);
 202:	eb07 0109 	add.w	r1, r7, r9
 206:	1d30      	adds	r0, r6, #4
 208:	f7ff fffe 	bl	0 <memcpy>
                goto out;
            }
        }
#endif

        i += clSuites->suiteSz;
 20c:	8832      	ldrh	r2, [r6, #0]
        clSuites->hashSigAlgoSz = 0;
 20e:	f8a6 b002 	strh.w	fp, [r6, #2]
        i += clSuites->suiteSz;
 212:	444a      	add	r2, r9

        /* compression length */
        b = input[i++];
 214:	f102 0c01 	add.w	ip, r2, #1
 218:	5cbb      	ldrb	r3, [r7, r2]
 21a:	18b9      	adds	r1, r7, r2

        if ((i - begin) + b > helloSz) {
 21c:	ebac 0205 	sub.w	r2, ip, r5
 220:	441a      	add	r2, r3
 222:	4542      	cmp	r2, r8
 224:	4699      	mov	r9, r3
 226:	f200 8094 	bhi.w	352 <DoClientHello+0x352>
            ret = BUFFER_ERROR;
            goto out;
        }

        if (b == 0) {
 22a:	b163      	cbz	r3, 246 <DoClientHello+0x246>
        }

        {
            /* compression match types */
            int matchNo = 0;
            int matchZlib = 0;
 22c:	465a      	mov	r2, fp
            int matchNo = 0;
 22e:	4658      	mov	r0, fp

            while (b--) {
 230:	3b01      	subs	r3, #1
 232:	b2db      	uxtb	r3, r3
 234:	2bff      	cmp	r3, #255	; 0xff
 236:	d164      	bne.n	302 <DoClientHello+0x302>
                if (comp == ZLIB_COMPRESSION) {
                    matchZlib = 1;
                }
            }

            if (ssl->options.usingCompression == 0 && matchNo) {
 238:	f894 3273 	ldrb.w	r3, [r4, #627]	; 0x273
 23c:	07d9      	lsls	r1, r3, #31
 23e:	44e1      	add	r9, ip
 240:	d46b      	bmi.n	31a <DoClientHello+0x31a>
 242:	2800      	cmp	r0, #0
 244:	d170      	bne.n	328 <DoClientHello+0x328>
            ret = COMPRESSION_ERROR;
 246:	4b6e      	ldr	r3, [pc, #440]	; (400 <DoClientHello+0x400>)
 248:	e0b1      	b.n	3ae <DoClientHello+0x3ae>
        lesserVersion |= ssl->options.dtls && ssl->version.minor < pv.minor;
 24a:	4293      	cmp	r3, r2
 24c:	f67f af10 	bls.w	70 <DoClientHello+0x70>
            if (!ssl->options.downgrade) {
 250:	f894 2271 	ldrb.w	r2, [r4, #625]	; 0x271
 254:	0750      	lsls	r0, r2, #29
 256:	d404      	bmi.n	262 <DoClientHello+0x262>
                ret = VERSION_ERROR;
 258:	4b6a      	ldr	r3, [pc, #424]	; (404 <DoClientHello+0x404>)
        if (ret != 0) {
            WOLFSSL_ERROR_VERBOSE(ret);
        }

        return ret;
    }
 25a:	4618      	mov	r0, r3
 25c:	b011      	add	sp, #68	; 0x44
 25e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            belowMinDowngrade = pv.minor < ssl->options.minDowngrade;
 262:	f894 0280 	ldrb.w	r0, [r4, #640]	; 0x280
            if (ssl->options.dtls)
 266:	2900      	cmp	r1, #0
 268:	f000 80bc 	beq.w	3e4 <DoClientHello+0x3e4>
            if (belowMinDowngrade) {
 26c:	4283      	cmp	r3, r0
 26e:	d8f3      	bhi.n	258 <DoClientHello+0x258>
                if (pv.minor == DTLSv1_2_MINOR) {
 270:	2bfd      	cmp	r3, #253	; 0xfd
 272:	d141      	bne.n	2f8 <DoClientHello+0x2f8>
                    ssl->options.tls1_3 = 0;
 274:	f894 2272 	ldrb.w	r2, [r4, #626]	; 0x272
 278:	f36f 0200 	bfc	r2, #0, #1
 27c:	f884 2272 	strb.w	r2, [r4, #626]	; 0x272
 280:	e0ba      	b.n	3f8 <DoClientHello+0x3f8>
                else if (pv.minor == TLSv1_MINOR) {
 282:	2b01      	cmp	r3, #1
 284:	d102      	bne.n	28c <DoClientHello+0x28c>
                    ssl->options.tls1_1 = 0;
 286:	f361 12c7 	bfi	r2, r1, #7, #1
 28a:	e0b3      	b.n	3f4 <DoClientHello+0x3f4>
                else if (pv.minor == TLSv1_1_MINOR) {
 28c:	2b02      	cmp	r3, #2
 28e:	f000 80b3 	beq.w	3f8 <DoClientHello+0x3f8>
                else if (pv.minor == TLSv1_2_MINOR) {
 292:	2b03      	cmp	r3, #3
 294:	f000 80b0 	beq.w	3f8 <DoClientHello+0x3f8>
            ret = AllocateSuites(ssl);
 298:	4620      	mov	r0, r4
            keySz = ssl->buffers.keySz;
 29a:	f8d4 90e8 	ldr.w	r9, [r4, #232]	; 0xe8
            ret = AllocateSuites(ssl);
 29e:	f7ff fffe 	bl	0 <DoClientHello>
            if (ret != 0)
 2a2:	4603      	mov	r3, r0
 2a4:	2800      	cmp	r0, #0
 2a6:	d1d8      	bne.n	25a <DoClientHello+0x25a>
                       TRUE, ssl->options.side);
 2a8:	f894 2270 	ldrb.w	r2, [r4, #624]	; 0x270
                       ssl->options.haveDilithiumSig, ssl->options.haveAnon,
 2ac:	f894 1273 	ldrb.w	r1, [r4, #627]	; 0x273
            InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
 2b0:	f3c2 1201 	ubfx	r2, r2, #4, #2
 2b4:	920a      	str	r2, [sp, #40]	; 0x28
                       ssl->options.haveDilithiumSig, ssl->options.haveAnon,
 2b6:	f894 2275 	ldrb.w	r2, [r4, #629]	; 0x275
            InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
 2ba:	f3c2 1200 	ubfx	r2, r2, #4, #1
 2be:	9208      	str	r2, [sp, #32]
 2c0:	09ca      	lsrs	r2, r1, #7
 2c2:	9207      	str	r2, [sp, #28]
 2c4:	f3c1 1280 	ubfx	r2, r1, #6, #1
 2c8:	2001      	movs	r0, #1
 2ca:	9206      	str	r2, [sp, #24]
 2cc:	f3c1 1240 	ubfx	r2, r1, #5, #1
 2d0:	e9cd 0204 	strd	r0, r2, [sp, #16]
 2d4:	f3c1 0280 	ubfx	r2, r1, #2, #1
 2d8:	9203      	str	r2, [sp, #12]
 2da:	f3c1 1200 	ubfx	r2, r1, #4, #1
 2de:	f3c1 01c0 	ubfx	r1, r1, #3, #1
 2e2:	e9cd 3100 	strd	r3, r1, [sp]
 2e6:	9009      	str	r0, [sp, #36]	; 0x24
 2e8:	9202      	str	r2, [sp, #8]
 2ea:	f8d4 113c 	ldr.w	r1, [r4, #316]	; 0x13c
 2ee:	6860      	ldr	r0, [r4, #4]
 2f0:	464a      	mov	r2, r9
 2f2:	f7ff fffe 	bl	0 <DoClientHello>
 2f6:	e6bb      	b.n	70 <DoClientHello+0x70>
                else if (pv.minor == DTLS_MINOR) {
 2f8:	2bff      	cmp	r3, #255	; 0xff
 2fa:	d1cd      	bne.n	298 <DoClientHello+0x298>
 2fc:	e7ba      	b.n	274 <DoClientHello+0x274>
            int reset = 0;
 2fe:	2300      	movs	r3, #0
 300:	e6d3      	b.n	aa <DoClientHello+0xaa>
                byte comp = input[i++];
 302:	f811 ef01 	ldrb.w	lr, [r1, #1]!
                if (comp == NO_COMPRESSION) {
 306:	f1be 0f00 	cmp.w	lr, #0
 30a:	d004      	beq.n	316 <DoClientHello+0x316>
                    matchZlib = 1;
 30c:	f1be 0fdd 	cmp.w	lr, #221	; 0xdd
 310:	bf08      	it	eq
 312:	2201      	moveq	r2, #1
 314:	e78c      	b.n	230 <DoClientHello+0x230>
                    matchNo = 1;
 316:	2001      	movs	r0, #1
 318:	e78a      	b.n	230 <DoClientHello+0x230>
            } else if (ssl->options.usingCompression && matchZlib) {
 31a:	b92a      	cbnz	r2, 328 <DoClientHello+0x328>
            } else if (ssl->options.usingCompression && matchNo) {
 31c:	2800      	cmp	r0, #0
 31e:	d092      	beq.n	246 <DoClientHello+0x246>
                ssl->options.usingCompression = 0;  /* turn off */
 320:	f362 0300 	bfi	r3, r2, #0, #1
 324:	f884 3273 	strb.w	r3, [r4, #627]	; 0x273
        if ((i - begin) < helloSz) {
 328:	eba9 0b05 	sub.w	fp, r9, r5
 32c:	45c3      	cmp	fp, r8
        *inOutIdx = i;
 32e:	f8ca 9000 	str.w	r9, [sl]
        if ((i - begin) < helloSz) {
 332:	d22c      	bcs.n	38e <DoClientHello+0x38e>
            if (TLSX_SupportExtensions(ssl))
 334:	4620      	mov	r0, r4
 336:	f7ff fffe 	bl	0 <TLSX_SupportExtensions>
 33a:	2800      	cmp	r0, #0
 33c:	d03d      	beq.n	3ba <DoClientHello+0x3ba>
                if ((ret = TLSX_PopulateExtensions(ssl, 1)) != 0)
 33e:	2101      	movs	r1, #1
 340:	4620      	mov	r0, r4
 342:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
 346:	4603      	mov	r3, r0
 348:	bb88      	cbnz	r0, 3ae <DoClientHello+0x3ae>
                if ((i - begin) + OPAQUE16_LEN > helloSz) {
 34a:	f10b 0b02 	add.w	fp, fp, #2
 34e:	45c3      	cmp	fp, r8
 350:	d901      	bls.n	356 <DoClientHello+0x356>
            ret = BUFFER_ERROR;
 352:	4b2d      	ldr	r3, [pc, #180]	; (408 <DoClientHello+0x408>)
 354:	e02b      	b.n	3ae <DoClientHello+0x3ae>
                ato16(&input[i], &totalExtSz);
 356:	eb07 0009 	add.w	r0, r7, r9
 35a:	f10d 013e 	add.w	r1, sp, #62	; 0x3e
 35e:	f7ff fffe 	bl	0 <DoClientHello>
                if ((i - begin) + totalExtSz > helloSz) {
 362:	f8bd 203e 	ldrh.w	r2, [sp, #62]	; 0x3e
                i += OPAQUE16_LEN;
 366:	f109 0902 	add.w	r9, r9, #2
                if ((i - begin) + totalExtSz > helloSz) {
 36a:	1b55      	subs	r5, r2, r5
 36c:	444d      	add	r5, r9
 36e:	4545      	cmp	r5, r8
 370:	d8ef      	bhi.n	352 <DoClientHello+0x352>
                if ((ret = TLSX_Parse(ssl, input + i, totalExtSz, client_hello,
 372:	2301      	movs	r3, #1
 374:	9600      	str	r6, [sp, #0]
 376:	eb07 0109 	add.w	r1, r7, r9
 37a:	4620      	mov	r0, r4
 37c:	f7ff fffe 	bl	0 <TLSX_Parse>
 380:	4603      	mov	r3, r0
 382:	b9a0      	cbnz	r0, 3ae <DoClientHello+0x3ae>
                i += totalExtSz;
 384:	f8bd 303e 	ldrh.w	r3, [sp, #62]	; 0x3e
 388:	444b      	add	r3, r9
                *inOutIdx = i;
 38a:	f8ca 3000 	str.w	r3, [sl]
        ssl->options.clientState   = CLIENT_HELLO_COMPLETE;
 38e:	230c      	movs	r3, #12
 390:	f884 327d 	strb.w	r3, [r4, #637]	; 0x27d
        ssl->options.haveSessionId = 1;
 394:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 398:	f043 0320 	orr.w	r3, r3, #32
 39c:	f884 3271 	strb.w	r3, [r4, #625]	; 0x271
        if (ssl->options.resuming) {
 3a0:	071b      	lsls	r3, r3, #28
 3a2:	d40e      	bmi.n	3c2 <DoClientHello+0x3c2>
            ret = MatchSuite(ssl, clSuites);
 3a4:	4631      	mov	r1, r6
 3a6:	4620      	mov	r0, r4
 3a8:	f7ff fffe 	bl	0 <DoClientHello>
 3ac:	4603      	mov	r3, r0
            XFREE(clSuites, ssl->heap, DYNAMIC_TYPE_SUITES);
 3ae:	4630      	mov	r0, r6
 3b0:	930d      	str	r3, [sp, #52]	; 0x34
 3b2:	f7ff fffe 	bl	0 <free>
 3b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 3b8:	e74f      	b.n	25a <DoClientHello+0x25a>
                *inOutIdx = begin + helloSz; /* skip extensions */
 3ba:	4445      	add	r5, r8
 3bc:	f8ca 5000 	str.w	r5, [sl]
 3c0:	e7e5      	b.n	38e <DoClientHello+0x38e>
            ret = HandleTlsResumption(ssl, clSuites);
 3c2:	4631      	mov	r1, r6
 3c4:	4620      	mov	r0, r4
 3c6:	f7ff fffe 	bl	0 <DoClientHello>
            if (ret != 0)
 3ca:	4603      	mov	r3, r0
 3cc:	2800      	cmp	r0, #0
 3ce:	d1ee      	bne.n	3ae <DoClientHello+0x3ae>
            if (ssl->options.clientState == CLIENT_KEYEXCHANGE_COMPLETE) {
 3d0:	f894 227d 	ldrb.w	r2, [r4, #637]	; 0x27d
 3d4:	2a0d      	cmp	r2, #13
 3d6:	d1e5      	bne.n	3a4 <DoClientHello+0x3a4>
 3d8:	e7e9      	b.n	3ae <DoClientHello+0x3ae>
            return BUFFER_ERROR;
 3da:	4b0b      	ldr	r3, [pc, #44]	; (408 <DoClientHello+0x408>)
 3dc:	e73d      	b.n	25a <DoClientHello+0x25a>
            ret = MEMORY_E;
 3de:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 3e2:	e73a      	b.n	25a <DoClientHello+0x25a>
            if (belowMinDowngrade) {
 3e4:	4283      	cmp	r3, r0
 3e6:	f4ff af37 	bcc.w	258 <DoClientHello+0x258>
                if (pv.minor == SSLv3_MINOR) {
 3ea:	2b00      	cmp	r3, #0
 3ec:	f47f af49 	bne.w	282 <DoClientHello+0x282>
                    ssl->options.tls    = 0;
 3f0:	f002 023f 	and.w	r2, r2, #63	; 0x3f
                    ssl->options.tls1_1 = 0;
 3f4:	f884 2271 	strb.w	r2, [r4, #625]	; 0x271
                    ssl->version.minor = DTLS_MINOR;
 3f8:	f884 313d 	strb.w	r3, [r4, #317]	; 0x13d
 3fc:	e74c      	b.n	298 <DoClientHello+0x298>
 3fe:	bf00      	nop
 400:	fffffe0a 	.word	0xfffffe0a
 404:	fffffeba 	.word	0xfffffeba
 408:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.DoHandShakeMsgType:

00000000 <DoHandShakeMsgType>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b091      	sub	sp, #68	; 0x44
   6:	e9dd 8a1a 	ldrd	r8, sl, [sp, #104]	; 0x68
   a:	461d      	mov	r5, r3
    if (*inOutIdx + size > totalSz) {
   c:	6813      	ldr	r3, [r2, #0]
   e:	4443      	add	r3, r8
  10:	4553      	cmp	r3, sl
{
  12:	4604      	mov	r4, r0
  14:	460f      	mov	r7, r1
  16:	4616      	mov	r6, r2
    if (*inOutIdx + size > totalSz) {
  18:	9305      	str	r3, [sp, #20]
  1a:	f200 8699 	bhi.w	d50 <DoHandShakeMsgType+0xd50>
                  (ssl->keys.encryptionOn ? ssl->keys.padSz : 0);
  1e:	f890 3268 	ldrb.w	r3, [r0, #616]	; 0x268
  22:	b10b      	cbz	r3, 28 <DoHandShakeMsgType+0x28>
  24:	f8d0 3264 	ldr.w	r3, [r0, #612]	; 0x264
  28:	9306      	str	r3, [sp, #24]
    if ( (ret = SanityCheckMsgReceived(ssl, type)) != 0) {
  2a:	4629      	mov	r1, r5
  2c:	4620      	mov	r0, r4
  2e:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
  32:	4681      	mov	r9, r0
  34:	b958      	cbnz	r0, 4e <DoHandShakeMsgType+0x4e>
    if (ssl->options.handShakeState == HANDSHAKE_DONE && type != hello_request){
  36:	f894 327e 	ldrb.w	r3, [r4, #638]	; 0x27e
  3a:	2b10      	cmp	r3, #16
  3c:	d10b      	bne.n	56 <DoHandShakeMsgType+0x56>
  3e:	b155      	cbz	r5, 56 <DoHandShakeMsgType+0x56>
        SendAlert(ssl, alert_fatal, unexpected_message);
  40:	220a      	movs	r2, #10
  42:	2102      	movs	r1, #2
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        return OUT_OF_ORDER_E;
  4a:	f46f 79ba 	mvn.w	r9, #372	; 0x174
}
  4e:	4648      	mov	r0, r9
  50:	b011      	add	sp, #68	; 0x44
  52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (ssl->options.side == WOLFSSL_CLIENT_END && ssl->options.dtls == 0 &&
  56:	f8d4 2270 	ldr.w	r2, [r4, #624]	; 0x270
  5a:	4b67      	ldr	r3, [pc, #412]	; (1f8 <DoHandShakeMsgType+0x1f8>)
  5c:	4013      	ands	r3, r2
  5e:	2b10      	cmp	r3, #16
  60:	d118      	bne.n	94 <DoHandShakeMsgType+0x94>
  62:	f894 327c 	ldrb.w	r3, [r4, #636]	; 0x27c
  66:	b913      	cbnz	r3, 6e <DoHandShakeMsgType+0x6e>
               ssl->options.serverState == NULL_STATE && type != server_hello &&
  68:	f015 0ffd 	tst.w	r5, #253	; 0xfd
  6c:	d1e8      	bne.n	40 <DoHandShakeMsgType+0x40>
    if (ssl->options.side == WOLFSSL_SERVER_END &&
  6e:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  72:	f013 0f30 	tst.w	r3, #48	; 0x30
  76:	d117      	bne.n	a8 <DoHandShakeMsgType+0xa8>
  78:	f894 327d 	ldrb.w	r3, [r4, #637]	; 0x27d
  7c:	b9a3      	cbnz	r3, a8 <DoHandShakeMsgType+0xa8>
               ssl->options.clientState == NULL_STATE && type != client_hello) {
  7e:	2d01      	cmp	r5, #1
  80:	d1de      	bne.n	40 <DoHandShakeMsgType+0x40>
        ret = HashInput(ssl, input + *inOutIdx, size);
  82:	6831      	ldr	r1, [r6, #0]
  84:	4642      	mov	r2, r8
  86:	4439      	add	r1, r7
  88:	4620      	mov	r0, r4
  8a:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        if (ret != 0) {
  8e:	b168      	cbz	r0, ac <DoHandShakeMsgType+0xac>
  90:	4681      	mov	r9, r0
  92:	e7dc      	b.n	4e <DoHandShakeMsgType+0x4e>
    if (ssl->options.side == WOLFSSL_CLIENT_END && ssl->options.dtls &&
  94:	4a59      	ldr	r2, [pc, #356]	; (1fc <DoHandShakeMsgType+0x1fc>)
  96:	4293      	cmp	r3, r2
  98:	d1e9      	bne.n	6e <DoHandShakeMsgType+0x6e>
  9a:	2d0e      	cmp	r5, #14
  9c:	d1e7      	bne.n	6e <DoHandShakeMsgType+0x6e>
            type == server_hello_done &&
  9e:	f894 327c 	ldrb.w	r3, [r4, #636]	; 0x27c
  a2:	2b02      	cmp	r3, #2
  a4:	d8e3      	bhi.n	6e <DoHandShakeMsgType+0x6e>
  a6:	e7cb      	b.n	40 <DoHandShakeMsgType+0x40>
    if (type != hello_request
  a8:	2d00      	cmp	r5, #0
  aa:	d1ea      	bne.n	82 <DoHandShakeMsgType+0x82>
    if (ssl->options.side == WOLFSSL_CLIENT_END) {
  ac:	f894 2270 	ldrb.w	r2, [r4, #624]	; 0x270
  b0:	f002 0230 	and.w	r2, r2, #48	; 0x30
  b4:	2a10      	cmp	r2, #16
  b6:	d117      	bne.n	e8 <DoHandShakeMsgType+0xe8>
        switch (type) {
  b8:	f1a5 030b 	sub.w	r3, r5, #11
  bc:	2b03      	cmp	r3, #3
  be:	d813      	bhi.n	e8 <DoHandShakeMsgType+0xe8>
            if (ssl->options.resuming) {
  c0:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  c4:	0719      	lsls	r1, r3, #28
  c6:	d50f      	bpl.n	e8 <DoHandShakeMsgType+0xe8>
                if (ssl->session->sessionIDSz != 0) {
  c8:	f8d4 10f4 	ldr.w	r1, [r4, #244]	; 0xf4
  cc:	f891 105c 	ldrb.w	r1, [r1, #92]	; 0x5c
  d0:	2900      	cmp	r1, #0
  d2:	d1b5      	bne.n	40 <DoHandShakeMsgType+0x40>
                ssl->options.resuming = 0;
  d4:	f361 03c3 	bfi	r3, r1, #3, #1
  d8:	f884 3271 	strb.w	r3, [r4, #625]	; 0x271
                ssl->options.peerAuthGood = 0;
  dc:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  e0:	f361 0341 	bfi	r3, r1, #1, #1
  e4:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
    switch (type) {
  e8:	2d16      	cmp	r5, #22
  ea:	f200 8635 	bhi.w	d58 <DoHandShakeMsgType+0xd58>
  ee:	e8df f015 	tbh	[pc, r5, lsl #1]
  f2:	0017      	.short	0x0017
  f4:	0051036e 	.word	0x0051036e
  f8:	0633003d 	.word	0x0633003d
  fc:	06330633 	.word	0x06330633
 100:	06330633 	.word	0x06330633
 104:	06330633 	.word	0x06330633
 108:	013b0329 	.word	0x013b0329
 10c:	03560087 	.word	0x03560087
 110:	03af0546 	.word	0x03af0546
 114:	06330633 	.word	0x06330633
 118:	03640633 	.word	0x03640633
 11c:	03300633 	.word	0x03300633
    if (size) /* must be 0 */
 120:	f1b8 0f00 	cmp.w	r8, #0
 124:	f040 8338 	bne.w	798 <DoHandShakeMsgType+0x798>
    if (IsEncryptionOn(ssl, 0)) {
 128:	4641      	mov	r1, r8
 12a:	4620      	mov	r0, r4
 12c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 130:	b160      	cbz	r0, 14c <DoHandShakeMsgType+0x14c>
                    *inOutIdx + ssl->keys.padSz > totalSz)
 132:	f8d4 1264 	ldr.w	r1, [r4, #612]	; 0x264
 136:	6833      	ldr	r3, [r6, #0]
 138:	440b      	add	r3, r1
            if (size != totalSz &&
 13a:	f1ba 0f00 	cmp.w	sl, #0
 13e:	d004      	beq.n	14a <DoHandShakeMsgType+0x14a>
 140:	459a      	cmp	sl, r3
 142:	d202      	bcs.n	14a <DoHandShakeMsgType+0x14a>
                return BUFFER_E;
 144:	f06f 0983 	mvn.w	r9, #131	; 0x83
 148:	e781      	b.n	4e <DoHandShakeMsgType+0x4e>
            *inOutIdx += ssl->keys.padSz;
 14a:	6033      	str	r3, [r6, #0]
    if (ssl->options.side == WOLFSSL_SERVER_END) {
 14c:	b93a      	cbnz	r2, 15e <DoHandShakeMsgType+0x15e>
        SendAlert(ssl, alert_fatal, unexpected_message); /* try */
 14e:	220a      	movs	r2, #10
 150:	2102      	movs	r1, #2
 152:	4620      	mov	r0, r4
 154:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        return FATAL_ERROR;
 158:	f46f 799c 	mvn.w	r9, #312	; 0x138
 15c:	e777      	b.n	4e <DoHandShakeMsgType+0x4e>
        return SendAlert(ssl, alert_warning, no_renegotiation);
 15e:	2264      	movs	r2, #100	; 0x64
 160:	2101      	movs	r1, #1
 162:	4620      	mov	r0, r4
 164:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
    ret = ProcessPeerCerts(ssl, input, inOutIdx, size);
 168:	4605      	mov	r5, r0
        break;
 16a:	e040      	b.n	1ee <DoHandShakeMsgType+0x1ee>
        ret = DoHelloVerifyRequest(ssl, input,inOutIdx, size);
 16c:	4639      	mov	r1, r7
 16e:	4643      	mov	r3, r8
 170:	4632      	mov	r2, r6
 172:	4620      	mov	r0, r4
 174:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        if (IsEncryptionOn(ssl, 0)) {
 178:	2100      	movs	r1, #0
        ret = DoHelloVerifyRequest(ssl, input,inOutIdx, size);
 17a:	4605      	mov	r5, r0
        if (IsEncryptionOn(ssl, 0)) {
 17c:	4620      	mov	r0, r4
 17e:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 182:	b3a0      	cbz	r0, 1ee <DoHandShakeMsgType+0x1ee>
                if (*inOutIdx + ssl->keys.padSz > totalSz)
 184:	6833      	ldr	r3, [r6, #0]
 186:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 18a:	4413      	add	r3, r2
 18c:	4553      	cmp	r3, sl
 18e:	d8d9      	bhi.n	144 <DoHandShakeMsgType+0x144>
                *inOutIdx += ssl->keys.padSz;
 190:	6033      	str	r3, [r6, #0]
 192:	e02c      	b.n	1ee <DoHandShakeMsgType+0x1ee>
        ret = DoServerHello(ssl, input, inOutIdx, size);
 194:	4643      	mov	r3, r8
 196:	4639      	mov	r1, r7
 198:	4632      	mov	r2, r6
 19a:	4620      	mov	r0, r4
 19c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        if (ssl->options.resuming || !IsAtLeastTLSv1_2(ssl) ||
 1a0:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 1a4:	071f      	lsls	r7, r3, #28
        ret = DoServerHello(ssl, input, inOutIdx, size);
 1a6:	4605      	mov	r5, r0
        if (ssl->options.resuming || !IsAtLeastTLSv1_2(ssl) ||
 1a8:	d408      	bmi.n	1bc <DoHandShakeMsgType+0x1bc>
 1aa:	4620      	mov	r0, r4
 1ac:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 1b0:	b120      	cbz	r0, 1bc <DoHandShakeMsgType+0x1bc>
                                               IsAtLeastTLSv1_3(ssl->version)) {
 1b2:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
 1b6:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        if (ssl->options.resuming || !IsAtLeastTLSv1_2(ssl) ||
 1ba:	b1c0      	cbz	r0, 1ee <DoHandShakeMsgType+0x1ee>
                ssl->options.cacheMessages = 0;
 1bc:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
 1c0:	f36f 0382 	bfc	r3, #2, #1
 1c4:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
                if ((ssl->hsHashes != NULL) && (ssl->hsHashes->messages != NULL)) {
 1c8:	68e3      	ldr	r3, [r4, #12]
 1ca:	b183      	cbz	r3, 1ee <DoHandShakeMsgType+0x1ee>
 1cc:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
 1d0:	b168      	cbz	r0, 1ee <DoHandShakeMsgType+0x1ee>
                    ForceZero(ssl->hsHashes->messages, ssl->hsHashes->length);
 1d2:	f8d3 12a4 	ldr.w	r1, [r3, #676]	; 0x2a4
 1d6:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    XFREE(ssl->hsHashes->messages, ssl->heap,
 1da:	68e3      	ldr	r3, [r4, #12]
 1dc:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
 1e0:	b108      	cbz	r0, 1e6 <DoHandShakeMsgType+0x1e6>
 1e2:	f7ff fffe 	bl	0 <free>
                    ssl->hsHashes->messages = NULL;
 1e6:	68e3      	ldr	r3, [r4, #12]
 1e8:	2200      	movs	r2, #0
 1ea:	f8c3 22a0 	str.w	r2, [r3, #672]	; 0x2a0
    if (ret == 0 && expectedIdx != *inOutIdx) {
 1ee:	2d00      	cmp	r5, #0
 1f0:	d07c      	beq.n	2ec <DoHandShakeMsgType+0x2ec>
 1f2:	46a9      	mov	r9, r5
 1f4:	e72b      	b.n	4e <DoHandShakeMsgType+0x4e>
 1f6:	bf00      	nop
 1f8:	00040030 	.word	0x00040030
 1fc:	00040010 	.word	0x00040010
        word32 begin = *inOutIdx;
 200:	6835      	ldr	r5, [r6, #0]
        if (OPAQUE8_LEN > size)
 202:	f1b8 0f00 	cmp.w	r8, #0
 206:	f000 82c7 	beq.w	798 <DoHandShakeMsgType+0x798>
        len = input[(*inOutIdx)++];
 20a:	1c6a      	adds	r2, r5, #1
 20c:	6032      	str	r2, [r6, #0]
 20e:	5d7b      	ldrb	r3, [r7, r5]
 210:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
        if ((*inOutIdx - begin) + len > size)
 214:	1c59      	adds	r1, r3, #1
 216:	4588      	cmp	r8, r1
 218:	f0c0 82be 	bcc.w	798 <DoHandShakeMsgType+0x798>
        *inOutIdx += len;
 21c:	441a      	add	r2, r3
 21e:	6032      	str	r2, [r6, #0]
        if (IsAtLeastTLSv1_2(ssl)) {
 220:	4620      	mov	r0, r4
 222:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 226:	b360      	cbz	r0, 282 <DoHandShakeMsgType+0x282>
            if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
 228:	f1c5 0302 	rsb	r3, r5, #2
 22c:	4413      	add	r3, r2
 22e:	4598      	cmp	r8, r3
 230:	f0c0 82b2 	bcc.w	798 <DoHandShakeMsgType+0x798>
            ato16(input + *inOutIdx, &len);
 234:	f10d 0122 	add.w	r1, sp, #34	; 0x22
 238:	18b8      	adds	r0, r7, r2
 23a:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
            *inOutIdx += OPAQUE16_LEN;
 23e:	6831      	ldr	r1, [r6, #0]
            if ((len > size) || ((*inOutIdx - begin) + len > size))
 240:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
            *inOutIdx += OPAQUE16_LEN;
 244:	3102      	adds	r1, #2
            if ((len > size) || ((*inOutIdx - begin) + len > size))
 246:	4590      	cmp	r8, r2
            *inOutIdx += OPAQUE16_LEN;
 248:	6031      	str	r1, [r6, #0]
            if ((len > size) || ((*inOutIdx - begin) + len > size))
 24a:	f0c0 82a5 	bcc.w	798 <DoHandShakeMsgType+0x798>
 24e:	1b4b      	subs	r3, r1, r5
 250:	4413      	add	r3, r2
 252:	4598      	cmp	r8, r3
 254:	f0c0 82a0 	bcc.w	798 <DoHandShakeMsgType+0x798>
            if (PickHashSigAlgo(ssl, input + *inOutIdx, len) != 0 &&
 258:	4439      	add	r1, r7
 25a:	4620      	mov	r0, r4
 25c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 260:	b150      	cbz	r0, 278 <DoHandShakeMsgType+0x278>
                                             ssl->buffers.certificate &&
 262:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
            if (PickHashSigAlgo(ssl, input + *inOutIdx, len) != 0 &&
 266:	b13b      	cbz	r3, 278 <DoHandShakeMsgType+0x278>
                                             ssl->buffers.certificate &&
 268:	681b      	ldr	r3, [r3, #0]
 26a:	b12b      	cbz	r3, 278 <DoHandShakeMsgType+0x278>
                if (ssl->buffers.key && ssl->buffers.key->buffer) {
 26c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 270:	b113      	cbz	r3, 278 <DoHandShakeMsgType+0x278>
 272:	681b      	ldr	r3, [r3, #0]
 274:	2b00      	cmp	r3, #0
 276:	d174      	bne.n	362 <DoHandShakeMsgType+0x362>
            *inOutIdx += len;
 278:	6833      	ldr	r3, [r6, #0]
 27a:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
 27e:	4413      	add	r3, r2
 280:	6033      	str	r3, [r6, #0]
        if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
 282:	6830      	ldr	r0, [r6, #0]
 284:	1c83      	adds	r3, r0, #2
 286:	1b5b      	subs	r3, r3, r5
 288:	4598      	cmp	r8, r3
 28a:	f0c0 8285 	bcc.w	798 <DoHandShakeMsgType+0x798>
        ato16(input + *inOutIdx, &len);
 28e:	f10d 0122 	add.w	r1, sp, #34	; 0x22
 292:	4438      	add	r0, r7
 294:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        *inOutIdx += OPAQUE16_LEN;
 298:	6833      	ldr	r3, [r6, #0]
        if ((*inOutIdx - begin) + len > size)
 29a:	f8bd 2022 	ldrh.w	r2, [sp, #34]	; 0x22
        *inOutIdx += OPAQUE16_LEN;
 29e:	3302      	adds	r3, #2
 2a0:	6033      	str	r3, [r6, #0]
        if ((*inOutIdx - begin) + len > size)
 2a2:	1b5b      	subs	r3, r3, r5
 2a4:	4413      	add	r3, r2
 2a6:	4598      	cmp	r8, r3
 2a8:	f0c0 8276 	bcc.w	798 <DoHandShakeMsgType+0x798>
        while (len) {
 2ac:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
            if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
 2b0:	6832      	ldr	r2, [r6, #0]
        while (len) {
 2b2:	bb73      	cbnz	r3, 312 <DoHandShakeMsgType+0x312>
        if (ssl->buffers.certificate && ssl->buffers.certificate->buffer) {
 2b4:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 2b8:	2b00      	cmp	r3, #0
 2ba:	d046      	beq.n	34a <DoHandShakeMsgType+0x34a>
 2bc:	681b      	ldr	r3, [r3, #0]
 2be:	2b00      	cmp	r3, #0
 2c0:	d043      	beq.n	34a <DoHandShakeMsgType+0x34a>
            if (ssl->buffers.key && ssl->buffers.key->buffer) {
 2c2:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 2c6:	b143      	cbz	r3, 2da <DoHandShakeMsgType+0x2da>
 2c8:	681b      	ldr	r3, [r3, #0]
 2ca:	b133      	cbz	r3, 2da <DoHandShakeMsgType+0x2da>
                ssl->options.sendVerify = SEND_CERT;
 2cc:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
 2d0:	2101      	movs	r1, #1
            ssl->options.sendVerify = SEND_BLANK_CERT;
 2d2:	f361 0301 	bfi	r3, r1, #0, #2
 2d6:	f884 3270 	strb.w	r3, [r4, #624]	; 0x270
        if (IsEncryptionOn(ssl, 0)) {
 2da:	2100      	movs	r1, #0
 2dc:	4620      	mov	r0, r4
 2de:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 2e2:	b118      	cbz	r0, 2ec <DoHandShakeMsgType+0x2ec>
            *inOutIdx += ssl->keys.padSz;
 2e4:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
            *inOutIdx += ssl->keys.padSz;
 2e8:	4413      	add	r3, r2
 2ea:	6033      	str	r3, [r6, #0]
    expectedIdx = *inOutIdx + size +
 2ec:	e9dd b305 	ldrd	fp, r3, [sp, #20]
 2f0:	449b      	add	fp, r3
    if (ret == 0 && expectedIdx != *inOutIdx) {
 2f2:	6833      	ldr	r3, [r6, #0]
 2f4:	455b      	cmp	r3, fp
 2f6:	f43f aeaa 	beq.w	4e <DoHandShakeMsgType+0x4e>
        if (!ssl->options.dtls)
 2fa:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 2fe:	075b      	lsls	r3, r3, #29
 300:	d404      	bmi.n	30c <DoHandShakeMsgType+0x30c>
            SendAlert(ssl, alert_fatal, decode_error);
 302:	2232      	movs	r2, #50	; 0x32
 304:	2102      	movs	r1, #2
 306:	4620      	mov	r0, r4
 308:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        ret = DECODE_E;
 30c:	f8df 92c8 	ldr.w	r9, [pc, #712]	; 5d8 <DoHandShakeMsgType+0x5d8>
 310:	e69d      	b.n	4e <DoHandShakeMsgType+0x4e>
            if ((*inOutIdx - begin) + OPAQUE16_LEN > size)
 312:	1c93      	adds	r3, r2, #2
 314:	1b5b      	subs	r3, r3, r5
 316:	4598      	cmp	r8, r3
 318:	f0c0 823e 	bcc.w	798 <DoHandShakeMsgType+0x798>
            ato16(input + *inOutIdx, &dnSz);
 31c:	a909      	add	r1, sp, #36	; 0x24
 31e:	18b8      	adds	r0, r7, r2
 320:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
            *inOutIdx += OPAQUE16_LEN;
 324:	6833      	ldr	r3, [r6, #0]
            if ((*inOutIdx - begin) + dnSz > size)
 326:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
            *inOutIdx += OPAQUE16_LEN;
 32a:	3302      	adds	r3, #2
            if ((*inOutIdx - begin) + dnSz > size)
 32c:	1b59      	subs	r1, r3, r5
 32e:	4411      	add	r1, r2
 330:	4588      	cmp	r8, r1
            *inOutIdx += OPAQUE16_LEN;
 332:	6033      	str	r3, [r6, #0]
            if ((*inOutIdx - begin) + dnSz > size)
 334:	f0c0 8230 	bcc.w	798 <DoHandShakeMsgType+0x798>
            *inOutIdx += dnSz;
 338:	4413      	add	r3, r2
 33a:	6033      	str	r3, [r6, #0]
            len -= OPAQUE16_LEN + dnSz;
 33c:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 340:	3b02      	subs	r3, #2
 342:	1a9b      	subs	r3, r3, r2
 344:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
 348:	e7b0      	b.n	2ac <DoHandShakeMsgType+0x2ac>
        else if (IsTLS(ssl) || ssl->options.dtls)
 34a:	4620      	mov	r0, r4
 34c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 350:	b918      	cbnz	r0, 35a <DoHandShakeMsgType+0x35a>
 352:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 356:	075d      	lsls	r5, r3, #29
 358:	d5bf      	bpl.n	2da <DoHandShakeMsgType+0x2da>
            ssl->options.sendVerify = SEND_BLANK_CERT;
 35a:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
 35e:	2102      	movs	r1, #2
 360:	e7b7      	b.n	2d2 <DoHandShakeMsgType+0x2d2>
                    return INVALID_PARAMETER;
 362:	f46f 79d4 	mvn.w	r9, #424	; 0x1a8
 366:	e672      	b.n	4e <DoHandShakeMsgType+0x4e>
        ssl->options.asyncState = TLS_ASYNC_BEGIN;
 368:	2100      	movs	r1, #0
        XMEMSET(args, 0, sizeof(DskeArgs));
 36a:	2218      	movs	r2, #24
        ssl->options.asyncState = TLS_ASYNC_BEGIN;
 36c:	f884 1283 	strb.w	r1, [r4, #643]	; 0x283
        XMEMSET(args, 0, sizeof(DskeArgs));
 370:	a809      	add	r0, sp, #36	; 0x24
 372:	f7ff fffe 	bl	0 <memset>
        args->sigAlgo = ssl->specs.sig_algo;
 376:	f894 314c 	ldrb.w	r3, [r4, #332]	; 0x14c
 37a:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
        args->hashAlgo = sha_mac;
 37e:	2302      	movs	r3, #2
        args->idx = *inOutIdx;
 380:	6832      	ldr	r2, [r6, #0]
        args->hashAlgo = sha_mac;
 382:	f88d 3039 	strb.w	r3, [sp, #57]	; 0x39
    switch(ssl->options.asyncState)
 386:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
        args->begin = *inOutIdx;
 38a:	e9cd 220b 	strd	r2, r2, [sp, #44]	; 0x2c
    switch(ssl->options.asyncState)
 38e:	2b05      	cmp	r3, #5
 390:	f200 81cd 	bhi.w	72e <DoHandShakeMsgType+0x72e>
 394:	e8df f013 	tbh	[pc, r3, lsl #1]
 398:	00720006 	.word	0x00720006
 39c:	0199012d 	.word	0x0199012d
 3a0:	01c201b5 	.word	0x01c201b5
            switch(ssl->specs.kea)
 3a4:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 3a8:	2b07      	cmp	r3, #7
 3aa:	d170      	bne.n	48e <DoHandShakeMsgType+0x48e>
                    if ((args->idx - args->begin) + ENUM_LEN + OPAQUE16_LEN +
 3ac:	f1b8 0f03 	cmp.w	r8, #3
 3b0:	d801      	bhi.n	3b6 <DoHandShakeMsgType+0x3b6>
                        ERROR_OUT(BUFFER_ERROR, exit_dske);
 3b2:	4d8a      	ldr	r5, [pc, #552]	; (5dc <DoHandShakeMsgType+0x5dc>)
 3b4:	e032      	b.n	41c <DoHandShakeMsgType+0x41c>
                    b = input[args->idx++];
 3b6:	1c53      	adds	r3, r2, #1
 3b8:	930b      	str	r3, [sp, #44]	; 0x2c
                    if (b != named_curve) {
 3ba:	5cbb      	ldrb	r3, [r7, r2]
 3bc:	2b03      	cmp	r3, #3
 3be:	f040 81b9 	bne.w	734 <DoHandShakeMsgType+0x734>
                    b = input[args->idx++];
 3c2:	18bb      	adds	r3, r7, r2
 3c4:	1cd1      	adds	r1, r2, #3
 3c6:	789b      	ldrb	r3, [r3, #2]
 3c8:	910b      	str	r1, [sp, #44]	; 0x2c
        switch (tlsCurveId) {
 3ca:	2b17      	cmp	r3, #23
 3cc:	d030      	beq.n	430 <DoHandShakeMsgType+0x430>
 3ce:	2b1d      	cmp	r3, #29
 3d0:	f040 81b2 	bne.w	738 <DoHandShakeMsgType+0x738>
            case WOLFSSL_ECC_X25519: return ECC_X25519_OID;
 3d4:	f240 1b6d 	movw	fp, #365	; 0x16d
                    ssl->ecdhCurveOID = curveOid;
 3d8:	f8c4 b290 	str.w	fp, [r4, #656]	; 0x290
                    if ((args->idx - args->begin) + length > size) {
 3dc:	f817 a001 	ldrb.w	sl, [r7, r1]
                    length = input[args->idx++];
 3e0:	3204      	adds	r2, #4
 3e2:	920b      	str	r2, [sp, #44]	; 0x2c
                    if ((args->idx - args->begin) + length > size) {
 3e4:	f10a 0204 	add.w	r2, sl, #4
 3e8:	4590      	cmp	r8, r2
 3ea:	d3e2      	bcc.n	3b2 <DoHandShakeMsgType+0x3b2>
                    if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 3ec:	f240 126d 	movw	r2, #365	; 0x16d
 3f0:	4593      	cmp	fp, r2
 3f2:	d14e      	bne.n	492 <DoHandShakeMsgType+0x492>
                        if (ssl->peerX25519Key == NULL) {
 3f4:	f8d4 52b4 	ldr.w	r5, [r4, #692]	; 0x2b4
 3f8:	b9ed      	cbnz	r5, 436 <DoHandShakeMsgType+0x436>
                            ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
 3fa:	f504 722d 	add.w	r2, r4, #692	; 0x2b4
 3fe:	2145      	movs	r1, #69	; 0x45
 400:	4620      	mov	r0, r4
 402:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                            if (ret != 0) {
 406:	4605      	mov	r5, r0
 408:	b940      	cbnz	r0, 41c <DoHandShakeMsgType+0x41c>
                        if ((ret = wc_curve25519_check_public(
 40a:	980b      	ldr	r0, [sp, #44]	; 0x2c
 40c:	2200      	movs	r2, #0
 40e:	4651      	mov	r1, sl
 410:	4438      	add	r0, r7
 412:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
 416:	4603      	mov	r3, r0
 418:	b1f0      	cbz	r0, 458 <DoHandShakeMsgType+0x458>
                            ERROR_OUT(ECC_PEERKEY_ERROR, exit_dske);
 41a:	4d71      	ldr	r5, [pc, #452]	; (5e0 <DoHandShakeMsgType+0x5e0>)
    if (args->verifySig) {
 41c:	980a      	ldr	r0, [sp, #40]	; 0x28
 41e:	b118      	cbz	r0, 428 <DoHandShakeMsgType+0x428>
        XFREE(args->verifySig, ssl->heap, DYNAMIC_TYPE_SIGNATURE);
 420:	f7ff fffe 	bl	0 <free>
        args->verifySig = NULL;
 424:	2300      	movs	r3, #0
 426:	930a      	str	r3, [sp, #40]	; 0x28
        FreeAsyncCtx(ssl, 0);
    #else
        FreeDcvArgs(ssl, args);
    #endif
        /* Final cleanup */
        FreeKeyExchange(ssl);
 428:	4620      	mov	r0, r4
 42a:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        break;
 42e:	e6de      	b.n	1ee <DoHandShakeMsgType+0x1ee>
        switch (tlsCurveId) {
 430:	f240 2b0e 	movw	fp, #526	; 0x20e
 434:	e7d0      	b.n	3d8 <DoHandShakeMsgType+0x3d8>
                        } else if (ssl->peerX25519KeyPresent) {
 436:	f894 32b8 	ldrb.w	r3, [r4, #696]	; 0x2b8
 43a:	2b00      	cmp	r3, #0
 43c:	d0e5      	beq.n	40a <DoHandShakeMsgType+0x40a>
            wc_curve25519_free((curve25519_key*)pKey);
 43e:	4628      	mov	r0, r5
 440:	f7ff fffe 	bl	0 <wc_curve25519_free>
            ret = wc_curve25519_init_ex((curve25519_key*)pKey, ssl->heap,
 444:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
 448:	6a61      	ldr	r1, [r4, #36]	; 0x24
 44a:	4628      	mov	r0, r5
 44c:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
                            ssl->peerX25519KeyPresent = 0;
 450:	2300      	movs	r3, #0
 452:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
                            if (ret != 0) {
 456:	e7d6      	b.n	406 <DoHandShakeMsgType+0x406>
                        if (wc_curve25519_import_public_ex(input + args->idx,
 458:	980b      	ldr	r0, [sp, #44]	; 0x2c
 45a:	f8d4 22b4 	ldr.w	r2, [r4, #692]	; 0x2b4
 45e:	4651      	mov	r1, sl
 460:	4438      	add	r0, r7
 462:	f7ff fffe 	bl	0 <wc_curve25519_import_public_ex>
 466:	2800      	cmp	r0, #0
 468:	d1d7      	bne.n	41a <DoHandShakeMsgType+0x41a>
                        args->idx += length;
 46a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 46c:	4453      	add	r3, sl
 46e:	930b      	str	r3, [sp, #44]	; 0x2c
                        ssl->peerX25519KeyPresent = 1;
 470:	2301      	movs	r3, #1
 472:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
            ssl->options.asyncState = TLS_ASYNC_BUILD;
 476:	2301      	movs	r3, #1
 478:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            switch(ssl->specs.kea)
 47c:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 480:	2b06      	cmp	r3, #6
 482:	d839      	bhi.n	4f8 <DoHandShakeMsgType+0x4f8>
 484:	2b03      	cmp	r3, #3
 486:	f200 80b1 	bhi.w	5ec <DoHandShakeMsgType+0x5ec>
 48a:	2b02      	cmp	r3, #2
 48c:	d036      	beq.n	4fc <DoHandShakeMsgType+0x4fc>
                    ret = BAD_KEA_TYPE_E;
 48e:	4d55      	ldr	r5, [pc, #340]	; (5e4 <DoHandShakeMsgType+0x5e4>)
 490:	e7c4      	b.n	41c <DoHandShakeMsgType+0x41c>
                    if (ssl->peerEccKey == NULL) {
 492:	f8d4 529c 	ldr.w	r5, [r4, #668]	; 0x29c
 496:	b9f5      	cbnz	r5, 4d6 <DoHandShakeMsgType+0x4d6>
                        ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
 498:	f504 7227 	add.w	r2, r4, #668	; 0x29c
 49c:	2125      	movs	r1, #37	; 0x25
 49e:	4620      	mov	r0, r4
 4a0:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                        if (ret != 0) {
 4a4:	4605      	mov	r5, r0
 4a6:	2800      	cmp	r0, #0
 4a8:	d1b8      	bne.n	41c <DoHandShakeMsgType+0x41c>
                    curveId = wc_ecc_get_oid(curveOid, NULL, NULL);
 4aa:	2200      	movs	r2, #0
 4ac:	4611      	mov	r1, r2
 4ae:	4658      	mov	r0, fp
 4b0:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
 4b4:	4603      	mov	r3, r0
                    if (wc_ecc_import_x963_ex(input + args->idx, length,
 4b6:	980b      	ldr	r0, [sp, #44]	; 0x2c
 4b8:	f8d4 229c 	ldr.w	r2, [r4, #668]	; 0x29c
 4bc:	4651      	mov	r1, sl
 4be:	4438      	add	r0, r7
 4c0:	f7ff fffe 	bl	0 <wc_ecc_import_x963_ex>
 4c4:	2800      	cmp	r0, #0
 4c6:	d1a8      	bne.n	41a <DoHandShakeMsgType+0x41a>
                    args->idx += length;
 4c8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 4ca:	4453      	add	r3, sl
 4cc:	930b      	str	r3, [sp, #44]	; 0x2c
                    ssl->peerEccKeyPresent = 1;
 4ce:	2301      	movs	r3, #1
 4d0:	f884 3299 	strb.w	r3, [r4, #665]	; 0x299
            if (ret != 0) {
 4d4:	e7cf      	b.n	476 <DoHandShakeMsgType+0x476>
                    } else if (ssl->peerEccKeyPresent) {
 4d6:	f894 2299 	ldrb.w	r2, [r4, #665]	; 0x299
 4da:	2a00      	cmp	r2, #0
 4dc:	d0e5      	beq.n	4aa <DoHandShakeMsgType+0x4aa>
            wc_ecc_free((ecc_key*)pKey);
 4de:	4628      	mov	r0, r5
 4e0:	f7ff fffe 	bl	0 <wc_ecc_free>
            ret = wc_ecc_init_ex((ecc_key*)pKey, ssl->heap, ssl->devId);
 4e4:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
 4e8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 4ea:	4628      	mov	r0, r5
 4ec:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
                        ssl->peerEccKeyPresent = 0;
 4f0:	2200      	movs	r2, #0
 4f2:	f884 2299 	strb.w	r2, [r4, #665]	; 0x299
                        if (ret != 0) {
 4f6:	e7d5      	b.n	4a4 <DoHandShakeMsgType+0x4a4>
 4f8:	2b07      	cmp	r3, #7
 4fa:	e7c7      	b.n	48c <DoHandShakeMsgType+0x48c>
                    if (ssl->options.usingAnon_cipher) {
 4fc:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 500:	0718      	lsls	r0, r3, #28
 502:	d473      	bmi.n	5ec <DoHandShakeMsgType+0x5ec>
                    verifySz = (word16)(args->idx - args->begin);
 504:	e9dd a20b 	ldrd	sl, r2, [sp, #44]	; 0x2c
 508:	ebaa 0502 	sub.w	r5, sl, r2
 50c:	b2ad      	uxth	r5, r5
                    if (verifySz > MAX_DH_SZ) {
 50e:	f240 630c 	movw	r3, #1548	; 0x60c
 512:	429d      	cmp	r5, r3
 514:	f63f af4d 	bhi.w	3b2 <DoHandShakeMsgType+0x3b2>
                    if (IsAtLeastTLSv1_2(ssl)) {
 518:	4620      	mov	r0, r4
 51a:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 51e:	b910      	cbnz	r0, 526 <DoHandShakeMsgType+0x526>
                        ret = ALGO_ID_E;
 520:	f06f 0584 	mvn.w	r5, #132	; 0x84
 524:	e77a      	b.n	41c <DoHandShakeMsgType+0x41c>
                        if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN >
 526:	f10a 0302 	add.w	r3, sl, #2
 52a:	1a9b      	subs	r3, r3, r2
 52c:	4598      	cmp	r8, r3
 52e:	f4ff af40 	bcc.w	3b2 <DoHandShakeMsgType+0x3b2>
                        DecodeSigAlg(&input[args->idx], &args->hashAlgo,
 532:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 536:	f10d 0139 	add.w	r1, sp, #57	; 0x39
 53a:	eb07 000a 	add.w	r0, r7, sl
 53e:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                        if (sigAlgo == ed25519_sa_algo &&
 542:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 546:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
 54a:	2b09      	cmp	r3, #9
 54c:	d139      	bne.n	5c2 <DoHandShakeMsgType+0x5c2>
 54e:	2a03      	cmp	r2, #3
 550:	d137      	bne.n	5c2 <DoHandShakeMsgType+0x5c2>
                            args->sigAlgo = sigAlgo;
 552:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
                        args->idx += 2;
 556:	980b      	ldr	r0, [sp, #44]	; 0x2c
                        hashType = HashAlgoToType(args->hashAlgo);
 558:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
                        args->idx += 2;
 55c:	3002      	adds	r0, #2
    switch (hashAlgo) {
 55e:	2b04      	cmp	r3, #4
                        args->idx += 2;
 560:	900b      	str	r0, [sp, #44]	; 0x2c
    switch (hashAlgo) {
 562:	d031      	beq.n	5c8 <DoHandShakeMsgType+0x5c8>
 564:	2b06      	cmp	r3, #6
 566:	d1db      	bne.n	520 <DoHandShakeMsgType+0x520>
 568:	f04f 0a08 	mov.w	sl, #8
                    if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
 56c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 56e:	1ac3      	subs	r3, r0, r3
 570:	3302      	adds	r3, #2
 572:	4598      	cmp	r8, r3
 574:	f4ff af1d 	bcc.w	3b2 <DoHandShakeMsgType+0x3b2>
                    ato16(input + args->idx, &args->verifySigSz);
 578:	a90d      	add	r1, sp, #52	; 0x34
 57a:	4438      	add	r0, r7
 57c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    args->idx += OPAQUE16_LEN;
 580:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
                    if ((args->idx - args->begin) + args->verifySigSz > size) {
 582:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 584:	f8bd 1034 	ldrh.w	r1, [sp, #52]	; 0x34
                    args->idx += OPAQUE16_LEN;
 588:	3302      	adds	r3, #2
 58a:	930b      	str	r3, [sp, #44]	; 0x2c
                    if ((args->idx - args->begin) + args->verifySigSz > size) {
 58c:	1a9b      	subs	r3, r3, r2
 58e:	440b      	add	r3, r1
 590:	4598      	cmp	r8, r3
 592:	f4ff af0e 	bcc.w	3b2 <DoHandShakeMsgType+0x3b2>
                    ret = HashSkeData(ssl, hashType, input + args->begin,
 596:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 59a:	9300      	str	r3, [sp, #0]
 59c:	443a      	add	r2, r7
 59e:	462b      	mov	r3, r5
 5a0:	4651      	mov	r1, sl
 5a2:	4620      	mov	r0, r4
 5a4:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    if (ret != 0) {
 5a8:	4605      	mov	r5, r0
 5aa:	2800      	cmp	r0, #0
 5ac:	f47f af36 	bne.w	41c <DoHandShakeMsgType+0x41c>
                    switch (args->sigAlgo)
 5b0:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 5b4:	2b03      	cmp	r3, #3
 5b6:	d00a      	beq.n	5ce <DoHandShakeMsgType+0x5ce>
 5b8:	2b09      	cmp	r3, #9
 5ba:	d1b1      	bne.n	520 <DoHandShakeMsgType+0x520>
                            if (!ssl->peerEd25519KeyPresent) {
 5bc:	f894 32b0 	ldrb.w	r3, [r4, #688]	; 0x2b0
 5c0:	e007      	b.n	5d2 <DoHandShakeMsgType+0x5d2>
                        if (sigAlgo != args->sigAlgo) {
 5c2:	429a      	cmp	r2, r3
 5c4:	d1ac      	bne.n	520 <DoHandShakeMsgType+0x520>
 5c6:	e7c6      	b.n	556 <DoHandShakeMsgType+0x556>
            return WC_HASH_TYPE_SHA256;
 5c8:	f04f 0a06 	mov.w	sl, #6
 5cc:	e7ce      	b.n	56c <DoHandShakeMsgType+0x56c>
                            if (!ssl->peerEccDsaKeyPresent) {
 5ce:	f894 32a6 	ldrb.w	r3, [r4, #678]	; 0x2a6
                            if (!ssl->peerEd25519KeyPresent) {
 5d2:	b95b      	cbnz	r3, 5ec <DoHandShakeMsgType+0x5ec>
                                ERROR_OUT(NO_PEER_KEY, exit_dske);
 5d4:	4d04      	ldr	r5, [pc, #16]	; (5e8 <DoHandShakeMsgType+0x5e8>)
 5d6:	e721      	b.n	41c <DoHandShakeMsgType+0x41c>
 5d8:	fffffe60 	.word	0xfffffe60
 5dc:	fffffeb8 	.word	0xfffffeb8
 5e0:	fffffea0 	.word	0xfffffea0
 5e4:	fffffe8a 	.word	0xfffffe8a
 5e8:	fffffec4 	.word	0xfffffec4
            ssl->options.asyncState = TLS_ASYNC_DO;
 5ec:	2302      	movs	r3, #2
 5ee:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            switch(ssl->specs.kea)
 5f2:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 5f6:	2b06      	cmp	r3, #6
 5f8:	d839      	bhi.n	66e <DoHandShakeMsgType+0x66e>
 5fa:	2b03      	cmp	r3, #3
 5fc:	d862      	bhi.n	6c4 <DoHandShakeMsgType+0x6c4>
 5fe:	2b02      	cmp	r3, #2
 600:	f47f af45 	bne.w	48e <DoHandShakeMsgType+0x48e>
                    if (ssl->options.usingAnon_cipher) {
 604:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 608:	0719      	lsls	r1, r3, #28
 60a:	d45b      	bmi.n	6c4 <DoHandShakeMsgType+0x6c4>
                    if (args->verifySig == NULL) {
 60c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 60e:	b96b      	cbnz	r3, 62c <DoHandShakeMsgType+0x62c>
                        args->verifySig = (byte*)XMALLOC(args->verifySigSz,
 610:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
 614:	f7ff fffe 	bl	0 <malloc>
 618:	900a      	str	r0, [sp, #40]	; 0x28
                        if (args->verifySig == NULL) {
 61a:	2800      	cmp	r0, #0
 61c:	f000 808f 	beq.w	73e <DoHandShakeMsgType+0x73e>
                        XMEMCPY(args->verifySig, input + args->idx,
 620:	990b      	ldr	r1, [sp, #44]	; 0x2c
 622:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
 626:	4439      	add	r1, r7
 628:	f7ff fffe 	bl	0 <memcpy>
                    switch (args->sigAlgo)
 62c:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
                                        args->verifySig, args->verifySigSz,
 630:	990a      	ldr	r1, [sp, #40]	; 0x28
 632:	2b03      	cmp	r3, #3
 634:	d01d      	beq.n	672 <DoHandShakeMsgType+0x672>
 636:	2b09      	cmp	r3, #9
 638:	f47f af72 	bne.w	520 <DoHandShakeMsgType+0x520>
                            ret = Ed25519Verify(ssl,
 63c:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
 640:	9301      	str	r3, [sp, #4]
 642:	2700      	movs	r7, #0
 644:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
 648:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
 64c:	9300      	str	r3, [sp, #0]
 64e:	9702      	str	r7, [sp, #8]
 650:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 654:	4620      	mov	r0, r4
 656:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                                FreeKey(ssl, DYNAMIC_TYPE_ED25519,
 65a:	f504 722b 	add.w	r2, r4, #684	; 0x2ac
                            ret = Ed25519Verify(ssl,
 65e:	4605      	mov	r5, r0
                                FreeKey(ssl, DYNAMIC_TYPE_ED25519,
 660:	2146      	movs	r1, #70	; 0x46
 662:	4620      	mov	r0, r4
 664:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                                ssl->peerEd25519KeyPresent = 0;
 668:	f884 72b0 	strb.w	r7, [r4, #688]	; 0x2b0
 66c:	e019      	b.n	6a2 <DoHandShakeMsgType+0x6a2>
 66e:	2b07      	cmp	r3, #7
 670:	e7c6      	b.n	600 <DoHandShakeMsgType+0x600>
                                    ret = EccVerify(ssl,
 672:	f8d4 32a0 	ldr.w	r3, [r4, #672]	; 0x2a0
 676:	9301      	str	r3, [sp, #4]
 678:	2700      	movs	r7, #0
 67a:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 67e:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
 682:	9300      	str	r3, [sp, #0]
 684:	9702      	str	r7, [sp, #8]
 686:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 68a:	4620      	mov	r0, r4
 68c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                                FreeKey(ssl, DYNAMIC_TYPE_ECC,
 690:	f504 7228 	add.w	r2, r4, #672	; 0x2a0
                                    ret = EccVerify(ssl,
 694:	4605      	mov	r5, r0
                                FreeKey(ssl, DYNAMIC_TYPE_ECC,
 696:	2125      	movs	r1, #37	; 0x25
 698:	4620      	mov	r0, r4
 69a:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                                ssl->peerEccDsaKeyPresent = 0;
 69e:	f884 72a6 	strb.w	r7, [r4, #678]	; 0x2a6
                                ssl->options.havePeerCert && (ret == 0);
 6a2:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
                            ssl->options.peerAuthGood =
 6a6:	f894 2276 	ldrb.w	r2, [r4, #630]	; 0x276
                                ssl->options.havePeerCert && (ret == 0);
 6aa:	f013 0301 	ands.w	r3, r3, #1
 6ae:	bf1c      	itt	ne
 6b0:	fab5 f385 	clzne	r3, r5
 6b4:	095b      	lsrne	r3, r3, #5
                            ssl->options.peerAuthGood =
 6b6:	f363 0241 	bfi	r2, r3, #1, #1
 6ba:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
            if (ret != 0) {
 6be:	2d00      	cmp	r5, #0
 6c0:	f47f aeac 	bne.w	41c <DoHandShakeMsgType+0x41c>
            ssl->options.asyncState = TLS_ASYNC_VERIFY;
 6c4:	2303      	movs	r3, #3
 6c6:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            switch(ssl->specs.kea)
 6ca:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 6ce:	2b06      	cmp	r3, #6
 6d0:	d82b      	bhi.n	72a <DoHandShakeMsgType+0x72a>
 6d2:	2b03      	cmp	r3, #3
 6d4:	d812      	bhi.n	6fc <DoHandShakeMsgType+0x6fc>
 6d6:	2b02      	cmp	r3, #2
 6d8:	f47f aed9 	bne.w	48e <DoHandShakeMsgType+0x48e>
                    if (ssl->options.usingAnon_cipher) {
 6dc:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 6e0:	071a      	lsls	r2, r3, #28
 6e2:	d40b      	bmi.n	6fc <DoHandShakeMsgType+0x6fc>
                    args->idx += args->verifySigSz;
 6e4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 6e6:	f8bd 2034 	ldrh.w	r2, [sp, #52]	; 0x34
 6ea:	4413      	add	r3, r2
 6ec:	930b      	str	r3, [sp, #44]	; 0x2c
                    switch(args->sigAlgo)
 6ee:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 6f2:	2b03      	cmp	r3, #3
 6f4:	d002      	beq.n	6fc <DoHandShakeMsgType+0x6fc>
 6f6:	2b09      	cmp	r3, #9
 6f8:	f47f af12 	bne.w	520 <DoHandShakeMsgType+0x520>
            ssl->options.asyncState = TLS_ASYNC_FINALIZE;
 6fc:	2304      	movs	r3, #4
 6fe:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            if (IsEncryptionOn(ssl, 0)) {
 702:	2100      	movs	r1, #0
 704:	4620      	mov	r0, r4
 706:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 70a:	b120      	cbz	r0, 716 <DoHandShakeMsgType+0x716>
                args->idx += ssl->keys.padSz;
 70c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 70e:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 712:	4413      	add	r3, r2
 714:	930b      	str	r3, [sp, #44]	; 0x2c
            ssl->options.asyncState = TLS_ASYNC_END;
 716:	2305      	movs	r3, #5
 718:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            *inOutIdx = args->idx;
 71c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 71e:	6033      	str	r3, [r6, #0]
            ssl->options.serverState = SERVER_KEYEXCHANGE_COMPLETE;
 720:	2307      	movs	r3, #7
 722:	f884 327c 	strb.w	r3, [r4, #636]	; 0x27c
            break;
 726:	2500      	movs	r5, #0
 728:	e678      	b.n	41c <DoHandShakeMsgType+0x41c>
 72a:	2b07      	cmp	r3, #7
 72c:	e7d4      	b.n	6d8 <DoHandShakeMsgType+0x6d8>
    switch(ssl->options.asyncState)
 72e:	f46f 7596 	mvn.w	r5, #300	; 0x12c
 732:	e673      	b.n	41c <DoHandShakeMsgType+0x41c>
                        ERROR_OUT(ECC_CURVETYPE_ERROR, exit_dske);
 734:	4dab      	ldr	r5, [pc, #684]	; (9e4 <DoHandShakeMsgType+0x9e4>)
 736:	e671      	b.n	41c <DoHandShakeMsgType+0x41c>
        switch (tlsCurveId) {
 738:	f46f 75af 	mvn.w	r5, #350	; 0x15e
 73c:	e66e      	b.n	41c <DoHandShakeMsgType+0x41c>
                            ERROR_OUT(MEMORY_E, exit_dske);
 73e:	f06f 057c 	mvn.w	r5, #124	; 0x7c
 742:	e66b      	b.n	41c <DoHandShakeMsgType+0x41c>
    ret = ProcessPeerCerts(ssl, input, inOutIdx, size);
 744:	4643      	mov	r3, r8
 746:	4632      	mov	r2, r6
 748:	4639      	mov	r1, r7
 74a:	4620      	mov	r0, r4
 74c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 750:	e50a      	b.n	168 <DoHandShakeMsgType+0x168>
    if (size < ENUM_LEN + OPAQUE24_LEN)
 752:	f1b8 0f03 	cmp.w	r8, #3
 756:	d91f      	bls.n	798 <DoHandShakeMsgType+0x798>
    status_type = input[(*inOutIdx)++];
 758:	6830      	ldr	r0, [r6, #0]
 75a:	3001      	adds	r0, #1
 75c:	6030      	str	r0, [r6, #0]
    c24to32(input + *inOutIdx, &status_length);
 75e:	a909      	add	r1, sp, #36	; 0x24
 760:	4438      	add	r0, r7
 762:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
    *inOutIdx += OPAQUE24_LEN;
 766:	6833      	ldr	r3, [r6, #0]
 768:	3303      	adds	r3, #3
 76a:	6033      	str	r3, [r6, #0]
    if (size != ENUM_LEN + OPAQUE24_LEN + status_length)
 76c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 76e:	3304      	adds	r3, #4
 770:	4598      	cmp	r8, r3
 772:	d111      	bne.n	798 <DoHandShakeMsgType+0x798>
        SendAlert(ssl, alert_fatal, bad_certificate_status_response);
 774:	2102      	movs	r1, #2
 776:	2271      	movs	r2, #113	; 0x71
 778:	4620      	mov	r0, r4
 77a:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
    if (IsEncryptionOn(ssl, 0)) {
 77e:	2100      	movs	r1, #0
 780:	4620      	mov	r0, r4
 782:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 786:	b138      	cbz	r0, 798 <DoHandShakeMsgType+0x798>
            if (*inOutIdx + ssl->keys.padSz > size)
 788:	6833      	ldr	r3, [r6, #0]
 78a:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 78e:	4413      	add	r3, r2
 790:	4598      	cmp	r8, r3
 792:	f4ff acd7 	bcc.w	144 <DoHandShakeMsgType+0x144>
            *inOutIdx += ssl->keys.padSz;
 796:	6033      	str	r3, [r6, #0]
        return BUFFER_ERROR;
 798:	f8df 924c 	ldr.w	r9, [pc, #588]	; 9e8 <DoHandShakeMsgType+0x9e8>
 79c:	e457      	b.n	4e <DoHandShakeMsgType+0x4e>
        ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
 79e:	2308      	movs	r3, #8
 7a0:	f884 327c 	strb.w	r3, [r4, #636]	; 0x27c
        if (IsEncryptionOn(ssl, 0)) {
 7a4:	2100      	movs	r1, #0
 7a6:	4620      	mov	r0, r4
 7a8:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 7ac:	2800      	cmp	r0, #0
 7ae:	f43f ad9d 	beq.w	2ec <DoHandShakeMsgType+0x2ec>
            *inOutIdx += ssl->keys.padSz;
 7b2:	6833      	ldr	r3, [r6, #0]
 7b4:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 7b8:	e596      	b.n	2e8 <DoHandShakeMsgType+0x2e8>
        ret = DoFinished(ssl, input, inOutIdx, size, totalSz, NO_SNIFF);
 7ba:	2300      	movs	r3, #0
 7bc:	e9cd a300 	strd	sl, r3, [sp]
 7c0:	4632      	mov	r2, r6
 7c2:	4643      	mov	r3, r8
 7c4:	4639      	mov	r1, r7
 7c6:	4620      	mov	r0, r4
 7c8:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 7cc:	e4cc      	b.n	168 <DoHandShakeMsgType+0x168>
        ret = DoClientHello(ssl, input, inOutIdx, size);
 7ce:	4643      	mov	r3, r8
 7d0:	4632      	mov	r2, r6
 7d2:	4639      	mov	r1, r7
 7d4:	4620      	mov	r0, r4
 7d6:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        if (ssl->options.resuming || !ssl->options.verifyPeer || \
 7da:	f8b4 3270 	ldrh.w	r3, [r4, #624]	; 0x270
 7de:	f403 6304 	and.w	r3, r3, #2112	; 0x840
 7e2:	2b40      	cmp	r3, #64	; 0x40
        ret = DoClientHello(ssl, input, inOutIdx, size);
 7e4:	4605      	mov	r5, r0
        if (ssl->options.resuming || !ssl->options.verifyPeer || \
 7e6:	d108      	bne.n	7fa <DoHandShakeMsgType+0x7fa>
                     !IsAtLeastTLSv1_2(ssl) || IsAtLeastTLSv1_3(ssl->version)) {
 7e8:	4620      	mov	r0, r4
 7ea:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        if (ssl->options.resuming || !ssl->options.verifyPeer || \
 7ee:	b120      	cbz	r0, 7fa <DoHandShakeMsgType+0x7fa>
                     !IsAtLeastTLSv1_2(ssl) || IsAtLeastTLSv1_3(ssl->version)) {
 7f0:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
 7f4:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 7f8:	b1c0      	cbz	r0, 82c <DoHandShakeMsgType+0x82c>
                ssl->options.cacheMessages = 0;
 7fa:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
 7fe:	f36f 0382 	bfc	r3, #2, #1
 802:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
                if ((ssl->hsHashes != NULL) && (ssl->hsHashes->messages != NULL)) {
 806:	68e3      	ldr	r3, [r4, #12]
 808:	b183      	cbz	r3, 82c <DoHandShakeMsgType+0x82c>
 80a:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
 80e:	b168      	cbz	r0, 82c <DoHandShakeMsgType+0x82c>
                    ForceZero(ssl->hsHashes->messages, ssl->hsHashes->length);
 810:	f8d3 12a4 	ldr.w	r1, [r3, #676]	; 0x2a4
 814:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    XFREE(ssl->hsHashes->messages, ssl->heap, DYNAMIC_TYPE_HASHES);
 818:	68e3      	ldr	r3, [r4, #12]
 81a:	f8d3 02a0 	ldr.w	r0, [r3, #672]	; 0x2a0
 81e:	b108      	cbz	r0, 824 <DoHandShakeMsgType+0x824>
 820:	f7ff fffe 	bl	0 <free>
                    ssl->hsHashes->messages = NULL;
 824:	68e3      	ldr	r3, [r4, #12]
 826:	2200      	movs	r2, #0
 828:	f8c3 22a0 	str.w	r2, [r3, #672]	; 0x2a0
        if (IsEncryptionOn(ssl, 0)) {
 82c:	2100      	movs	r1, #0
 82e:	4620      	mov	r0, r4
 830:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 834:	2800      	cmp	r0, #0
 836:	f43f acda 	beq.w	1ee <DoHandShakeMsgType+0x1ee>
                        *inOutIdx + ssl->keys.padSz > totalSz)
 83a:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 83e:	6832      	ldr	r2, [r6, #0]
                if (size != totalSz &&
 840:	45d0      	cmp	r8, sl
                        *inOutIdx + ssl->keys.padSz > totalSz)
 842:	4413      	add	r3, r2
                if (size != totalSz &&
 844:	f43f aca4 	beq.w	190 <DoHandShakeMsgType+0x190>
 848:	459a      	cmp	sl, r3
 84a:	f4bf aca1 	bcs.w	190 <DoHandShakeMsgType+0x190>
 84e:	e479      	b.n	144 <DoHandShakeMsgType+0x144>
        else
    #endif /* WOLFSSL_ASYNC_CRYPT */
        {
            /* Reset state */
            ret = 0;
            ssl->options.asyncState = TLS_ASYNC_BEGIN;
 850:	2100      	movs	r1, #0
 852:	f884 1283 	strb.w	r1, [r4, #643]	; 0x283
            XMEMSET(args, 0, sizeof(DckeArgs));
 856:	2214      	movs	r2, #20
 858:	a809      	add	r0, sp, #36	; 0x24
 85a:	f7ff fffe 	bl	0 <memset>
            args->idx = *inOutIdx;
 85e:	6833      	ldr	r3, [r6, #0]
            args->begin = *inOutIdx;
 860:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
            ssl->async->freeArgs = FreeDckeArgs;
        #endif
        }

        /* Do Client Key Exchange State Machine */
        switch(ssl->options.asyncState)
 864:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
 868:	2b05      	cmp	r3, #5
 86a:	f200 817c 	bhi.w	b66 <DoHandShakeMsgType+0xb66>
 86e:	e8df f013 	tbh	[pc, r3, lsl #1]
 872:	0006      	.short	0x0006
 874:	00d30059 	.word	0x00d30059
 878:	00fd00f1 	.word	0x00fd00f1
 87c:	0111      	.short	0x0111
        {
            case TLS_ASYNC_BEGIN:
            {
                /* Sanity checks */
                /* server side checked in SanityCheckMsgReceived */
                if (ssl->options.clientState < CLIENT_HELLO_COMPLETE) {
 87e:	f894 327d 	ldrb.w	r3, [r4, #637]	; 0x27d
 882:	2b0b      	cmp	r3, #11
 884:	d810      	bhi.n	8a8 <DoHandShakeMsgType+0x8a8>
                    WOLFSSL_MSG("Client sending keyexchange at wrong time");
                    SendAlert(ssl, alert_fatal, unexpected_message);
 886:	220a      	movs	r2, #10
 888:	2102      	movs	r1, #2
 88a:	4620      	mov	r0, r4
 88c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    ERROR_OUT(OUT_OF_ORDER_E, exit_dcke);
 890:	f46f 75ba 	mvn.w	r5, #372	; 0x174
        }
    #endif


        /* Cleanup PMS */
        if (ssl->arrays->preMasterSecret != NULL) {
 894:	68a3      	ldr	r3, [r4, #8]
 896:	6858      	ldr	r0, [r3, #4]
 898:	b110      	cbz	r0, 8a0 <DoHandShakeMsgType+0x8a0>
            ForceZero(ssl->arrays->preMasterSecret, ssl->arrays->preMasterSz);
 89a:	6899      	ldr	r1, [r3, #8]
 89c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
        }
        ssl->arrays->preMasterSz = 0;
 8a0:	68a3      	ldr	r3, [r4, #8]
 8a2:	2200      	movs	r2, #0
 8a4:	609a      	str	r2, [r3, #8]

        /* Final cleanup */
        FreeKeyExchange(ssl);
 8a6:	e5bf      	b.n	428 <DoHandShakeMsgType+0x428>
                if (ssl->options.verifyPeer &&
 8a8:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
 8ac:	065b      	lsls	r3, r3, #25
 8ae:	d50c      	bpl.n	8ca <DoHandShakeMsgType+0x8ca>
                         (ssl->options.mutualAuth || ssl->options.failNoCert)) {
 8b0:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
                if (ssl->options.verifyPeer &&
 8b4:	07dd      	lsls	r5, r3, #31
 8b6:	d403      	bmi.n	8c0 <DoHandShakeMsgType+0x8c0>
                         (ssl->options.mutualAuth || ssl->options.failNoCert)) {
 8b8:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 8bc:	07d8      	lsls	r0, r3, #31
 8be:	d504      	bpl.n	8ca <DoHandShakeMsgType+0x8ca>
                    if (!ssl->options.havePeerCert) {
 8c0:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 8c4:	07d9      	lsls	r1, r3, #31
 8c6:	f140 8151 	bpl.w	b6c <DoHandShakeMsgType+0xb6c>
                if (ssl->options.verifyPeer && ssl->options.failNoCertxPSK) {
 8ca:	f8b4 3270 	ldrh.w	r3, [r4, #624]	; 0x270
 8ce:	f403 7310 	and.w	r3, r3, #576	; 0x240
 8d2:	f5b3 7f10 	cmp.w	r3, #576	; 0x240
 8d6:	d105      	bne.n	8e4 <DoHandShakeMsgType+0x8e4>
                    if (!ssl->options.havePeerCert &&
 8d8:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 8dc:	f013 0f05 	tst.w	r3, #5
 8e0:	f000 8144 	beq.w	b6c <DoHandShakeMsgType+0xb6c>
                if (ssl->arrays->preMasterSecret == NULL) {
 8e4:	f8d4 a008 	ldr.w	sl, [r4, #8]
 8e8:	f8da 1004 	ldr.w	r1, [sl, #4]
 8ec:	b989      	cbnz	r1, 912 <DoHandShakeMsgType+0x912>
                    ssl->arrays->preMasterSz = ENCRYPT_LEN;
 8ee:	258b      	movs	r5, #139	; 0x8b
 8f0:	f8ca 5008 	str.w	r5, [sl, #8]
                    ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
 8f4:	4628      	mov	r0, r5
 8f6:	9107      	str	r1, [sp, #28]
 8f8:	f7ff fffe 	bl	0 <malloc>
                    if (ssl->arrays->preMasterSecret == NULL) {
 8fc:	68a3      	ldr	r3, [r4, #8]
                    ssl->arrays->preMasterSecret = (byte*)XMALLOC(ENCRYPT_LEN,
 8fe:	f8ca 0004 	str.w	r0, [sl, #4]
                    if (ssl->arrays->preMasterSecret == NULL) {
 902:	6858      	ldr	r0, [r3, #4]
 904:	2800      	cmp	r0, #0
 906:	f000 8134 	beq.w	b72 <DoHandShakeMsgType+0xb72>
                    XMEMSET(ssl->arrays->preMasterSecret, 0, ENCRYPT_LEN);
 90a:	9907      	ldr	r1, [sp, #28]
 90c:	462a      	mov	r2, r5
 90e:	f7ff fffe 	bl	0 <memset>
                switch (ssl->specs.kea) {
 912:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 916:	2b07      	cmp	r3, #7
 918:	d001      	beq.n	91e <DoHandShakeMsgType+0x91e>
                        ret = BAD_KEA_TYPE_E;
 91a:	4d34      	ldr	r5, [pc, #208]	; (9ec <DoHandShakeMsgType+0x9ec>)
 91c:	e7ba      	b.n	894 <DoHandShakeMsgType+0x894>
                ssl->options.asyncState = TLS_ASYNC_BUILD;
 91e:	2301      	movs	r3, #1
 920:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                switch (ssl->specs.kea) {
 924:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 928:	2b07      	cmp	r3, #7
 92a:	d1f6      	bne.n	91a <DoHandShakeMsgType+0x91a>
                        if (ssl->specs.static_ecdh &&
 92c:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
                        ecc_key* private_key = ssl->eccTempKey;
 930:	f8d4 a294 	ldr.w	sl, [r4, #660]	; 0x294
                        if (ssl->specs.static_ecdh &&
 934:	b1cb      	cbz	r3, 96a <DoHandShakeMsgType+0x96a>
                                          ssl->ecdhCurveOID != ECC_X25519_OID &&
 936:	f8d4 3290 	ldr.w	r3, [r4, #656]	; 0x290
                        if (ssl->specs.static_ecdh &&
 93a:	f240 126d 	movw	r2, #365	; 0x16d
 93e:	4293      	cmp	r3, r2
 940:	d013      	beq.n	96a <DoHandShakeMsgType+0x96a>
                                          ssl->ecdhCurveOID != ECC_X25519_OID &&
 942:	f5b3 7fb5 	cmp.w	r3, #362	; 0x16a
 946:	d010      	beq.n	96a <DoHandShakeMsgType+0x96a>
                            ssl->buffers.keyType = ecc_dsa_sa_algo;
 948:	f894 30e4 	ldrb.w	r3, [r4, #228]	; 0xe4
 94c:	2203      	movs	r2, #3
 94e:	f362 0305 	bfi	r3, r2, #0, #6
 952:	f884 30e4 	strb.w	r3, [r4, #228]	; 0xe4
                            ret = DecodePrivateKey(ssl, &keySz);
 956:	f10d 0122 	add.w	r1, sp, #34	; 0x22
 95a:	4620      	mov	r0, r4
 95c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                            if (ret != 0) {
 960:	4605      	mov	r5, r0
 962:	2800      	cmp	r0, #0
 964:	d196      	bne.n	894 <DoHandShakeMsgType+0x894>
                            private_key = (ecc_key*)ssl->hsKey;
 966:	f8d4 a03c 	ldr.w	sl, [r4, #60]	; 0x3c
                        if ((args->idx - args->begin) + OPAQUE8_LEN > size) {
 96a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 96c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 96e:	1c51      	adds	r1, r2, #1
 970:	1acb      	subs	r3, r1, r3
 972:	4598      	cmp	r8, r3
 974:	d201      	bcs.n	97a <DoHandShakeMsgType+0x97a>
                            ERROR_OUT(BUFFER_ERROR, exit_dcke);
 976:	4d1c      	ldr	r5, [pc, #112]	; (9e8 <DoHandShakeMsgType+0x9e8>)
 978:	e78c      	b.n	894 <DoHandShakeMsgType+0x894>
                        args->length = input[args->idx++];
 97a:	5cba      	ldrb	r2, [r7, r2]
 97c:	910b      	str	r1, [sp, #44]	; 0x2c
                        if ((args->idx - args->begin) + args->length > size) {
 97e:	4413      	add	r3, r2
 980:	4598      	cmp	r8, r3
                        args->length = input[args->idx++];
 982:	920a      	str	r2, [sp, #40]	; 0x28
                        if ((args->idx - args->begin) + args->length > size) {
 984:	d3f7      	bcc.n	976 <DoHandShakeMsgType+0x976>
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 986:	f8d4 2290 	ldr.w	r2, [r4, #656]	; 0x290
 98a:	f240 136d 	movw	r3, #365	; 0x16d
 98e:	429a      	cmp	r2, r3
 990:	f040 8091 	bne.w	ab6 <DoHandShakeMsgType+0xab6>
                            if (ssl->peerX25519Key == NULL) {
 994:	f8d4 52b4 	ldr.w	r5, [r4, #692]	; 0x2b4
 998:	b99d      	cbnz	r5, 9c2 <DoHandShakeMsgType+0x9c2>
                                ret = AllocKey(ssl, DYNAMIC_TYPE_CURVE25519,
 99a:	f504 722d 	add.w	r2, r4, #692	; 0x2b4
 99e:	2145      	movs	r1, #69	; 0x45
 9a0:	4620      	mov	r0, r4
 9a2:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                                if (ret != 0) {
 9a6:	4605      	mov	r5, r0
 9a8:	2800      	cmp	r0, #0
 9aa:	f47f af73 	bne.w	894 <DoHandShakeMsgType+0x894>
                            if ((ret = wc_curve25519_check_public(
 9ae:	e9dd 100a 	ldrd	r1, r0, [sp, #40]	; 0x28
 9b2:	2200      	movs	r2, #0
 9b4:	4438      	add	r0, r7
 9b6:	f7ff fffe 	bl	0 <wc_curve25519_check_public>
 9ba:	4603      	mov	r3, r0
 9bc:	b1d0      	cbz	r0, 9f4 <DoHandShakeMsgType+0x9f4>
                                ERROR_OUT(ECC_PEERKEY_ERROR, exit_dcke);
 9be:	4d0c      	ldr	r5, [pc, #48]	; (9f0 <DoHandShakeMsgType+0x9f0>)
 9c0:	e768      	b.n	894 <DoHandShakeMsgType+0x894>
                            } else if (ssl->peerX25519KeyPresent) {
 9c2:	f894 32b8 	ldrb.w	r3, [r4, #696]	; 0x2b8
 9c6:	2b00      	cmp	r3, #0
 9c8:	d0f1      	beq.n	9ae <DoHandShakeMsgType+0x9ae>
            wc_curve25519_free((curve25519_key*)pKey);
 9ca:	4628      	mov	r0, r5
 9cc:	f7ff fffe 	bl	0 <wc_curve25519_free>
            ret = wc_curve25519_init_ex((curve25519_key*)pKey, ssl->heap,
 9d0:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
 9d4:	6a61      	ldr	r1, [r4, #36]	; 0x24
 9d6:	4628      	mov	r0, r5
 9d8:	f7ff fffe 	bl	0 <wc_curve25519_init_ex>
                                ssl->peerX25519KeyPresent = 0;
 9dc:	2300      	movs	r3, #0
 9de:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
                                if (ret != 0) {
 9e2:	e7e0      	b.n	9a6 <DoHandShakeMsgType+0x9a6>
 9e4:	fffffea2 	.word	0xfffffea2
 9e8:	fffffeb8 	.word	0xfffffeb8
 9ec:	fffffe8a 	.word	0xfffffe8a
 9f0:	fffffea0 	.word	0xfffffea0
                            if (wc_curve25519_import_public_ex(
 9f4:	e9dd 100a 	ldrd	r1, r0, [sp, #40]	; 0x28
 9f8:	f8d4 22b4 	ldr.w	r2, [r4, #692]	; 0x2b4
 9fc:	4438      	add	r0, r7
 9fe:	f7ff fffe 	bl	0 <wc_curve25519_import_public_ex>
 a02:	2800      	cmp	r0, #0
 a04:	d1db      	bne.n	9be <DoHandShakeMsgType+0x9be>
                            ssl->arrays->preMasterSz = CURVE25519_KEYSIZE;
 a06:	68a3      	ldr	r3, [r4, #8]
 a08:	2220      	movs	r2, #32
 a0a:	609a      	str	r2, [r3, #8]
                            ssl->peerX25519KeyPresent = 1;
 a0c:	2301      	movs	r3, #1
 a0e:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
                ssl->options.asyncState = TLS_ASYNC_DO;
 a12:	2302      	movs	r3, #2
 a14:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                switch (ssl->specs.kea) {
 a18:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 a1c:	2b07      	cmp	r3, #7
 a1e:	f47f af7c 	bne.w	91a <DoHandShakeMsgType+0x91a>
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 a22:	f8d4 1290 	ldr.w	r1, [r4, #656]	; 0x290
                                ssl->arrays->preMasterSecret,
 a26:	68a3      	ldr	r3, [r4, #8]
                        void* private_key = ssl->eccTempKey;
 a28:	f8d4 0294 	ldr.w	r0, [r4, #660]	; 0x294
                            ret = X25519SharedSecret(ssl,
 a2c:	685a      	ldr	r2, [r3, #4]
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 a2e:	f240 156d 	movw	r5, #365	; 0x16d
 a32:	42a9      	cmp	r1, r5
                            ret = X25519SharedSecret(ssl,
 a34:	f103 0308 	add.w	r3, r3, #8
                        if (ssl->ecdhCurveOID == ECC_X25519_OID) {
 a38:	d178      	bne.n	b2c <DoHandShakeMsgType+0xb2c>
        ret = wc_curve25519_shared_secret_ex(priv_key, pub_key, out, outlen,
 a3a:	2100      	movs	r1, #0
 a3c:	9100      	str	r1, [sp, #0]
 a3e:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
 a42:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret_ex>
 a46:	4605      	mov	r5, r0
                if (ret != 0) {
 a48:	2d00      	cmp	r5, #0
 a4a:	f47f af23 	bne.w	894 <DoHandShakeMsgType+0x894>
                ssl->options.asyncState = TLS_ASYNC_VERIFY;
 a4e:	2303      	movs	r3, #3
 a50:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                switch (ssl->specs.kea) {
 a54:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
 a58:	2b07      	cmp	r3, #7
 a5a:	f47f af5e 	bne.w	91a <DoHandShakeMsgType+0x91a>
                        args->idx += args->length;
 a5e:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 a62:	4413      	add	r3, r2
 a64:	930b      	str	r3, [sp, #44]	; 0x2c
                ssl->options.asyncState = TLS_ASYNC_FINALIZE;
 a66:	2304      	movs	r3, #4
 a68:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                if (IsEncryptionOn(ssl, 0)) {
 a6c:	2100      	movs	r1, #0
 a6e:	4620      	mov	r0, r4
 a70:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 a74:	b120      	cbz	r0, a80 <DoHandShakeMsgType+0xa80>
                    args->idx += ssl->keys.padSz;
 a76:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 a78:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 a7c:	4413      	add	r3, r2
 a7e:	930b      	str	r3, [sp, #44]	; 0x2c
                ret = MakeMasterSecret(ssl);
 a80:	4620      	mov	r0, r4
 a82:	f7ff fffe 	bl	0 <MakeMasterSecret>
                if (ret != 0) {
 a86:	4605      	mov	r5, r0
 a88:	2800      	cmp	r0, #0
 a8a:	f47f af03 	bne.w	894 <DoHandShakeMsgType+0x894>
                ssl->options.asyncState = TLS_ASYNC_END;
 a8e:	2305      	movs	r3, #5
 a90:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                *inOutIdx = args->idx;
 a94:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 a96:	6033      	str	r3, [r6, #0]
                if (ssl->options.verifyPeer) {
 a98:	f894 0270 	ldrb.w	r0, [r4, #624]	; 0x270
                ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
 a9c:	230d      	movs	r3, #13
                if (ssl->options.verifyPeer) {
 a9e:	f010 0040 	ands.w	r0, r0, #64	; 0x40
                ssl->options.clientState = CLIENT_KEYEXCHANGE_COMPLETE;
 aa2:	f884 327d 	strb.w	r3, [r4, #637]	; 0x27d
                if (ssl->options.verifyPeer) {
 aa6:	d004      	beq.n	ab2 <DoHandShakeMsgType+0xab2>
                    ret = BuildCertHashes(ssl, &ssl->hsHashes->certHashes);
 aa8:	68e1      	ldr	r1, [r4, #12]
 aaa:	4620      	mov	r0, r4
 aac:	3174      	adds	r1, #116	; 0x74
 aae:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 ab2:	4605      	mov	r5, r0
 ab4:	e6ee      	b.n	894 <DoHandShakeMsgType+0x894>
                        if (!ssl->specs.static_ecdh &&
 ab6:	f894 314f 	ldrb.w	r3, [r4, #335]	; 0x14f
 aba:	b91b      	cbnz	r3, ac4 <DoHandShakeMsgType+0xac4>
 abc:	f894 3298 	ldrb.w	r3, [r4, #664]	; 0x298
 ac0:	2b00      	cmp	r3, #0
 ac2:	d059      	beq.n	b78 <DoHandShakeMsgType+0xb78>
                        if (ssl->peerEccKey == NULL) {
 ac4:	f8d4 529c 	ldr.w	r5, [r4, #668]	; 0x29c
 ac8:	b9fd      	cbnz	r5, b0a <DoHandShakeMsgType+0xb0a>
                            ret = AllocKey(ssl, DYNAMIC_TYPE_ECC,
 aca:	f504 7227 	add.w	r2, r4, #668	; 0x29c
 ace:	2125      	movs	r1, #37	; 0x25
 ad0:	4620      	mov	r0, r4
 ad2:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                            if (ret != 0) {
 ad6:	4605      	mov	r5, r0
 ad8:	2800      	cmp	r0, #0
 ada:	f47f aedb 	bne.w	894 <DoHandShakeMsgType+0x894>
                        if (wc_ecc_import_x963_ex(input + args->idx,
 ade:	e9dd 100a 	ldrd	r1, r0, [sp, #40]	; 0x28
 ae2:	f8da 3010 	ldr.w	r3, [sl, #16]
 ae6:	f8d4 229c 	ldr.w	r2, [r4, #668]	; 0x29c
 aea:	685b      	ldr	r3, [r3, #4]
 aec:	4438      	add	r0, r7
 aee:	f7ff fffe 	bl	0 <wc_ecc_import_x963_ex>
 af2:	2800      	cmp	r0, #0
 af4:	f47f af63 	bne.w	9be <DoHandShakeMsgType+0x9be>
                        ssl->arrays->preMasterSz = private_key->dp->size;
 af8:	f8da 2010 	ldr.w	r2, [sl, #16]
 afc:	68a3      	ldr	r3, [r4, #8]
 afe:	6812      	ldr	r2, [r2, #0]
 b00:	609a      	str	r2, [r3, #8]
                        ssl->peerEccKeyPresent = 1;
 b02:	2301      	movs	r3, #1
 b04:	f884 3299 	strb.w	r3, [r4, #665]	; 0x299
                if (ret != 0) {
 b08:	e783      	b.n	a12 <DoHandShakeMsgType+0xa12>
                        } else if (ssl->peerEccKeyPresent) {
 b0a:	f894 3299 	ldrb.w	r3, [r4, #665]	; 0x299
 b0e:	2b00      	cmp	r3, #0
 b10:	d0e5      	beq.n	ade <DoHandShakeMsgType+0xade>
            wc_ecc_free((ecc_key*)pKey);
 b12:	4628      	mov	r0, r5
 b14:	f7ff fffe 	bl	0 <wc_ecc_free>
            ret = wc_ecc_init_ex((ecc_key*)pKey, ssl->heap, ssl->devId);
 b18:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
 b1c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 b1e:	4628      	mov	r0, r5
 b20:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
                            ssl->peerEccKeyPresent = 0;
 b24:	2300      	movs	r3, #0
 b26:	f884 3299 	strb.w	r3, [r4, #665]	; 0x299
                            if (ret != 0) {
 b2a:	e7d4      	b.n	ad6 <DoHandShakeMsgType+0xad6>
                        if (ssl->specs.static_ecdh) {
 b2c:	f894 114f 	ldrb.w	r1, [r4, #335]	; 0x14f
 b30:	b101      	cbz	r1, b34 <DoHandShakeMsgType+0xb34>
                            private_key = ssl->hsKey;
 b32:	6be0      	ldr	r0, [r4, #60]	; 0x3c
                        ret = EccSharedSecret(ssl,
 b34:	9201      	str	r2, [sp, #4]
 b36:	f04f 0800 	mov.w	r8, #0
 b3a:	e9cd 3802 	strd	r3, r8, [sp, #8]
 b3e:	ab0a      	add	r3, sp, #40	; 0x28
 b40:	9300      	str	r3, [sp, #0]
 b42:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 b44:	f8d4 229c 	ldr.w	r2, [r4, #668]	; 0x29c
 b48:	4601      	mov	r1, r0
 b4a:	443b      	add	r3, r7
 b4c:	4620      	mov	r0, r4
 b4e:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                            FreeKey(ssl, DYNAMIC_TYPE_ECC,
 b52:	f504 7227 	add.w	r2, r4, #668	; 0x29c
                        ret = EccSharedSecret(ssl,
 b56:	4605      	mov	r5, r0
                            FreeKey(ssl, DYNAMIC_TYPE_ECC,
 b58:	2125      	movs	r1, #37	; 0x25
 b5a:	4620      	mov	r0, r4
 b5c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                            ssl->peerEccKeyPresent = 0;
 b60:	f884 8299 	strb.w	r8, [r4, #665]	; 0x299
                        break;
 b64:	e770      	b.n	a48 <DoHandShakeMsgType+0xa48>
        switch(ssl->options.asyncState)
 b66:	f46f 7596 	mvn.w	r5, #300	; 0x12c
 b6a:	e693      	b.n	894 <DoHandShakeMsgType+0x894>
                        ERROR_OUT(NO_PEER_CERT, exit_dcke);
 b6c:	f46f 75ac 	mvn.w	r5, #344	; 0x158
 b70:	e690      	b.n	894 <DoHandShakeMsgType+0x894>
                        ERROR_OUT(MEMORY_E, exit_dcke);
 b72:	f06f 057c 	mvn.w	r5, #124	; 0x7c
 b76:	e68d      	b.n	894 <DoHandShakeMsgType+0x894>
                            ERROR_OUT(ECC_MAKEKEY_ERROR, exit_dcke);
 b78:	f46f 75b0 	mvn.w	r5, #352	; 0x160
 b7c:	e68a      	b.n	894 <DoHandShakeMsgType+0x894>
            ssl->options.asyncState = TLS_ASYNC_BEGIN;
 b7e:	2100      	movs	r1, #0
 b80:	f884 1283 	strb.w	r1, [r4, #643]	; 0x283
            XMEMSET(args, 0, sizeof(DcvArgs));
 b84:	221c      	movs	r2, #28
 b86:	a809      	add	r0, sp, #36	; 0x24
 b88:	f7ff fffe 	bl	0 <memset>
            args->hashAlgo = sha_mac;
 b8c:	2302      	movs	r3, #2
            args->idx = *inOutIdx;
 b8e:	6835      	ldr	r5, [r6, #0]
            args->hashAlgo = sha_mac;
 b90:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
        switch(ssl->options.asyncState)
 b94:	f894 3283 	ldrb.w	r3, [r4, #643]	; 0x283
            args->begin = *inOutIdx;
 b98:	e9cd 550d 	strd	r5, r5, [sp, #52]	; 0x34
        switch(ssl->options.asyncState)
 b9c:	2b05      	cmp	r3, #5
 b9e:	d804      	bhi.n	baa <DoHandShakeMsgType+0xbaa>
 ba0:	e8df f003 	tbb	[pc, r3]
 ba4:	a7611b18 	.word	0xa7611b18
 ba8:	c3aa      	.short	0xc3aa
 baa:	f46f 7596 	mvn.w	r5, #300	; 0x12c
        if(ssl->buffers.digest.buffer) {
 bae:	f8d4 00c8 	ldr.w	r0, [r4, #200]	; 0xc8
 bb2:	b128      	cbz	r0, bc0 <DoHandShakeMsgType+0xbc0>
            if (!ssl->options.dontFreeDigest) {
 bb4:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
 bb8:	075a      	lsls	r2, r3, #29
 bba:	d401      	bmi.n	bc0 <DoHandShakeMsgType+0xbc0>
                XFREE(ssl->buffers.digest.buffer,
 bbc:	f7ff fffe 	bl	0 <free>
        ssl->options.dontFreeDigest = 0;
 bc0:	f894 2275 	ldrb.w	r2, [r4, #629]	; 0x275
        ssl->buffers.digest.buffer = NULL;
 bc4:	2300      	movs	r3, #0
        ssl->options.dontFreeDigest = 0;
 bc6:	f363 0282 	bfi	r2, r3, #2, #1
        ssl->buffers.digest.length = 0;
 bca:	e9c4 3332 	strd	r3, r3, [r4, #200]	; 0xc8
        ssl->options.dontFreeDigest = 0;
 bce:	f884 2275 	strb.w	r2, [r4, #629]	; 0x275
 bd2:	e429      	b.n	428 <DoHandShakeMsgType+0x428>
                ssl->options.asyncState = TLS_ASYNC_BUILD;
 bd4:	2301      	movs	r3, #1
 bd6:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                if (IsAtLeastTLSv1_2(ssl)) {
 bda:	4620      	mov	r0, r4
 bdc:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 be0:	2800      	cmp	r0, #0
 be2:	f000 80a4 	beq.w	d2e <DoHandShakeMsgType+0xd2e>
                    if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > size) {
 be6:	f1b8 0f01 	cmp.w	r8, #1
 bea:	d801      	bhi.n	bf0 <DoHandShakeMsgType+0xbf0>
                        ERROR_OUT(BUFFER_ERROR, exit_dcv);
 bec:	4d5c      	ldr	r5, [pc, #368]	; (d60 <DoHandShakeMsgType+0xd60>)
 bee:	e7de      	b.n	bae <DoHandShakeMsgType+0xbae>
                    DecodeSigAlg(&input[args->idx], &args->hashAlgo,
 bf0:	f10d 023d 	add.w	r2, sp, #61	; 0x3d
 bf4:	a90f      	add	r1, sp, #60	; 0x3c
 bf6:	1978      	adds	r0, r7, r5
 bf8:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    args->idx += 2;
 bfc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 bfe:	3302      	adds	r3, #2
 c00:	930d      	str	r3, [sp, #52]	; 0x34
                if ((args->idx - args->begin) + OPAQUE16_LEN > size) {
 c02:	980d      	ldr	r0, [sp, #52]	; 0x34
 c04:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 c06:	1c83      	adds	r3, r0, #2
 c08:	1a9b      	subs	r3, r3, r2
 c0a:	4598      	cmp	r8, r3
 c0c:	d3ee      	bcc.n	bec <DoHandShakeMsgType+0xbec>
                ato16(input + args->idx, &args->sz);
 c0e:	a90b      	add	r1, sp, #44	; 0x2c
 c10:	4438      	add	r0, r7
 c12:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                args->idx += OPAQUE16_LEN;
 c16:	9b0d      	ldr	r3, [sp, #52]	; 0x34
                if ((args->idx - args->begin) + args->sz > size ||
 c18:	990e      	ldr	r1, [sp, #56]	; 0x38
 c1a:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
                args->idx += OPAQUE16_LEN;
 c1e:	3302      	adds	r3, #2
 c20:	930d      	str	r3, [sp, #52]	; 0x34
                if ((args->idx - args->begin) + args->sz > size ||
 c22:	1a5b      	subs	r3, r3, r1
 c24:	4413      	add	r3, r2
 c26:	4598      	cmp	r8, r3
 c28:	d3e0      	bcc.n	bec <DoHandShakeMsgType+0xbec>
 c2a:	2a8b      	cmp	r2, #139	; 0x8b
 c2c:	d8de      	bhi.n	bec <DoHandShakeMsgType+0xbec>
                if (ssl->peerEccDsaKeyPresent) {
 c2e:	f894 32a6 	ldrb.w	r3, [r4, #678]	; 0x2a6
 c32:	b1ab      	cbz	r3, c60 <DoHandShakeMsgType+0xc60>
            ssl->options.dontFreeDigest = 1;
 c34:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
 c38:	f043 0304 	orr.w	r3, r3, #4
 c3c:	f884 3275 	strb.w	r3, [r4, #629]	; 0x275
            ssl->buffers.digest.buffer = ssl->hsHashes->certHashes.sha;
 c40:	68e3      	ldr	r3, [r4, #12]
 c42:	3374      	adds	r3, #116	; 0x74
 c44:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
            ssl->buffers.digest.length = WC_SHA_DIGEST_SIZE;
 c48:	2314      	movs	r3, #20
 c4a:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
                    if (IsAtLeastTLSv1_2(ssl)) {
 c4e:	4620      	mov	r0, r4
 c50:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 c54:	b120      	cbz	r0, c60 <DoHandShakeMsgType+0xc60>
                        SetDigest(ssl, args->hashAlgo);
 c56:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
 c5a:	4620      	mov	r0, r4
 c5c:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                ssl->options.asyncState = TLS_ASYNC_DO;
 c60:	2302      	movs	r3, #2
 c62:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                if (ssl->peerEccDsaKeyPresent) {
 c66:	f894 02a6 	ldrb.w	r0, [r4, #678]	; 0x2a6
 c6a:	b1f0      	cbz	r0, caa <DoHandShakeMsgType+0xcaa>
                        ret = EccVerify(ssl,
 c6c:	2300      	movs	r3, #0
 c6e:	990d      	ldr	r1, [sp, #52]	; 0x34
 c70:	9302      	str	r3, [sp, #8]
 c72:	f8d4 32a0 	ldr.w	r3, [r4, #672]	; 0x2a0
 c76:	9301      	str	r3, [sp, #4]
 c78:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
 c7c:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
 c80:	9300      	str	r3, [sp, #0]
 c82:	4439      	add	r1, r7
 c84:	f8d4 30c8 	ldr.w	r3, [r4, #200]	; 0xc8
 c88:	4620      	mov	r0, r4
 c8a:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    ssl->options.peerAuthGood = ssl->options.havePeerCert &&
 c8e:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 c92:	f894 2276 	ldrb.w	r2, [r4, #630]	; 0x276
 c96:	f013 0301 	ands.w	r3, r3, #1
 c9a:	bf1c      	itt	ne
 c9c:	fab0 f380 	clzne	r3, r0
 ca0:	095b      	lsrne	r3, r3, #5
 ca2:	f363 0241 	bfi	r2, r3, #1, #1
 ca6:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
                if (ssl->peerEd25519KeyPresent) {
 caa:	f894 32b0 	ldrb.w	r3, [r4, #688]	; 0x2b0
 cae:	b1fb      	cbz	r3, cf0 <DoHandShakeMsgType+0xcf0>
                    ret = Ed25519Verify(ssl,
 cb0:	2200      	movs	r2, #0
 cb2:	9202      	str	r2, [sp, #8]
                        ssl->hsHashes->messages, ssl->hsHashes->prevLen,
 cb4:	68e3      	ldr	r3, [r4, #12]
                    ret = Ed25519Verify(ssl,
 cb6:	f8d4 22ac 	ldr.w	r2, [r4, #684]	; 0x2ac
 cba:	9201      	str	r2, [sp, #4]
 cbc:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
 cc0:	990d      	ldr	r1, [sp, #52]	; 0x34
 cc2:	9200      	str	r2, [sp, #0]
 cc4:	f8d3 32a0 	ldr.w	r3, [r3, #672]	; 0x2a0
 cc8:	f8bd 202c 	ldrh.w	r2, [sp, #44]	; 0x2c
 ccc:	4439      	add	r1, r7
 cce:	4620      	mov	r0, r4
 cd0:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
                    ssl->options.peerAuthGood = ssl->options.havePeerCert &&
 cd4:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
 cd8:	f894 2276 	ldrb.w	r2, [r4, #630]	; 0x276
 cdc:	f013 0301 	ands.w	r3, r3, #1
 ce0:	bf1c      	itt	ne
 ce2:	fab0 f380 	clzne	r3, r0
 ce6:	095b      	lsrne	r3, r3, #5
 ce8:	f363 0241 	bfi	r2, r3, #1, #1
 cec:	f884 2276 	strb.w	r2, [r4, #630]	; 0x276
                if (ret != 0) {
 cf0:	bb58      	cbnz	r0, d4a <DoHandShakeMsgType+0xd4a>
                ssl->options.asyncState = TLS_ASYNC_FINALIZE;
 cf2:	2304      	movs	r3, #4
 cf4:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
                if (IsEncryptionOn(ssl, 0)) {
 cf8:	2100      	movs	r1, #0
 cfa:	4620      	mov	r0, r4
 cfc:	f7ff fffe 	bl	0 <DoHandShakeMsgType>
 d00:	b120      	cbz	r0, d0c <DoHandShakeMsgType+0xd0c>
                    args->idx += ssl->keys.padSz;
 d02:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 d04:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 d08:	4413      	add	r3, r2
 d0a:	930d      	str	r3, [sp, #52]	; 0x34
                ssl->options.havePeerVerify = 1;
 d0c:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
                args->idx += args->sz;
 d10:	9a0d      	ldr	r2, [sp, #52]	; 0x34
                ssl->options.havePeerVerify = 1;
 d12:	f043 0302 	orr.w	r3, r3, #2
 d16:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
                args->idx += args->sz;
 d1a:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
 d1e:	4413      	add	r3, r2
                *inOutIdx = args->idx;
 d20:	6033      	str	r3, [r6, #0]
                args->idx += args->sz;
 d22:	930d      	str	r3, [sp, #52]	; 0x34
                ssl->options.asyncState = TLS_ASYNC_END;
 d24:	2305      	movs	r3, #5
 d26:	f884 3283 	strb.w	r3, [r4, #643]	; 0x283
            ret = 0;
 d2a:	2500      	movs	r5, #0
 d2c:	e73f      	b.n	bae <DoHandShakeMsgType+0xbae>
                else if (ssl->peerEccDsaKeyPresent) {
 d2e:	f894 32a6 	ldrb.w	r3, [r4, #678]	; 0x2a6
 d32:	b11b      	cbz	r3, d3c <DoHandShakeMsgType+0xd3c>
                        args->sigAlgo = ecc_dsa_sa_algo;
 d34:	2303      	movs	r3, #3
                    args->sigAlgo = ed25519_sa_algo;
 d36:	f88d 303d 	strb.w	r3, [sp, #61]	; 0x3d
 d3a:	e762      	b.n	c02 <DoHandShakeMsgType+0xc02>
                else if (ssl->peerEd25519KeyPresent)
 d3c:	f894 32b0 	ldrb.w	r3, [r4, #688]	; 0x2b0
 d40:	2b00      	cmp	r3, #0
 d42:	f43f af5e 	beq.w	c02 <DoHandShakeMsgType+0xc02>
                    args->sigAlgo = ed25519_sa_algo;
 d46:	2309      	movs	r3, #9
 d48:	e7f5      	b.n	d36 <DoHandShakeMsgType+0xd36>
                    ret = SIG_VERIFY_E;
 d4a:	f06f 05e4 	mvn.w	r5, #228	; 0xe4
 d4e:	e72e      	b.n	bae <DoHandShakeMsgType+0xbae>
        return INCOMPLETE_DATA;
 d50:	f8df 9010 	ldr.w	r9, [pc, #16]	; d64 <DoHandShakeMsgType+0xd64>
 d54:	f7ff b97b 	b.w	4e <DoHandShakeMsgType+0x4e>
    switch (type) {
 d58:	f46f 7999 	mvn.w	r9, #306	; 0x132
 d5c:	f7ff b977 	b.w	4e <DoHandShakeMsgType+0x4e>
 d60:	fffffeb8 	.word	0xfffffeb8
 d64:	fffffeca 	.word	0xfffffeca

Disassembly of section .text.ProcessReplyEx:

00000000 <ProcessReplyEx>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (ssl->error != 0 && ssl->error != WANT_READ && ssl->error != WANT_WRITE
   4:	f8d0 6114 	ldr.w	r6, [r0, #276]	; 0x114
{
   8:	b09b      	sub	sp, #108	; 0x6c
   a:	4604      	mov	r4, r0
    if (ssl->error != 0 && ssl->error != WANT_READ && ssl->error != WANT_WRITE
   c:	b156      	cbz	r6, 24 <ProcessReplyEx+0x24>
   e:	f026 0204 	bic.w	r2, r6, #4
  12:	f46f 73a3 	mvn.w	r3, #326	; 0x146
  16:	429a      	cmp	r2, r3
  18:	d004      	beq.n	24 <ProcessReplyEx+0x24>
        && (allowSocketErr != 1 || ssl->error != SOCKET_ERROR_E)
  1a:	2901      	cmp	r1, #1
  1c:	d16f      	bne.n	fe <ProcessReplyEx+0xfe>
  1e:	f516 7f9a 	cmn.w	r6, #308	; 0x134
  22:	d16c      	bne.n	fe <ProcessReplyEx+0xfe>
    ret = RetrySendAlert(ssl);
  24:	4620      	mov	r0, r4
  26:	f7ff fffe 	bl	0 <ProcessReplyEx>
    if (ret != 0)
  2a:	4606      	mov	r6, r0
  2c:	2800      	cmp	r0, #0
  2e:	d166      	bne.n	fe <ProcessReplyEx+0xfe>
    word32 startIdx = 0;
  30:	4682      	mov	sl, r0
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
  32:	4680      	mov	r8, r0
        switch (ssl->options.processReply) {
  34:	f894 3277 	ldrb.w	r3, [r4, #631]	; 0x277
  38:	2b08      	cmp	r3, #8
  3a:	f200 840f 	bhi.w	85c <ProcessReplyEx+0x85c>
  3e:	e8df f013 	tbh	[pc, r3, lsl #1]
  42:	0009      	.short	0x0009
  44:	0013040d 	.word	0x0013040d
  48:	007d006e 	.word	0x007d006e
  4c:	01810080 	.word	0x01810080
  50:	01d701d4 	.word	0x01d701d4
            if (!ssl->options.dtls) {
  54:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  58:	075b      	lsls	r3, r3, #29
  5a:	d405      	bmi.n	68 <ProcessReplyEx+0x68>
                if ((ret = GetInputData(ssl, readSz)) < 0)
  5c:	2105      	movs	r1, #5
  5e:	4620      	mov	r0, r4
  60:	f7ff fffe 	bl	0 <ProcessReplyEx>
  64:	1e06      	subs	r6, r0, #0
  66:	db4a      	blt.n	fe <ProcessReplyEx+0xfe>
    if (!ssl->options.dtls) {
  68:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  6c:	075f      	lsls	r7, r3, #29
  6e:	d414      	bmi.n	9a <ProcessReplyEx+0x9a>
        XMEMCPY(rh, ssl->buffers.inputBuffer.buffer + *inOutIdx, RECORD_HEADER_SZ);
  70:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
  74:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
  78:	2205      	movs	r2, #5
  7a:	4419      	add	r1, r3
  7c:	f204 1033 	addw	r0, r4, #307	; 0x133
  80:	f7ff fffe 	bl	0 <memcpy>
        *inOutIdx += RECORD_HEADER_SZ;
  84:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
  88:	3305      	adds	r3, #5
  8a:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
        ato16(rh->length, size);
  8e:	f504 7198 	add.w	r1, r4, #304	; 0x130
  92:	f504 709b 	add.w	r0, r4, #310	; 0x136
  96:	f7ff fffe 	bl	0 <ProcessReplyEx>
    if (rh->pvMajor != ssl->version.major || rh->pvMinor != ssl->version.minor)
  9a:	f894 2134 	ldrb.w	r2, [r4, #308]	; 0x134
  9e:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
  a2:	429a      	cmp	r2, r3
  a4:	d105      	bne.n	b2 <ProcessReplyEx+0xb2>
  a6:	f894 2135 	ldrb.w	r2, [r4, #309]	; 0x135
  aa:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
  ae:	429a      	cmp	r2, r3
  b0:	d01d      	beq.n	ee <ProcessReplyEx+0xee>
        if (ssl->options.side == WOLFSSL_SERVER_END &&
  b2:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  b6:	f013 0330 	ands.w	r3, r3, #48	; 0x30
  ba:	d103      	bne.n	c4 <ProcessReplyEx+0xc4>
  bc:	f894 2282 	ldrb.w	r2, [r4, #642]	; 0x282
  c0:	2a03      	cmp	r2, #3
  c2:	d914      	bls.n	ee <ProcessReplyEx+0xee>
        else if (ssl->options.side == WOLFSSL_CLIENT_END &&
  c4:	f8b4 2270 	ldrh.w	r2, [r4, #624]	; 0x270
  c8:	f402 6286 	and.w	r2, r2, #1072	; 0x430
  cc:	f5b2 6f82 	cmp.w	r2, #1040	; 0x410
  d0:	d103      	bne.n	da <ProcessReplyEx+0xda>
                                 ssl->options.downgrade &&
  d2:	f894 2281 	ldrb.w	r2, [r4, #641]	; 0x281
  d6:	2a03      	cmp	r2, #3
  d8:	d909      	bls.n	ee <ProcessReplyEx+0xee>
        else if (ssl->options.dtls && rh->type == handshake)
  da:	f894 2272 	ldrb.w	r2, [r4, #626]	; 0x272
  de:	0756      	lsls	r6, r2, #29
  e0:	f140 83d4 	bpl.w	88c <ProcessReplyEx+0x88c>
  e4:	f894 2133 	ldrb.w	r2, [r4, #307]	; 0x133
  e8:	2a16      	cmp	r2, #22
  ea:	f040 83cf 	bne.w	88c <ProcessReplyEx+0x88c>
    if (*size > (MAX_RECORD_SIZE + MAX_COMP_EXTRA + MAX_MSG_EXTRA)) {
  ee:	f8b4 2130 	ldrh.w	r2, [r4, #304]	; 0x130
  f2:	f244 4366 	movw	r3, #17510	; 0x4466
  f6:	429a      	cmp	r2, r3
  f8:	d905      	bls.n	106 <ProcessReplyEx+0x106>
        return LENGTH_ERROR;
  fa:	f46f 76aa 	mvn.w	r6, #340	; 0x154
}
  fe:	4630      	mov	r0, r6
 100:	b01b      	add	sp, #108	; 0x6c
 102:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        else if (ssl->options.dtls && rh->type == handshake)
 106:	f894 3133 	ldrb.w	r3, [r4, #307]	; 0x133
    if (*size == 0 && rh->type != application_data) {
 10a:	2a00      	cmp	r2, #0
 10c:	d172      	bne.n	1f4 <ProcessReplyEx+0x1f4>
 10e:	2b17      	cmp	r3, #23
 110:	d1f3      	bne.n	fa <ProcessReplyEx+0xfa>
            ssl->options.processReply = getData;
 112:	2303      	movs	r3, #3
    ssl->keys.decryptedCur = 0;
 114:	f884 8269 	strb.w	r8, [r4, #617]	; 0x269
            ssl->options.processReply = getData;
 118:	f884 3277 	strb.w	r3, [r4, #631]	; 0x277
            ret = GetRecordHeader(ssl, &ssl->buffers.inputBuffer.idx,
 11c:	2600      	movs	r6, #0
            if (!ssl->options.dtls) {
 11e:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 122:	075d      	lsls	r5, r3, #29
 124:	d406      	bmi.n	134 <ProcessReplyEx+0x134>
                if ((ret = GetInputData(ssl, ssl->curSize)) < 0) {
 126:	f8b4 1130 	ldrh.w	r1, [r4, #304]	; 0x130
 12a:	4620      	mov	r0, r4
 12c:	f7ff fffe 	bl	0 <ProcessReplyEx>
 130:	1e06      	subs	r6, r0, #0
 132:	dbe4      	blt.n	fe <ProcessReplyEx+0xfe>
            startIdx = ssl->buffers.inputBuffer.idx;  /* in case > 1 msg per */
 134:	f8d4 a088 	ldr.w	sl, [r4, #136]	; 0x88
            ssl->keys.padSz = 0;
 138:	f8c4 8264 	str.w	r8, [r4, #612]	; 0x264
            ssl->options.processReply = decryptMessage;
 13c:	2305      	movs	r3, #5
 13e:	f884 3277 	strb.w	r3, [r4, #631]	; 0x277
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
 142:	2100      	movs	r1, #0
 144:	4620      	mov	r0, r4
 146:	f7ff fffe 	bl	0 <ProcessReplyEx>
 14a:	2800      	cmp	r0, #0
 14c:	f000 80f7 	beq.w	33e <ProcessReplyEx+0x33e>
 150:	f894 3269 	ldrb.w	r3, [r4, #617]	; 0x269
 154:	2b00      	cmp	r3, #0
 156:	f040 80f2 	bne.w	33e <ProcessReplyEx+0x33e>
                                        (!IsAtLeastTLSv1_3(ssl->version) ||
 15a:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
 15e:	f7ff fffe 	bl	0 <ProcessReplyEx>
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
 162:	b120      	cbz	r0, 16e <ProcessReplyEx+0x16e>
                                        (!IsAtLeastTLSv1_3(ssl->version) ||
 164:	f894 3133 	ldrb.w	r3, [r4, #307]	; 0x133
 168:	2b14      	cmp	r3, #20
 16a:	f000 80e8 	beq.w	33e <ProcessReplyEx+0x33e>
    if (ssl->specs.cipher_type == block) {
 16e:	f894 3149 	ldrb.w	r3, [r4, #329]	; 0x149
                ret = SanityCheckCipherText(ssl, ssl->curSize);
 172:	f8b4 6130 	ldrh.w	r6, [r4, #304]	; 0x130
    word32 minLength = ssl->specs.hash_size; /* covers stream */
 176:	f894 214d 	ldrb.w	r2, [r4, #333]	; 0x14d
    if (ssl->specs.cipher_type == block) {
 17a:	2b01      	cmp	r3, #1
 17c:	d140      	bne.n	200 <ProcessReplyEx+0x200>
        if (encryptSz % ssl->specs.block_size) {
 17e:	f8b4 3144 	ldrh.w	r3, [r4, #324]	; 0x144
 182:	fbb6 f1f3 	udiv	r1, r6, r3
 186:	fb03 6111 	mls	r1, r3, r1, r6
 18a:	2900      	cmp	r1, #0
 18c:	f040 8369 	bne.w	862 <ProcessReplyEx+0x862>
        minLength++;  /* pad byte */
 190:	3201      	adds	r2, #1
        if (ssl->options.tls1_1)
 192:	f994 1271 	ldrsb.w	r1, [r4, #625]	; 0x271
 196:	429a      	cmp	r2, r3
 198:	bf38      	it	cc
 19a:	461a      	movcc	r2, r3
 19c:	2900      	cmp	r1, #0
 19e:	da00      	bge.n	1a2 <ProcessReplyEx+0x1a2>
            minLength += ssl->specs.block_size;  /* explicit IV */
 1a0:	441a      	add	r2, r3
    if (encryptSz < minLength) {
 1a2:	4296      	cmp	r6, r2
 1a4:	f0c0 835d 	bcc.w	862 <ProcessReplyEx+0x862>
                    if (!ssl->options.tls1_3) {
 1a8:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 1ac:	f013 0301 	ands.w	r3, r3, #1
 1b0:	f040 8149 	bne.w	446 <ProcessReplyEx+0x446>
                        ret = DecryptTls(ssl,
 1b4:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
 1b8:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
        ssl->decrypt.state = CIPHER_STATE_BEGIN;
 1bc:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
            if (ssl->decrypt.setup == 0) {
 1c0:	f894 3075 	ldrb.w	r3, [r4, #117]	; 0x75
                        ret = DecryptTls(ssl,
 1c4:	4415      	add	r5, r2
            if (ssl->decrypt.setup == 0) {
 1c6:	2b00      	cmp	r3, #0
 1c8:	f000 813d 	beq.w	446 <ProcessReplyEx+0x446>
            if (ssl->specs.bulk_cipher_algorithm == wolfssl_aes_ccm ||
 1cc:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
 1d0:	1fda      	subs	r2, r3, #7
 1d2:	2a01      	cmp	r2, #1
 1d4:	d963      	bls.n	29e <ProcessReplyEx+0x29e>
                ssl->specs.bulk_cipher_algorithm == wolfssl_aes_gcm ||
 1d6:	2b0e      	cmp	r3, #14
 1d8:	d061      	beq.n	29e <ProcessReplyEx+0x29e>
    switch (ssl->specs.bulk_cipher_algorithm)
 1da:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
            ssl->decrypt.state = CIPHER_STATE_DO;
 1de:	2701      	movs	r7, #1
    switch (ssl->specs.bulk_cipher_algorithm)
 1e0:	2b06      	cmp	r3, #6
            ssl->decrypt.state = CIPHER_STATE_DO;
 1e2:	f884 7074 	strb.w	r7, [r4, #116]	; 0x74
    switch (ssl->specs.bulk_cipher_algorithm)
 1e6:	f000 808f 	beq.w	308 <ProcessReplyEx+0x308>
 1ea:	d813      	bhi.n	214 <ProcessReplyEx+0x214>
 1ec:	2b04      	cmp	r3, #4
 1ee:	d06a      	beq.n	2c6 <ProcessReplyEx+0x2c6>
 1f0:	4eb5      	ldr	r6, [pc, #724]	; (4c8 <ProcessReplyEx+0x4c8>)
 1f2:	e06f      	b.n	2d4 <ProcessReplyEx+0x2d4>
    switch (rh->type) {
 1f4:	3b14      	subs	r3, #20
 1f6:	2b03      	cmp	r3, #3
 1f8:	d98b      	bls.n	112 <ProcessReplyEx+0x112>
 1fa:	f46f 769b 	mvn.w	r6, #310	; 0x136
 1fe:	e77e      	b.n	fe <ProcessReplyEx+0xfe>
    if (ssl->specs.cipher_type == aead) {
 200:	2b02      	cmp	r3, #2
 202:	d1ce      	bne.n	1a2 <ProcessReplyEx+0x1a2>
    return (ssl->specs.cipher_type == aead) &&
 204:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
        minLength = ssl->specs.aead_mac_size;    /* authTag size */
 208:	f8b4 2146 	ldrh.w	r2, [r4, #326]	; 0x146
    return (ssl->specs.cipher_type == aead) &&
 20c:	2b09      	cmp	r3, #9
            minLength += AESGCM_EXP_IV_SZ;       /* explicit IV  */
 20e:	bf18      	it	ne
 210:	3208      	addne	r2, #8
 212:	e7c6      	b.n	1a2 <ProcessReplyEx+0x1a2>
    switch (ssl->specs.bulk_cipher_algorithm)
 214:	3b07      	subs	r3, #7
 216:	2b01      	cmp	r3, #1
 218:	d8ea      	bhi.n	1f0 <ProcessReplyEx+0x1f0>
            XMEMSET(ssl->decrypt.additional, 0, AEAD_AUTH_DATA_SZ);
 21a:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 21c:	220d      	movs	r2, #13
 21e:	2100      	movs	r1, #0
 220:	f7ff fffe 	bl	0 <memset>
            WriteSEQ(ssl, PEER_ORDER, ssl->decrypt.additional);
 224:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 226:	4639      	mov	r1, r7
 228:	4620      	mov	r0, r4
 22a:	f7ff fffe 	bl	0 <ProcessReplyEx>
            ssl->decrypt.additional[AEAD_TYPE_OFFSET] = ssl->curRL.type;
 22e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 230:	f894 2133 	ldrb.w	r2, [r4, #307]	; 0x133
 234:	721a      	strb	r2, [r3, #8]
            ssl->decrypt.additional[AEAD_VMAJ_OFFSET] = ssl->curRL.pvMajor;
 236:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 238:	f894 2134 	ldrb.w	r2, [r4, #308]	; 0x134
 23c:	725a      	strb	r2, [r3, #9]
            ssl->decrypt.additional[AEAD_VMIN_OFFSET] = ssl->curRL.pvMinor;
 23e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 240:	f894 2135 	ldrb.w	r2, [r4, #309]	; 0x135
 244:	729a      	strb	r2, [r3, #10]
            c16toa(sz - AESGCM_EXP_IV_SZ - ssl->specs.aead_mac_size,
 246:	f8b4 3146 	ldrh.w	r3, [r4, #326]	; 0x146
                                    ssl->decrypt.additional + AEAD_LEN_OFFSET);
 24a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
            c16toa(sz - AESGCM_EXP_IV_SZ - ssl->specs.aead_mac_size,
 24c:	f1a6 0708 	sub.w	r7, r6, #8
 250:	1afb      	subs	r3, r7, r3
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 252:	f3c3 2107 	ubfx	r1, r3, #8, #8
    c[1] =  (byte)(wc_u16       & 0xff);
 256:	7313      	strb	r3, [r2, #12]
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 258:	72d1      	strb	r1, [r2, #11]
                XMEMCPY(ssl->decrypt.nonce, ssl->keys.aead_dec_imp_IV,
 25a:	6f20      	ldr	r0, [r4, #112]	; 0x70
 25c:	f504 7111 	add.w	r1, r4, #580	; 0x244
 260:	2204      	movs	r2, #4
 262:	f7ff fffe 	bl	0 <memcpy>
            XMEMCPY(ssl->decrypt.nonce + AESGCM_IMP_IV_SZ, input,
 266:	6f20      	ldr	r0, [r4, #112]	; 0x70
 268:	4629      	mov	r1, r5
 26a:	2208      	movs	r2, #8
 26c:	3004      	adds	r0, #4
 26e:	f7ff fffe 	bl	0 <memcpy>
                if ((ret = aes_auth_fn(ssl->decrypt.aes,
 272:	210d      	movs	r1, #13
                            sz - AESGCM_EXP_IV_SZ - ssl->specs.aead_mac_size,
 274:	f8b4 3146 	ldrh.w	r3, [r4, #326]	; 0x146
                if ((ret = aes_auth_fn(ssl->decrypt.aes,
 278:	9105      	str	r1, [sp, #20]
 27a:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
                            input + sz - ssl->specs.aead_mac_size,
 27c:	1af0      	subs	r0, r6, r3
                if ((ret = aes_auth_fn(ssl->decrypt.aes,
 27e:	e9cd 3103 	strd	r3, r1, [sp, #12]
 282:	210c      	movs	r1, #12
 284:	4428      	add	r0, r5
 286:	f105 0208 	add.w	r2, r5, #8
 28a:	9101      	str	r1, [sp, #4]
 28c:	6f21      	ldr	r1, [r4, #112]	; 0x70
 28e:	9002      	str	r0, [sp, #8]
 290:	9100      	str	r1, [sp, #0]
 292:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 294:	1afb      	subs	r3, r7, r3
 296:	4611      	mov	r1, r2
 298:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
 29c:	e019      	b.n	2d2 <ProcessReplyEx+0x2d2>
                if (ssl->decrypt.additional == NULL)
 29e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 2a0:	b91b      	cbnz	r3, 2aa <ProcessReplyEx+0x2aa>
                    ssl->decrypt.additional = (byte*)XMALLOC(AEAD_AUTH_DATA_SZ,
 2a2:	200d      	movs	r0, #13
 2a4:	f7ff fffe 	bl	0 <malloc>
 2a8:	66e0      	str	r0, [r4, #108]	; 0x6c
                if (ssl->decrypt.nonce == NULL) {
 2aa:	6f23      	ldr	r3, [r4, #112]	; 0x70
 2ac:	b91b      	cbnz	r3, 2b6 <ProcessReplyEx+0x2b6>
                    ssl->decrypt.nonce = (byte*)XMALLOC(AESGCM_NONCE_SZ,
 2ae:	200c      	movs	r0, #12
 2b0:	f7ff fffe 	bl	0 <malloc>
 2b4:	6720      	str	r0, [r4, #112]	; 0x70
                if (ssl->decrypt.additional == NULL ||
 2b6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 2b8:	b113      	cbz	r3, 2c0 <ProcessReplyEx+0x2c0>
 2ba:	6f23      	ldr	r3, [r4, #112]	; 0x70
 2bc:	2b00      	cmp	r3, #0
 2be:	d18c      	bne.n	1da <ProcessReplyEx+0x1da>
                    return MEMORY_E;
 2c0:	f06f 067c 	mvn.w	r6, #124	; 0x7c
 2c4:	e01a      	b.n	2fc <ProcessReplyEx+0x2fc>
            ret = wc_Des3_CbcDecrypt(ssl->decrypt.des3, plain, input, sz);
 2c6:	6e60      	ldr	r0, [r4, #100]	; 0x64
 2c8:	4633      	mov	r3, r6
 2ca:	462a      	mov	r2, r5
 2cc:	4629      	mov	r1, r5
 2ce:	f7ff fffe 	bl	0 <wc_Des3_CbcDecrypt>
                if ((ret = aes_auth_fn(ssl->decrypt.aes,
 2d2:	4606      	mov	r6, r0
            ssl->decrypt.state = CIPHER_STATE_END;
 2d4:	2302      	movs	r3, #2
 2d6:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
            if (ssl->specs.bulk_cipher_algorithm == wolfssl_aes_ccm ||
 2da:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
 2de:	3b07      	subs	r3, #7
 2e0:	2b01      	cmp	r3, #1
 2e2:	d818      	bhi.n	316 <ProcessReplyEx+0x316>
                if (ssl->decrypt.nonce)
 2e4:	6f20      	ldr	r0, [r4, #112]	; 0x70
 2e6:	b110      	cbz	r0, 2ee <ProcessReplyEx+0x2ee>
                    ForceZero(ssl->decrypt.nonce, AESGCM_NONCE_SZ);
 2e8:	210c      	movs	r1, #12
 2ea:	f7ff fffe 	bl	0 <ProcessReplyEx>
                if (ret < 0) {
 2ee:	2e00      	cmp	r6, #0
 2f0:	da11      	bge.n	316 <ProcessReplyEx+0x316>
    ssl->decrypt.state = CIPHER_STATE_BEGIN;
 2f2:	2300      	movs	r3, #0
 2f4:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
                    ret = VERIFY_MAC_ERROR;
 2f8:	f46f 7698 	mvn.w	r6, #304	; 0x130
                    SendAlert(ssl, alert_fatal, bad_record_mac);
 2fc:	2214      	movs	r2, #20
 2fe:	2102      	movs	r1, #2
 300:	4620      	mov	r0, r4
 302:	f7ff fffe 	bl	0 <ProcessReplyEx>
                    return ret;
 306:	e6fa      	b.n	fe <ProcessReplyEx+0xfe>
            ret = wc_AesCbcDecrypt(ssl->decrypt.aes, plain, input, sz);
 308:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 30a:	4633      	mov	r3, r6
 30c:	462a      	mov	r2, r5
 30e:	4629      	mov	r1, r5
 310:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
 314:	e7dd      	b.n	2d2 <ProcessReplyEx+0x2d2>
                if (ret >= 0) {
 316:	2e00      	cmp	r6, #0
    ssl->decrypt.state = CIPHER_STATE_BEGIN;
 318:	f884 8074 	strb.w	r8, [r4, #116]	; 0x74
                if (ret >= 0) {
 31c:	dbee      	blt.n	2fc <ProcessReplyEx+0x2fc>
                    if (ssl->options.tls1_1 && ssl->specs.cipher_type == block)
 31e:	f994 3271 	ldrsb.w	r3, [r4, #625]	; 0x271
 322:	f894 2149 	ldrb.w	r2, [r4, #329]	; 0x149
 326:	2b00      	cmp	r3, #0
 328:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 32c:	f280 8082 	bge.w	434 <ProcessReplyEx+0x434>
 330:	2a01      	cmp	r2, #1
 332:	d17f      	bne.n	434 <ProcessReplyEx+0x434>
                        ssl->buffers.inputBuffer.idx += ssl->specs.block_size;
 334:	f8b4 2144 	ldrh.w	r2, [r4, #324]	; 0x144
 338:	4413      	add	r3, r2
                        ssl->buffers.inputBuffer.idx += AESGCM_EXP_IV_SZ;
 33a:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
            ssl->options.processReply = verifyMessage;
 33e:	2306      	movs	r3, #6
 340:	f884 3277 	strb.w	r3, [r4, #631]	; 0x277
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
 344:	2100      	movs	r1, #0
 346:	4620      	mov	r0, r4
 348:	f7ff fffe 	bl	0 <ProcessReplyEx>
 34c:	2800      	cmp	r0, #0
 34e:	d04c      	beq.n	3ea <ProcessReplyEx+0x3ea>
 350:	f894 3269 	ldrb.w	r3, [r4, #617]	; 0x269
 354:	2b00      	cmp	r3, #0
 356:	d148      	bne.n	3ea <ProcessReplyEx+0x3ea>
                                        (!IsAtLeastTLSv1_3(ssl->version) ||
 358:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
 35c:	f7ff fffe 	bl	0 <ProcessReplyEx>
                                         ssl->curRL.type != change_cipher_spec))
 360:	f894 7133 	ldrb.w	r7, [r4, #307]	; 0x133
            if (IsEncryptionOn(ssl, 0) && ssl->keys.decryptedCur == 0 &&
 364:	b108      	cbz	r0, 36a <ProcessReplyEx+0x36a>
                                        (!IsAtLeastTLSv1_3(ssl->version) ||
 366:	2f14      	cmp	r7, #20
 368:	d03f      	beq.n	3ea <ProcessReplyEx+0x3ea>
    if (ssl->specs.cipher_type == block) {
 36a:	f894 b149 	ldrb.w	fp, [r4, #329]	; 0x149
                    ret = VerifyMac(ssl, ssl->buffers.inputBuffer.buffer +
 36e:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 372:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    word32 digestSz = ssl->specs.hash_size;
 376:	f894 914d 	ldrb.w	r9, [r4, #333]	; 0x14d
    if (ssl->specs.cipher_type == block) {
 37a:	f1bb 0f01 	cmp.w	fp, #1
                    ret = VerifyMac(ssl, ssl->buffers.inputBuffer.buffer +
 37e:	441e      	add	r6, r3
 380:	f8b4 3130 	ldrh.w	r3, [r4, #304]	; 0x130
    if (ssl->specs.cipher_type == block) {
 384:	f040 809a 	bne.w	4bc <ProcessReplyEx+0x4bc>
        if (ssl->options.tls1_1)
 388:	f994 2271 	ldrsb.w	r2, [r4, #625]	; 0x271
 38c:	f894 1271 	ldrb.w	r1, [r4, #625]	; 0x271
 390:	2a00      	cmp	r2, #0
            ivExtra = ssl->specs.block_size;
 392:	bfb4      	ite	lt
 394:	f8b4 2144 	ldrhlt.w	r2, [r4, #324]	; 0x144
        int ivExtra = 0;
 398:	2200      	movge	r2, #0
        pad = *(input + msgSz - ivExtra - 1);
 39a:	1a9a      	subs	r2, r3, r2
 39c:	18b0      	adds	r0, r6, r2
        if (ssl->options.tls) {
 39e:	f011 0140 	ands.w	r1, r1, #64	; 0x40
        pad = *(input + msgSz - ivExtra - 1);
 3a2:	f810 5c01 	ldrb.w	r5, [r0, #-1]
        if (ssl->options.tls) {
 3a6:	d050      	beq.n	44a <ProcessReplyEx+0x44a>
            ret = TimingPadVerify(ssl, input, pad, digestSz, msgSz - ivExtra,
 3a8:	e9cd 2700 	strd	r2, r7, [sp]
 3ac:	4631      	mov	r1, r6
 3ae:	464b      	mov	r3, r9
 3b0:	462a      	mov	r2, r5
 3b2:	4620      	mov	r0, r4
 3b4:	f7ff fffe 	bl	0 <ProcessReplyEx>
            if (ret != 0)
 3b8:	1e06      	subs	r6, r0, #0
 3ba:	f040 80a8 	bne.w	50e <ProcessReplyEx+0x50e>
        padByte = 1;
 3be:	2301      	movs	r3, #1
    if (ssl->specs.cipher_type == aead) {
 3c0:	f894 2149 	ldrb.w	r2, [r4, #329]	; 0x149
 3c4:	2a02      	cmp	r2, #2
        *padSz = digestSz + pad + padByte;
 3c6:	bf13      	iteet	ne
 3c8:	18ed      	addne	r5, r5, r3
        *padSz = ssl->specs.aead_mac_size;
 3ca:	f8b4 3146 	ldrheq.w	r3, [r4, #326]	; 0x146
 3ce:	f8c4 3264 	streq.w	r3, [r4, #612]	; 0x264
        *padSz = digestSz + pad + padByte;
 3d2:	444d      	addne	r5, r9
 3d4:	bf18      	it	ne
 3d6:	f8c4 5264 	strne.w	r5, [r4, #612]	; 0x264
    return 0;
 3da:	2600      	movs	r6, #0
                ssl->keys.encryptSz    = ssl->curSize;
 3dc:	f8b4 3130 	ldrh.w	r3, [r4, #304]	; 0x130
 3e0:	f8c4 3260 	str.w	r3, [r4, #608]	; 0x260
                ssl->keys.decryptedCur = 1;
 3e4:	2301      	movs	r3, #1
 3e6:	f884 3269 	strb.w	r3, [r4, #617]	; 0x269
            ssl->options.processReply = runProcessingOneMessage;
 3ea:	2308      	movs	r3, #8
 3ec:	f884 3277 	strb.w	r3, [r4, #631]	; 0x277
                    >= ssl->buffers.inputBuffer.length) {
 3f0:	e9d4 7521 	ldrd	r7, r5, [r4, #132]	; 0x84
            if (ssl->buffers.inputBuffer.idx
 3f4:	42bd      	cmp	r5, r7
 3f6:	f080 8237 	bcs.w	868 <ProcessReplyEx+0x868>
            if (!IsAtLeastTLSv1_3(ssl->version)
 3fa:	f8d4 013c 	ldr.w	r0, [r4, #316]	; 0x13c
 3fe:	f7ff fffe 	bl	0 <ProcessReplyEx>
 402:	9006      	str	r0, [sp, #24]
 404:	b950      	cbnz	r0, 41c <ProcessReplyEx+0x41c>
                    && ssl->curSize - ssl->keys.padSz -
 406:	f8b4 3130 	ldrh.w	r3, [r4, #304]	; 0x130
 40a:	f8d4 2264 	ldr.w	r2, [r4, #612]	; 0x264
 40e:	1a9b      	subs	r3, r3, r2
 410:	1b5b      	subs	r3, r3, r5
 412:	4453      	add	r3, sl
 414:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 418:	f200 8226 	bhi.w	868 <ProcessReplyEx+0x868>
            switch (ssl->curRL.type) {
 41c:	f894 3133 	ldrb.w	r3, [r4, #307]	; 0x133
 420:	3b14      	subs	r3, #20
 422:	2b03      	cmp	r3, #3
 424:	f63f aee9 	bhi.w	1fa <ProcessReplyEx+0x1fa>
 428:	e8df f013 	tbh	[pc, r3, lsl #1]
 42c:	019f012b 	.word	0x019f012b
 430:	01960074 	.word	0x01960074
    return (ssl->specs.cipher_type == aead) &&
 434:	2a02      	cmp	r2, #2
 436:	d182      	bne.n	33e <ProcessReplyEx+0x33e>
 438:	f894 2148 	ldrb.w	r2, [r4, #328]	; 0x148
 43c:	2a09      	cmp	r2, #9
 43e:	f43f af7e 	beq.w	33e <ProcessReplyEx+0x33e>
                        ssl->buffers.inputBuffer.idx += AESGCM_EXP_IV_SZ;
 442:	3308      	adds	r3, #8
 444:	e779      	b.n	33a <ProcessReplyEx+0x33a>
                        ret = DECRYPT_ERROR;
 446:	4e20      	ldr	r6, [pc, #128]	; (4c8 <ProcessReplyEx+0x4c8>)
 448:	e758      	b.n	2fc <ProcessReplyEx+0x2fc>
            XMEMSET(dmy, 0, sizeof(dmy));
 44a:	2201      	movs	r2, #1
 44c:	a809      	add	r0, sp, #36	; 0x24
 44e:	9307      	str	r3, [sp, #28]
 450:	9106      	str	r1, [sp, #24]
 452:	f7ff fffe 	bl	0 <memset>
            if (pad > (msgSz - digestSz - 1)) {
 456:	9b07      	ldr	r3, [sp, #28]
 458:	9906      	ldr	r1, [sp, #24]
 45a:	3b01      	subs	r3, #1
 45c:	eba3 0309 	sub.w	r3, r3, r9
 460:	429d      	cmp	r5, r3
                pad       = 0;  /* no bad read */
 462:	bf88      	it	hi
 464:	460d      	movhi	r5, r1
            ret = ssl->hmac(ssl, verify, input, msgSz - digestSz - pad - 1,
 466:	f04f 0201 	mov.w	r2, #1
 46a:	eba3 0305 	sub.w	r3, r3, r5
 46e:	e9cd 2202 	strd	r2, r2, [sp, #8]
 472:	e9cd 5700 	strd	r5, r7, [sp]
            int  badPadLen = 0;
 476:	bf98      	it	ls
 478:	468b      	movls	fp, r1
            ret = ssl->hmac(ssl, verify, input, msgSz - digestSz - pad - 1,
 47a:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
 47c:	9306      	str	r3, [sp, #24]
 47e:	4632      	mov	r2, r6
 480:	a90a      	add	r1, sp, #40	; 0x28
 482:	4620      	mov	r0, r4
                badPadLen = 1;
 484:	bf88      	it	hi
 486:	f04f 0b01 	movhi.w	fp, #1
            ret = ssl->hmac(ssl, verify, input, msgSz - digestSz - pad - 1,
 48a:	47b8      	blx	r7
    for (i = 0; i < length; i++) {
 48c:	9b06      	ldr	r3, [sp, #24]
    int compareSum = 0;
 48e:	2100      	movs	r1, #0
 490:	aa0a      	add	r2, sp, #40	; 0x28
 492:	4433      	add	r3, r6
    for (i = 0; i < length; i++) {
 494:	460f      	mov	r7, r1
 496:	454f      	cmp	r7, r9
 498:	db06      	blt.n	4a8 <ProcessReplyEx+0x4a8>
            if (ConstantCompare(verify, input + msgSz - digestSz - pad - 1,
 49a:	ea40 000b 	orr.w	r0, r0, fp
 49e:	ea50 0301 	orrs.w	r3, r0, r1
 4a2:	d08c      	beq.n	3be <ProcessReplyEx+0x3be>
                        return DECRYPT_ERROR;
 4a4:	4e08      	ldr	r6, [pc, #32]	; (4c8 <ProcessReplyEx+0x4c8>)
 4a6:	e62a      	b.n	fe <ProcessReplyEx+0xfe>
        compareSum |= a[i] ^ b[i];
 4a8:	f812 cb01 	ldrb.w	ip, [r2], #1
 4ac:	f813 6b01 	ldrb.w	r6, [r3], #1
 4b0:	ea8c 0c06 	eor.w	ip, ip, r6
 4b4:	ea41 010c 	orr.w	r1, r1, ip
    for (i = 0; i < length; i++) {
 4b8:	3701      	adds	r7, #1
 4ba:	e7ec      	b.n	496 <ProcessReplyEx+0x496>
    else if (ssl->specs.cipher_type == stream) {
 4bc:	f1bb 0f00 	cmp.w	fp, #0
 4c0:	d004      	beq.n	4cc <ProcessReplyEx+0x4cc>
    word32 padByte = 0;
 4c2:	2300      	movs	r3, #0
    word32 pad     = 0;
 4c4:	461d      	mov	r5, r3
 4c6:	e77b      	b.n	3c0 <ProcessReplyEx+0x3c0>
 4c8:	fffffec8 	.word	0xfffffec8
        ret = ssl->hmac(ssl, verify, input, msgSz - digestSz, -1, content, 1,
 4cc:	2201      	movs	r2, #1
 4ce:	e9cd 2202 	strd	r2, r2, [sp, #8]
 4d2:	eba3 0509 	sub.w	r5, r3, r9
 4d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 4da:	9701      	str	r7, [sp, #4]
 4dc:	9200      	str	r2, [sp, #0]
 4de:	462b      	mov	r3, r5
 4e0:	4632      	mov	r2, r6
 4e2:	a90a      	add	r1, sp, #40	; 0x28
 4e4:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
 4e6:	4620      	mov	r0, r4
 4e8:	47b8      	blx	r7
 4ea:	aa0a      	add	r2, sp, #40	; 0x28
 4ec:	1973      	adds	r3, r6, r5
 4ee:	4659      	mov	r1, fp
 4f0:	4589      	cmp	r9, r1
 4f2:	dc03      	bgt.n	4fc <ProcessReplyEx+0x4fc>
        if (ConstantCompare(verify, input + msgSz - digestSz, digestSz) != 0) {
 4f4:	ea50 030b 	orrs.w	r3, r0, fp
 4f8:	d0e3      	beq.n	4c2 <ProcessReplyEx+0x4c2>
 4fa:	e7d3      	b.n	4a4 <ProcessReplyEx+0x4a4>
        compareSum |= a[i] ^ b[i];
 4fc:	f812 5b01 	ldrb.w	r5, [r2], #1
 500:	f813 6b01 	ldrb.w	r6, [r3], #1
 504:	4075      	eors	r5, r6
 506:	ea4b 0b05 	orr.w	fp, fp, r5
    for (i = 0; i < length; i++) {
 50a:	3101      	adds	r1, #1
 50c:	e7f0      	b.n	4f0 <ProcessReplyEx+0x4f0>
                    if (ret < 0) {
 50e:	f6bf af65 	bge.w	3dc <ProcessReplyEx+0x3dc>
 512:	e7c7      	b.n	4a4 <ProcessReplyEx+0x4a4>
                    if (ssl->options.dtls) {
 514:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 518:	0758      	lsls	r0, r3, #29
 51a:	d422      	bmi.n	562 <ProcessReplyEx+0x562>
                    else if (!IsAtLeastTLSv1_3(ssl->version)
 51c:	9b06      	ldr	r3, [sp, #24]
 51e:	2b00      	cmp	r3, #0
 520:	f040 80ad 	bne.w	67e <ProcessReplyEx+0x67e>
                        ret = DoHandShakeMsg(ssl,
 524:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    if (ssl->arrays == NULL) {
 528:	68a3      	ldr	r3, [r4, #8]
                        ret = DoHandShakeMsg(ssl,
 52a:	f104 0b88 	add.w	fp, r4, #136	; 0x88
    const byte *ptr = input + *inOutIdx;
 52e:	1970      	adds	r0, r6, r5
    if (ssl->arrays == NULL) {
 530:	b9d3      	cbnz	r3, 568 <ProcessReplyEx+0x568>
    *inOutIdx += HANDSHAKE_HEADER_SZ;
 532:	1d2b      	adds	r3, r5, #4
    if (*inOutIdx > totalSz)
 534:	429f      	cmp	r7, r3
    *inOutIdx += HANDSHAKE_HEADER_SZ;
 536:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    if (*inOutIdx > totalSz)
 53a:	d32b      	bcc.n	594 <ProcessReplyEx+0x594>
    c24to32(&ptr[1], size);
 53c:	a90a      	add	r1, sp, #40	; 0x28
 53e:	3001      	adds	r0, #1
    *type = ptr[0];
 540:	5d75      	ldrb	r5, [r6, r5]
    c24to32(&ptr[1], size);
 542:	f7ff fffe 	bl	0 <ProcessReplyEx>
        if (size > MAX_HANDSHAKE_SZ) {
 546:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 548:	f644 031e 	movw	r3, #18462	; 0x481e
 54c:	429a      	cmp	r2, r3
 54e:	d81f      	bhi.n	590 <ProcessReplyEx+0x590>
        return DoHandShakeMsgType(ssl, input, inOutIdx, type, size, totalSz);
 550:	e9cd 2700 	strd	r2, r7, [sp]
        ret = DoHandShakeMsgType(ssl, input, inOutIdx, type, size, totalSz);
 554:	4631      	mov	r1, r6
 556:	462b      	mov	r3, r5
 558:	465a      	mov	r2, fp
 55a:	4620      	mov	r0, r4
 55c:	f7ff fffe 	bl	0 <ProcessReplyEx>
 560:	4606      	mov	r6, r0
                    if (ret != 0
 562:	2e00      	cmp	r6, #0
 564:	d040      	beq.n	5e8 <ProcessReplyEx+0x5e8>
 566:	e016      	b.n	596 <ProcessReplyEx+0x596>
    if (ssl->arrays->pendingMsgSz == 0) {
 568:	68d9      	ldr	r1, [r3, #12]
    inputLength = ssl->buffers.inputBuffer.length - *inOutIdx;
 56a:	eba7 0905 	sub.w	r9, r7, r5
    if (ssl->arrays->pendingMsgSz == 0) {
 56e:	2900      	cmp	r1, #0
 570:	d155      	bne.n	61e <ProcessReplyEx+0x61e>
    *inOutIdx += HANDSHAKE_HEADER_SZ;
 572:	1d2b      	adds	r3, r5, #4
    if (*inOutIdx > totalSz)
 574:	429f      	cmp	r7, r3
    *inOutIdx += HANDSHAKE_HEADER_SZ;
 576:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    if (*inOutIdx > totalSz)
 57a:	d30b      	bcc.n	594 <ProcessReplyEx+0x594>
    c24to32(&ptr[1], size);
 57c:	3001      	adds	r0, #1
 57e:	a90a      	add	r1, sp, #40	; 0x28
    *type = ptr[0];
 580:	5d75      	ldrb	r5, [r6, r5]
    c24to32(&ptr[1], size);
 582:	f7ff fffe 	bl	0 <ProcessReplyEx>
        if (size > MAX_HANDSHAKE_SZ) {
 586:	980a      	ldr	r0, [sp, #40]	; 0x28
 588:	f644 031e 	movw	r3, #18462	; 0x481e
 58c:	4298      	cmp	r0, r3
 58e:	d90c      	bls.n	5aa <ProcessReplyEx+0x5aa>
            return HANDSHAKE_SIZE_ERROR;
 590:	4eb9      	ldr	r6, [pc, #740]	; (878 <ProcessReplyEx+0x878>)
 592:	e000      	b.n	596 <ProcessReplyEx+0x596>
            return PARSE_ERROR;
 594:	4eb9      	ldr	r6, [pc, #740]	; (87c <ProcessReplyEx+0x87c>)
                        && (!ssl->options.dtls
 596:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 59a:	0759      	lsls	r1, r3, #29
 59c:	f57f adaf 	bpl.w	fe <ProcessReplyEx+0xfe>
                            || ret != WANT_WRITE)
 5a0:	f46f 73a3 	mvn.w	r3, #326	; 0x146
 5a4:	429e      	cmp	r6, r3
 5a6:	d020      	beq.n	5ea <ProcessReplyEx+0x5ea>
 5a8:	e5a9      	b.n	fe <ProcessReplyEx+0xfe>
        if (inputLength - HANDSHAKE_HEADER_SZ < size) {
 5aa:	f1a9 0304 	sub.w	r3, r9, #4
 5ae:	4298      	cmp	r0, r3
 5b0:	d92f      	bls.n	612 <ProcessReplyEx+0x612>
            ssl->arrays->pendingMsgType = type;
 5b2:	68a7      	ldr	r7, [r4, #8]
            ssl->arrays->pendingMsgSz = size + HANDSHAKE_HEADER_SZ;
 5b4:	3004      	adds	r0, #4
            ssl->arrays->pendingMsgType = type;
 5b6:	f887 50a5 	strb.w	r5, [r7, #165]	; 0xa5
            ssl->arrays->pendingMsgSz = size + HANDSHAKE_HEADER_SZ;
 5ba:	60f8      	str	r0, [r7, #12]
            ssl->arrays->pendingMsg = (byte*)XMALLOC(size + HANDSHAKE_HEADER_SZ,
 5bc:	f7ff fffe 	bl	0 <malloc>
            if (ssl->arrays->pendingMsg == NULL)
 5c0:	68a3      	ldr	r3, [r4, #8]
            ssl->arrays->pendingMsg = (byte*)XMALLOC(size + HANDSHAKE_HEADER_SZ,
 5c2:	6038      	str	r0, [r7, #0]
            if (ssl->arrays->pendingMsg == NULL)
 5c4:	6818      	ldr	r0, [r3, #0]
 5c6:	b338      	cbz	r0, 618 <ProcessReplyEx+0x618>
            XMEMCPY(ssl->arrays->pendingMsg,
 5c8:	f8d4 1088 	ldr.w	r1, [r4, #136]	; 0x88
 5cc:	3904      	subs	r1, #4
 5ce:	464a      	mov	r2, r9
 5d0:	4431      	add	r1, r6
 5d2:	f7ff fffe 	bl	0 <memcpy>
            ssl->arrays->pendingMsgOffset = inputLength;
 5d6:	68a3      	ldr	r3, [r4, #8]
 5d8:	f8c3 9010 	str.w	r9, [r3, #16]
            *inOutIdx += inputLength - HANDSHAKE_HEADER_SZ;
 5dc:	f8d4 5088 	ldr.w	r5, [r4, #136]	; 0x88
 5e0:	3d04      	subs	r5, #4
 5e2:	444d      	add	r5, r9
 5e4:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
    int    ret = 0;
 5e8:	2600      	movs	r6, #0
            if (ssl->buffers.inputBuffer.idx >= ssl->buffers.inputBuffer.length
 5ea:	e9d4 3221 	ldrd	r3, r2, [r4, #132]	; 0x84
 5ee:	429a      	cmp	r2, r3
            ssl->options.processReply = doProcessInit;
 5f0:	f884 8277 	strb.w	r8, [r4, #631]	; 0x277
            if (ssl->buffers.inputBuffer.idx >= ssl->buffers.inputBuffer.length
 5f4:	f0c0 810f 	bcc.w	816 <ProcessReplyEx+0x816>
                if ((ret == 0) && ssl->buffers.inputBuffer.dynamicFlag)
 5f8:	2e00      	cmp	r6, #0
 5fa:	f47f ad80 	bne.w	fe <ProcessReplyEx+0xfe>
 5fe:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
 602:	2b00      	cmp	r3, #0
 604:	f43f ad7b 	beq.w	fe <ProcessReplyEx+0xfe>
                    ShrinkInputBuffer(ssl, NO_FORCED_FREE);
 608:	4631      	mov	r1, r6
 60a:	4620      	mov	r0, r4
 60c:	f7ff fffe 	bl	0 <ProcessReplyEx>
 610:	e575      	b.n	fe <ProcessReplyEx+0xfe>
        ret = DoHandShakeMsgType(ssl, input, inOutIdx, type, size, totalSz);
 612:	e9cd 0700 	strd	r0, r7, [sp]
 616:	e79d      	b.n	554 <ProcessReplyEx+0x554>
                return MEMORY_E;
 618:	f06f 067c 	mvn.w	r6, #124	; 0x7c
 61c:	e7bb      	b.n	596 <ProcessReplyEx+0x596>
            ssl->arrays->pendingMsgSz - ssl->arrays->pendingMsgOffset;
 61e:	691e      	ldr	r6, [r3, #16]
            XMEMCPY(ssl->arrays->pendingMsg + ssl->arrays->pendingMsgOffset,
 620:	681b      	ldr	r3, [r3, #0]
        word32 pendSz =
 622:	1b8d      	subs	r5, r1, r6
 624:	454d      	cmp	r5, r9
 626:	bf28      	it	cs
 628:	464d      	movcs	r5, r9
            XMEMCPY(ssl->arrays->pendingMsg + ssl->arrays->pendingMsgOffset,
 62a:	4601      	mov	r1, r0
 62c:	462a      	mov	r2, r5
 62e:	1998      	adds	r0, r3, r6
 630:	f7ff fffe 	bl	0 <memcpy>
        ssl->arrays->pendingMsgOffset += inputLength;
 634:	68a1      	ldr	r1, [r4, #8]
 636:	690b      	ldr	r3, [r1, #16]
 638:	442b      	add	r3, r5
 63a:	610b      	str	r3, [r1, #16]
        *inOutIdx += inputLength;
 63c:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
 640:	442a      	add	r2, r5
 642:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
        if (ssl->arrays->pendingMsgOffset == ssl->arrays->pendingMsgSz)
 646:	e9d1 3203 	ldrd	r3, r2, [r1, #12]
 64a:	429a      	cmp	r2, r3
 64c:	d1cc      	bne.n	5e8 <ProcessReplyEx+0x5e8>
            word32 idx = HANDSHAKE_HEADER_SZ;
 64e:	2304      	movs	r3, #4
 650:	930a      	str	r3, [sp, #40]	; 0x28
            ret = DoHandShakeMsgType(ssl,
 652:	f891 30a5 	ldrb.w	r3, [r1, #165]	; 0xa5
 656:	9201      	str	r2, [sp, #4]
 658:	3a04      	subs	r2, #4
 65a:	9200      	str	r2, [sp, #0]
 65c:	6809      	ldr	r1, [r1, #0]
 65e:	aa0a      	add	r2, sp, #40	; 0x28
 660:	4620      	mov	r0, r4
 662:	f7ff fffe 	bl	0 <ProcessReplyEx>
                XFREE(ssl->arrays->pendingMsg, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 666:	68a3      	ldr	r3, [r4, #8]
            ret = DoHandShakeMsgType(ssl,
 668:	4606      	mov	r6, r0
                XFREE(ssl->arrays->pendingMsg, ssl->heap, DYNAMIC_TYPE_ARRAYS);
 66a:	6818      	ldr	r0, [r3, #0]
 66c:	b108      	cbz	r0, 672 <ProcessReplyEx+0x672>
 66e:	f7ff fffe 	bl	0 <free>
                ssl->arrays->pendingMsg = NULL;
 672:	68a3      	ldr	r3, [r4, #8]
 674:	f8c3 8000 	str.w	r8, [r3]
                ssl->arrays->pendingMsgSz = 0;
 678:	f8c3 800c 	str.w	r8, [r3, #12]
 67c:	e771      	b.n	562 <ProcessReplyEx+0x562>
                        ret = BUFFER_ERROR;
 67e:	4e80      	ldr	r6, [pc, #512]	; (880 <ProcessReplyEx+0x880>)
 680:	e789      	b.n	596 <ProcessReplyEx+0x596>
                            ssl->curSize < 1) {
 682:	f8b4 2130 	ldrh.w	r2, [r4, #304]	; 0x130
                            ssl->buffers.inputBuffer.length ||
 686:	2a00      	cmp	r2, #0
 688:	f43f ad37 	beq.w	fa <ProcessReplyEx+0xfa>
                    if (ssl->buffers.inputBuffer.buffer[
 68c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 690:	5d5b      	ldrb	r3, [r3, r5]
 692:	2b01      	cmp	r3, #1
 694:	f47f ad31 	bne.w	fa <ProcessReplyEx+0xfa>
                    if (IsEncryptionOn(ssl, 0) && ssl->options.handShakeDone) {
 698:	2100      	movs	r1, #0
 69a:	4620      	mov	r0, r4
 69c:	f7ff fffe 	bl	0 <ProcessReplyEx>
 6a0:	b1b8      	cbz	r0, 6d2 <ProcessReplyEx+0x6d2>
 6a2:	f894 327f 	ldrb.w	r3, [r4, #639]	; 0x27f
 6a6:	b1a3      	cbz	r3, 6d2 <ProcessReplyEx+0x6d2>
                        if (ssl->specs.cipher_type == aead) {
 6a8:	f894 3149 	ldrb.w	r3, [r4, #329]	; 0x149
 6ac:	2b02      	cmp	r3, #2
 6ae:	d147      	bne.n	740 <ProcessReplyEx+0x740>
                            if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha)
 6b0:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
 6b4:	2b09      	cmp	r3, #9
                                ssl->curSize -= AESGCM_EXP_IV_SZ;
 6b6:	bf1c      	itt	ne
 6b8:	3a08      	subne	r2, #8
 6ba:	f8a4 2130 	strhne.w	r2, [r4, #304]	; 0x130
                            ssl->curSize -= ssl->specs.aead_mac_size;
 6be:	f8b4 3130 	ldrh.w	r3, [r4, #304]	; 0x130
                            ssl->buffers.inputBuffer.idx += ssl->specs.aead_mac_size;
 6c2:	f8b4 2146 	ldrh.w	r2, [r4, #326]	; 0x146
 6c6:	4415      	add	r5, r2
                            ssl->curSize -= ssl->specs.aead_mac_size;
 6c8:	1a9b      	subs	r3, r3, r2
                            ssl->buffers.inputBuffer.idx += ssl->specs.aead_mac_size;
 6ca:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
                            ssl->curSize -= ssl->specs.aead_mac_size;
 6ce:	f8a4 3130 	strh.w	r3, [r4, #304]	; 0x130
                    if (ssl->curSize != 1) {
 6d2:	f8b4 3130 	ldrh.w	r3, [r4, #304]	; 0x130
 6d6:	2b01      	cmp	r3, #1
 6d8:	f47f ad0f 	bne.w	fa <ProcessReplyEx+0xfa>
                    ssl->buffers.inputBuffer.idx++;
 6dc:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 6e0:	3301      	adds	r3, #1
 6e2:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
                    ret = SanityCheckMsgReceived(ssl, change_cipher_hs);
 6e6:	2137      	movs	r1, #55	; 0x37
 6e8:	4620      	mov	r0, r4
 6ea:	f7ff fffe 	bl	0 <ProcessReplyEx>
                    if (ret != 0) {
 6ee:	4606      	mov	r6, r0
 6f0:	b120      	cbz	r0, 6fc <ProcessReplyEx+0x6fc>
                        if (!ssl->options.dtls) {
 6f2:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 6f6:	075a      	lsls	r2, r3, #29
 6f8:	f57f ad01 	bpl.w	fe <ProcessReplyEx+0xfe>
                    ssl->keys.encryptionOn = 1;
 6fc:	2301      	movs	r3, #1
 6fe:	f884 3268 	strb.w	r3, [r4, #616]	; 0x268
                    if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)
 702:	2102      	movs	r1, #2
 704:	4620      	mov	r0, r4
 706:	f7ff fffe 	bl	0 <SetKeysSide>
 70a:	4606      	mov	r6, r0
 70c:	2800      	cmp	r0, #0
 70e:	f47f acf6 	bne.w	fe <ProcessReplyEx+0xfe>
                                       ssl->options.side == WOLFSSL_CLIENT_END ?
 712:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
                    ret = BuildFinished(ssl, &ssl->hsHashes->verifyHashes,
 716:	4a5b      	ldr	r2, [pc, #364]	; (884 <ProcessReplyEx+0x884>)
 718:	495b      	ldr	r1, [pc, #364]	; (888 <ProcessReplyEx+0x888>)
 71a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 71e:	2b10      	cmp	r3, #16
 720:	bf18      	it	ne
 722:	460a      	movne	r2, r1
    if (ssl->options.tls) {
 724:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 728:	065b      	lsls	r3, r3, #25
 72a:	f57f af5d 	bpl.w	5e8 <ProcessReplyEx+0x5e8>
        ret = BuildTlsFinished(ssl, hashes, sender);
 72e:	68e1      	ldr	r1, [r4, #12]
 730:	4620      	mov	r0, r4
 732:	f7ff fffe 	bl	0 <BuildTlsFinished>
                    if ((ret = DoApplicationData(ssl,
 736:	4606      	mov	r6, r0
 738:	2800      	cmp	r0, #0
 73a:	f43f af55 	beq.w	5e8 <ProcessReplyEx+0x5e8>
 73e:	e4de      	b.n	fe <ProcessReplyEx+0xfe>
                            ssl->curSize -= ssl->specs.iv_size;
 740:	f8b4 1142 	ldrh.w	r1, [r4, #322]	; 0x142
                            ssl->buffers.inputBuffer.idx += ssl->keys.padSz;
 744:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
                            ssl->curSize -= ssl->specs.iv_size;
 748:	1a52      	subs	r2, r2, r1
                            ssl->buffers.inputBuffer.idx += ssl->keys.padSz;
 74a:	441d      	add	r5, r3
                            ssl->curSize -= ssl->specs.iv_size;
 74c:	1ad2      	subs	r2, r2, r3
                            ssl->buffers.inputBuffer.idx += ssl->keys.padSz;
 74e:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
                            ssl->curSize -= ssl->specs.iv_size;
 752:	f8a4 2130 	strh.w	r2, [r4, #304]	; 0x130
 756:	e7bc      	b.n	6d2 <ProcessReplyEx+0x6d2>
                    if ((ret = DoApplicationData(ssl,
 758:	f8d4 1080 	ldr.w	r1, [r4, #128]	; 0x80
 75c:	2300      	movs	r3, #0
 75e:	f104 0288 	add.w	r2, r4, #136	; 0x88
 762:	4620      	mov	r0, r4
 764:	f7ff fffe 	bl	0 <ProcessReplyEx>
 768:	e7e5      	b.n	736 <ProcessReplyEx+0x736>
    if (IsEncryptionOn(ssl, 0)) {
 76a:	2100      	movs	r1, #0
 76c:	4620      	mov	r0, r4
                    ret = DoAlert(ssl, ssl->buffers.inputBuffer.buffer,
 76e:	f8d4 6080 	ldr.w	r6, [r4, #128]	; 0x80
    word32 dataSz = (word32)ssl->curSize;
 772:	f8b4 2130 	ldrh.w	r2, [r4, #304]	; 0x130
    if (IsEncryptionOn(ssl, 0)) {
 776:	f7ff fffe 	bl	0 <ProcessReplyEx>
 77a:	b168      	cbz	r0, 798 <ProcessReplyEx+0x798>
        if (ssl->specs.cipher_type == block) {
 77c:	f894 3149 	ldrb.w	r3, [r4, #329]	; 0x149
 780:	2b01      	cmp	r3, #1
 782:	d13b      	bne.n	7fc <ProcessReplyEx+0x7fc>
            if (ssl->options.tls1_1)
 784:	f994 3271 	ldrsb.w	r3, [r4, #625]	; 0x271
 788:	428b      	cmp	r3, r1
 78a:	da01      	bge.n	790 <ProcessReplyEx+0x790>
                ivExtra = ssl->specs.block_size;
 78c:	f8b4 1144 	ldrh.w	r1, [r4, #324]	; 0x144
        dataSz -= ssl->keys.padSz;
 790:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 794:	1ad2      	subs	r2, r2, r3
 796:	1a52      	subs	r2, r2, r1
    if (dataSz != ALERT_SIZE) {
 798:	2a02      	cmp	r2, #2
 79a:	d167      	bne.n	86c <ProcessReplyEx+0x86c>
    level = input[(*inOutIdx)++];
 79c:	1c6b      	adds	r3, r5, #1
 79e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 7a2:	5d72      	ldrb	r2, [r6, r5]
    code  = input[(*inOutIdx)++];
 7a4:	3502      	adds	r5, #2
    if (level == alert_fatal) {
 7a6:	2a02      	cmp	r2, #2
    code  = input[(*inOutIdx)++];
 7a8:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
    ssl->alert_history.last_rx.code = code;
 7ac:	5cf6      	ldrb	r6, [r6, r3]
        ssl->options.isClosed = 1;  /* Don't send close_notify */
 7ae:	bf02      	ittt	eq
 7b0:	f894 3272 	ldrbeq.w	r3, [r4, #626]	; 0x272
 7b4:	f043 0310 	orreq.w	r3, r3, #16
 7b8:	f884 3272 	strbeq.w	r3, [r4, #626]	; 0x272
    if (++ssl->options.alertCount >= WOLFSSL_ALERT_COUNT_MAX) {
 7bc:	f894 3285 	ldrb.w	r3, [r4, #645]	; 0x285
 7c0:	3301      	adds	r3, #1
 7c2:	b2db      	uxtb	r3, r3
 7c4:	2b04      	cmp	r3, #4
    ssl->alert_history.last_rx.level = level;
 7c6:	e9c4 623f 	strd	r6, r2, [r4, #252]	; 0xfc
    if (++ssl->options.alertCount >= WOLFSSL_ALERT_COUNT_MAX) {
 7ca:	f884 3285 	strb.w	r3, [r4, #645]	; 0x285
 7ce:	d850      	bhi.n	872 <ProcessReplyEx+0x872>
    if (*type == close_notify) {
 7d0:	b92e      	cbnz	r6, 7de <ProcessReplyEx+0x7de>
        ssl->options.closeNotify = 1;
 7d2:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 7d6:	f043 0320 	orr.w	r3, r3, #32
 7da:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
    if (IsEncryptionOn(ssl, 0)) {
 7de:	2100      	movs	r1, #0
 7e0:	4620      	mov	r0, r4
 7e2:	f7ff fffe 	bl	0 <ProcessReplyEx>
 7e6:	b120      	cbz	r0, 7f2 <ProcessReplyEx+0x7f2>
        *inOutIdx += ssl->keys.padSz;
 7e8:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 7ec:	441d      	add	r5, r3
 7ee:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
                    if (ret == alert_fatal)
 7f2:	2a02      	cmp	r2, #2
 7f4:	d153      	bne.n	89e <ProcessReplyEx+0x89e>
                        return FATAL_ERROR;
 7f6:	f46f 769c 	mvn.w	r6, #312	; 0x138
 7fa:	e480      	b.n	fe <ProcessReplyEx+0xfe>
        if (ssl->specs.cipher_type == aead) {
 7fc:	2b02      	cmp	r3, #2
 7fe:	d1c7      	bne.n	790 <ProcessReplyEx+0x790>
    return (ssl->specs.cipher_type == aead) &&
 800:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
                ivExtra = AESGCM_EXP_IV_SZ;
 804:	2b09      	cmp	r3, #9
 806:	bf0c      	ite	eq
 808:	2100      	moveq	r1, #0
 80a:	2108      	movne	r1, #8
 80c:	e7c0      	b.n	790 <ProcessReplyEx+0x790>
                    if (type == decrypt_error)
 80e:	2e33      	cmp	r6, #51	; 0x33
 810:	f47f aeea 	bne.w	5e8 <ProcessReplyEx+0x5e8>
 814:	e7ef      	b.n	7f6 <ProcessReplyEx+0x7f6>
            else if ((ssl->buffers.inputBuffer.idx - startIdx) < ssl->curSize) {
 816:	f8b4 1130 	ldrh.w	r1, [r4, #304]	; 0x130
 81a:	eba2 030a 	sub.w	r3, r2, sl
 81e:	428b      	cmp	r3, r1
 820:	d20e      	bcs.n	840 <ProcessReplyEx+0x840>
                ssl->options.processReply = runProcessingOneMessage;
 822:	2308      	movs	r3, #8
 824:	f884 3277 	strb.w	r3, [r4, #631]	; 0x277
                if (IsEncryptionOn(ssl, 0)) {
 828:	2100      	movs	r1, #0
 82a:	4620      	mov	r0, r4
 82c:	f7ff fffe 	bl	0 <ProcessReplyEx>
 830:	b130      	cbz	r0, 840 <ProcessReplyEx+0x840>
                        if (ssl->buffers.inputBuffer.idx >= ssl->keys.padSz) {
 832:	f8d4 3264 	ldr.w	r3, [r4, #612]	; 0x264
 836:	429a      	cmp	r2, r3
 838:	d3dd      	bcc.n	7f6 <ProcessReplyEx+0x7f6>
                            ssl->buffers.inputBuffer.idx -= ssl->keys.padSz;
 83a:	1ad2      	subs	r2, r2, r3
 83c:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
            if (ret == 0 && ssl->buffers.inputBuffer.dynamicFlag)
 840:	2e00      	cmp	r6, #0
 842:	f47f abf7 	bne.w	34 <ProcessReplyEx+0x34>
 846:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
 84a:	2b00      	cmp	r3, #0
 84c:	f43f abf2 	beq.w	34 <ProcessReplyEx+0x34>
                ShrinkInputBuffer(ssl, NO_FORCED_FREE);
 850:	4631      	mov	r1, r6
 852:	4620      	mov	r0, r4
 854:	f7ff fffe 	bl	0 <ProcessReplyEx>
 858:	f7ff bbec 	b.w	34 <ProcessReplyEx+0x34>
        switch (ssl->options.processReply) {
 85c:	f46f 7696 	mvn.w	r6, #300	; 0x12c
 860:	e44d      	b.n	fe <ProcessReplyEx+0xfe>
            return SANITY_CIPHER_E;
 862:	f46f 76bb 	mvn.w	r6, #374	; 0x176
 866:	e44a      	b.n	fe <ProcessReplyEx+0xfe>
                return BUFFER_ERROR;
 868:	4e05      	ldr	r6, [pc, #20]	; (880 <ProcessReplyEx+0x880>)
 86a:	e448      	b.n	fe <ProcessReplyEx+0xfe>
        return BUFFER_E;
 86c:	f06f 0683 	mvn.w	r6, #131	; 0x83
 870:	e445      	b.n	fe <ProcessReplyEx+0xfe>
        return ALERT_COUNT_E;
 872:	f46f 76d5 	mvn.w	r6, #426	; 0x1aa
 876:	e442      	b.n	fe <ProcessReplyEx+0xfe>
 878:	fffffe6c 	.word	0xfffffe6c
 87c:	fffffece 	.word	0xfffffece
 880:	fffffeb8 	.word	0xfffffeb8
	...
                    if (ssl->options.side == WOLFSSL_CLIENT_END)
 88c:	2b10      	cmp	r3, #16
 88e:	d104      	bne.n	89a <ProcessReplyEx+0x89a>
                        SendAlert(ssl, alert_fatal,
 890:	2246      	movs	r2, #70	; 0x46
 892:	2102      	movs	r1, #2
 894:	4620      	mov	r0, r4
 896:	f7ff fffe 	bl	0 <ProcessReplyEx>
 89a:	4e06      	ldr	r6, [pc, #24]	; (8b4 <ProcessReplyEx+0x8b4>)
 89c:	e42f      	b.n	fe <ProcessReplyEx+0xfe>
                    if (type == close_notify) {
 89e:	2e00      	cmp	r6, #0
 8a0:	d1b5      	bne.n	80e <ProcessReplyEx+0x80e>
                        ssl->options.processReply = doProcessInit;
 8a2:	f884 6277 	strb.w	r6, [r4, #631]	; 0x277
                        return ssl->error = ZERO_RETURN;
 8a6:	f46f 76ab 	mvn.w	r6, #342	; 0x156
                        ssl->buffers.inputBuffer.idx =
 8aa:	f8c4 7088 	str.w	r7, [r4, #136]	; 0x88
                        return ssl->error = ZERO_RETURN;
 8ae:	f8c4 6114 	str.w	r6, [r4, #276]	; 0x114
 8b2:	e424      	b.n	fe <ProcessReplyEx+0xfe>
 8b4:	fffffeba 	.word	0xfffffeba

Disassembly of section .text.ProcessReply:

00000000 <ProcessReply>:
    return ProcessReplyEx(ssl, 0);
   0:	2100      	movs	r1, #0
   2:	f7ff bffe 	b.w	0 <ProcessReply>

Disassembly of section .text.ReceiveData:

00000000 <ReceiveData>:
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	461f      	mov	r7, r3
    if (ssl->error == WANT_READ || ssl->error == WOLFSSL_ERROR_WANT_READ) {
   6:	f8d0 3114 	ldr.w	r3, [r0, #276]	; 0x114
{
   a:	4691      	mov	r9, r2
    if (ssl->error == WANT_READ || ssl->error == WOLFSSL_ERROR_WANT_READ) {
   c:	f46f 72a1 	mvn.w	r2, #322	; 0x142
  10:	4293      	cmp	r3, r2
{
  12:	4605      	mov	r5, r0
  14:	4688      	mov	r8, r1
    if (ssl->error == WANT_READ || ssl->error == WOLFSSL_ERROR_WANT_READ) {
  16:	d001      	beq.n	1c <ReceiveData+0x1c>
  18:	2b02      	cmp	r3, #2
  1a:	d102      	bne.n	22 <ReceiveData+0x22>
        ssl->error = 0;
  1c:	2300      	movs	r3, #0
  1e:	f8c5 3114 	str.w	r3, [r5, #276]	; 0x114
    if (ssl->error != 0 && ssl->error != WANT_WRITE
  22:	f8d5 4114 	ldr.w	r4, [r5, #276]	; 0x114
  26:	b11c      	cbz	r4, 30 <ReceiveData+0x30>
  28:	f46f 73a3 	mvn.w	r3, #326	; 0x146
  2c:	429c      	cmp	r4, r3
  2e:	d128      	bne.n	82 <ReceiveData+0x82>
        if (ssl->options.handShakeState != HANDSHAKE_DONE)
  30:	f895 327e 	ldrb.w	r3, [r5, #638]	; 0x27e
  34:	2b10      	cmp	r3, #16
  36:	d005      	beq.n	44 <ReceiveData+0x44>
            if ( (err = wolfSSL_negotiate(ssl)) != WOLFSSL_SUCCESS) {
  38:	4628      	mov	r0, r5
  3a:	f7ff fffe 	bl	0 <wolfSSL_negotiate>
  3e:	2801      	cmp	r0, #1
  40:	4604      	mov	r4, r0
  42:	d11e      	bne.n	82 <ReceiveData+0x82>
    while (ssl->buffers.clearOutputBuffer.length == 0) {
  44:	f8d5 60bc 	ldr.w	r6, [r5, #188]	; 0xbc
  48:	b1f6      	cbz	r6, 88 <ReceiveData+0x88>
    size = min(sz, (int)ssl->buffers.clearOutputBuffer.length);
  4a:	45b1      	cmp	r9, r6
  4c:	464c      	mov	r4, r9
  4e:	bf28      	it	cs
  50:	4634      	movcs	r4, r6
    XMEMCPY(output, ssl->buffers.clearOutputBuffer.buffer, size);
  52:	f8d5 10b8 	ldr.w	r1, [r5, #184]	; 0xb8
  56:	4622      	mov	r2, r4
  58:	4640      	mov	r0, r8
  5a:	f7ff fffe 	bl	0 <memcpy>
    if (peek == 0) {
  5e:	b94f      	cbnz	r7, 74 <ReceiveData+0x74>
        ssl->buffers.clearOutputBuffer.length -= size;
  60:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
  64:	1b1b      	subs	r3, r3, r4
  66:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
        ssl->buffers.clearOutputBuffer.buffer += size;
  6a:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
  6e:	4423      	add	r3, r4
  70:	f8c5 30b8 	str.w	r3, [r5, #184]	; 0xb8
    if (ssl->buffers.inputBuffer.dynamicFlag)
  74:	f895 3090 	ldrb.w	r3, [r5, #144]	; 0x90
  78:	b11b      	cbz	r3, 82 <ReceiveData+0x82>
       ShrinkInputBuffer(ssl, NO_FORCED_FREE);
  7a:	2100      	movs	r1, #0
  7c:	4628      	mov	r0, r5
  7e:	f7ff fffe 	bl	0 <ReceiveData>
}
  82:	4620      	mov	r0, r4
  84:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if ( (ssl->error = ProcessReply(ssl)) < 0) {
  88:	4628      	mov	r0, r5
  8a:	f7ff fffe 	bl	0 <ReceiveData>
  8e:	2800      	cmp	r0, #0
  90:	4604      	mov	r4, r0
  92:	f8c5 0114 	str.w	r0, [r5, #276]	; 0x114
  96:	dad5      	bge.n	44 <ReceiveData+0x44>
            if (ssl->error == ZERO_RETURN) {
  98:	f46f 73ab 	mvn.w	r3, #342	; 0x156
  9c:	4298      	cmp	r0, r3
  9e:	d00b      	beq.n	b8 <ReceiveData+0xb8>
            if (ssl->error == SOCKET_ERROR_E) {
  a0:	f510 7f9a 	cmn.w	r0, #308	; 0x134
  a4:	d1ed      	bne.n	82 <ReceiveData+0x82>
                if (ssl->options.connReset || ssl->options.isClosed) {
  a6:	f895 3272 	ldrb.w	r3, [r5, #626]	; 0x272
  aa:	f013 0f18 	tst.w	r3, #24
  ae:	d0e8      	beq.n	82 <ReceiveData+0x82>
                    ssl->error = SOCKET_PEER_CLOSED_E;
  b0:	f46f 73c6 	mvn.w	r3, #396	; 0x18c
  b4:	f8c5 3114 	str.w	r3, [r5, #276]	; 0x114
                return 0; /* no more data coming */
  b8:	4634      	mov	r4, r6
  ba:	e7e2      	b.n	82 <ReceiveData+0x82>

Disassembly of section .text.SendServerHelloDone:

00000000 <SendServerHelloDone>:
    {
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        if (IsEncryptionOn(ssl, 1))
   4:	2101      	movs	r1, #1
    {
   6:	b086      	sub	sp, #24
   8:	4605      	mov	r5, r0
        if (IsEncryptionOn(ssl, 1))
   a:	f7ff fffe 	bl	0 <SendServerHelloDone>
        ssl->options.buildingMsg = 1;
   e:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
            sendSz += MAX_MSG_EXTRA;
  12:	2800      	cmp	r0, #0
  14:	bf0c      	ite	eq
  16:	f04f 0809 	moveq.w	r8, #9
  1a:	f04f 086f 	movne.w	r8, #111	; 0x6f
        ssl->options.buildingMsg = 1;
  1e:	f043 0308 	orr.w	r3, r3, #8
  22:	f885 3276 	strb.w	r3, [r5, #630]	; 0x276
        if ((ret = CheckAvailableSize(ssl, sendSz)) != 0)
  26:	4641      	mov	r1, r8
  28:	4628      	mov	r0, r5
  2a:	f7ff fffe 	bl	0 <SendServerHelloDone>
  2e:	4604      	mov	r4, r0
  30:	2800      	cmp	r0, #0
  32:	d13c      	bne.n	ae <SendServerHelloDone+0xae>
        output = GetOutputBuffer(ssl);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <SendServerHelloDone>
        AddHeaders(output, 0, server_hello_done, ssl);
  3a:	4621      	mov	r1, r4
  3c:	462b      	mov	r3, r5
  3e:	220e      	movs	r2, #14
  40:	f7ff fffe 	bl	0 <SendServerHelloDone>
        output = GetOutputBuffer(ssl);
  44:	4606      	mov	r6, r0
        if (IsEncryptionOn(ssl, 1)) {
  46:	2101      	movs	r1, #1
  48:	4628      	mov	r0, r5
  4a:	f7ff fffe 	bl	0 <SendServerHelloDone>
  4e:	b390      	cbz	r0, b6 <SendServerHelloDone+0xb6>
            if (ssl->options.dtls) {
  50:	f895 3272 	ldrb.w	r3, [r5, #626]	; 0x272
  54:	f003 0304 	and.w	r3, r3, #4
                recordHeaderSz += DTLS_RECORD_EXTRA;
  58:	2b00      	cmp	r3, #0
  5a:	bf0c      	ite	eq
  5c:	f04f 0904 	moveq.w	r9, #4
  60:	f04f 090c 	movne.w	r9, #12
            input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
  64:	4648      	mov	r0, r9
                recordHeaderSz += DTLS_RECORD_EXTRA;
  66:	bf0c      	ite	eq
  68:	f04f 0a05 	moveq.w	sl, #5
  6c:	f04f 0a0d 	movne.w	sl, #13
            input = (byte*)XMALLOC(inputSz, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
  70:	f7ff fffe 	bl	0 <malloc>
            if (input == NULL)
  74:	4607      	mov	r7, r0
  76:	2800      	cmp	r0, #0
  78:	d03b      	beq.n	f2 <SendServerHelloDone+0xf2>
            XMEMCPY(input, output + recordHeaderSz, inputSz);
  7a:	464a      	mov	r2, r9
  7c:	eb06 010a 	add.w	r1, r6, sl
  80:	f7ff fffe 	bl	0 <memcpy>
            sendSz = BuildMessage(ssl, output, sendSz, input, inputSz,
  84:	2316      	movs	r3, #22
  86:	2201      	movs	r2, #1
  88:	e9cd 3201 	strd	r3, r2, [sp, #4]
  8c:	e9cd 4404 	strd	r4, r4, [sp, #16]
  90:	9403      	str	r4, [sp, #12]
  92:	463b      	mov	r3, r7
  94:	4642      	mov	r2, r8
  96:	4631      	mov	r1, r6
  98:	f8cd 9000 	str.w	r9, [sp]
  9c:	4628      	mov	r0, r5
  9e:	f7ff fffe 	bl	0 <SendServerHelloDone>
  a2:	4604      	mov	r4, r0
            XFREE(input, ssl->heap, DYNAMIC_TYPE_IN_BUFFER);
  a4:	4638      	mov	r0, r7
  a6:	f7ff fffe 	bl	0 <free>
            if (sendSz < 0)
  aa:	2c00      	cmp	r4, #0
  ac:	da0d      	bge.n	ca <SendServerHelloDone+0xca>
    }
  ae:	4620      	mov	r0, r4
  b0:	b006      	add	sp, #24
  b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            ret = HashOutput(ssl, output, sendSz, 0);
  b6:	4623      	mov	r3, r4
  b8:	4642      	mov	r2, r8
  ba:	4631      	mov	r1, r6
  bc:	4628      	mov	r0, r5
  be:	f7ff fffe 	bl	0 <SendServerHelloDone>
            if (ret != 0)
  c2:	4604      	mov	r4, r0
  c4:	2800      	cmp	r0, #0
  c6:	d1f2      	bne.n	ae <SendServerHelloDone+0xae>
  c8:	4644      	mov	r4, r8
        ssl->buffers.outputBuffer.length += sendSz;
  ca:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
        ssl->options.serverState = SERVER_HELLODONE_COMPLETE;
  ce:	2308      	movs	r3, #8
  d0:	f885 327c 	strb.w	r3, [r5, #636]	; 0x27c
        ssl->options.buildingMsg = 0;
  d4:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
        ssl->buffers.outputBuffer.length += sendSz;
  d8:	4420      	add	r0, r4
        ssl->options.buildingMsg = 0;
  da:	f36f 03c3 	bfc	r3, #3, #1
        ssl->buffers.outputBuffer.length += sendSz;
  de:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
        ret = SendBuffered(ssl);
  e2:	4628      	mov	r0, r5
        ssl->options.buildingMsg = 0;
  e4:	f885 3276 	strb.w	r3, [r5, #630]	; 0x276
    }
  e8:	b006      	add	sp, #24
  ea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        ret = SendBuffered(ssl);
  ee:	f7ff bffe 	b.w	0 <SendServerHelloDone>
                return MEMORY_E;
  f2:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  f6:	e7da      	b.n	ae <SendServerHelloDone+0xae>

Disassembly of section .text.wolfSSL_GetMaxFragSize:

00000000 <wolfSSL_GetMaxFragSize>:
        maxFragment = ModifyForMTU(ssl, maxFragment, outputSz, mtuSz);
    }
#endif

    return maxFragment;
}
   0:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
   4:	bfa8      	it	ge
   6:	f44f 4180 	movge.w	r1, #16384	; 0x4000
   a:	4608      	mov	r0, r1
   c:	4770      	bx	lr

keys.o:     file format elf32-littlearm


Disassembly of section .text.GetCipherSpec:

00000000 <GetCipherSpec>:
 * @param opts         [in/out] Options can be NULL
 * @return
 */
int GetCipherSpec(word16 side, byte cipherSuite0, byte cipherSuite,
                      CipherSpecs* specs, Options* opts)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)
    if (opts != NULL)
        havePSK = opts->havePSK;
#endif
#ifndef NO_WOLFSSL_CLIENT
    if (side == WOLFSSL_CLIENT_END) {
   2:	2801      	cmp	r0, #1
{
   4:	9d06      	ldr	r5, [sp, #24]
   6:	460f      	mov	r7, r1
   8:	4616      	mov	r6, r2
   a:	461c      	mov	r4, r3
    if (side == WOLFSSL_CLIENT_END) {
   c:	d003      	beq.n	16 <GetCipherSpec+0x16>
        }
    }
#endif /* NO_WOLFSSL_CLIENT */

    /* Chacha extensions, 0xcc */
    if (cipherSuite0 == CHACHA_BYTE) {
   e:	2fcc      	cmp	r7, #204	; 0xcc
  10:	d107      	bne.n	22 <GetCipherSpec+0x22>
    }

    /* ECC extensions, AES-CCM or TLS 1.3 Integrity-only */
    if (cipherSuite0 == ECC_BYTE) {

    switch (cipherSuite) {
  12:	483a      	ldr	r0, [pc, #232]	; (fc <GetCipherSpec+0xfc>)
        /* CLIENT/SERVER: No peer authentication to be performed. */
        opts->peerAuthGood = 1;
    }

    return 0;
}
  14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (VerifyClientSuite(havePSK, cipherSuite0, cipherSuite) != 1) {
  16:	2000      	movs	r0, #0
  18:	f7ff fffe 	bl	0 <VerifyClientSuite>
  1c:	2801      	cmp	r0, #1
  1e:	d0f6      	beq.n	e <GetCipherSpec+0xe>
  20:	e7f7      	b.n	12 <GetCipherSpec+0x12>
    if (cipherSuite0 == ECC_BYTE) {
  22:	2fc0      	cmp	r7, #192	; 0xc0
  24:	d15c      	bne.n	e0 <GetCipherSpec+0xe0>
    switch (cipherSuite) {
  26:	2e0a      	cmp	r6, #10
  28:	d04b      	beq.n	c2 <GetCipherSpec+0xc2>
  2a:	d813      	bhi.n	54 <GetCipherSpec+0x54>
  2c:	2e08      	cmp	r6, #8
  2e:	d038      	beq.n	a2 <GetCipherSpec+0xa2>
  30:	2e09      	cmp	r6, #9
  32:	d1ee      	bne.n	12 <GetCipherSpec+0x12>
        specs->bulk_cipher_algorithm = wolfssl_aes;
  34:	f44f 7383 	mov.w	r3, #262	; 0x106
  38:	8123      	strh	r3, [r4, #8]
        specs->mac_algorithm         = sha_mac;
  3a:	f240 7302 	movw	r3, #1794	; 0x702
  3e:	8163      	strh	r3, [r4, #10]
        specs->sig_algo              = ecc_dsa_sa_algo;
  40:	f241 4303 	movw	r3, #5123	; 0x1403
  44:	81a3      	strh	r3, [r4, #12]
        specs->pad_size              = PAD_SHA;
  46:	2328      	movs	r3, #40	; 0x28
  48:	81e3      	strh	r3, [r4, #14]
        specs->key_size              = AES_128_KEY_SIZE;
  4a:	2310      	movs	r3, #16
  4c:	8023      	strh	r3, [r4, #0]
        specs->block_size            = AES_BLOCK_SIZE;
  4e:	80a3      	strh	r3, [r4, #4]
        specs->iv_size               = AES_IV_SIZE;
  50:	8063      	strh	r3, [r4, #2]
        break;
  52:	e024      	b.n	9e <GetCipherSpec+0x9e>
    switch (cipherSuite) {
  54:	2e23      	cmp	r6, #35	; 0x23
  56:	d013      	beq.n	80 <GetCipherSpec+0x80>
  58:	2e2b      	cmp	r6, #43	; 0x2b
  5a:	d1da      	bne.n	12 <GetCipherSpec+0x12>
        specs->key_size              = AES_128_KEY_SIZE;
  5c:	2310      	movs	r3, #16
  5e:	8023      	strh	r3, [r4, #0]
        specs->block_size            = AES_BLOCK_SIZE;
  60:	80a3      	strh	r3, [r4, #4]
        specs->aead_mac_size         = AES_GCM_AUTH_SZ;
  62:	80e3      	strh	r3, [r4, #6]
        specs->bulk_cipher_algorithm = wolfssl_aes_gcm;
  64:	f240 2307 	movw	r3, #519	; 0x207
  68:	8123      	strh	r3, [r4, #8]
        specs->mac_algorithm         = sha256_mac;
  6a:	f240 7304 	movw	r3, #1796	; 0x704
  6e:	8163      	strh	r3, [r4, #10]
        specs->sig_algo              = ecc_dsa_sa_algo;
  70:	f242 0303 	movw	r3, #8195	; 0x2003
        specs->iv_size               = AESGCM_IMP_IV_SZ;
  74:	2204      	movs	r2, #4
        specs->sig_algo              = ecc_dsa_sa_algo;
  76:	81a3      	strh	r3, [r4, #12]
        specs->pad_size              = PAD_SHA;
  78:	2328      	movs	r3, #40	; 0x28
        specs->iv_size               = AESGCM_IMP_IV_SZ;
  7a:	8062      	strh	r2, [r4, #2]
        specs->pad_size              = PAD_SHA;
  7c:	81e3      	strh	r3, [r4, #14]
        break;
  7e:	e00e      	b.n	9e <GetCipherSpec+0x9e>
        specs->bulk_cipher_algorithm = wolfssl_aes;
  80:	f44f 7383 	mov.w	r3, #262	; 0x106
  84:	8123      	strh	r3, [r4, #8]
        specs->mac_algorithm         = sha256_mac;
  86:	f240 7304 	movw	r3, #1796	; 0x704
  8a:	8163      	strh	r3, [r4, #10]
        specs->sig_algo              = ecc_dsa_sa_algo;
  8c:	f242 0303 	movw	r3, #8195	; 0x2003
  90:	81a3      	strh	r3, [r4, #12]
        specs->pad_size              = PAD_SHA;
  92:	2328      	movs	r3, #40	; 0x28
  94:	81e3      	strh	r3, [r4, #14]
        specs->key_size              = AES_128_KEY_SIZE;
  96:	2310      	movs	r3, #16
  98:	8023      	strh	r3, [r4, #0]
        specs->iv_size               = AES_IV_SIZE;
  9a:	8063      	strh	r3, [r4, #2]
        specs->block_size            = AES_BLOCK_SIZE;
  9c:	80a3      	strh	r3, [r4, #4]
    return 0;
  9e:	2000      	movs	r0, #0
  a0:	e7b8      	b.n	14 <GetCipherSpec+0x14>
        specs->bulk_cipher_algorithm = wolfssl_triple_des;
  a2:	f44f 7382 	mov.w	r3, #260	; 0x104
  a6:	8123      	strh	r3, [r4, #8]
        specs->mac_algorithm         = sha_mac;
  a8:	f240 7302 	movw	r3, #1794	; 0x702
  ac:	8163      	strh	r3, [r4, #10]
        specs->sig_algo              = ecc_dsa_sa_algo;
  ae:	f241 4303 	movw	r3, #5123	; 0x1403
  b2:	81a3      	strh	r3, [r4, #12]
        specs->pad_size              = PAD_SHA;
  b4:	2328      	movs	r3, #40	; 0x28
  b6:	81e3      	strh	r3, [r4, #14]
        specs->key_size              = DES3_KEY_SIZE;
  b8:	2318      	movs	r3, #24
  ba:	8023      	strh	r3, [r4, #0]
        specs->block_size            = DES_BLOCK_SIZE;
  bc:	80a6      	strh	r6, [r4, #4]
        specs->iv_size               = DES_IV_SIZE;
  be:	8066      	strh	r6, [r4, #2]
        break;
  c0:	e7ed      	b.n	9e <GetCipherSpec+0x9e>
        specs->bulk_cipher_algorithm = wolfssl_aes;
  c2:	f44f 7383 	mov.w	r3, #262	; 0x106
  c6:	8123      	strh	r3, [r4, #8]
        specs->mac_algorithm         = sha_mac;
  c8:	f240 7302 	movw	r3, #1794	; 0x702
  cc:	8163      	strh	r3, [r4, #10]
        specs->sig_algo              = ecc_dsa_sa_algo;
  ce:	f241 4303 	movw	r3, #5123	; 0x1403
  d2:	81a3      	strh	r3, [r4, #12]
        specs->pad_size              = PAD_SHA;
  d4:	2328      	movs	r3, #40	; 0x28
  d6:	81e3      	strh	r3, [r4, #14]
        specs->key_size              = AES_256_KEY_SIZE;
  d8:	2320      	movs	r3, #32
  da:	8023      	strh	r3, [r4, #0]
        specs->block_size            = AES_BLOCK_SIZE;
  dc:	2310      	movs	r3, #16
  de:	e7b6      	b.n	4e <GetCipherSpec+0x4e>
    if (cipherSuite0 != ECC_BYTE &&
  e0:	2fd0      	cmp	r7, #208	; 0xd0
  e2:	d001      	beq.n	e8 <GetCipherSpec+0xe8>
        cipherSuite0 != CHACHA_BYTE &&
  e4:	2f13      	cmp	r7, #19
  e6:	d194      	bne.n	12 <GetCipherSpec+0x12>
    if (specs->sig_algo == anonymous_sa_algo && opts != NULL) {
  e8:	7b20      	ldrb	r0, [r4, #12]
  ea:	2800      	cmp	r0, #0
  ec:	d1d7      	bne.n	9e <GetCipherSpec+0x9e>
  ee:	2d00      	cmp	r5, #0
  f0:	d0d5      	beq.n	9e <GetCipherSpec+0x9e>
        opts->peerAuthGood = 1;
  f2:	7aab      	ldrb	r3, [r5, #10]
  f4:	f043 0302 	orr.w	r3, r3, #2
  f8:	72ab      	strb	r3, [r5, #10]
  fa:	e78b      	b.n	14 <GetCipherSpec+0x14>
  fc:	fffffe0c 	.word	0xfffffe0c

Disassembly of section .text.SetCipherSpecs:

00000000 <SetCipherSpecs>:
{
   0:	b513      	push	{r0, r1, r4, lr}
   2:	4604      	mov	r4, r0
    int ret = GetCipherSpec(ssl->options.side, ssl->options.cipherSuite0,
   4:	f890 0270 	ldrb.w	r0, [r0, #624]	; 0x270
   8:	f894 2279 	ldrb.w	r2, [r4, #633]	; 0x279
   c:	f894 1278 	ldrb.w	r1, [r4, #632]	; 0x278
  10:	f504 731b 	add.w	r3, r4, #620	; 0x26c
  14:	9300      	str	r3, [sp, #0]
  16:	f3c0 1001 	ubfx	r0, r0, #4, #2
  1a:	f504 73a0 	add.w	r3, r4, #320	; 0x140
  1e:	f7ff fffe 	bl	0 <SetCipherSpecs>
    if (ret == 0) {
  22:	bb00      	cbnz	r0, 66 <SetCipherSpecs+0x66>
        if (ssl->version.major == SSLv3_MAJOR &&
  24:	f894 313c 	ldrb.w	r3, [r4, #316]	; 0x13c
  28:	2b03      	cmp	r3, #3
  2a:	d11c      	bne.n	66 <SetCipherSpecs+0x66>
                ssl->version.minor >= TLSv1_MINOR) {
  2c:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
        if (ssl->version.major == SSLv3_MAJOR &&
  30:	b1cb      	cbz	r3, 66 <SetCipherSpecs+0x66>
            ssl->options.tls = 1;
  32:	f894 2271 	ldrb.w	r2, [r4, #625]	; 0x271
  36:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  3a:	f884 2271 	strb.w	r2, [r4, #625]	; 0x271
            if (ssl->version.minor >= TLSv1_1_MINOR) {
  3e:	2b01      	cmp	r3, #1
            ssl->hmac = TLS_hmac;
  40:	4a0a      	ldr	r2, [pc, #40]	; (6c <SetCipherSpecs+0x6c>)
  42:	64e2      	str	r2, [r4, #76]	; 0x4c
            if (ssl->version.minor >= TLSv1_1_MINOR) {
  44:	d00f      	beq.n	66 <SetCipherSpecs+0x66>
                if (ssl->version.minor >= TLSv1_3_MINOR)
  46:	2b03      	cmp	r3, #3
                ssl->options.tls1_1 = 1;
  48:	f894 2271 	ldrb.w	r2, [r4, #625]	; 0x271
                    ssl->options.tls1_3 = 1;
  4c:	bf88      	it	hi
  4e:	f894 3272 	ldrbhi.w	r3, [r4, #626]	; 0x272
                ssl->options.tls1_1 = 1;
  52:	f042 0280 	orr.w	r2, r2, #128	; 0x80
                    ssl->options.tls1_3 = 1;
  56:	bf88      	it	hi
  58:	f043 0301 	orrhi.w	r3, r3, #1
                ssl->options.tls1_1 = 1;
  5c:	f884 2271 	strb.w	r2, [r4, #625]	; 0x271
                    ssl->options.tls1_3 = 1;
  60:	bf88      	it	hi
  62:	f884 3272 	strbhi.w	r3, [r4, #626]	; 0x272
}
  66:	b002      	add	sp, #8
  68:	bd10      	pop	{r4, pc}
  6a:	bf00      	nop
  6c:	00000000 	.word	0x00000000

Disassembly of section .text.SetKeysSide:

00000000 <SetKeysSide>:
#endif
            copy = 1;
    }
#endif /* HAVE_SECURE_RENEGOTIATION */

    switch (side) {
   0:	2902      	cmp	r1, #2
{
   2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   6:	4604      	mov	r4, r0
    switch (side) {
   8:	d02a      	beq.n	60 <SetKeysSide+0x60>
   a:	2903      	cmp	r1, #3
   c:	d02c      	beq.n	68 <SetKeysSide+0x68>
   e:	2901      	cmp	r1, #1
  10:	f040 81ca 	bne.w	3a8 <SetKeysSide+0x3a8>
            }
            else {
                WOLFSSL_BUFFER(keys->server_write_key, ssl->specs.key_size);
            }
#endif
            wc_encrypt = &ssl->encrypt;
  14:	f100 0550 	add.w	r5, r0, #80	; 0x50
    Ciphers* wc_decrypt = NULL;
  18:	2600      	movs	r6, #0
    if (specs->bulk_cipher_algorithm == wolfssl_triple_des) {
  1a:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
        ret = ssl->ctx->EncryptKeysCb(ssl, ctx);
    }
    if (!ssl->ctx->EncryptKeysCb || ret == PROTOCOLCB_UNAVAILABLE)
#endif
    {
        ret = SetKeys(wc_encrypt, wc_decrypt, keys, &ssl->specs, ssl->options.side,
  1e:	f894 7270 	ldrb.w	r7, [r4, #624]	; 0x270
                      ssl->heap, ssl->devId, ssl->rng, ssl->options.tls1_3);
  22:	f894 a272 	ldrb.w	sl, [r4, #626]	; 0x272
        ret = SetKeys(wc_encrypt, wc_decrypt, keys, &ssl->specs, ssl->options.side,
  26:	f8d4 8024 	ldr.w	r8, [r4, #36]	; 0x24
  2a:	f8d4 92bc 	ldr.w	r9, [r4, #700]	; 0x2bc
  2e:	f8d4 b018 	ldr.w	fp, [r4, #24]
    if (specs->bulk_cipher_algorithm == wolfssl_triple_des) {
  32:	2b04      	cmp	r3, #4
        ret = SetKeys(wc_encrypt, wc_decrypt, keys, &ssl->specs, ssl->options.side,
  34:	f3c7 1701 	ubfx	r7, r7, #4, #2
                      ssl->heap, ssl->devId, ssl->rng, ssl->options.tls1_3);
  38:	f00a 0a01 	and.w	sl, sl, #1
    if (specs->bulk_cipher_algorithm == wolfssl_triple_des) {
  3c:	d166      	bne.n	10c <SetKeysSide+0x10c>
        if (enc) {
  3e:	2d00      	cmp	r5, #0
  40:	f000 81d8 	beq.w	3f4 <SetKeysSide+0x3f4>
            if (enc->des3 == NULL)
  44:	682b      	ldr	r3, [r5, #0]
  46:	b923      	cbnz	r3, 52 <SetKeysSide+0x52>
                enc->des3 = (Des3*)XMALLOC(sizeof(Des3), heap, DYNAMIC_TYPE_CIPHER);
  48:	f44f 70ca 	mov.w	r0, #404	; 0x194
  4c:	f7ff fffe 	bl	0 <malloc>
  50:	6028      	str	r0, [r5, #0]
            if (enc->des3 == NULL)
  52:	6828      	ldr	r0, [r5, #0]
  54:	b968      	cbnz	r0, 72 <SetKeysSide+0x72>
                return MEMORY_E;
  56:	f06f 007c 	mvn.w	r0, #124	; 0x7c
        CacheStatusPP(ssl->secure_renegotiation);
    }
#endif /* HAVE_SECURE_RENEGOTIATION */

    return ret;
}
  5a:	b003      	add	sp, #12
  5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            wc_decrypt = &ssl->decrypt;
  60:	f100 0664 	add.w	r6, r0, #100	; 0x64
    Ciphers* wc_encrypt = NULL;
  64:	2500      	movs	r5, #0
            break;
  66:	e7d8      	b.n	1a <SetKeysSide+0x1a>
            wc_encrypt = &ssl->encrypt;
  68:	f100 0550 	add.w	r5, r0, #80	; 0x50
            wc_decrypt = &ssl->decrypt;
  6c:	f100 0664 	add.w	r6, r0, #100	; 0x64
            break;
  70:	e7d3      	b.n	1a <SetKeysSide+0x1a>
            XMEMSET(enc->des3, 0, sizeof(Des3));
  72:	f44f 72ca 	mov.w	r2, #404	; 0x194
  76:	2100      	movs	r1, #0
  78:	f7ff fffe 	bl	0 <memset>
        if (dec) {
  7c:	b1c6      	cbz	r6, b0 <SetKeysSide+0xb0>
            if (dec->des3 == NULL)
  7e:	6833      	ldr	r3, [r6, #0]
  80:	b923      	cbnz	r3, 8c <SetKeysSide+0x8c>
                dec->des3 = (Des3*)XMALLOC(sizeof(Des3), heap, DYNAMIC_TYPE_CIPHER);
  82:	f44f 70ca 	mov.w	r0, #404	; 0x194
  86:	f7ff fffe 	bl	0 <malloc>
  8a:	6030      	str	r0, [r6, #0]
            if (dec->des3 == NULL)
  8c:	6830      	ldr	r0, [r6, #0]
  8e:	2800      	cmp	r0, #0
  90:	d0e1      	beq.n	56 <SetKeysSide+0x56>
            XMEMSET(dec->des3, 0, sizeof(Des3));
  92:	f44f 72ca 	mov.w	r2, #404	; 0x194
  96:	2100      	movs	r1, #0
  98:	f7ff fffe 	bl	0 <memset>
        if (enc) {
  9c:	b945      	cbnz	r5, b0 <SetKeysSide+0xb0>
            if (wc_Des3Init(dec->des3, heap, devId) != 0) {
  9e:	6830      	ldr	r0, [r6, #0]
  a0:	464a      	mov	r2, r9
  a2:	4641      	mov	r1, r8
  a4:	f7ff fffe 	bl	0 <wc_Des3Init>
  a8:	b1c0      	cbz	r0, dc <SetKeysSide+0xdc>
                return ASYNC_INIT_E;
  aa:	f06f 00b5 	mvn.w	r0, #181	; 0xb5
  ae:	e7d4      	b.n	5a <SetKeysSide+0x5a>
            if (wc_Des3Init(enc->des3, heap, devId) != 0) {
  b0:	6828      	ldr	r0, [r5, #0]
  b2:	464a      	mov	r2, r9
  b4:	4641      	mov	r1, r8
  b6:	f7ff fffe 	bl	0 <wc_Des3Init>
  ba:	2800      	cmp	r0, #0
  bc:	d1f5      	bne.n	aa <SetKeysSide+0xaa>
        if (dec) {
  be:	2e00      	cmp	r6, #0
  c0:	d1ed      	bne.n	9e <SetKeysSide+0x9e>
        if (side == WOLFSSL_CLIENT_END) {
  c2:	2f01      	cmp	r7, #1
  c4:	f040 80ae 	bne.w	224 <SetKeysSide+0x224>
                desRet = wc_Des3_SetKey(enc->des3, keys->client_write_key,
  c8:	6828      	ldr	r0, [r5, #0]
  ca:	2300      	movs	r3, #0
  cc:	f504 7204 	add.w	r2, r4, #528	; 0x210
  d0:	f504 71e8 	add.w	r1, r4, #464	; 0x1d0
  d4:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
                if (desRet != 0) return desRet;
  d8:	b128      	cbz	r0, e6 <SetKeysSide+0xe6>
  da:	e7be      	b.n	5a <SetKeysSide+0x5a>
        if (side == WOLFSSL_CLIENT_END) {
  dc:	2f01      	cmp	r7, #1
  de:	f040 8097 	bne.w	210 <SetKeysSide+0x210>
            if (enc) {
  e2:	2d00      	cmp	r5, #0
  e4:	d1f0      	bne.n	c8 <SetKeysSide+0xc8>
            if (dec) {
  e6:	b90e      	cbnz	r6, ec <SetKeysSide+0xec>
        if (enc)
  e8:	b95d      	cbnz	r5, 102 <SetKeysSide+0x102>
  ea:	e00f      	b.n	10c <SetKeysSide+0x10c>
                desRet = wc_Des3_SetKey(dec->des3, keys->server_write_key,
  ec:	2301      	movs	r3, #1
  ee:	f504 7208 	add.w	r2, r4, #544	; 0x220
  f2:	f504 71f8 	add.w	r1, r4, #496	; 0x1f0
                desRet = wc_Des3_SetKey(dec->des3, keys->client_write_key,
  f6:	6830      	ldr	r0, [r6, #0]
  f8:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
                if (desRet != 0) return desRet;
  fc:	2800      	cmp	r0, #0
  fe:	d1ac      	bne.n	5a <SetKeysSide+0x5a>
        if (enc)
 100:	b115      	cbz	r5, 108 <SetKeysSide+0x108>
            enc->setup = 1;
 102:	2301      	movs	r3, #1
 104:	746b      	strb	r3, [r5, #17]
        if (dec)
 106:	b10e      	cbz	r6, 10c <SetKeysSide+0x10c>
            dec->setup = 1;
 108:	2301      	movs	r3, #1
 10a:	7473      	strb	r3, [r6, #17]
    if (specs->bulk_cipher_algorithm == wolfssl_aes) {
 10c:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
 110:	2b06      	cmp	r3, #6
 112:	d158      	bne.n	1c6 <SetKeysSide+0x1c6>
        if (enc) {
 114:	2d00      	cmp	r5, #0
 116:	f000 8171 	beq.w	3fc <SetKeysSide+0x3fc>
            if (enc->aes == NULL) {
 11a:	6868      	ldr	r0, [r5, #4]
 11c:	2800      	cmp	r0, #0
 11e:	f040 808c 	bne.w	23a <SetKeysSide+0x23a>
                enc->aes = (Aes*)XMALLOC(sizeof(Aes), heap, DYNAMIC_TYPE_CIPHER);
 122:	f44f 709c 	mov.w	r0, #312	; 0x138
 126:	f7ff fffe 	bl	0 <malloc>
 12a:	6068      	str	r0, [r5, #4]
                if (enc->aes == NULL)
 12c:	2800      	cmp	r0, #0
 12e:	d092      	beq.n	56 <SetKeysSide+0x56>
            XMEMSET(enc->aes, 0, sizeof(Aes));
 130:	6868      	ldr	r0, [r5, #4]
 132:	f44f 729c 	mov.w	r2, #312	; 0x138
 136:	2100      	movs	r1, #0
 138:	f7ff fffe 	bl	0 <memset>
        if (dec) {
 13c:	2e00      	cmp	r6, #0
 13e:	f000 8136 	beq.w	3ae <SetKeysSide+0x3ae>
            if (dec->aes == NULL) {
 142:	6870      	ldr	r0, [r6, #4]
 144:	2800      	cmp	r0, #0
 146:	d17b      	bne.n	240 <SetKeysSide+0x240>
                dec->aes = (Aes*)XMALLOC(sizeof(Aes), heap, DYNAMIC_TYPE_CIPHER);
 148:	f44f 709c 	mov.w	r0, #312	; 0x138
 14c:	f7ff fffe 	bl	0 <malloc>
 150:	6070      	str	r0, [r6, #4]
                if (dec->aes == NULL)
 152:	2800      	cmp	r0, #0
 154:	f43f af7f 	beq.w	56 <SetKeysSide+0x56>
            XMEMSET(dec->aes, 0, sizeof(Aes));
 158:	6870      	ldr	r0, [r6, #4]
 15a:	f44f 729c 	mov.w	r2, #312	; 0x138
 15e:	2100      	movs	r1, #0
 160:	f7ff fffe 	bl	0 <memset>
        if (enc) {
 164:	2d00      	cmp	r5, #0
 166:	f040 8125 	bne.w	3b4 <SetKeysSide+0x3b4>
            if (wc_AesInit(dec->aes, heap, devId) != 0) {
 16a:	6870      	ldr	r0, [r6, #4]
 16c:	464a      	mov	r2, r9
 16e:	4641      	mov	r1, r8
 170:	f7ff fffe 	bl	0 <wc_AesInit>
 174:	2800      	cmp	r0, #0
 176:	d198      	bne.n	aa <SetKeysSide+0xaa>
        if (side == WOLFSSL_CLIENT_END) {
 178:	2f01      	cmp	r7, #1
 17a:	d164      	bne.n	246 <SetKeysSide+0x246>
            if (enc) {
 17c:	b17d      	cbz	r5, 19e <SetKeysSide+0x19e>
                aesRet = wc_AesSetKey(enc->aes, keys->client_write_key,
 17e:	2300      	movs	r3, #0
 180:	9300      	str	r3, [sp, #0]
 182:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 186:	6868      	ldr	r0, [r5, #4]
 188:	f504 7304 	add.w	r3, r4, #528	; 0x210
 18c:	f504 71e8 	add.w	r1, r4, #464	; 0x1d0
 190:	f7ff fffe 	bl	0 <wc_AesSetKey>
                if (aesRet != 0) return aesRet;
 194:	2800      	cmp	r0, #0
 196:	f47f af60 	bne.w	5a <SetKeysSide+0x5a>
            if (dec) {
 19a:	2e00      	cmp	r6, #0
 19c:	d057      	beq.n	24e <SetKeysSide+0x24e>
                aesRet = wc_AesSetKey(dec->aes, keys->server_write_key,
 19e:	2301      	movs	r3, #1
 1a0:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 1a4:	9300      	str	r3, [sp, #0]
 1a6:	f504 71f8 	add.w	r1, r4, #496	; 0x1f0
 1aa:	f504 7308 	add.w	r3, r4, #544	; 0x220
                aesRet = wc_AesSetKey(dec->aes, keys->client_write_key,
 1ae:	6870      	ldr	r0, [r6, #4]
 1b0:	f7ff fffe 	bl	0 <wc_AesSetKey>
                if (aesRet != 0) return aesRet;
 1b4:	2800      	cmp	r0, #0
 1b6:	f47f af50 	bne.w	5a <SetKeysSide+0x5a>
        if (enc)
 1ba:	b115      	cbz	r5, 1c2 <SetKeysSide+0x1c2>
            enc->setup = 1;
 1bc:	2301      	movs	r3, #1
 1be:	746b      	strb	r3, [r5, #17]
        if (dec)
 1c0:	b10e      	cbz	r6, 1c6 <SetKeysSide+0x1c6>
            dec->setup = 1;
 1c2:	2301      	movs	r3, #1
 1c4:	7473      	strb	r3, [r6, #17]
    if (specs->bulk_cipher_algorithm == wolfssl_aes_gcm) {
 1c6:	f894 3148 	ldrb.w	r3, [r4, #328]	; 0x148
 1ca:	2b07      	cmp	r3, #7
 1cc:	f040 80e4 	bne.w	398 <SetKeysSide+0x398>
        if (enc) {
 1d0:	2d00      	cmp	r5, #0
 1d2:	d04b      	beq.n	26c <SetKeysSide+0x26c>
            if (enc->aes == NULL) {
 1d4:	6868      	ldr	r0, [r5, #4]
 1d6:	2800      	cmp	r0, #0
 1d8:	d145      	bne.n	266 <SetKeysSide+0x266>
                enc->aes = (Aes*)XMALLOC(sizeof(Aes), heap, DYNAMIC_TYPE_CIPHER);
 1da:	f44f 709c 	mov.w	r0, #312	; 0x138
 1de:	f7ff fffe 	bl	0 <malloc>
 1e2:	6068      	str	r0, [r5, #4]
                if (enc->aes == NULL)
 1e4:	2800      	cmp	r0, #0
 1e6:	f43f af36 	beq.w	56 <SetKeysSide+0x56>
            XMEMSET(enc->aes, 0, sizeof(Aes));
 1ea:	6868      	ldr	r0, [r5, #4]
 1ec:	f44f 729c 	mov.w	r2, #312	; 0x138
 1f0:	2100      	movs	r1, #0
 1f2:	f7ff fffe 	bl	0 <memset>
        if (dec) {
 1f6:	2e00      	cmp	r6, #0
 1f8:	d139      	bne.n	26e <SetKeysSide+0x26e>
            if (wc_AesInit(enc->aes, heap, devId) != 0) {
 1fa:	6868      	ldr	r0, [r5, #4]
 1fc:	464a      	mov	r2, r9
 1fe:	4641      	mov	r1, r8
 200:	f7ff fffe 	bl	0 <wc_AesInit>
 204:	2800      	cmp	r0, #0
 206:	f47f af50 	bne.w	aa <SetKeysSide+0xaa>
        if (dec) {
 20a:	2e00      	cmp	r6, #0
 20c:	d04a      	beq.n	2a4 <SetKeysSide+0x2a4>
 20e:	e041      	b.n	294 <SetKeysSide+0x294>
            if (enc) {
 210:	b945      	cbnz	r5, 224 <SetKeysSide+0x224>
            if (dec) {
 212:	2e00      	cmp	r6, #0
 214:	f43f af68 	beq.w	e8 <SetKeysSide+0xe8>
                desRet = wc_Des3_SetKey(dec->des3, keys->client_write_key,
 218:	2301      	movs	r3, #1
 21a:	f504 7204 	add.w	r2, r4, #528	; 0x210
 21e:	f504 71e8 	add.w	r1, r4, #464	; 0x1d0
 222:	e768      	b.n	f6 <SetKeysSide+0xf6>
                desRet = wc_Des3_SetKey(enc->des3, keys->server_write_key,
 224:	6828      	ldr	r0, [r5, #0]
 226:	2300      	movs	r3, #0
 228:	f504 7208 	add.w	r2, r4, #544	; 0x220
 22c:	f504 71f8 	add.w	r1, r4, #496	; 0x1f0
 230:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
                if (desRet != 0) return desRet;
 234:	2800      	cmp	r0, #0
 236:	d0ec      	beq.n	212 <SetKeysSide+0x212>
 238:	e70f      	b.n	5a <SetKeysSide+0x5a>
                wc_AesFree(enc->aes);
 23a:	f7ff fffe 	bl	0 <wc_AesFree>
 23e:	e777      	b.n	130 <SetKeysSide+0x130>
                wc_AesFree(dec->aes);
 240:	f7ff fffe 	bl	0 <wc_AesFree>
 244:	e788      	b.n	158 <SetKeysSide+0x158>
            if (enc) {
 246:	2d00      	cmp	r5, #0
 248:	f040 80c2 	bne.w	3d0 <SetKeysSide+0x3d0>
            if (dec) {
 24c:	b916      	cbnz	r6, 254 <SetKeysSide+0x254>
        if (enc)
 24e:	2d00      	cmp	r5, #0
 250:	d1b4      	bne.n	1bc <SetKeysSide+0x1bc>
 252:	e7b8      	b.n	1c6 <SetKeysSide+0x1c6>
                aesRet = wc_AesSetKey(dec->aes, keys->client_write_key,
 254:	2301      	movs	r3, #1
 256:	9300      	str	r3, [sp, #0]
 258:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 25c:	f504 7304 	add.w	r3, r4, #528	; 0x210
 260:	f504 71e8 	add.w	r1, r4, #464	; 0x1d0
 264:	e7a3      	b.n	1ae <SetKeysSide+0x1ae>
                wc_AesFree(enc->aes);
 266:	f7ff fffe 	bl	0 <wc_AesFree>
 26a:	e7be      	b.n	1ea <SetKeysSide+0x1ea>
        if (dec) {
 26c:	b1d6      	cbz	r6, 2a4 <SetKeysSide+0x2a4>
            if (dec->aes == NULL) {
 26e:	6870      	ldr	r0, [r6, #4]
 270:	2800      	cmp	r0, #0
 272:	d13c      	bne.n	2ee <SetKeysSide+0x2ee>
                dec->aes = (Aes*)XMALLOC(sizeof(Aes), heap, DYNAMIC_TYPE_CIPHER);
 274:	f44f 709c 	mov.w	r0, #312	; 0x138
 278:	f7ff fffe 	bl	0 <malloc>
 27c:	6070      	str	r0, [r6, #4]
                if (dec->aes == NULL)
 27e:	2800      	cmp	r0, #0
 280:	f43f aee9 	beq.w	56 <SetKeysSide+0x56>
            XMEMSET(dec->aes, 0, sizeof(Aes));
 284:	6870      	ldr	r0, [r6, #4]
 286:	f44f 729c 	mov.w	r2, #312	; 0x138
 28a:	2100      	movs	r1, #0
 28c:	f7ff fffe 	bl	0 <memset>
        if (enc) {
 290:	2d00      	cmp	r5, #0
 292:	d1b2      	bne.n	1fa <SetKeysSide+0x1fa>
            if (wc_AesInit(dec->aes, heap, devId) != 0) {
 294:	6870      	ldr	r0, [r6, #4]
 296:	464a      	mov	r2, r9
 298:	4641      	mov	r1, r8
 29a:	f7ff fffe 	bl	0 <wc_AesInit>
 29e:	2800      	cmp	r0, #0
 2a0:	f47f af03 	bne.w	aa <SetKeysSide+0xaa>
        if (side == WOLFSSL_CLIENT_END) {
 2a4:	2f01      	cmp	r7, #1
 2a6:	d145      	bne.n	334 <SetKeysSide+0x334>
            if (enc) {
 2a8:	b325      	cbz	r5, 2f4 <SetKeysSide+0x2f4>
                gcmRet = wc_AesGcmSetKey(enc->aes, keys->client_write_key,
 2aa:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 2ae:	6868      	ldr	r0, [r5, #4]
 2b0:	f504 71e8 	add.w	r1, r4, #464	; 0x1d0
 2b4:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
                if (gcmRet != 0) return gcmRet;
 2b8:	2800      	cmp	r0, #0
 2ba:	f47f aece 	bne.w	5a <SetKeysSide+0x5a>
                XMEMCPY(keys->aead_enc_imp_IV, keys->client_write_IV,
 2be:	f504 7704 	add.w	r7, r4, #528	; 0x210
 2c2:	220c      	movs	r2, #12
 2c4:	4639      	mov	r1, r7
 2c6:	f504 700e 	add.w	r0, r4, #568	; 0x238
 2ca:	f7ff fffe 	bl	0 <memcpy>
                if (!tls13) {
 2ce:	f1ba 0f00 	cmp.w	sl, #0
 2d2:	d10a      	bne.n	2ea <SetKeysSide+0x2ea>
                    gcmRet = wc_AesGcmSetIV(enc->aes, AESGCM_NONCE_SZ,
 2d4:	f8cd b000 	str.w	fp, [sp]
 2d8:	6868      	ldr	r0, [r5, #4]
 2da:	2304      	movs	r3, #4
 2dc:	463a      	mov	r2, r7
 2de:	210c      	movs	r1, #12
 2e0:	f7ff fffe 	bl	0 <wc_AesGcmSetIV>
                    if (gcmRet != 0) return gcmRet;
 2e4:	2800      	cmp	r0, #0
 2e6:	f47f aeb8 	bne.w	5a <SetKeysSide+0x5a>
            if (dec) {
 2ea:	b92e      	cbnz	r6, 2f8 <SetKeysSide+0x2f8>
 2ec:	e017      	b.n	31e <SetKeysSide+0x31e>
                wc_AesFree(dec->aes);
 2ee:	f7ff fffe 	bl	0 <wc_AesFree>
 2f2:	e7c7      	b.n	284 <SetKeysSide+0x284>
            if (dec) {
 2f4:	2e00      	cmp	r6, #0
 2f6:	d055      	beq.n	3a4 <SetKeysSide+0x3a4>
                gcmRet = wc_AesGcmSetKey(dec->aes, keys->server_write_key,
 2f8:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 2fc:	6870      	ldr	r0, [r6, #4]
 2fe:	f504 71f8 	add.w	r1, r4, #496	; 0x1f0
 302:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
                if (gcmRet != 0) return gcmRet;
 306:	2800      	cmp	r0, #0
 308:	f47f aea7 	bne.w	5a <SetKeysSide+0x5a>
                XMEMCPY(keys->aead_dec_imp_IV, keys->server_write_IV,
 30c:	220c      	movs	r2, #12
 30e:	f504 7108 	add.w	r1, r4, #544	; 0x220
                XMEMCPY(keys->aead_dec_imp_IV, keys->client_write_IV,
 312:	f504 7011 	add.w	r0, r4, #580	; 0x244
 316:	f7ff fffe 	bl	0 <memcpy>
        if (enc)
 31a:	2d00      	cmp	r5, #0
 31c:	d067      	beq.n	3ee <SetKeysSide+0x3ee>
            enc->setup = 1;
 31e:	2301      	movs	r3, #1
 320:	746b      	strb	r3, [r5, #17]
        if (dec)
 322:	2e00      	cmp	r6, #0
 324:	d039      	beq.n	39a <SetKeysSide+0x39a>
            dec->setup = 1;
 326:	2301      	movs	r3, #1
 328:	7473      	strb	r3, [r6, #17]
    if (enc) {
 32a:	bbb5      	cbnz	r5, 39a <SetKeysSide+0x39a>
        keys->peer_sequence_number_hi = 0;
 32c:	2000      	movs	r0, #0
        keys->peer_sequence_number_lo = 0;
 32e:	e9c4 0094 	strd	r0, r0, [r4, #592]	; 0x250
 332:	e692      	b.n	5a <SetKeysSide+0x5a>
            if (enc) {
 334:	b30d      	cbz	r5, 37a <SetKeysSide+0x37a>
                gcmRet = wc_AesGcmSetKey(enc->aes, keys->server_write_key,
 336:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 33a:	6868      	ldr	r0, [r5, #4]
 33c:	f504 71f8 	add.w	r1, r4, #496	; 0x1f0
 340:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
                if (gcmRet != 0) return gcmRet;
 344:	2800      	cmp	r0, #0
 346:	f47f ae88 	bne.w	5a <SetKeysSide+0x5a>
                XMEMCPY(keys->aead_enc_imp_IV, keys->server_write_IV,
 34a:	f504 7708 	add.w	r7, r4, #544	; 0x220
 34e:	220c      	movs	r2, #12
 350:	4639      	mov	r1, r7
 352:	f504 700e 	add.w	r0, r4, #568	; 0x238
 356:	f7ff fffe 	bl	0 <memcpy>
                if (!tls13) {
 35a:	f1ba 0f00 	cmp.w	sl, #0
 35e:	d10a      	bne.n	376 <SetKeysSide+0x376>
                    gcmRet = wc_AesGcmSetIV(enc->aes, AESGCM_NONCE_SZ,
 360:	f8cd b000 	str.w	fp, [sp]
 364:	6868      	ldr	r0, [r5, #4]
 366:	2304      	movs	r3, #4
 368:	463a      	mov	r2, r7
 36a:	210c      	movs	r1, #12
 36c:	f7ff fffe 	bl	0 <wc_AesGcmSetIV>
                    if (gcmRet != 0) return gcmRet;
 370:	2800      	cmp	r0, #0
 372:	f47f ae72 	bne.w	5a <SetKeysSide+0x5a>
            if (dec) {
 376:	b90e      	cbnz	r6, 37c <SetKeysSide+0x37c>
 378:	e7d1      	b.n	31e <SetKeysSide+0x31e>
 37a:	b19e      	cbz	r6, 3a4 <SetKeysSide+0x3a4>
                gcmRet = wc_AesGcmSetKey(dec->aes, keys->client_write_key,
 37c:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 380:	6870      	ldr	r0, [r6, #4]
 382:	f504 71e8 	add.w	r1, r4, #464	; 0x1d0
 386:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
                if (gcmRet != 0) return gcmRet;
 38a:	2800      	cmp	r0, #0
 38c:	f47f ae65 	bne.w	5a <SetKeysSide+0x5a>
                XMEMCPY(keys->aead_dec_imp_IV, keys->client_write_IV,
 390:	220c      	movs	r2, #12
 392:	f504 7104 	add.w	r1, r4, #528	; 0x210
 396:	e7bc      	b.n	312 <SetKeysSide+0x312>
    if (enc) {
 398:	b115      	cbz	r5, 3a0 <SetKeysSide+0x3a0>
        keys->sequence_number_hi      = 0;
 39a:	2300      	movs	r3, #0
        keys->sequence_number_lo      = 0;
 39c:	e9c4 3396 	strd	r3, r3, [r4, #600]	; 0x258
    if (dec) {
 3a0:	2e00      	cmp	r6, #0
 3a2:	d1c3      	bne.n	32c <SetKeysSide+0x32c>
    return 0;
 3a4:	2000      	movs	r0, #0
 3a6:	e658      	b.n	5a <SetKeysSide+0x5a>
    switch (side) {
 3a8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 3ac:	e655      	b.n	5a <SetKeysSide+0x5a>
        if (enc) {
 3ae:	2d00      	cmp	r5, #0
 3b0:	f43f af09 	beq.w	1c6 <SetKeysSide+0x1c6>
            if (wc_AesInit(enc->aes, heap, devId) != 0) {
 3b4:	6868      	ldr	r0, [r5, #4]
 3b6:	464a      	mov	r2, r9
 3b8:	4641      	mov	r1, r8
 3ba:	f7ff fffe 	bl	0 <wc_AesInit>
 3be:	2800      	cmp	r0, #0
 3c0:	f47f ae73 	bne.w	aa <SetKeysSide+0xaa>
        if (dec) {
 3c4:	2e00      	cmp	r6, #0
 3c6:	f47f aed0 	bne.w	16a <SetKeysSide+0x16a>
        if (side == WOLFSSL_CLIENT_END) {
 3ca:	2f01      	cmp	r7, #1
 3cc:	f43f aed7 	beq.w	17e <SetKeysSide+0x17e>
                aesRet = wc_AesSetKey(enc->aes, keys->server_write_key,
 3d0:	2300      	movs	r3, #0
 3d2:	9300      	str	r3, [sp, #0]
 3d4:	f8b4 2140 	ldrh.w	r2, [r4, #320]	; 0x140
 3d8:	6868      	ldr	r0, [r5, #4]
 3da:	f504 7308 	add.w	r3, r4, #544	; 0x220
 3de:	f504 71f8 	add.w	r1, r4, #496	; 0x1f0
 3e2:	f7ff fffe 	bl	0 <wc_AesSetKey>
                if (aesRet != 0) return aesRet;
 3e6:	2800      	cmp	r0, #0
 3e8:	f43f af30 	beq.w	24c <SetKeysSide+0x24c>
 3ec:	e635      	b.n	5a <SetKeysSide+0x5a>
        if (dec)
 3ee:	2e00      	cmp	r6, #0
 3f0:	d199      	bne.n	326 <SetKeysSide+0x326>
 3f2:	e7d7      	b.n	3a4 <SetKeysSide+0x3a4>
        if (dec) {
 3f4:	2e00      	cmp	r6, #0
 3f6:	f47f ae42 	bne.w	7e <SetKeysSide+0x7e>
 3fa:	e687      	b.n	10c <SetKeysSide+0x10c>
        if (dec) {
 3fc:	2e00      	cmp	r6, #0
 3fe:	f47f aea0 	bne.w	142 <SetKeysSide+0x142>
 402:	e6e0      	b.n	1c6 <SetKeysSide+0x1c6>

Disassembly of section .text.StoreKeys:

00000000 <StoreKeys>:


/* TLS can call too */
int StoreKeys(WOLFSSL* ssl, const byte* keyData, int side)
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

        return 0;
    }
#endif /* WOLFSSL_MULTICAST */

    if (ssl->specs.cipher_type != aead) {
   4:	f890 3149 	ldrb.w	r3, [r0, #329]	; 0x149
   8:	2b02      	cmp	r3, #2
{
   a:	4605      	mov	r5, r0
   c:	460f      	mov	r7, r1
        sz = ssl->specs.hash_size;
        if (side & PROVISION_CLIENT) {
   e:	f002 0801 	and.w	r8, r2, #1
  12:	f002 0602 	and.w	r6, r2, #2
    if (ssl->specs.cipher_type != aead) {
  16:	d048      	beq.n	aa <StoreKeys+0xaa>
        sz = ssl->specs.hash_size;
  18:	f890 914d 	ldrb.w	r9, [r0, #333]	; 0x14d
        if (side & PROVISION_CLIENT) {
  1c:	f1b8 0f00 	cmp.w	r8, #0
  20:	d041      	beq.n	a6 <StoreKeys+0xa6>
        #ifdef WOLFSSL_DTLS
            if (scr_copy)
                XMEMCPY(ssl->keys.client_write_MAC_secret,
                        keys->client_write_MAC_secret, sz);
        #endif
            XMEMCPY(keys->client_write_MAC_secret,&keyData[i], sz);
  22:	464a      	mov	r2, r9
  24:	f500 70a8 	add.w	r0, r0, #336	; 0x150
  28:	f7ff fffe 	bl	0 <memcpy>
    #endif
            i += sz;
  2c:	464c      	mov	r4, r9
        }
        if (side & PROVISION_SERVER) {
  2e:	b136      	cbz	r6, 3e <StoreKeys+0x3e>
        #ifdef WOLFSSL_DTLS
            if (scr_copy)
                XMEMCPY(ssl->keys.server_write_MAC_secret,
                        keys->server_write_MAC_secret, sz);
        #endif
            XMEMCPY(keys->server_write_MAC_secret,&keyData[i], sz);
  30:	1939      	adds	r1, r7, r4
  32:	464a      	mov	r2, r9
  34:	f505 70c8 	add.w	r0, r5, #400	; 0x190
  38:	f7ff fffe 	bl	0 <memcpy>
    #endif
            i += sz;
  3c:	444c      	add	r4, r9
        }
    }
    sz = ssl->specs.key_size;
  3e:	f8b5 9140 	ldrh.w	r9, [r5, #320]	; 0x140
    if (side & PROVISION_CLIENT) {
  42:	f1b8 0f00 	cmp.w	r8, #0
  46:	d006      	beq.n	56 <StoreKeys+0x56>
    #ifdef WOLFSSL_DTLS
        if (scr_copy)
            XMEMCPY(ssl->keys.client_write_key,
                    keys->client_write_key, sz);
    #endif
        XMEMCPY(keys->client_write_key, &keyData[i], sz);
  48:	1939      	adds	r1, r7, r4
  4a:	464a      	mov	r2, r9
  4c:	f505 70e8 	add.w	r0, r5, #464	; 0x1d0
  50:	f7ff fffe 	bl	0 <memcpy>
        i += sz;
  54:	444c      	add	r4, r9
    }
    if (side & PROVISION_SERVER) {
  56:	b136      	cbz	r6, 66 <StoreKeys+0x66>
    #ifdef WOLFSSL_DTLS
        if (scr_copy)
            XMEMCPY(ssl->keys.server_write_key,
                    keys->server_write_key, sz);
    #endif
        XMEMCPY(keys->server_write_key, &keyData[i], sz);
  58:	1939      	adds	r1, r7, r4
  5a:	464a      	mov	r2, r9
  5c:	f505 70f8 	add.w	r0, r5, #496	; 0x1f0
  60:	f7ff fffe 	bl	0 <memcpy>
        i += sz;
  64:	444c      	add	r4, r9
    }

    sz = ssl->specs.iv_size;
  66:	f8b5 9142 	ldrh.w	r9, [r5, #322]	; 0x142
    if (side & PROVISION_CLIENT) {
  6a:	f1b8 0f00 	cmp.w	r8, #0
  6e:	d006      	beq.n	7e <StoreKeys+0x7e>
    #ifdef WOLFSSL_DTLS
        if (scr_copy)
            XMEMCPY(ssl->keys.client_write_IV,
                    keys->client_write_IV, sz);
    #endif
        XMEMCPY(keys->client_write_IV, &keyData[i], sz);
  70:	1939      	adds	r1, r7, r4
  72:	464a      	mov	r2, r9
  74:	f505 7004 	add.w	r0, r5, #528	; 0x210
  78:	f7ff fffe 	bl	0 <memcpy>
        i += sz;
  7c:	444c      	add	r4, r9
    }
    if (side & PROVISION_SERVER) {
  7e:	b12e      	cbz	r6, 8c <StoreKeys+0x8c>
    #ifdef WOLFSSL_DTLS
        if (scr_copy)
            XMEMCPY(ssl->keys.server_write_IV,
                    keys->server_write_IV, sz);
    #endif
        XMEMCPY(keys->server_write_IV, &keyData[i], sz);
  80:	464a      	mov	r2, r9
  82:	1939      	adds	r1, r7, r4
  84:	f505 7008 	add.w	r0, r5, #544	; 0x220
  88:	f7ff fffe 	bl	0 <memcpy>
    }

#ifdef HAVE_AEAD
    if (ssl->specs.cipher_type == aead) {
  8c:	f895 3149 	ldrb.w	r3, [r5, #329]	; 0x149
  90:	2b02      	cmp	r3, #2
  92:	d105      	bne.n	a0 <StoreKeys+0xa0>
    #ifdef WOLFSSL_DTLS
        if (scr_copy)
            XMEMMOVE(ssl->keys.aead_exp_IV,
                    keys->aead_exp_IV, AEAD_MAX_EXP_SZ);
    #endif
        XMEMSET(keys->aead_exp_IV, 0, AEAD_MAX_EXP_SZ);
  94:	2208      	movs	r2, #8
  96:	2100      	movs	r1, #0
  98:	f505 700c 	add.w	r0, r5, #560	; 0x230
  9c:	f7ff fffe 	bl	0 <memset>
    }
#endif

    return 0;
}
  a0:	2000      	movs	r0, #0
  a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    int sz, i = 0;
  a6:	4644      	mov	r4, r8
  a8:	e7c1      	b.n	2e <StoreKeys+0x2e>
  aa:	2400      	movs	r4, #0
  ac:	e7c7      	b.n	3e <StoreKeys+0x3e>

Disassembly of section .text.MakeMasterSecret:

00000000 <MakeMasterSecret>:
    /* append secret to premaster : premaster | SerSi | CliSi */
#ifndef NO_OLD_TLS
    if (ssl->options.tls) return MakeTlsMasterSecret(ssl);
    return MakeSslMasterSecret(ssl);
#elif !defined(WOLFSSL_NO_TLS12) && !defined(NO_TLS)
    return MakeTlsMasterSecret(ssl);
   0:	f7ff bffe 	b.w	0 <MakeTlsMasterSecret>

ocsp.o:     file format elf32-littlearm


sniffer.o:     file format elf32-littlearm


ssl.o:     file format elf32-littlearm


Disassembly of section .text.ForceZero:

00000000 <ForceZero>:
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
   0:	4401      	add	r1, r0
   2:	2300      	movs	r3, #0
   4:	4288      	cmp	r0, r1
   6:	d100      	bne.n	a <ForceZero+0xa>
}
   8:	4770      	bx	lr
    while (len--) *z++ = 0;
   a:	f800 3b01 	strb.w	r3, [r0], #1
   e:	e7f9      	b.n	4 <ForceZero+0x4>

Disassembly of section .text.HashSigner:

00000000 <HashSigner>:
#if defined(HAVE_SESSION_TICKET) || !defined(NO_CERTS) || \
    !defined(NO_SESSION_CACHE)
/* Make a word from the front of random hash */
WC_MISC_STATIC WC_INLINE word32 MakeWordFromHash(const byte* hashID)
{
    return ((word32)hashID[0] << 24) | ((word32)hashID[1] << 16) |
   0:	6803      	ldr	r3, [r0, #0]
#ifndef NO_CERTS

/* hash is the SHA digest of name, just use first 32 bits as hash */
static WC_INLINE word32 HashSigner(const byte* hash)
{
    return MakeWordFromHash(hash) % CA_TABLE_SIZE;
   2:	220b      	movs	r2, #11
   4:	ba1b      	rev	r3, r3
   6:	fbb3 f0f2 	udiv	r0, r3, r2
}
   a:	fb02 3010 	mls	r0, r2, r0, r3
   e:	4770      	bx	lr

Disassembly of section .text.ModeToVerifyOptions:

00000000 <ModeToVerifyOptions>:
    byte failNoCertxPSK:1;
    byte verifyPostHandshake:1;
} SetVerifyOptions;

static SetVerifyOptions ModeToVerifyOptions(int mode)
{
   0:	b513      	push	{r0, r1, r4, lr}
    SetVerifyOptions opts;
    XMEMSET(&opts, 0, sizeof(SetVerifyOptions));
   2:	2201      	movs	r2, #1
{
   4:	4604      	mov	r4, r0
    XMEMSET(&opts, 0, sizeof(SetVerifyOptions));
   6:	2100      	movs	r1, #0
   8:	a801      	add	r0, sp, #4
   a:	f7ff fffe 	bl	0 <memset>

    if (mode != WOLFSSL_VERIFY_DEFAULT) {
   e:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
  12:	d01a      	beq.n	4a <ModeToVerifyOptions+0x4a>
        opts.verifyNone = (mode == WOLFSSL_VERIFY_NONE);
  14:	f89d 3004 	ldrb.w	r3, [sp, #4]
  18:	fab4 f284 	clz	r2, r4
  1c:	0952      	lsrs	r2, r2, #5
  1e:	f362 0341 	bfi	r3, r2, #1, #1
  22:	f88d 3004 	strb.w	r3, [sp, #4]
        if (!opts.verifyNone) {
  26:	b2da      	uxtb	r2, r3
  28:	079b      	lsls	r3, r3, #30
  2a:	d40e      	bmi.n	4a <ModeToVerifyOptions+0x4a>
            opts.verifyPeer =
                    (mode & WOLFSSL_VERIFY_PEER) != 0;
            opts.failNoCertxPSK =
                    (mode & WOLFSSL_VERIFY_FAIL_EXCEPT_PSK) != 0;
            opts.failNoCert =
                    (mode & WOLFSSL_VERIFY_FAIL_IF_NO_PEER_CERT) != 0;
  2c:	f3c4 0340 	ubfx	r3, r4, #1, #1
            opts.verifyPeer =
  30:	f004 0001 	and.w	r0, r4, #1
  34:	ea40 0083 	orr.w	r0, r0, r3, lsl #2
                    (mode & WOLFSSL_VERIFY_FAIL_EXCEPT_PSK) != 0;
  38:	f3c4 1400 	ubfx	r4, r4, #4, #1
            opts.verifyPeer =
  3c:	ea40 04c4 	orr.w	r4, r0, r4, lsl #3
  40:	f022 030d 	bic.w	r3, r2, #13
  44:	431c      	orrs	r4, r3
  46:	f88d 4004 	strb.w	r4, [sp, #4]
#endif
        }
    }

    return opts;
}
  4a:	f89d 0004 	ldrb.w	r0, [sp, #4]
  4e:	b002      	add	sp, #8
  50:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSL_CertManagerFree:

00000000 <wolfSSL_CertManagerFree>:
/* Dispose of certificate manager.
 *
 * @param [in, out] cm  Certificate manager.
 */
void wolfSSL_CertManagerFree(WOLFSSL_CERT_MANAGER* cm)
{
   0:	b510      	push	{r4, lr}
    WOLFSSL_ENTER("wolfSSL_CertManagerFree");

    /* Validate parameter. */
    if (cm != NULL) {
   2:	4604      	mov	r4, r0
   4:	b180      	cbz	r0, 28 <wolfSSL_CertManagerFree+0x28>
        int doFree = 0;
        int ret;

        /* Decrement reference count and check if value is 0. */
        wolfSSL_RefDec(&cm->ref, &doFree, &ret);
   6:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
   8:	3b01      	subs	r3, #1
   a:	65c3      	str	r3, [r0, #92]	; 0x5c
            WOLFSSL_MSG("Couldn't lock cm mutex");
        }
    #else
        (void)ret;
    #endif
        if (doFree) {
   c:	b963      	cbnz	r3, 28 <wolfSSL_CertManagerFree+0x28>
            }
        #endif
    #endif /* HAVE_OCSP */

            /* Dispose of CA table and mutex. */
            FreeSignerTable(cm->caTable, CA_TABLE_SIZE, cm->heap);
   e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  10:	210b      	movs	r1, #11
  12:	f7ff fffe 	bl	0 <FreeSignerTable>
            wc_FreeMutex(&cm->caLock);
  16:	f104 0054 	add.w	r0, r4, #84	; 0x54
  1a:	f7ff fffe 	bl	0 <wc_FreeMutex>
        #endif

            /* Dispose of reference count. */
            wolfSSL_RefFree(&cm->ref);
            /* Dispose of certificate manager memory. */
            XFREE(cm, cm->heap, DYNAMIC_TYPE_CERT_MANAGER);
  1e:	4620      	mov	r0, r4
        }
    }
}
  20:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            XFREE(cm, cm->heap, DYNAMIC_TYPE_CERT_MANAGER);
  24:	f7ff bffe 	b.w	0 <free>
}
  28:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSL_CertManagerNew_ex:

00000000 <wolfSSL_CertManagerNew_ex>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4605      	mov	r5, r0
    cm = (WOLFSSL_CERT_MANAGER*)XMALLOC(sizeof(WOLFSSL_CERT_MANAGER), heap,
   4:	2060      	movs	r0, #96	; 0x60
   6:	f7ff fffe 	bl	0 <malloc>
    if (cm == NULL) {
   a:	4604      	mov	r4, r0
   c:	b170      	cbz	r0, 2c <wolfSSL_CertManagerNew_ex+0x2c>
        XMEMSET(cm, 0, sizeof(WOLFSSL_CERT_MANAGER));
   e:	2260      	movs	r2, #96	; 0x60
  10:	2100      	movs	r1, #0
  12:	f7ff fffe 	bl	0 <memset>
        if (wc_InitMutex(&cm->caLock) != 0) {
  16:	f104 0054 	add.w	r0, r4, #84	; 0x54
  1a:	f7ff fffe 	bl	0 <wc_InitMutex>
  1e:	b938      	cbnz	r0, 30 <wolfSSL_CertManagerNew_ex+0x30>
        wolfSSL_RefInit(&cm->ref, &err);
  20:	2301      	movs	r3, #1
  22:	65e3      	str	r3, [r4, #92]	; 0x5c
        cm->minEccKeySz = MIN_ECCKEY_SZ;
  24:	231c      	movs	r3, #28
  26:	f8a4 305a 	strh.w	r3, [r4, #90]	; 0x5a
        cm->heap = heap;
  2a:	62e5      	str	r5, [r4, #44]	; 0x2c
}
  2c:	4620      	mov	r0, r4
  2e:	bd38      	pop	{r3, r4, r5, pc}
        wolfSSL_CertManagerFree(cm);
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <wolfSSL_CertManagerNew_ex>
        cm = NULL;
  36:	2400      	movs	r4, #0
    return cm;
  38:	e7f8      	b.n	2c <wolfSSL_CertManagerNew_ex+0x2c>

Disassembly of section .text.wolfSSL_CertManagerNew:

00000000 <wolfSSL_CertManagerNew>:
    return wolfSSL_CertManagerNew_ex(NULL);
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfSSL_CertManagerNew>

Disassembly of section .text.wolfSSL_CertManager_up_ref:

00000000 <wolfSSL_CertManager_up_ref>:
int wolfSSL_CertManager_up_ref(WOLFSSL_CERT_MANAGER* cm)
{
    int ret = WOLFSSL_SUCCESS;

    /* Validate parameter. */
    if (cm == NULL) {
   0:	b118      	cbz	r0, a <wolfSSL_CertManager_up_ref+0xa>
    }
    if (ret == WOLFSSL_SUCCESS) {
        int err;

        /* Increment reference. */
        wolfSSL_RefInc(&cm->ref, &err);
   2:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
   4:	3301      	adds	r3, #1
   6:	65c3      	str	r3, [r0, #92]	; 0x5c
    int ret = WOLFSSL_SUCCESS;
   8:	2001      	movs	r0, #1
        (void)err;
    #endif
    }

    return ret;
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerUnloadCAs:

00000000 <wolfSSL_CertManagerUnloadCAs>:
 * @return  WOLFSSL_SUCCESS on success.
 * @return  BAD_FUNC_ARG when cm is NULL.
 * @return  BAD_MUTEX_E when locking fails.
 */
int wolfSSL_CertManagerUnloadCAs(WOLFSSL_CERT_MANAGER* cm)
{
   0:	b538      	push	{r3, r4, r5, lr}
    int ret = WOLFSSL_SUCCESS;

    WOLFSSL_ENTER("wolfSSL_CertManagerUnloadCAs");

    /* Validate parameter. */
    if (cm == NULL) {
   2:	4604      	mov	r4, r0
   4:	b178      	cbz	r0, 26 <wolfSSL_CertManagerUnloadCAs+0x26>
        ret = BAD_FUNC_ARG;
    }
    /* Lock CA table. */
    if ((ret == WOLFSSL_SUCCESS) && (wc_LockMutex(&cm->caLock) != 0)) {
   6:	f100 0554 	add.w	r5, r0, #84	; 0x54
   a:	4628      	mov	r0, r5
   c:	f7ff fffe 	bl	0 <wc_LockMutex>
  10:	b960      	cbnz	r0, 2c <wolfSSL_CertManagerUnloadCAs+0x2c>
        ret = BAD_MUTEX_E;
    }
    if (ret == WOLFSSL_SUCCESS) {
        /* Dispose of CA table. */
        FreeSignerTable(cm->caTable, CA_TABLE_SIZE, cm->heap);
  12:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  14:	210b      	movs	r1, #11
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <FreeSignerTable>

        /* Unlock CA table. */
        wc_UnLockMutex(&cm->caLock);
  1c:	4628      	mov	r0, r5
  1e:	f7ff fffe 	bl	0 <wc_UnLockMutex>
  22:	2001      	movs	r0, #1
    }

    return ret;
}
  24:	bd38      	pop	{r3, r4, r5, pc}
        ret = BAD_FUNC_ARG;
  26:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2a:	e7fb      	b.n	24 <wolfSSL_CertManagerUnloadCAs+0x24>
        ret = BAD_MUTEX_E;
  2c:	f06f 0069 	mvn.w	r0, #105	; 0x69
    return ret;
  30:	e7f8      	b.n	24 <wolfSSL_CertManagerUnloadCAs+0x24>

Disassembly of section .text.wolfSSL_CertManagerSetVerify:

00000000 <wolfSSL_CertManagerSetVerify>:
 * @param [in] vc  Verification callback.
 */
void wolfSSL_CertManagerSetVerify(WOLFSSL_CERT_MANAGER* cm, VerifyCallback vc)
{
    WOLFSSL_ENTER("wolfSSL_CertManagerSetVerify");
    if (cm != NULL) {
   0:	b100      	cbz	r0, 4 <wolfSSL_CertManagerSetVerify+0x4>
        cm->verifyCallback = vc;
   2:	6401      	str	r1, [r0, #64]	; 0x40
    }
}
   4:	4770      	bx	lr

Disassembly of section .text.CM_VerifyBuffer_ex:

00000000 <CM_VerifyBuffer_ex>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int CM_VerifyBuffer_ex(WOLFSSL_CERT_MANAGER* cm, const unsigned char* buff,
    long sz, int format, int prev_err)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	b088      	sub	sp, #32
   6:	4607      	mov	r7, r0
    int ret = 0;
    int fatal = 0;
    DerBuffer* der = NULL;
   8:	2400      	movs	r4, #0

    (void)prev_err;

#ifdef WOLFSSL_SMALL_STACK
    /* Allocate memory for decoded certificate. */
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cm->heap,
   a:	f44f 7056 	mov.w	r0, #856	; 0x358
{
   e:	f8dd a040 	ldr.w	sl, [sp, #64]	; 0x40
    DerBuffer* der = NULL;
  12:	9405      	str	r4, [sp, #20]
{
  14:	4688      	mov	r8, r1
  16:	4691      	mov	r9, r2
  18:	461d      	mov	r5, r3
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), cm->heap,
  1a:	f7ff fffe 	bl	0 <malloc>
         DYNAMIC_TYPE_DCERT);
    if (cert == NULL) {
  1e:	4606      	mov	r6, r0
  20:	2800      	cmp	r0, #0
  22:	d05b      	beq.n	dc <CM_VerifyBuffer_ex+0xdc>
    }
    if (ret == 0)
#endif
    {
        /* Reset fields of decoded certificate. */
        XMEMSET(cert, 0, sizeof(DecodedCert));
  24:	f44f 7256 	mov.w	r2, #856	; 0x358
  28:	4621      	mov	r1, r4
  2a:	f7ff fffe 	bl	0 <memset>

        if (format == WOLFSSL_FILETYPE_PEM) {
  2e:	2d01      	cmp	r5, #1
  30:	d110      	bne.n	54 <CM_VerifyBuffer_ex+0x54>
        #ifndef WOLFSSL_PEM_TO_DER
            ret = NOT_COMPILED_IN;
            fatal = 1;
        #else
            /* Convert to DER from PEM. */
            ret = PemToDer(buff, sz, CERT_TYPE, &der, cm->heap, NULL, NULL);
  32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  34:	9300      	str	r3, [sp, #0]
  36:	e9cd 4401 	strd	r4, r4, [sp, #4]
  3a:	4622      	mov	r2, r4
  3c:	ab05      	add	r3, sp, #20
  3e:	4649      	mov	r1, r9
  40:	4640      	mov	r0, r8
  42:	f7ff fffe 	bl	0 <PemToDer>
            if (ret != 0) {
  46:	4604      	mov	r4, r0
  48:	bbb8      	cbnz	r0, ba <CM_VerifyBuffer_ex+0xba>
                fatal = 1;
            }
            else {
                /* Replace buffer pointer and size with DER buffer. */
                buff = der->buffer;
  4a:	9b05      	ldr	r3, [sp, #20]
  4c:	f8d3 8000 	ldr.w	r8, [r3]
                sz = (long)der->length;
  50:	f8d3 9008 	ldr.w	r9, [r3, #8]
        #endif
        }
    }
    if (ret == 0) {
        /* Create a decoded certificate with DER buffer. */
        InitDecodedCert(cert, buff, (word32)sz, cm->heap);
  54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  56:	464a      	mov	r2, r9
  58:	4641      	mov	r1, r8
  5a:	4630      	mov	r0, r6
  5c:	f7ff fffe 	bl	0 <InitDecodedCert>

        /* Parse DER into decoded certificate fields and verify signature
         * against a known CA. */
        ret = ParseCertRelative(cert, CERT_TYPE, VERIFY, cm);
  60:	463b      	mov	r3, r7
  62:	2201      	movs	r2, #1
  64:	2100      	movs	r1, #0
  66:	4630      	mov	r0, r6
  68:	f7ff fffe 	bl	0 <ParseCertRelative>

    (void)fatal;

#ifndef NO_WOLFSSL_CM_VERIFY
    /* Use callback to perform verification too if available. */
    if ((!fatal) && cm->verifyCallback) {
  6c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
        ret = ParseCertRelative(cert, CERT_TYPE, VERIFY, cm);
  6e:	4604      	mov	r4, r0
    if ((!fatal) && cm->verifyCallback) {
  70:	b31b      	cbz	r3, ba <CM_VerifyBuffer_ex+0xba>
    #endif
        buffer certBuf;

    #ifdef WOLFSSL_SMALL_STACK
        /* Allocate memory for object to hold arguments for callback. */
        args = (ProcPeerCertArgs*)XMALLOC(sizeof(ProcPeerCertArgs), cm->heap,
  72:	2024      	movs	r0, #36	; 0x24
  74:	f7ff fffe 	bl	0 <malloc>
            DYNAMIC_TYPE_TMP_BUFFER);
        if (args == NULL) {
  78:	4605      	mov	r5, r0
  7a:	b378      	cbz	r0, dc <CM_VerifyBuffer_ex+0xdc>
            fatal = 1;
        }
        if (!fatal)
    #endif
        {
            XMEMSET(args, 0, sizeof(ProcPeerCertArgs));
  7c:	2224      	movs	r2, #36	; 0x24
  7e:	2100      	movs	r1, #0
  80:	f7ff fffe 	bl	0 <memset>
            /* DER encoding. */
            certBuf.buffer = (byte*)buff;
            certBuf.length = (unsigned int)sz;

            /* One certificate available. */
            args->totalCerts = 1;
  84:	2301      	movs	r3, #1
  86:	612b      	str	r3, [r5, #16]
            args->certs = &certBuf;
  88:	ab06      	add	r3, sp, #24
            args->dCert = cert;
  8a:	e9c5 3600 	strd	r3, r6, [r5]
            args->dCertInit = 1;
  8e:	f895 3020 	ldrb.w	r3, [r5, #32]
  92:	f043 0304 	orr.w	r3, r3, #4
  96:	f885 3020 	strb.w	r3, [r5, #32]
            /* Replace value in ret with an error value passed in. */
            if (prev_err != 0) {
                ret = prev_err;
            }
            /* Use callback to verify certificate. */
            ret = DoVerifyCallback(cm, NULL, ret, args);
  9a:	f1ba 0f00 	cmp.w	sl, #0
  9e:	bf14      	ite	ne
  a0:	4652      	movne	r2, sl
  a2:	4622      	moveq	r2, r4
  a4:	462b      	mov	r3, r5
  a6:	2100      	movs	r1, #0
  a8:	4638      	mov	r0, r7
            certBuf.length = (unsigned int)sz;
  aa:	e9cd 8906 	strd	r8, r9, [sp, #24]
            ret = DoVerifyCallback(cm, NULL, ret, args);
  ae:	f7ff fffe 	bl	0 <DoVerifyCallback>
  b2:	4604      	mov	r4, r0
        }
    #ifdef WOLFSSL_SMALL_STACK
        /* Dispose of allocated callback args. */
        XFREE(args, cm->heap, DYNAMIC_TYPE_TMP_BUFFER);
  b4:	4628      	mov	r0, r5
  b6:	f7ff fffe 	bl	0 <free>
    #endif
    }
#endif

    /* Dispose of allocated memory. */
    FreeDecodedCert(cert);
  ba:	4630      	mov	r0, r6
  bc:	f7ff fffe 	bl	0 <FreeDecodedCert>
    FreeDer(&der);
  c0:	a805      	add	r0, sp, #20
  c2:	f7ff fffe 	bl	0 <FreeDer>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(cert, cm->heap, DYNAMIC_TYPE_DCERT);
  c6:	b116      	cbz	r6, ce <CM_VerifyBuffer_ex+0xce>
  c8:	4630      	mov	r0, r6
  ca:	f7ff fffe 	bl	0 <free>
#endif

    /* Convert the ret value to a return value. */
    return (ret == 0) ? WOLFSSL_SUCCESS : ret;
  ce:	2c00      	cmp	r4, #0
  d0:	bf08      	it	eq
  d2:	2401      	moveq	r4, #1
}
  d4:	4620      	mov	r0, r4
  d6:	b008      	add	sp, #32
  d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            ret = MEMORY_E;
  dc:	f06f 047c 	mvn.w	r4, #124	; 0x7c
        XFREE(args, cm->heap, DYNAMIC_TYPE_TMP_BUFFER);
  e0:	e7eb      	b.n	ba <CM_VerifyBuffer_ex+0xba>

Disassembly of section .text.wolfSSL_CertManagerVerifyBuffer:

00000000 <wolfSSL_CertManagerVerifyBuffer>:
 * @return  NOT_COMPILED_IN when converting from PEM to DER is not a feature of
 *          the wolfSSL build.
 */
int wolfSSL_CertManagerVerifyBuffer(WOLFSSL_CERT_MANAGER* cm,
    const unsigned char* buff, long sz, int format)
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    int ret;

    WOLFSSL_ENTER("wolfSSL_CertManagerVerifyBuffer");

    /* Validate parameters. */
    if ((cm == NULL) || (buff == NULL) || (sz <= 0)) {
   2:	b158      	cbz	r0, 1c <wolfSSL_CertManagerVerifyBuffer+0x1c>
   4:	b151      	cbz	r1, 1c <wolfSSL_CertManagerVerifyBuffer+0x1c>
   6:	2a00      	cmp	r2, #0
   8:	dd08      	ble.n	1c <wolfSSL_CertManagerVerifyBuffer+0x1c>
        ret = BAD_FUNC_ARG;
    }
    else if ((format != WOLFSSL_FILETYPE_ASN1) &&
   a:	1e5c      	subs	r4, r3, #1
   c:	2c01      	cmp	r4, #1
   e:	d808      	bhi.n	22 <wolfSSL_CertManagerVerifyBuffer+0x22>
             (format != WOLFSSL_FILETYPE_PEM)) {
        ret = WOLFSSL_BAD_FILETYPE;
    }
    else {
        /* No previous error. */
        ret = CM_VerifyBuffer_ex(cm, buff, sz, format, 0);
  10:	2400      	movs	r4, #0
  12:	9400      	str	r4, [sp, #0]
  14:	f7ff fffe 	bl	0 <wolfSSL_CertManagerVerifyBuffer>
    }

    return ret;
}
  18:	b002      	add	sp, #8
  1a:	bd70      	pop	{r4, r5, r6, pc}
        ret = BAD_FUNC_ARG;
  1c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  20:	e7fa      	b.n	18 <wolfSSL_CertManagerVerifyBuffer+0x18>
        ret = WOLFSSL_BAD_FILETYPE;
  22:	f06f 0004 	mvn.w	r0, #4
    return ret;
  26:	e7f7      	b.n	18 <wolfSSL_CertManagerVerifyBuffer+0x18>

Disassembly of section .text.wolfSSL_CertManagerEnableCRL:

00000000 <wolfSSL_CertManagerEnableCRL>:

    (void)options;

    /* Validate parameters. */
    if (cm == NULL) {
        ret = BAD_FUNC_ARG;
   0:	2800      	cmp	r0, #0
        }
#endif
    }

    return ret;
}
   2:	bf14      	ite	ne
   4:	f06f 00ad 	mvnne.w	r0, #173	; 0xad
   8:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerDisableCRL:

00000000 <wolfSSL_CertManagerDisableCRL>:
    int ret = WOLFSSL_SUCCESS;

    WOLFSSL_ENTER("wolfSSL_CertManagerDisableCRL");

    /* Validate parameter. */
    if (cm == NULL) {
   0:	b138      	cbz	r0, 12 <wolfSSL_CertManagerDisableCRL+0x12>
        ret = BAD_FUNC_ARG;
    }
    if (ret == WOLFSSL_SUCCESS) {
        /* Disable CRL checking. */
        cm->crlEnabled = 0;
   2:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   6:	f36f 0300 	bfc	r3, #0, #1
   a:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
    int ret = WOLFSSL_SUCCESS;
   e:	2001      	movs	r0, #1
  10:	4770      	bx	lr
        ret = BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }

    return ret;
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerEnableOCSP:

00000000 <wolfSSL_CertManagerEnableOCSP>:
   0:	2800      	cmp	r0, #0
   2:	bf14      	ite	ne
   4:	f06f 00ad 	mvnne.w	r0, #173	; 0xad
   8:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerDisableOCSP:

00000000 <wolfSSL_CertManagerDisableOCSP>:
    int ret = WOLFSSL_SUCCESS;

    WOLFSSL_ENTER("wolfSSL_CertManagerDisableOCSP");

    /* Validate parameter. */
    if (cm == NULL) {
   0:	b138      	cbz	r0, 12 <wolfSSL_CertManagerDisableOCSP+0x12>
        ret = BAD_FUNC_ARG;
    }
    if (ret == WOLFSSL_SUCCESS) {
        /* Disable use of OCSP with certificate validation. */
        cm->ocspEnabled = 0;
   2:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
   6:	f36f 0382 	bfc	r3, #2, #1
   a:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
    int ret = WOLFSSL_SUCCESS;
   e:	2001      	movs	r0, #1
  10:	4770      	bx	lr
        ret = BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }

    return ret;
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerEnableOCSPStapling:

00000000 <wolfSSL_CertManagerEnableOCSPStapling>:

    WOLFSSL_ENTER("wolfSSL_CertManagerEnableOCSPStapling");

    /* Validate parameters. */
    if (cm == NULL) {
        ret = BAD_FUNC_ARG;
   0:	2800      	cmp	r0, #0
    }
#endif /* HAVE_CERTIFICATE_STATUS_REQUEST ||
        * HAVE_CERTIFICATE_STATUS_REQUEST_V2 */

    return ret;
}
   2:	bf14      	ite	ne
   4:	f06f 00ad 	mvnne.w	r0, #173	; 0xad
   8:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerDisableOCSPStapling:

00000000 <wolfSSL_CertManagerDisableOCSPStapling>:
   0:	2800      	cmp	r0, #0
   2:	bf14      	ite	ne
   4:	f06f 00ad 	mvnne.w	r0, #173	; 0xad
   8:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerEnableOCSPMustStaple:

00000000 <wolfSSL_CertManagerEnableOCSPMustStaple>:
   0:	2800      	cmp	r0, #0
   2:	bf14      	ite	ne
   4:	f06f 00ad 	mvnne.w	r0, #173	; 0xad
   8:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CertManagerDisableOCSPMustStaple:

00000000 <wolfSSL_CertManagerDisableOCSPMustStaple>:
   0:	2800      	cmp	r0, #0
   2:	bf14      	ite	ne
   4:	f06f 00ad 	mvnne.w	r0, #173	; 0xad
   8:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wolfssl_get_global_rng:

00000000 <wolfssl_get_global_rng>:
}
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wolfssl_make_global_rng:

00000000 <wolfssl_make_global_rng>:
    ret = wolfssl_get_global_rng();
   0:	f7ff bffe 	b.w	0 <wolfssl_make_global_rng>

Disassembly of section .text.wolfssl_make_rng:

00000000 <wolfssl_make_rng>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    *local = 0;
   2:	2300      	movs	r3, #0
   4:	600b      	str	r3, [r1, #0]
    rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), NULL, DYNAMIC_TYPE_RNG);
   6:	2008      	movs	r0, #8
{
   8:	460d      	mov	r5, r1
    rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), NULL, DYNAMIC_TYPE_RNG);
   a:	f7ff fffe 	bl	0 <malloc>
    if ((rng != NULL) && (wc_InitRng(rng) == 0)) {
   e:	4604      	mov	r4, r0
  10:	b138      	cbz	r0, 22 <wolfssl_make_rng+0x22>
  12:	f7ff fffe 	bl	0 <wc_InitRng>
  16:	b920      	cbnz	r0, 22 <wolfssl_make_rng+0x22>
        *local = 1;
  18:	2301      	movs	r3, #1
  1a:	602b      	str	r3, [r5, #0]
  1c:	4625      	mov	r5, r4
}
  1e:	4628      	mov	r0, r5
  20:	bd38      	pop	{r3, r4, r5, pc}
    ret = wolfssl_get_global_rng();
  22:	f7ff fffe 	bl	0 <wolfssl_make_rng>
    if (ret != rng) {
  26:	4284      	cmp	r4, r0
    ret = wolfssl_get_global_rng();
  28:	4605      	mov	r5, r0
    if (ret != rng) {
  2a:	d0f8      	beq.n	1e <wolfssl_make_rng+0x1e>
        XFREE(rng, NULL, DYNAMIC_TYPE_RNG);
  2c:	2c00      	cmp	r4, #0
  2e:	d0f6      	beq.n	1e <wolfssl_make_rng+0x1e>
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <free>
    return ret;
  36:	e7f2      	b.n	1e <wolfssl_make_rng+0x1e>

Disassembly of section .text.wolfSSL_CTX_up_ref:

00000000 <wolfSSL_CTX_up_ref>:
    wolfSSL_RefInc(&ctx->ref, &ret);
   0:	6883      	ldr	r3, [r0, #8]
   2:	3301      	adds	r3, #1
   4:	6083      	str	r3, [r0, #8]
}
   6:	2001      	movs	r0, #1
   8:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_free:

00000000 <wolfSSL_CTX_free>:
    if (ctx) {
   0:	b108      	cbz	r0, 6 <wolfSSL_CTX_free+0x6>
        FreeSSL_Ctx(ctx);
   2:	f7ff bffe 	b.w	0 <FreeSSL_Ctx>
}
   6:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_new_rng:

00000000 <wolfSSL_CTX_new_rng>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if (ctx == NULL) {
   2:	4605      	mov	r5, r0
   4:	b190      	cbz	r0, 2c <wolfSSL_CTX_new_rng+0x2c>
    rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), ctx->heap, DYNAMIC_TYPE_RNG);
   6:	2008      	movs	r0, #8
   8:	f7ff fffe 	bl	0 <malloc>
    if (rng == NULL) {
   c:	4606      	mov	r6, r0
   e:	b180      	cbz	r0, 32 <wolfSSL_CTX_new_rng+0x32>
    ret = wc_InitRng_ex(rng, ctx->heap, ctx->devId);
  10:	6e2a      	ldr	r2, [r5, #96]	; 0x60
  12:	6b29      	ldr	r1, [r5, #48]	; 0x30
  14:	f7ff fffe 	bl	0 <wc_InitRng_ex>
    if (ret != 0) {
  18:	4604      	mov	r4, r0
  1a:	b120      	cbz	r0, 26 <wolfSSL_CTX_new_rng+0x26>
        XFREE(rng, ctx->heap, DYNAMIC_TYPE_RNG);
  1c:	4630      	mov	r0, r6
  1e:	f7ff fffe 	bl	0 <free>
}
  22:	4620      	mov	r0, r4
  24:	bd70      	pop	{r4, r5, r6, pc}
    ctx->rng = rng;
  26:	606e      	str	r6, [r5, #4]
    return WOLFSSL_SUCCESS;
  28:	2401      	movs	r4, #1
  2a:	e7fa      	b.n	22 <wolfSSL_CTX_new_rng+0x22>
        return BAD_FUNC_ARG;
  2c:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  30:	e7f7      	b.n	22 <wolfSSL_CTX_new_rng+0x22>
        return MEMORY_E;
  32:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  36:	e7f4      	b.n	22 <wolfSSL_CTX_new_rng+0x22>

Disassembly of section .text.wolfSSL_new:

00000000 <wolfSSL_new>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (ctx == NULL)
   2:	4605      	mov	r5, r0
   4:	b910      	cbnz	r0, c <wolfSSL_new+0xc>
            ssl = 0;
   6:	2400      	movs	r4, #0
}
   8:	4620      	mov	r0, r4
   a:	bd38      	pop	{r3, r4, r5, pc}
    ssl = (WOLFSSL*) XMALLOC(sizeof(WOLFSSL), ctx->heap, DYNAMIC_TYPE_SSL);
   c:	f44f 7031 	mov.w	r0, #708	; 0x2c4
  10:	f7ff fffe 	bl	0 <malloc>
    if (ssl)
  14:	4604      	mov	r4, r0
  16:	2800      	cmp	r0, #0
  18:	d0f5      	beq.n	6 <wolfSSL_new+0x6>
        if ( (ret = InitSSL(ssl, ctx, 0)) < 0) {
  1a:	2200      	movs	r2, #0
  1c:	4629      	mov	r1, r5
  1e:	f7ff fffe 	bl	0 <InitSSL>
  22:	2800      	cmp	r0, #0
  24:	daf0      	bge.n	8 <wolfSSL_new+0x8>
            FreeSSL(ssl, ctx->heap);
  26:	6b29      	ldr	r1, [r5, #48]	; 0x30
  28:	4620      	mov	r0, r4
  2a:	f7ff fffe 	bl	0 <FreeSSL>
  2e:	e7ea      	b.n	6 <wolfSSL_new+0x6>

Disassembly of section .text.wolfSSL_free:

00000000 <wolfSSL_free>:
    if (ssl)
   0:	b118      	cbz	r0, a <wolfSSL_free+0xa>
        FreeSSL(ssl, ssl->ctx->heap);
   2:	6803      	ldr	r3, [r0, #0]
   4:	6b19      	ldr	r1, [r3, #48]	; 0x30
   6:	f7ff bffe 	b.w	0 <FreeSSL>
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_is_server:

00000000 <wolfSSL_is_server>:
    if (ssl == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_is_server+0x12>
    return ssl->options.side == WOLFSSL_SERVER_END;
   2:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
   6:	f013 0f30 	tst.w	r3, #48	; 0x30
   a:	bf0c      	ite	eq
   c:	2001      	moveq	r0, #1
   e:	2000      	movne	r0, #0
  10:	4770      	bx	lr
        return BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_set_fd:

00000000 <wolfSSL_set_fd>:
    if (ssl == NULL) {
   0:	b158      	cbz	r0, 1a <wolfSSL_set_fd+0x1a>
    ssl->IOCB_ReadCtx  = &ssl->rfd;
   2:	f500 738c 	add.w	r3, r0, #280	; 0x118
   6:	6103      	str	r3, [r0, #16]
    ssl->IOCB_WriteCtx  = &ssl->wfd;
   8:	f500 738e 	add.w	r3, r0, #284	; 0x11c
    ssl->rfd = fd;      /* not used directly to allow IO callbacks */
   c:	f8c0 1118 	str.w	r1, [r0, #280]	; 0x118
    ssl->wfd = fd;      /* not used directly to allow IO callbacks */
  10:	f8c0 111c 	str.w	r1, [r0, #284]	; 0x11c
    ssl->IOCB_WriteCtx  = &ssl->wfd;
  14:	6143      	str	r3, [r0, #20]
    return ret;
  16:	2001      	movs	r0, #1
  18:	4770      	bx	lr
        return BAD_FUNC_ARG;
  1a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  1e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_set_read_fd:

00000000 <wolfSSL_set_read_fd>:
    if (ssl == NULL) {
   0:	b130      	cbz	r0, 10 <wolfSSL_set_read_fd+0x10>
    ssl->IOCB_ReadCtx  = &ssl->rfd;
   2:	f500 738c 	add.w	r3, r0, #280	; 0x118
    ssl->rfd = fd;      /* not used directly to allow IO callbacks */
   6:	f8c0 1118 	str.w	r1, [r0, #280]	; 0x118
    ssl->IOCB_ReadCtx  = &ssl->rfd;
   a:	6103      	str	r3, [r0, #16]
    return WOLFSSL_SUCCESS;
   c:	2001      	movs	r0, #1
   e:	4770      	bx	lr
        return BAD_FUNC_ARG;
  10:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  14:	4770      	bx	lr

Disassembly of section .text.wolfSSL_set_write_fd:

00000000 <wolfSSL_set_write_fd>:
    if (ssl == NULL) {
   0:	b130      	cbz	r0, 10 <wolfSSL_set_write_fd+0x10>
    ssl->IOCB_WriteCtx  = &ssl->wfd;
   2:	f500 738e 	add.w	r3, r0, #284	; 0x11c
    ssl->wfd = fd;      /* not used directly to allow IO callbacks */
   6:	f8c0 111c 	str.w	r1, [r0, #284]	; 0x11c
    ssl->IOCB_WriteCtx  = &ssl->wfd;
   a:	6143      	str	r3, [r0, #20]
    return WOLFSSL_SUCCESS;
   c:	2001      	movs	r0, #1
   e:	4770      	bx	lr
        return BAD_FUNC_ARG;
  10:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  14:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_cipher_list:

00000000 <wolfSSL_get_cipher_list>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
    const CipherSuiteInfo* ciphers = GetCipherNames();
   4:	f7ff fffe 	bl	0 <GetCipherNames>
   8:	4605      	mov	r5, r0
    if (priority >= GetCipherNamesSize() || priority < 0) {
   a:	f7ff fffe 	bl	0 <GetCipherNamesSize>
   e:	42a0      	cmp	r0, r4
  10:	dd05      	ble.n	1e <wolfSSL_get_cipher_list+0x1e>
  12:	2c00      	cmp	r4, #0
  14:	db03      	blt.n	1e <wolfSSL_get_cipher_list+0x1e>
    return (char*)ciphers[priority].name;
  16:	200c      	movs	r0, #12
  18:	4344      	muls	r4, r0
  1a:	5928      	ldr	r0, [r5, r4]
}
  1c:	bd38      	pop	{r3, r4, r5, pc}
        return 0;
  1e:	2000      	movs	r0, #0
  20:	e7fc      	b.n	1c <wolfSSL_get_cipher_list+0x1c>

Disassembly of section .text.wolfSSL_get_cipher_list_ex:

00000000 <wolfSSL_get_cipher_list_ex>:
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
    if (ssl == NULL) {
   4:	b118      	cbz	r0, e <wolfSSL_get_cipher_list_ex+0xe>
        if ((cipher = wolfSSL_get_cipher_name_internal(ssl)) != NULL) {
   6:	f7ff fffe 	bl	0 <wolfSSL_get_cipher_name_internal>
   a:	b110      	cbz	r0, 12 <wolfSSL_get_cipher_list_ex+0x12>
            if (priority == 0) {
   c:	b104      	cbz	r4, 10 <wolfSSL_get_cipher_list_ex+0x10>
                return NULL;
   e:	2000      	movs	r0, #0
}
  10:	bd10      	pop	{r4, pc}
            return wolfSSL_get_cipher_list(priority);
  12:	4620      	mov	r0, r4
}
  14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            return wolfSSL_get_cipher_list(priority);
  18:	f7ff bffe 	b.w	0 <wolfSSL_get_cipher_list_ex>

Disassembly of section .text.wolfSSL_get_ciphers:

00000000 <wolfSSL_get_ciphers>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4689      	mov	r9, r1
   6:	4604      	mov	r4, r0
    const CipherSuiteInfo* ciphers = GetCipherNames();
   8:	f7ff fffe 	bl	0 <GetCipherNames>
   c:	4607      	mov	r7, r0
    int ciphersSz = GetCipherNamesSize();
   e:	f7ff fffe 	bl	0 <GetCipherNamesSize>
  12:	4606      	mov	r6, r0
    if (buf == NULL || len <= 0)
  14:	b35c      	cbz	r4, 6e <wolfSSL_get_ciphers+0x6e>
  16:	f1b9 0f00 	cmp.w	r9, #0
  1a:	dd28      	ble.n	6e <wolfSSL_get_ciphers+0x6e>
    for (i = 0; i < ciphersSz; i++) {
  1c:	2500      	movs	r5, #0
            if (i < ciphersSz - 1)
  1e:	f100 3aff 	add.w	sl, r0, #4294967295	; 0xffffffff
                *buf++ = ':';
  22:	f04f 0b3a 	mov.w	fp, #58	; 0x3a
    for (i = 0; i < ciphersSz; i++) {
  26:	42b5      	cmp	r5, r6
  28:	db03      	blt.n	32 <wolfSSL_get_ciphers+0x32>
    return WOLFSSL_SUCCESS;
  2a:	2001      	movs	r0, #1
}
  2c:	b003      	add	sp, #12
  2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        int cipherNameSz = (int)XSTRLEN(ciphers[i].name);
  32:	230c      	movs	r3, #12
  34:	fb03 f105 	mul.w	r1, r3, r5
  38:	9101      	str	r1, [sp, #4]
  3a:	5878      	ldr	r0, [r7, r1]
  3c:	f7ff fffe 	bl	0 <strlen>
        if (cipherNameSz + 1 < len) {
  40:	1c43      	adds	r3, r0, #1
  42:	454b      	cmp	r3, r9
        int cipherNameSz = (int)XSTRLEN(ciphers[i].name);
  44:	4680      	mov	r8, r0
        if (cipherNameSz + 1 < len) {
  46:	9300      	str	r3, [sp, #0]
  48:	da14      	bge.n	74 <wolfSSL_get_ciphers+0x74>
            XSTRNCPY(buf, ciphers[i].name, len);
  4a:	9901      	ldr	r1, [sp, #4]
  4c:	464a      	mov	r2, r9
  4e:	5879      	ldr	r1, [r7, r1]
  50:	4620      	mov	r0, r4
            buf += cipherNameSz;
  52:	4444      	add	r4, r8
            XSTRNCPY(buf, ciphers[i].name, len);
  54:	f7ff fffe 	bl	0 <strncpy>
            if (i < ciphersSz - 1)
  58:	45aa      	cmp	sl, r5
  5a:	9b00      	ldr	r3, [sp, #0]
                *buf++ = ':';
  5c:	bfc8      	it	gt
  5e:	f804 bb01 	strbgt.w	fp, [r4], #1
            *buf = 0;
  62:	2100      	movs	r1, #0
  64:	7021      	strb	r1, [r4, #0]
            len -= cipherNameSz + 1;
  66:	eba9 0903 	sub.w	r9, r9, r3
    for (i = 0; i < ciphersSz; i++) {
  6a:	3501      	adds	r5, #1
  6c:	e7db      	b.n	26 <wolfSSL_get_ciphers+0x26>
        return BAD_FUNC_ARG;
  6e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  72:	e7db      	b.n	2c <wolfSSL_get_ciphers+0x2c>
            return BUFFER_E;
  74:	f06f 0083 	mvn.w	r0, #131	; 0x83
  78:	e7d8      	b.n	2c <wolfSSL_get_ciphers+0x2c>

Disassembly of section .text.wolfSSL_get_ciphers_iana:

00000000 <wolfSSL_get_ciphers_iana>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4689      	mov	r9, r1
   6:	4604      	mov	r4, r0
    const CipherSuiteInfo* ciphers = GetCipherNames();
   8:	f7ff fffe 	bl	0 <GetCipherNames>
   c:	4605      	mov	r5, r0
    int ciphersSz = GetCipherNamesSize();
   e:	f7ff fffe 	bl	0 <GetCipherNamesSize>
  12:	4607      	mov	r7, r0
    if (buf == NULL || len <= 0)
  14:	b364      	cbz	r4, 70 <wolfSSL_get_ciphers_iana+0x70>
  16:	f1b9 0f00 	cmp.w	r9, #0
  1a:	dd29      	ble.n	70 <wolfSSL_get_ciphers_iana+0x70>
    for (i = 0; i < ciphersSz; i++) {
  1c:	2600      	movs	r6, #0
            if (i < ciphersSz - 1)
  1e:	1e43      	subs	r3, r0, #1
  20:	9300      	str	r3, [sp, #0]
            *buf = 0;
  22:	46b2      	mov	sl, r6
                *buf++ = ':';
  24:	f04f 0b3a 	mov.w	fp, #58	; 0x3a
    for (i = 0; i < ciphersSz; i++) {
  28:	42be      	cmp	r6, r7
  2a:	db03      	blt.n	34 <wolfSSL_get_ciphers_iana+0x34>
    return WOLFSSL_SUCCESS;
  2c:	2001      	movs	r0, #1
}
  2e:	b003      	add	sp, #12
  30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (ciphers[i].flags & WOLFSSL_CIPHER_SUITE_FLAG_NAMEALIAS)
  34:	7aab      	ldrb	r3, [r5, #10]
  36:	07db      	lsls	r3, r3, #31
  38:	d417      	bmi.n	6a <wolfSSL_get_ciphers_iana+0x6a>
        cipherNameSz = (int)XSTRLEN(ciphers[i].name_iana);
  3a:	6868      	ldr	r0, [r5, #4]
  3c:	f7ff fffe 	bl	0 <strlen>
        if (cipherNameSz + 1 < len) {
  40:	1c43      	adds	r3, r0, #1
  42:	454b      	cmp	r3, r9
        cipherNameSz = (int)XSTRLEN(ciphers[i].name_iana);
  44:	4680      	mov	r8, r0
        if (cipherNameSz + 1 < len) {
  46:	9301      	str	r3, [sp, #4]
  48:	da15      	bge.n	76 <wolfSSL_get_ciphers_iana+0x76>
            XSTRNCPY(buf, ciphers[i].name_iana, len);
  4a:	464a      	mov	r2, r9
  4c:	4620      	mov	r0, r4
  4e:	6869      	ldr	r1, [r5, #4]
  50:	f7ff fffe 	bl	0 <strncpy>
            if (i < ciphersSz - 1)
  54:	9b00      	ldr	r3, [sp, #0]
            buf += cipherNameSz;
  56:	4444      	add	r4, r8
            if (i < ciphersSz - 1)
  58:	42b3      	cmp	r3, r6
                *buf++ = ':';
  5a:	bfc8      	it	gt
  5c:	f804 bb01 	strbgt.w	fp, [r4], #1
            if (i < ciphersSz - 1)
  60:	9b01      	ldr	r3, [sp, #4]
            *buf = 0;
  62:	f884 a000 	strb.w	sl, [r4]
            len -= cipherNameSz + 1;
  66:	eba9 0903 	sub.w	r9, r9, r3
    for (i = 0; i < ciphersSz; i++) {
  6a:	3601      	adds	r6, #1
  6c:	350c      	adds	r5, #12
  6e:	e7db      	b.n	28 <wolfSSL_get_ciphers_iana+0x28>
        return BAD_FUNC_ARG;
  70:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  74:	e7db      	b.n	2e <wolfSSL_get_ciphers_iana+0x2e>
            return BUFFER_E;
  76:	f06f 0083 	mvn.w	r0, #131	; 0x83
  7a:	e7d8      	b.n	2e <wolfSSL_get_ciphers_iana+0x2e>

Disassembly of section .text.wolfSSL_get_shared_ciphers:

00000000 <wolfSSL_get_shared_ciphers>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if (ssl == NULL)
   2:	4603      	mov	r3, r0
{
   4:	460c      	mov	r4, r1
   6:	4616      	mov	r6, r2
    if (ssl == NULL)
   8:	b168      	cbz	r0, 26 <wolfSSL_get_shared_ciphers+0x26>
    cipher = wolfSSL_get_cipher_name_iana(ssl);
   a:	f7ff fffe 	bl	0 <wolfSSL_get_cipher_name_iana>
   e:	4605      	mov	r5, r0
    len = min(len, (int)(XSTRLEN(cipher) + 1));
  10:	f7ff fffe 	bl	0 <strlen>
  14:	1c42      	adds	r2, r0, #1
    XMEMCPY(buf, cipher, len);
  16:	42b2      	cmp	r2, r6
  18:	bf28      	it	cs
  1a:	4632      	movcs	r2, r6
  1c:	4629      	mov	r1, r5
  1e:	4620      	mov	r0, r4
  20:	f7ff fffe 	bl	0 <memcpy>
    return buf;
  24:	4623      	mov	r3, r4
}
  26:	4618      	mov	r0, r3
  28:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.wolfSSL_get_fd:

00000000 <wolfSSL_get_fd>:
    if (ssl) {
   0:	b110      	cbz	r0, 8 <wolfSSL_get_fd+0x8>
        fd = ssl->rfd;
   2:	f8d0 0118 	ldr.w	r0, [r0, #280]	; 0x118
   6:	4770      	bx	lr
    int fd = -1;
   8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_dtls:

00000000 <wolfSSL_dtls>:
    if (ssl)
   0:	b118      	cbz	r0, a <wolfSSL_dtls+0xa>
        dtlsOpt = ssl->options.dtls;
   2:	f890 0272 	ldrb.w	r0, [r0, #626]	; 0x272
   6:	f3c0 0080 	ubfx	r0, r0, #2, #1
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_mutual_auth:

00000000 <wolfSSL_CTX_mutual_auth>:
    if (ctx == NULL)
   0:	b158      	cbz	r0, 1a <wolfSSL_CTX_mutual_auth+0x1a>
    if (ctx->method->side == WOLFSSL_CLIENT_END)
   2:	6803      	ldr	r3, [r0, #0]
   4:	789b      	ldrb	r3, [r3, #2]
   6:	2b01      	cmp	r3, #1
   8:	d00a      	beq.n	20 <wolfSSL_CTX_mutual_auth+0x20>
    ctx->mutualAuth = (byte)req;
   a:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
   e:	f361 0382 	bfi	r3, r1, #2, #1
  12:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
    return 0;
  16:	2000      	movs	r0, #0
  18:	4770      	bx	lr
        return BAD_FUNC_ARG;
  1a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1e:	4770      	bx	lr
        return SIDE_ERROR;
  20:	4800      	ldr	r0, [pc, #0]	; (24 <wolfSSL_CTX_mutual_auth+0x24>)
}
  22:	4770      	bx	lr
  24:	fffffea8 	.word	0xfffffea8

Disassembly of section .text.wolfSSL_mutual_auth:

00000000 <wolfSSL_mutual_auth>:
    if (ssl == NULL)
   0:	b160      	cbz	r0, 1c <wolfSSL_mutual_auth+0x1c>
    if (ssl->options.side == WOLFSSL_SERVER_END)
   2:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
   6:	f013 0f30 	tst.w	r3, #48	; 0x30
   a:	d00a      	beq.n	22 <wolfSSL_mutual_auth+0x22>
    ssl->options.mutualAuth = (word16)req;
   c:	f890 3276 	ldrb.w	r3, [r0, #630]	; 0x276
  10:	f361 0300 	bfi	r3, r1, #0, #1
  14:	f880 3276 	strb.w	r3, [r0, #630]	; 0x276
    return 0;
  18:	2000      	movs	r0, #0
  1a:	4770      	bx	lr
        return BAD_FUNC_ARG;
  1c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  20:	4770      	bx	lr
        return SIDE_ERROR;
  22:	4801      	ldr	r0, [pc, #4]	; (28 <wolfSSL_mutual_auth+0x28>)
}
  24:	4770      	bx	lr
  26:	bf00      	nop
  28:	fffffea8 	.word	0xfffffea8

Disassembly of section .text.wolfSSL_dtls_set_peer:

00000000 <wolfSSL_dtls_set_peer>:
}
   0:	f06f 0002 	mvn.w	r0, #2
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_dtls_get_peer:

00000000 <wolfSSL_dtls_get_peer>:
}
   0:	f06f 0002 	mvn.w	r0, #2
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetRNG:

00000000 <wolfSSL_GetRNG>:
    if (ssl) {
   0:	b100      	cbz	r0, 4 <wolfSSL_GetRNG+0x4>
        return ssl->rng;
   2:	6980      	ldr	r0, [r0, #24]
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetObjectSize:

00000000 <wolfSSL_GetObjectSize>:
}
   0:	f44f 7031 	mov.w	r0, #708	; 0x2c4
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_GetObjectSize:

00000000 <wolfSSL_CTX_GetObjectSize>:
}
   0:	206c      	movs	r0, #108	; 0x6c
   2:	4770      	bx	lr

Disassembly of section .text.wolfSSL_METHOD_GetObjectSize:

00000000 <wolfSSL_METHOD_GetObjectSize>:
}
   0:	2004      	movs	r0, #4
   2:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetMaxOutputSize:

00000000 <wolfSSL_GetMaxOutputSize>:
    if (ssl == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_GetMaxOutputSize+0x12>
    if (ssl->options.handShakeState != HANDSHAKE_DONE) {
   2:	f890 327e 	ldrb.w	r3, [r0, #638]	; 0x27e
   6:	2b10      	cmp	r3, #16
   8:	d103      	bne.n	12 <wolfSSL_GetMaxOutputSize+0x12>
    return wolfSSL_GetMaxFragSize(ssl, OUTPUT_RECORD_SIZE);
   a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   e:	f7ff bffe 	b.w	0 <wolfSSL_GetMaxFragSize>
}
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetOutputSize:

00000000 <wolfSSL_GetOutputSize>:
{
   0:	b530      	push	{r4, r5, lr}
    if (inSz < 0)
   2:	1e0c      	subs	r4, r1, #0
{
   4:	b087      	sub	sp, #28
   6:	4605      	mov	r5, r0
    if (inSz < 0)
   8:	db15      	blt.n	36 <wolfSSL_GetOutputSize+0x36>
    maxSize = wolfSSL_GetMaxOutputSize(ssl);
   a:	f7ff fffe 	bl	0 <wolfSSL_GetOutputSize>
    if (maxSize < 0)
   e:	2800      	cmp	r0, #0
  10:	db0f      	blt.n	32 <wolfSSL_GetOutputSize+0x32>
    if (inSz > maxSize)
  12:	4284      	cmp	r4, r0
  14:	dc12      	bgt.n	3c <wolfSSL_GetOutputSize+0x3c>
    return BuildMessage(ssl, NULL, 0, NULL, inSz, application_data, 0, 1, 0, CUR_ORDER);
  16:	2300      	movs	r3, #0
  18:	2201      	movs	r2, #1
  1a:	e9cd 3202 	strd	r3, r2, [sp, #8]
  1e:	2217      	movs	r2, #23
  20:	e9cd 4200 	strd	r4, r2, [sp]
  24:	e9cd 3304 	strd	r3, r3, [sp, #16]
  28:	461a      	mov	r2, r3
  2a:	4619      	mov	r1, r3
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <BuildMessage>
}
  32:	b007      	add	sp, #28
  34:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  36:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  3a:	e7fa      	b.n	32 <wolfSSL_GetOutputSize+0x32>
        return INPUT_SIZE_E;
  3c:	4800      	ldr	r0, [pc, #0]	; (40 <wolfSSL_GetOutputSize+0x40>)
  3e:	e7f8      	b.n	32 <wolfSSL_GetOutputSize+0x32>
  40:	fffffe64 	.word	0xfffffe64

Disassembly of section .text.wolfSSL_CTX_SetMinEccKey_Sz:

00000000 <wolfSSL_CTX_SetMinEccKey_Sz>:
    if (ctx == NULL || keySz < 0 || keySz % 8 != 0) {
   0:	b150      	cbz	r0, 18 <wolfSSL_CTX_SetMinEccKey_Sz+0x18>
   2:	2900      	cmp	r1, #0
   4:	db08      	blt.n	18 <wolfSSL_CTX_SetMinEccKey_Sz+0x18>
   6:	074b      	lsls	r3, r1, #29
   8:	d106      	bne.n	18 <wolfSSL_CTX_SetMinEccKey_Sz+0x18>
    ctx->cm->minEccKeySz = keySz / 8;
   a:	6a83      	ldr	r3, [r0, #40]	; 0x28
    ctx->minEccKeySz     = keySz / 8;
   c:	10c9      	asrs	r1, r1, #3
   e:	8741      	strh	r1, [r0, #58]	; 0x3a
    ctx->cm->minEccKeySz = keySz / 8;
  10:	f8a3 105a 	strh.w	r1, [r3, #90]	; 0x5a
    return WOLFSSL_SUCCESS;
  14:	2001      	movs	r0, #1
  16:	4770      	bx	lr
        return BAD_FUNC_ARG;
  18:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  1c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetMinEccKey_Sz:

00000000 <wolfSSL_SetMinEccKey_Sz>:
    if (ssl == NULL || keySz < 0 || keySz % 8 != 0) {
   0:	b140      	cbz	r0, 14 <wolfSSL_SetMinEccKey_Sz+0x14>
   2:	2900      	cmp	r1, #0
   4:	db06      	blt.n	14 <wolfSSL_SetMinEccKey_Sz+0x14>
   6:	074b      	lsls	r3, r1, #29
   8:	d104      	bne.n	14 <wolfSSL_SetMinEccKey_Sz+0x14>
    ssl->options.minEccKeySz = keySz / 8;
   a:	10c9      	asrs	r1, r1, #3
   c:	f8a0 1286 	strh.w	r1, [r0, #646]	; 0x286
    return WOLFSSL_SUCCESS;
  10:	2001      	movs	r0, #1
  12:	4770      	bx	lr
        return BAD_FUNC_ARG;
  14:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  18:	4770      	bx	lr

Disassembly of section .text.wolfSSL_write:

00000000 <wolfSSL_write>:
{
   0:	b510      	push	{r4, lr}
    if (ssl == NULL || data == NULL || sz < 0)
   2:	b138      	cbz	r0, 14 <wolfSSL_write+0x14>
   4:	b131      	cbz	r1, 14 <wolfSSL_write+0x14>
   6:	2a00      	cmp	r2, #0
   8:	db04      	blt.n	14 <wolfSSL_write+0x14>
    ret = SendData(ssl, data, sz);
   a:	f7ff fffe 	bl	0 <SendData>
    if (ret < 0)
   e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
}
  12:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  14:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  18:	e7fb      	b.n	12 <wolfSSL_write+0x12>

Disassembly of section .text.wolfSSL_peek:

00000000 <wolfSSL_peek>:
{
   0:	b510      	push	{r4, lr}
    if (ssl == NULL || data == NULL || sz < 0)
   2:	b140      	cbz	r0, 16 <wolfSSL_peek+0x16>
   4:	b139      	cbz	r1, 16 <wolfSSL_peek+0x16>
   6:	2a00      	cmp	r2, #0
   8:	db05      	blt.n	16 <wolfSSL_peek+0x16>
    ret = ReceiveData(ssl, (byte*)data, sz, peek);
   a:	2301      	movs	r3, #1
   c:	f7ff fffe 	bl	0 <ReceiveData>
    if (ret < 0)
  10:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
}
  14:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    return wolfSSL_read_internal(ssl, data, sz, TRUE);
  1a:	e7fb      	b.n	14 <wolfSSL_peek+0x14>

Disassembly of section .text.wolfSSL_read:

00000000 <wolfSSL_read>:
{
   0:	b510      	push	{r4, lr}
    if (ssl == NULL || data == NULL || sz < 0)
   2:	b140      	cbz	r0, 16 <wolfSSL_read+0x16>
   4:	b139      	cbz	r1, 16 <wolfSSL_read+0x16>
   6:	2a00      	cmp	r2, #0
   8:	db05      	blt.n	16 <wolfSSL_read+0x16>
    ret = ReceiveData(ssl, (byte*)data, sz, peek);
   a:	2300      	movs	r3, #0
   c:	f7ff fffe 	bl	0 <ReceiveData>
    if (ret < 0)
  10:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
}
  14:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    return wolfSSL_read_internal(ssl, data, sz, FALSE);
  1a:	e7fb      	b.n	14 <wolfSSL_read+0x14>

Disassembly of section .text.wolfSSL_SetDevId:

00000000 <wolfSSL_SetDevId>:
    if (ssl == NULL)
   0:	b118      	cbz	r0, a <wolfSSL_SetDevId+0xa>
    ssl->devId = devId;
   2:	f8c0 12bc 	str.w	r1, [r0, #700]	; 0x2bc
    return WOLFSSL_SUCCESS;
   6:	2001      	movs	r0, #1
   8:	4770      	bx	lr
        return BAD_FUNC_ARG;
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_SetDevId:

00000000 <wolfSSL_CTX_SetDevId>:
    if (ctx == NULL)
   0:	b110      	cbz	r0, 8 <wolfSSL_CTX_SetDevId+0x8>
    ctx->devId = devId;
   2:	6601      	str	r1, [r0, #96]	; 0x60
    return WOLFSSL_SUCCESS;
   4:	2001      	movs	r0, #1
   6:	4770      	bx	lr
        return BAD_FUNC_ARG;
   8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_GetDevId:

00000000 <wolfSSL_CTX_GetDevId>:
{
   0:	4603      	mov	r3, r0
    if (ssl != NULL)
   2:	b131      	cbz	r1, 12 <wolfSSL_CTX_GetDevId+0x12>
        devId = ssl->devId;
   4:	f8d1 02bc 	ldr.w	r0, [r1, #700]	; 0x2bc
    if (ctx != NULL && devId == INVALID_DEVID)
   8:	b13b      	cbz	r3, 1a <wolfSSL_CTX_GetDevId+0x1a>
   a:	1c82      	adds	r2, r0, #2
   c:	d105      	bne.n	1a <wolfSSL_CTX_GetDevId+0x1a>
        devId = ctx->devId;
   e:	6e18      	ldr	r0, [r3, #96]	; 0x60
    return devId;
  10:	4770      	bx	lr
    if (ctx != NULL && devId == INVALID_DEVID)
  12:	2800      	cmp	r0, #0
  14:	d1fb      	bne.n	e <wolfSSL_CTX_GetDevId+0xe>
    int devId = INVALID_DEVID;
  16:	f06f 0001 	mvn.w	r0, #1
}
  1a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_GetHeap:

00000000 <wolfSSL_CTX_GetHeap>:
    if (ctx != NULL)
   0:	b110      	cbz	r0, 8 <wolfSSL_CTX_GetHeap+0x8>
        heap = ctx->heap;
   2:	6b01      	ldr	r1, [r0, #48]	; 0x30
}
   4:	4608      	mov	r0, r1
   6:	4770      	bx	lr
    else if (ssl != NULL)
   8:	2900      	cmp	r1, #0
   a:	d0fb      	beq.n	4 <wolfSSL_CTX_GetHeap+0x4>
        heap = ssl->heap;
   c:	6a49      	ldr	r1, [r1, #36]	; 0x24
   e:	e7f9      	b.n	4 <wolfSSL_CTX_GetHeap+0x4>

Disassembly of section .text.wolfSSL_UseSupportedCurve:

00000000 <wolfSSL_UseSupportedCurve>:
    if (ssl == NULL || !isValidCurveGroup(name))
   0:	b1a8      	cbz	r0, 2e <wolfSSL_UseSupportedCurve+0x2e>
    switch (name) {
   2:	2929      	cmp	r1, #41	; 0x29
   4:	d004      	beq.n	10 <wolfSSL_UseSupportedCurve+0x10>
   6:	d80e      	bhi.n	26 <wolfSSL_UseSupportedCurve+0x26>
   8:	f1a1 030f 	sub.w	r3, r1, #15
   c:	2b0f      	cmp	r3, #15
   e:	d80e      	bhi.n	2e <wolfSSL_UseSupportedCurve+0x2e>
    ssl->options.userCurves = 1;
  10:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
    return TLSX_UseSupportedCurve(&ssl->extensions, name, ssl->heap);
  14:	6a42      	ldr	r2, [r0, #36]	; 0x24
    ssl->options.userCurves = 1;
  16:	f043 0320 	orr.w	r3, r3, #32
  1a:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
    return TLSX_UseSupportedCurve(&ssl->extensions, name, ssl->heap);
  1e:	f500 7030 	add.w	r0, r0, #704	; 0x2c0
  22:	f7ff bffe 	b.w	0 <TLSX_UseSupportedCurve>
    switch (name) {
  26:	f5a1 7380 	sub.w	r3, r1, #256	; 0x100
  2a:	2b04      	cmp	r3, #4
  2c:	e7ef      	b.n	e <wolfSSL_UseSupportedCurve+0xe>
}
  2e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  32:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_UseSupportedCurve:

00000000 <wolfSSL_CTX_UseSupportedCurve>:
    if (ctx == NULL || !isValidCurveGroup(name))
   0:	b188      	cbz	r0, 26 <wolfSSL_CTX_UseSupportedCurve+0x26>
    switch (name) {
   2:	2929      	cmp	r1, #41	; 0x29
   4:	d004      	beq.n	10 <wolfSSL_CTX_UseSupportedCurve+0x10>
   6:	d80a      	bhi.n	1e <wolfSSL_CTX_UseSupportedCurve+0x1e>
   8:	f1a1 030f 	sub.w	r3, r1, #15
   c:	2b0f      	cmp	r3, #15
   e:	d80a      	bhi.n	26 <wolfSSL_CTX_UseSupportedCurve+0x26>
    ctx->userCurves = 1;
  10:	2301      	movs	r3, #1
    return TLSX_UseSupportedCurve(&ctx->extensions, name, ctx->heap);
  12:	6b02      	ldr	r2, [r0, #48]	; 0x30
    ctx->userCurves = 1;
  14:	f880 3068 	strb.w	r3, [r0, #104]	; 0x68
    return TLSX_UseSupportedCurve(&ctx->extensions, name, ctx->heap);
  18:	3064      	adds	r0, #100	; 0x64
  1a:	f7ff bffe 	b.w	0 <TLSX_UseSupportedCurve>
    switch (name) {
  1e:	f5a1 7380 	sub.w	r3, r1, #256	; 0x100
  22:	2b04      	cmp	r3, #4
  24:	e7f3      	b.n	e <wolfSSL_CTX_UseSupportedCurve+0xe>
}
  26:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_send:

00000000 <wolfSSL_send>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if (ssl == NULL || data == NULL || sz < 0)
   2:	4604      	mov	r4, r0
   4:	b158      	cbz	r0, 1e <wolfSSL_send+0x1e>
   6:	b151      	cbz	r1, 1e <wolfSSL_send+0x1e>
   8:	2a00      	cmp	r2, #0
   a:	db08      	blt.n	1e <wolfSSL_send+0x1e>
    oldFlags = ssl->wflags;
   c:	f8d0 5124 	ldr.w	r5, [r0, #292]	; 0x124
    ssl->wflags = flags;
  10:	f8c0 3124 	str.w	r3, [r0, #292]	; 0x124
    ret = wolfSSL_write(ssl, data, sz);
  14:	f7ff fffe 	bl	0 <wolfSSL_send>
    ssl->wflags = oldFlags;
  18:	f8c4 5124 	str.w	r5, [r4, #292]	; 0x124
}
  1c:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  1e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  22:	e7fb      	b.n	1c <wolfSSL_send+0x1c>

Disassembly of section .text.wolfSSL_recv:

00000000 <wolfSSL_recv>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if (ssl == NULL || data == NULL || sz < 0)
   2:	4604      	mov	r4, r0
   4:	b158      	cbz	r0, 1e <wolfSSL_recv+0x1e>
   6:	b151      	cbz	r1, 1e <wolfSSL_recv+0x1e>
   8:	2a00      	cmp	r2, #0
   a:	db08      	blt.n	1e <wolfSSL_recv+0x1e>
    oldFlags = ssl->rflags;
   c:	f8d0 5120 	ldr.w	r5, [r0, #288]	; 0x120
    ssl->rflags = flags;
  10:	f8c0 3120 	str.w	r3, [r0, #288]	; 0x120
    ret = wolfSSL_read(ssl, data, sz);
  14:	f7ff fffe 	bl	0 <wolfSSL_recv>
    ssl->rflags = oldFlags;
  18:	f8c4 5120 	str.w	r5, [r4, #288]	; 0x120
}
  1c:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  1e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  22:	e7fb      	b.n	1c <wolfSSL_recv+0x1c>

Disassembly of section .text.wolfSSL_shutdown:

00000000 <wolfSSL_shutdown>:
{
   0:	b510      	push	{r4, lr}
    if (ssl == NULL)
   2:	4604      	mov	r4, r0
   4:	2800      	cmp	r0, #0
   6:	d042      	beq.n	8e <wolfSSL_shutdown+0x8e>
    if (ssl->options.quietShutdown) {
   8:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
   c:	0699      	lsls	r1, r3, #26
   e:	d433      	bmi.n	78 <wolfSSL_shutdown+0x78>
        if (!ssl->options.isClosed && !ssl->options.connReset &&
  10:	f890 2272 	ldrb.w	r2, [r0, #626]	; 0x272
  14:	f012 0258 	ands.w	r2, r2, #88	; 0x58
  18:	d130      	bne.n	7c <wolfSSL_shutdown+0x7c>
            ssl->error = SendAlert(ssl, alert_warning, close_notify);
  1a:	2101      	movs	r1, #1
  1c:	f7ff fffe 	bl	0 <SendAlert>
            if (ssl->error < 0) {
  20:	2800      	cmp	r0, #0
            ssl->error = SendAlert(ssl, alert_warning, close_notify);
  22:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
            if (ssl->error < 0) {
  26:	db32      	blt.n	8e <wolfSSL_shutdown+0x8e>
            ssl->options.sentNotify = 1;  /* don't send close_notify twice */
  28:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  2c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
            if (ssl->options.closeNotify) {
  30:	069a      	lsls	r2, r3, #26
            ssl->options.sentNotify = 1;  /* don't send close_notify twice */
  32:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
            if (ssl->options.closeNotify) {
  36:	d401      	bmi.n	3c <wolfSSL_shutdown+0x3c>
                return ret;
  38:	2002      	movs	r0, #2
}
  3a:	bd10      	pop	{r4, pc}
                ssl->options.shutdownDone = 1;
  3c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
                ret = WOLFSSL_SUCCESS;
  44:	2001      	movs	r0, #1
        if (ssl->options.sentNotify && !ssl->options.closeNotify) {
  46:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  4a:	f003 0360 	and.w	r3, r3, #96	; 0x60
  4e:	2b40      	cmp	r3, #64	; 0x40
  50:	d1f3      	bne.n	3a <wolfSSL_shutdown+0x3a>
            ret = ProcessReply(ssl);
  52:	4620      	mov	r0, r4
  54:	f7ff fffe 	bl	0 <ProcessReply>
            if ((ret == ZERO_RETURN) || (ret == SOCKET_ERROR_E)) {
  58:	f46f 73ab 	mvn.w	r3, #342	; 0x156
  5c:	4298      	cmp	r0, r3
  5e:	d002      	beq.n	66 <wolfSSL_shutdown+0x66>
  60:	f510 7f9a 	cmn.w	r0, #308	; 0x134
  64:	d10d      	bne.n	82 <wolfSSL_shutdown+0x82>
                ssl->options.shutdownDone = 1;
  66:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
  6a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  6e:	f884 3272 	strb.w	r3, [r4, #626]	; 0x272
                ssl->error = WOLFSSL_ERROR_NONE;
  72:	2300      	movs	r3, #0
  74:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
        ret = WOLFSSL_SUCCESS;
  78:	2001      	movs	r0, #1
  7a:	e7de      	b.n	3a <wolfSSL_shutdown+0x3a>
    int  ret = WOLFSSL_FATAL_ERROR;
  7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  80:	e7e1      	b.n	46 <wolfSSL_shutdown+0x46>
            } else if (ret == MEMORY_E) {
  82:	307d      	adds	r0, #125	; 0x7d
  84:	d003      	beq.n	8e <wolfSSL_shutdown+0x8e>
            } else if (ssl->error == WOLFSSL_ERROR_NONE) {
  86:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
  8a:	2b00      	cmp	r3, #0
  8c:	d0d4      	beq.n	38 <wolfSSL_shutdown+0x38>
                ret = WOLFSSL_FATAL_ERROR;
  8e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  92:	e7d2      	b.n	3a <wolfSSL_shutdown+0x3a>

Disassembly of section .text.wolfSSL_state:

00000000 <wolfSSL_state>:
    if (ssl == NULL) {
   0:	b110      	cbz	r0, 8 <wolfSSL_state+0x8>
    return ssl->error;
   2:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
   6:	4770      	bx	lr
        return BAD_FUNC_ARG;
   8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_error:

00000000 <wolfSSL_get_error>:
    if (ret > 0)
   0:	2900      	cmp	r1, #0
{
   2:	4603      	mov	r3, r0
    if (ret > 0)
   4:	dc14      	bgt.n	30 <wolfSSL_get_error+0x30>
    if (ssl == NULL)
   6:	b1a8      	cbz	r0, 34 <wolfSSL_get_error+0x34>
    if (ssl->error == WANT_READ)
   8:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
   c:	f46f 72a1 	mvn.w	r2, #322	; 0x142
  10:	4290      	cmp	r0, r2
  12:	d012      	beq.n	3a <wolfSSL_get_error+0x3a>
    else if (ssl->error == WANT_WRITE)
  14:	f46f 72a3 	mvn.w	r2, #326	; 0x146
  18:	4290      	cmp	r0, r2
  1a:	d010      	beq.n	3e <wolfSSL_get_error+0x3e>
    else if (ssl->error == ZERO_RETURN || ssl->options.shutdownDone)
  1c:	f46f 72ab 	mvn.w	r2, #342	; 0x156
  20:	4290      	cmp	r0, r2
  22:	d00e      	beq.n	42 <wolfSSL_get_error+0x42>
  24:	f993 3272 	ldrsb.w	r3, [r3, #626]	; 0x272
        return WOLFSSL_ERROR_ZERO_RETURN;       /* convert to OpenSSL type */
  28:	2b00      	cmp	r3, #0
  2a:	bfb8      	it	lt
  2c:	2006      	movlt	r0, #6
  2e:	4770      	bx	lr
        return WOLFSSL_ERROR_NONE;
  30:	2000      	movs	r0, #0
  32:	4770      	bx	lr
        return BAD_FUNC_ARG;
  34:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  38:	4770      	bx	lr
        return WOLFSSL_ERROR_WANT_READ;         /* convert to OpenSSL type */
  3a:	2002      	movs	r0, #2
  3c:	4770      	bx	lr
        return WOLFSSL_ERROR_WANT_WRITE;        /* convert to OpenSSL type */
  3e:	2003      	movs	r0, #3
  40:	4770      	bx	lr
        return WOLFSSL_ERROR_ZERO_RETURN;       /* convert to OpenSSL type */
  42:	2006      	movs	r0, #6
}
  44:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_alert_history:

00000000 <wolfSSL_get_alert_history>:
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
    if (ssl && h) {
   4:	b120      	cbz	r0, 10 <wolfSSL_get_alert_history+0x10>
   6:	b119      	cbz	r1, 10 <wolfSSL_get_alert_history+0x10>
        *h = ssl->alert_history;
   8:	30fc      	adds	r0, #252	; 0xfc
   a:	c80f      	ldmia	r0, {r0, r1, r2, r3}
   c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
}
  10:	2001      	movs	r0, #1
  12:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSL_want_read:

00000000 <wolfSSL_want_read>:
    if (ssl->error == WANT_READ)
   0:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
}
   4:	f46f 73a1 	mvn.w	r3, #322	; 0x142
   8:	1ac3      	subs	r3, r0, r3
   a:	4258      	negs	r0, r3
   c:	4158      	adcs	r0, r3
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_want_write:

00000000 <wolfSSL_want_write>:
    if (ssl->error == WANT_WRITE)
   0:	f8d0 0114 	ldr.w	r0, [r0, #276]	; 0x114
}
   4:	f46f 73a3 	mvn.w	r3, #326	; 0x146
   8:	1ac3      	subs	r3, r0, r3
   a:	4258      	negs	r0, r3
   c:	4158      	adcs	r0, r3
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_ERR_error_string:

00000000 <wolfSSL_ERR_error_string>:
{
   0:	b510      	push	{r4, lr}
    if (data) {
   2:	460c      	mov	r4, r1
   4:	b119      	cbz	r1, e <wolfSSL_ERR_error_string+0xe>
        SetErrorString((int)errNumber, data);
   6:	f7ff fffe 	bl	0 <SetErrorString>
}
   a:	4620      	mov	r0, r4
   c:	bd10      	pop	{r4, pc}
        SetErrorString((int)errNumber, tmp);
   e:	4902      	ldr	r1, [pc, #8]	; (18 <wolfSSL_ERR_error_string+0x18>)
        return tmp;
  10:	4c01      	ldr	r4, [pc, #4]	; (18 <wolfSSL_ERR_error_string+0x18>)
        SetErrorString((int)errNumber, tmp);
  12:	f7ff fffe 	bl	0 <SetErrorString>
        return tmp;
  16:	e7f8      	b.n	a <wolfSSL_ERR_error_string+0xa>
  18:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_ERR_error_string_n:

00000000 <wolfSSL_ERR_error_string_n>:
{
   0:	b530      	push	{r4, r5, lr}
    if (len >= WOLFSSL_MAX_ERROR_SZ)
   2:	2a4f      	cmp	r2, #79	; 0x4f
{
   4:	b095      	sub	sp, #84	; 0x54
   6:	460d      	mov	r5, r1
   8:	4614      	mov	r4, r2
    if (len >= WOLFSSL_MAX_ERROR_SZ)
   a:	d904      	bls.n	16 <wolfSSL_ERR_error_string_n+0x16>
}
   c:	b015      	add	sp, #84	; 0x54
   e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        wolfSSL_ERR_error_string(e, buf);
  12:	f7ff bffe 	b.w	0 <wolfSSL_ERR_error_string_n>
        if (len) {
  16:	b152      	cbz	r2, 2e <wolfSSL_ERR_error_string_n+0x2e>
        SetErrorString((int)errNumber, data);
  18:	4669      	mov	r1, sp
            XMEMCPY(buf, tmp, len-1);
  1a:	3c01      	subs	r4, #1
        SetErrorString((int)errNumber, data);
  1c:	f7ff fffe 	bl	0 <SetErrorString>
            XMEMCPY(buf, tmp, len-1);
  20:	4622      	mov	r2, r4
  22:	4669      	mov	r1, sp
  24:	4628      	mov	r0, r5
  26:	f7ff fffe 	bl	0 <memcpy>
            buf[len-1] = '\0';
  2a:	2300      	movs	r3, #0
  2c:	552b      	strb	r3, [r5, r4]
}
  2e:	b015      	add	sp, #84	; 0x54
  30:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.wolfSSL_KeepArrays:

00000000 <wolfSSL_KeepArrays>:
    if (ssl)
   0:	b128      	cbz	r0, e <wolfSSL_KeepArrays+0xe>
        ssl->options.saveArrays = 1;
   2:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
   6:	f043 0301 	orr.w	r3, r3, #1
   a:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
}
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_FreeArrays:

00000000 <wolfSSL_FreeArrays>:
    if (ssl && ssl->options.handShakeState == HANDSHAKE_DONE) {
   0:	b160      	cbz	r0, 1c <wolfSSL_FreeArrays+0x1c>
   2:	f890 227e 	ldrb.w	r2, [r0, #638]	; 0x27e
   6:	2a10      	cmp	r2, #16
   8:	d108      	bne.n	1c <wolfSSL_FreeArrays+0x1c>
        ssl->options.saveArrays = 0;
   a:	f890 2275 	ldrb.w	r2, [r0, #629]	; 0x275
   e:	f36f 0200 	bfc	r2, #0, #1
  12:	f880 2275 	strb.w	r2, [r0, #629]	; 0x275
        FreeArrays(ssl, 1);
  16:	2101      	movs	r1, #1
  18:	f7ff bffe 	b.w	0 <FreeArrays>
}
  1c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_KeepHandshakeResources:

00000000 <wolfSSL_KeepHandshakeResources>:
    if (ssl == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_KeepHandshakeResources+0x12>
    ssl->options.keepResources = 1;
   2:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
   6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   a:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
    return 0;
   e:	2000      	movs	r0, #0
  10:	4770      	bx	lr
        return BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_FreeHandshakeResources:

00000000 <wolfSSL_FreeHandshakeResources>:
{
   0:	b508      	push	{r3, lr}
    if (ssl == NULL)
   2:	b118      	cbz	r0, c <wolfSSL_FreeHandshakeResources+0xc>
    FreeHandshakeResources(ssl);
   4:	f7ff fffe 	bl	0 <FreeHandshakeResources>
    return 0;
   8:	2000      	movs	r0, #0
}
   a:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
   c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  10:	e7fb      	b.n	a <wolfSSL_FreeHandshakeResources+0xa>

Disassembly of section .text.wolfSSL_CTX_UseClientSuites:

00000000 <wolfSSL_CTX_UseClientSuites>:
    if (ctx == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_CTX_UseClientSuites+0x12>
    ctx->useClientOrder = 1;
   2:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
   6:	f043 0302 	orr.w	r3, r3, #2
   a:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
    return 0;
   e:	2000      	movs	r0, #0
  10:	4770      	bx	lr
        return BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_UseClientSuites:

00000000 <wolfSSL_UseClientSuites>:
    if (ssl == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_UseClientSuites+0x12>
    ssl->options.useClientOrder = 1;
   2:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
   6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   a:	f880 3275 	strb.w	r3, [r0, #629]	; 0x275
    return 0;
   e:	2000      	movs	r0, #0
  10:	4770      	bx	lr
        return BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetMacSecret:

00000000 <wolfSSL_GetMacSecret>:
    if (ssl == NULL)
   0:	b170      	cbz	r0, 20 <wolfSSL_GetMacSecret+0x20>
    if ( (ssl->options.side == WOLFSSL_CLIENT_END && !verify) ||
   2:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
   6:	f003 0330 	and.w	r3, r3, #48	; 0x30
   a:	2b10      	cmp	r3, #16
   c:	d103      	bne.n	16 <wolfSSL_GetMacSecret+0x16>
   e:	b929      	cbnz	r1, 1c <wolfSSL_GetMacSecret+0x1c>
        return ssl->keys.client_write_MAC_secret;
  10:	f500 70a8 	add.w	r0, r0, #336	; 0x150
  14:	4770      	bx	lr
    if ( (ssl->options.side == WOLFSSL_CLIENT_END && !verify) ||
  16:	b90b      	cbnz	r3, 1c <wolfSSL_GetMacSecret+0x1c>
         (ssl->options.side == WOLFSSL_SERVER_END &&  verify) )
  18:	2900      	cmp	r1, #0
  1a:	d1f9      	bne.n	10 <wolfSSL_GetMacSecret+0x10>
        return ssl->keys.server_write_MAC_secret;
  1c:	f500 70c8 	add.w	r0, r0, #400	; 0x190
}
  20:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetSide:

00000000 <wolfSSL_GetSide>:
    if (ssl)
   0:	b120      	cbz	r0, c <wolfSSL_GetSide+0xc>
        return ssl->options.side;
   2:	f890 0270 	ldrb.w	r0, [r0, #624]	; 0x270
   6:	f3c0 1001 	ubfx	r0, r0, #4, #2
   a:	4770      	bx	lr
    return BAD_FUNC_ARG;
   c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  10:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_GetCertManager:

00000000 <wolfSSL_CTX_GetCertManager>:
    if (ctx)
   0:	b100      	cbz	r0, 4 <wolfSSL_CTX_GetCertManager+0x4>
        cm = ctx->cm;
   2:	6a80      	ldr	r0, [r0, #40]	; 0x28
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_pending:

00000000 <wolfSSL_pending>:
    if (ssl == NULL)
   0:	b108      	cbz	r0, 6 <wolfSSL_pending+0x6>
    return ssl->buffers.clearOutputBuffer.length;
   2:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
}
   6:	4770      	bx	lr

Disassembly of section .text.wolfSSL_has_pending:

00000000 <wolfSSL_has_pending>:
    if (ssl == NULL)
   0:	b120      	cbz	r0, c <wolfSSL_has_pending+0xc>
    return ssl->buffers.clearOutputBuffer.length > 0;
   2:	f8d0 00bc 	ldr.w	r0, [r0, #188]	; 0xbc
   6:	3800      	subs	r0, #0
   8:	bf18      	it	ne
   a:	2001      	movne	r0, #1
}
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_set_group_messages:

00000000 <wolfSSL_CTX_set_group_messages>:
    if (ctx == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_CTX_set_group_messages+0x12>
    ctx->groupMessages = 1;
   2:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
   6:	f043 0304 	orr.w	r3, r3, #4
   a:	f880 3037 	strb.w	r3, [r0, #55]	; 0x37
    return WOLFSSL_SUCCESS;
   e:	2001      	movs	r0, #1
  10:	4770      	bx	lr
       return BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_set_group_messages:

00000000 <wolfSSL_set_group_messages>:
    if (ssl == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_set_group_messages+0x12>
    ssl->options.groupMessages = 1;
   2:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
   6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   a:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
    return WOLFSSL_SUCCESS;
   e:	2001      	movs	r0, #1
  10:	4770      	bx	lr
       return BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_SetMinVersion:

00000000 <wolfSSL_CTX_SetMinVersion>:
    if (ctx == NULL) {
   0:	b128      	cbz	r0, e <wolfSSL_CTX_SetMinVersion+0xe>
    switch (version) {
   2:	2903      	cmp	r1, #3
   4:	d103      	bne.n	e <wolfSSL_CTX_SetMinVersion+0xe>
            *minVersion = TLSv1_2_MINOR;
   6:	f880 1038 	strb.w	r1, [r0, #56]	; 0x38
    return WOLFSSL_SUCCESS;
   a:	2001      	movs	r0, #1
   c:	4770      	bx	lr
        return BAD_FUNC_ARG;
   e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  12:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetMinVersion:

00000000 <wolfSSL_SetMinVersion>:
    if (ssl == NULL) {
   0:	b128      	cbz	r0, e <wolfSSL_SetMinVersion+0xe>
    switch (version) {
   2:	2903      	cmp	r1, #3
   4:	d103      	bne.n	e <wolfSSL_SetMinVersion+0xe>
            *minVersion = TLSv1_2_MINOR;
   6:	f880 1280 	strb.w	r1, [r0, #640]	; 0x280
    return WOLFSSL_SUCCESS;
   a:	2001      	movs	r0, #1
   c:	4770      	bx	lr
        return BAD_FUNC_ARG;
   e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  12:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetVersion:

00000000 <wolfSSL_GetVersion>:
    if (ssl == NULL)
   0:	b150      	cbz	r0, 18 <wolfSSL_GetVersion+0x18>
    if (ssl->version.major == SSLv3_MAJOR) {
   2:	f890 313c 	ldrb.w	r3, [r0, #316]	; 0x13c
   6:	2b03      	cmp	r3, #3
   8:	d109      	bne.n	1e <wolfSSL_GetVersion+0x1e>
        switch (ssl->version.minor) {
   a:	f890 313d 	ldrb.w	r3, [r0, #317]	; 0x13d
   e:	4805      	ldr	r0, [pc, #20]	; (24 <wolfSSL_GetVersion+0x24>)
  10:	2b04      	cmp	r3, #4
  12:	bf98      	it	ls
  14:	4618      	movls	r0, r3
  16:	4770      	bx	lr
        return BAD_FUNC_ARG;
  18:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1c:	4770      	bx	lr
    return VERSION_ERROR;
  1e:	4801      	ldr	r0, [pc, #4]	; (24 <wolfSSL_GetVersion+0x24>)
}
  20:	4770      	bx	lr
  22:	bf00      	nop
  24:	fffffeba 	.word	0xfffffeba

Disassembly of section .text.wolfSSL_SetVersion:

00000000 <wolfSSL_SetVersion>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if (ssl == NULL) {
   2:	4604      	mov	r4, r0
{
   4:	b08c      	sub	sp, #48	; 0x30
    if (ssl == NULL) {
   6:	b3b0      	cbz	r0, 76 <wolfSSL_SetVersion+0x76>
    switch (version) {
   8:	2903      	cmp	r1, #3
   a:	d134      	bne.n	76 <wolfSSL_SetVersion+0x76>
            ssl->version = MakeTLSv1_2();
   c:	f7ff fffe 	bl	0 <MakeTLSv1_2>
  10:	f8a4 013c 	strh.w	r0, [r4, #316]	; 0x13c
    if (AllocateSuites(ssl) != 0)
  14:	4620      	mov	r0, r4
        keySz = ssl->buffers.keySz;
  16:	f8d4 60e8 	ldr.w	r6, [r4, #232]	; 0xe8
    if (AllocateSuites(ssl) != 0)
  1a:	f7ff fffe 	bl	0 <AllocateSuites>
  1e:	4603      	mov	r3, r0
  20:	bb60      	cbnz	r0, 7c <wolfSSL_SetVersion+0x7c>
               ssl->options.haveAnon, TRUE, ssl->options.side);
  22:	f894 1270 	ldrb.w	r1, [r4, #624]	; 0x270
    InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
  26:	2501      	movs	r5, #1
  28:	f3c1 1101 	ubfx	r1, r1, #4, #2
  2c:	910a      	str	r1, [sp, #40]	; 0x28
  2e:	9509      	str	r5, [sp, #36]	; 0x24
               ssl->options.haveAnon, TRUE, ssl->options.side);
  30:	f894 1275 	ldrb.w	r1, [r4, #629]	; 0x275
    InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
  34:	f3c1 1100 	ubfx	r1, r1, #4, #1
  38:	9108      	str	r1, [sp, #32]
               ssl->options.haveFalconSig, ssl->options.haveDilithiumSig,
  3a:	f894 1273 	ldrb.w	r1, [r4, #627]	; 0x273
    InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
  3e:	09ca      	lsrs	r2, r1, #7
  40:	9207      	str	r2, [sp, #28]
  42:	f3c1 1280 	ubfx	r2, r1, #6, #1
  46:	9206      	str	r2, [sp, #24]
  48:	f3c1 1240 	ubfx	r2, r1, #5, #1
  4c:	e9cd 5204 	strd	r5, r2, [sp, #16]
  50:	f3c1 0280 	ubfx	r2, r1, #2, #1
  54:	9203      	str	r2, [sp, #12]
  56:	f3c1 1200 	ubfx	r2, r1, #4, #1
  5a:	f3c1 01c0 	ubfx	r1, r1, #3, #1
  5e:	e9cd 0100 	strd	r0, r1, [sp]
  62:	9202      	str	r2, [sp, #8]
  64:	6860      	ldr	r0, [r4, #4]
  66:	f8d4 113c 	ldr.w	r1, [r4, #316]	; 0x13c
  6a:	4632      	mov	r2, r6
  6c:	f7ff fffe 	bl	0 <InitSuites>
    return WOLFSSL_SUCCESS;
  70:	4628      	mov	r0, r5
}
  72:	b00c      	add	sp, #48	; 0x30
  74:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  76:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  7a:	e7fa      	b.n	72 <wolfSSL_SetVersion+0x72>
        return WOLFSSL_FAILURE;
  7c:	2000      	movs	r0, #0
  7e:	e7f8      	b.n	72 <wolfSSL_SetVersion+0x72>

Disassembly of section .text.AlreadySigner:

00000000 <AlreadySigner>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460d      	mov	r5, r1
    if (cm == NULL || hash == NULL) {
   6:	4606      	mov	r6, r0
   8:	b918      	cbnz	r0, 12 <AlreadySigner+0x12>
        return ret;
   a:	2400      	movs	r4, #0
}
   c:	4620      	mov	r0, r4
   e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (cm == NULL || hash == NULL) {
  12:	2900      	cmp	r1, #0
  14:	d0f9      	beq.n	a <AlreadySigner+0xa>
    row = HashSigner(hash);
  16:	4608      	mov	r0, r1
  18:	f7ff fffe 	bl	0 <AlreadySigner>
    if (wc_LockMutex(&cm->caLock) != 0) {
  1c:	f106 0854 	add.w	r8, r6, #84	; 0x54
    row = HashSigner(hash);
  20:	4607      	mov	r7, r0
    if (wc_LockMutex(&cm->caLock) != 0) {
  22:	4640      	mov	r0, r8
  24:	f7ff fffe 	bl	0 <wc_LockMutex>
  28:	4604      	mov	r4, r0
  2a:	2800      	cmp	r0, #0
  2c:	d1ed      	bne.n	a <AlreadySigner+0xa>
    signers = cm->caTable[row];
  2e:	f856 6027 	ldr.w	r6, [r6, r7, lsl #2]
    while (signers) {
  32:	b91e      	cbnz	r6, 3c <AlreadySigner+0x3c>
    wc_UnLockMutex(&cm->caLock);
  34:	4640      	mov	r0, r8
  36:	f7ff fffe 	bl	0 <wc_UnLockMutex>
    return ret;
  3a:	e7e7      	b.n	c <AlreadySigner+0xc>
        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
  3c:	2214      	movs	r2, #20
  3e:	f106 0134 	add.w	r1, r6, #52	; 0x34
  42:	4628      	mov	r0, r5
  44:	f7ff fffe 	bl	0 <memcmp>
  48:	b108      	cbz	r0, 4e <AlreadySigner+0x4e>
        signers = signers->next;
  4a:	6cb6      	ldr	r6, [r6, #72]	; 0x48
  4c:	e7f1      	b.n	32 <AlreadySigner+0x32>
            ret = 1; /* success */
  4e:	2401      	movs	r4, #1
  50:	e7f0      	b.n	34 <AlreadySigner+0x34>

Disassembly of section .text.GetCA:

00000000 <GetCA>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460d      	mov	r5, r1
    if (cm == NULL || hash == NULL)
   4:	4604      	mov	r4, r0
   6:	b910      	cbnz	r0, e <GetCA+0xe>
        return NULL;
   8:	2400      	movs	r4, #0
}
   a:	4620      	mov	r0, r4
   c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (cm == NULL || hash == NULL)
   e:	2900      	cmp	r1, #0
  10:	d0fa      	beq.n	8 <GetCA+0x8>
    row = HashSigner(hash);
  12:	4608      	mov	r0, r1
  14:	f7ff fffe 	bl	0 <GetCA>
    if (wc_LockMutex(&cm->caLock) != 0)
  18:	f104 0754 	add.w	r7, r4, #84	; 0x54
    row = HashSigner(hash);
  1c:	4606      	mov	r6, r0
    if (wc_LockMutex(&cm->caLock) != 0)
  1e:	4638      	mov	r0, r7
  20:	f7ff fffe 	bl	0 <wc_LockMutex>
  24:	2800      	cmp	r0, #0
  26:	d1ef      	bne.n	8 <GetCA+0x8>
    signers = cm->caTable[row];
  28:	f854 4026 	ldr.w	r4, [r4, r6, lsl #2]
    while (signers) {
  2c:	b91c      	cbnz	r4, 36 <GetCA+0x36>
    wc_UnLockMutex(&cm->caLock);
  2e:	4638      	mov	r0, r7
  30:	f7ff fffe 	bl	0 <wc_UnLockMutex>
    return ret;
  34:	e7e9      	b.n	a <GetCA+0xa>
        if (XMEMCMP(hash, subjectHash, SIGNER_DIGEST_SIZE) == 0) {
  36:	2214      	movs	r2, #20
  38:	f104 0134 	add.w	r1, r4, #52	; 0x34
  3c:	4628      	mov	r0, r5
  3e:	f7ff fffe 	bl	0 <memcmp>
  42:	2800      	cmp	r0, #0
  44:	d0f3      	beq.n	2e <GetCA+0x2e>
        signers = signers->next;
  46:	6ca4      	ldr	r4, [r4, #72]	; 0x48
  48:	e7f0      	b.n	2c <GetCA+0x2c>

Disassembly of section .text.GetCAByName:

00000000 <GetCAByName>:
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	4688      	mov	r8, r1
    if (cm == NULL)
   6:	4604      	mov	r4, r0
   8:	b918      	cbnz	r0, 12 <GetCAByName+0x12>
        return NULL;
   a:	2500      	movs	r5, #0
}
   c:	4628      	mov	r0, r5
   e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (wc_LockMutex(&cm->caLock) != 0)
  12:	f100 0954 	add.w	r9, r0, #84	; 0x54
  16:	4648      	mov	r0, r9
  18:	f7ff fffe 	bl	0 <wc_LockMutex>
  1c:	2800      	cmp	r0, #0
  1e:	d1f4      	bne.n	a <GetCAByName+0xa>
  20:	1f27      	subs	r7, r4, #4
  22:	3428      	adds	r4, #40	; 0x28
        signers = cm->caTable[row];
  24:	f857 6f04 	ldr.w	r6, [r7, #4]!
        while (signers && ret == NULL) {
  28:	2500      	movs	r5, #0
  2a:	b17e      	cbz	r6, 4c <GetCAByName+0x4c>
  2c:	b11d      	cbz	r5, 36 <GetCAByName+0x36>
    wc_UnLockMutex(&cm->caLock);
  2e:	4648      	mov	r0, r9
  30:	f7ff fffe 	bl	0 <wc_UnLockMutex>
    return ret;
  34:	e7ea      	b.n	c <GetCAByName+0xc>
            if (XMEMCMP(hash, signers->subjectNameHash,
  36:	f106 0120 	add.w	r1, r6, #32
  3a:	2214      	movs	r2, #20
  3c:	4640      	mov	r0, r8
  3e:	f7ff fffe 	bl	0 <memcmp>
  42:	2800      	cmp	r0, #0
  44:	bf08      	it	eq
  46:	4635      	moveq	r5, r6
            signers = signers->next;
  48:	6cb6      	ldr	r6, [r6, #72]	; 0x48
  4a:	e7ee      	b.n	2a <GetCAByName+0x2a>
    for (row = 0; row < CA_TABLE_SIZE && ret == NULL; row++) {
  4c:	42bc      	cmp	r4, r7
  4e:	d0ee      	beq.n	2e <GetCAByName+0x2e>
  50:	2d00      	cmp	r5, #0
  52:	d0e7      	beq.n	24 <GetCAByName+0x24>
  54:	e7eb      	b.n	2e <GetCAByName+0x2e>

Disassembly of section .text.AddCA:

00000000 <AddCA>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    DerBuffer*   der = *pDer;
   4:	f8d1 a000 	ldr.w	sl, [r1]
{
   8:	4688      	mov	r8, r1
   a:	4691      	mov	r9, r2
   c:	461d      	mov	r5, r3
    if (cm == NULL) {
   e:	4607      	mov	r7, r0
  10:	b940      	cbnz	r0, 24 <AddCA+0x24>
        FreeDer(pDer);
  12:	4608      	mov	r0, r1
  14:	f7ff fffe 	bl	0 <FreeDer>
        return BAD_FUNC_ARG;
  18:	f06f 06ac 	mvn.w	r6, #172	; 0xac
}
  1c:	4630      	mov	r0, r6
  1e:	b003      	add	sp, #12
  20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL,
  24:	f44f 7056 	mov.w	r0, #856	; 0x358
  28:	f7ff fffe 	bl	0 <malloc>
    if (cert == NULL) {
  2c:	4604      	mov	r4, r0
  2e:	b928      	cbnz	r0, 3c <AddCA+0x3c>
        FreeDer(pDer);
  30:	4640      	mov	r0, r8
  32:	f7ff fffe 	bl	0 <FreeDer>
        return MEMORY_E;
  36:	f06f 067c 	mvn.w	r6, #124	; 0x7c
  3a:	e7ef      	b.n	1c <AddCA+0x1c>
    InitDecodedCert(cert, der->buffer, der->length, cm->heap);
  3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  3e:	f8da 2008 	ldr.w	r2, [sl, #8]
  42:	f8da 1000 	ldr.w	r1, [sl]
  46:	f7ff fffe 	bl	0 <InitDecodedCert>
    ret = ParseCert(cert, CA_TYPE, verify, cm);
  4a:	463b      	mov	r3, r7
  4c:	462a      	mov	r2, r5
  4e:	2105      	movs	r1, #5
  50:	4620      	mov	r0, r4
  52:	f7ff fffe 	bl	0 <ParseCert>
  56:	4606      	mov	r6, r0
    if (verify) {
  58:	b175      	cbz	r5, 78 <AddCA+0x78>
        switch (cert->keyOID) {
  5a:	69e3      	ldr	r3, [r4, #28]
  5c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  60:	d021      	beq.n	a6 <AddCA+0xa6>
  62:	f240 2206 	movw	r2, #518	; 0x206
  66:	4293      	cmp	r3, r2
  68:	d106      	bne.n	78 <AddCA+0x78>
                if (cm->minEccKeySz < 0 ||
  6a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
  6e:	2b00      	cmp	r3, #0
  70:	db1d      	blt.n	ae <AddCA+0xae>
  72:	6862      	ldr	r2, [r4, #4]
  74:	429a      	cmp	r2, r3
  76:	d31a      	bcc.n	ae <AddCA+0xae>
    if (ret == 0 && cert->isCA == 0 && type != WOLFSSL_USER_CA) {
  78:	bb76      	cbnz	r6, d8 <AddCA+0xd8>
  7a:	f894 3354 	ldrb.w	r3, [r4, #852]	; 0x354
  7e:	06d8      	lsls	r0, r3, #27
  80:	d418      	bmi.n	b4 <AddCA+0xb4>
  82:	f1b9 0f01 	cmp.w	r9, #1
  86:	d120      	bne.n	ca <AddCA+0xca>
    subjectHash = cert->extSubjKeyId;
  88:	f504 7b33 	add.w	fp, r4, #716	; 0x2cc
    else if (ret == 0 && AlreadySigner(cm, subjectHash)) {
  8c:	4659      	mov	r1, fp
  8e:	4638      	mov	r0, r7
  90:	f7ff fffe 	bl	0 <AddCA>
  94:	bb00      	cbnz	r0, d8 <AddCA+0xd8>
        signer = MakeSigner(cm->heap);
  96:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  98:	f7ff fffe 	bl	0 <MakeSigner>
        if (!signer)
  9c:	4605      	mov	r5, r0
  9e:	b9e8      	cbnz	r0, dc <AddCA+0xdc>
            ret = MEMORY_ERROR;
  a0:	f46f 7697 	mvn.w	r6, #302	; 0x12e
  a4:	e074      	b.n	190 <AddCA+0x190>
                if (cm->minEccKeySz < 0 ||
  a6:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
  aa:	2b20      	cmp	r3, #32
  ac:	d9e4      	bls.n	78 <AddCA+0x78>
                    ret = ECC_KEY_SIZE_E;
  ae:	4e42      	ldr	r6, [pc, #264]	; (1b8 <AddCA+0x1b8>)
    Signer*     signer = NULL;
  b0:	2500      	movs	r5, #0
  b2:	e06d      	b.n	190 <AddCA+0x190>
    else if (ret == 0 && cert->isCA == 1 && type != WOLFSSL_USER_CA &&
  b4:	f1b9 0f01 	cmp.w	r9, #1
  b8:	d0e6      	beq.n	88 <AddCA+0x88>
        !cert->selfSigned && (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) == 0) {
  ba:	f894 3356 	ldrb.w	r3, [r4, #854]	; 0x356
    else if (ret == 0 && cert->isCA == 1 && type != WOLFSSL_USER_CA &&
  be:	0799      	lsls	r1, r3, #30
  c0:	d4e2      	bmi.n	88 <AddCA+0x88>
        !cert->selfSigned && (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) == 0) {
  c2:	f8b4 32f8 	ldrh.w	r3, [r4, #760]	; 0x2f8
  c6:	075a      	lsls	r2, r3, #29
  c8:	d4de      	bmi.n	88 <AddCA+0x88>
    Signer*     signer = NULL;
  ca:	4635      	mov	r5, r6
        ret = NOT_CA_ERROR;
  cc:	f46f 76b2 	mvn.w	r6, #356	; 0x164
  d0:	e05e      	b.n	190 <AddCA+0x190>
            ret = BAD_MUTEX_E;
  d2:	f06f 0669 	mvn.w	r6, #105	; 0x69
  d6:	e05b      	b.n	190 <AddCA+0x190>
  d8:	2500      	movs	r5, #0
  da:	e059      	b.n	190 <AddCA+0x190>
        signer->keyOID         = cert->keyOID;
  dc:	69e3      	ldr	r3, [r4, #28]
  de:	606b      	str	r3, [r5, #4]
        if (cert->pubKeyStored) {
  e0:	68a3      	ldr	r3, [r4, #8]
  e2:	b11b      	cbz	r3, ec <AddCA+0xec>
            signer->publicKey      = cert->publicKey;
  e4:	6823      	ldr	r3, [r4, #0]
  e6:	60eb      	str	r3, [r5, #12]
            signer->pubKeySize     = cert->pubKeySize;
  e8:	6863      	ldr	r3, [r4, #4]
  ea:	602b      	str	r3, [r5, #0]
        if (cert->subjectCNStored) {
  ec:	f894 3354 	ldrb.w	r3, [r4, #852]	; 0x354
        signer->selfSigned     = cert->selfSigned;
  f0:	7aea      	ldrb	r2, [r5, #11]
        if (cert->subjectCNStored) {
  f2:	07db      	lsls	r3, r3, #31
            signer->nameLen        = cert->subjectCNLen;
  f4:	bf41      	itttt	mi
  f6:	6ea3      	ldrmi	r3, [r4, #104]	; 0x68
  f8:	612b      	strmi	r3, [r5, #16]
            signer->name           = cert->subjectCN;
  fa:	6e63      	ldrmi	r3, [r4, #100]	; 0x64
  fc:	616b      	strmi	r3, [r5, #20]
        signer->maxPathLen     = cert->maxPathLen;
  fe:	f894 32f5 	ldrb.w	r3, [r4, #757]	; 0x2f5
 102:	72ab      	strb	r3, [r5, #10]
        signer->selfSigned     = cert->selfSigned;
 104:	f894 3356 	ldrb.w	r3, [r4, #854]	; 0x356
 108:	f3c3 0340 	ubfx	r3, r3, #1, #1
 10c:	f363 0200 	bfi	r2, r3, #0, #1
 110:	72ea      	strb	r2, [r5, #11]
        signer->permittedNames = cert->permittedNames;
 112:	6b23      	ldr	r3, [r4, #48]	; 0x30
 114:	61ab      	str	r3, [r5, #24]
        XMEMCPY(signer->subjectKeyIdHash, cert->extSubjKeyId,
 116:	f105 0634 	add.w	r6, r5, #52	; 0x34
        signer->excludedNames  = cert->excludedNames;
 11a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 11c:	61eb      	str	r3, [r5, #28]
        XMEMCPY(signer->subjectKeyIdHash, cert->extSubjKeyId,
 11e:	4659      	mov	r1, fp
 120:	2214      	movs	r2, #20
 122:	4630      	mov	r0, r6
 124:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(signer->subjectNameHash, cert->subjectHash,
 128:	2214      	movs	r2, #20
 12a:	f104 0138 	add.w	r1, r4, #56	; 0x38
 12e:	f105 0020 	add.w	r0, r5, #32
 132:	f7ff fffe 	bl	0 <memcpy>
        signer->keyUsage = cert->extKeyUsageSet ? cert->extKeyUsage
 136:	f994 3354 	ldrsb.w	r3, [r4, #852]	; 0x354
 13a:	2b00      	cmp	r3, #0
 13c:	bfb4      	ite	lt
 13e:	f8b4 32f8 	ldrhlt.w	r3, [r4, #760]	; 0x2f8
 142:	f64f 73ff 	movwge	r3, #65535	; 0xffff
 146:	812b      	strh	r3, [r5, #8]
        signer->next    = NULL; /* If Key Usage not set, all uses valid. */
 148:	2300      	movs	r3, #0
 14a:	64ab      	str	r3, [r5, #72]	; 0x48
        row = HashSigner(signer->subjectKeyIdHash);
 14c:	4630      	mov	r0, r6
        cert->excludedNames = NULL;
 14e:	e9c4 330c 	strd	r3, r3, [r4, #48]	; 0x30
        cert->publicKey = 0;    /* in case lock fails don't free here.   */
 152:	6023      	str	r3, [r4, #0]
        cert->subjectCN = 0;
 154:	6663      	str	r3, [r4, #100]	; 0x64
        row = HashSigner(signer->subjectKeyIdHash);
 156:	f7ff fffe 	bl	0 <AddCA>
        if (wc_LockMutex(&cm->caLock) == 0) {
 15a:	f107 0354 	add.w	r3, r7, #84	; 0x54
        row = HashSigner(signer->subjectKeyIdHash);
 15e:	4683      	mov	fp, r0
        if (wc_LockMutex(&cm->caLock) == 0) {
 160:	4618      	mov	r0, r3
 162:	9301      	str	r3, [sp, #4]
 164:	f7ff fffe 	bl	0 <wc_LockMutex>
 168:	9b01      	ldr	r3, [sp, #4]
 16a:	4606      	mov	r6, r0
 16c:	2800      	cmp	r0, #0
 16e:	d1b0      	bne.n	d2 <AddCA+0xd2>
            signer->next = cm->caTable[row];
 170:	f857 202b 	ldr.w	r2, [r7, fp, lsl #2]
 174:	64aa      	str	r2, [r5, #72]	; 0x48
            wc_UnLockMutex(&cm->caLock);
 176:	4618      	mov	r0, r3
            cm->caTable[row] = signer;   /* takes ownership */
 178:	f847 502b 	str.w	r5, [r7, fp, lsl #2]
            wc_UnLockMutex(&cm->caLock);
 17c:	f7ff fffe 	bl	0 <wc_UnLockMutex>
            if (cm->caCacheCallback)
 180:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 182:	b12b      	cbz	r3, 190 <AddCA+0x190>
                cm->caCacheCallback(der->buffer, (int)der->length, type);
 184:	f8da 1008 	ldr.w	r1, [sl, #8]
 188:	f8da 0000 	ldr.w	r0, [sl]
 18c:	464a      	mov	r2, r9
 18e:	4798      	blx	r3
    FreeDecodedCert(cert);
 190:	4620      	mov	r0, r4
 192:	f7ff fffe 	bl	0 <FreeDecodedCert>
    if (ret != 0 && signer != NULL)
 196:	b126      	cbz	r6, 1a2 <AddCA+0x1a2>
 198:	b11d      	cbz	r5, 1a2 <AddCA+0x1a2>
        FreeSigner(signer, cm->heap);
 19a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 19c:	4628      	mov	r0, r5
 19e:	f7ff fffe 	bl	0 <FreeSigner>
    XFREE(cert, NULL, DYNAMIC_TYPE_DCERT);
 1a2:	4620      	mov	r0, r4
 1a4:	f7ff fffe 	bl	0 <free>
    FreeDer(pDer);
 1a8:	4640      	mov	r0, r8
 1aa:	f7ff fffe 	bl	0 <FreeDer>
    return ret == 0 ? WOLFSSL_SUCCESS : ret;
 1ae:	2e00      	cmp	r6, #0
 1b0:	bf08      	it	eq
 1b2:	2601      	moveq	r6, #1
 1b4:	e732      	b.n	1c <AddCA+0x1c>
 1b6:	bf00      	nop
 1b8:	fffffe66 	.word	0xfffffe66

Disassembly of section .text.ProcessBuffer:

00000000 <ProcessBuffer>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b09f      	sub	sp, #124	; 0x7c
   6:	e9dd 7528 	ldrd	r7, r5, [sp, #160]	; 0xa0
   a:	910e      	str	r1, [sp, #56]	; 0x38
    DerBuffer*    der = NULL;
   c:	2400      	movs	r4, #0
    void*         heap = wolfSSL_CTX_GetHeap(ctx, ssl);
   e:	4629      	mov	r1, r5
{
  10:	9312      	str	r3, [sp, #72]	; 0x48
  12:	4606      	mov	r6, r0
    int           keyFormat = 0;
  14:	e9cd 4417 	strd	r4, r4, [sp, #92]	; 0x5c
    void*         heap = wolfSSL_CTX_GetHeap(ctx, ssl);
  18:	f7ff fffe 	bl	0 <ProcessBuffer>
    int           devId = wolfSSL_CTX_GetDevId(ctx, ssl);
  1c:	4629      	mov	r1, r5
    void*         heap = wolfSSL_CTX_GetHeap(ctx, ssl);
  1e:	900f      	str	r0, [sp, #60]	; 0x3c
    int           devId = wolfSSL_CTX_GetDevId(ctx, ssl);
  20:	4630      	mov	r0, r6
{
  22:	4693      	mov	fp, r2
    int           devId = wolfSSL_CTX_GetDevId(ctx, ssl);
  24:	f7ff fffe 	bl	0 <ProcessBuffer>
    if (used)
  28:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
    int           devId = wolfSSL_CTX_GetDevId(ctx, ssl);
  2a:	9013      	str	r0, [sp, #76]	; 0x4c
    word32        algId = 0;
  2c:	e9cd 4419 	strd	r4, r4, [sp, #100]	; 0x64
    if (used)
  30:	b10b      	cbz	r3, 36 <ProcessBuffer+0x36>
        *used = sz;     /* used bytes default to sz, PEM chain may shorten*/
  32:	f8c3 b000 	str.w	fp, [r3]
    if (format != WOLFSSL_FILETYPE_ASN1 && format != WOLFSSL_FILETYPE_PEM)
  36:	9b12      	ldr	r3, [sp, #72]	; 0x48
  38:	3b01      	subs	r3, #1
  3a:	2b01      	cmp	r3, #1
  3c:	f200 8425 	bhi.w	88a <ProcessBuffer+0x88a>
    if (ctx == NULL && ssl == NULL)
  40:	b916      	cbnz	r6, 48 <ProcessBuffer+0x48>
  42:	2d00      	cmp	r5, #0
  44:	f000 8184 	beq.w	350 <ProcessBuffer+0x350>
    if (type == CHAIN_CERT_TYPE)
  48:	2f25      	cmp	r7, #37	; 0x25
  4a:	f000 8181 	beq.w	350 <ProcessBuffer+0x350>
    info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), heap,
  4e:	2004      	movs	r0, #4
  50:	f7ff fffe 	bl	0 <malloc>
    if (info == NULL)
  54:	4680      	mov	r8, r0
  56:	b928      	cbnz	r0, 64 <ProcessBuffer+0x64>
        return MEMORY_E;
  58:	f06f 047c 	mvn.w	r4, #124	; 0x7c
}
  5c:	4620      	mov	r0, r4
  5e:	b01f      	add	sp, #124	; 0x7c
  60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    XMEMSET(info, 0, sizeof(EncryptedInfo));
  64:	2204      	movs	r2, #4
  66:	2100      	movs	r1, #0
  68:	f7ff fffe 	bl	0 <memset>
    if (format == WOLFSSL_FILETYPE_PEM) {
  6c:	9b12      	ldr	r3, [sp, #72]	; 0x48
  6e:	2b01      	cmp	r3, #1
  70:	d133      	bne.n	da <ProcessBuffer+0xda>
        ret = PemToDer(buff, sz, type, &der, heap, info, &keyFormat);
  72:	ab18      	add	r3, sp, #96	; 0x60
  74:	e9cd 8301 	strd	r8, r3, [sp, #4]
  78:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  7a:	9300      	str	r3, [sp, #0]
  7c:	980e      	ldr	r0, [sp, #56]	; 0x38
  7e:	ab17      	add	r3, sp, #92	; 0x5c
  80:	463a      	mov	r2, r7
  82:	4659      	mov	r1, fp
  84:	f7ff fffe 	bl	0 <PemToDer>
  88:	4604      	mov	r4, r0
    if (used) {
  8a:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
  8c:	b11b      	cbz	r3, 96 <ProcessBuffer+0x96>
        *used = info->consumed;
  8e:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
  90:	f8d8 3000 	ldr.w	r3, [r8]
  94:	6013      	str	r3, [r2, #0]
    if (ret >= 0) {
  96:	2c00      	cmp	r4, #0
  98:	f2c0 8122 	blt.w	2e0 <ProcessBuffer+0x2e0>
        if (userChain) {
  9c:	9b2b      	ldr	r3, [sp, #172]	; 0xac
  9e:	b12b      	cbz	r3, ac <ProcessBuffer+0xac>
            (info->consumed < sz)) {
  a0:	f8d8 3000 	ldr.w	r3, [r8]
  a4:	930d      	str	r3, [sp, #52]	; 0x34
    if ((type == CERT_TYPE || type == CHAIN_CERT_TYPE || type == CA_TYPE) &&
  a6:	459b      	cmp	fp, r3
  a8:	dc57      	bgt.n	15a <ProcessBuffer+0x15a>
    int ret = 0;
  aa:	2400      	movs	r4, #0
    if (ret < 0 || type != PRIVATEKEY_TYPE) {
  ac:	2f01      	cmp	r7, #1
  ae:	f040 8117 	bne.w	2e0 <ProcessBuffer+0x2e0>
        if (ssl != NULL) {
  b2:	2d00      	cmp	r5, #0
  b4:	f040 81a5 	bne.w	402 <ProcessBuffer+0x402>
        else if (ctx != NULL) {
  b8:	2e00      	cmp	r6, #0
  ba:	f000 81b5 	beq.w	428 <ProcessBuffer+0x428>
            if (ctx->privateKey != NULL && ctx->privateKey->buffer != NULL) {
  be:	69b3      	ldr	r3, [r6, #24]
  c0:	b123      	cbz	r3, cc <ProcessBuffer+0xcc>
  c2:	6818      	ldr	r0, [r3, #0]
  c4:	b110      	cbz	r0, cc <ProcessBuffer+0xcc>
                ForceZero(ctx->privateKey->buffer, ctx->privateKey->length);
  c6:	6899      	ldr	r1, [r3, #8]
  c8:	f7ff fffe 	bl	0 <ProcessBuffer>
            FreeDer(&ctx->privateKey);
  cc:	f106 0018 	add.w	r0, r6, #24
  d0:	f7ff fffe 	bl	0 <FreeDer>
            ctx->privateKey = der;
  d4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  d6:	61b3      	str	r3, [r6, #24]
    if (done == 1) {
  d8:	e1a6      	b.n	428 <ProcessBuffer+0x428>
        word32 inOutIdx = 0;
  da:	2400      	movs	r4, #0
        if (GetSequence(buff, &inOutIdx, &length, (word32)sz) >= 0) {
  dc:	980e      	ldr	r0, [sp, #56]	; 0x38
        int length = (int)sz;
  de:	f8cd b070 	str.w	fp, [sp, #112]	; 0x70
        if (GetSequence(buff, &inOutIdx, &length, (word32)sz) >= 0) {
  e2:	465b      	mov	r3, fp
  e4:	aa1c      	add	r2, sp, #112	; 0x70
  e6:	a91d      	add	r1, sp, #116	; 0x74
        word32 inOutIdx = 0;
  e8:	941d      	str	r4, [sp, #116]	; 0x74
        if (GetSequence(buff, &inOutIdx, &length, (word32)sz) >= 0) {
  ea:	f7ff fffe 	bl	0 <GetSequence>
  ee:	42a0      	cmp	r0, r4
  f0:	db04      	blt.n	fc <ProcessBuffer+0xfc>
            length += inOutIdx; /* include leading oct string */
  f2:	e9dd 321c 	ldrd	r3, r2, [sp, #112]	; 0x70
  f6:	4413      	add	r3, r2
  f8:	931c      	str	r3, [sp, #112]	; 0x70
  fa:	e003      	b.n	104 <ProcessBuffer+0x104>
        else if (type == PRIVATEKEY_TYPE &&
  fc:	2f01      	cmp	r7, #1
  fe:	d023      	beq.n	148 <ProcessBuffer+0x148>
            ret = ASN_PARSE_E;
 100:	f06f 048b 	mvn.w	r4, #139	; 0x8b
        info->consumed = length;
 104:	991c      	ldr	r1, [sp, #112]	; 0x70
 106:	f8c8 1000 	str.w	r1, [r8]
        if (ret == 0) {
 10a:	2c00      	cmp	r4, #0
 10c:	d1bd      	bne.n	8a <ProcessBuffer+0x8a>
            ret = AllocDer(&der, (word32)length, type, heap);
 10e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 110:	463a      	mov	r2, r7
 112:	a817      	add	r0, sp, #92	; 0x5c
 114:	f7ff fffe 	bl	0 <AllocDer>
            if (ret == 0) {
 118:	4604      	mov	r4, r0
 11a:	2800      	cmp	r0, #0
 11c:	d1b5      	bne.n	8a <ProcessBuffer+0x8a>
                XMEMCPY(der->buffer, buff, length);
 11e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 120:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 122:	990e      	ldr	r1, [sp, #56]	; 0x38
 124:	6818      	ldr	r0, [r3, #0]
 126:	f7ff fffe 	bl	0 <memcpy>
            if (ret == 0 && type == PRIVATEKEY_TYPE) {
 12a:	2f01      	cmp	r7, #1
 12c:	d1ad      	bne.n	8a <ProcessBuffer+0x8a>
                if ((ret = ToTraditional_ex(der->buffer, der->length,
 12e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 130:	aa1a      	add	r2, sp, #104	; 0x68
 132:	6899      	ldr	r1, [r3, #8]
 134:	6818      	ldr	r0, [r3, #0]
 136:	f7ff fffe 	bl	0 <ToTraditional_ex>
 13a:	2800      	cmp	r0, #0
                    der->length = ret;
 13c:	bfc1      	itttt	gt
 13e:	9b17      	ldrgt	r3, [sp, #92]	; 0x5c
 140:	6098      	strgt	r0, [r3, #8]
                    keyFormat = algId;
 142:	9b1a      	ldrgt	r3, [sp, #104]	; 0x68
 144:	9318      	strgt	r3, [sp, #96]	; 0x60
 146:	e7a0      	b.n	8a <ProcessBuffer+0x8a>
                    GetOctetString(buff, &inOutIdx, &length, (word32)sz) >= 0) {
 148:	980e      	ldr	r0, [sp, #56]	; 0x38
 14a:	465b      	mov	r3, fp
 14c:	aa1c      	add	r2, sp, #112	; 0x70
 14e:	a91d      	add	r1, sp, #116	; 0x74
 150:	f7ff fffe 	bl	0 <GetOctetString>
        else if (type == PRIVATEKEY_TYPE &&
 154:	2800      	cmp	r0, #0
 156:	dacc      	bge.n	f2 <ProcessBuffer+0xf2>
 158:	e7d2      	b.n	100 <ProcessBuffer+0x100>
    void* heap = wolfSSL_CTX_GetHeap(ctx, ssl);
 15a:	4629      	mov	r1, r5
 15c:	4630      	mov	r0, r6
 15e:	f7ff fffe 	bl	0 <ProcessBuffer>
        bufferSz = (word32)(sz - consumed) + (CERT_HEADER_SZ * MAX_CHAIN_DEPTH);
 162:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    void* heap = wolfSSL_CTX_GetHeap(ctx, ssl);
 164:	9010      	str	r0, [sp, #64]	; 0x40
        bufferSz = (word32)(sz - consumed) + (CERT_HEADER_SZ * MAX_CHAIN_DEPTH);
 166:	ebab 0303 	sub.w	r3, fp, r3
 16a:	331b      	adds	r3, #27
            chainBuffer = (byte*)XMALLOC(bufferSz, heap, DYNAMIC_TYPE_FILE);
 16c:	4618      	mov	r0, r3
        bufferSz = (word32)(sz - consumed) + (CERT_HEADER_SZ * MAX_CHAIN_DEPTH);
 16e:	9315      	str	r3, [sp, #84]	; 0x54
            chainBuffer = (byte*)XMALLOC(bufferSz, heap, DYNAMIC_TYPE_FILE);
 170:	f7ff fffe 	bl	0 <malloc>
            if (chainBuffer == NULL) {
 174:	4682      	mov	sl, r0
 176:	2800      	cmp	r0, #0
 178:	f000 80e1 	beq.w	33e <ProcessBuffer+0x33e>
 17c:	2400      	movs	r4, #0
 17e:	9411      	str	r4, [sp, #68]	; 0x44
 180:	46a1      	mov	r9, r4
            DerBuffer* part = NULL;
 182:	2300      	movs	r3, #0
            word32 remain = (word32)(sz - consumed);
 184:	9a0d      	ldr	r2, [sp, #52]	; 0x34
            DerBuffer* part = NULL;
 186:	931b      	str	r3, [sp, #108]	; 0x6c
            info->consumed = 0;
 188:	f8c8 3000 	str.w	r3, [r8]
                ret = PemToDer(buff + consumed, remain, type, &part,
 18c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 18e:	4413      	add	r3, r2
 190:	9314      	str	r3, [sp, #80]	; 0x50
            if (format == WOLFSSL_FILETYPE_PEM) {
 192:	9b12      	ldr	r3, [sp, #72]	; 0x48
 194:	2b01      	cmp	r3, #1
            word32 remain = (word32)(sz - consumed);
 196:	ebab 0102 	sub.w	r1, fp, r2
            if (format == WOLFSSL_FILETYPE_PEM) {
 19a:	d143      	bne.n	224 <ProcessBuffer+0x224>
                ret = PemToDer(buff + consumed, remain, type, &part,
 19c:	2300      	movs	r3, #0
 19e:	e9cd 8301 	strd	r8, r3, [sp, #4]
 1a2:	9b10      	ldr	r3, [sp, #64]	; 0x40
 1a4:	9300      	str	r3, [sp, #0]
 1a6:	9814      	ldr	r0, [sp, #80]	; 0x50
 1a8:	ab1b      	add	r3, sp, #108	; 0x6c
 1aa:	2225      	movs	r2, #37	; 0x25
 1ac:	f7ff fffe 	bl	0 <PemToDer>
            if (ret == 0) {
 1b0:	4604      	mov	r4, r0
 1b2:	2800      	cmp	r0, #0
 1b4:	d059      	beq.n	26a <ProcessBuffer+0x26a>
            FreeDer(&part);
 1b6:	a81b      	add	r0, sp, #108	; 0x6c
 1b8:	f7ff fffe 	bl	0 <FreeDer>
            if (ret == ASN_NO_PEM_HEADER && gotOne) {
 1bc:	f114 0fa2 	cmn.w	r4, #162	; 0xa2
 1c0:	f040 8085 	bne.w	2ce <ProcessBuffer+0x2ce>
 1c4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 1c6:	2b00      	cmp	r3, #0
 1c8:	f000 8083 	beq.w	2d2 <ProcessBuffer+0x2d2>
        if (idx > 0) {
 1cc:	f1b9 0f00 	cmp.w	r9, #0
 1d0:	f000 80b1 	beq.w	336 <ProcessBuffer+0x336>
            if (ssl) {
 1d4:	2d00      	cmp	r5, #0
 1d6:	f000 8097 	beq.w	308 <ProcessBuffer+0x308>
                if (ssl->buffers.weOwnCertChain) {
 1da:	f895 30d9 	ldrb.w	r3, [r5, #217]	; 0xd9
                    FreeDer(&ssl->buffers.certChain);
 1de:	f105 04f0 	add.w	r4, r5, #240	; 0xf0
                if (ssl->buffers.weOwnCertChain) {
 1e2:	b113      	cbz	r3, 1ea <ProcessBuffer+0x1ea>
                    FreeDer(&ssl->buffers.certChain);
 1e4:	4620      	mov	r0, r4
 1e6:	f7ff fffe 	bl	0 <FreeDer>
                ret = AllocDer(&ssl->buffers.certChain, idx, type, heap);
 1ea:	4620      	mov	r0, r4
 1ec:	9b10      	ldr	r3, [sp, #64]	; 0x40
 1ee:	2225      	movs	r2, #37	; 0x25
 1f0:	4649      	mov	r1, r9
 1f2:	f7ff fffe 	bl	0 <AllocDer>
                if (ret == 0) {
 1f6:	4604      	mov	r4, r0
 1f8:	b948      	cbnz	r0, 20e <ProcessBuffer+0x20e>
                    XMEMCPY(ssl->buffers.certChain->buffer, chainBuffer,
 1fa:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 1fe:	464a      	mov	r2, r9
 200:	6818      	ldr	r0, [r3, #0]
 202:	4651      	mov	r1, sl
 204:	f7ff fffe 	bl	0 <memcpy>
                    ssl->buffers.weOwnCertChain = 1;
 208:	2301      	movs	r3, #1
 20a:	f885 30d9 	strb.w	r3, [r5, #217]	; 0xd9
            XFREE(chainBuffer, heap, DYNAMIC_TYPE_FILE);
 20e:	4650      	mov	r0, sl
 210:	f7ff fffe 	bl	0 <free>
            if (ret == ASN_NO_PEM_HEADER) { /* Additional chain is optional */
 214:	f114 0fa2 	cmn.w	r4, #162	; 0xa2
 218:	f43f af47 	beq.w	aa <ProcessBuffer+0xaa>
    if (ret < 0 || type != PRIVATEKEY_TYPE) {
 21c:	2c00      	cmp	r4, #0
 21e:	f6bf af45 	bge.w	ac <ProcessBuffer+0xac>
 222:	e05d      	b.n	2e0 <ProcessBuffer+0x2e0>
                    word32 inOutIdx = 0;
 224:	2300      	movs	r3, #0
                int length = remain;
 226:	911c      	str	r1, [sp, #112]	; 0x70
                    word32 inOutIdx = 0;
 228:	931d      	str	r3, [sp, #116]	; 0x74
                    if (GetSequence(buff + consumed, &inOutIdx, &length,
 22a:	9814      	ldr	r0, [sp, #80]	; 0x50
 22c:	460b      	mov	r3, r1
 22e:	aa1c      	add	r2, sp, #112	; 0x70
 230:	a91d      	add	r1, sp, #116	; 0x74
 232:	f7ff fffe 	bl	0 <GetSequence>
                    length += inOutIdx; /* include leading sequence */
 236:	e9dd 131c 	ldrd	r1, r3, [sp, #112]	; 0x70
                        ret = ASN_NO_PEM_HEADER;
 23a:	2800      	cmp	r0, #0
                    length += inOutIdx; /* include leading sequence */
 23c:	4419      	add	r1, r3
                        ret = ASN_NO_PEM_HEADER;
 23e:	bfb8      	it	lt
 240:	f06f 04a1 	mvnlt.w	r4, #161	; 0xa1
                    length += inOutIdx; /* include leading sequence */
 244:	911c      	str	r1, [sp, #112]	; 0x70
                info->consumed = length;
 246:	f8c8 1000 	str.w	r1, [r8]
                if (ret == 0) {
 24a:	2c00      	cmp	r4, #0
 24c:	d1b3      	bne.n	1b6 <ProcessBuffer+0x1b6>
                    ret = AllocDer(&part, length, type, heap);
 24e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 250:	2225      	movs	r2, #37	; 0x25
 252:	a81b      	add	r0, sp, #108	; 0x6c
 254:	f7ff fffe 	bl	0 <AllocDer>
                    if (ret == 0) {
 258:	4604      	mov	r4, r0
 25a:	2800      	cmp	r0, #0
 25c:	d1ab      	bne.n	1b6 <ProcessBuffer+0x1b6>
                        XMEMCPY(part->buffer, buff + consumed, length);
 25e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 260:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 262:	9914      	ldr	r1, [sp, #80]	; 0x50
 264:	6818      	ldr	r0, [r3, #0]
 266:	f7ff fffe 	bl	0 <memcpy>
                if ((idx + part->length + CERT_HEADER_SZ) > bufferSz) {
 26a:	991b      	ldr	r1, [sp, #108]	; 0x6c
 26c:	9815      	ldr	r0, [sp, #84]	; 0x54
 26e:	688b      	ldr	r3, [r1, #8]
 270:	1cda      	adds	r2, r3, #3
 272:	444a      	add	r2, r9
 274:	4290      	cmp	r0, r2
 276:	d321      	bcc.n	2bc <ProcessBuffer+0x2bc>
                    c32to24(part->length, &chainBuffer[idx]);
 278:	eb0a 0209 	add.w	r2, sl, r9
    out[0] = (byte)((in >> 16) & 0xff);
 27c:	0c18      	lsrs	r0, r3, #16
 27e:	f80a 0009 	strb.w	r0, [sl, r9]
    out[1] = (byte)((in >>  8) & 0xff);
 282:	0a18      	lsrs	r0, r3, #8
 284:	7050      	strb	r0, [r2, #1]
    out[2] =  (byte)(in        & 0xff);
 286:	7093      	strb	r3, [r2, #2]
                    idx += CERT_HEADER_SZ;
 288:	f109 0903 	add.w	r9, r9, #3
                    XMEMCPY(&chainBuffer[idx], part->buffer, part->length);
 28c:	688a      	ldr	r2, [r1, #8]
 28e:	6809      	ldr	r1, [r1, #0]
 290:	eb0a 0009 	add.w	r0, sl, r9
 294:	f7ff fffe 	bl	0 <memcpy>
                    idx += part->length;
 298:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
                    consumed  += info->consumed;
 29a:	f8d8 2000 	ldr.w	r2, [r8]
                    idx += part->length;
 29e:	689b      	ldr	r3, [r3, #8]
 2a0:	4499      	add	r9, r3
                    consumed  += info->consumed;
 2a2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 2a4:	4413      	add	r3, r2
 2a6:	930d      	str	r3, [sp, #52]	; 0x34
                    if (used)
 2a8:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
 2aa:	b163      	cbz	r3, 2c6 <ProcessBuffer+0x2c6>
                        *used += info->consumed;
 2ac:	681b      	ldr	r3, [r3, #0]
 2ae:	4413      	add	r3, r2
 2b0:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
 2b2:	6013      	str	r3, [r2, #0]
                gotOne = 1;
 2b4:	2301      	movs	r3, #1
 2b6:	9311      	str	r3, [sp, #68]	; 0x44
                        *used += info->consumed;
 2b8:	2400      	movs	r4, #0
 2ba:	e77c      	b.n	1b6 <ProcessBuffer+0x1b6>
                gotOne = 1;
 2bc:	2301      	movs	r3, #1
 2be:	9311      	str	r3, [sp, #68]	; 0x44
                    ret = BUFFER_E;
 2c0:	f06f 0483 	mvn.w	r4, #131	; 0x83
 2c4:	e777      	b.n	1b6 <ProcessBuffer+0x1b6>
                gotOne = 1;
 2c6:	2301      	movs	r3, #1
 2c8:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
 2ca:	9311      	str	r3, [sp, #68]	; 0x44
 2cc:	e773      	b.n	1b6 <ProcessBuffer+0x1b6>
            if (ret < 0) {
 2ce:	2c00      	cmp	r4, #0
 2d0:	da15      	bge.n	2fe <ProcessBuffer+0x2fe>
                    XFREE(chainBuffer, heap, DYNAMIC_TYPE_FILE);
 2d2:	4650      	mov	r0, sl
 2d4:	f7ff fffe 	bl	0 <free>
            if (ret == ASN_NO_PEM_HEADER) { /* Additional chain is optional */
 2d8:	f114 0fa2 	cmn.w	r4, #162	; 0xa2
 2dc:	f43f aee5 	beq.w	aa <ProcessBuffer+0xaa>
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 2e0:	4640      	mov	r0, r8
 2e2:	f7ff fffe 	bl	0 <free>
    if (ret < 0) {
 2e6:	2c00      	cmp	r4, #0
 2e8:	da2c      	bge.n	344 <ProcessBuffer+0x344>
        FreeDer(&der);
 2ea:	a817      	add	r0, sp, #92	; 0x5c
 2ec:	f7ff fffe 	bl	0 <FreeDer>
        if ((type == CA_TYPE) || (type == CERT_TYPE)) {
 2f0:	2f05      	cmp	r7, #5
 2f2:	f040 8293 	bne.w	81c <ProcessBuffer+0x81c>
            if ((ctx != NULL) && (ctx->cm != NULL) &&
 2f6:	2e00      	cmp	r6, #0
 2f8:	f43f aeb0 	beq.w	5c <ProcessBuffer+0x5c>
 2fc:	e032      	b.n	364 <ProcessBuffer+0x364>
        while (consumed < sz) {
 2fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 300:	459b      	cmp	fp, r3
 302:	f73f af3e 	bgt.w	182 <ProcessBuffer+0x182>
 306:	e761      	b.n	1cc <ProcessBuffer+0x1cc>
            } else if (ctx) {
 308:	b1be      	cbz	r6, 33a <ProcessBuffer+0x33a>
                FreeDer(&ctx->certChain);
 30a:	f106 0414 	add.w	r4, r6, #20
 30e:	4620      	mov	r0, r4
 310:	f7ff fffe 	bl	0 <FreeDer>
                ret = AllocDer(&ctx->certChain, idx, type, heap);
 314:	4620      	mov	r0, r4
 316:	9b10      	ldr	r3, [sp, #64]	; 0x40
 318:	2225      	movs	r2, #37	; 0x25
 31a:	4649      	mov	r1, r9
 31c:	f7ff fffe 	bl	0 <AllocDer>
                if (ret == 0) {
 320:	4604      	mov	r4, r0
 322:	2800      	cmp	r0, #0
 324:	f47f af73 	bne.w	20e <ProcessBuffer+0x20e>
                    XMEMCPY(ctx->certChain->buffer, chainBuffer, idx);
 328:	6973      	ldr	r3, [r6, #20]
 32a:	464a      	mov	r2, r9
 32c:	6818      	ldr	r0, [r3, #0]
 32e:	4651      	mov	r1, sl
 330:	f7ff fffe 	bl	0 <memcpy>
 334:	e76b      	b.n	20e <ProcessBuffer+0x20e>
        ret = 0;
 336:	464c      	mov	r4, r9
 338:	e769      	b.n	20e <ProcessBuffer+0x20e>
 33a:	4634      	mov	r4, r6
 33c:	e767      	b.n	20e <ProcessBuffer+0x20e>
                return MEMORY_E;
 33e:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 342:	e7cd      	b.n	2e0 <ProcessBuffer+0x2e0>
    else if (type == CA_TYPE) {
 344:	2f05      	cmp	r7, #5
 346:	d120      	bne.n	38a <ProcessBuffer+0x38a>
        if (ctx == NULL) {
 348:	b92e      	cbnz	r6, 356 <ProcessBuffer+0x356>
            FreeDer(&der);
 34a:	a817      	add	r0, sp, #92	; 0x5c
 34c:	f7ff fffe 	bl	0 <FreeDer>
        return BAD_FUNC_ARG;
 350:	f06f 04ac 	mvn.w	r4, #172	; 0xac
 354:	e682      	b.n	5c <ProcessBuffer+0x5c>
        ret = AddCA(ctx->cm, &der, WOLFSSL_USER_CA, verify);
 356:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
 358:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 35a:	2201      	movs	r2, #1
 35c:	a917      	add	r1, sp, #92	; 0x5c
 35e:	f7ff fffe 	bl	0 <ProcessBuffer>
 362:	4604      	mov	r4, r0
            if ((ctx != NULL) && (ctx->cm != NULL) &&
 364:	6ab0      	ldr	r0, [r6, #40]	; 0x28
 366:	2800      	cmp	r0, #0
 368:	f43f ae78 	beq.w	5c <ProcessBuffer+0x5c>
 36c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 36e:	2b00      	cmp	r3, #0
 370:	f43f ae74 	beq.w	5c <ProcessBuffer+0x5c>
                ret = CM_VerifyBuffer_ex(ctx->cm, buff,
 374:	2c01      	cmp	r4, #1
 376:	bf08      	it	eq
 378:	2400      	moveq	r4, #0
 37a:	9400      	str	r4, [sp, #0]
 37c:	9b12      	ldr	r3, [sp, #72]	; 0x48
 37e:	990e      	ldr	r1, [sp, #56]	; 0x38
 380:	465a      	mov	r2, fp
 382:	f7ff fffe 	bl	0 <ProcessBuffer>
 386:	4604      	mov	r4, r0
 388:	e668      	b.n	5c <ProcessBuffer+0x5c>
    else if (type == CERT_TYPE) {
 38a:	bb8f      	cbnz	r7, 3f0 <ProcessBuffer+0x3f0>
        if (ssl != NULL) {
 38c:	b33d      	cbz	r5, 3de <ProcessBuffer+0x3de>
            if (ssl->buffers.weOwnCert) {
 38e:	f895 30d8 	ldrb.w	r3, [r5, #216]	; 0xd8
 392:	b11b      	cbz	r3, 39c <ProcessBuffer+0x39c>
                FreeDer(&ssl->buffers.certificate);
 394:	f105 00dc 	add.w	r0, r5, #220	; 0xdc
 398:	f7ff fffe 	bl	0 <FreeDer>
            ssl->buffers.certificate = der;
 39c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 39e:	f8c5 30dc 	str.w	r3, [r5, #220]	; 0xdc
            ssl->buffers.weOwnCert = 1;
 3a2:	2301      	movs	r3, #1
 3a4:	f885 30d8 	strb.w	r3, [r5, #216]	; 0xd8
        cert = (DecodedCert*)XMALLOC(sizeof(DecodedCert), heap,
 3a8:	f44f 7056 	mov.w	r0, #856	; 0x358
 3ac:	f7ff fffe 	bl	0 <malloc>
        if (cert == NULL)
 3b0:	4680      	mov	r8, r0
 3b2:	2800      	cmp	r0, #0
 3b4:	f43f ae50 	beq.w	58 <ProcessBuffer+0x58>
        InitDecodedCert_ex(cert, der->buffer, der->length, heap, devId);
 3b8:	9917      	ldr	r1, [sp, #92]	; 0x5c
 3ba:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 3bc:	9300      	str	r3, [sp, #0]
 3be:	688a      	ldr	r2, [r1, #8]
 3c0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 3c2:	6809      	ldr	r1, [r1, #0]
 3c4:	f7ff fffe 	bl	0 <InitDecodedCert_ex>
        if (DecodeToKey(cert, 0) < 0) {
 3c8:	2100      	movs	r1, #0
 3ca:	4640      	mov	r0, r8
 3cc:	f7ff fffe 	bl	0 <DecodeToKey>
 3d0:	2800      	cmp	r0, #0
 3d2:	f280 813d 	bge.w	650 <ProcessBuffer+0x650>
            FreeDecodedCert(cert);
 3d6:	4640      	mov	r0, r8
 3d8:	f7ff fffe 	bl	0 <FreeDecodedCert>
 3dc:	e0cd      	b.n	57a <ProcessBuffer+0x57a>
        else if (ctx != NULL) {
 3de:	2e00      	cmp	r6, #0
 3e0:	d0e2      	beq.n	3a8 <ProcessBuffer+0x3a8>
            FreeDer(&ctx->certificate); /* Make sure previous is free'd */
 3e2:	f106 0010 	add.w	r0, r6, #16
 3e6:	f7ff fffe 	bl	0 <FreeDer>
            ctx->certificate = der;
 3ea:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 3ec:	6133      	str	r3, [r6, #16]
    if (done == 1) {
 3ee:	e7db      	b.n	3a8 <ProcessBuffer+0x3a8>
    else if (type == PRIVATEKEY_TYPE) {
 3f0:	2f01      	cmp	r7, #1
 3f2:	f43f ae5e 	beq.w	b2 <ProcessBuffer+0xb2>
        FreeDer(&der);
 3f6:	a817      	add	r0, sp, #92	; 0x5c
 3f8:	f7ff fffe 	bl	0 <FreeDer>
        return WOLFSSL_BAD_CERTTYPE;
 3fc:	f06f 0407 	mvn.w	r4, #7
 400:	e62c      	b.n	5c <ProcessBuffer+0x5c>
            if (ssl->buffers.weOwnKey) {
 402:	f895 30da 	ldrb.w	r3, [r5, #218]	; 0xda
 406:	b14b      	cbz	r3, 41c <ProcessBuffer+0x41c>
                ForceZero(ssl->buffers.key->buffer, ssl->buffers.key->length);
 408:	462a      	mov	r2, r5
 40a:	f852 3fe0 	ldr.w	r3, [r2, #224]!
 40e:	6818      	ldr	r0, [r3, #0]
 410:	6899      	ldr	r1, [r3, #8]
 412:	f7ff fffe 	bl	0 <ProcessBuffer>
                FreeDer(&ssl->buffers.key);
 416:	4610      	mov	r0, r2
 418:	f7ff fffe 	bl	0 <FreeDer>
            ssl->buffers.key = der;
 41c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 41e:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
            ssl->buffers.weOwnKey = 1;
 422:	2301      	movs	r3, #1
 424:	f885 30da 	strb.w	r3, [r5, #218]	; 0xda
        ret = ProcessBufferTryDecode(ctx, ssl, der, &keySz, &idx, &resetSuites,
 428:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
    if (ctx == NULL && ssl == NULL)
 42c:	b916      	cbnz	r6, 434 <ProcessBuffer+0x434>
 42e:	2d00      	cmp	r5, #0
 430:	f000 80d1 	beq.w	5d6 <ProcessBuffer+0x5d6>
    if (!der || !keySz || !idx || !resetSuites || !keyFormat)
 434:	f1ba 0f00 	cmp.w	sl, #0
 438:	f000 80cd 	beq.w	5d6 <ProcessBuffer+0x5d6>
    if ((*keyFormat == 0) || (*keyFormat == ECDSAk)
 43c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 43e:	b123      	cbz	r3, 44a <ProcessBuffer+0x44a>
 440:	f240 2206 	movw	r2, #518	; 0x206
 444:	4293      	cmp	r3, r2
 446:	f040 80b3 	bne.w	5b0 <ProcessBuffer+0x5b0>
    key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);
 44a:	f44f 70de 	mov.w	r0, #444	; 0x1bc
 44e:	f7ff fffe 	bl	0 <malloc>
    if (key == NULL)
 452:	4681      	mov	r9, r0
 454:	b930      	cbnz	r0, 464 <ProcessBuffer+0x464>
        return MEMORY_E;
 456:	f06f 077c 	mvn.w	r7, #124	; 0x7c
            XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 45a:	4640      	mov	r0, r8
 45c:	f7ff fffe 	bl	0 <free>
            return ret;
 460:	463c      	mov	r4, r7
 462:	e5fb      	b.n	5c <ProcessBuffer+0x5c>
    if (wc_ecc_init_ex(key, heap, devId) == 0) {
 464:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 466:	990f      	ldr	r1, [sp, #60]	; 0x3c
 468:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
 46c:	4607      	mov	r7, r0
 46e:	2800      	cmp	r0, #0
 470:	f040 809b 	bne.w	5aa <ProcessBuffer+0x5aa>
        *idx = 0;
 474:	9019      	str	r0, [sp, #100]	; 0x64
        ret = wc_EccPrivateKeyDecode(der->buffer, idx, key, der->length);
 476:	f8da 3008 	ldr.w	r3, [sl, #8]
 47a:	f8da 0000 	ldr.w	r0, [sl]
 47e:	464a      	mov	r2, r9
 480:	a919      	add	r1, sp, #100	; 0x64
 482:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
        if (ret == 0) {
 486:	4604      	mov	r4, r0
 488:	2800      	cmp	r0, #0
 48a:	f040 808c 	bne.w	5a6 <ProcessBuffer+0x5a6>
            int minKeySz = ssl ? ssl->options.minEccKeySz : ctx->minEccKeySz;
 48e:	2d00      	cmp	r5, #0
 490:	d079      	beq.n	586 <ProcessBuffer+0x586>
 492:	f9b5 b286 	ldrsh.w	fp, [r5, #646]	; 0x286
                ret = ECC_KEY_SIZE_E;
 496:	4fb2      	ldr	r7, [pc, #712]	; (760 <ProcessBuffer+0x760>)
            *keySz = wc_ecc_size(key);
 498:	4648      	mov	r0, r9
 49a:	f7ff fffe 	bl	0 <wc_ecc_size>
            *keyFormat = ECDSAk;
 49e:	f240 2206 	movw	r2, #518	; 0x206
                ret = ECC_KEY_SIZE_E;
 4a2:	4558      	cmp	r0, fp
 4a4:	bfa8      	it	ge
 4a6:	2700      	movge	r7, #0
            *keyFormat = ECDSAk;
 4a8:	9218      	str	r2, [sp, #96]	; 0x60
            if (ssl) {
 4aa:	2d00      	cmp	r5, #0
 4ac:	d06e      	beq.n	58c <ProcessBuffer+0x58c>
                ssl->options.haveStaticECC = 1;
 4ae:	f895 2273 	ldrb.w	r2, [r5, #627]	; 0x273
            if (ssl && ssl->options.side == WOLFSSL_SERVER_END) {
 4b2:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
                ssl->buffers.keySz = *keySz;
 4b6:	f8c5 00e8 	str.w	r0, [r5, #232]	; 0xe8
                ssl->options.haveStaticECC = 1;
 4ba:	f042 0220 	orr.w	r2, r2, #32
 4be:	f885 2273 	strb.w	r2, [r5, #627]	; 0x273
                ssl->buffers.keyType = ecc_dsa_sa_algo;
 4c2:	f895 20e4 	ldrb.w	r2, [r5, #228]	; 0xe4
 4c6:	2103      	movs	r1, #3
            if (ssl && ssl->options.side == WOLFSSL_SERVER_END) {
 4c8:	f013 0f30 	tst.w	r3, #48	; 0x30
                ssl->buffers.keyType = ecc_dsa_sa_algo;
 4cc:	f361 0205 	bfi	r2, r1, #0, #6
 4d0:	f885 20e4 	strb.w	r2, [r5, #228]	; 0xe4
            if (ssl && ssl->options.side == WOLFSSL_SERVER_END) {
 4d4:	bf0c      	ite	eq
 4d6:	2401      	moveq	r4, #1
 4d8:	2400      	movne	r4, #0
        wc_ecc_free(key);
 4da:	4648      	mov	r0, r9
 4dc:	f7ff fffe 	bl	0 <wc_ecc_free>
    XFREE(key, heap, DYNAMIC_TYPE_ECC);
 4e0:	4648      	mov	r0, r9
 4e2:	f7ff fffe 	bl	0 <free>
        if (ret != 0)
 4e6:	2f00      	cmp	r7, #0
 4e8:	d1b7      	bne.n	45a <ProcessBuffer+0x45a>
    if ((*keyFormat == 0 || *keyFormat == ED25519k)) {
 4ea:	9b18      	ldr	r3, [sp, #96]	; 0x60
 4ec:	f433 7380 	bics.w	r3, r3, #256	; 0x100
 4f0:	d174      	bne.n	5dc <ProcessBuffer+0x5dc>
    key = (ed25519_key*)XMALLOC(sizeof(ed25519_key), heap,
 4f2:	2068      	movs	r0, #104	; 0x68
 4f4:	f7ff fffe 	bl	0 <malloc>
    if (key == NULL)
 4f8:	4681      	mov	r9, r0
 4fa:	2800      	cmp	r0, #0
 4fc:	d0ab      	beq.n	456 <ProcessBuffer+0x456>
    ret = wc_ed25519_init_ex(key, heap, devId);
 4fe:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 500:	990f      	ldr	r1, [sp, #60]	; 0x3c
 502:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
    if (ret == 0) {
 506:	4607      	mov	r7, r0
 508:	bb78      	cbnz	r0, 56a <ProcessBuffer+0x56a>
        ret = wc_Ed25519PrivateKeyDecode(der->buffer, idx, key, der->length);
 50a:	f8da 3008 	ldr.w	r3, [sl, #8]
        *idx = 0;
 50e:	9019      	str	r0, [sp, #100]	; 0x64
        ret = wc_Ed25519PrivateKeyDecode(der->buffer, idx, key, der->length);
 510:	464a      	mov	r2, r9
 512:	f8da 0000 	ldr.w	r0, [sl]
 516:	a919      	add	r1, sp, #100	; 0x64
 518:	f7ff fffe 	bl	0 <wc_Ed25519PrivateKeyDecode>
        if (ret == 0) {
 51c:	4682      	mov	sl, r0
 51e:	2800      	cmp	r0, #0
 520:	d154      	bne.n	5cc <ProcessBuffer+0x5cc>
            int minKeySz = ssl ? ssl->options.minEccKeySz : ctx->minEccKeySz;
 522:	2d00      	cmp	r5, #0
 524:	d046      	beq.n	5b4 <ProcessBuffer+0x5b4>
            if (*keySz < minKeySz) {
 526:	f9b5 3286 	ldrsh.w	r3, [r5, #646]	; 0x286
 52a:	2b20      	cmp	r3, #32
 52c:	dc50      	bgt.n	5d0 <ProcessBuffer+0x5d0>
                    ssl->buffers.keyType = ed25519_sa_algo;
 52e:	f895 30e4 	ldrb.w	r3, [r5, #228]	; 0xe4
 532:	2209      	movs	r2, #9
 534:	f362 0305 	bfi	r3, r2, #0, #6
 538:	f885 30e4 	strb.w	r3, [r5, #228]	; 0xe4
                    ssl->buffers.keySz = *keySz;
 53c:	2320      	movs	r3, #32
 53e:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8
                *keyFormat = ED25519k;
 542:	f44f 7380 	mov.w	r3, #256	; 0x100
 546:	9318      	str	r3, [sp, #96]	; 0x60
                if (ssl != NULL) {
 548:	b15d      	cbz	r5, 562 <ProcessBuffer+0x562>
                    ssl->options.cacheMessages = 1;
 54a:	f895 3276 	ldrb.w	r3, [r5, #630]	; 0x276
 54e:	f043 0304 	orr.w	r3, r3, #4
 552:	f885 3276 	strb.w	r3, [r5, #630]	; 0x276
                    if (ssl->options.side == WOLFSSL_SERVER_END) {
 556:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
                        *resetSuites = 1;
 55a:	f013 0f30 	tst.w	r3, #48	; 0x30
 55e:	bf08      	it	eq
 560:	2401      	moveq	r4, #1
        wc_ed25519_free(key);
 562:	4648      	mov	r0, r9
 564:	f7ff fffe 	bl	0 <wc_ed25519_free>
 568:	4657      	mov	r7, sl
    XFREE(key, heap, DYNAMIC_TYPE_ED25519);
 56a:	4648      	mov	r0, r9
 56c:	f7ff fffe 	bl	0 <free>
        if (ret != 0) {
 570:	2f00      	cmp	r7, #0
 572:	f47f af72 	bne.w	45a <ProcessBuffer+0x45a>
        if (keyFormat == 0) {
 576:	9b18      	ldr	r3, [sp, #96]	; 0x60
 578:	bb83      	cbnz	r3, 5dc <ProcessBuffer+0x5dc>
            XFREE(cert, heap, DYNAMIC_TYPE_DCERT);
 57a:	4640      	mov	r0, r8
 57c:	f7ff fffe 	bl	0 <free>
            return WOLFSSL_BAD_FILE;
 580:	f06f 0403 	mvn.w	r4, #3
 584:	e56a      	b.n	5c <ProcessBuffer+0x5c>
            int minKeySz = ssl ? ssl->options.minEccKeySz : ctx->minEccKeySz;
 586:	f9b6 b03a 	ldrsh.w	fp, [r6, #58]	; 0x3a
 58a:	e784      	b.n	496 <ProcessBuffer+0x496>
                ctx->haveStaticECC = 1;
 58c:	f896 2036 	ldrb.w	r2, [r6, #54]	; 0x36
                ctx->privateKeySz = *keySz;
 590:	6230      	str	r0, [r6, #32]
                ctx->haveStaticECC = 1;
 592:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 596:	f886 2036 	strb.w	r2, [r6, #54]	; 0x36
                ctx->privateKeyType = ecc_dsa_sa_algo;
 59a:	7f32      	ldrb	r2, [r6, #28]
 59c:	2103      	movs	r1, #3
 59e:	f361 0205 	bfi	r2, r1, #0, #6
 5a2:	7732      	strb	r2, [r6, #28]
            if (ssl && ssl->options.side == WOLFSSL_SERVER_END) {
 5a4:	e799      	b.n	4da <ProcessBuffer+0x4da>
    int           resetSuites = 0;
 5a6:	463c      	mov	r4, r7
 5a8:	e797      	b.n	4da <ProcessBuffer+0x4da>
 5aa:	2400      	movs	r4, #0
    int ret = 0;
 5ac:	4627      	mov	r7, r4
 5ae:	e797      	b.n	4e0 <ProcessBuffer+0x4e0>
    int           resetSuites = 0;
 5b0:	2400      	movs	r4, #0
 5b2:	e79a      	b.n	4ea <ProcessBuffer+0x4ea>
            if (*keySz < minKeySz) {
 5b4:	f9b6 303a 	ldrsh.w	r3, [r6, #58]	; 0x3a
 5b8:	2b20      	cmp	r3, #32
 5ba:	dc09      	bgt.n	5d0 <ProcessBuffer+0x5d0>
                    ctx->privateKeyType = ed25519_sa_algo;
 5bc:	7f33      	ldrb	r3, [r6, #28]
 5be:	2209      	movs	r2, #9
 5c0:	f362 0305 	bfi	r3, r2, #0, #6
 5c4:	7733      	strb	r3, [r6, #28]
                    ctx->privateKeySz = *keySz;
 5c6:	2320      	movs	r3, #32
 5c8:	6233      	str	r3, [r6, #32]
 5ca:	e7ba      	b.n	542 <ProcessBuffer+0x542>
            ret = 0; /* continue trying other algorithms */
 5cc:	46ba      	mov	sl, r7
 5ce:	e7c8      	b.n	562 <ProcessBuffer+0x562>
                ret = ECC_KEY_SIZE_E;
 5d0:	f8df a18c 	ldr.w	sl, [pc, #396]	; 760 <ProcessBuffer+0x760>
 5d4:	e7c5      	b.n	562 <ProcessBuffer+0x562>
        return BAD_FUNC_ARG;
 5d6:	f06f 07ac 	mvn.w	r7, #172	; 0xac
 5da:	e73e      	b.n	45a <ProcessBuffer+0x45a>
        XFREE(info, heap, DYNAMIC_TYPE_ENCRYPTEDINFO);
 5dc:	4640      	mov	r0, r8
 5de:	f7ff fffe 	bl	0 <free>
    if (ssl && resetSuites) {
 5e2:	2d00      	cmp	r5, #0
 5e4:	f040 811e 	bne.w	824 <ProcessBuffer+0x824>
    else if (ctx && resetSuites) {
 5e8:	2e00      	cmp	r6, #0
 5ea:	f000 8152 	beq.w	892 <ProcessBuffer+0x892>
 5ee:	2c00      	cmp	r4, #0
 5f0:	f000 814f 	beq.w	892 <ProcessBuffer+0x892>
        if (AllocateCtxSuites(ctx) != 0)
 5f4:	4630      	mov	r0, r6
        keySz = ctx->privateKeySz;
 5f6:	6a37      	ldr	r7, [r6, #32]
        if (AllocateCtxSuites(ctx) != 0)
 5f8:	f7ff fffe 	bl	0 <AllocateCtxSuites>
 5fc:	2800      	cmp	r0, #0
 5fe:	f040 8119 	bne.w	834 <ProcessBuffer+0x834>
        InitSuites(ctx->suites, ctx->method->version, keySz, haveRSA,
 602:	6831      	ldr	r1, [r6, #0]
 604:	2201      	movs	r2, #1
 606:	788b      	ldrb	r3, [r1, #2]
 608:	930a      	str	r3, [sp, #40]	; 0x28
 60a:	e9cd 5208 	strd	r5, r2, [sp, #32]
                   ctx->haveFalconSig, ctx->haveDilithiumSig,
 60e:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
        InitSuites(ctx->suites, ctx->method->version, keySz, haveRSA,
 612:	f3c3 1040 	ubfx	r0, r3, #5, #1
 616:	9007      	str	r0, [sp, #28]
 618:	f3c3 1000 	ubfx	r0, r3, #4, #1
 61c:	9006      	str	r0, [sp, #24]
 61e:	f3c3 1080 	ubfx	r0, r3, #6, #1
 622:	e9cd 2004 	strd	r2, r0, [sp, #16]
 626:	f3c3 0240 	ubfx	r2, r3, #1, #1
 62a:	9203      	str	r2, [sp, #12]
 62c:	f3c3 02c0 	ubfx	r2, r3, #3, #1
 630:	f3c3 0380 	ubfx	r3, r3, #2, #1
 634:	e9cd 5300 	strd	r5, r3, [sp]
 638:	9202      	str	r2, [sp, #8]
 63a:	784a      	ldrb	r2, [r1, #1]
 63c:	780b      	ldrb	r3, [r1, #0]
 63e:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 640:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 644:	4629      	mov	r1, r5
 646:	f363 010f 	bfi	r1, r3, #0, #16
 64a:	463a      	mov	r2, r7
 64c:	462b      	mov	r3, r5
 64e:	e118      	b.n	882 <ProcessBuffer+0x882>
        if (ssl) {
 650:	b33d      	cbz	r5, 6a2 <ProcessBuffer+0x6a2>
            if (ssl->options.side == WOLFSSL_SERVER_END)
 652:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
 656:	f013 0f30 	tst.w	r3, #48	; 0x30
        if (ssl && ssl->ctx->haveECDSAsig) {
 65a:	682b      	ldr	r3, [r5, #0]
 65c:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
            if (ssl->options.side == WOLFSSL_SERVER_END)
 660:	bf0c      	ite	eq
 662:	2701      	moveq	r7, #1
 664:	2700      	movne	r7, #0
        if (ssl && ssl->ctx->haveECDSAsig) {
 666:	0719      	lsls	r1, r3, #28
 668:	d423      	bmi.n	6b2 <ProcessBuffer+0x6b2>
        switch (cert->signatureOID) {
 66a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 66e:	f8d8 201c 	ldr.w	r2, [r8, #28]
 672:	f5b3 7f86 	cmp.w	r3, #268	; 0x10c
 676:	f000 808b 	beq.w	790 <ProcessBuffer+0x790>
 67a:	d84f      	bhi.n	71c <ProcessBuffer+0x71c>
 67c:	2bdc      	cmp	r3, #220	; 0xdc
 67e:	d81f      	bhi.n	6c0 <ProcessBuffer+0x6c0>
 680:	2bd4      	cmp	r3, #212	; 0xd4
 682:	d953      	bls.n	72c <ProcessBuffer+0x72c>
 684:	3bd5      	subs	r3, #213	; 0xd5
 686:	2101      	movs	r1, #1
 688:	fa01 f303 	lsl.w	r3, r1, r3
 68c:	f013 0f89 	tst.w	r3, #137	; 0x89
 690:	d04c      	beq.n	72c <ProcessBuffer+0x72c>
                if (ssl)
 692:	2d00      	cmp	r5, #0
 694:	f000 8089 	beq.w	7aa <ProcessBuffer+0x7aa>
                    ssl->options.haveDilithiumSig = 1;
 698:	f895 3273 	ldrb.w	r3, [r5, #627]	; 0x273
 69c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 6a0:	e018      	b.n	6d4 <ProcessBuffer+0x6d4>
        else if (ctx && ctx->method->side == WOLFSSL_SERVER_END) {
 6a2:	2e00      	cmp	r6, #0
 6a4:	d0e1      	beq.n	66a <ProcessBuffer+0x66a>
 6a6:	6833      	ldr	r3, [r6, #0]
 6a8:	789f      	ldrb	r7, [r3, #2]
 6aa:	fab7 f787 	clz	r7, r7
 6ae:	097f      	lsrs	r7, r7, #5
 6b0:	e7db      	b.n	66a <ProcessBuffer+0x66a>
            ssl->options.haveECDSAsig = 0;   /* may turn back on next */
 6b2:	f895 3273 	ldrb.w	r3, [r5, #627]	; 0x273
 6b6:	f36f 1304 	bfc	r3, #4, #1
 6ba:	f885 3273 	strb.w	r3, [r5, #627]	; 0x273
 6be:	e7d4      	b.n	66a <ProcessBuffer+0x66a>
        switch (cert->signatureOID) {
 6c0:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
 6c4:	2b01      	cmp	r3, #1
 6c6:	d831      	bhi.n	72c <ProcessBuffer+0x72c>
                if (ssl)
 6c8:	2d00      	cmp	r5, #0
 6ca:	d04b      	beq.n	764 <ProcessBuffer+0x764>
                    ssl->options.haveECDSAsig = 1;
 6cc:	f895 3273 	ldrb.w	r3, [r5, #627]	; 0x273
 6d0:	f043 0310 	orr.w	r3, r3, #16
                    ssl->options.haveFalconSig = 1;
 6d4:	f885 3273 	strb.w	r3, [r5, #627]	; 0x273
            ssl->pkCurveOID = cert->pkCurveOID;
 6d8:	f8d8 32fc 	ldr.w	r3, [r8, #764]	; 0x2fc
 6dc:	f8c5 32a8 	str.w	r3, [r5, #680]	; 0x2a8
            if (cert->keyOID == ECDSAk) {
 6e0:	f240 2306 	movw	r3, #518	; 0x206
 6e4:	429a      	cmp	r2, r3
 6e6:	d167      	bne.n	7b8 <ProcessBuffer+0x7b8>
                ssl->options.haveECC = 1;
 6e8:	f895 3273 	ldrb.w	r3, [r5, #627]	; 0x273
 6ec:	f043 0304 	orr.w	r3, r3, #4
 6f0:	f885 3273 	strb.w	r3, [r5, #627]	; 0x273
                keySz = wc_ecc_get_curve_size_from_id(
 6f4:	2200      	movs	r2, #0
 6f6:	4611      	mov	r1, r2
 6f8:	f8d8 02fc 	ldr.w	r0, [r8, #764]	; 0x2fc
 6fc:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
 700:	f7ff fffe 	bl	0 <wc_ecc_get_curve_size_from_id>
                if (ssl && !ssl->options.verifyNone) {
 704:	2d00      	cmp	r5, #0
 706:	d07a      	beq.n	7fe <ProcessBuffer+0x7fe>
 708:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
 70c:	2b00      	cmp	r3, #0
 70e:	db76      	blt.n	7fe <ProcessBuffer+0x7fe>
                    if (ssl->options.minEccKeySz < 0 ||
 710:	f9b5 3286 	ldrsh.w	r3, [r5, #646]	; 0x286
 714:	2b00      	cmp	r3, #0
 716:	da7b      	bge.n	810 <ProcessBuffer+0x810>
                        ret = ECC_KEY_SIZE_E;
 718:	4c11      	ldr	r4, [pc, #68]	; (760 <ProcessBuffer+0x760>)
 71a:	e011      	b.n	740 <ProcessBuffer+0x740>
        switch (cert->signatureOID) {
 71c:	f5b3 7f02 	cmp.w	r3, #520	; 0x208
 720:	d0d2      	beq.n	6c8 <ProcessBuffer+0x6c8>
 722:	d818      	bhi.n	756 <ProcessBuffer+0x756>
 724:	f240 110f 	movw	r1, #271	; 0x10f
 728:	428b      	cmp	r3, r1
 72a:	d031      	beq.n	790 <ProcessBuffer+0x790>
        if (ssl) {
 72c:	2d00      	cmp	r5, #0
 72e:	d1d3      	bne.n	6d8 <ProcessBuffer+0x6d8>
        else if (ctx) {
 730:	bb06      	cbnz	r6, 774 <ProcessBuffer+0x774>
        switch (cert->keyOID) {
 732:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 736:	d06e      	beq.n	816 <ProcessBuffer+0x816>
 738:	f240 2306 	movw	r3, #518	; 0x206
 73c:	429a      	cmp	r2, r3
 73e:	d0d9      	beq.n	6f4 <ProcessBuffer+0x6f4>
        FreeDecodedCert(cert);
 740:	4640      	mov	r0, r8
 742:	f7ff fffe 	bl	0 <FreeDecodedCert>
        XFREE(cert, heap, DYNAMIC_TYPE_DCERT);
 746:	4640      	mov	r0, r8
 748:	f7ff fffe 	bl	0 <free>
        if (ret != 0) {
 74c:	2c00      	cmp	r4, #0
 74e:	f47f add2 	bne.w	2f6 <ProcessBuffer+0x2f6>
 752:	463c      	mov	r4, r7
 754:	e745      	b.n	5e2 <ProcessBuffer+0x5e2>
        switch (cert->signatureOID) {
 756:	f5a3 7303 	sub.w	r3, r3, #524	; 0x20c
 75a:	2b02      	cmp	r3, #2
 75c:	e7b3      	b.n	6c6 <ProcessBuffer+0x6c6>
 75e:	bf00      	nop
 760:	fffffe66 	.word	0xfffffe66
                else if (ctx)
 764:	2e00      	cmp	r6, #0
 766:	d0e4      	beq.n	732 <ProcessBuffer+0x732>
                    ctx->haveECDSAsig = 1;
 768:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
 76c:	f043 0308 	orr.w	r3, r3, #8
                    ctx->haveDilithiumSig = 1;
 770:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
            ctx->pkCurveOID = cert->pkCurveOID;
 774:	f8d8 32fc 	ldr.w	r3, [r8, #764]	; 0x2fc
 778:	65f3      	str	r3, [r6, #92]	; 0x5c
            if (cert->keyOID == ECDSAk) {
 77a:	f240 2306 	movw	r3, #518	; 0x206
 77e:	429a      	cmp	r2, r3
 780:	d12c      	bne.n	7dc <ProcessBuffer+0x7dc>
                ctx->haveECC = 1;
 782:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
 786:	f043 0302 	orr.w	r3, r3, #2
 78a:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
 78e:	e7b1      	b.n	6f4 <ProcessBuffer+0x6f4>
                if (ssl)
 790:	b125      	cbz	r5, 79c <ProcessBuffer+0x79c>
                    ssl->options.haveFalconSig = 1;
 792:	f895 3273 	ldrb.w	r3, [r5, #627]	; 0x273
 796:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 79a:	e79b      	b.n	6d4 <ProcessBuffer+0x6d4>
                else if (ctx)
 79c:	2e00      	cmp	r6, #0
 79e:	d0c8      	beq.n	732 <ProcessBuffer+0x732>
                    ctx->haveFalconSig = 1;
 7a0:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
 7a4:	f043 0310 	orr.w	r3, r3, #16
 7a8:	e7e2      	b.n	770 <ProcessBuffer+0x770>
                else if (ctx)
 7aa:	2e00      	cmp	r6, #0
 7ac:	d0c1      	beq.n	732 <ProcessBuffer+0x732>
                    ctx->haveDilithiumSig = 1;
 7ae:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
 7b2:	f043 0320 	orr.w	r3, r3, #32
 7b6:	e7db      	b.n	770 <ProcessBuffer+0x770>
                else if (cert->keyOID == ED25519k) {
 7b8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 7bc:	d1bc      	bne.n	738 <ProcessBuffer+0x738>
                    ssl->options.haveECC = 1;
 7be:	f895 3273 	ldrb.w	r3, [r5, #627]	; 0x273
 7c2:	f043 0304 	orr.w	r3, r3, #4
 7c6:	f885 3273 	strb.w	r3, [r5, #627]	; 0x273
                if (ssl && !ssl->options.verifyNone) {
 7ca:	f995 3270 	ldrsb.w	r3, [r5, #624]	; 0x270
 7ce:	2b00      	cmp	r3, #0
 7d0:	db0d      	blt.n	7ee <ProcessBuffer+0x7ee>
                    if (ssl->options.minEccKeySz < 0 ||
 7d2:	f8b5 3286 	ldrh.w	r3, [r5, #646]	; 0x286
                    if (ctx->minEccKeySz < 0 ||
 7d6:	2b20      	cmp	r3, #32
 7d8:	d89e      	bhi.n	718 <ProcessBuffer+0x718>
 7da:	e7b1      	b.n	740 <ProcessBuffer+0x740>
                else if (cert->keyOID == ED25519k) {
 7dc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 7e0:	d1aa      	bne.n	738 <ProcessBuffer+0x738>
                    ctx->haveECC = 1;
 7e2:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
 7e6:	f043 0302 	orr.w	r3, r3, #2
 7ea:	f886 3036 	strb.w	r3, [r6, #54]	; 0x36
                else if (ctx && !ctx->verifyNone) {
 7ee:	2e00      	cmp	r6, #0
 7f0:	d0a6      	beq.n	740 <ProcessBuffer+0x740>
 7f2:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
 7f6:	079b      	lsls	r3, r3, #30
 7f8:	d4a2      	bmi.n	740 <ProcessBuffer+0x740>
                    if (ctx->minEccKeySz < 0 ||
 7fa:	8f73      	ldrh	r3, [r6, #58]	; 0x3a
 7fc:	e7eb      	b.n	7d6 <ProcessBuffer+0x7d6>
                else if (ctx && !ctx->verifyNone) {
 7fe:	2e00      	cmp	r6, #0
 800:	d09e      	beq.n	740 <ProcessBuffer+0x740>
 802:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
 806:	079a      	lsls	r2, r3, #30
 808:	d49a      	bmi.n	740 <ProcessBuffer+0x740>
                    if (ctx->minEccKeySz < 0 ||
 80a:	f9b6 303a 	ldrsh.w	r3, [r6, #58]	; 0x3a
 80e:	e781      	b.n	714 <ProcessBuffer+0x714>
 810:	4298      	cmp	r0, r3
 812:	db81      	blt.n	718 <ProcessBuffer+0x718>
 814:	e794      	b.n	740 <ProcessBuffer+0x740>
                if (ssl && !ssl->options.verifyNone) {
 816:	2d00      	cmp	r5, #0
 818:	d0e9      	beq.n	7ee <ProcessBuffer+0x7ee>
 81a:	e7d6      	b.n	7ca <ProcessBuffer+0x7ca>
        if ((type == CA_TYPE) || (type == CERT_TYPE)) {
 81c:	2f00      	cmp	r7, #0
 81e:	f47f ac1d 	bne.w	5c <ProcessBuffer+0x5c>
 822:	e568      	b.n	2f6 <ProcessBuffer+0x2f6>
    if (ssl && resetSuites) {
 824:	b3ac      	cbz	r4, 892 <ProcessBuffer+0x892>
        if (AllocateSuites(ssl) != 0)
 826:	4628      	mov	r0, r5
        keySz = ssl->buffers.keySz;
 828:	f8d5 60e8 	ldr.w	r6, [r5, #232]	; 0xe8
        if (AllocateSuites(ssl) != 0)
 82c:	f7ff fffe 	bl	0 <AllocateSuites>
 830:	4603      	mov	r3, r0
 832:	b108      	cbz	r0, 838 <ProcessBuffer+0x838>
            return WOLFSSL_FAILURE;
 834:	2400      	movs	r4, #0
 836:	e411      	b.n	5c <ProcessBuffer+0x5c>
                   ssl->options.haveAnon, TRUE, ssl->options.side);
 838:	f895 1270 	ldrb.w	r1, [r5, #624]	; 0x270
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 83c:	2201      	movs	r2, #1
 83e:	f3c1 1101 	ubfx	r1, r1, #4, #2
 842:	9209      	str	r2, [sp, #36]	; 0x24
 844:	910a      	str	r1, [sp, #40]	; 0x28
                   ssl->options.haveAnon, TRUE, ssl->options.side);
 846:	f895 1275 	ldrb.w	r1, [r5, #629]	; 0x275
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 84a:	f3c1 1100 	ubfx	r1, r1, #4, #1
 84e:	9108      	str	r1, [sp, #32]
                   ssl->options.haveFalconSig, ssl->options.haveDilithiumSig,
 850:	f895 1273 	ldrb.w	r1, [r5, #627]	; 0x273
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA,
 854:	09c8      	lsrs	r0, r1, #7
 856:	9007      	str	r0, [sp, #28]
 858:	f3c1 1080 	ubfx	r0, r1, #6, #1
 85c:	9006      	str	r0, [sp, #24]
 85e:	f3c1 1040 	ubfx	r0, r1, #5, #1
 862:	e9cd 2004 	strd	r2, r0, [sp, #16]
 866:	f3c1 0280 	ubfx	r2, r1, #2, #1
 86a:	9203      	str	r2, [sp, #12]
 86c:	f3c1 1200 	ubfx	r2, r1, #4, #1
 870:	f3c1 01c0 	ubfx	r1, r1, #3, #1
 874:	e9cd 3100 	strd	r3, r1, [sp]
 878:	9202      	str	r2, [sp, #8]
 87a:	f8d5 113c 	ldr.w	r1, [r5, #316]	; 0x13c
 87e:	6868      	ldr	r0, [r5, #4]
 880:	4632      	mov	r2, r6
        InitSuites(ctx->suites, ctx->method->version, keySz, haveRSA,
 882:	f7ff fffe 	bl	0 <InitSuites>
 886:	f7ff bbe9 	b.w	5c <ProcessBuffer+0x5c>
        return WOLFSSL_BAD_FILETYPE;
 88a:	f06f 0404 	mvn.w	r4, #4
 88e:	f7ff bbe5 	b.w	5c <ProcessBuffer+0x5c>
    return WOLFSSL_SUCCESS;
 892:	2401      	movs	r4, #1
 894:	f7ff bbe2 	b.w	5c <ProcessBuffer+0x5c>

Disassembly of section .text.wolfSSL_CTX_set_verify_depth:

00000000 <wolfSSL_CTX_set_verify_depth>:
    if (ctx == NULL || depth < 0 || depth > MAX_CHAIN_DEPTH) {
   0:	b118      	cbz	r0, a <wolfSSL_CTX_set_verify_depth+0xa>
   2:	2909      	cmp	r1, #9
    ctx->verifyDepth = (byte)depth;
   4:	bf98      	it	ls
   6:	f880 1034 	strbls.w	r1, [r0, #52]	; 0x34
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_verify_depth:

00000000 <wolfSSL_get_verify_depth>:
        return BAD_FUNC_ARG;
   0:	2800      	cmp	r0, #0
}
   2:	bf14      	ite	ne
   4:	2009      	movne	r0, #9
   6:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_get_verify_depth:

00000000 <wolfSSL_CTX_get_verify_depth>:
   0:	2800      	cmp	r0, #0
   2:	bf14      	ite	ne
   4:	2009      	movne	r0, #9
   6:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_check_private_key:

00000000 <wolfSSL_CTX_check_private_key>:
{
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    if (ctx == NULL) {
   4:	b300      	cbz	r0, 48 <wolfSSL_CTX_check_private_key+0x48>
    return check_cert_key(ctx->certificate, ctx->privateKey, ctx->heap,
   6:	6906      	ldr	r6, [r0, #16]
    if (cert == NULL || key == NULL) {
   8:	b1f6      	cbz	r6, 48 <wolfSSL_CTX_check_private_key+0x48>
    return check_cert_key(ctx->certificate, ctx->privateKey, ctx->heap,
   a:	6984      	ldr	r4, [r0, #24]
    if (cert == NULL || key == NULL) {
   c:	b1ec      	cbz	r4, 4a <wolfSSL_CTX_check_private_key+0x4a>
    return check_cert_key(ctx->certificate, ctx->privateKey, ctx->heap,
   e:	6b07      	ldr	r7, [r0, #48]	; 0x30
  10:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24
    der = (DecodedCert*)XMALLOC(sizeof(DecodedCert), NULL, DYNAMIC_TYPE_DCERT);
  14:	f44f 7056 	mov.w	r0, #856	; 0x358
  18:	f7ff fffe 	bl	0 <malloc>
    if (der == NULL)
  1c:	4605      	mov	r5, r0
  1e:	b338      	cbz	r0, 70 <wolfSSL_CTX_check_private_key+0x70>
    InitDecodedCert_ex(der, buff, size, heap, devId);
  20:	f8cd 8000 	str.w	r8, [sp]
  24:	68b2      	ldr	r2, [r6, #8]
  26:	6831      	ldr	r1, [r6, #0]
  28:	463b      	mov	r3, r7
  2a:	f7ff fffe 	bl	0 <InitDecodedCert_ex>
    if (ParseCertRelative(der, CERT_TYPE, NO_VERIFY, NULL) != 0) {
  2e:	2300      	movs	r3, #0
  30:	461a      	mov	r2, r3
  32:	4619      	mov	r1, r3
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <ParseCertRelative>
  3a:	b150      	cbz	r0, 52 <wolfSSL_CTX_check_private_key+0x52>
        FreeDecodedCert(der);
  3c:	4628      	mov	r0, r5
  3e:	f7ff fffe 	bl	0 <FreeDecodedCert>
        XFREE(der, NULL, DYNAMIC_TYPE_DCERT);
  42:	4628      	mov	r0, r5
  44:	f7ff fffe 	bl	0 <free>
        return WOLFSSL_FAILURE;
  48:	2400      	movs	r4, #0
}
  4a:	4620      	mov	r0, r4
  4c:	b002      	add	sp, #8
  4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret = wc_CheckPrivateKeyCert(buff, size, der);
  52:	68a1      	ldr	r1, [r4, #8]
  54:	6820      	ldr	r0, [r4, #0]
  56:	462a      	mov	r2, r5
  58:	f7ff fffe 	bl	0 <wc_CheckPrivateKeyCert>
        ret = (ret == 1) ? WOLFSSL_SUCCESS: WOLFSSL_FAILURE;
  5c:	1e43      	subs	r3, r0, #1
  5e:	425c      	negs	r4, r3
    FreeDecodedCert(der);
  60:	4628      	mov	r0, r5
        ret = (ret == 1) ? WOLFSSL_SUCCESS: WOLFSSL_FAILURE;
  62:	415c      	adcs	r4, r3
    FreeDecodedCert(der);
  64:	f7ff fffe 	bl	0 <FreeDecodedCert>
    XFREE(der, NULL, DYNAMIC_TYPE_DCERT);
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <free>
    return ret;
  6e:	e7ec      	b.n	4a <wolfSSL_CTX_check_private_key+0x4a>
        return MEMORY_E;
  70:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  74:	e7e9      	b.n	4a <wolfSSL_CTX_check_private_key+0x4a>

Disassembly of section .text.wolfSSL_use_certificate_ASN1:

00000000 <wolfSSL_use_certificate_ASN1>:
{
   0:	b510      	push	{r4, lr}
   2:	4603      	mov	r3, r0
   4:	b088      	sub	sp, #32
   6:	4608      	mov	r0, r1
    if (der != NULL && ssl != NULL) {
   8:	b189      	cbz	r1, 2e <wolfSSL_use_certificate_ASN1+0x2e>
   a:	b193      	cbz	r3, 32 <wolfSSL_use_certificate_ASN1+0x32>
        if (ProcessBuffer(NULL, der, derSz, WOLFSSL_FILETYPE_ASN1, CERT_TYPE,
   c:	f993 0270 	ldrsb.w	r0, [r3, #624]	; 0x270
  10:	43c0      	mvns	r0, r0
  12:	0fc0      	lsrs	r0, r0, #31
  14:	9004      	str	r0, [sp, #16]
  16:	ac07      	add	r4, sp, #28
  18:	2000      	movs	r0, #0
  1a:	e9cd 3401 	strd	r3, r4, [sp, #4]
  1e:	9003      	str	r0, [sp, #12]
  20:	2302      	movs	r3, #2
  22:	9000      	str	r0, [sp, #0]
  24:	f7ff fffe 	bl	0 <wolfSSL_use_certificate_ASN1>
  28:	1e43      	subs	r3, r0, #1
  2a:	4258      	negs	r0, r3
  2c:	4158      	adcs	r0, r3
}
  2e:	b008      	add	sp, #32
  30:	bd10      	pop	{r4, pc}
    return WOLFSSL_FAILURE;
  32:	4618      	mov	r0, r3
  34:	e7fb      	b.n	2e <wolfSSL_use_certificate_ASN1+0x2e>

Disassembly of section .text.wolfSSL_CTX_SetTmpEC_DHE_Sz:

00000000 <wolfSSL_CTX_SetTmpEC_DHE_Sz>:
    if (ctx == NULL)
   0:	b180      	cbz	r0, 24 <wolfSSL_CTX_SetTmpEC_DHE_Sz+0x24>
    if (sz == 0) {
   2:	b939      	cbnz	r1, 14 <wolfSSL_CTX_SetTmpEC_DHE_Sz+0x14>
        if (ctx->privateKeyType != ecc_dsa_sa_algo)
   4:	7f03      	ldrb	r3, [r0, #28]
   6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   a:	2b03      	cmp	r3, #3
   c:	d108      	bne.n	20 <wolfSSL_CTX_SetTmpEC_DHE_Sz+0x20>
        if (ctx->privateKeySz == 0) {
   e:	6a01      	ldr	r1, [r0, #32]
  10:	b141      	cbz	r1, 24 <wolfSSL_CTX_SetTmpEC_DHE_Sz+0x24>
        sz = (word16)ctx->privateKeySz;
  12:	b289      	uxth	r1, r1
    if (sz < ECC_MINSIZE)
  14:	f1a1 031c 	sub.w	r3, r1, #28
  18:	2b26      	cmp	r3, #38	; 0x26
  1a:	d803      	bhi.n	24 <wolfSSL_CTX_SetTmpEC_DHE_Sz+0x24>
    ctx->eccTempKeySz = sz;
  1c:	f8a0 1058 	strh.w	r1, [r0, #88]	; 0x58
            return WOLFSSL_SUCCESS;
  20:	2001      	movs	r0, #1
  22:	4770      	bx	lr
        return BAD_FUNC_ARG;
  24:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  28:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetTmpEC_DHE_Sz:

00000000 <wolfSSL_SetTmpEC_DHE_Sz>:
    if (ssl == NULL)
   0:	b138      	cbz	r0, 12 <wolfSSL_SetTmpEC_DHE_Sz+0x12>
    if (sz < ECC_MINSIZE)
   2:	f1a1 031c 	sub.w	r3, r1, #28
   6:	2b26      	cmp	r3, #38	; 0x26
   8:	d803      	bhi.n	12 <wolfSSL_SetTmpEC_DHE_Sz+0x12>
    ssl->eccTempKeySz = sz;
   a:	f8a0 12a4 	strh.w	r1, [r0, #676]	; 0x2a4
    return WOLFSSL_SUCCESS;
   e:	2001      	movs	r0, #1
  10:	4770      	bx	lr
        return BAD_FUNC_ARG;
  12:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_set_verify:

00000000 <wolfSSL_CTX_set_verify>:

WOLFSSL_ABI
void wolfSSL_CTX_set_verify(WOLFSSL_CTX* ctx, int mode, VerifyCallback vc)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4615      	mov	r5, r2
    SetVerifyOptions opts;

    WOLFSSL_ENTER("wolfSSL_CTX_set_verify");
    if (ctx == NULL)
   4:	4604      	mov	r4, r0
   6:	b1b8      	cbz	r0, 38 <wolfSSL_CTX_set_verify+0x38>
        return;

    opts = ModeToVerifyOptions(mode);
   8:	4608      	mov	r0, r1
   a:	f7ff fffe 	bl	0 <wolfSSL_CTX_set_verify>

    ctx->verifyNone     = opts.verifyNone;
    ctx->verifyPeer     = opts.verifyPeer;
   e:	f3c0 0200 	ubfx	r2, r0, #0, #1
  12:	f000 0302 	and.w	r3, r0, #2
  16:	4313      	orrs	r3, r2
    ctx->failNoCert     = opts.failNoCert;
  18:	f3c0 0280 	ubfx	r2, r0, #2, #1
    ctx->verifyPeer     = opts.verifyPeer;
  1c:	ea43 0382 	orr.w	r3, r3, r2, lsl #2
  20:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
    ctx->failNoCertxPSK = opts.failNoCertxPSK;
#if defined(WOLFSSL_TLS13) && defined(WOLFSSL_POST_HANDSHAKE_AUTH)
    ctx->verifyPostHandshake = opts.verifyPostHandshake;
#endif

    ctx->verifyCallback = vc;
  24:	64a5      	str	r5, [r4, #72]	; 0x48
    ctx->failNoCertxPSK = opts.failNoCertxPSK;
  26:	f3c0 01c0 	ubfx	r1, r0, #3, #1
    ctx->verifyPeer     = opts.verifyPeer;
  2a:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
  2e:	f022 020f 	bic.w	r2, r2, #15
  32:	4313      	orrs	r3, r2
  34:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
}
  38:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.wolfSSL_set_verify:

00000000 <wolfSSL_set_verify>:
}
#endif


void wolfSSL_set_verify(WOLFSSL* ssl, int mode, VerifyCallback vc)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
   6:	4608      	mov	r0, r1
    SetVerifyOptions opts;

    WOLFSSL_ENTER("wolfSSL_set_verify");
    if (ssl == NULL)
   8:	b164      	cbz	r4, 24 <wolfSSL_set_verify+0x24>
        return;

    opts = ModeToVerifyOptions(mode);
   a:	f7ff fffe 	bl	0 <wolfSSL_set_verify>

    ssl->options.verifyNone = opts.verifyNone;
    ssl->options.verifyPeer = opts.verifyPeer;
   e:	0183      	lsls	r3, r0, #6
  10:	f8b4 0270 	ldrh.w	r0, [r4, #624]	; 0x270
    ssl->options.failNoCertxPSK = opts.failNoCertxPSK;
#if defined(WOLFSSL_TLS13) && defined(WOLFSSL_POST_HANDSHAKE_AUTH)
    ssl->options.verifyPostHandshake = opts.verifyPostHandshake;
#endif

    ssl->verifyCallback = vc;
  14:	6225      	str	r5, [r4, #32]
    ssl->options.verifyPeer = opts.verifyPeer;
  16:	f403 7370 	and.w	r3, r3, #960	; 0x3c0
  1a:	f420 7070 	bic.w	r0, r0, #960	; 0x3c0
  1e:	4303      	orrs	r3, r0
  20:	f8a4 3270 	strh.w	r3, [r4, #624]	; 0x270
}
  24:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.wolfSSL_set_verify_result:

00000000 <wolfSSL_set_verify_result>:
    ssl->peerVerifyRet = v;
#else
    (void)v;
    WOLFSSL_STUB("wolfSSL_set_verify_result");
#endif
}
   0:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetCertCbCtx:

00000000 <wolfSSL_SetCertCbCtx>:

/* store user ctx for verify callback */
void wolfSSL_SetCertCbCtx(WOLFSSL* ssl, void* ctx)
{
    WOLFSSL_ENTER("wolfSSL_SetCertCbCtx");
    if (ssl)
   0:	b100      	cbz	r0, 4 <wolfSSL_SetCertCbCtx+0x4>
        ssl->verifyCbCtx = ctx;
   2:	61c1      	str	r1, [r0, #28]
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_SetCertCbCtx:

00000000 <wolfSSL_CTX_SetCertCbCtx>:

/* store user ctx for verify callback */
void wolfSSL_CTX_SetCertCbCtx(WOLFSSL_CTX* ctx, void* userCtx)
{
    WOLFSSL_ENTER("wolfSSL_CTX_SetCertCbCtx");
    if (ctx)
   0:	b100      	cbz	r0, 4 <wolfSSL_CTX_SetCertCbCtx+0x4>
        ctx->verifyCbCtx = userCtx;
   2:	64c1      	str	r1, [r0, #76]	; 0x4c
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_SetCACb:

00000000 <wolfSSL_CTX_SetCACb>:


/* store context CA Cache addition callback */
void wolfSSL_CTX_SetCACb(WOLFSSL_CTX* ctx, CallbackCACache cb)
{
    if (ctx && ctx->cm)
   0:	b110      	cbz	r0, 8 <wolfSSL_CTX_SetCACb+0x8>
   2:	6a83      	ldr	r3, [r0, #40]	; 0x28
   4:	b103      	cbz	r3, 8 <wolfSSL_CTX_SetCACb+0x8>
        ctx->cm->caCacheCallback = cb;
   6:	6459      	str	r1, [r3, #68]	; 0x44
}
   8:	4770      	bx	lr

Disassembly of section .text.wolfSSL_load_error_strings:

00000000 <wolfSSL_load_error_strings>:


void wolfSSL_load_error_strings(void)
{
    /* compatibility only */
}
   0:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_set_cipher_list:

00000000 <wolfSSL_CTX_set_cipher_list>:

#endif


int wolfSSL_CTX_set_cipher_list(WOLFSSL_CTX* ctx, const char* list)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    WOLFSSL_ENTER("wolfSSL_CTX_set_cipher_list");

    if (ctx == NULL)
   4:	4604      	mov	r4, r0
   6:	b908      	cbnz	r0, c <wolfSSL_CTX_set_cipher_list+0xc>
        return WOLFSSL_FAILURE;
   8:	2000      	movs	r0, #0
    return wolfSSL_parse_cipher_list(ctx, ctx->suites, list);
#else
    return (SetCipherList(ctx, ctx->suites, list)) ?
        WOLFSSL_SUCCESS : WOLFSSL_FAILURE;
#endif
}
   a:	bd38      	pop	{r3, r4, r5, pc}
    if (AllocateCtxSuites(ctx) != 0)
   c:	f7ff fffe 	bl	0 <AllocateCtxSuites>
  10:	2800      	cmp	r0, #0
  12:	d1f9      	bne.n	8 <wolfSSL_CTX_set_cipher_list+0x8>
    return (SetCipherList(ctx, ctx->suites, list)) ?
  14:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  16:	462a      	mov	r2, r5
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <SetCipherList>
        WOLFSSL_SUCCESS : WOLFSSL_FAILURE;
  1e:	3800      	subs	r0, #0
  20:	bf18      	it	ne
  22:	2001      	movne	r0, #1
  24:	e7f1      	b.n	a <wolfSSL_CTX_set_cipher_list+0xa>

Disassembly of section .text.wolfSSL_set_cipher_list:

00000000 <wolfSSL_set_cipher_list>:
        WOLFSSL_SUCCESS : WOLFSSL_FAILURE;
}
#endif /* OPENSSL_EXTRA || WOLFSSL_SET_CIPHER_BYTES */

int wolfSSL_set_cipher_list(WOLFSSL* ssl, const char* list)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    WOLFSSL_ENTER("wolfSSL_set_cipher_list");

    if (ssl == NULL || ssl->ctx == NULL) {
   4:	4604      	mov	r4, r0
   6:	b908      	cbnz	r0, c <wolfSSL_set_cipher_list+0xc>
        return WOLFSSL_FAILURE;
   8:	2000      	movs	r0, #0
#else
    return (SetCipherList(ssl->ctx, ssl->suites, list)) ?
        WOLFSSL_SUCCESS :
        WOLFSSL_FAILURE;
#endif
}
   a:	bd38      	pop	{r3, r4, r5, pc}
    if (ssl == NULL || ssl->ctx == NULL) {
   c:	6803      	ldr	r3, [r0, #0]
   e:	2b00      	cmp	r3, #0
  10:	d0fa      	beq.n	8 <wolfSSL_set_cipher_list+0x8>
    if (AllocateSuites(ssl) != 0)
  12:	f7ff fffe 	bl	0 <AllocateSuites>
  16:	2800      	cmp	r0, #0
  18:	d1f6      	bne.n	8 <wolfSSL_set_cipher_list+0x8>
    return (SetCipherList(ssl->ctx, ssl->suites, list)) ?
  1a:	e9d4 0100 	ldrd	r0, r1, [r4]
  1e:	462a      	mov	r2, r5
  20:	f7ff fffe 	bl	0 <SetCipherList>
        WOLFSSL_SUCCESS :
  24:	3800      	subs	r0, #0
  26:	bf18      	it	ne
  28:	2001      	movne	r0, #1
  2a:	e7ee      	b.n	a <wolfSSL_set_cipher_list+0xa>

Disassembly of section .text.wolfSSL_dtls_get_using_nonblock:

00000000 <wolfSSL_dtls_get_using_nonblock>:
    else {
        WOLFSSL_MSG("wolfSSL_dtls_get_using_nonblock() is "
                    "DEPRECATED for non-DTLS use.");
    }
    return useNb;
}
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wolfSSL_dtls_set_using_nonblock:

00000000 <wolfSSL_dtls_set_using_nonblock>:
   0:	4770      	bx	lr

Disassembly of section .text.wolfSSLv23_client_method_ex:

00000000 <wolfSSLv23_client_method_ex>:
    WOLFSSL_METHOD* wolfSSLv23_client_method(void)
    {
        return wolfSSLv23_client_method_ex(NULL);
    }
    WOLFSSL_METHOD* wolfSSLv23_client_method_ex(void* heap)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
   2:	2004      	movs	r0, #4
   4:	f7ff fffe 	bl	0 <malloc>
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("wolfSSLv23_client_method_ex");
        if (method) {
   8:	4604      	mov	r4, r0
   a:	b138      	cbz	r0, 1c <wolfSSLv23_client_method_ex+0x1c>
    #if !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
        #if defined(WOLFSSL_TLS13)
            InitSSL_Method(method, MakeTLSv1_3());
        #elif !defined(WOLFSSL_NO_TLS12)
            InitSSL_Method(method, MakeTLSv1_2());
   c:	f7ff fffe 	bl	0 <MakeTLSv1_2>
  10:	f8ad 0004 	strh.w	r0, [sp, #4]
  14:	9901      	ldr	r1, [sp, #4]
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <InitSSL_Method>
    #if !defined(NO_OLD_TLS) || defined(WOLFSSL_TLS13)
            method->downgrade = 1;
    #endif
        }
        return method;
    }
  1c:	4620      	mov	r0, r4
  1e:	b002      	add	sp, #8
  20:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSLv23_client_method:

00000000 <wolfSSLv23_client_method>:
        return wolfSSLv23_client_method_ex(NULL);
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfSSLv23_client_method>

Disassembly of section .text.wolfSSL_connect:

00000000 <wolfSSL_connect>:

    /* please see note at top of README if you get an error from connect */
    WOLFSSL_ABI
    int wolfSSL_connect(WOLFSSL* ssl)
    {
   0:	b538      	push	{r3, r4, r5, lr}

        #ifdef HAVE_ERRNO_H
            errno = 0;
        #endif

        if (ssl == NULL)
   2:	4604      	mov	r4, r0
   4:	2800      	cmp	r0, #0
   6:	f000 80ea 	beq.w	1de <wolfSSL_connect+0x1de>

        WOLFSSL_ENTER("wolfSSL_connect");

        /* make sure this wolfSSL object has arrays and rng setup. Protects
         * case where the WOLFSSL object is reused via wolfSSL_clear() */
        if ((ret = ReinitSSL(ssl, ssl->ctx, 0)) != 0) {
   a:	6801      	ldr	r1, [r0, #0]
   c:	2200      	movs	r2, #0
   e:	f7ff fffe 	bl	0 <ReinitSSL>
  12:	4605      	mov	r5, r0
  14:	bbb0      	cbnz	r0, 84 <wolfSSL_connect+0x84>
                return WOLFSSL_FATAL_ERROR;
            }
        }
#endif /* WOLFSSL_WOLFSENTRY_HOOKS */

        if (ssl->options.side != WOLFSSL_CLIENT_END) {
  16:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  1a:	f003 0330 	and.w	r3, r3, #48	; 0x30
  1e:	2b10      	cmp	r3, #16
  20:	d003      	beq.n	2a <wolfSSL_connect+0x2a>
            ssl->error = SIDE_ERROR;
  22:	4b70      	ldr	r3, [pc, #448]	; (1e4 <wolfSSL_connect+0x1e4>)
    #if !defined(WOLFSSL_NO_TLS12) || !defined(NO_OLD_TLS)
        case FIRST_REPLY_SECOND :
            /* CLIENT: Fail-safe for Server Authentication. */
            if (!ssl->options.peerAuthGood) {
                WOLFSSL_MSG("Server authentication did not happen");
                ssl->error = NO_PEER_VERIFY;
  24:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
                return WOLFSSL_FATAL_ERROR;
  28:	e02a      	b.n	80 <wolfSSL_connect+0x80>
        advanceState = ssl->fragOffset == 0 &&
  2a:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
  2e:	b94b      	cbnz	r3, 44 <wolfSSL_connect+0x44>
            (ssl->options.connectState == CONNECT_BEGIN ||
  30:	f894 5281 	ldrb.w	r5, [r4, #641]	; 0x281
        advanceState = ssl->fragOffset == 0 &&
  34:	f015 0ffd 	tst.w	r5, #253	; 0xfd
  38:	d026      	beq.n	88 <wolfSSL_connect+0x88>
             ssl->options.connectState == HELLO_AGAIN ||
  3a:	3d04      	subs	r5, #4
  3c:	2d04      	cmp	r5, #4
  3e:	bf8c      	ite	hi
  40:	2500      	movhi	r5, #0
  42:	2501      	movls	r5, #1
        if (ssl->buffers.outputBuffer.length > 0
  44:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
  48:	b1a3      	cbz	r3, 74 <wolfSSL_connect+0x74>
            ret = SendBuffered(ssl);
  4a:	4620      	mov	r0, r4
  4c:	f7ff fffe 	bl	0 <SendBuffered>
            if (ret == 0) {
  50:	b9a0      	cbnz	r0, 7c <wolfSSL_connect+0x7c>
                if (ssl->fragOffset == 0 && !ssl->options.buildingMsg) {
  52:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
  56:	b96b      	cbnz	r3, 74 <wolfSSL_connect+0x74>
  58:	f894 1276 	ldrb.w	r1, [r4, #630]	; 0x276
  5c:	f011 0108 	ands.w	r1, r1, #8
  60:	d108      	bne.n	74 <wolfSSL_connect+0x74>
                    if (advanceState) {
  62:	b13d      	cbz	r5, 74 <wolfSSL_connect+0x74>
                        ssl->options.connectState++;
  64:	f894 3281 	ldrb.w	r3, [r4, #641]	; 0x281
  68:	3301      	adds	r3, #1
  6a:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
                        FreeAsyncCtx(ssl, 0);
  6e:	4620      	mov	r0, r4
  70:	f7ff fffe 	bl	0 <FreeAsyncCtx>
        ret = RetrySendAlert(ssl);
  74:	4620      	mov	r0, r4
  76:	f7ff fffe 	bl	0 <RetrySendAlert>
        if (ret != 0) {
  7a:	b138      	cbz	r0, 8c <wolfSSL_connect+0x8c>
                ssl->error = ret;
  7c:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
                return WOLFSSL_FATAL_ERROR;
  80:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
        default:
            WOLFSSL_MSG("Unknown connect state ERROR");
            return WOLFSSL_FATAL_ERROR; /* unknown connect state */
        }
    #endif /* !WOLFSSL_NO_TLS12 || !NO_OLD_TLS || !WOLFSSL_TLS13 */
    }
  84:	4628      	mov	r0, r5
  86:	bd38      	pop	{r3, r4, r5, pc}
        advanceState = ssl->fragOffset == 0 &&
  88:	2501      	movs	r5, #1
  8a:	e7db      	b.n	44 <wolfSSL_connect+0x44>
        switch (ssl->options.connectState) {
  8c:	f894 3281 	ldrb.w	r3, [r4, #641]	; 0x281
  90:	2b0a      	cmp	r3, #10
  92:	d8f5      	bhi.n	80 <wolfSSL_connect+0x80>
  94:	e8df f003 	tbb	[pc, r3]
  98:	1c1c1006 	.word	0x1c1c1006
  9c:	5c312a1f 	.word	0x5c312a1f
  a0:	7066      	.short	0x7066
  a2:	77          	.byte	0x77
  a3:	00          	.byte	0x00
            if ( (ssl->error = SendClientHello(ssl)) != 0) {
  a4:	4620      	mov	r0, r4
  a6:	f7ff fffe 	bl	0 <SendClientHello>
  aa:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
  ae:	2800      	cmp	r0, #0
  b0:	d1e6      	bne.n	80 <wolfSSL_connect+0x80>
            ssl->options.connectState = CLIENT_HELLO_SENT;
  b2:	2301      	movs	r3, #1
  b4:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            neededState = ssl->options.resuming ? SERVER_FINISHED_COMPLETE :
  b8:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  bc:	f013 0f08 	tst.w	r3, #8
  c0:	bf18      	it	ne
  c2:	250a      	movne	r5, #10
                            neededState = SERVER_HELLODONE_COMPLETE;
  c4:	bf08      	it	eq
  c6:	2508      	moveq	r5, #8
            while (ssl->options.serverState < neededState) {
  c8:	f894 327c 	ldrb.w	r3, [r4, #636]	; 0x27c
  cc:	429d      	cmp	r5, r3
  ce:	dc1a      	bgt.n	106 <wolfSSL_connect+0x106>
            ssl->options.connectState = FIRST_REPLY_DONE;
  d0:	2304      	movs	r3, #4
  d2:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            if (ssl->options.certOnly)
  d6:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
  da:	065a      	lsls	r2, r3, #25
  dc:	d46d      	bmi.n	1ba <wolfSSL_connect+0x1ba>
                if (ssl->options.sendVerify) {
  de:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  e2:	079b      	lsls	r3, r3, #30
  e4:	d11d      	bne.n	122 <wolfSSL_connect+0x122>
            ssl->options.connectState = FIRST_REPLY_FIRST;
  e6:	2305      	movs	r3, #5
  e8:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            if (!ssl->options.resuming) {
  ec:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
  f0:	071d      	lsls	r5, r3, #28
  f2:	d51e      	bpl.n	132 <wolfSSL_connect+0x132>
            ssl->options.connectState = FIRST_REPLY_SECOND;
  f4:	2306      	movs	r3, #6
  f6:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            if (!ssl->options.peerAuthGood) {
  fa:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  fe:	0798      	lsls	r0, r3, #30
 100:	d41f      	bmi.n	142 <wolfSSL_connect+0x142>
                ssl->error = NO_PEER_VERIFY;
 102:	4b39      	ldr	r3, [pc, #228]	; (1e8 <wolfSSL_connect+0x1e8>)
 104:	e78e      	b.n	24 <wolfSSL_connect+0x24>
                if ( (ssl->error = ProcessReply(ssl)) < 0) {
 106:	4620      	mov	r0, r4
 108:	f7ff fffe 	bl	0 <ProcessReply>
 10c:	2800      	cmp	r0, #0
 10e:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 112:	dbb5      	blt.n	80 <wolfSSL_connect+0x80>
                else if (neededState == SERVER_FINISHED_COMPLETE) {
 114:	2d0a      	cmp	r5, #10
 116:	d1d7      	bne.n	c8 <wolfSSL_connect+0xc8>
                    if (!ssl->options.resuming) {
 118:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
                            neededState = SERVER_HELLODONE_COMPLETE;
 11c:	f013 0f08 	tst.w	r3, #8
 120:	e7d0      	b.n	c4 <wolfSSL_connect+0xc4>
                    if ( (ssl->error = SendCertificate(ssl)) != 0) {
 122:	4620      	mov	r0, r4
 124:	f7ff fffe 	bl	0 <SendCertificate>
 128:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 12c:	2800      	cmp	r0, #0
 12e:	d0da      	beq.n	e6 <wolfSSL_connect+0xe6>
 130:	e7a6      	b.n	80 <wolfSSL_connect+0x80>
                if ( (ssl->error = SendClientKeyExchange(ssl)) != 0) {
 132:	4620      	mov	r0, r4
 134:	f7ff fffe 	bl	0 <SendClientKeyExchange>
 138:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 13c:	2800      	cmp	r0, #0
 13e:	d0d9      	beq.n	f4 <wolfSSL_connect+0xf4>
 140:	e79e      	b.n	80 <wolfSSL_connect+0x80>
                if (ssl->options.sendVerify) {
 142:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
 146:	0799      	lsls	r1, r3, #30
 148:	d139      	bne.n	1be <wolfSSL_connect+0x1be>
            ssl->options.connectState = FIRST_REPLY_THIRD;
 14a:	2307      	movs	r3, #7
 14c:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            if ( (ssl->error = SendChangeCipher(ssl)) != 0) {
 150:	4620      	mov	r0, r4
 152:	f7ff fffe 	bl	0 <SendChangeCipher>
 156:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 15a:	2800      	cmp	r0, #0
 15c:	d190      	bne.n	80 <wolfSSL_connect+0x80>
            ssl->options.connectState = FIRST_REPLY_FOURTH;
 15e:	2308      	movs	r3, #8
 160:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            if ( (ssl->error = SendFinished(ssl)) != 0) {
 164:	4620      	mov	r0, r4
 166:	f7ff fffe 	bl	0 <SendFinished>
 16a:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 16e:	2800      	cmp	r0, #0
 170:	d186      	bne.n	80 <wolfSSL_connect+0x80>
            ssl->options.connectState = FINISHED_DONE;
 172:	2309      	movs	r3, #9
 174:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            while (ssl->options.serverState < SERVER_FINISHED_COMPLETE)
 178:	f894 327c 	ldrb.w	r3, [r4, #636]	; 0x27c
 17c:	2b09      	cmp	r3, #9
 17e:	d926      	bls.n	1ce <wolfSSL_connect+0x1ce>
            ssl->options.connectState = SECOND_REPLY_DONE;
 180:	230a      	movs	r3, #10
 182:	f884 3281 	strb.w	r3, [r4, #641]	; 0x281
            if (ssl->hsDoneCb) {
 186:	6b23      	ldr	r3, [r4, #48]	; 0x30
 188:	b12b      	cbz	r3, 196 <wolfSSL_connect+0x196>
                int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);
 18a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 18c:	4620      	mov	r0, r4
 18e:	4798      	blx	r3
                if (cbret < 0) {
 190:	2800      	cmp	r0, #0
 192:	f6ff af73 	blt.w	7c <wolfSSL_connect+0x7c>
            if (!ssl->options.dtls) {
 196:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 19a:	075a      	lsls	r2, r3, #29
 19c:	d406      	bmi.n	1ac <wolfSSL_connect+0x1ac>
                if (!ssl->options.keepResources) {
 19e:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
 1a2:	065b      	lsls	r3, r3, #25
 1a4:	d402      	bmi.n	1ac <wolfSSL_connect+0x1ac>
                    FreeHandshakeResources(ssl);
 1a6:	4620      	mov	r0, r4
 1a8:	f7ff fffe 	bl	0 <FreeHandshakeResources>
            FreeAsyncCtx(ssl, 1);
 1ac:	2101      	movs	r1, #1
 1ae:	4620      	mov	r0, r4
 1b0:	f7ff fffe 	bl	0 <FreeAsyncCtx>
            ssl->error = 0; /* clear the error */
 1b4:	2300      	movs	r3, #0
 1b6:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
                return WOLFSSL_SUCCESS;
 1ba:	2501      	movs	r5, #1
 1bc:	e762      	b.n	84 <wolfSSL_connect+0x84>
                    if ( (ssl->error = SendCertificateVerify(ssl)) != 0) {
 1be:	4620      	mov	r0, r4
 1c0:	f7ff fffe 	bl	0 <SendCertificateVerify>
 1c4:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 1c8:	2800      	cmp	r0, #0
 1ca:	d0be      	beq.n	14a <wolfSSL_connect+0x14a>
 1cc:	e758      	b.n	80 <wolfSSL_connect+0x80>
                if ( (ssl->error = ProcessReply(ssl)) < 0) {
 1ce:	4620      	mov	r0, r4
 1d0:	f7ff fffe 	bl	0 <ProcessReply>
 1d4:	2800      	cmp	r0, #0
 1d6:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 1da:	dacd      	bge.n	178 <wolfSSL_connect+0x178>
 1dc:	e750      	b.n	80 <wolfSSL_connect+0x80>
            return BAD_FUNC_ARG;
 1de:	f06f 05ac 	mvn.w	r5, #172	; 0xac
 1e2:	e74f      	b.n	84 <wolfSSL_connect+0x84>
 1e4:	fffffea8 	.word	0xfffffea8
 1e8:	fffffe86 	.word	0xfffffe86

Disassembly of section .text.wolfSSL_connect_cert:

00000000 <wolfSSL_connect_cert>:
{
   0:	b510      	push	{r4, lr}
    if (ssl == NULL)
   2:	4604      	mov	r4, r0
   4:	b168      	cbz	r0, 22 <wolfSSL_connect_cert+0x22>
    ssl->options.certOnly = 1;
   6:	f890 3274 	ldrb.w	r3, [r0, #628]	; 0x274
   a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   e:	f880 3274 	strb.w	r3, [r0, #628]	; 0x274
    ret = wolfSSL_connect(ssl);
  12:	f7ff fffe 	bl	0 <wolfSSL_connect_cert>
    ssl->options.certOnly   = 0;
  16:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
  1a:	f36f 1386 	bfc	r3, #6, #1
  1e:	f884 3274 	strb.w	r3, [r4, #628]	; 0x274
}
  22:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSLv23_server_method_ex:

00000000 <wolfSSLv23_server_method_ex>:
    {
        return wolfSSLv23_server_method_ex(NULL);
    }

    WOLFSSL_METHOD* wolfSSLv23_server_method_ex(void* heap)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
   2:	2004      	movs	r0, #4
   4:	f7ff fffe 	bl	0 <malloc>
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("wolfSSLv23_server_method_ex");
        if (method) {
   8:	4604      	mov	r4, r0
   a:	b148      	cbz	r0, 20 <wolfSSLv23_server_method_ex+0x20>
    #if !defined(NO_SHA256) || defined(WOLFSSL_SHA384) || defined(WOLFSSL_SHA512)
        #ifdef WOLFSSL_TLS13
            InitSSL_Method(method, MakeTLSv1_3());
        #elif !defined(WOLFSSL_NO_TLS12)
            InitSSL_Method(method, MakeTLSv1_2());
   c:	f7ff fffe 	bl	0 <MakeTLSv1_2>
  10:	f8ad 0004 	strh.w	r0, [sp, #4]
  14:	9901      	ldr	r1, [sp, #4]
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <InitSSL_Method>
        #endif
    #endif
    #if !defined(NO_OLD_TLS) || defined(WOLFSSL_TLS13)
            method->downgrade = 1;
    #endif
            method->side      = WOLFSSL_SERVER_END;
  1c:	2300      	movs	r3, #0
  1e:	70a3      	strb	r3, [r4, #2]
        }
        return method;
    }
  20:	4620      	mov	r0, r4
  22:	b002      	add	sp, #8
  24:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSLv23_server_method:

00000000 <wolfSSLv23_server_method>:
        return wolfSSLv23_server_method_ex(NULL);
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfSSLv23_server_method>

Disassembly of section .text.wolfSSL_accept:

00000000 <wolfSSL_accept>:


    WOLFSSL_ABI
    int wolfSSL_accept(WOLFSSL* ssl)
    {
   0:	b510      	push	{r4, lr}
#endif
        int ret = 0;

        (void)ret;

        if (ssl == NULL)
   2:	4604      	mov	r4, r0
   4:	b910      	cbnz	r0, c <wolfSSL_accept+0xc>
            ssl->error = ret;
            WOLFSSL_ERROR(ssl->error);
            return WOLFSSL_FATAL_ERROR;
        }

        switch (ssl->options.acceptState) {
   6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   a:	e114      	b.n	236 <wolfSSL_accept+0x236>
        if ((ret = ReinitSSL(ssl, ssl->ctx, 0)) != 0) {
   c:	6801      	ldr	r1, [r0, #0]
   e:	2200      	movs	r2, #0
  10:	f7ff fffe 	bl	0 <ReinitSSL>
  14:	2800      	cmp	r0, #0
  16:	f040 810e 	bne.w	236 <wolfSSL_accept+0x236>
        if (ssl->options.side != WOLFSSL_SERVER_END) {
  1a:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  1e:	f013 0f30 	tst.w	r3, #48	; 0x30
  22:	d003      	beq.n	2c <wolfSSL_accept+0x2c>
            ssl->error = SIDE_ERROR;
  24:	4ba7      	ldr	r3, [pc, #668]	; (2c4 <wolfSSL_accept+0x2c4>)
                    ssl->error = NO_PRIVATE_KEY;
  26:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
                    return WOLFSSL_FATAL_ERROR;
  2a:	e7ec      	b.n	6 <wolfSSL_accept+0x6>
                if (!ssl->buffers.certificate ||
  2c:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
  30:	b10b      	cbz	r3, 36 <wolfSSL_accept+0x36>
  32:	681b      	ldr	r3, [r3, #0]
  34:	b913      	cbnz	r3, 3c <wolfSSL_accept+0x3c>
                    ssl->error = NO_PRIVATE_KEY;
  36:	f46f 739e 	mvn.w	r3, #316	; 0x13c
  3a:	e7f4      	b.n	26 <wolfSSL_accept+0x26>
                if (!ssl->buffers.key || !ssl->buffers.key->buffer) {
  3c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
  40:	2b00      	cmp	r3, #0
  42:	d0f8      	beq.n	36 <wolfSSL_accept+0x36>
  44:	681b      	ldr	r3, [r3, #0]
  46:	2b00      	cmp	r3, #0
  48:	d0f5      	beq.n	36 <wolfSSL_accept+0x36>
        if (ssl->buffers.outputBuffer.length > 0
  4a:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
  4e:	b1e3      	cbz	r3, 8a <wolfSSL_accept+0x8a>
            ret = SendBuffered(ssl);
  50:	4620      	mov	r0, r4
  52:	f7ff fffe 	bl	0 <SendBuffered>
            if (ret == 0) {
  56:	b9e0      	cbnz	r0, 92 <wolfSSL_accept+0x92>
                if (ssl->fragOffset == 0 && !ssl->options.buildingMsg) {
  58:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
  5c:	b9ab      	cbnz	r3, 8a <wolfSSL_accept+0x8a>
  5e:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
  62:	071a      	lsls	r2, r3, #28
  64:	d411      	bmi.n	8a <wolfSSL_accept+0x8a>
                    if (ssl->options.acceptState == ACCEPT_FIRST_REPLY_DONE ||
  66:	f894 3282 	ldrb.w	r3, [r4, #642]	; 0x282
  6a:	f023 0208 	bic.w	r2, r3, #8
  6e:	3a04      	subs	r2, #4
  70:	2a02      	cmp	r2, #2
  72:	d903      	bls.n	7c <wolfSSL_accept+0x7c>
                        ssl->options.acceptState == CERT_SENT ||
  74:	f1a3 0208 	sub.w	r2, r3, #8
  78:	2a02      	cmp	r2, #2
  7a:	d806      	bhi.n	8a <wolfSSL_accept+0x8a>
                        ssl->options.acceptState++;
  7c:	3301      	adds	r3, #1
  7e:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
                        FreeAsyncCtx(ssl, 0);
  82:	2100      	movs	r1, #0
  84:	4620      	mov	r0, r4
  86:	f7ff fffe 	bl	0 <FreeAsyncCtx>
        ret = RetrySendAlert(ssl);
  8a:	4620      	mov	r0, r4
  8c:	f7ff fffe 	bl	0 <RetrySendAlert>
        if (ret != 0) {
  90:	b110      	cbz	r0, 98 <wolfSSL_accept+0x98>
        case ACCEPT_THIRD_REPLY_DONE :
#ifndef NO_HANDSHAKE_DONE_CB
            if (ssl->hsDoneCb) {
                int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);
                if (cbret < 0) {
                    ssl->error = cbret;
  92:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
                    WOLFSSL_MSG("HandShake Done Cb don't continue error");
                    return WOLFSSL_FATAL_ERROR;
  96:	e7b6      	b.n	6 <wolfSSL_accept+0x6>
        switch (ssl->options.acceptState) {
  98:	f894 3282 	ldrb.w	r3, [r4, #642]	; 0x282
  9c:	2b10      	cmp	r3, #16
  9e:	d8b2      	bhi.n	6 <wolfSSL_accept+0x6>
  a0:	a201      	add	r2, pc, #4	; (adr r2, a8 <wolfSSL_accept+0xa8>)
  a2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  a6:	bf00      	nop
  a8:	000000fb 	.word	0x000000fb
  ac:	00000007 	.word	0x00000007
  b0:	00000007 	.word	0x00000007
  b4:	00000007 	.word	0x00000007
  b8:	00000109 	.word	0x00000109
  bc:	0000011f 	.word	0x0000011f
  c0:	0000012f 	.word	0x0000012f
  c4:	00000007 	.word	0x00000007
  c8:	0000013f 	.word	0x0000013f
  cc:	0000014f 	.word	0x0000014f
  d0:	00000177 	.word	0x00000177
  d4:	00000185 	.word	0x00000185
  d8:	0000018f 	.word	0x0000018f
  dc:	000001bd 	.word	0x000001bd
  e0:	000001dd 	.word	0x000001dd
  e4:	000001f3 	.word	0x000001f3
  e8:	00000201 	.word	0x00000201
                if ( (ssl->error = ProcessReply(ssl)) < 0) {
  ec:	4620      	mov	r0, r4
  ee:	f7ff fffe 	bl	0 <ProcessReply>
  f2:	2800      	cmp	r0, #0
  f4:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
  f8:	db85      	blt.n	6 <wolfSSL_accept+0x6>
            while (ssl->options.clientState < CLIENT_HELLO_COMPLETE)
  fa:	f894 327d 	ldrb.w	r3, [r4, #637]	; 0x27d
  fe:	2b0b      	cmp	r3, #11
 100:	d9f4      	bls.n	ec <wolfSSL_accept+0xec>
            ssl->options.acceptState = ACCEPT_FIRST_REPLY_DONE;
 102:	2304      	movs	r3, #4
 104:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if ( (ssl->error = SendServerHello(ssl)) != 0) {
 108:	4620      	mov	r0, r4
 10a:	f7ff fffe 	bl	0 <SendServerHello>
 10e:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 112:	2800      	cmp	r0, #0
 114:	f47f af77 	bne.w	6 <wolfSSL_accept+0x6>
            ssl->options.acceptState = SERVER_HELLO_SENT;
 118:	2305      	movs	r3, #5
 11a:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
                if (!ssl->options.resuming)
 11e:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 122:	071b      	lsls	r3, r3, #28
 124:	f140 8088 	bpl.w	238 <wolfSSL_accept+0x238>
            ssl->options.acceptState = CERT_SENT;
 128:	2306      	movs	r3, #6
 12a:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if (!ssl->options.resuming)
 12e:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 132:	0718      	lsls	r0, r3, #28
 134:	f140 8089 	bpl.w	24a <wolfSSL_accept+0x24a>
            ssl->options.acceptState = CERT_STATUS_SENT;
 138:	2308      	movs	r3, #8
 13a:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if (!ssl->options.resuming)
 13e:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 142:	0719      	lsls	r1, r3, #28
 144:	f140 808a 	bpl.w	25c <wolfSSL_accept+0x25c>
            ssl->options.acceptState = KEY_EXCHANGE_SENT;
 148:	2309      	movs	r3, #9
 14a:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
                if (!ssl->options.resuming) {
 14e:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 152:	071a      	lsls	r2, r3, #28
 154:	d40c      	bmi.n	170 <wolfSSL_accept+0x170>
                    if (ssl->options.verifyPeer) {
 156:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
 15a:	065b      	lsls	r3, r3, #25
 15c:	f140 8087 	bpl.w	26e <wolfSSL_accept+0x26e>
                        if ( (ssl->error = SendCertificateRequest(ssl)) != 0) {
 160:	4620      	mov	r0, r4
 162:	f7ff fffe 	bl	0 <SendCertificateRequest>
 166:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 16a:	2800      	cmp	r0, #0
 16c:	f47f af4b 	bne.w	6 <wolfSSL_accept+0x6>
            ssl->options.acceptState = CERT_REQ_SENT;
 170:	230a      	movs	r3, #10
 172:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if (!ssl->options.resuming)
 176:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 17a:	0718      	lsls	r0, r3, #28
 17c:	d57e      	bpl.n	27c <wolfSSL_accept+0x27c>
            ssl->options.acceptState = SERVER_HELLO_DONE;
 17e:	230b      	movs	r3, #11
 180:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if (!ssl->options.resuming) {
 184:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 188:	0719      	lsls	r1, r3, #28
 18a:	f140 8088 	bpl.w	29e <wolfSSL_accept+0x29e>
            if (!ssl->options.resuming && ssl->options.verifyPeer &&
 18e:	f8b4 3270 	ldrh.w	r3, [r4, #624]	; 0x270
 192:	f403 6304 	and.w	r3, r3, #2112	; 0x840
 196:	2b40      	cmp	r3, #64	; 0x40
 198:	d10d      	bne.n	1b6 <wolfSSL_accept+0x1b6>
                !ssl->options.havePeerCert && !ssl->options.failNoCert) {
 19a:	f894 3274 	ldrb.w	r3, [r4, #628]	; 0x274
            if (!ssl->options.resuming && ssl->options.verifyPeer &&
 19e:	07da      	lsls	r2, r3, #31
 1a0:	d409      	bmi.n	1b6 <wolfSSL_accept+0x1b6>
                !ssl->options.havePeerCert && !ssl->options.failNoCert) {
 1a2:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 1a6:	07db      	lsls	r3, r3, #31
                ssl->options.peerAuthGood = 1;
 1a8:	bf5e      	ittt	pl
 1aa:	f894 3276 	ldrbpl.w	r3, [r4, #630]	; 0x276
 1ae:	f043 0302 	orrpl.w	r3, r3, #2
 1b2:	f884 3276 	strbpl.w	r3, [r4, #630]	; 0x276
            ssl->options.acceptState = TICKET_SENT;
 1b6:	230d      	movs	r3, #13
 1b8:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if (!ssl->options.peerAuthGood) {
 1bc:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
 1c0:	0798      	lsls	r0, r3, #30
 1c2:	f57f af20 	bpl.w	6 <wolfSSL_accept+0x6>
            if ( (ssl->error = SendChangeCipher(ssl)) != 0) {
 1c6:	4620      	mov	r0, r4
 1c8:	f7ff fffe 	bl	0 <SendChangeCipher>
 1cc:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 1d0:	2800      	cmp	r0, #0
 1d2:	f47f af18 	bne.w	6 <wolfSSL_accept+0x6>
            ssl->options.acceptState = CHANGE_CIPHER_SENT;
 1d6:	230e      	movs	r3, #14
 1d8:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if ( (ssl->error = SendFinished(ssl)) != 0) {
 1dc:	4620      	mov	r0, r4
 1de:	f7ff fffe 	bl	0 <SendFinished>
 1e2:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 1e6:	2800      	cmp	r0, #0
 1e8:	f47f af0d 	bne.w	6 <wolfSSL_accept+0x6>
            ssl->options.acceptState = ACCEPT_FINISHED_DONE;
 1ec:	230f      	movs	r3, #15
 1ee:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if (ssl->options.resuming) {
 1f2:	f894 3271 	ldrb.w	r3, [r4, #625]	; 0x271
 1f6:	0719      	lsls	r1, r3, #28
 1f8:	d45e      	bmi.n	2b8 <wolfSSL_accept+0x2b8>
            ssl->options.acceptState = ACCEPT_THIRD_REPLY_DONE;
 1fa:	2310      	movs	r3, #16
 1fc:	f884 3282 	strb.w	r3, [r4, #642]	; 0x282
            if (ssl->hsDoneCb) {
 200:	6b23      	ldr	r3, [r4, #48]	; 0x30
 202:	b12b      	cbz	r3, 210 <wolfSSL_accept+0x210>
                int cbret = ssl->hsDoneCb(ssl, ssl->hsDoneCtx);
 204:	6b61      	ldr	r1, [r4, #52]	; 0x34
 206:	4620      	mov	r0, r4
 208:	4798      	blx	r3
                if (cbret < 0) {
 20a:	2800      	cmp	r0, #0
 20c:	f6ff af41 	blt.w	92 <wolfSSL_accept+0x92>
                }
            }
#endif /* NO_HANDSHAKE_DONE_CB */

            if (!ssl->options.dtls) {
 210:	f894 3272 	ldrb.w	r3, [r4, #626]	; 0x272
 214:	075a      	lsls	r2, r3, #29
 216:	d406      	bmi.n	226 <wolfSSL_accept+0x226>
                if (!ssl->options.keepResources) {
 218:	f894 3275 	ldrb.w	r3, [r4, #629]	; 0x275
 21c:	065b      	lsls	r3, r3, #25
 21e:	d402      	bmi.n	226 <wolfSSL_accept+0x226>
                    FreeHandshakeResources(ssl);
 220:	4620      	mov	r0, r4
 222:	f7ff fffe 	bl	0 <FreeHandshakeResources>
                ssl->secure_renegotiation->startScr = 0;
            }
#endif /* WOLFSSL_ASYNC_CRYPT && HAVE_SECURE_RENEGOTIATION */
#if defined(WOLFSSL_ASYNC_IO) && !defined(WOLFSSL_ASYNC_CRYPT)
            /* Free the remaining async context if not using it for crypto */
            FreeAsyncCtx(ssl, 1);
 226:	4620      	mov	r0, r4
 228:	2101      	movs	r1, #1
 22a:	f7ff fffe 	bl	0 <FreeAsyncCtx>
                    WOLFSSL_ERROR(ssl->error);
                    return WOLFSSL_FATAL_ERROR;
                }
            }
#endif
            ssl->error = 0; /* clear the error */
 22e:	2300      	movs	r3, #0
 230:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114

            WOLFSSL_LEAVE("wolfSSL_accept", WOLFSSL_SUCCESS);
            return WOLFSSL_SUCCESS;
 234:	2001      	movs	r0, #1
        default :
            WOLFSSL_MSG("Unknown accept state ERROR");
            return WOLFSSL_FATAL_ERROR;
        }
#endif /* !WOLFSSL_NO_TLS12 */
    }
 236:	bd10      	pop	{r4, pc}
                    if ( (ssl->error = SendCertificate(ssl)) != 0) {
 238:	4620      	mov	r0, r4
 23a:	f7ff fffe 	bl	0 <SendCertificate>
 23e:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 242:	2800      	cmp	r0, #0
 244:	f43f af70 	beq.w	128 <wolfSSL_accept+0x128>
 248:	e6dd      	b.n	6 <wolfSSL_accept+0x6>
                if ( (ssl->error = SendCertificateStatus(ssl)) != 0) {
 24a:	4620      	mov	r0, r4
 24c:	f7ff fffe 	bl	0 <SendCertificateStatus>
 250:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 254:	2800      	cmp	r0, #0
 256:	f43f af6f 	beq.w	138 <wolfSSL_accept+0x138>
 25a:	e6d4      	b.n	6 <wolfSSL_accept+0x6>
                if ( (ssl->error = SendServerKeyExchange(ssl)) != 0) {
 25c:	4620      	mov	r0, r4
 25e:	f7ff fffe 	bl	0 <SendServerKeyExchange>
 262:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 266:	2800      	cmp	r0, #0
 268:	f43f af6e 	beq.w	148 <wolfSSL_accept+0x148>
 26c:	e6cb      	b.n	6 <wolfSSL_accept+0x6>
                        ssl->options.peerAuthGood = 1;
 26e:	f894 3276 	ldrb.w	r3, [r4, #630]	; 0x276
 272:	f043 0302 	orr.w	r3, r3, #2
 276:	f884 3276 	strb.w	r3, [r4, #630]	; 0x276
 27a:	e779      	b.n	170 <wolfSSL_accept+0x170>
                if ( (ssl->error = SendServerHelloDone(ssl)) != 0) {
 27c:	4620      	mov	r0, r4
 27e:	f7ff fffe 	bl	0 <SendServerHelloDone>
 282:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 286:	2800      	cmp	r0, #0
 288:	f43f af79 	beq.w	17e <wolfSSL_accept+0x17e>
 28c:	e6bb      	b.n	6 <wolfSSL_accept+0x6>
                    if ( (ssl->error = ProcessReply(ssl)) < 0) {
 28e:	4620      	mov	r0, r4
 290:	f7ff fffe 	bl	0 <ProcessReply>
 294:	2800      	cmp	r0, #0
 296:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 29a:	f6ff aeb4 	blt.w	6 <wolfSSL_accept+0x6>
                while (ssl->options.clientState < CLIENT_FINISHED_COMPLETE)
 29e:	f894 327d 	ldrb.w	r3, [r4, #637]	; 0x27d
 2a2:	2b0e      	cmp	r3, #14
 2a4:	d9f3      	bls.n	28e <wolfSSL_accept+0x28e>
 2a6:	e772      	b.n	18e <wolfSSL_accept+0x18e>
                    if ( (ssl->error = ProcessReply(ssl)) < 0) {
 2a8:	4620      	mov	r0, r4
 2aa:	f7ff fffe 	bl	0 <ProcessReply>
 2ae:	2800      	cmp	r0, #0
 2b0:	f8c4 0114 	str.w	r0, [r4, #276]	; 0x114
 2b4:	f6ff aea7 	blt.w	6 <wolfSSL_accept+0x6>
                while (ssl->options.clientState < CLIENT_FINISHED_COMPLETE) {
 2b8:	f894 327d 	ldrb.w	r3, [r4, #637]	; 0x27d
 2bc:	2b0e      	cmp	r3, #14
 2be:	d9f3      	bls.n	2a8 <wolfSSL_accept+0x2a8>
 2c0:	e79b      	b.n	1fa <wolfSSL_accept+0x1fa>
 2c2:	bf00      	nop
 2c4:	fffffea8 	.word	0xfffffea8

Disassembly of section .text.wolfSSL_negotiate:

00000000 <wolfSSL_negotiate>:
{
   0:	b510      	push	{r4, lr}
    if (ssl == NULL)
   2:	4604      	mov	r4, r0
   4:	b1a0      	cbz	r0, 30 <wolfSSL_negotiate+0x30>
    if (ssl->options.side == WOLFSSL_SERVER_END) {
   6:	f890 3270 	ldrb.w	r3, [r0, #624]	; 0x270
   a:	f013 0f30 	tst.w	r3, #48	; 0x30
   e:	d10c      	bne.n	2a <wolfSSL_negotiate+0x2a>
            err = wolfSSL_accept(ssl);
  10:	f7ff fffe 	bl	0 <wolfSSL_negotiate>
    if (ssl->options.side == WOLFSSL_CLIENT_END) {
  14:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  18:	f003 0330 	and.w	r3, r3, #48	; 0x30
  1c:	2b10      	cmp	r3, #16
  1e:	d109      	bne.n	34 <wolfSSL_negotiate+0x34>
            err = wolfSSL_connect(ssl);
  20:	4620      	mov	r0, r4
}
  22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            err = wolfSSL_connect(ssl);
  26:	f7ff bffe 	b.w	0 <wolfSSL_negotiate>
    int err = WOLFSSL_FATAL_ERROR;
  2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  2e:	e7f1      	b.n	14 <wolfSSL_negotiate+0x14>
        return WOLFSSL_FATAL_ERROR;
  30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  34:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSL_SetHsDoneCb:

00000000 <wolfSSL_SetHsDoneCb>:

int wolfSSL_SetHsDoneCb(WOLFSSL* ssl, HandShakeDoneCb cb, void* user_ctx)
{
    WOLFSSL_ENTER("wolfSSL_SetHsDoneCb");

    if (ssl == NULL)
   0:	b118      	cbz	r0, a <wolfSSL_SetHsDoneCb+0xa>
        return BAD_FUNC_ARG;

    ssl->hsDoneCb  = cb;
    ssl->hsDoneCtx = user_ctx;
   2:	e9c0 120c 	strd	r1, r2, [r0, #48]	; 0x30

    return WOLFSSL_SUCCESS;
   6:	2001      	movs	r0, #1
   8:	4770      	bx	lr
        return BAD_FUNC_ARG;
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_Cleanup:

00000000 <wolfSSL_Cleanup>:

#endif /* NO_HANDSHAKE_DONE_CB */

WOLFSSL_ABI
int wolfSSL_Cleanup(void)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int j;
#endif

    WOLFSSL_ENTER("wolfSSL_Cleanup");

    if (initRefCount == 0)
   2:	4d25      	ldr	r5, [pc, #148]	; (98 <wolfSSL_Cleanup+0x98>)
   4:	682b      	ldr	r3, [r5, #0]
   6:	2b00      	cmp	r3, #0
   8:	d040      	beq.n	8c <wolfSSL_Cleanup+0x8c>
        return ret;  /* possibly no init yet, but not failure either way */

    if ((count_mutex_valid == 1) && (wc_LockMutex(&count_mutex) != 0)) {
   a:	4e24      	ldr	r6, [pc, #144]	; (9c <wolfSSL_Cleanup+0x9c>)
   c:	6833      	ldr	r3, [r6, #0]
   e:	2b01      	cmp	r3, #1
  10:	d034      	beq.n	7c <wolfSSL_Cleanup+0x7c>
    int ret = WOLFSSL_SUCCESS; /* Only the first error will be returned */
  12:	2401      	movs	r4, #1
        WOLFSSL_MSG("Bad Lock Mutex count");
        ret = BAD_MUTEX_E;
    }

    release = initRefCount-- == 1;
  14:	682f      	ldr	r7, [r5, #0]
  16:	1e7b      	subs	r3, r7, #1
  18:	602b      	str	r3, [r5, #0]
    if (initRefCount < 0)
  1a:	682b      	ldr	r3, [r5, #0]
  1c:	2b00      	cmp	r3, #0
        initRefCount = 0;
  1e:	bfbc      	itt	lt
  20:	2300      	movlt	r3, #0
  22:	602b      	strlt	r3, [r5, #0]

    if (count_mutex_valid == 1) {
  24:	6833      	ldr	r3, [r6, #0]
  26:	2b01      	cmp	r3, #1
  28:	d132      	bne.n	90 <wolfSSL_Cleanup+0x90>
        wc_UnLockMutex(&count_mutex);
  2a:	481d      	ldr	r0, [pc, #116]	; (a0 <wolfSSL_Cleanup+0xa0>)
  2c:	f7ff fffe 	bl	0 <wc_UnLockMutex>
    }

    if (!release)
  30:	2f01      	cmp	r7, #1
  32:	d121      	bne.n	78 <wolfSSL_Cleanup+0x78>
    }
    clisession_mutex_valid = 0;
    #endif
#endif /* !NO_SESSION_CACHE */

    if ((count_mutex_valid == 1) && (wc_FreeMutex(&count_mutex) != 0)) {
  34:	6833      	ldr	r3, [r6, #0]
  36:	2b01      	cmp	r3, #1
  38:	d107      	bne.n	4a <wolfSSL_Cleanup+0x4a>
  3a:	4819      	ldr	r0, [pc, #100]	; (a0 <wolfSSL_Cleanup+0xa0>)
  3c:	f7ff fffe 	bl	0 <wc_FreeMutex>
  40:	b118      	cbz	r0, 4a <wolfSSL_Cleanup+0x4a>
        if (ret == WOLFSSL_SUCCESS)
            ret = BAD_MUTEX_E;
  42:	2c01      	cmp	r4, #1
  44:	bf08      	it	eq
  46:	f06f 0469 	mvneq.w	r4, #105	; 0x69
    }
    count_mutex_valid = 0;
  4a:	2300      	movs	r3, #0
  4c:	6033      	str	r3, [r6, #0]

#ifdef OPENSSL_EXTRA
    wolfSSL_RAND_Cleanup();
#endif

    if (wolfCrypt_Cleanup() != 0) {
  4e:	f7ff fffe 	bl	0 <wolfCrypt_Cleanup>
  52:	b118      	cbz	r0, 5c <wolfSSL_Cleanup+0x5c>
        WOLFSSL_MSG("Error with wolfCrypt_Cleanup call");
        if (ret == WOLFSSL_SUCCESS)
            ret = WC_CLEANUP_E;
  54:	2c01      	cmp	r4, #1
  56:	bf08      	it	eq
  58:	f06f 04f0 	mvneq.w	r4, #240	; 0xf0
            ret = WC_CLEANUP_E;
    }
#endif

#ifdef HAVE_GLOBAL_RNG
    if ((globalRNGMutex_valid == 1) && (wc_FreeMutex(&globalRNGMutex) != 0)) {
  5c:	4d11      	ldr	r5, [pc, #68]	; (a4 <wolfSSL_Cleanup+0xa4>)
  5e:	682b      	ldr	r3, [r5, #0]
  60:	2b01      	cmp	r3, #1
  62:	d107      	bne.n	74 <wolfSSL_Cleanup+0x74>
  64:	4810      	ldr	r0, [pc, #64]	; (a8 <wolfSSL_Cleanup+0xa8>)
  66:	f7ff fffe 	bl	0 <wc_FreeMutex>
  6a:	b118      	cbz	r0, 74 <wolfSSL_Cleanup+0x74>
        if (ret == WOLFSSL_SUCCESS)
            ret = BAD_MUTEX_E;
  6c:	2c01      	cmp	r4, #1
  6e:	bf08      	it	eq
  70:	f06f 0469 	mvneq.w	r4, #105	; 0x69
    }
    globalRNGMutex_valid = 0;
  74:	2300      	movs	r3, #0
  76:	602b      	str	r3, [r5, #0]
#ifdef WOLFSSL_MEM_FAIL_COUNT
    wc_MemFailCount_Free();
#endif

    return ret;
}
  78:	4620      	mov	r0, r4
  7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((count_mutex_valid == 1) && (wc_LockMutex(&count_mutex) != 0)) {
  7c:	4808      	ldr	r0, [pc, #32]	; (a0 <wolfSSL_Cleanup+0xa0>)
  7e:	f7ff fffe 	bl	0 <wc_LockMutex>
  82:	2800      	cmp	r0, #0
  84:	d0c5      	beq.n	12 <wolfSSL_Cleanup+0x12>
        ret = BAD_MUTEX_E;
  86:	f06f 0469 	mvn.w	r4, #105	; 0x69
  8a:	e7c3      	b.n	14 <wolfSSL_Cleanup+0x14>
        return ret;  /* possibly no init yet, but not failure either way */
  8c:	2401      	movs	r4, #1
  8e:	e7f3      	b.n	78 <wolfSSL_Cleanup+0x78>
    if (!release)
  90:	2f01      	cmp	r7, #1
  92:	d0da      	beq.n	4a <wolfSSL_Cleanup+0x4a>
  94:	e7f0      	b.n	78 <wolfSSL_Cleanup+0x78>
  96:	bf00      	nop
	...

Disassembly of section .text.wolfSSL_Init:

00000000 <wolfSSL_Init>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (initRefCount == 0) {
   2:	4c16      	ldr	r4, [pc, #88]	; (5c <wolfSSL_Init+0x5c>)
   4:	6823      	ldr	r3, [r4, #0]
   6:	b9bb      	cbnz	r3, 38 <wolfSSL_Init+0x38>
        if (wolfCrypt_Init() != 0) {
   8:	f7ff fffe 	bl	0 <wolfCrypt_Init>
   c:	bb10      	cbnz	r0, 54 <wolfSSL_Init+0x54>
            if (wc_InitMutex(&globalRNGMutex) != 0) {
   e:	4814      	ldr	r0, [pc, #80]	; (60 <wolfSSL_Init+0x60>)
  10:	f7ff fffe 	bl	0 <wc_InitMutex>
  14:	b130      	cbz	r0, 24 <wolfSSL_Init+0x24>
                ret = BAD_MUTEX_E;
  16:	f06f 0569 	mvn.w	r5, #105	; 0x69
        initRefCount = 1; /* Force cleanup */
  1a:	2301      	movs	r3, #1
  1c:	6023      	str	r3, [r4, #0]
        (void)wolfSSL_Cleanup(); /* Ignore any error from cleanup */
  1e:	f7ff fffe 	bl	0 <wolfSSL_Init>
    return ret;
  22:	e015      	b.n	50 <wolfSSL_Init+0x50>
                globalRNGMutex_valid = 1;
  24:	4b0f      	ldr	r3, [pc, #60]	; (64 <wolfSSL_Init+0x64>)
            if (wc_InitMutex(&count_mutex) != 0) {
  26:	4810      	ldr	r0, [pc, #64]	; (68 <wolfSSL_Init+0x68>)
                globalRNGMutex_valid = 1;
  28:	2501      	movs	r5, #1
  2a:	601d      	str	r5, [r3, #0]
            if (wc_InitMutex(&count_mutex) != 0) {
  2c:	f7ff fffe 	bl	0 <wc_InitMutex>
  30:	2800      	cmp	r0, #0
  32:	d1f0      	bne.n	16 <wolfSSL_Init+0x16>
                count_mutex_valid = 1;
  34:	4b0d      	ldr	r3, [pc, #52]	; (6c <wolfSSL_Init+0x6c>)
  36:	601d      	str	r5, [r3, #0]
        if (wc_LockMutex(&count_mutex) != 0) {
  38:	480b      	ldr	r0, [pc, #44]	; (68 <wolfSSL_Init+0x68>)
  3a:	f7ff fffe 	bl	0 <wc_LockMutex>
  3e:	2800      	cmp	r0, #0
  40:	d1e9      	bne.n	16 <wolfSSL_Init+0x16>
            initRefCount++;
  42:	6823      	ldr	r3, [r4, #0]
            wc_UnLockMutex(&count_mutex);
  44:	4808      	ldr	r0, [pc, #32]	; (68 <wolfSSL_Init+0x68>)
            initRefCount++;
  46:	3301      	adds	r3, #1
  48:	6023      	str	r3, [r4, #0]
            wc_UnLockMutex(&count_mutex);
  4a:	f7ff fffe 	bl	0 <wc_UnLockMutex>
  4e:	2501      	movs	r5, #1
}
  50:	4628      	mov	r0, r5
  52:	bd38      	pop	{r3, r4, r5, pc}
  54:	f06f 05e3 	mvn.w	r5, #227	; 0xe3
  58:	e7df      	b.n	1a <wolfSSL_Init+0x1a>
  5a:	bf00      	nop
	...

Disassembly of section .text.wolfSSL_CTX_new_ex:

00000000 <wolfSSL_CTX_new_ex>:
    if (initRefCount == 0) {
   0:	4b11      	ldr	r3, [pc, #68]	; (48 <wolfSSL_CTX_new_ex+0x48>)
   2:	681b      	ldr	r3, [r3, #0]
{
   4:	b570      	push	{r4, r5, r6, lr}
   6:	4605      	mov	r5, r0
   8:	460e      	mov	r6, r1
    if (initRefCount == 0) {
   a:	b95b      	cbnz	r3, 24 <wolfSSL_CTX_new_ex+0x24>
        int ret = wolfSSL_Init();
   c:	f7ff fffe 	bl	0 <wolfSSL_CTX_new_ex>
        if (ret != WOLFSSL_SUCCESS) {
  10:	2801      	cmp	r0, #1
  12:	d007      	beq.n	24 <wolfSSL_CTX_new_ex+0x24>
            if (method != NULL) {
  14:	b915      	cbnz	r5, 1c <wolfSSL_CTX_new_ex+0x1c>
            ctx = NULL;
  16:	2400      	movs	r4, #0
}
  18:	4620      	mov	r0, r4
  1a:	bd70      	pop	{r4, r5, r6, pc}
                XFREE(method, heap, DYNAMIC_TYPE_METHOD);
  1c:	4628      	mov	r0, r5
  1e:	f7ff fffe 	bl	0 <free>
  22:	e7f8      	b.n	16 <wolfSSL_CTX_new_ex+0x16>
    if (method == NULL)
  24:	2d00      	cmp	r5, #0
  26:	d0f6      	beq.n	16 <wolfSSL_CTX_new_ex+0x16>
    ctx = (WOLFSSL_CTX*)XMALLOC(sizeof(WOLFSSL_CTX), heap, DYNAMIC_TYPE_CTX);
  28:	206c      	movs	r0, #108	; 0x6c
  2a:	f7ff fffe 	bl	0 <malloc>
  2e:	4604      	mov	r4, r0
    if (ctx) {
  30:	2800      	cmp	r0, #0
  32:	d0f3      	beq.n	1c <wolfSSL_CTX_new_ex+0x1c>
        ret = InitSSL_Ctx(ctx, method, heap);
  34:	4632      	mov	r2, r6
  36:	4629      	mov	r1, r5
  38:	f7ff fffe 	bl	0 <InitSSL_Ctx>
        if (ret < 0) {
  3c:	2800      	cmp	r0, #0
  3e:	daeb      	bge.n	18 <wolfSSL_CTX_new_ex+0x18>
            wolfSSL_CTX_free(ctx);
  40:	4620      	mov	r0, r4
  42:	f7ff fffe 	bl	0 <wolfSSL_CTX_new_ex>
  46:	e7e6      	b.n	16 <wolfSSL_CTX_new_ex+0x16>
  48:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_CTX_new:

00000000 <wolfSSL_CTX_new>:
    return wolfSSL_CTX_new_ex(method, NULL);
   0:	2100      	movs	r1, #0
   2:	f7ff bffe 	b.w	0 <wolfSSL_CTX_new>

Disassembly of section .text.wolfSSL_library_init:

00000000 <wolfSSL_library_init>:
{
   0:	b508      	push	{r3, lr}
    if (wolfSSL_Init() == WOLFSSL_SUCCESS)
   2:	f7ff fffe 	bl	0 <wolfSSL_library_init>
        return WOLFSSL_FATAL_ERROR;
   6:	2801      	cmp	r0, #1
}
   8:	bf18      	it	ne
   a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   e:	bd08      	pop	{r3, pc}

Disassembly of section .text.SetupSession:

00000000 <SetupSession>:

void SetupSession(WOLFSSL* ssl)
{
   0:	b538      	push	{r3, r4, r5, lr}
    WOLFSSL_SESSION* session = ssl->session;
   2:	f8d0 40f4 	ldr.w	r4, [r0, #244]	; 0xf4
{
   6:	4605      	mov	r5, r0

    WOLFSSL_ENTER("SetupSession");

    if (!IsAtLeastTLSv1_3(ssl->version) && ssl->arrays != NULL) {
   8:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
   c:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_3>
  10:	b988      	cbnz	r0, 36 <SetupSession+0x36>
  12:	68a9      	ldr	r1, [r5, #8]
  14:	b179      	cbz	r1, 36 <SetupSession+0x36>
        /* Make sure the session ID is available when the user calls any
         * get_session API */
        if (!session->haveAltSessionID) {
  16:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  1a:	07db      	lsls	r3, r3, #31
            XMEMCPY(session->sessionID, ssl->arrays->sessionID, ID_LEN);
  1c:	f104 003c 	add.w	r0, r4, #60	; 0x3c
  20:	f04f 0220 	mov.w	r2, #32
        if (!session->haveAltSessionID) {
  24:	d435      	bmi.n	92 <SetupSession+0x92>
            XMEMCPY(session->sessionID, ssl->arrays->sessionID, ID_LEN);
  26:	3154      	adds	r1, #84	; 0x54
  28:	f7ff fffe 	bl	0 <memcpy>
            session->sessionIDSz = ssl->arrays->sessionIDSz;
  2c:	68ab      	ldr	r3, [r5, #8]
  2e:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
        }
        else {
            XMEMCPY(session->sessionID, session->altSessionID, ID_LEN);
            session->sessionIDSz = ID_LEN;
  32:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
        }
    }
    session->side = (byte)ssl->options.side;
  36:	f895 3270 	ldrb.w	r3, [r5, #624]	; 0x270
  3a:	f3c3 1301 	ubfx	r3, r3, #4, #2
  3e:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    if (!IsAtLeastTLSv1_3(ssl->version) && ssl->arrays != NULL)
  42:	f8d5 013c 	ldr.w	r0, [r5, #316]	; 0x13c
  46:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_3>
  4a:	b938      	cbnz	r0, 5c <SetupSession+0x5c>
  4c:	68a9      	ldr	r1, [r5, #8]
  4e:	b129      	cbz	r1, 5c <SetupSession+0x5c>
        XMEMCPY(session->masterSecret, ssl->arrays->masterSecret, SECRET_LEN);
  50:	2230      	movs	r2, #48	; 0x30
  52:	3175      	adds	r1, #117	; 0x75
  54:	f104 005d 	add.w	r0, r4, #93	; 0x5d
  58:	f7ff fffe 	bl	0 <memcpy>
    session->haveEMS = ssl->options.haveEMS;
  5c:	f895 3275 	ldrb.w	r3, [r5, #629]	; 0x275
  60:	f3c3 03c0 	ubfx	r3, r3, #3, #1
  64:	f8a4 308e 	strh.w	r3, [r4, #142]	; 0x8e
    if (ssl->sessionCtxSz > 0 && ssl->sessionCtxSz < ID_LEN) {
        XMEMCPY(ssl->session->sessionCtx, ssl->sessionCtx, ssl->sessionCtxSz);
        session->sessionCtxSz = ssl->sessionCtxSz;
    }
#endif
    session->timeout = ssl->timeout;
  68:	f8d5 3128 	ldr.w	r3, [r5, #296]	; 0x128
  6c:	63a3      	str	r3, [r4, #56]	; 0x38
#ifndef NO_ASN_TIME
    session->bornOn  = LowResTimer();
  6e:	f7ff fffe 	bl	0 <LowResTimer>
  72:	6360      	str	r0, [r4, #52]	; 0x34
                               defined(HAVE_SESSION_TICKET))
    session->version = ssl->version;
#endif
#if defined(SESSION_CERTS) || !defined(NO_RESUME_SUITE_CHECK) || \
                        (defined(WOLFSSL_TLS13) && defined(HAVE_SESSION_TICKET))
    session->cipherSuite0 = ssl->options.cipherSuite0;
  74:	f895 3278 	ldrb.w	r3, [r5, #632]	; 0x278
  78:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
    session->cipherSuite = ssl->options.cipherSuite;
  7c:	f895 3279 	ldrb.w	r3, [r5, #633]	; 0x279
  80:	f884 3091 	strb.w	r3, [r4, #145]	; 0x91
#endif
#if defined(OPENSSL_EXTRA) || defined(OPENSSL_EXTRA_X509_SMALL)
    session->peerVerifyRet = (byte)ssl->peerVerifyRet;
#endif
    session->isSetup = 1;
  84:	f894 30a8 	ldrb.w	r3, [r4, #168]	; 0xa8
  88:	f043 0301 	orr.w	r3, r3, #1
  8c:	f884 30a8 	strb.w	r3, [r4, #168]	; 0xa8
}
  90:	bd38      	pop	{r3, r4, r5, pc}
            XMEMCPY(session->sessionID, session->altSessionID, ID_LEN);
  92:	f104 0108 	add.w	r1, r4, #8
  96:	f7ff fffe 	bl	0 <memcpy>
            session->sessionIDSz = ID_LEN;
  9a:	2320      	movs	r3, #32
  9c:	e7c9      	b.n	32 <SetupSession+0x32>

Disassembly of section .text.ClientSessionToSession:

00000000 <ClientSessionToSession>:
#else  /* NO_SESSION_CACHE */

WOLFSSL_SESSION* ClientSessionToSession(const WOLFSSL_SESSION* session)
{
    return (WOLFSSL_SESSION*)session;
}
   0:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetSession:

00000000 <wolfSSL_GetSession>:
    (void)ssl;
    (void)masterSecret;
    (void)restoreSessionCerts;

    return NULL;
}
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wolfSSL_check_domain_name:

00000000 <wolfSSL_check_domain_name>:

/* call before SSL_connect, if verifying will add name check to
   date check and signature check */
WOLFSSL_ABI
int wolfSSL_check_domain_name(WOLFSSL* ssl, const char* dn)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460c      	mov	r4, r1
    WOLFSSL_ENTER("wolfSSL_check_domain_name");

    if (ssl == NULL || dn == NULL) {
   4:	4605      	mov	r5, r0
   6:	b1d8      	cbz	r0, 40 <wolfSSL_check_domain_name+0x40>
   8:	b301      	cbz	r1, 4c <wolfSSL_check_domain_name+0x4c>
        WOLFSSL_MSG("Bad function argument: NULL");
        return WOLFSSL_FAILURE;
    }

    if (ssl->buffers.domainName.buffer)
   a:	f8d0 00b0 	ldr.w	r0, [r0, #176]	; 0xb0
   e:	b108      	cbz	r0, 14 <wolfSSL_check_domain_name+0x14>
        XFREE(ssl->buffers.domainName.buffer, ssl->heap, DYNAMIC_TYPE_DOMAIN);
  10:	f7ff fffe 	bl	0 <free>

    ssl->buffers.domainName.length = (word32)XSTRLEN(dn);
  14:	4620      	mov	r0, r4
  16:	f7ff fffe 	bl	0 <strlen>
  1a:	f8c5 00b4 	str.w	r0, [r5, #180]	; 0xb4
    ssl->buffers.domainName.buffer = (byte*)XMALLOC(
  1e:	3001      	adds	r0, #1
  20:	f7ff fffe 	bl	0 <malloc>
  24:	4606      	mov	r6, r0
  26:	f8c5 00b0 	str.w	r0, [r5, #176]	; 0xb0
            ssl->buffers.domainName.length + 1, ssl->heap, DYNAMIC_TYPE_DOMAIN);

    if (ssl->buffers.domainName.buffer) {
  2a:	b150      	cbz	r0, 42 <wolfSSL_check_domain_name+0x42>
        unsigned char* domainName = ssl->buffers.domainName.buffer;
        XMEMCPY(domainName, dn, ssl->buffers.domainName.length);
  2c:	f8d5 20b4 	ldr.w	r2, [r5, #180]	; 0xb4
  30:	4621      	mov	r1, r4
  32:	f7ff fffe 	bl	0 <memcpy>
        domainName[ssl->buffers.domainName.length] = '\0';
  36:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
  3a:	2200      	movs	r2, #0
  3c:	54f2      	strb	r2, [r6, r3]
        return WOLFSSL_SUCCESS;
  3e:	2001      	movs	r0, #1
    }
    else {
        ssl->error = MEMORY_ERROR;
        return WOLFSSL_FAILURE;
    }
}
  40:	bd70      	pop	{r4, r5, r6, pc}
        ssl->error = MEMORY_ERROR;
  42:	f46f 7397 	mvn.w	r3, #302	; 0x12e
  46:	f8c5 3114 	str.w	r3, [r5, #276]	; 0x114
        return WOLFSSL_FAILURE;
  4a:	e7f9      	b.n	40 <wolfSSL_check_domain_name+0x40>
        return WOLFSSL_FAILURE;
  4c:	4608      	mov	r0, r1
  4e:	e7f7      	b.n	40 <wolfSSL_check_domain_name+0x40>

Disassembly of section .text.wolfSSL_set_compression:

00000000 <wolfSSL_set_compression>:
    ssl->options.usingCompression = 1;
    return WOLFSSL_SUCCESS;
#else
    return NOT_COMPILED_IN;
#endif
}
   0:	f06f 00ad 	mvn.w	r0, #173	; 0xad
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_load_verify_buffer_ex:

00000000 <wolfSSL_CTX_load_verify_buffer_ex>:

    int wolfSSL_CTX_load_verify_buffer_ex(WOLFSSL_CTX* ctx,
                                         const unsigned char* in,
                                         long sz, int format, int userChain,
                                         word32 flags)
    {
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4689      	mov	r9, r1
   6:	b089      	sub	sp, #36	; 0x24
   8:	4617      	mov	r7, r2
        int verify;
        int ret = WOLFSSL_FAILURE;

        WOLFSSL_ENTER("wolfSSL_CTX_load_verify_buffer_ex");

        verify = GET_VERIFY_SETTING_CTX(ctx);
   a:	4606      	mov	r6, r0
   c:	b1a0      	cbz	r0, 38 <wolfSSL_CTX_load_verify_buffer_ex+0x38>
   e:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
  12:	f085 0502 	eor.w	r5, r5, #2
  16:	f3c5 0540 	ubfx	r5, r5, #1, #1
        if (flags & WOLFSSL_LOAD_FLAG_DATE_ERR_OKAY)
            verify = VERIFY_SKIP_DATE;
  1a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  1c:	f012 0f02 	tst.w	r2, #2
  20:	bf18      	it	ne
  22:	2505      	movne	r5, #5

        if (format == WOLFSSL_FILETYPE_PEM)
  24:	2b01      	cmp	r3, #1
  26:	f04f 0400 	mov.w	r4, #0
  2a:	d12a      	bne.n	82 <wolfSSL_CTX_load_verify_buffer_ex+0x82>
    int  ret    = 0;
  2c:	4620      	mov	r0, r4
    long used   = 0;
  2e:	46a0      	mov	r8, r4
        long consumed = 0;
  30:	46a2      	mov	sl, r4
        ret = ProcessBuffer(ctx, buff + used, sz - used, format, type, ssl,
  32:	f04f 0b05 	mov.w	fp, #5
  36:	e003      	b.n	40 <wolfSSL_CTX_load_verify_buffer_ex+0x40>
        verify = GET_VERIFY_SETTING_CTX(ctx);
  38:	2501      	movs	r5, #1
  3a:	e7ee      	b.n	1a <wolfSSL_CTX_load_verify_buffer_ex+0x1a>
            gotOne = 1;
  3c:	2401      	movs	r4, #1
        used += consumed;
  3e:	4498      	add	r8, r3
    while (used < sz) {
  40:	4547      	cmp	r7, r8
  42:	dd18      	ble.n	76 <wolfSSL_CTX_load_verify_buffer_ex+0x76>
        ret = ProcessBuffer(ctx, buff + used, sz - used, format, type, ssl,
  44:	ab07      	add	r3, sp, #28
  46:	e9cd a301 	strd	sl, r3, [sp, #4]
  4a:	e9cd a503 	strd	sl, r5, [sp, #12]
  4e:	f8cd b000 	str.w	fp, [sp]
  52:	2301      	movs	r3, #1
  54:	eba7 0208 	sub.w	r2, r7, r8
  58:	eb09 0108 	add.w	r1, r9, r8
  5c:	4630      	mov	r0, r6
        long consumed = 0;
  5e:	f8cd a01c 	str.w	sl, [sp, #28]
        ret = ProcessBuffer(ctx, buff + used, sz - used, format, type, ssl,
  62:	f7ff fffe 	bl	0 <wolfSSL_CTX_load_verify_buffer_ex>
        if (ret == MEMORY_E) {
  66:	f110 0f7d 	cmn.w	r0, #125	; 0x7d
  6a:	d007      	beq.n	7c <wolfSSL_CTX_load_verify_buffer_ex+0x7c>
        else if (ret < 0) {
  6c:	2800      	cmp	r0, #0
            if (consumed > 0) { /* Made progress in file */
  6e:	9b07      	ldr	r3, [sp, #28]
        else if (ret < 0) {
  70:	dae4      	bge.n	3c <wolfSSL_CTX_load_verify_buffer_ex+0x3c>
            if (consumed > 0) { /* Made progress in file */
  72:	2b00      	cmp	r3, #0
  74:	dce3      	bgt.n	3e <wolfSSL_CTX_load_verify_buffer_ex+0x3e>
        return WOLFSSL_SUCCESS;
  76:	2c00      	cmp	r4, #0
  78:	bf18      	it	ne
  7a:	4620      	movne	r0, r4
            ret = wolfSSL_CTX_trust_peer_buffer(ctx, in, sz, format);
#endif

        WOLFSSL_LEAVE("wolfSSL_CTX_load_verify_buffer_ex", ret);
        return ret;
    }
  7c:	b009      	add	sp, #36	; 0x24
  7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            ret = ProcessBuffer(ctx, in, sz, format, CA_TYPE, NULL, NULL,
  82:	9a12      	ldr	r2, [sp, #72]	; 0x48
  84:	9504      	str	r5, [sp, #16]
  86:	e9cd 4202 	strd	r4, r2, [sp, #8]
  8a:	2205      	movs	r2, #5
  8c:	9200      	str	r2, [sp, #0]
  8e:	9401      	str	r4, [sp, #4]
  90:	463a      	mov	r2, r7
  92:	4649      	mov	r1, r9
  94:	4630      	mov	r0, r6
  96:	f7ff fffe 	bl	0 <wolfSSL_CTX_load_verify_buffer_ex>
        return ret;
  9a:	e7ef      	b.n	7c <wolfSSL_CTX_load_verify_buffer_ex+0x7c>

Disassembly of section .text.wolfSSL_CertManagerLoadCABuffer_ex:

00000000 <wolfSSL_CertManagerLoadCABuffer_ex>:
{
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4617      	mov	r7, r2
   8:	4698      	mov	r8, r3
    if (cm == NULL) {
   a:	4605      	mov	r5, r0
   c:	b310      	cbz	r0, 54 <wolfSSL_CertManagerLoadCABuffer_ex+0x54>
            return wolfTLSv1_2_client_method();
   e:	f7ff fffe 	bl	0 <wolfTLSv1_2_client_method>
    if ((ret == WOLFSSL_SUCCESS) && ((tmp = wolfSSL_CTX_new(cm_pick_method()))
  12:	f7ff fffe 	bl	0 <wolfSSL_CertManagerLoadCABuffer_ex>
  16:	4604      	mov	r4, r0
  18:	b1e8      	cbz	r0, 56 <wolfSSL_CertManagerLoadCABuffer_ex+0x56>
        wolfSSL_CTX_set_verify(tmp, WOLFSSL_VERIFY_DEFAULT, NULL);
  1a:	2200      	movs	r2, #0
  1c:	f44f 7100 	mov.w	r1, #512	; 0x200
  20:	f7ff fffe 	bl	0 <wolfSSL_CertManagerLoadCABuffer_ex>
        wolfSSL_CertManagerFree(tmp->cm);
  24:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  26:	f7ff fffe 	bl	0 <wolfSSL_CertManagerLoadCABuffer_ex>
        ret = wolfSSL_CTX_load_verify_buffer_ex(tmp, buff, sz, format,
  2a:	9b09      	ldr	r3, [sp, #36]	; 0x24
        tmp->cm = cm;
  2c:	62a5      	str	r5, [r4, #40]	; 0x28
        ret = wolfSSL_CTX_load_verify_buffer_ex(tmp, buff, sz, format,
  2e:	9301      	str	r3, [sp, #4]
  30:	9b08      	ldr	r3, [sp, #32]
  32:	9300      	str	r3, [sp, #0]
  34:	463a      	mov	r2, r7
  36:	4643      	mov	r3, r8
  38:	4631      	mov	r1, r6
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <wolfSSL_CertManagerLoadCABuffer_ex>
        tmp->cm = NULL;
  40:	2300      	movs	r3, #0
        ret = wolfSSL_CTX_load_verify_buffer_ex(tmp, buff, sz, format,
  42:	4605      	mov	r5, r0
        tmp->cm = NULL;
  44:	62a3      	str	r3, [r4, #40]	; 0x28
    wolfSSL_CTX_free(tmp);
  46:	4620      	mov	r0, r4
  48:	f7ff fffe 	bl	0 <wolfSSL_CertManagerLoadCABuffer_ex>
}
  4c:	4628      	mov	r0, r5
  4e:	b002      	add	sp, #8
  50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    WOLFSSL_CTX* tmp = NULL;
  54:	4604      	mov	r4, r0
        ret = WOLFSSL_FATAL_ERROR;
  56:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  5a:	e7f4      	b.n	46 <wolfSSL_CertManagerLoadCABuffer_ex+0x46>

Disassembly of section .text.wolfSSL_CertManagerLoadCABuffer:

00000000 <wolfSSL_CertManagerLoadCABuffer>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wolfSSL_CertManagerLoadCABuffer_ex(cm, buff, sz, format, 0,
   2:	2400      	movs	r4, #0
   4:	e9cd 4400 	strd	r4, r4, [sp]
   8:	f7ff fffe 	bl	0 <wolfSSL_CertManagerLoadCABuffer>
}
   c:	b002      	add	sp, #8
   e:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSL_CTX_load_verify_buffer:

00000000 <wolfSSL_CTX_load_verify_buffer>:

    /* wolfSSL extension allows DER files to be loaded from buffers as well */
    int wolfSSL_CTX_load_verify_buffer(WOLFSSL_CTX* ctx,
                                       const unsigned char* in,
                                       long sz, int format)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 0,
   2:	2400      	movs	r4, #0
   4:	e9cd 4400 	strd	r4, r4, [sp]
   8:	f7ff fffe 	bl	0 <wolfSSL_CTX_load_verify_buffer>
            WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
    }
   c:	b002      	add	sp, #8
   e:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSL_CTX_load_verify_chain_buffer_format:

00000000 <wolfSSL_CTX_load_verify_chain_buffer_format>:

    int wolfSSL_CTX_load_verify_chain_buffer_format(WOLFSSL_CTX* ctx,
                                       const unsigned char* in,
                                       long sz, int format)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        return wolfSSL_CTX_load_verify_buffer_ex(ctx, in, sz, format, 1,
   2:	f04f 0c00 	mov.w	ip, #0
   6:	2401      	movs	r4, #1
   8:	e9cd 4c00 	strd	r4, ip, [sp]
   c:	f7ff fffe 	bl	0 <wolfSSL_CTX_load_verify_chain_buffer_format>
            WOLFSSL_LOAD_VERIFY_DEFAULT_FLAGS);
    }
  10:	b002      	add	sp, #8
  12:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfSSL_CTX_use_certificate_buffer:

00000000 <wolfSSL_CTX_use_certificate_buffer>:
#endif /* WOLFSSL_TRUST_PEER_CERT */


    int wolfSSL_CTX_use_certificate_buffer(WOLFSSL_CTX* ctx,
                                 const unsigned char* in, long sz, int format)
    {
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
        int ret = WOLFSSL_FAILURE;

        WOLFSSL_ENTER("wolfSSL_CTX_use_certificate_buffer");
        ret = ProcessBuffer(ctx, in, sz, format, CERT_TYPE, NULL, NULL, 0,
   4:	b178      	cbz	r0, 26 <wolfSSL_CTX_use_certificate_buffer+0x26>
   6:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
   a:	f084 0402 	eor.w	r4, r4, #2
   e:	f3c4 0440 	ubfx	r4, r4, #1, #1
  12:	9404      	str	r4, [sp, #16]
  14:	2400      	movs	r4, #0
  16:	e9cd 4402 	strd	r4, r4, [sp, #8]
  1a:	e9cd 4400 	strd	r4, r4, [sp]
  1e:	f7ff fffe 	bl	0 <wolfSSL_CTX_use_certificate_buffer>
                             GET_VERIFY_SETTING_CTX(ctx));
        WOLFSSL_LEAVE("wolfSSL_CTX_use_certificate_buffer", ret);
        return ret;
    }
  22:	b006      	add	sp, #24
  24:	bd10      	pop	{r4, pc}
        ret = ProcessBuffer(ctx, in, sz, format, CERT_TYPE, NULL, NULL, 0,
  26:	2401      	movs	r4, #1
  28:	e7f3      	b.n	12 <wolfSSL_CTX_use_certificate_buffer+0x12>

Disassembly of section .text.wolfSSL_CTX_use_PrivateKey_buffer:

00000000 <wolfSSL_CTX_use_PrivateKey_buffer>:


    int wolfSSL_CTX_use_PrivateKey_buffer(WOLFSSL_CTX* ctx,
                                 const unsigned char* in, long sz, int format)
    {
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
        int ret = WOLFSSL_FAILURE;

        WOLFSSL_ENTER("wolfSSL_CTX_use_PrivateKey_buffer");
        ret = ProcessBuffer(ctx, in, sz, format, PRIVATEKEY_TYPE, NULL, NULL,
   4:	b180      	cbz	r0, 28 <wolfSSL_CTX_use_PrivateKey_buffer+0x28>
   6:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
   a:	f084 0402 	eor.w	r4, r4, #2
   e:	f3c4 0440 	ubfx	r4, r4, #1, #1
  12:	9404      	str	r4, [sp, #16]
  14:	2400      	movs	r4, #0
  16:	e9cd 4402 	strd	r4, r4, [sp, #8]
  1a:	9401      	str	r4, [sp, #4]
  1c:	2401      	movs	r4, #1
  1e:	9400      	str	r4, [sp, #0]
  20:	f7ff fffe 	bl	0 <wolfSSL_CTX_use_PrivateKey_buffer>
                             0, GET_VERIFY_SETTING_CTX(ctx));
        WOLFSSL_LEAVE("wolfSSL_CTX_use_PrivateKey_buffer", ret);
        return ret;
    }
  24:	b006      	add	sp, #24
  26:	bd10      	pop	{r4, pc}
        ret = ProcessBuffer(ctx, in, sz, format, PRIVATEKEY_TYPE, NULL, NULL,
  28:	2401      	movs	r4, #1
  2a:	e7f2      	b.n	12 <wolfSSL_CTX_use_PrivateKey_buffer+0x12>

Disassembly of section .text.wolfSSL_CTX_use_certificate_chain_buffer_format:

00000000 <wolfSSL_CTX_use_certificate_chain_buffer_format>:
    }
#endif /* WOLF_PRIVATE_KEY_ID */

    int wolfSSL_CTX_use_certificate_chain_buffer_format(WOLFSSL_CTX* ctx,
                                 const unsigned char* in, long sz, int format)
    {
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
        WOLFSSL_ENTER("wolfSSL_CTX_use_certificate_chain_buffer_format");
        return ProcessBuffer(ctx, in, sz, format, CERT_TYPE, NULL, NULL, 1,
   4:	b188      	cbz	r0, 2a <wolfSSL_CTX_use_certificate_chain_buffer_format+0x2a>
   6:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
   a:	f084 0402 	eor.w	r4, r4, #2
   e:	f3c4 0440 	ubfx	r4, r4, #1, #1
  12:	9404      	str	r4, [sp, #16]
  14:	f04f 0c01 	mov.w	ip, #1
  18:	2400      	movs	r4, #0
  1a:	e9cd 4c02 	strd	r4, ip, [sp, #8]
  1e:	e9cd 4400 	strd	r4, r4, [sp]
  22:	f7ff fffe 	bl	0 <wolfSSL_CTX_use_certificate_chain_buffer_format>
                             GET_VERIFY_SETTING_CTX(ctx));
    }
  26:	b006      	add	sp, #24
  28:	bd10      	pop	{r4, pc}
        return ProcessBuffer(ctx, in, sz, format, CERT_TYPE, NULL, NULL, 1,
  2a:	2401      	movs	r4, #1
  2c:	e7f1      	b.n	12 <wolfSSL_CTX_use_certificate_chain_buffer_format+0x12>

Disassembly of section .text.wolfSSL_CTX_use_certificate_chain_buffer:

00000000 <wolfSSL_CTX_use_certificate_chain_buffer>:

    int wolfSSL_CTX_use_certificate_chain_buffer(WOLFSSL_CTX* ctx,
                                 const unsigned char* in, long sz)
    {
        return wolfSSL_CTX_use_certificate_chain_buffer_format(ctx, in, sz,
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <wolfSSL_CTX_use_certificate_chain_buffer>

Disassembly of section .text.wolfSSL_use_certificate_buffer:

00000000 <wolfSSL_use_certificate_buffer>:
#endif /* NO_DH */


    int wolfSSL_use_certificate_buffer(WOLFSSL* ssl,
                                 const unsigned char* in, long sz, int format)
    {
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
        WOLFSSL_ENTER("wolfSSL_use_certificate_buffer");
        if (ssl == NULL)
   4:	b170      	cbz	r0, 24 <wolfSSL_use_certificate_buffer+0x24>
            return BAD_FUNC_ARG;

        return ProcessBuffer(ssl->ctx, in, sz, format, CERT_TYPE, ssl, NULL, 0,
   6:	f990 4270 	ldrsb.w	r4, [r0, #624]	; 0x270
   a:	43e4      	mvns	r4, r4
   c:	0fe4      	lsrs	r4, r4, #31
   e:	9404      	str	r4, [sp, #16]
  10:	2400      	movs	r4, #0
  12:	e9cd 4402 	strd	r4, r4, [sp, #8]
  16:	e9cd 4000 	strd	r4, r0, [sp]
  1a:	6800      	ldr	r0, [r0, #0]
  1c:	f7ff fffe 	bl	0 <wolfSSL_use_certificate_buffer>
                             GET_VERIFY_SETTING_SSL(ssl));
    }
  20:	b006      	add	sp, #24
  22:	bd10      	pop	{r4, pc}
            return BAD_FUNC_ARG;
  24:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  28:	e7fa      	b.n	20 <wolfSSL_use_certificate_buffer+0x20>

Disassembly of section .text.wolfSSL_use_PrivateKey_buffer:

00000000 <wolfSSL_use_PrivateKey_buffer>:


    int wolfSSL_use_PrivateKey_buffer(WOLFSSL* ssl,
                                 const unsigned char* in, long sz, int format)
    {
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
        WOLFSSL_ENTER("wolfSSL_use_PrivateKey_buffer");
        if (ssl == NULL)
   4:	b178      	cbz	r0, 26 <wolfSSL_use_PrivateKey_buffer+0x26>
            return BAD_FUNC_ARG;

        return ProcessBuffer(ssl->ctx, in, sz, format, PRIVATEKEY_TYPE,
   6:	f990 4270 	ldrsb.w	r4, [r0, #624]	; 0x270
   a:	9001      	str	r0, [sp, #4]
   c:	43e4      	mvns	r4, r4
   e:	0fe4      	lsrs	r4, r4, #31
  10:	9404      	str	r4, [sp, #16]
  12:	2400      	movs	r4, #0
  14:	e9cd 4402 	strd	r4, r4, [sp, #8]
  18:	2401      	movs	r4, #1
  1a:	9400      	str	r4, [sp, #0]
  1c:	6800      	ldr	r0, [r0, #0]
  1e:	f7ff fffe 	bl	0 <wolfSSL_use_PrivateKey_buffer>
                             ssl, NULL, 0, GET_VERIFY_SETTING_SSL(ssl));
    }
  22:	b006      	add	sp, #24
  24:	bd10      	pop	{r4, pc}
            return BAD_FUNC_ARG;
  26:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2a:	e7fa      	b.n	22 <wolfSSL_use_PrivateKey_buffer+0x22>

Disassembly of section .text.wolfSSL_use_certificate_chain_buffer_format:

00000000 <wolfSSL_use_certificate_chain_buffer_format>:
    }
#endif /* WOLF_PRIVATE_KEY_ID */

    int wolfSSL_use_certificate_chain_buffer_format(WOLFSSL* ssl,
                                 const unsigned char* in, long sz, int format)
    {
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
        WOLFSSL_ENTER("wolfSSL_use_certificate_chain_buffer_format");
        if (ssl == NULL)
   4:	b180      	cbz	r0, 28 <wolfSSL_use_certificate_chain_buffer_format+0x28>
            return BAD_FUNC_ARG;

        return ProcessBuffer(ssl->ctx, in, sz, format, CERT_TYPE,
   6:	f990 4270 	ldrsb.w	r4, [r0, #624]	; 0x270
   a:	43e4      	mvns	r4, r4
   c:	0fe4      	lsrs	r4, r4, #31
   e:	9404      	str	r4, [sp, #16]
  10:	f04f 0c01 	mov.w	ip, #1
  14:	2400      	movs	r4, #0
  16:	e9cd 4c02 	strd	r4, ip, [sp, #8]
  1a:	e9cd 4000 	strd	r4, r0, [sp]
  1e:	6800      	ldr	r0, [r0, #0]
  20:	f7ff fffe 	bl	0 <wolfSSL_use_certificate_chain_buffer_format>
                             ssl, NULL, 1, GET_VERIFY_SETTING_SSL(ssl));
    }
  24:	b006      	add	sp, #24
  26:	bd10      	pop	{r4, pc}
            return BAD_FUNC_ARG;
  28:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2c:	e7fa      	b.n	24 <wolfSSL_use_certificate_chain_buffer_format+0x24>

Disassembly of section .text.wolfSSL_use_certificate_chain_buffer:

00000000 <wolfSSL_use_certificate_chain_buffer>:

    int wolfSSL_use_certificate_chain_buffer(WOLFSSL* ssl,
                                 const unsigned char* in, long sz)
    {
        return wolfSSL_use_certificate_chain_buffer_format(ssl, in, sz,
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <wolfSSL_use_certificate_chain_buffer>

Disassembly of section .text.wolfSSL_UnloadCertsKeys:

00000000 <wolfSSL_UnloadCertsKeys>:


    /* unload any certs or keys that SSL owns, leave CTX as is
       WOLFSSL_SUCCESS on ok */
    int wolfSSL_UnloadCertsKeys(WOLFSSL* ssl)
    {
   0:	b538      	push	{r3, r4, r5, lr}
        if (ssl == NULL) {
   2:	4604      	mov	r4, r0
   4:	b330      	cbz	r0, 54 <wolfSSL_UnloadCertsKeys+0x54>
            WOLFSSL_MSG("Null function arg");
            return BAD_FUNC_ARG;
        }

        if (ssl->buffers.weOwnCert && !ssl->keepCert) {
   6:	f890 30d8 	ldrb.w	r3, [r0, #216]	; 0xd8
   a:	b13b      	cbz	r3, 1c <wolfSSL_UnloadCertsKeys+0x1c>
   c:	f890 52b9 	ldrb.w	r5, [r0, #697]	; 0x2b9
  10:	b925      	cbnz	r5, 1c <wolfSSL_UnloadCertsKeys+0x1c>
            WOLFSSL_MSG("Unloading cert");
            FreeDer(&ssl->buffers.certificate);
  12:	30dc      	adds	r0, #220	; 0xdc
  14:	f7ff fffe 	bl	0 <FreeDer>
            #ifdef KEEP_OUR_CERT
            wolfSSL_X509_free(ssl->ourCert);
            ssl->ourCert = NULL;
            #endif
            ssl->buffers.weOwnCert = 0;
  18:	f884 50d8 	strb.w	r5, [r4, #216]	; 0xd8
        }

        if (ssl->buffers.weOwnCertChain) {
  1c:	f894 30d9 	ldrb.w	r3, [r4, #217]	; 0xd9
  20:	b133      	cbz	r3, 30 <wolfSSL_UnloadCertsKeys+0x30>
            WOLFSSL_MSG("Unloading cert chain");
            FreeDer(&ssl->buffers.certChain);
  22:	f104 00f0 	add.w	r0, r4, #240	; 0xf0
  26:	f7ff fffe 	bl	0 <FreeDer>
            ssl->buffers.weOwnCertChain = 0;
  2a:	2300      	movs	r3, #0
  2c:	f884 30d9 	strb.w	r3, [r4, #217]	; 0xd9
        }

        if (ssl->buffers.weOwnKey) {
  30:	f894 30da 	ldrb.w	r3, [r4, #218]	; 0xda
  34:	b163      	cbz	r3, 50 <wolfSSL_UnloadCertsKeys+0x50>
            WOLFSSL_MSG("Unloading key");
            ForceZero(ssl->buffers.key->buffer, ssl->buffers.key->length);
  36:	4622      	mov	r2, r4
  38:	f852 3fe0 	ldr.w	r3, [r2, #224]!
  3c:	6818      	ldr	r0, [r3, #0]
  3e:	6899      	ldr	r1, [r3, #8]
  40:	f7ff fffe 	bl	0 <wolfSSL_UnloadCertsKeys>
            FreeDer(&ssl->buffers.key);
  44:	4610      	mov	r0, r2
  46:	f7ff fffe 	bl	0 <FreeDer>
            ssl->buffers.weOwnKey = 0;
  4a:	2300      	movs	r3, #0
  4c:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
        }

        return WOLFSSL_SUCCESS;
  50:	2001      	movs	r0, #1
  52:	e001      	b.n	58 <wolfSSL_UnloadCertsKeys+0x58>
            return BAD_FUNC_ARG;
  54:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
  58:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.wolfSSL_CTX_UnloadCAs:

00000000 <wolfSSL_CTX_UnloadCAs>:

    int wolfSSL_CTX_UnloadCAs(WOLFSSL_CTX* ctx)
    {
        WOLFSSL_ENTER("wolfSSL_CTX_UnloadCAs");

        if (ctx == NULL)
   0:	b110      	cbz	r0, 8 <wolfSSL_CTX_UnloadCAs+0x8>
            return BAD_FUNC_ARG;

        return wolfSSL_CertManagerUnloadCAs(ctx->cm);
   2:	6a80      	ldr	r0, [r0, #40]	; 0x28
   4:	f7ff bffe 	b.w	0 <wolfSSL_CTX_UnloadCAs>
    }
   8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_is_init_finished:

00000000 <wolfSSL_is_init_finished>:
#endif /* OPENSSL_EXTRA || WOLFSSL_EXTRA || WOLFSSL_WPAS_SMALL */

    /* return true if connection established */
    int wolfSSL_is_init_finished(WOLFSSL* ssl)
    {
        if (ssl == NULL)
   0:	b128      	cbz	r0, e <wolfSSL_is_init_finished+0xe>
            return 0;

        if (ssl->options.handShakeState == HANDSHAKE_DONE)
   2:	f890 027e 	ldrb.w	r0, [r0, #638]	; 0x27e
   6:	f1a0 0310 	sub.w	r3, r0, #16
   a:	4258      	negs	r0, r3
   c:	4158      	adcs	r0, r3
            return 1;

        return 0;
    }
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_get_options:

00000000 <wolfSSL_CTX_get_options>:

    long wolfSSL_CTX_get_options(WOLFSSL_CTX* ctx)
    {
        WOLFSSL_ENTER("wolfSSL_CTX_get_options");
        WOLFSSL_MSG("wolfSSL options are set through API calls and macros");
        if(ctx == NULL)
   0:	b108      	cbz	r0, 6 <wolfSSL_CTX_get_options+0x6>
            return BAD_FUNC_ARG;
        return ctx->mask;
   2:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
   4:	4770      	bx	lr
            return BAD_FUNC_ARG;
   6:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_set_options:

00000000 <wolfSSL_CTX_set_options>:

    long wolfSSL_CTX_set_options(WOLFSSL_CTX* ctx, long opt)
    {
        WOLFSSL_ENTER("wolfSSL_CTX_set_options");

        if (ctx == NULL)
   0:	4603      	mov	r3, r0
   2:	b118      	cbz	r0, c <wolfSSL_CTX_set_options+0xc>
    #else
        WOLFSSL_MSG("SSL_OP_NO_COMPRESSION: compression not compiled in");
    #endif
    }

    return old_op | op;
   4:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
   6:	4308      	orrs	r0, r1
        ctx->mask = wolf_set_options(ctx->mask, opt);
   8:	63d8      	str	r0, [r3, #60]	; 0x3c
        return ctx->mask;
   a:	4770      	bx	lr
            return BAD_FUNC_ARG;
   c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
  10:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_clear_options:

00000000 <wolfSSL_CTX_clear_options>:
        if(ctx == NULL)
   0:	4602      	mov	r2, r0
   2:	b120      	cbz	r0, e <wolfSSL_CTX_clear_options+0xe>
        ctx->mask &= ~opt;
   4:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
   6:	ea23 0001 	bic.w	r0, r3, r1
   a:	63d0      	str	r0, [r2, #60]	; 0x3c
        return ctx->mask;
   c:	4770      	bx	lr
            return BAD_FUNC_ARG;
   e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
  12:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_shutdown:

00000000 <wolfSSL_get_shutdown>:
    if (ssl) {
   0:	b140      	cbz	r0, 14 <wolfSSL_get_shutdown+0x14>
            if (ssl->options.sentNotify)
   2:	f890 3272 	ldrb.w	r3, [r0, #626]	; 0x272
   6:	f3c3 1080 	ubfx	r0, r3, #6, #1
            if (ssl->options.closeNotify||ssl->options.connReset)
   a:	f013 0f28 	tst.w	r3, #40	; 0x28
                isShutdown |= WOLFSSL_RECEIVED_SHUTDOWN;
   e:	bf18      	it	ne
  10:	f040 0002 	orrne.w	r0, r0, #2
}
  14:	4770      	bx	lr

Disassembly of section .text.wolfSSL_session_reused:

00000000 <wolfSSL_session_reused>:
    if (ssl) {
   0:	b118      	cbz	r0, a <wolfSSL_session_reused+0xa>
        resuming = ssl->options.resuming;
   2:	f890 0271 	ldrb.w	r0, [r0, #625]	; 0x271
   6:	f3c0 00c0 	ubfx	r0, r0, #3, #1
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_NewSession:

00000000 <wolfSSL_NewSession>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4605      	mov	r5, r0
    ret = (WOLFSSL_SESSION*)XMALLOC(sizeof(WOLFSSL_SESSION), heap,
   4:	20ac      	movs	r0, #172	; 0xac
   6:	f7ff fffe 	bl	0 <malloc>
    if (ret != NULL) {
   a:	4604      	mov	r4, r0
   c:	b140      	cbz	r0, 20 <wolfSSL_NewSession+0x20>
        XMEMSET(ret, 0, sizeof(WOLFSSL_SESSION));
   e:	22ac      	movs	r2, #172	; 0xac
  10:	2100      	movs	r1, #0
  12:	f7ff fffe 	bl	0 <memset>
        wolfSSL_RefInit(&ret->ref, &err);
  16:	2301      	movs	r3, #1
  18:	6063      	str	r3, [r4, #4]
        ret->type = WOLFSSL_SESSION_TYPE_HEAP;
  1a:	2303      	movs	r3, #3
  1c:	7023      	strb	r3, [r4, #0]
        ret->heap = heap;
  1e:	62e5      	str	r5, [r4, #44]	; 0x2c
}
  20:	4620      	mov	r0, r4
  22:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.wolfSSL_SESSION_new_ex:

00000000 <wolfSSL_SESSION_new_ex>:
    return wolfSSL_NewSession(heap);
   0:	f7ff bffe 	b.w	0 <wolfSSL_SESSION_new_ex>

Disassembly of section .text.wolfSSL_SESSION_new:

00000000 <wolfSSL_SESSION_new>:
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfSSL_SESSION_new>

Disassembly of section .text.wolfSSL_SESSION_up_ref:

00000000 <wolfSSL_SESSION_up_ref>:
    if (session == NULL || session->type != WOLFSSL_SESSION_TYPE_HEAP)
   0:	b140      	cbz	r0, 14 <wolfSSL_SESSION_up_ref+0x14>
   2:	7803      	ldrb	r3, [r0, #0]
   4:	2b03      	cmp	r3, #3
   6:	d104      	bne.n	12 <wolfSSL_SESSION_up_ref+0x12>
    wolfSSL_RefInc(&session->ref, &ret);
   8:	6843      	ldr	r3, [r0, #4]
   a:	3301      	adds	r3, #1
   c:	6043      	str	r3, [r0, #4]
    return WOLFSSL_SUCCESS;
   e:	2001      	movs	r0, #1
  10:	4770      	bx	lr
        return WOLFSSL_FAILURE;
  12:	2000      	movs	r0, #0
}
  14:	4770      	bx	lr

Disassembly of section .text.wolfSSL_DupSession:

00000000 <wolfSSL_DupSession>:
{
   0:	b508      	push	{r3, lr}
   2:	460b      	mov	r3, r1
    if (input == NULL || output == NULL || input == output) {
   4:	b150      	cbz	r0, 1c <wolfSSL_DupSession+0x1c>
   6:	b151      	cbz	r1, 1e <wolfSSL_DupSession+0x1e>
   8:	4288      	cmp	r0, r1
   a:	d008      	beq.n	1e <wolfSSL_DupSession+0x1e>
    XMEMCPY((byte*)output + copyOffset, (byte*)input + copyOffset,
   c:	f100 0130 	add.w	r1, r0, #48	; 0x30
  10:	227c      	movs	r2, #124	; 0x7c
  12:	f103 0030 	add.w	r0, r3, #48	; 0x30
  16:	f7ff fffe 	bl	0 <memcpy>
    return ret;
  1a:	2001      	movs	r0, #1
}
  1c:	bd08      	pop	{r3, pc}
        return WOLFSSL_FAILURE;
  1e:	2000      	movs	r0, #0
    return wolfSSL_DupSessionEx(input, output, avoidSysCalls, NULL, NULL, NULL);
  20:	e7fc      	b.n	1c <wolfSSL_DupSession+0x1c>

Disassembly of section .text.wolfSSL_FreeSession:

00000000 <wolfSSL_FreeSession>:
{
   0:	b508      	push	{r3, lr}
    if (session == NULL)
   2:	460a      	mov	r2, r1
   4:	b1c1      	cbz	r1, 38 <wolfSSL_FreeSession+0x38>
    if (session->ref.count > 0) {
   6:	684b      	ldr	r3, [r1, #4]
   8:	2b00      	cmp	r3, #0
   a:	dc11      	bgt.n	30 <wolfSSL_FreeSession+0x30>
    ForceZero(session->masterSecret, SECRET_LEN);
   c:	2130      	movs	r1, #48	; 0x30
   e:	f102 005d 	add.w	r0, r2, #93	; 0x5d
  12:	f7ff fffe 	bl	0 <wolfSSL_FreeSession>
    ForceZero(session->sessionID, ID_LEN);
  16:	2120      	movs	r1, #32
  18:	f102 003c 	add.w	r0, r2, #60	; 0x3c
  1c:	f7ff fffe 	bl	0 <wolfSSL_FreeSession>
    if (session->type == WOLFSSL_SESSION_TYPE_HEAP) {
  20:	7813      	ldrb	r3, [r2, #0]
  22:	2b03      	cmp	r3, #3
  24:	d108      	bne.n	38 <wolfSSL_FreeSession+0x38>
}
  26:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        XFREE(session, session->heap, DYNAMIC_TYPE_SESSION);
  2a:	4610      	mov	r0, r2
  2c:	f7ff bffe 	b.w	0 <free>
        wolfSSL_RefDec(&session->ref, &isZero, &ret);
  30:	3b01      	subs	r3, #1
  32:	604b      	str	r3, [r1, #4]
        if (!isZero) {
  34:	2b00      	cmp	r3, #0
  36:	d0e9      	beq.n	c <wolfSSL_FreeSession+0xc>
}
  38:	bd08      	pop	{r3, pc}

Disassembly of section .text.wolfSSL_SESSION_dup:

00000000 <wolfSSL_SESSION_dup>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (session == NULL)
   2:	4605      	mov	r5, r0
   4:	b910      	cbnz	r0, c <wolfSSL_SESSION_dup+0xc>
        copy = NULL;
   6:	2400      	movs	r4, #0
}
   8:	4620      	mov	r0, r4
   a:	bd38      	pop	{r3, r4, r5, pc}
    copy = wolfSSL_NewSession(session->heap);
   c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
   e:	f7ff fffe 	bl	0 <wolfSSL_SESSION_dup>
    if (copy != NULL &&
  12:	4604      	mov	r4, r0
  14:	2800      	cmp	r0, #0
  16:	d0f6      	beq.n	6 <wolfSSL_SESSION_dup+0x6>
            wolfSSL_DupSession(session, copy, 0) != WOLFSSL_SUCCESS) {
  18:	4601      	mov	r1, r0
  1a:	2200      	movs	r2, #0
  1c:	4628      	mov	r0, r5
  1e:	f7ff fffe 	bl	0 <wolfSSL_SESSION_dup>
    if (copy != NULL &&
  22:	2801      	cmp	r0, #1
  24:	d0f0      	beq.n	8 <wolfSSL_SESSION_dup+0x8>
        wolfSSL_FreeSession(NULL, copy);
  26:	4621      	mov	r1, r4
  28:	2000      	movs	r0, #0
  2a:	f7ff fffe 	bl	0 <wolfSSL_SESSION_dup>
  2e:	e7ea      	b.n	6 <wolfSSL_SESSION_dup+0x6>

Disassembly of section .text.wolfSSL_SESSION_free:

00000000 <wolfSSL_SESSION_free>:
{
   0:	4601      	mov	r1, r0
    wolfSSL_FreeSession(NULL, session);
   2:	2000      	movs	r0, #0
   4:	f7ff bffe 	b.w	0 <wolfSSL_SESSION_free>

Disassembly of section .text.wolfSSL_get_version:

00000000 <wolfSSL_get_version>:
    if (ssl == NULL) {
   0:	b158      	cbz	r0, 1a <wolfSSL_get_version+0x1a>
    if (version->major == SSLv3_MAJOR) {
   2:	f890 313c 	ldrb.w	r3, [r0, #316]	; 0x13c
   6:	2b03      	cmp	r3, #3
   8:	d107      	bne.n	1a <wolfSSL_get_version+0x1a>
        switch (version->minor) {
   a:	f890 313d 	ldrb.w	r3, [r0, #317]	; 0x13d
   e:	2b04      	cmp	r3, #4
  10:	d803      	bhi.n	1a <wolfSSL_get_version+0x1a>
  12:	4a03      	ldr	r2, [pc, #12]	; (20 <wolfSSL_get_version+0x20>)
  14:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
  18:	4770      	bx	lr
        return "unknown";
  1a:	4802      	ldr	r0, [pc, #8]	; (24 <wolfSSL_get_version+0x24>)
}
  1c:	4770      	bx	lr
  1e:	bf00      	nop
	...

Disassembly of section .text.wolfSSL_lib_version:

00000000 <wolfSSL_lib_version>:
}
   0:	4800      	ldr	r0, [pc, #0]	; (4 <wolfSSL_lib_version+0x4>)
   2:	4770      	bx	lr
   4:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_lib_version_hex:

00000000 <wolfSSL_lib_version_hex>:
}
   0:	4800      	ldr	r0, [pc, #0]	; (4 <wolfSSL_lib_version_hex+0x4>)
   2:	4770      	bx	lr
   4:	05006004 	.word	0x05006004

Disassembly of section .text.wolfSSL_get_current_cipher_suite:

00000000 <wolfSSL_get_current_cipher_suite>:
    if (ssl)
   0:	b118      	cbz	r0, a <wolfSSL_get_current_cipher_suite+0xa>
        return (ssl->options.cipherSuite0 << 8) | ssl->options.cipherSuite;
   2:	f8b0 0278 	ldrh.w	r0, [r0, #632]	; 0x278
   6:	ba40      	rev16	r0, r0
   8:	b280      	uxth	r0, r0
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_current_cipher:

00000000 <wolfSSL_get_current_cipher>:
    if (ssl) {
   0:	b118      	cbz	r0, a <wolfSSL_get_current_cipher+0xa>
        ssl->cipher.cipherSuite0 = ssl->options.cipherSuite0;
   2:	f8b0 3278 	ldrh.w	r3, [r0, #632]	; 0x278
   6:	f820 3f44 	strh.w	r3, [r0, #68]!
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CIPHER_get_name:

00000000 <wolfSSL_CIPHER_get_name>:
    if (cipher == NULL) {
   0:	b118      	cbz	r0, a <wolfSSL_CIPHER_get_name+0xa>
        return GetCipherNameIana(cipher->cipherSuite0, cipher->cipherSuite);
   2:	7841      	ldrb	r1, [r0, #1]
   4:	7800      	ldrb	r0, [r0, #0]
   6:	f7ff bffe 	b.w	0 <GetCipherNameIana>
}
   a:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CIPHER_get_version:

00000000 <wolfSSL_CIPHER_get_version>:
    if (cipher == NULL || cipher->ssl == NULL) {
   0:	b118      	cbz	r0, a <wolfSSL_CIPHER_get_version+0xa>
   2:	6840      	ldr	r0, [r0, #4]
   4:	b108      	cbz	r0, a <wolfSSL_CIPHER_get_version+0xa>
    return wolfSSL_get_version(cipher->ssl);
   6:	f7ff bffe 	b.w	0 <wolfSSL_CIPHER_get_version>
}
   a:	2000      	movs	r0, #0
   c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SESSION_CIPHER_get_name:

00000000 <wolfSSL_SESSION_CIPHER_get_name>:
    if (session == NULL) {
   0:	b128      	cbz	r0, e <wolfSSL_SESSION_CIPHER_get_name+0xe>
        return GetCipherNameIana(session->cipherSuite0, session->cipherSuite);
   2:	f890 1091 	ldrb.w	r1, [r0, #145]	; 0x91
   6:	f890 0090 	ldrb.w	r0, [r0, #144]	; 0x90
   a:	f7ff bffe 	b.w	0 <GetCipherNameIana>
}
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_cipher:

00000000 <wolfSSL_get_cipher>:
{
   0:	b508      	push	{r3, lr}
    return wolfSSL_CIPHER_get_name(wolfSSL_get_current_cipher(ssl));
   2:	f7ff fffe 	bl	0 <wolfSSL_get_cipher>
}
   6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    return wolfSSL_CIPHER_get_name(wolfSSL_get_current_cipher(ssl));
   a:	f7ff bffe 	b.w	0 <wolfSSL_get_cipher>

Disassembly of section .text.wolfSSL_get_cipher_name:

00000000 <wolfSSL_get_cipher_name>:
    return wolfSSL_get_cipher_name_internal(ssl);
   0:	f7ff bffe 	b.w	0 <wolfSSL_get_cipher_name_internal>

Disassembly of section .text.wolfSSL_get_cipher_name_from_suite:

00000000 <wolfSSL_get_cipher_name_from_suite>:
    return GetCipherNameInternal(cipherSuite0, cipherSuite);
   0:	f7ff bffe 	b.w	0 <GetCipherNameInternal>

Disassembly of section .text.wolfSSL_get_cipher_name_iana_from_suite:

00000000 <wolfSSL_get_cipher_name_iana_from_suite>:
    return GetCipherNameIana(cipherSuite0, cipherSuite);
   0:	f7ff bffe 	b.w	0 <GetCipherNameIana>

Disassembly of section .text.wolfSSL_get_cipher_suite_from_name:

00000000 <wolfSSL_get_cipher_suite_from_name>:
                                       byte* cipherSuite, int *flags) {
   0:	b470      	push	{r4, r5, r6}
    if ((name == NULL) ||
   2:	b128      	cbz	r0, 10 <wolfSSL_get_cipher_suite_from_name+0x10>
   4:	b121      	cbz	r1, 10 <wolfSSL_get_cipher_suite_from_name+0x10>
        (cipherSuite0 == NULL) ||
   6:	b11a      	cbz	r2, 10 <wolfSSL_get_cipher_suite_from_name+0x10>
        (cipherSuite == NULL) ||
   8:	b113      	cbz	r3, 10 <wolfSSL_get_cipher_suite_from_name+0x10>
}
   a:	bc70      	pop	{r4, r5, r6}
    return GetCipherSuiteFromName(name, cipherSuite0, cipherSuite, flags);
   c:	f7ff bffe 	b.w	0 <GetCipherSuiteFromName>
}
  10:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  14:	bc70      	pop	{r4, r5, r6}
  16:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CIPHER_get_id:

00000000 <wolfSSL_CIPHER_get_id>:
    if (cipher && cipher->ssl) {
   0:	b128      	cbz	r0, e <wolfSSL_CIPHER_get_id+0xe>
   2:	6840      	ldr	r0, [r0, #4]
   4:	b118      	cbz	r0, e <wolfSSL_CIPHER_get_id+0xe>
        cipher_id = (cipher->ssl->options.cipherSuite0 << 8) |
   6:	f8b0 0278 	ldrh.w	r0, [r0, #632]	; 0x278
   a:	ba40      	rev16	r0, r0
   c:	b280      	uxth	r0, r0
}
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_cipher_by_value:

00000000 <wolfSSL_get_cipher_by_value>:
}
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wolfSSL_get_curve_name:

00000000 <wolfSSL_get_curve_name>:
{
   0:	b508      	push	{r3, lr}
    if (ssl == NULL)
   2:	b130      	cbz	r0, 12 <wolfSSL_get_curve_name+0x12>
    if (ssl->ecdhCurveOID == ECC_X25519_OID && cName == NULL) {
   4:	f8d0 0290 	ldr.w	r0, [r0, #656]	; 0x290
   8:	f240 136d 	movw	r3, #365	; 0x16d
   c:	4298      	cmp	r0, r3
   e:	d101      	bne.n	14 <wolfSSL_get_curve_name+0x14>
        cName = "X25519";
  10:	4805      	ldr	r0, [pc, #20]	; (28 <wolfSSL_get_curve_name+0x28>)
}
  12:	bd08      	pop	{r3, pc}
    if (ssl->ecdhCurveOID != 0 && cName == NULL) {
  14:	2800      	cmp	r0, #0
  16:	d0fc      	beq.n	12 <wolfSSL_get_curve_name+0x12>
        cName = wc_ecc_get_name(wc_ecc_get_oid(ssl->ecdhCurveOID, NULL,
  18:	2200      	movs	r2, #0
  1a:	4611      	mov	r1, r2
  1c:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
}
  20:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        cName = wc_ecc_get_name(wc_ecc_get_oid(ssl->ecdhCurveOID, NULL,
  24:	f7ff bffe 	b.w	0 <wc_ecc_get_name>
  28:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_set_options:

00000000 <wolfSSL_set_options>:
}

long wolfSSL_set_options(WOLFSSL* ssl, long op)
{
   0:	b530      	push	{r4, r5, lr}
    word16 havePSK = 0;
    int    keySz   = 0;

    WOLFSSL_ENTER("wolfSSL_set_options");

    if (ssl == NULL) {
   2:	4604      	mov	r4, r0
{
   4:	b08d      	sub	sp, #52	; 0x34
    if (ssl == NULL) {
   6:	b910      	cbnz	r0, e <wolfSSL_set_options+0xe>
        return 0;
   8:	2000      	movs	r0, #0
                   ssl->options.haveFalconSig, ssl->options.haveDilithiumSig,
                   ssl->options.haveAnon, TRUE, ssl->options.side);
    }

    return ssl->options.mask;
}
   a:	b00d      	add	sp, #52	; 0x34
   c:	bd30      	pop	{r4, r5, pc}
    return old_op | op;
   e:	f8d0 326c 	ldr.w	r3, [r0, #620]	; 0x26c
  12:	4319      	orrs	r1, r3
    if ((ssl->options.mask & WOLFSSL_OP_NO_TLSv1_3) == WOLFSSL_OP_NO_TLSv1_3) {
  14:	008d      	lsls	r5, r1, #2
    ssl->options.mask = wolf_set_options(ssl->options.mask, op);
  16:	f8c0 126c 	str.w	r1, [r0, #620]	; 0x26c
    if ((ssl->options.mask & WOLFSSL_OP_NO_TLSv1_3) == WOLFSSL_OP_NO_TLSv1_3) {
  1a:	d506      	bpl.n	2a <wolfSSL_set_options+0x2a>
        if (ssl->version.minor == TLSv1_3_MINOR)
  1c:	f890 313d 	ldrb.w	r3, [r0, #317]	; 0x13d
  20:	2b04      	cmp	r3, #4
            ssl->version.minor = TLSv1_2_MINOR;
  22:	bf04      	itt	eq
  24:	2303      	moveq	r3, #3
  26:	f880 313d 	strbeq.w	r3, [r0, #317]	; 0x13d
    if ((ssl->options.mask & WOLFSSL_OP_NO_TLSv1_2) == WOLFSSL_OP_NO_TLSv1_2) {
  2a:	0108      	lsls	r0, r1, #4
  2c:	d506      	bpl.n	3c <wolfSSL_set_options+0x3c>
        if (ssl->version.minor == TLSv1_2_MINOR)
  2e:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
  32:	2b03      	cmp	r3, #3
            ssl->version.minor = TLSv1_1_MINOR;
  34:	bf04      	itt	eq
  36:	2302      	moveq	r3, #2
  38:	f884 313d 	strbeq.w	r3, [r4, #317]	; 0x13d
    if ((ssl->options.mask & WOLFSSL_OP_NO_TLSv1_1) == WOLFSSL_OP_NO_TLSv1_1) {
  3c:	014a      	lsls	r2, r1, #5
  3e:	d506      	bpl.n	4e <wolfSSL_set_options+0x4e>
        if (ssl->version.minor == TLSv1_1_MINOR)
  40:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
  44:	2b02      	cmp	r3, #2
            ssl->version.minor = TLSv1_MINOR;
  46:	bf04      	itt	eq
  48:	2301      	moveq	r3, #1
  4a:	f884 313d 	strbeq.w	r3, [r4, #317]	; 0x13d
    if ((ssl->options.mask & WOLFSSL_OP_NO_TLSv1) == WOLFSSL_OP_NO_TLSv1) {
  4e:	048b      	lsls	r3, r1, #18
  50:	d506      	bpl.n	60 <wolfSSL_set_options+0x60>
        if (ssl->version.minor == TLSv1_MINOR)
  52:	f894 313d 	ldrb.w	r3, [r4, #317]	; 0x13d
  56:	2b01      	cmp	r3, #1
            ssl->version.minor = SSLv3_MINOR;
  58:	bf04      	itt	eq
  5a:	2300      	moveq	r3, #0
  5c:	f884 313d 	strbeq.w	r3, [r4, #317]	; 0x13d
    if (ssl->options.side != WOLFSSL_NEITHER_END) {
  60:	f894 3270 	ldrb.w	r3, [r4, #624]	; 0x270
  64:	f003 0330 	and.w	r3, r3, #48	; 0x30
  68:	2b30      	cmp	r3, #48	; 0x30
  6a:	d02e      	beq.n	ca <wolfSSL_set_options+0xca>
        if (AllocateSuites(ssl) != 0)
  6c:	4620      	mov	r0, r4
    keySz = ssl->buffers.keySz;
  6e:	f8d4 50e8 	ldr.w	r5, [r4, #232]	; 0xe8
        if (AllocateSuites(ssl) != 0)
  72:	f7ff fffe 	bl	0 <AllocateSuites>
  76:	4603      	mov	r3, r0
  78:	2800      	cmp	r0, #0
  7a:	d1c5      	bne.n	8 <wolfSSL_set_options+0x8>
                   ssl->options.haveAnon, TRUE, ssl->options.side);
  7c:	f894 1270 	ldrb.w	r1, [r4, #624]	; 0x270
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
  80:	2001      	movs	r0, #1
  82:	f3c1 1101 	ubfx	r1, r1, #4, #2
  86:	910a      	str	r1, [sp, #40]	; 0x28
  88:	9009      	str	r0, [sp, #36]	; 0x24
                   ssl->options.haveAnon, TRUE, ssl->options.side);
  8a:	f894 1275 	ldrb.w	r1, [r4, #629]	; 0x275
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
  8e:	f3c1 1100 	ubfx	r1, r1, #4, #1
  92:	9108      	str	r1, [sp, #32]
                   ssl->options.haveFalconSig, ssl->options.haveDilithiumSig,
  94:	f894 1273 	ldrb.w	r1, [r4, #627]	; 0x273
        InitSuites(ssl->suites, ssl->version, keySz, haveRSA, havePSK,
  98:	09ca      	lsrs	r2, r1, #7
  9a:	9207      	str	r2, [sp, #28]
  9c:	f3c1 1280 	ubfx	r2, r1, #6, #1
  a0:	9206      	str	r2, [sp, #24]
  a2:	f3c1 1240 	ubfx	r2, r1, #5, #1
  a6:	e9cd 0204 	strd	r0, r2, [sp, #16]
  aa:	f3c1 0280 	ubfx	r2, r1, #2, #1
  ae:	9203      	str	r2, [sp, #12]
  b0:	f3c1 1200 	ubfx	r2, r1, #4, #1
  b4:	f3c1 01c0 	ubfx	r1, r1, #3, #1
  b8:	e9cd 3100 	strd	r3, r1, [sp]
  bc:	9202      	str	r2, [sp, #8]
  be:	f8d4 113c 	ldr.w	r1, [r4, #316]	; 0x13c
  c2:	6860      	ldr	r0, [r4, #4]
  c4:	462a      	mov	r2, r5
  c6:	f7ff fffe 	bl	0 <InitSuites>
    return ssl->options.mask;
  ca:	f8d4 026c 	ldr.w	r0, [r4, #620]	; 0x26c
  ce:	e79c      	b.n	a <wolfSSL_set_options+0xa>

Disassembly of section .text.wolfSSL_get_options:

00000000 <wolfSSL_get_options>:


long wolfSSL_get_options(const WOLFSSL* ssl)
{
    WOLFSSL_ENTER("wolfSSL_get_options");
    if(ssl == NULL)
   0:	b108      	cbz	r0, 6 <wolfSSL_get_options+0x6>
        return WOLFSSL_FAILURE;
    return ssl->options.mask;
   2:	f8d0 026c 	ldr.w	r0, [r0, #620]	; 0x26c
}
   6:	4770      	bx	lr

Disassembly of section .text.wolfSSL_version:

00000000 <wolfSSL_version>:
#endif /* OPENSSL_EXTRA */

int wolfSSL_version(WOLFSSL* ssl)
{
    WOLFSSL_ENTER("wolfSSL_version");
    if (ssl->version.major == SSLv3_MAJOR) {
   0:	f890 313c 	ldrb.w	r3, [r0, #316]	; 0x13c
   4:	2b03      	cmp	r3, #3
   6:	d106      	bne.n	16 <wolfSSL_version+0x16>
        switch (ssl->version.minor) {
   8:	f890 013d 	ldrb.w	r0, [r0, #317]	; 0x13d
   c:	2804      	cmp	r0, #4
   e:	d80e      	bhi.n	2e <wolfSSL_version+0x2e>
  10:	f500 7040 	add.w	r0, r0, #768	; 0x300
  14:	4770      	bx	lr
                return TLS1_3_VERSION;
            default:
                return WOLFSSL_FAILURE;
        }
    }
    else if (ssl->version.major == DTLS_MAJOR) {
  16:	2bfe      	cmp	r3, #254	; 0xfe
  18:	d109      	bne.n	2e <wolfSSL_version+0x2e>
        switch (ssl->version.minor) {
  1a:	f890 313d 	ldrb.w	r3, [r0, #317]	; 0x13d
  1e:	3304      	adds	r3, #4
  20:	b2db      	uxtb	r3, r3
  22:	2b03      	cmp	r3, #3
  24:	d803      	bhi.n	2e <wolfSSL_version+0x2e>
  26:	4a03      	ldr	r2, [pc, #12]	; (34 <wolfSSL_version+0x34>)
  28:	f832 0013 	ldrh.w	r0, [r2, r3, lsl #1]
  2c:	4770      	bx	lr
  2e:	2000      	movs	r0, #0
            default:
                return WOLFSSL_FAILURE;
        }
    }
    return WOLFSSL_FAILURE;
}
  30:	4770      	bx	lr
  32:	bf00      	nop
  34:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_get_SSL_CTX:

00000000 <wolfSSL_get_SSL_CTX>:

WOLFSSL_CTX* wolfSSL_get_SSL_CTX(WOLFSSL* ssl)
{
    WOLFSSL_ENTER("wolfSSL_get_SSL_CTX");
    return ssl->ctx;
}
   0:	6800      	ldr	r0, [r0, #0]
   2:	4770      	bx	lr

Disassembly of section .text.wolfSSL_X509_check_host:

00000000 <wolfSSL_X509_check_host>:


#ifndef NO_ASN
int wolfSSL_X509_check_host(WOLFSSL_X509 *x, const char *chk, size_t chklen,
                    unsigned int flags, char **peername)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460c      	mov	r4, r1
   4:	4617      	mov	r7, r2

    /* flags and peername not needed for Nginx. */
    (void)flags;
    (void)peername;

    if ((x == NULL) || (chk == NULL)) {
   6:	4605      	mov	r5, r0
   8:	b340      	cbz	r0, 5c <wolfSSL_X509_check_host+0x5c>
   a:	b339      	cbz	r1, 5c <wolfSSL_X509_check_host+0x5c>
        WOLFSSL_MSG("Invalid parameter");
        return WOLFSSL_FAILURE;
    }

    if (flags == WOLFSSL_NO_WILDCARDS) {
   c:	2b02      	cmp	r3, #2
   e:	d025      	beq.n	5c <wolfSSL_X509_check_host+0x5c>
        WOLFSSL_MSG("X509_CHECK_FLAG_NO_WILDCARDS not yet implemented");
        return WOLFSSL_FAILURE;
    }
    if (flags == WOLFSSL_NO_PARTIAL_WILDCARDS) {
  10:	2b04      	cmp	r3, #4
  12:	d023      	beq.n	5c <wolfSSL_X509_check_host+0x5c>
        WOLFSSL_MSG("X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS not yet implemented");
        return WOLFSSL_FAILURE;
    }

#ifdef WOLFSSL_SMALL_STACK
    dCert = (DecodedCert *)XMALLOC(sizeof(*dCert), x->heap,
  14:	f44f 7056 	mov.w	r0, #856	; 0x358
  18:	f7ff fffe 	bl	0 <malloc>
  1c:	4606      	mov	r6, r0
                                   DYNAMIC_TYPE_DCERT);
    if (dCert == NULL) {
  1e:	b1f8      	cbz	r0, 60 <wolfSSL_X509_check_host+0x60>
        WOLFSSL_MSG("\tout of memory");
        return WOLFSSL_FATAL_ERROR;
    }
#endif

    InitDecodedCert(dCert, x->derCert->buffer, x->derCert->length, NULL);
  20:	6fe9      	ldr	r1, [r5, #124]	; 0x7c
  22:	2300      	movs	r3, #0
  24:	688a      	ldr	r2, [r1, #8]
  26:	6809      	ldr	r1, [r1, #0]
  28:	f7ff fffe 	bl	0 <InitDecodedCert>
    ret = ParseCertRelative(dCert, CERT_TYPE, 0, NULL);
  2c:	2300      	movs	r3, #0
  2e:	461a      	mov	r2, r3
  30:	4619      	mov	r1, r3
  32:	4630      	mov	r0, r6
  34:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (ret != 0) {
  38:	4605      	mov	r5, r0
  3a:	b928      	cbnz	r0, 48 <wolfSSL_X509_check_host+0x48>
        goto out;
    }

    ret = CheckHostName(dCert, (char *)chk, chklen);
  3c:	463a      	mov	r2, r7
  3e:	4621      	mov	r1, r4
  40:	4630      	mov	r0, r6
  42:	f7ff fffe 	bl	0 <CheckHostName>
  46:	4605      	mov	r5, r0

out:

    FreeDecodedCert(dCert);
  48:	4630      	mov	r0, r6
  4a:	f7ff fffe 	bl	0 <FreeDecodedCert>
#ifdef WOLFSSL_SMALL_STACK
    XFREE(dCert, x->heap, DYNAMIC_TYPE_DCERT);
  4e:	4630      	mov	r0, r6
  50:	f7ff fffe 	bl	0 <free>
#endif

    if (ret != 0)
  54:	fab5 f085 	clz	r0, r5
  58:	0940      	lsrs	r0, r0, #5
        return WOLFSSL_FAILURE;
    return WOLFSSL_SUCCESS;
}
  5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return WOLFSSL_FAILURE;
  5c:	2000      	movs	r0, #0
  5e:	e7fc      	b.n	5a <wolfSSL_X509_check_host+0x5a>
        return WOLFSSL_FATAL_ERROR;
  60:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  64:	e7f9      	b.n	5a <wolfSSL_X509_check_host+0x5a>

Disassembly of section .text.wolfSSL_X509_check_ip_asc:

00000000 <wolfSSL_X509_check_ip_asc>:


int wolfSSL_X509_check_ip_asc(WOLFSSL_X509 *x, const char *ipasc,
        unsigned int flags)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460e      	mov	r6, r1
    WOLFSSL_ENTER("wolfSSL_X509_check_ip_asc");

    /* flags not yet implemented */
    (void)flags;

    if ((x == NULL) || (x->derCert == NULL) || (ipasc == NULL)) {
   4:	4604      	mov	r4, r0
   6:	b910      	cbnz	r0, e <wolfSSL_X509_check_ip_asc+0xe>

    if (ret == WOLFSSL_SUCCESS) {
        InitDecodedCert(dCert, x->derCert->buffer, x->derCert->length, NULL);
        ret = ParseCertRelative(dCert, CERT_TYPE, 0, NULL);
        if (ret != 0) {
            ret = WOLFSSL_FAILURE;
   8:	2400      	movs	r4, #0
    if (dCert != NULL)
        XFREE(dCert, x->heap, DYNAMIC_TYPE_DCERT);
#endif

    return ret;
}
   a:	4620      	mov	r0, r4
   c:	bd70      	pop	{r4, r5, r6, pc}
    if ((x == NULL) || (x->derCert == NULL) || (ipasc == NULL)) {
   e:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  10:	2b00      	cmp	r3, #0
  12:	d0f9      	beq.n	8 <wolfSSL_X509_check_ip_asc+0x8>
  14:	2900      	cmp	r1, #0
  16:	d0f7      	beq.n	8 <wolfSSL_X509_check_ip_asc+0x8>
        dCert = (DecodedCert *)XMALLOC(sizeof(*dCert), x->heap,
  18:	f44f 7056 	mov.w	r0, #856	; 0x358
  1c:	f7ff fffe 	bl	0 <malloc>
        if (dCert == NULL) {
  20:	4605      	mov	r5, r0
  22:	2800      	cmp	r0, #0
  24:	d0f0      	beq.n	8 <wolfSSL_X509_check_ip_asc+0x8>
        InitDecodedCert(dCert, x->derCert->buffer, x->derCert->length, NULL);
  26:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
  28:	2300      	movs	r3, #0
  2a:	688a      	ldr	r2, [r1, #8]
  2c:	6809      	ldr	r1, [r1, #0]
  2e:	f7ff fffe 	bl	0 <InitDecodedCert>
        ret = ParseCertRelative(dCert, CERT_TYPE, 0, NULL);
  32:	2300      	movs	r3, #0
  34:	461a      	mov	r2, r3
  36:	4619      	mov	r1, r3
  38:	4628      	mov	r0, r5
  3a:	f7ff fffe 	bl	0 <ParseCertRelative>
        if (ret != 0) {
  3e:	b968      	cbnz	r0, 5c <wolfSSL_X509_check_ip_asc+0x5c>
            ret = CheckIPAddr(dCert, ipasc);
  40:	4631      	mov	r1, r6
  42:	4628      	mov	r0, r5
  44:	f7ff fffe 	bl	0 <CheckIPAddr>
            if (ret != 0) {
  48:	fab0 f480 	clz	r4, r0
  4c:	0964      	lsrs	r4, r4, #5
        FreeDecodedCert(dCert);
  4e:	4628      	mov	r0, r5
  50:	f7ff fffe 	bl	0 <FreeDecodedCert>
        XFREE(dCert, x->heap, DYNAMIC_TYPE_DCERT);
  54:	4628      	mov	r0, r5
  56:	f7ff fffe 	bl	0 <free>
    return ret;
  5a:	e7d6      	b.n	a <wolfSSL_X509_check_ip_asc+0xa>
            ret = WOLFSSL_FAILURE;
  5c:	2400      	movs	r4, #0
  5e:	e7f6      	b.n	4e <wolfSSL_X509_check_ip_asc+0x4e>

tls.o:     file format elf32-littlearm


Disassembly of section .text.ctMaskEq:

00000000 <ctMaskEq>:
}

/* Constant time - mask set when a < b. */
WC_MISC_STATIC WC_INLINE byte ctMaskLT(int a, int b)
{
    return (byte)((((word32)b - (word32)a - 1) >> 31) - 1);
   0:	1e4b      	subs	r3, r1, #1
   2:	1a1b      	subs	r3, r3, r0
    return (byte)((((word32)a - (word32)b - 1) >> 31) - 1);
   4:	1a40      	subs	r0, r0, r1
}

/* Constant time - mask set when a == b. */
WC_MISC_STATIC WC_INLINE byte ctMaskEq(int a, int b)
{
    return (byte)((byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b)));
   6:	17db      	asrs	r3, r3, #31
    return (byte)((((word32)a - (word32)b - 1) >> 31) - 1);
   8:	3801      	subs	r0, #1
    return (byte)((byte)(~ctMaskGT(a, b)) & (byte)(~ctMaskLT(a, b)));
   a:	ea03 70e0 	and.w	r0, r3, r0, asr #31
}
   e:	b2c0      	uxtb	r0, r0
  10:	4770      	bx	lr

Disassembly of section .text.TLSX_SupportedCurve_ValidateRequest:

00000000 <TLSX_SupportedCurve_ValidateRequest>:
}
#else
static void TLSX_SupportedCurve_ValidateRequest(WOLFSSL* ssl, byte* semaphore)
{
    word16 i;
    const Suites* suites = WOLFSSL_SUITES(ssl);
   0:	6842      	ldr	r2, [r0, #4]
{
   2:	b530      	push	{r4, r5, lr}
    const Suites* suites = WOLFSSL_SUITES(ssl);
   4:	b90a      	cbnz	r2, a <TLSX_SupportedCurve_ValidateRequest+0xa>
   6:	6803      	ldr	r3, [r0, #0]
   8:	6ada      	ldr	r2, [r3, #44]	; 0x2c

    for (i = 0; i < suites->suiteSz; i += 2) {
   a:	8814      	ldrh	r4, [r2, #0]
   c:	2300      	movs	r3, #0
   e:	429c      	cmp	r4, r3
  10:	d804      	bhi.n	1c <TLSX_SupportedCurve_ValidateRequest+0x1c>
        }
        #endif
    }

    /* turns semaphore on to avoid sending this extension. */
    TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SUPPORTED_GROUPS));
  12:	784b      	ldrb	r3, [r1, #1]
  14:	f043 0304 	orr.w	r3, r3, #4
  18:	704b      	strb	r3, [r1, #1]
}
  1a:	bd30      	pop	{r4, r5, pc}
        if (suites->suites[i] == TLS13_BYTE)
  1c:	18d0      	adds	r0, r2, r3
  1e:	7900      	ldrb	r0, [r0, #4]
  20:	2813      	cmp	r0, #19
  22:	d0fa      	beq.n	1a <TLSX_SupportedCurve_ValidateRequest+0x1a>
        if ((suites->suites[i] == ECC_BYTE) ||
  24:	f000 05ef 	and.w	r5, r0, #239	; 0xef
  28:	2dc0      	cmp	r5, #192	; 0xc0
  2a:	d0f6      	beq.n	1a <TLSX_SupportedCurve_ValidateRequest+0x1a>
            (suites->suites[i] == ECDHE_PSK_BYTE) ||
  2c:	28cc      	cmp	r0, #204	; 0xcc
  2e:	d0f4      	beq.n	1a <TLSX_SupportedCurve_ValidateRequest+0x1a>
    for (i = 0; i < suites->suiteSz; i += 2) {
  30:	3302      	adds	r3, #2
  32:	b29b      	uxth	r3, r3
  34:	e7eb      	b.n	e <TLSX_SupportedCurve_ValidateRequest+0xe>

Disassembly of section .text.TLSX_PointFormat_ValidateRequest:

00000000 <TLSX_PointFormat_ValidateRequest>:
#ifdef HAVE_FFDHE
    (void)ssl;
    (void)semaphore;
#else
    word16 i;
    const Suites* suites = WOLFSSL_SUITES(ssl);
   0:	6842      	ldr	r2, [r0, #4]
{
   2:	b530      	push	{r4, r5, lr}
    const Suites* suites = WOLFSSL_SUITES(ssl);
   4:	b912      	cbnz	r2, c <TLSX_PointFormat_ValidateRequest+0xc>
   6:	6803      	ldr	r3, [r0, #0]
   8:	6ada      	ldr	r2, [r3, #44]	; 0x2c

    if (suites == NULL)
   a:	b13a      	cbz	r2, 1c <TLSX_PointFormat_ValidateRequest+0x1c>
        return;

    for (i = 0; i < suites->suiteSz; i += 2) {
   c:	8814      	ldrh	r4, [r2, #0]
   e:	2300      	movs	r3, #0
  10:	429c      	cmp	r4, r3
  12:	d804      	bhi.n	1e <TLSX_PointFormat_ValidateRequest+0x1e>
            return;
        #endif
        }
    }
   /* turns semaphore on to avoid sending this extension. */
   TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EC_POINT_FORMATS));
  14:	784b      	ldrb	r3, [r1, #1]
  16:	f043 0308 	orr.w	r3, r3, #8
  1a:	704b      	strb	r3, [r1, #1]
#endif
}
  1c:	bd30      	pop	{r4, r5, pc}
        if (suites->suites[i] == TLS13_BYTE)
  1e:	18d0      	adds	r0, r2, r3
  20:	7900      	ldrb	r0, [r0, #4]
  22:	2813      	cmp	r0, #19
  24:	d0fa      	beq.n	1c <TLSX_PointFormat_ValidateRequest+0x1c>
        if ((suites->suites[i] == ECC_BYTE) ||
  26:	f000 05ef 	and.w	r5, r0, #239	; 0xef
  2a:	2dc0      	cmp	r5, #192	; 0xc0
  2c:	d0f6      	beq.n	1c <TLSX_PointFormat_ValidateRequest+0x1c>
            (suites->suites[i] == ECDHE_PSK_BYTE) ||
  2e:	28cc      	cmp	r0, #204	; 0xcc
  30:	d0f4      	beq.n	1c <TLSX_PointFormat_ValidateRequest+0x1c>
    for (i = 0; i < suites->suiteSz; i += 2) {
  32:	3302      	adds	r3, #2
  34:	b29b      	uxth	r3, r3
  36:	e7eb      	b.n	10 <TLSX_PointFormat_ValidateRequest+0x10>

Disassembly of section .text.TLSX_GetSize:

00000000 <TLSX_GetSize>:
                        word16* pLength)
{
    int    ret = 0;
    TLSX*  extension;
    word16 length = 0;
    byte   isRequest = (msgType == client_hello ||
   0:	2a01      	cmp	r2, #1
{
   2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   6:	4614      	mov	r4, r2
    byte   isRequest = (msgType == client_hello ||
   8:	d002      	beq.n	10 <TLSX_GetSize+0x10>
   a:	3a0d      	subs	r2, #13
   c:	4254      	negs	r4, r2
   e:	4154      	adcs	r4, r2
    word16 length = 0;
  10:	2200      	movs	r2, #0
    switch (type) {
  12:	f64f 7701 	movw	r7, #65281	; 0xff01
        /* only extensions marked as response are sent back to the client. */
        if (!isRequest && !extension->resp)
            continue; /* skip! */

        /* ssl level extensions are expected to override ctx level ones. */
        if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
  16:	f04f 0c01 	mov.w	ip, #1
    while ((extension = list)) {
  1a:	b920      	cbnz	r0, 26 <TLSX_GetSize+0x26>
        /* marks the extension as processed so ctx level */
        /* extensions don't overlap with ssl level ones. */
        TURN_ON(semaphore, TLSX_ToSemaphore(extension->type));
    }

    *pLength += length;
  1c:	8819      	ldrh	r1, [r3, #0]
  1e:	440a      	add	r2, r1
  20:	801a      	strh	r2, [r3, #0]

    return ret;
}
  22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        list = extension->next;
  26:	f8d0 e010 	ldr.w	lr, [r0, #16]
        if (!isRequest && !extension->resp)
  2a:	b90c      	cbnz	r4, 30 <TLSX_GetSize+0x30>
  2c:	7b05      	ldrb	r5, [r0, #12]
  2e:	b345      	cbz	r5, 82 <TLSX_GetSize+0x82>
        if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
  30:	f8b0 a000 	ldrh.w	sl, [r0]
    switch (type) {
  34:	45ba      	cmp	sl, r7
  36:	bf14      	ite	ne
  38:	46d1      	movne	r9, sl
  3a:	f04f 093f 	moveq.w	r9, #63	; 0x3f
        if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
  3e:	ea4f 06d9 	mov.w	r6, r9, lsr #3
  42:	f009 0907 	and.w	r9, r9, #7
  46:	5d8d      	ldrb	r5, [r1, r6]
  48:	fa0c f909 	lsl.w	r9, ip, r9
  4c:	ea19 0f05 	tst.w	r9, r5
  50:	fa5f f889 	uxtb.w	r8, r9
  54:	d115      	bne.n	82 <TLSX_GetSize+0x82>
        length += HELLO_EXT_TYPE_SZ + OPAQUE16_LEN;
  56:	3204      	adds	r2, #4
        switch (extension->type) {
  58:	f1ba 0f0b 	cmp.w	sl, #11
        length += HELLO_EXT_TYPE_SZ + OPAQUE16_LEN;
  5c:	b292      	uxth	r2, r2
        switch (extension->type) {
  5e:	d017      	beq.n	90 <TLSX_GetSize+0x90>
  60:	f1ba 0f0d 	cmp.w	sl, #13
  64:	d01f      	beq.n	a6 <TLSX_GetSize+0xa6>
  66:	f1ba 0f0a 	cmp.w	sl, #10
  6a:	d107      	bne.n	7c <TLSX_GetSize+0x7c>
                length += EC_GET_SIZE((SupportedCurve*)extension->data);
  6c:	f8d0 9004 	ldr.w	r9, [r0, #4]
    word16 length = OPAQUE16_LEN; /* list length */
  70:	2002      	movs	r0, #2
    while ((curve = list)) {
  72:	f1b9 0f00 	cmp.w	r9, #0
  76:	d106      	bne.n	86 <TLSX_GetSize+0x86>
                length += SA_GET_SIZE(extension->data);
  78:	4402      	add	r2, r0
  7a:	b292      	uxth	r2, r2
        TURN_ON(semaphore, TLSX_ToSemaphore(extension->type));
  7c:	ea45 0508 	orr.w	r5, r5, r8
  80:	558d      	strb	r5, [r1, r6]
    word16 length = ENUM_LEN; /* list length */
  82:	4670      	mov	r0, lr
  84:	e7c9      	b.n	1a <TLSX_GetSize+0x1a>
        length += OPAQUE16_LEN; /* curve length */
  86:	3002      	adds	r0, #2
        list = curve->next;
  88:	f8d9 9004 	ldr.w	r9, [r9, #4]
        length += OPAQUE16_LEN; /* curve length */
  8c:	b280      	uxth	r0, r0
  8e:	e7f0      	b.n	72 <TLSX_GetSize+0x72>
                length += PF_GET_SIZE((PointFormat*)extension->data);
  90:	f8d0 9004 	ldr.w	r9, [r0, #4]
    word16 length = ENUM_LEN; /* list length */
  94:	2001      	movs	r0, #1
    while ((point = list)) {
  96:	f1b9 0f00 	cmp.w	r9, #0
  9a:	d0ed      	beq.n	78 <TLSX_GetSize+0x78>
        length += ENUM_LEN; /* format length */
  9c:	3001      	adds	r0, #1
        list = point->next;
  9e:	f8d9 9004 	ldr.w	r9, [r9, #4]
        length += ENUM_LEN; /* format length */
  a2:	b280      	uxth	r0, r0
  a4:	e7f7      	b.n	96 <TLSX_GetSize+0x96>
                length += SA_GET_SIZE(extension->data);
  a6:	f8d0 9004 	ldr.w	r9, [r0, #4]
    if (sa->hashSigAlgoSz == 0)
  aa:	f8b9 0004 	ldrh.w	r0, [r9, #4]
  ae:	b940      	cbnz	r0, c2 <TLSX_GetSize+0xc2>
        return OPAQUE16_LEN + WOLFSSL_SUITES(sa->ssl)->hashSigAlgoSz;
  b0:	f8d9 9000 	ldr.w	r9, [r9]
  b4:	f8d9 0004 	ldr.w	r0, [r9, #4]
  b8:	b910      	cbnz	r0, c0 <TLSX_GetSize+0xc0>
  ba:	f8d9 0000 	ldr.w	r0, [r9]
  be:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
  c0:	8840      	ldrh	r0, [r0, #2]
        return OPAQUE16_LEN + sa->hashSigAlgoSz;
  c2:	3002      	adds	r0, #2
  c4:	b280      	uxth	r0, r0
  c6:	e7d7      	b.n	78 <TLSX_GetSize+0x78>

Disassembly of section .text.TLSX_Write:

00000000 <TLSX_Write>:

/** Writes the extensions of a list in a buffer. */
static int TLSX_Write(TLSX* list, byte* output, byte* semaphore,
                         byte msgType, word16* pOffset)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int    ret = 0;
    TLSX*  extension;
    word16 offset = 0;
    word16 length_offset = 0;
    byte   isRequest = (msgType == client_hello ||
   4:	2b01      	cmp	r3, #1
{
   6:	b085      	sub	sp, #20
   8:	4606      	mov	r6, r0
   a:	460f      	mov	r7, r1
   c:	4691      	mov	r9, r2
    byte   isRequest = (msgType == client_hello ||
   e:	d003      	beq.n	18 <TLSX_Write+0x18>
  10:	f1a3 020d 	sub.w	r2, r3, #13
  14:	4253      	negs	r3, r2
  16:	4153      	adcs	r3, r2
  18:	9301      	str	r3, [sp, #4]
    word16 offset = 0;
  1a:	2400      	movs	r4, #0
    switch (type) {
  1c:	f64f 7a01 	movw	sl, #65281	; 0xff01
        /* only extensions marked as response are written in a response. */
        if (!isRequest && !extension->resp)
            continue; /* skip! */

        /* ssl level extensions are expected to override ctx level ones. */
        if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
  20:	f04f 0b01 	mov.w	fp, #1
    while ((extension = list)) {
  24:	b946      	cbnz	r6, 38 <TLSX_Write+0x38>
        /* if we encountered an error propagate it */
        if (ret != 0)
            break;
    }

    *pOffset += offset;
  26:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  28:	881b      	ldrh	r3, [r3, #0]
  2a:	441c      	add	r4, r3
  2c:	9b0e      	ldr	r3, [sp, #56]	; 0x38

    return ret;
}
  2e:	4630      	mov	r0, r6
    *pOffset += offset;
  30:	801c      	strh	r4, [r3, #0]
}
  32:	b005      	add	sp, #20
  34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        list = extension->next;
  38:	6933      	ldr	r3, [r6, #16]
  3a:	9302      	str	r3, [sp, #8]
        if (!isRequest && !extension->resp)
  3c:	9b01      	ldr	r3, [sp, #4]
  3e:	b913      	cbnz	r3, 46 <TLSX_Write+0x46>
  40:	7b33      	ldrb	r3, [r6, #12]
  42:	2b00      	cmp	r3, #0
  44:	d03a      	beq.n	bc <TLSX_Write+0xbc>
        if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
  46:	8832      	ldrh	r2, [r6, #0]
    switch (type) {
  48:	4552      	cmp	r2, sl
  4a:	bf14      	ite	ne
  4c:	4613      	movne	r3, r2
  4e:	233f      	moveq	r3, #63	; 0x3f
        if (!IS_OFF(semaphore, TLSX_ToSemaphore(extension->type)))
  50:	08d9      	lsrs	r1, r3, #3
  52:	f003 0307 	and.w	r3, r3, #7
  56:	f819 1001 	ldrb.w	r1, [r9, r1]
  5a:	fa0b f303 	lsl.w	r3, fp, r3
  5e:	4219      	tst	r1, r3
  60:	d12c      	bne.n	bc <TLSX_Write+0xbc>
        c16toa(extension->type, output + offset);
  62:	193b      	adds	r3, r7, r4
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  64:	0a11      	lsrs	r1, r2, #8
  66:	5539      	strb	r1, [r7, r4]
    c[1] =  (byte)(wc_u16       & 0xff);
  68:	705a      	strb	r2, [r3, #1]
        switch (extension->type) {
  6a:	8833      	ldrh	r3, [r6, #0]
        offset += HELLO_EXT_TYPE_SZ + OPAQUE16_LEN;
  6c:	1d25      	adds	r5, r4, #4
        switch (extension->type) {
  6e:	2b0b      	cmp	r3, #11
        offset += HELLO_EXT_TYPE_SZ + OPAQUE16_LEN;
  70:	b2ad      	uxth	r5, r5
        switch (extension->type) {
  72:	d030      	beq.n	d6 <TLSX_Write+0xd6>
  74:	2b0d      	cmp	r3, #13
  76:	d03b      	beq.n	f0 <TLSX_Write+0xf0>
  78:	2b0a      	cmp	r3, #10
  7a:	d165      	bne.n	148 <TLSX_Write+0x148>
                offset += EC_WRITE((SupportedCurve*)extension->data,
  7c:	6873      	ldr	r3, [r6, #4]
  7e:	197a      	adds	r2, r7, r5
    word16 offset = OPAQUE16_LEN;
  80:	2402      	movs	r4, #2
    while (list) {
  82:	b9eb      	cbnz	r3, c0 <TLSX_Write+0xc0>
    c16toa(offset - OPAQUE16_LEN, output); /* writing list length */
  84:	1ea3      	subs	r3, r4, #2
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  86:	f3c3 2107 	ubfx	r1, r3, #8, #8
  8a:	5579      	strb	r1, [r7, r5]
    c[1] =  (byte)(wc_u16       & 0xff);
  8c:	7053      	strb	r3, [r2, #1]
                offset += PF_WRITE((PointFormat*)extension->data,
  8e:	442c      	add	r4, r5
  90:	b2a4      	uxth	r4, r4
        c16toa(offset - length_offset, output + length_offset - OPAQUE16_LEN);
  92:	1b63      	subs	r3, r4, r5
  94:	3d02      	subs	r5, #2
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  96:	f3c3 2107 	ubfx	r1, r3, #8, #8
  9a:	197a      	adds	r2, r7, r5
  9c:	5579      	strb	r1, [r7, r5]
    c[1] =  (byte)(wc_u16       & 0xff);
  9e:	7053      	strb	r3, [r2, #1]
        TURN_ON(semaphore, TLSX_ToSemaphore(extension->type));
  a0:	8833      	ldrh	r3, [r6, #0]
            return 63;
  a2:	4553      	cmp	r3, sl
  a4:	bf08      	it	eq
  a6:	233f      	moveq	r3, #63	; 0x3f
        TURN_ON(semaphore, TLSX_ToSemaphore(extension->type));
  a8:	08da      	lsrs	r2, r3, #3
  aa:	f003 0307 	and.w	r3, r3, #7
  ae:	f819 1002 	ldrb.w	r1, [r9, r2]
  b2:	fa0b f303 	lsl.w	r3, fp, r3
  b6:	430b      	orrs	r3, r1
  b8:	f809 3002 	strb.w	r3, [r9, r2]
            return 63;
  bc:	9e02      	ldr	r6, [sp, #8]
  be:	e7b1      	b.n	24 <TLSX_Write+0x24>
        c16toa(list->name, output + offset);
  c0:	8819      	ldrh	r1, [r3, #0]
  c2:	1910      	adds	r0, r2, r4
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  c4:	ea4f 2c11 	mov.w	ip, r1, lsr #8
  c8:	f802 c004 	strb.w	ip, [r2, r4]
    c[1] =  (byte)(wc_u16       & 0xff);
  cc:	7041      	strb	r1, [r0, #1]
        offset += OPAQUE16_LEN;
  ce:	3402      	adds	r4, #2
        list = list->next;
  d0:	685b      	ldr	r3, [r3, #4]
        offset += OPAQUE16_LEN;
  d2:	b2a4      	uxth	r4, r4
        list = list->next;
  d4:	e7d5      	b.n	82 <TLSX_Write+0x82>
                offset += PF_WRITE((PointFormat*)extension->data,
  d6:	6873      	ldr	r3, [r6, #4]
  d8:	197a      	adds	r2, r7, r5
    word16 offset = ENUM_LEN;
  da:	2401      	movs	r4, #1
    while (list) {
  dc:	b913      	cbnz	r3, e4 <TLSX_Write+0xe4>
    output[0] = (byte)(offset - ENUM_LEN);
  de:	1e63      	subs	r3, r4, #1
  e0:	557b      	strb	r3, [r7, r5]
  e2:	e7d4      	b.n	8e <TLSX_Write+0x8e>
        output[offset++] = list->format;
  e4:	7818      	ldrb	r0, [r3, #0]
  e6:	5510      	strb	r0, [r2, r4]
  e8:	1c61      	adds	r1, r4, #1
        list = list->next;
  ea:	685b      	ldr	r3, [r3, #4]
        output[offset++] = list->format;
  ec:	b28c      	uxth	r4, r1
  ee:	e7f5      	b.n	dc <TLSX_Write+0xdc>
                offset += SA_WRITE(extension->data, output + offset);
  f0:	6873      	ldr	r3, [r6, #4]
    const Suites* suites = WOLFSSL_SUITES(sa->ssl);
  f2:	6819      	ldr	r1, [r3, #0]
  f4:	f8d1 8004 	ldr.w	r8, [r1, #4]
                offset += SA_WRITE(extension->data, output + offset);
  f8:	197a      	adds	r2, r7, r5
    const Suites* suites = WOLFSSL_SUITES(sa->ssl);
  fa:	f1b8 0f00 	cmp.w	r8, #0
  fe:	d102      	bne.n	106 <TLSX_Write+0x106>
 100:	6809      	ldr	r1, [r1, #0]
 102:	f8d1 802c 	ldr.w	r8, [r1, #44]	; 0x2c
    if (sa->hashSigAlgoSz == 0) {
 106:	8899      	ldrh	r1, [r3, #4]
        XMEMCPY(output + OPAQUE16_LEN, suites->hashSigAlgo,
 108:	1c90      	adds	r0, r2, #2
    if (sa->hashSigAlgoSz == 0) {
 10a:	b981      	cbnz	r1, 12e <TLSX_Write+0x12e>
        c16toa(suites->hashSigAlgoSz, output);
 10c:	f8b8 3002 	ldrh.w	r3, [r8, #2]
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 110:	0a19      	lsrs	r1, r3, #8
 112:	5579      	strb	r1, [r7, r5]
    c[1] =  (byte)(wc_u16       & 0xff);
 114:	7053      	strb	r3, [r2, #1]
        XMEMCPY(output + OPAQUE16_LEN, suites->hashSigAlgo,
 116:	f8b8 2002 	ldrh.w	r2, [r8, #2]
 11a:	f508 7198 	add.w	r1, r8, #304	; 0x130
 11e:	f7ff fffe 	bl	0 <memcpy>
        hashSigAlgoSz = suites->hashSigAlgoSz;
 122:	f8b8 3002 	ldrh.w	r3, [r8, #2]
    return OPAQUE16_LEN + hashSigAlgoSz;
 126:	3406      	adds	r4, #6
                offset += SA_WRITE(extension->data, output + offset);
 128:	fa13 f484 	uxtah	r4, r3, r4
 12c:	e7b0      	b.n	90 <TLSX_Write+0x90>
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
 12e:	ea4f 2c11 	mov.w	ip, r1, lsr #8
 132:	f807 c005 	strb.w	ip, [r7, r5]
    c[1] =  (byte)(wc_u16       & 0xff);
 136:	7051      	strb	r1, [r2, #1]
        XMEMCPY(output + OPAQUE16_LEN, sa->hashSigAlgo,
 138:	889a      	ldrh	r2, [r3, #4]
 13a:	9303      	str	r3, [sp, #12]
 13c:	1d99      	adds	r1, r3, #6
 13e:	f7ff fffe 	bl	0 <memcpy>
        hashSigAlgoSz = sa->hashSigAlgoSz;
 142:	9b03      	ldr	r3, [sp, #12]
 144:	889b      	ldrh	r3, [r3, #4]
 146:	e7ee      	b.n	126 <TLSX_Write+0x126>
        switch (extension->type) {
 148:	462c      	mov	r4, r5
 14a:	e7a2      	b.n	92 <TLSX_Write+0x92>

Disassembly of section .text.Hmac_HashUpdate:

00000000 <Hmac_HashUpdate>:
    switch (hmac->macType) {
   0:	f890 3224 	ldrb.w	r3, [r0, #548]	; 0x224
   4:	2b06      	cmp	r3, #6
   6:	d005      	beq.n	14 <Hmac_HashUpdate+0x14>
   8:	2b08      	cmp	r3, #8
   a:	d005      	beq.n	18 <Hmac_HashUpdate+0x18>
   c:	2b04      	cmp	r3, #4
   e:	d105      	bne.n	1c <Hmac_HashUpdate+0x1c>
            ret = wc_ShaUpdate(&hmac->hash.sha, data, sz);
  10:	f7ff bffe 	b.w	0 <wc_ShaUpdate>
            ret = wc_Sha256Update(&hmac->hash.sha256, data, sz);
  14:	f7ff bffe 	b.w	0 <wc_Sha256Update>
            ret = wc_Sha512Update(&hmac->hash.sha512, data, sz);
  18:	f7ff bffe 	b.w	0 <wc_Sha512Update>
}
  1c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  20:	4770      	bx	lr

Disassembly of section .text.TLSX_PointFormat_ValidateResponse.isra.0:

00000000 <TLSX_PointFormat_ValidateResponse.isra.0>:
    if (ssl->options.cipherSuite0 == TLS13_BYTE)
   0:	2813      	cmp	r0, #19
   2:	d009      	beq.n	18 <TLSX_PointFormat_ValidateResponse.isra.0+0x18>
    if (ssl->options.cipherSuite0 == ECC_BYTE ||
   4:	f000 03ef 	and.w	r3, r0, #239	; 0xef
   8:	2bc0      	cmp	r3, #192	; 0xc0
   a:	d005      	beq.n	18 <TLSX_PointFormat_ValidateResponse.isra.0+0x18>
        ssl->options.cipherSuite0 == ECDHE_PSK_BYTE ||
   c:	28cc      	cmp	r0, #204	; 0xcc
    TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_EC_POINT_FORMATS));
   e:	bf1e      	ittt	ne
  10:	784b      	ldrbne	r3, [r1, #1]
  12:	f043 0308 	orrne.w	r3, r3, #8
  16:	704b      	strbne	r3, [r1, #1]
}
  18:	4770      	bx	lr

Disassembly of section .text.BuildTlsHandshakeHash:

00000000 <BuildTlsHandshakeHash>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460e      	mov	r6, r1
   4:	4614      	mov	r4, r2
    if (ssl == NULL || hash == NULL || hashLen == NULL || *hashLen < HSHASH_SZ)
   6:	4605      	mov	r5, r0
   8:	b1f8      	cbz	r0, 4a <BuildTlsHandshakeHash+0x4a>
   a:	b1f1      	cbz	r1, 4a <BuildTlsHandshakeHash+0x4a>
   c:	b1ea      	cbz	r2, 4a <BuildTlsHandshakeHash+0x4a>
   e:	6813      	ldr	r3, [r2, #0]
  10:	2b23      	cmp	r3, #35	; 0x23
  12:	d91a      	bls.n	4a <BuildTlsHandshakeHash+0x4a>
    if (IsAtLeastTLSv1_2(ssl)) {
  14:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_2>
  18:	b190      	cbz	r0, 40 <BuildTlsHandshakeHash+0x40>
        if (ssl->specs.mac_algorithm <= sha256_mac ||
  1a:	f895 314a 	ldrb.w	r3, [r5, #330]	; 0x14a
  1e:	2b04      	cmp	r3, #4
  20:	d901      	bls.n	26 <BuildTlsHandshakeHash+0x26>
  22:	2b08      	cmp	r3, #8
  24:	d10e      	bne.n	44 <BuildTlsHandshakeHash+0x44>
            ret |= wc_Sha256GetHash(&ssl->hsHashes->hashSha256, hash);
  26:	68e8      	ldr	r0, [r5, #12]
  28:	4631      	mov	r1, r6
  2a:	f500 70a6 	add.w	r0, r0, #332	; 0x14c
  2e:	f7ff fffe 	bl	0 <wc_Sha256GetHash>
            hashSz = WC_SHA256_DIGEST_SIZE;
  32:	2320      	movs	r3, #32
    *hashLen = hashSz;
  34:	6023      	str	r3, [r4, #0]
        ret = BUILD_MSG_ERROR;
  36:	4b06      	ldr	r3, [pc, #24]	; (50 <BuildTlsHandshakeHash+0x50>)
  38:	2800      	cmp	r0, #0
  3a:	bf18      	it	ne
  3c:	4618      	movne	r0, r3
}
  3e:	bd70      	pop	{r4, r5, r6, pc}
    word32 hashSz = FINISHED_SZ;
  40:	2324      	movs	r3, #36	; 0x24
  42:	e7f7      	b.n	34 <BuildTlsHandshakeHash+0x34>
  44:	2324      	movs	r3, #36	; 0x24
    int ret = 0;
  46:	2000      	movs	r0, #0
  48:	e7f4      	b.n	34 <BuildTlsHandshakeHash+0x34>
        return BAD_FUNC_ARG;
  4a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  4e:	e7f6      	b.n	3e <BuildTlsHandshakeHash+0x3e>
  50:	fffffec0 	.word	0xfffffec0

Disassembly of section .text.BuildTlsFinished:

00000000 <BuildTlsFinished>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    word32 hashSz = HSHASH_SZ;
   4:	2324      	movs	r3, #36	; 0x24
{
   6:	b093      	sub	sp, #76	; 0x4c
    ret = BuildTlsHandshakeHash(ssl, handshake_hash, &hashSz);
   8:	eb0d 0403 	add.w	r4, sp, r3
{
   c:	460f      	mov	r7, r1
   e:	4616      	mov	r6, r2
    ret = BuildTlsHandshakeHash(ssl, handshake_hash, &hashSz);
  10:	4621      	mov	r1, r4
  12:	aa08      	add	r2, sp, #32
{
  14:	4605      	mov	r5, r0
    word32 hashSz = HSHASH_SZ;
  16:	9308      	str	r3, [sp, #32]
    ret = BuildTlsHandshakeHash(ssl, handshake_hash, &hashSz);
  18:	f7ff fffe 	bl	0 <BuildTlsFinished>
    if (ret == 0) {
  1c:	b968      	cbnz	r0, 3a <BuildTlsFinished+0x3a>
        if (XSTRNCMP((const char*)sender, (const char*)kTlsClientStr,
  1e:	491c      	ldr	r1, [pc, #112]	; (90 <BuildTlsFinished+0x90>)
  20:	2204      	movs	r2, #4
  22:	4630      	mov	r0, r6
  24:	f7ff fffe 	bl	0 <strncmp>
  28:	b178      	cbz	r0, 4a <BuildTlsFinished+0x4a>
        else if (XSTRNCMP((const char*)sender, (const char*)kTlsServerStr,
  2a:	491a      	ldr	r1, [pc, #104]	; (94 <BuildTlsFinished+0x94>)
  2c:	2204      	movs	r2, #4
  2e:	4630      	mov	r0, r6
  30:	f7ff fffe 	bl	0 <strncmp>
  34:	b348      	cbz	r0, 8a <BuildTlsFinished+0x8a>
            ret = BAD_FUNC_ARG;
  36:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  3a:	b013      	add	sp, #76	; 0x4c
  3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    while (len--) *z++ = 0;
  40:	f804 2b01 	strb.w	r2, [r4], #1
  44:	3b01      	subs	r3, #1
  46:	d2fb      	bcs.n	40 <BuildTlsFinished+0x40>
  48:	e7f7      	b.n	3a <BuildTlsFinished+0x3a>
            side = kTlsClientFinStr;
  4a:	f8df 804c 	ldr.w	r8, [pc, #76]	; 98 <BuildTlsFinished+0x98>
                      ssl->arrays->masterSecret, SECRET_LEN, side,
  4e:	68ae      	ldr	r6, [r5, #8]
            ret = wc_PRF_TLS((byte*)hashes, TLS_FINISHED_SZ,
  50:	f8dd 9020 	ldr.w	r9, [sp, #32]
  54:	4628      	mov	r0, r5
  56:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_2>
  5a:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
  5e:	9307      	str	r3, [sp, #28]
  60:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  62:	9306      	str	r3, [sp, #24]
  64:	f895 314a 	ldrb.w	r3, [r5, #330]	; 0x14a
                      ssl->arrays->masterSecret, SECRET_LEN, side,
  68:	3675      	adds	r6, #117	; 0x75
            ret = wc_PRF_TLS((byte*)hashes, TLS_FINISHED_SZ,
  6a:	e9cd 0304 	strd	r0, r3, [sp, #16]
  6e:	230f      	movs	r3, #15
  70:	e9cd 8300 	strd	r8, r3, [sp]
  74:	4632      	mov	r2, r6
  76:	2330      	movs	r3, #48	; 0x30
  78:	e9cd 4902 	strd	r4, r9, [sp, #8]
  7c:	210c      	movs	r1, #12
  7e:	4638      	mov	r0, r7
  80:	f7ff fffe 	bl	0 <wc_PRF_TLS>
        ForceZero(handshake_hash, hashSz);
  84:	9b08      	ldr	r3, [sp, #32]
  86:	2200      	movs	r2, #0
  88:	e7dc      	b.n	44 <BuildTlsFinished+0x44>
            side = kTlsServerFinStr;
  8a:	f8df 8010 	ldr.w	r8, [pc, #16]	; 9c <BuildTlsFinished+0x9c>
  8e:	e7de      	b.n	4e <BuildTlsFinished+0x4e>
	...

Disassembly of section .text.MakeTLSv1_2:

00000000 <MakeTLSv1_2>:
{
   0:	b082      	sub	sp, #8
}
   2:	f240 3003 	movw	r0, #771	; 0x303
   6:	b002      	add	sp, #8
   8:	4770      	bx	lr

Disassembly of section .text.wolfSSL_DeriveTlsKeys:

00000000 <wolfSSL_DeriveTlsKeys>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b098      	sub	sp, #96	; 0x60
    XMEMCPY(seed,           sr, RAN_LEN);
   6:	f10d 0820 	add.w	r8, sp, #32
{
   a:	4604      	mov	r4, r0
   c:	460d      	mov	r5, r1
   e:	4616      	mov	r6, r2
    XMEMCPY(seed,           sr, RAN_LEN);
  10:	991e      	ldr	r1, [sp, #120]	; 0x78
  12:	2220      	movs	r2, #32
  14:	4640      	mov	r0, r8
{
  16:	461f      	mov	r7, r3
    XMEMCPY(seed,           sr, RAN_LEN);
  18:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(seed + RAN_LEN, cr, RAN_LEN);
  1c:	991f      	ldr	r1, [sp, #124]	; 0x7c
  1e:	2220      	movs	r2, #32
  20:	a810      	add	r0, sp, #64	; 0x40
  22:	f7ff fffe 	bl	0 <memcpy>
    ret = wc_PRF_TLS(key_dig, key_dig_len, ms, msLen, key_label, KEY_LABEL_SZ,
  26:	2300      	movs	r3, #0
  28:	f06f 0201 	mvn.w	r2, #1
  2c:	e9cd 3206 	strd	r3, r2, [sp, #24]
  30:	9b21      	ldr	r3, [sp, #132]	; 0x84
  32:	9305      	str	r3, [sp, #20]
  34:	9b20      	ldr	r3, [sp, #128]	; 0x80
  36:	9304      	str	r3, [sp, #16]
  38:	2340      	movs	r3, #64	; 0x40
  3a:	e9cd 8302 	strd	r8, r3, [sp, #8]
  3e:	230d      	movs	r3, #13
  40:	9301      	str	r3, [sp, #4]
  42:	4b05      	ldr	r3, [pc, #20]	; (58 <wolfSSL_DeriveTlsKeys+0x58>)
  44:	9300      	str	r3, [sp, #0]
  46:	4632      	mov	r2, r6
  48:	463b      	mov	r3, r7
  4a:	4629      	mov	r1, r5
  4c:	4620      	mov	r0, r4
  4e:	f7ff fffe 	bl	0 <wc_PRF_TLS>
}
  52:	b018      	add	sp, #96	; 0x60
  54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  58:	00000000 	.word	0x00000000

Disassembly of section .text.DeriveTlsKeys:

00000000 <DeriveTlsKeys>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                        2 * ssl->specs.key_size  +
   4:	f8b0 3140 	ldrh.w	r3, [r0, #320]	; 0x140
    int   key_dig_len = 2 * ssl->specs.hash_size +
   8:	f890 514d 	ldrb.w	r5, [r0, #333]	; 0x14d
   c:	441d      	add	r5, r3
                        2 * ssl->specs.iv_size;
   e:	f8b0 3142 	ldrh.w	r3, [r0, #322]	; 0x142
{
  12:	b09b      	sub	sp, #108	; 0x6c
  14:	4604      	mov	r4, r0
    key_dig = (byte*)XMALLOC(MAX_PRF_DIG, ssl->heap, DYNAMIC_TYPE_DIGEST);
  16:	20e0      	movs	r0, #224	; 0xe0
                        2 * ssl->specs.key_size  +
  18:	441d      	add	r5, r3
    key_dig = (byte*)XMALLOC(MAX_PRF_DIG, ssl->heap, DYNAMIC_TYPE_DIGEST);
  1a:	f7ff fffe 	bl	0 <malloc>
    int   key_dig_len = 2 * ssl->specs.hash_size +
  1e:	006d      	lsls	r5, r5, #1
    if (key_dig == NULL) {
  20:	4606      	mov	r6, r0
  22:	2800      	cmp	r0, #0
  24:	d03b      	beq.n	9e <DeriveTlsKeys+0x9e>
        ret = _DeriveTlsKeys(key_dig, key_dig_len,
  26:	4620      	mov	r0, r4
                         ssl->arrays->masterSecret, SECRET_LEN,
  28:	68a7      	ldr	r7, [r4, #8]
        ret = _DeriveTlsKeys(key_dig, key_dig_len,
  2a:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_2>
    XMEMCPY(seed,           sr, RAN_LEN);
  2e:	f10d 0928 	add.w	r9, sp, #40	; 0x28
        ret = _DeriveTlsKeys(key_dig, key_dig_len,
  32:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
  36:	9309      	str	r3, [sp, #36]	; 0x24
  38:	4680      	mov	r8, r0
    XMEMCPY(seed,           sr, RAN_LEN);
  3a:	2220      	movs	r2, #32
  3c:	f107 0134 	add.w	r1, r7, #52	; 0x34
  40:	4648      	mov	r0, r9
        ret = _DeriveTlsKeys(key_dig, key_dig_len,
  42:	f894 a14a 	ldrb.w	sl, [r4, #330]	; 0x14a
  46:	f8d4 b024 	ldr.w	fp, [r4, #36]	; 0x24
    XMEMCPY(seed,           sr, RAN_LEN);
  4a:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(seed + RAN_LEN, cr, RAN_LEN);
  4e:	2220      	movs	r2, #32
  50:	f107 0114 	add.w	r1, r7, #20
  54:	a812      	add	r0, sp, #72	; 0x48
  56:	f7ff fffe 	bl	0 <memcpy>
    ret = wc_PRF_TLS(key_dig, key_dig_len, ms, msLen, key_label, KEY_LABEL_SZ,
  5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  5c:	e9cd b306 	strd	fp, r3, [sp, #24]
  60:	2340      	movs	r3, #64	; 0x40
  62:	e9cd 9302 	strd	r9, r3, [sp, #8]
  66:	230d      	movs	r3, #13
  68:	9301      	str	r3, [sp, #4]
  6a:	4b0e      	ldr	r3, [pc, #56]	; (a4 <DeriveTlsKeys+0xa4>)
  6c:	9300      	str	r3, [sp, #0]
  6e:	4629      	mov	r1, r5
  70:	e9cd 8a04 	strd	r8, sl, [sp, #16]
  74:	2330      	movs	r3, #48	; 0x30
  76:	f107 0275 	add.w	r2, r7, #117	; 0x75
  7a:	4630      	mov	r0, r6
  7c:	f7ff fffe 	bl	0 <wc_PRF_TLS>
    if (ret == 0)
  80:	4605      	mov	r5, r0
  82:	b928      	cbnz	r0, 90 <DeriveTlsKeys+0x90>
        ret = StoreKeys(ssl, key_dig, PROVISION_CLIENT_SERVER);
  84:	2203      	movs	r2, #3
  86:	4631      	mov	r1, r6
  88:	4620      	mov	r0, r4
  8a:	f7ff fffe 	bl	0 <StoreKeys>
  8e:	4605      	mov	r5, r0
    XFREE(key_dig, ssl->heap, DYNAMIC_TYPE_DIGEST);
  90:	4630      	mov	r0, r6
  92:	f7ff fffe 	bl	0 <free>
}
  96:	4628      	mov	r0, r5
  98:	b01b      	add	sp, #108	; 0x6c
  9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return MEMORY_E;
  9e:	f06f 057c 	mvn.w	r5, #124	; 0x7c
  a2:	e7f8      	b.n	96 <DeriveTlsKeys+0x96>
  a4:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_MakeTlsMasterSecret:

00000000 <wolfSSL_MakeTlsMasterSecret>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b098      	sub	sp, #96	; 0x60
    XMEMCPY(seed,           cr, RAN_LEN);
   6:	f10d 0820 	add.w	r8, sp, #32
{
   a:	4604      	mov	r4, r0
   c:	460d      	mov	r5, r1
   e:	4616      	mov	r6, r2
    XMEMCPY(seed,           cr, RAN_LEN);
  10:	991e      	ldr	r1, [sp, #120]	; 0x78
  12:	2220      	movs	r2, #32
  14:	4640      	mov	r0, r8
{
  16:	461f      	mov	r7, r3
    XMEMCPY(seed,           cr, RAN_LEN);
  18:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(seed + RAN_LEN, sr, RAN_LEN);
  1c:	991f      	ldr	r1, [sp, #124]	; 0x7c
  1e:	2220      	movs	r2, #32
  20:	a810      	add	r0, sp, #64	; 0x40
  22:	f7ff fffe 	bl	0 <memcpy>
    ret = wc_PRF_TLS(ms, msLen, pms, pmsLen, master_label, MASTER_LABEL_SZ,
  26:	2300      	movs	r3, #0
  28:	f06f 0201 	mvn.w	r2, #1
  2c:	e9cd 3206 	strd	r3, r2, [sp, #24]
  30:	9b21      	ldr	r3, [sp, #132]	; 0x84
  32:	9305      	str	r3, [sp, #20]
  34:	9b20      	ldr	r3, [sp, #128]	; 0x80
  36:	9304      	str	r3, [sp, #16]
  38:	2340      	movs	r3, #64	; 0x40
  3a:	e9cd 8302 	strd	r8, r3, [sp, #8]
  3e:	230d      	movs	r3, #13
  40:	9301      	str	r3, [sp, #4]
  42:	4b05      	ldr	r3, [pc, #20]	; (58 <wolfSSL_MakeTlsMasterSecret+0x58>)
  44:	9300      	str	r3, [sp, #0]
  46:	4632      	mov	r2, r6
  48:	463b      	mov	r3, r7
  4a:	4629      	mov	r1, r5
  4c:	4620      	mov	r0, r4
  4e:	f7ff fffe 	bl	0 <wc_PRF_TLS>
}
  52:	b018      	add	sp, #96	; 0x60
  54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  58:	00000000 	.word	0x00000000

Disassembly of section .text.MakeTlsMasterSecret:

00000000 <MakeTlsMasterSecret>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            ret = _MakeTlsMasterSecret(ssl->arrays->masterSecret,
   4:	6885      	ldr	r5, [r0, #8]
{
   6:	b09b      	sub	sp, #108	; 0x6c
   8:	4604      	mov	r4, r0
            ret = _MakeTlsMasterSecret(ssl->arrays->masterSecret,
   a:	e9d5 8901 	ldrd	r8, r9, [r5, #4]
   e:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_2>
    XMEMCPY(seed,           cr, RAN_LEN);
  12:	af0a      	add	r7, sp, #40	; 0x28
            ret = _MakeTlsMasterSecret(ssl->arrays->masterSecret,
  14:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
  18:	9309      	str	r3, [sp, #36]	; 0x24
  1a:	4606      	mov	r6, r0
    XMEMCPY(seed,           cr, RAN_LEN);
  1c:	2220      	movs	r2, #32
  1e:	f105 0114 	add.w	r1, r5, #20
  22:	4638      	mov	r0, r7
            ret = _MakeTlsMasterSecret(ssl->arrays->masterSecret,
  24:	f894 a14a 	ldrb.w	sl, [r4, #330]	; 0x14a
  28:	f8d4 b024 	ldr.w	fp, [r4, #36]	; 0x24
    XMEMCPY(seed,           cr, RAN_LEN);
  2c:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(seed + RAN_LEN, sr, RAN_LEN);
  30:	2220      	movs	r2, #32
  32:	f105 0134 	add.w	r1, r5, #52	; 0x34
  36:	a812      	add	r0, sp, #72	; 0x48
  38:	f7ff fffe 	bl	0 <memcpy>
    ret = wc_PRF_TLS(ms, msLen, pms, pmsLen, master_label, MASTER_LABEL_SZ,
  3c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  3e:	e9cd b306 	strd	fp, r3, [sp, #24]
  42:	2340      	movs	r3, #64	; 0x40
  44:	e9cd 7302 	strd	r7, r3, [sp, #8]
  48:	230d      	movs	r3, #13
  4a:	9301      	str	r3, [sp, #4]
  4c:	4b0a      	ldr	r3, [pc, #40]	; (78 <MakeTlsMasterSecret+0x78>)
  4e:	9300      	str	r3, [sp, #0]
  50:	e9cd 6a04 	strd	r6, sl, [sp, #16]
  54:	464b      	mov	r3, r9
  56:	4642      	mov	r2, r8
  58:	2130      	movs	r1, #48	; 0x30
  5a:	f105 0075 	add.w	r0, r5, #117	; 0x75
  5e:	f7ff fffe 	bl	0 <wc_PRF_TLS>
    if (ret == 0) {
  62:	b928      	cbnz	r0, 70 <MakeTlsMasterSecret+0x70>
        ret = DeriveTlsKeys(ssl);
  64:	4620      	mov	r0, r4
}
  66:	b01b      	add	sp, #108	; 0x6c
  68:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        ret = DeriveTlsKeys(ssl);
  6c:	f7ff bffe 	b.w	0 <MakeTlsMasterSecret>
}
  70:	b01b      	add	sp, #108	; 0x6c
  72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  76:	bf00      	nop
  78:	00000000 	.word	0x00000000

Disassembly of section .text.wolfSSL_make_eap_keys:

00000000 <wolfSSL_make_eap_keys>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4604      	mov	r4, r0
   6:	b088      	sub	sp, #32
    seed = (byte*)XMALLOC(SEED_LEN, ssl->heap, DYNAMIC_TYPE_SEED);
   8:	2040      	movs	r0, #64	; 0x40
{
   a:	460f      	mov	r7, r1
   c:	4690      	mov	r8, r2
   e:	461e      	mov	r6, r3
    seed = (byte*)XMALLOC(SEED_LEN, ssl->heap, DYNAMIC_TYPE_SEED);
  10:	f7ff fffe 	bl	0 <malloc>
    if (seed == NULL)
  14:	4605      	mov	r5, r0
  16:	b380      	cbz	r0, 7a <wolfSSL_make_eap_keys+0x7a>
    XMEMCPY(seed,           ssl->arrays->clientRandom, RAN_LEN);
  18:	68a1      	ldr	r1, [r4, #8]
  1a:	2220      	movs	r2, #32
  1c:	3114      	adds	r1, #20
  1e:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(seed + RAN_LEN, ssl->arrays->serverRandom, RAN_LEN);
  22:	68a1      	ldr	r1, [r4, #8]
  24:	2220      	movs	r2, #32
  26:	3134      	adds	r1, #52	; 0x34
  28:	18a8      	adds	r0, r5, r2
  2a:	f7ff fffe 	bl	0 <memcpy>
    ret = wc_PRF_TLS((byte*)msk, len, ssl->arrays->masterSecret, SECRET_LEN,
  2e:	68a2      	ldr	r2, [r4, #8]
              (const byte *)label, (word32)XSTRLEN(label), seed, SEED_LEN,
  30:	4630      	mov	r0, r6
    ret = wc_PRF_TLS((byte*)msk, len, ssl->arrays->masterSecret, SECRET_LEN,
  32:	f102 0975 	add.w	r9, r2, #117	; 0x75
              (const byte *)label, (word32)XSTRLEN(label), seed, SEED_LEN,
  36:	f7ff fffe 	bl	0 <strlen>
  3a:	4682      	mov	sl, r0
    ret = wc_PRF_TLS((byte*)msk, len, ssl->arrays->masterSecret, SECRET_LEN,
  3c:	4620      	mov	r0, r4
  3e:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_2>
  42:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
  46:	9307      	str	r3, [sp, #28]
  48:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4a:	9306      	str	r3, [sp, #24]
  4c:	f894 314a 	ldrb.w	r3, [r4, #330]	; 0x14a
  50:	e9cd 0304 	strd	r0, r3, [sp, #16]
  54:	2340      	movs	r3, #64	; 0x40
  56:	e9cd 5302 	strd	r5, r3, [sp, #8]
  5a:	e9cd 6a00 	strd	r6, sl, [sp]
  5e:	2330      	movs	r3, #48	; 0x30
  60:	464a      	mov	r2, r9
  62:	4641      	mov	r1, r8
  64:	4638      	mov	r0, r7
  66:	f7ff fffe 	bl	0 <wc_PRF_TLS>
  6a:	4604      	mov	r4, r0
    XFREE(seed, ssl->heap, DYNAMIC_TYPE_SEED);
  6c:	4628      	mov	r0, r5
  6e:	f7ff fffe 	bl	0 <free>
}
  72:	4620      	mov	r0, r4
  74:	b008      	add	sp, #32
  76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return MEMORY_E;
  7a:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  7e:	e7f8      	b.n	72 <wolfSSL_make_eap_keys+0x72>

Disassembly of section .text.wolfSSL_GetHmacType_ex:

00000000 <wolfSSL_GetHmacType_ex>:
    if (specs == NULL)
   0:	b140      	cbz	r0, 14 <wolfSSL_GetHmacType_ex+0x14>
    switch (specs->mac_algorithm) {
   2:	7a83      	ldrb	r3, [r0, #10]
   4:	2b02      	cmp	r3, #2
   6:	d008      	beq.n	1a <wolfSSL_GetHmacType_ex+0x1a>
            return WC_SHA256;
   8:	2b04      	cmp	r3, #4
   a:	bf14      	ite	ne
   c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  10:	2006      	moveq	r0, #6
  12:	4770      	bx	lr
        return BAD_FUNC_ARG;
  14:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  18:	4770      	bx	lr
    switch (specs->mac_algorithm) {
  1a:	2004      	movs	r0, #4
}
  1c:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetHmacType:

00000000 <wolfSSL_GetHmacType>:
    if (ssl == NULL)
   0:	b118      	cbz	r0, a <wolfSSL_GetHmacType+0xa>
    return wolfSSL_GetHmacType_ex(&ssl->specs);
   2:	f500 70a0 	add.w	r0, r0, #320	; 0x140
   6:	f7ff bffe 	b.w	0 <wolfSSL_GetHmacType>
}
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   e:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetTlsHmacInner:

00000000 <wolfSSL_SetTlsHmacInner>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460c      	mov	r4, r1
   4:	4616      	mov	r6, r2
   6:	461f      	mov	r7, r3
    if (ssl == NULL || inner == NULL)
   8:	4605      	mov	r5, r0
   a:	b1b8      	cbz	r0, 3c <wolfSSL_SetTlsHmacInner+0x3c>
   c:	b1b1      	cbz	r1, 3c <wolfSSL_SetTlsHmacInner+0x3c>
    XMEMSET(inner, 0, WOLFSSL_TLS_HMAC_INNER_SZ);
   e:	220d      	movs	r2, #13
  10:	2100      	movs	r1, #0
  12:	4620      	mov	r0, r4
  14:	f7ff fffe 	bl	0 <memset>
    WriteSEQ(ssl, verify, inner);
  18:	4628      	mov	r0, r5
  1a:	9906      	ldr	r1, [sp, #24]
  1c:	4622      	mov	r2, r4
  1e:	f7ff fffe 	bl	0 <WriteSEQ>
    inner[SEQ_SZ] = (byte)content;
  22:	7227      	strb	r7, [r4, #8]
    inner[SEQ_SZ + ENUM_LEN]            = ssl->version.major;
  24:	f895 313c 	ldrb.w	r3, [r5, #316]	; 0x13c
  28:	7263      	strb	r3, [r4, #9]
    inner[SEQ_SZ + ENUM_LEN + ENUM_LEN] = ssl->version.minor;
  2a:	f895 313d 	ldrb.w	r3, [r5, #317]	; 0x13d
  2e:	72a3      	strb	r3, [r4, #10]
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  30:	f3c6 2307 	ubfx	r3, r6, #8, #8
  34:	72e3      	strb	r3, [r4, #11]
    c[1] =  (byte)(wc_u16       & 0xff);
  36:	7326      	strb	r6, [r4, #12]
    return 0;
  38:	2000      	movs	r0, #0
}
  3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
  3c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  40:	e7fb      	b.n	3a <wolfSSL_SetTlsHmacInner+0x3a>

Disassembly of section .text.TLS_hmac:

00000000 <TLS_hmac>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f5ad 7d57 	sub.w	sp, sp, #860	; 0x35c
   8:	461f      	mov	r7, r3
   a:	9de2      	ldr	r5, [sp, #904]	; 0x388
   c:	9103      	str	r1, [sp, #12]
   e:	e9dd 93e0 	ldrd	r9, r3, [sp, #896]	; 0x380
  12:	4690      	mov	r8, r2
    if (ssl == NULL)
  14:	4604      	mov	r4, r0
  16:	2800      	cmp	r0, #0
  18:	f000 8194 	beq.w	344 <TLS_hmac+0x344>
    if (!ssl->options.dtls)
  1c:	f890 2272 	ldrb.w	r2, [r0, #626]	; 0x272
    hashSz = ssl->specs.hash_size;
  20:	f890 a14d 	ldrb.w	sl, [r0, #333]	; 0x14d
    if (!ssl->options.dtls)
  24:	0752      	lsls	r2, r2, #29
        wolfSSL_SetTlsHmacInner(ssl, myInner, sz, content, epochOrder);
  26:	bf46      	itte	mi
  28:	9ae3      	ldrmi	r2, [sp, #908]	; 0x38c
  2a:	9200      	strmi	r2, [sp, #0]
        wolfSSL_SetTlsHmacInner(ssl, myInner, sz, content, verify);
  2c:	9500      	strpl	r5, [sp, #0]
        wolfSSL_SetTlsHmacInner(ssl, myInner, sz, content, epochOrder);
  2e:	463a      	mov	r2, r7
  30:	a910      	add	r1, sp, #64	; 0x40
  32:	f7ff fffe 	bl	0 <TLS_hmac>
    ret = wc_HmacInit(&hmac, ssl->heap, ssl->devId);
  36:	f8d4 22bc 	ldr.w	r2, [r4, #700]	; 0x2bc
  3a:	6a61      	ldr	r1, [r4, #36]	; 0x24
  3c:	a84c      	add	r0, sp, #304	; 0x130
  3e:	f7ff fffe 	bl	0 <wc_HmacInit>
    if (ret != 0)
  42:	4602      	mov	r2, r0
  44:	2800      	cmp	r0, #0
  46:	f040 8081 	bne.w	14c <TLS_hmac+0x14c>
    macSecret = wolfSSL_GetMacSecret(ssl, verify);
  4a:	4629      	mov	r1, r5
  4c:	4620      	mov	r0, r4
  4e:	f7ff fffe 	bl	0 <wolfSSL_GetMacSecret>
  52:	4602      	mov	r2, r0
    ret = wc_HmacSetKey(&hmac, wolfSSL_GetHmacType(ssl),
  54:	4620      	mov	r0, r4
  56:	f7ff fffe 	bl	0 <TLS_hmac>
  5a:	f894 314d 	ldrb.w	r3, [r4, #333]	; 0x14d
  5e:	4601      	mov	r1, r0
  60:	a84c      	add	r0, sp, #304	; 0x130
  62:	f7ff fffe 	bl	0 <wc_HmacSetKey>
    if (ret == 0) {
  66:	4602      	mov	r2, r0
  68:	2800      	cmp	r0, #0
  6a:	d16a      	bne.n	142 <TLS_hmac+0x142>
        if (verify && padSz >= 0) {
  6c:	2d00      	cmp	r5, #0
  6e:	f000 8151 	beq.w	314 <TLS_hmac+0x314>
  72:	f1b9 0f00 	cmp.w	r9, #0
  76:	f2c0 814d 	blt.w	314 <TLS_hmac+0x314>
    switch (hmac->macType) {
  7a:	f89d 6354 	ldrb.w	r6, [sp, #852]	; 0x354
  7e:	2e06      	cmp	r6, #6
  80:	d069      	beq.n	156 <TLS_hmac+0x156>
  82:	2e08      	cmp	r6, #8
  84:	d06a      	beq.n	15c <TLS_hmac+0x15c>
  86:	2e04      	cmp	r6, #4
  88:	f040 813f 	bne.w	30a <TLS_hmac+0x30a>
            padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1;
  8c:	2409      	movs	r4, #9
            blockSz = WC_SHA_BLOCK_SIZE;
  8e:	2540      	movs	r5, #64	; 0x40
            blockBits = 6;
  90:	2606      	movs	r6, #6
  92:	444f      	add	r7, r9
    maxLen = WOLFSSL_TLS_HMAC_INNER_SZ + sz - 1 - macLen;
  94:	f107 030d 	add.w	r3, r7, #13
  98:	9306      	str	r3, [sp, #24]
    realLen = maxLen - in[sz - 1];
  9a:	eb08 030a 	add.w	r3, r8, sl
    c[0] = (byte)((wc_u32 >> 24) & 0xff);
  9e:	2200      	movs	r2, #0
  a0:	f813 9007 	ldrb.w	r9, [r3, r7]
  a4:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
  a8:	f107 030d 	add.w	r3, r7, #13
  ac:	eba3 0909 	sub.w	r9, r3, r9
    realLen += blockSz;
  b0:	eb05 0309 	add.w	r3, r5, r9
  b4:	f3c3 5147 	ubfx	r1, r3, #21, #8
    c[1] = (byte)((wc_u32 >> 16) & 0xff);
  b8:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
    c[2] = (byte)((wc_u32 >>  8) & 0xff);
  bc:	f88d 203a 	strb.w	r2, [sp, #58]	; 0x3a
    c32toa(realLen >> ((sizeof(word32) * 8) - 3), lenBytes);
  c0:	0f5a      	lsrs	r2, r3, #29
    c[3] =  (byte)(wc_u32        & 0xff);
  c2:	f88d 203b 	strb.w	r2, [sp, #59]	; 0x3b
    c[0] = (byte)((wc_u32 >> 24) & 0xff);
  c6:	f88d 103c 	strb.w	r1, [sp, #60]	; 0x3c
    c32toa(realLen << 3, lenBytes + sizeof(word32));
  ca:	00da      	lsls	r2, r3, #3
    c[1] = (byte)((wc_u32 >> 16) & 0xff);
  cc:	f3c3 314f 	ubfx	r1, r3, #13, #16
  d0:	f88d 103d 	strb.w	r1, [sp, #61]	; 0x3d
    c[2] = (byte)((wc_u32 >>  8) & 0xff);
  d4:	f3c3 1357 	ubfx	r3, r3, #5, #24
    c[3] =  (byte)(wc_u32        & 0xff);
  d8:	f88d 203f 	strb.w	r2, [sp, #63]	; 0x3f
    ret = Hmac_HashUpdate(hmac, (unsigned char*)hmac->ipad, blockSz);
  dc:	a984      	add	r1, sp, #528	; 0x210
  de:	462a      	mov	r2, r5
  e0:	a84c      	add	r0, sp, #304	; 0x130
    c[2] = (byte)((wc_u32 >>  8) & 0xff);
  e2:	f88d 303e 	strb.w	r3, [sp, #62]	; 0x3e
  e6:	f7ff fffe 	bl	0 <TLS_hmac>
    if (ret != 0)
  ea:	4601      	mov	r1, r0
  ec:	2800      	cmp	r0, #0
  ee:	f040 810f 	bne.w	310 <TLS_hmac+0x310>
    extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz);
  f2:	f107 030d 	add.w	r3, r7, #13
    blockMask = blockSz - 1;
  f6:	f105 3bff 	add.w	fp, r5, #4294967295	; 0xffffffff
    extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz);
  fa:	4423      	add	r3, r4
    blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock;
  fc:	370c      	adds	r7, #12
}

/* Constant time - bit set when a <= b. */
WC_MISC_STATIC WC_INLINE byte ctSetLTE(int a, int b)
{
    return (byte)(((word32)a - (word32)b - 1) >> 31);
  fe:	43e2      	mvns	r2, r4
    extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz);
 100:	ea03 030b 	and.w	r3, r3, fp
    blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock;
 104:	442f      	add	r7, r5
 106:	4413      	add	r3, r2
 108:	40f7      	lsrs	r7, r6
 10a:	eb07 73d3 	add.w	r3, r7, r3, lsr #31
    safeBlocks = blocks - 6;
 10e:	1f9f      	subs	r7, r3, #6
    XMEMSET(hmac->innerHash, 0, macLen);
 110:	9005      	str	r0, [sp, #20]
 112:	4652      	mov	r2, sl
 114:	a8c4      	add	r0, sp, #784	; 0x310
    blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock;
 116:	9304      	str	r3, [sp, #16]
    XMEMSET(hmac->innerHash, 0, macLen);
 118:	f7ff fffe 	bl	0 <memset>
    if (safeBlocks > 0) {
 11c:	2f00      	cmp	r7, #0
 11e:	9905      	ldr	r1, [sp, #20]
 120:	dd20      	ble.n	164 <TLS_hmac+0x164>
        ret = Hmac_HashUpdate(hmac, header, WOLFSSL_TLS_HMAC_INNER_SZ);
 122:	220d      	movs	r2, #13
 124:	a910      	add	r1, sp, #64	; 0x40
 126:	a84c      	add	r0, sp, #304	; 0x130
 128:	f7ff fffe 	bl	0 <TLS_hmac>
        if (ret != 0)
 12c:	4602      	mov	r2, r0
 12e:	b940      	cbnz	r0, 142 <TLS_hmac+0x142>
        ret = Hmac_HashUpdate(hmac, in, safeBlocks * blockSz -
 130:	fb07 f205 	mul.w	r2, r7, r5
 134:	3a0d      	subs	r2, #13
 136:	4641      	mov	r1, r8
 138:	a84c      	add	r0, sp, #304	; 0x130
 13a:	f7ff fffe 	bl	0 <TLS_hmac>
        if (ret != 0)
 13e:	4602      	mov	r2, r0
 140:	b188      	cbz	r0, 166 <TLS_hmac+0x166>
    wc_HmacFree(&hmac);
 142:	a84c      	add	r0, sp, #304	; 0x130
 144:	9203      	str	r2, [sp, #12]
 146:	f7ff fffe 	bl	0 <wc_HmacFree>
    return ret;
 14a:	9a03      	ldr	r2, [sp, #12]
}
 14c:	4610      	mov	r0, r2
 14e:	f50d 7d57 	add.w	sp, sp, #860	; 0x35c
 152:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1;
 156:	2409      	movs	r4, #9
            blockSz = WC_SHA_BLOCK_SIZE;
 158:	2540      	movs	r5, #64	; 0x40
 15a:	e79a      	b.n	92 <TLS_hmac+0x92>
    switch (hmac->macType) {
 15c:	2411      	movs	r4, #17
 15e:	2580      	movs	r5, #128	; 0x80
 160:	2607      	movs	r6, #7
 162:	e796      	b.n	92 <TLS_hmac+0x92>
        safeBlocks = 0;
 164:	460f      	mov	r7, r1
    lastBlockLen = realLen & blockMask;
 166:	ea0b 0309 	and.w	r3, fp, r9
    extraLen = ((blockSz * 2 - padSz - lastBlockLen) & blockMask) + 1;
 16a:	ebc4 0445 	rsb	r4, r4, r5, lsl #1
 16e:	1ae4      	subs	r4, r4, r3
 170:	ea04 0b0b 	and.w	fp, r4, fp
 174:	f10b 0b01 	add.w	fp, fp, #1
    lenBlock = (realLen + extraLen) >> blockBits;
 178:	44cb      	add	fp, r9
    lastBlockLen = realLen & blockMask;
 17a:	9305      	str	r3, [sp, #20]
    lenBlock = (realLen + extraLen) >> blockBits;
 17c:	fa2b f306 	lsr.w	r3, fp, r6
 180:	9307      	str	r3, [sp, #28]
    XMEMSET(digest, 0, macLen);
 182:	9803      	ldr	r0, [sp, #12]
    eocBlock = realLen >> blockBits;
 184:	fa29 f306 	lsr.w	r3, r9, r6
    XMEMSET(digest, 0, macLen);
 188:	4652      	mov	r2, sl
 18a:	2100      	movs	r1, #0
    eocBlock = realLen >> blockBits;
 18c:	9308      	str	r3, [sp, #32]
    XMEMSET(digest, 0, macLen);
 18e:	f7ff fffe 	bl	0 <memset>
                b = ctMaskSel(isOutBlock, lenBytes[j - (blockSz - 8)], b);
 192:	abd6      	add	r3, sp, #856	; 0x358
 194:	1b5b      	subs	r3, r3, r5
 196:	f5a3 7346 	sub.w	r3, r3, #792	; 0x318
    k = safeBlocks * blockSz;
 19a:	fb07 fb05 	mul.w	fp, r7, r5
                b = ctMaskSel(isOutBlock, lenBytes[j - (blockSz - 8)], b);
 19e:	930c      	str	r3, [sp, #48]	; 0x30
    for (i = safeBlocks; i < blocks; i++) {
 1a0:	9b04      	ldr	r3, [sp, #16]
 1a2:	42bb      	cmp	r3, r7
 1a4:	dc33      	bgt.n	20e <TLS_hmac+0x20e>
    enum wc_HashType hashType = (enum wc_HashType)hmac->macType;
 1a6:	f89d 4354 	ldrb.w	r4, [sp, #852]	; 0x354
    int digestSz = wc_HashGetDigestSize(hashType);
 1aa:	4620      	mov	r0, r4
 1ac:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
 1b0:	4605      	mov	r5, r0
    int blockSz = wc_HashGetBlockSize(hashType);
 1b2:	4620      	mov	r0, r4
 1b4:	f7ff fffe 	bl	0 <wc_HashGetBlockSize>
    if ((digestSz >= 0) && (blockSz >= 0)) {
 1b8:	2d00      	cmp	r5, #0
    int blockSz = wc_HashGetBlockSize(hashType);
 1ba:	4606      	mov	r6, r0
    if ((digestSz >= 0) && (blockSz >= 0)) {
 1bc:	f2c0 80a5 	blt.w	30a <TLS_hmac+0x30a>
 1c0:	2800      	cmp	r0, #0
 1c2:	f2c0 80a2 	blt.w	30a <TLS_hmac+0x30a>
        ret = wc_HashInit(&hash, hashType);
 1c6:	4621      	mov	r1, r4
 1c8:	a814      	add	r0, sp, #80	; 0x50
 1ca:	f7ff fffe 	bl	0 <wc_HashInit>
    if (ret == 0) {
 1ce:	4602      	mov	r2, r0
 1d0:	2800      	cmp	r0, #0
 1d2:	d1b6      	bne.n	142 <TLS_hmac+0x142>
        ret = wc_HashUpdate(&hash, hashType, (byte*)hmac->opad,
 1d4:	aaa4      	add	r2, sp, #656	; 0x290
 1d6:	4633      	mov	r3, r6
 1d8:	4621      	mov	r1, r4
 1da:	a814      	add	r0, sp, #80	; 0x50
 1dc:	f7ff fffe 	bl	0 <wc_HashUpdate>
        if (ret == 0)
 1e0:	4602      	mov	r2, r0
 1e2:	b968      	cbnz	r0, 200 <TLS_hmac+0x200>
            ret = wc_HashUpdate(&hash, hashType, (byte*)hmac->innerHash,
 1e4:	aac4      	add	r2, sp, #784	; 0x310
 1e6:	462b      	mov	r3, r5
 1e8:	4621      	mov	r1, r4
 1ea:	a814      	add	r0, sp, #80	; 0x50
 1ec:	f7ff fffe 	bl	0 <wc_HashUpdate>
        if (ret == 0)
 1f0:	4602      	mov	r2, r0
 1f2:	b928      	cbnz	r0, 200 <TLS_hmac+0x200>
            ret = wc_HashFinal(&hash, hashType, mac);
 1f4:	9a03      	ldr	r2, [sp, #12]
 1f6:	4621      	mov	r1, r4
 1f8:	a814      	add	r0, sp, #80	; 0x50
 1fa:	f7ff fffe 	bl	0 <wc_HashFinal>
 1fe:	4602      	mov	r2, r0
        wc_HashFree(&hash, hashType);
 200:	4621      	mov	r1, r4
 202:	a814      	add	r0, sp, #80	; 0x50
 204:	9203      	str	r2, [sp, #12]
 206:	f7ff fffe 	bl	0 <wc_HashFree>
 20a:	9a03      	ldr	r2, [sp, #12]
 20c:	e799      	b.n	142 <TLS_hmac+0x142>
        unsigned char isEocBlock = ctMaskEq(i, eocBlock);
 20e:	9908      	ldr	r1, [sp, #32]
 210:	4638      	mov	r0, r7
 212:	f7ff fffe 	bl	0 <TLS_hmac>
        unsigned char isOutBlock = ctMaskEq(i, lenBlock);
 216:	9907      	ldr	r1, [sp, #28]
        unsigned char isEocBlock = ctMaskEq(i, eocBlock);
 218:	4681      	mov	r9, r0
        unsigned char isOutBlock = ctMaskEq(i, lenBlock);
 21a:	4638      	mov	r0, r7
 21c:	f7ff fffe 	bl	0 <TLS_hmac>
    return (byte)((((word32)a - (word32)b - 1) >> 31) - 1);
 220:	9b05      	ldr	r3, [sp, #20]
 222:	43db      	mvns	r3, r3
 224:	9309      	str	r3, [sp, #36]	; 0x24
                b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];
 226:	f1a8 030d 	sub.w	r3, r8, #13
 22a:	930b      	str	r3, [sp, #44]	; 0x2c
            b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;
 22c:	ea69 0300 	orn	r3, r9, r0
 230:	930a      	str	r3, [sp, #40]	; 0x28
        unsigned char isOutBlock = ctMaskEq(i, lenBlock);
 232:	4604      	mov	r4, r0
 234:	465e      	mov	r6, fp
        for (j = 0; j < blockSz; j++) {
 236:	2200      	movs	r2, #0
            if (j >= blockSz - 8) {
 238:	f1a5 0308 	sub.w	r3, r5, #8
            unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;
 23c:	9905      	ldr	r1, [sp, #20]
 23e:	930d      	str	r3, [sp, #52]	; 0x34
 240:	4610      	mov	r0, r2
 242:	f7ff fffe 	bl	0 <TLS_hmac>
 246:	9b09      	ldr	r3, [sp, #36]	; 0x24
 248:	1899      	adds	r1, r3, r2
 24a:	0fc9      	lsrs	r1, r1, #31
 24c:	3901      	subs	r1, #1
 24e:	ea09 0c00 	and.w	ip, r9, r0
            unsigned char pastEoc = ctMaskGT(j, eocIndex) & isEocBlock;
 252:	ea09 0101 	and.w	r1, r9, r1
            if (k < WOLFSSL_TLS_HMAC_INNER_SZ)
 256:	2e0c      	cmp	r6, #12
 258:	9b0d      	ldr	r3, [sp, #52]	; 0x34
            unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock;
 25a:	fa5f fc8c 	uxtb.w	ip, ip
            unsigned char pastEoc = ctMaskGT(j, eocIndex) & isEocBlock;
 25e:	b2c8      	uxtb	r0, r1
            if (k < WOLFSSL_TLS_HMAC_INNER_SZ)
 260:	d83a      	bhi.n	2d8 <TLS_hmac+0x2d8>
                b = header[k];
 262:	a910      	add	r1, sp, #64	; 0x40
                b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];
 264:	f811 e006 	ldrb.w	lr, [r1, r6]
    return (byte)((b & ((byte)~(word32)m)) | (a & m));
 268:	f08e 0180 	eor.w	r1, lr, #128	; 0x80
 26c:	ea0c 0c01 	and.w	ip, ip, r1
            b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;
 270:	990a      	ldr	r1, [sp, #40]	; 0x28
 272:	ea8e 0e0c 	eor.w	lr, lr, ip
 276:	ea21 0000 	bic.w	r0, r1, r0
            if (j >= blockSz - 8) {
 27a:	4293      	cmp	r3, r2
            k++;
 27c:	f106 0601 	add.w	r6, r6, #1
            b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock;
 280:	ea0e 0000 	and.w	r0, lr, r0
            if (j >= blockSz - 8) {
 284:	dc04      	bgt.n	290 <TLS_hmac+0x290>
 286:	990c      	ldr	r1, [sp, #48]	; 0x30
 288:	5c89      	ldrb	r1, [r1, r2]
 28a:	4041      	eors	r1, r0
 28c:	4021      	ands	r1, r4
 28e:	4048      	eors	r0, r1
            hashBlock[j] = b;
 290:	a914      	add	r1, sp, #80	; 0x50
 292:	5488      	strb	r0, [r1, r2]
        for (j = 0; j < blockSz; j++) {
 294:	3201      	adds	r2, #1
 296:	4295      	cmp	r5, r2
 298:	d1d0      	bne.n	23c <TLS_hmac+0x23c>
        ret = Hmac_HashUpdate(hmac, hashBlock, blockSz);
 29a:	462a      	mov	r2, r5
 29c:	a84c      	add	r0, sp, #304	; 0x130
 29e:	f7ff fffe 	bl	0 <TLS_hmac>
            k++;
 2a2:	44ab      	add	fp, r5
        if (ret != 0)
 2a4:	4602      	mov	r2, r0
 2a6:	2800      	cmp	r0, #0
 2a8:	f47f af4b 	bne.w	142 <TLS_hmac+0x142>
    switch (hmac->macType) {
 2ac:	f89d 3354 	ldrb.w	r3, [sp, #852]	; 0x354
 2b0:	2b06      	cmp	r3, #6
 2b2:	a914      	add	r1, sp, #80	; 0x50
 2b4:	d018      	beq.n	2e8 <TLS_hmac+0x2e8>
 2b6:	2b08      	cmp	r3, #8
 2b8:	d01a      	beq.n	2f0 <TLS_hmac+0x2f0>
 2ba:	2b04      	cmp	r3, #4
 2bc:	d125      	bne.n	30a <TLS_hmac+0x30a>
            ret = wc_ShaFinalRaw(&hmac->hash.sha, hash);
 2be:	a84c      	add	r0, sp, #304	; 0x130
 2c0:	f7ff fffe 	bl	0 <wc_ShaFinalRaw>
            ret = wc_Sha512FinalRaw(&hmac->hash.sha512, hash);
 2c4:	4602      	mov	r2, r0
        if (ret != 0)
 2c6:	2800      	cmp	r0, #0
 2c8:	f47f af3b 	bne.w	142 <TLS_hmac+0x142>
 2cc:	abc4      	add	r3, sp, #784	; 0x310
 2ce:	ae14      	add	r6, sp, #80	; 0x50
        for (j = 0; j < macLen; j++)
 2d0:	4592      	cmp	sl, r2
 2d2:	dc11      	bgt.n	2f8 <TLS_hmac+0x2f8>
    for (i = safeBlocks; i < blocks; i++) {
 2d4:	3701      	adds	r7, #1
 2d6:	e763      	b.n	1a0 <TLS_hmac+0x1a0>
            else if (k < maxLen)
 2d8:	9906      	ldr	r1, [sp, #24]
 2da:	42b1      	cmp	r1, r6
 2dc:	d901      	bls.n	2e2 <TLS_hmac+0x2e2>
                b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ];
 2de:	990b      	ldr	r1, [sp, #44]	; 0x2c
 2e0:	e7c0      	b.n	264 <TLS_hmac+0x264>
            unsigned char b = 0;
 2e2:	f04f 0e00 	mov.w	lr, #0
 2e6:	e7bf      	b.n	268 <TLS_hmac+0x268>
            ret = wc_Sha256FinalRaw(&hmac->hash.sha256, hash);
 2e8:	a84c      	add	r0, sp, #304	; 0x130
 2ea:	f7ff fffe 	bl	0 <wc_Sha256FinalRaw>
 2ee:	e7e9      	b.n	2c4 <TLS_hmac+0x2c4>
            ret = wc_Sha512FinalRaw(&hmac->hash.sha512, hash);
 2f0:	a84c      	add	r0, sp, #304	; 0x130
 2f2:	f7ff fffe 	bl	0 <wc_Sha512FinalRaw>
 2f6:	e7e5      	b.n	2c4 <TLS_hmac+0x2c4>
            ((unsigned char*)hmac->innerHash)[j] |= hashBlock[j] & isOutBlock;
 2f8:	f816 0b01 	ldrb.w	r0, [r6], #1
 2fc:	7819      	ldrb	r1, [r3, #0]
 2fe:	4020      	ands	r0, r4
 300:	4301      	orrs	r1, r0
 302:	f803 1b01 	strb.w	r1, [r3], #1
        for (j = 0; j < macLen; j++)
 306:	3201      	adds	r2, #1
 308:	e7e2      	b.n	2d0 <TLS_hmac+0x2d0>
    switch (hmac->macType) {
 30a:	f06f 02ac 	mvn.w	r2, #172	; 0xac
 30e:	e718      	b.n	142 <TLS_hmac+0x142>
 310:	4602      	mov	r2, r0
                ret = Hmac_UpdateFinal_CT(&hmac, digest, in,
 312:	e716      	b.n	142 <TLS_hmac+0x142>
            ret = wc_HmacUpdate(&hmac, myInner, sizeof(myInner));
 314:	220d      	movs	r2, #13
 316:	a910      	add	r1, sp, #64	; 0x40
 318:	a84c      	add	r0, sp, #304	; 0x130
 31a:	f7ff fffe 	bl	0 <wc_HmacUpdate>
            if (ret == 0)
 31e:	4602      	mov	r2, r0
 320:	2800      	cmp	r0, #0
 322:	f47f af0e 	bne.w	142 <TLS_hmac+0x142>
                ret = wc_HmacUpdate(&hmac, in, sz);                /* content */
 326:	463a      	mov	r2, r7
 328:	4641      	mov	r1, r8
 32a:	a84c      	add	r0, sp, #304	; 0x130
 32c:	f7ff fffe 	bl	0 <wc_HmacUpdate>
            if (ret == 0)
 330:	4602      	mov	r2, r0
 332:	2800      	cmp	r0, #0
 334:	f47f af05 	bne.w	142 <TLS_hmac+0x142>
                ret = wc_HmacFinal(&hmac, digest);
 338:	9903      	ldr	r1, [sp, #12]
 33a:	a84c      	add	r0, sp, #304	; 0x130
 33c:	f7ff fffe 	bl	0 <wc_HmacFinal>
 340:	4602      	mov	r2, r0
 342:	e6fe      	b.n	142 <TLS_hmac+0x142>
        return BAD_FUNC_ARG;
 344:	f06f 02ac 	mvn.w	r2, #172	; 0xac
 348:	e700      	b.n	14c <TLS_hmac+0x14c>

Disassembly of section .text.TLSX_HandleUnsupportedExtension:

00000000 <TLSX_HandleUnsupportedExtension>:
{
   0:	b508      	push	{r3, lr}
    SendAlert(ssl, alert_fatal, unsupported_extension);
   2:	226e      	movs	r2, #110	; 0x6e
   4:	2102      	movs	r1, #2
   6:	f7ff fffe 	bl	0 <SendAlert>
}
   a:	f46f 70d6 	mvn.w	r0, #428	; 0x1ac
   e:	bd08      	pop	{r3, pc}

Disassembly of section .text.TLSX_SignatureAlgorithms_New:

00000000 <TLSX_SignatureAlgorithms_New>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    sa = (SignatureAlgorithms*)XMALLOC(sizeof(*sa) + hashSigAlgoSz, heap,
   2:	f101 0708 	add.w	r7, r1, #8
{
   6:	4606      	mov	r6, r0
    sa = (SignatureAlgorithms*)XMALLOC(sizeof(*sa) + hashSigAlgoSz, heap,
   8:	4638      	mov	r0, r7
{
   a:	460d      	mov	r5, r1
    sa = (SignatureAlgorithms*)XMALLOC(sizeof(*sa) + hashSigAlgoSz, heap,
   c:	f7ff fffe 	bl	0 <malloc>
    if (sa != NULL) {
  10:	4604      	mov	r4, r0
  12:	b128      	cbz	r0, 20 <TLSX_SignatureAlgorithms_New+0x20>
        XMEMSET(sa, 0, sizeof(*sa) + hashSigAlgoSz);
  14:	463a      	mov	r2, r7
  16:	2100      	movs	r1, #0
  18:	f7ff fffe 	bl	0 <memset>
        sa->ssl = ssl;
  1c:	6026      	str	r6, [r4, #0]
        sa->hashSigAlgoSz = hashSigAlgoSz;
  1e:	80a5      	strh	r5, [r4, #4]
}
  20:	4620      	mov	r0, r4
  22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.TLSX_SignatureAlgorithms_FreeAll:

00000000 <TLSX_SignatureAlgorithms_FreeAll>:
    XFREE(sa, heap, DYNAMIC_TYPE_TLSX);
   0:	b108      	cbz	r0, 6 <TLSX_SignatureAlgorithms_FreeAll+0x6>
   2:	f7ff bffe 	b.w	0 <free>
}
   6:	4770      	bx	lr

Disassembly of section .text.TLSX_Find:

00000000 <TLSX_Find>:
    while (extension && extension->type != type)
   0:	b110      	cbz	r0, 8 <TLSX_Find+0x8>
   2:	8803      	ldrh	r3, [r0, #0]
   4:	428b      	cmp	r3, r1
   6:	d100      	bne.n	a <TLSX_Find+0xa>
}
   8:	4770      	bx	lr
        extension = extension->next;
   a:	6900      	ldr	r0, [r0, #16]
   c:	e7f8      	b.n	0 <TLSX_Find>

Disassembly of section .text.TLSX_CheckUnsupportedExtension:

00000000 <TLSX_CheckUnsupportedExtension>:
{
   0:	b508      	push	{r3, lr}
   2:	4602      	mov	r2, r0
    TLSX *extension = TLSX_Find(ssl->extensions, type);
   4:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
   8:	f7ff fffe 	bl	0 <TLSX_CheckUnsupportedExtension>
    if (!extension)
   c:	b918      	cbnz	r0, 16 <TLSX_CheckUnsupportedExtension+0x16>
        extension = TLSX_Find(ssl->ctx->extensions, type);
   e:	6813      	ldr	r3, [r2, #0]
  10:	6e58      	ldr	r0, [r3, #100]	; 0x64
  12:	f7ff fffe 	bl	0 <TLSX_CheckUnsupportedExtension>
}
  16:	fab0 f080 	clz	r0, r0
  1a:	0940      	lsrs	r0, r0, #5
  1c:	bd08      	pop	{r3, pc}

Disassembly of section .text.TLSX_SetResponse:

00000000 <TLSX_SetResponse>:
{
   0:	b508      	push	{r3, lr}
    TLSX *extension = TLSX_Find(ssl->extensions, type);
   2:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
   6:	f7ff fffe 	bl	0 <TLSX_SetResponse>
    if (extension)
   a:	b108      	cbz	r0, 10 <TLSX_SetResponse+0x10>
        extension->resp = 1;
   c:	2301      	movs	r3, #1
   e:	7303      	strb	r3, [r0, #12]
}
  10:	bd08      	pop	{r3, pc}

Disassembly of section .text.TLSX_ValidateSupportedCurves:

00000000 <TLSX_ValidateSupportedCurves>:
                                 word32* ecdhCurveOID) {
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (first == CHACHA_BYTE) {
   4:	29cc      	cmp	r1, #204	; 0xcc
                                 word32* ecdhCurveOID) {
   6:	b085      	sub	sp, #20
   8:	4606      	mov	r6, r0
   a:	4688      	mov	r8, r1
   c:	461d      	mov	r5, r3
    if (first == CHACHA_BYTE) {
   e:	d109      	bne.n	24 <TLSX_ValidateSupportedCurves+0x24>
        switch (second) {
  10:	2aab      	cmp	r2, #171	; 0xab
  12:	d805      	bhi.n	20 <TLSX_ValidateSupportedCurves+0x20>
  14:	2aa9      	cmp	r2, #169	; 0xa9
  16:	d801      	bhi.n	1c <TLSX_ValidateSupportedCurves+0x1c>
  18:	2a15      	cmp	r2, #21
  1a:	d107      	bne.n	2c <TLSX_ValidateSupportedCurves+0x2c>
        return 1; /* no suite restriction */
  1c:	2001      	movs	r0, #1
  1e:	e041      	b.n	a4 <TLSX_ValidateSupportedCurves+0xa4>
        switch (second) {
  20:	2aad      	cmp	r2, #173	; 0xad
  22:	e7fa      	b.n	1a <TLSX_ValidateSupportedCurves+0x1a>
    if (first == ECC_BYTE || first == ECDHE_PSK_BYTE || first == CHACHA_BYTE)
  24:	f001 03ef 	and.w	r3, r1, #239	; 0xef
  28:	2bc0      	cmp	r3, #192	; 0xc0
  2a:	d1f7      	bne.n	1c <TLSX_ValidateSupportedCurves+0x1c>
        extension = TLSX_Find(ssl->extensions, TLSX_SUPPORTED_GROUPS);
  2c:	f8d6 02c0 	ldr.w	r0, [r6, #704]	; 0x2c0
  30:	210a      	movs	r1, #10
  32:	f7ff fffe 	bl	0 <TLSX_ValidateSupportedCurves>
    if (!extension)
  36:	2800      	cmp	r0, #0
  38:	d0f0      	beq.n	1c <TLSX_ValidateSupportedCurves+0x1c>
            switch (second) {
  3a:	f102 0452 	add.w	r4, r2, #82	; 0x52
  3e:	b2e4      	uxtb	r4, r4
    word32          currOid   = ssl->ecdhCurveOID;
  40:	f8d6 e290 	ldr.w	lr, [r6, #656]	; 0x290
            switch (second) {
  44:	9402      	str	r4, [sp, #8]
  46:	f1a2 0423 	sub.w	r4, r2, #35	; 0x23
    for (curve = (SupportedCurve*)extension->data;
  4a:	f8d0 a004 	ldr.w	sl, [r0, #4]
    word32          nextSz    = 80; /* Maximum known curve size is 66. */
  4e:	2150      	movs	r1, #80	; 0x50
    int             key       = 0; /* validate key       */
  50:	2000      	movs	r0, #0
            switch (second) {
  52:	b2e4      	uxtb	r4, r4
    word32          currOid   = ssl->ecdhCurveOID;
  54:	46f1      	mov	r9, lr
    int             ephmSuite = 0;
  56:	9001      	str	r0, [sp, #4]
    word32          nextOid   = 0;
  58:	4607      	mov	r7, r0
    word32          defSz     = 80; /* Maximum known curve size is 66. */
  5a:	468c      	mov	ip, r1
    word32          defOid    = 0;
  5c:	4603      	mov	r3, r0
            switch (second) {
  5e:	9403      	str	r4, [sp, #12]
    for (curve = (SupportedCurve*)extension->data;
  60:	f1ba 0f00 	cmp.w	sl, #0
  64:	d000      	beq.n	68 <TLSX_ValidateSupportedCurves+0x68>
         curve && !key;
  66:	b300      	cbz	r0, aa <TLSX_ValidateSupportedCurves+0xaa>
    *ecdhCurveOID = ssl->ecdhCurveOID;
  68:	f8c5 e000 	str.w	lr, [r5]
    if (*ecdhCurveOID == 0 && defSz == ssl->eccTempKeySz)
  6c:	f1be 0f00 	cmp.w	lr, #0
  70:	d105      	bne.n	7e <TLSX_ValidateSupportedCurves+0x7e>
  72:	f8b6 22a4 	ldrh.w	r2, [r6, #676]	; 0x2a4
  76:	4562      	cmp	r2, ip
        *ecdhCurveOID = defOid;
  78:	bf04      	itt	eq
  7a:	602b      	streq	r3, [r5, #0]
        key = 1;
  7c:	2001      	moveq	r0, #1
    if (*ecdhCurveOID == 0) {
  7e:	682a      	ldr	r2, [r5, #0]
  80:	b90a      	cbnz	r2, 86 <TLSX_ValidateSupportedCurves+0x86>
  82:	464a      	mov	r2, r9
        key = 1;
  84:	2001      	movs	r0, #1
  86:	602a      	str	r2, [r5, #0]
    if (*ecdhCurveOID == 0 && defSz == nextSz)
  88:	b912      	cbnz	r2, 90 <TLSX_ValidateSupportedCurves+0x90>
  8a:	458c      	cmp	ip, r1
        *ecdhCurveOID = defOid;
  8c:	bf08      	it	eq
  8e:	602b      	streq	r3, [r5, #0]
    if (*ecdhCurveOID == 0)
  90:	682b      	ldr	r3, [r5, #0]
  92:	2b00      	cmp	r3, #0
  94:	bf08      	it	eq
  96:	463b      	moveq	r3, r7
  98:	602b      	str	r3, [r5, #0]
    if (*ecdhCurveOID == 0 && ephmSuite)
  9a:	b91b      	cbnz	r3, a4 <TLSX_ValidateSupportedCurves+0xa4>
        key = 0;
  9c:	9b01      	ldr	r3, [sp, #4]
  9e:	2b00      	cmp	r3, #0
  a0:	bf18      	it	ne
  a2:	2000      	movne	r0, #0
}
  a4:	b005      	add	sp, #20
  a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch (curve->name) {
  aa:	f8ba 4000 	ldrh.w	r4, [sl]
  ae:	2c17      	cmp	r4, #23
  b0:	d033      	beq.n	11a <TLSX_ValidateSupportedCurves+0x11a>
  b2:	2c1d      	cmp	r4, #29
  b4:	d142      	bne.n	13c <TLSX_ValidateSupportedCurves+0x13c>
  b6:	f240 146d 	movw	r4, #365	; 0x16d
        if (defOid == 0 && ssl->eccTempKeySz <= octets && defSz > octets) {
  ba:	b953      	cbnz	r3, d2 <TLSX_ValidateSupportedCurves+0xd2>
  bc:	f8b6 b2a4 	ldrh.w	fp, [r6, #676]	; 0x2a4
  c0:	f1bb 0f20 	cmp.w	fp, #32
  c4:	d805      	bhi.n	d2 <TLSX_ValidateSupportedCurves+0xd2>
  c6:	f1bc 0f20 	cmp.w	ip, #32
  ca:	bf1c      	itt	ne
  cc:	4623      	movne	r3, r4
            defSz = octets;
  ce:	f04f 0c20 	movne.w	ip, #32
        if (currOid == 0 && ssl->eccTempKeySz == octets)
  d2:	f1b9 0f00 	cmp.w	r9, #0
  d6:	d104      	bne.n	e2 <TLSX_ValidateSupportedCurves+0xe2>
  d8:	f8b6 b2a4 	ldrh.w	fp, [r6, #676]	; 0x2a4
  dc:	f1bb 0f20 	cmp.w	fp, #32
  e0:	d03a      	beq.n	158 <TLSX_ValidateSupportedCurves+0x158>
        if ((nextOid == 0 || nextSz > octets) && ssl->eccTempKeySz <= octets) {
  e2:	b10f      	cbz	r7, e8 <TLSX_ValidateSupportedCurves+0xe8>
  e4:	2920      	cmp	r1, #32
  e6:	d006      	beq.n	f6 <TLSX_ValidateSupportedCurves+0xf6>
  e8:	f8b6 b2a4 	ldrh.w	fp, [r6, #676]	; 0x2a4
  ec:	f1bb 0f20 	cmp.w	fp, #32
  f0:	bf9c      	itt	ls
  f2:	4627      	movls	r7, r4
  f4:	2120      	movls	r1, #32
        if (first == ECC_BYTE) {
  f6:	f1b8 0fc0 	cmp.w	r8, #192	; 0xc0
  fa:	d124      	bne.n	146 <TLSX_ValidateSupportedCurves+0x146>
            switch (second) {
  fc:	2a2c      	cmp	r2, #44	; 0x2c
  fe:	d820      	bhi.n	142 <TLSX_ValidateSupportedCurves+0x142>
 100:	2a2a      	cmp	r2, #42	; 0x2a
 102:	d803      	bhi.n	10c <TLSX_ValidateSupportedCurves+0x10c>
 104:	2a0a      	cmp	r2, #10
 106:	d80b      	bhi.n	120 <TLSX_ValidateSupportedCurves+0x120>
 108:	2a06      	cmp	r2, #6
 10a:	d90c      	bls.n	126 <TLSX_ValidateSupportedCurves+0x126>
                    key |= ssl->ecdhCurveOID == oid;
 10c:	eba4 040e 	sub.w	r4, r4, lr
 110:	4260      	negs	r0, r4
 112:	4160      	adcs	r0, r4
                    ephmSuite = 1;
 114:	2401      	movs	r4, #1
 116:	9401      	str	r4, [sp, #4]
                break;
 118:	e010      	b.n	13c <TLSX_ValidateSupportedCurves+0x13c>
                oid = ECC_SECP256R1_OID;
 11a:	f240 240e 	movw	r4, #526	; 0x20e
 11e:	e7cc      	b.n	ba <TLSX_ValidateSupportedCurves+0xba>
            switch (second) {
 120:	9803      	ldr	r0, [sp, #12]
 122:	2801      	cmp	r0, #1
 124:	d9f2      	bls.n	10c <TLSX_ValidateSupportedCurves+0x10c>
                    if (oid == ECC_X25519_OID && defOid == oid) {
 126:	f240 106d 	movw	r0, #365	; 0x16d
 12a:	4284      	cmp	r4, r0
 12c:	d112      	bne.n	154 <TLSX_ValidateSupportedCurves+0x154>
 12e:	4283      	cmp	r3, r0
                    key = 1;
 130:	f04f 0001 	mov.w	r0, #1
                    if (oid == ECC_X25519_OID && defOid == oid) {
 134:	d102      	bne.n	13c <TLSX_ValidateSupportedCurves+0x13c>
                        defSz = 80;
 136:	f04f 0c50 	mov.w	ip, #80	; 0x50
                        defOid = 0;
 13a:	2300      	movs	r3, #0
         curve = curve->next) {
 13c:	f8da a004 	ldr.w	sl, [sl, #4]
 140:	e78e      	b.n	60 <TLSX_ValidateSupportedCurves+0x60>
            switch (second) {
 142:	9802      	ldr	r0, [sp, #8]
 144:	e7ed      	b.n	122 <TLSX_ValidateSupportedCurves+0x122>
        if (first == CHACHA_BYTE) {
 146:	f1b8 0fcc 	cmp.w	r8, #204	; 0xcc
 14a:	d1f7      	bne.n	13c <TLSX_ValidateSupportedCurves+0x13c>
            switch (second) {
 14c:	2a14      	cmp	r2, #20
 14e:	d0dd      	beq.n	10c <TLSX_ValidateSupportedCurves+0x10c>
 150:	2aa9      	cmp	r2, #169	; 0xa9
 152:	d0db      	beq.n	10c <TLSX_ValidateSupportedCurves+0x10c>
 154:	2001      	movs	r0, #1
 156:	e7f1      	b.n	13c <TLSX_ValidateSupportedCurves+0x13c>
        if ((nextOid == 0 || nextSz > octets) && ssl->eccTempKeySz <= octets) {
 158:	46a1      	mov	r9, r4
 15a:	2f00      	cmp	r7, #0
 15c:	d1c2      	bne.n	e4 <TLSX_ValidateSupportedCurves+0xe4>
 15e:	4627      	mov	r7, r4
            nextSz  = octets;
 160:	4659      	mov	r1, fp
 162:	e7c8      	b.n	f6 <TLSX_ValidateSupportedCurves+0xf6>

Disassembly of section .text.TLSX_FreeAll:

00000000 <TLSX_FreeAll>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4604      	mov	r4, r0
   4:	460d      	mov	r5, r1
    while ((extension = list)) {
   6:	b904      	cbnz	r4, a <TLSX_FreeAll+0xa>
}
   8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        switch (extension->type) {
   a:	8823      	ldrh	r3, [r4, #0]
        list = extension->next;
   c:	6926      	ldr	r6, [r4, #16]
        switch (extension->type) {
   e:	2b0b      	cmp	r3, #11
  10:	d00f      	beq.n	32 <TLSX_FreeAll+0x32>
  12:	2b0d      	cmp	r3, #13
  14:	d015      	beq.n	42 <TLSX_FreeAll+0x42>
  16:	2b0a      	cmp	r3, #10
  18:	d101      	bne.n	1e <TLSX_FreeAll+0x1e>
                EC_FREE_ALL((SupportedCurve*)extension->data, heap);
  1a:	6860      	ldr	r0, [r4, #4]
    while ((curve = list)) {
  1c:	b920      	cbnz	r0, 28 <TLSX_FreeAll+0x28>
        XFREE(extension, heap, DYNAMIC_TYPE_TLSX);
  1e:	4620      	mov	r0, r4
  20:	f7ff fffe 	bl	0 <free>
        list = extension->next;
  24:	4634      	mov	r4, r6
  26:	e7ee      	b.n	6 <TLSX_FreeAll+0x6>
        list = curve->next;
  28:	6847      	ldr	r7, [r0, #4]
        XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
  2a:	f7ff fffe 	bl	0 <free>
        list = curve->next;
  2e:	4638      	mov	r0, r7
  30:	e7f4      	b.n	1c <TLSX_FreeAll+0x1c>
                PF_FREE_ALL((PointFormat*)extension->data, heap);
  32:	6860      	ldr	r0, [r4, #4]
    while ((point = list)) {
  34:	2800      	cmp	r0, #0
  36:	d0f2      	beq.n	1e <TLSX_FreeAll+0x1e>
        list = point->next;
  38:	6847      	ldr	r7, [r0, #4]
        XFREE(point, heap, DYNAMIC_TYPE_TLSX);
  3a:	f7ff fffe 	bl	0 <free>
        list = point->next;
  3e:	4638      	mov	r0, r7
  40:	e7f8      	b.n	34 <TLSX_FreeAll+0x34>
                SA_FREE_ALL((SignatureAlgorithms*)extension->data, heap);
  42:	6860      	ldr	r0, [r4, #4]
  44:	4629      	mov	r1, r5
  46:	f7ff fffe 	bl	0 <TLSX_FreeAll>
                break;
  4a:	e7e8      	b.n	1e <TLSX_FreeAll+0x1e>

Disassembly of section .text.TLSX_Append:

00000000 <TLSX_Append>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4605      	mov	r5, r0
    TLSX* extension = (TLSX*)XMALLOC(sizeof(TLSX), heap, DYNAMIC_TYPE_TLSX);
   6:	2014      	movs	r0, #20
{
   8:	460e      	mov	r6, r1
   a:	4690      	mov	r8, r2
   c:	461f      	mov	r7, r3
    TLSX* extension = (TLSX*)XMALLOC(sizeof(TLSX), heap, DYNAMIC_TYPE_TLSX);
   e:	f7ff fffe 	bl	0 <malloc>
    if (extension) {
  12:	4604      	mov	r4, r0
  14:	b1e8      	cbz	r0, 52 <TLSX_Append+0x52>
        extension->data = (void*)data;
  16:	f8c0 8004 	str.w	r8, [r0, #4]
        extension->resp = 0;
  1a:	f04f 0800 	mov.w	r8, #0
        extension->type = type;
  1e:	8006      	strh	r6, [r0, #0]
        extension->resp = 0;
  20:	f880 800c 	strb.w	r8, [r0, #12]
        extension->next = NULL;
  24:	f8c0 8010 	str.w	r8, [r0, #16]
    for (cur = *list; cur != NULL;) {
  28:	6828      	ldr	r0, [r5, #0]
  2a:	b910      	cbnz	r0, 32 <TLSX_Append+0x32>
    *prevNext = extension;
  2c:	602c      	str	r4, [r5, #0]
}
  2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (cur->type == type) {
  32:	8802      	ldrh	r2, [r0, #0]
            *prevNext = cur->next;
  34:	6903      	ldr	r3, [r0, #16]
        if (cur->type == type) {
  36:	42b2      	cmp	r2, r6
  38:	d108      	bne.n	4c <TLSX_Append+0x4c>
            *prevNext = cur->next;
  3a:	602b      	str	r3, [r5, #0]
            TLSX_FreeAll(cur, heap);
  3c:	4639      	mov	r1, r7
            cur->next = NULL;
  3e:	f8c0 8010 	str.w	r8, [r0, #16]
            TLSX_FreeAll(cur, heap);
  42:	f7ff fffe 	bl	0 <TLSX_Append>
            cur = *prevNext;
  46:	682b      	ldr	r3, [r5, #0]
{
  48:	4618      	mov	r0, r3
  4a:	e7ee      	b.n	2a <TLSX_Append+0x2a>
            prevNext = &cur->next;
  4c:	f100 0510 	add.w	r5, r0, #16
            cur = cur->next;
  50:	e7fa      	b.n	48 <TLSX_Append+0x48>
        return MEMORY_E;
  52:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  56:	e7ea      	b.n	2e <TLSX_Append+0x2e>

Disassembly of section .text.TLSX_Push:

00000000 <TLSX_Push>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
    TLSX* extension = (TLSX*)XMALLOC(sizeof(TLSX), heap, DYNAMIC_TYPE_TLSX);
   4:	2014      	movs	r0, #20
{
   6:	460c      	mov	r4, r1
   8:	4617      	mov	r7, r2
   a:	461e      	mov	r6, r3
    TLSX* extension = (TLSX*)XMALLOC(sizeof(TLSX), heap, DYNAMIC_TYPE_TLSX);
   c:	f7ff fffe 	bl	0 <malloc>
    if (extension) {
  10:	b1a8      	cbz	r0, 3e <TLSX_Push+0x3e>
        extension->resp = 0;
  12:	2300      	movs	r3, #0
  14:	7303      	strb	r3, [r0, #12]
    extension->next = *list;
  16:	682b      	ldr	r3, [r5, #0]
        extension->type = type;
  18:	8004      	strh	r4, [r0, #0]
        extension->data = (void*)data;
  1a:	6047      	str	r7, [r0, #4]
    extension->next = *list;
  1c:	6103      	str	r3, [r0, #16]
    *list = extension;
  1e:	6028      	str	r0, [r5, #0]
        if (extension->next && extension->next->type == type) {
  20:	4603      	mov	r3, r0
  22:	6900      	ldr	r0, [r0, #16]
  24:	b150      	cbz	r0, 3c <TLSX_Push+0x3c>
  26:	8802      	ldrh	r2, [r0, #0]
  28:	42a2      	cmp	r2, r4
  2a:	d1f9      	bne.n	20 <TLSX_Push+0x20>
            extension->next = next->next;
  2c:	6902      	ldr	r2, [r0, #16]
  2e:	611a      	str	r2, [r3, #16]
            next->next = NULL;
  30:	2400      	movs	r4, #0
  32:	6104      	str	r4, [r0, #16]
            TLSX_FreeAll(next, heap);
  34:	4631      	mov	r1, r6
  36:	f7ff fffe 	bl	0 <TLSX_Push>
    return 0;
  3a:	4620      	mov	r0, r4
}
  3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return MEMORY_E;
  3e:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  42:	e7fb      	b.n	3c <TLSX_Push+0x3c>

Disassembly of section .text.TLSX_UseSupportedCurve:

00000000 <TLSX_UseSupportedCurve>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4690      	mov	r8, r2
    if (extensions == NULL) {
   8:	4607      	mov	r7, r0
   a:	b308      	cbz	r0, 50 <TLSX_UseSupportedCurve+0x50>
    extension = TLSX_Find(*extensions, TLSX_SUPPORTED_GROUPS);
   c:	6800      	ldr	r0, [r0, #0]
   e:	210a      	movs	r1, #10
  10:	f7ff fffe 	bl	0 <TLSX_UseSupportedCurve>
    if (!extension) {
  14:	4604      	mov	r4, r0
  16:	b9c8      	cbnz	r0, 4c <TLSX_UseSupportedCurve+0x4c>
    *curve = (SupportedCurve*)XMALLOC(sizeof(SupportedCurve), heap,
  18:	2008      	movs	r0, #8
  1a:	f7ff fffe 	bl	0 <malloc>
    if (*curve == NULL)
  1e:	4605      	mov	r5, r0
  20:	b920      	cbnz	r0, 2c <TLSX_UseSupportedCurve+0x2c>
        return MEMORY_E;
  22:	f06f 047c 	mvn.w	r4, #124	; 0x7c
}
  26:	4620      	mov	r0, r4
  28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (*curve)->next = NULL;
  2c:	6044      	str	r4, [r0, #4]
    (*curve)->name = name;
  2e:	8006      	strh	r6, [r0, #0]
        ret = TLSX_Push(extensions, TLSX_SUPPORTED_GROUPS, curve, heap);
  30:	4602      	mov	r2, r0
  32:	4643      	mov	r3, r8
  34:	210a      	movs	r1, #10
  36:	4638      	mov	r0, r7
  38:	f7ff fffe 	bl	0 <TLSX_UseSupportedCurve>
        if (ret != 0) {
  3c:	4604      	mov	r4, r0
  3e:	b908      	cbnz	r0, 44 <TLSX_UseSupportedCurve+0x44>
    return WOLFSSL_SUCCESS;
  40:	2401      	movs	r4, #1
  42:	e7f0      	b.n	26 <TLSX_UseSupportedCurve+0x26>
            XFREE(curve, heap, DYNAMIC_TYPE_TLSX);
  44:	4628      	mov	r0, r5
  46:	f7ff fffe 	bl	0 <free>
  4a:	e7ec      	b.n	26 <TLSX_UseSupportedCurve+0x26>
        ret = TLSX_SupportedCurve_Append((SupportedCurve*)extension->data, name,
  4c:	6844      	ldr	r4, [r0, #4]
    while (list) {
  4e:	b914      	cbnz	r4, 56 <TLSX_UseSupportedCurve+0x56>
        return BAD_FUNC_ARG;
  50:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  54:	e7e7      	b.n	26 <TLSX_UseSupportedCurve+0x26>
        if (list->name == name) {
  56:	8823      	ldrh	r3, [r4, #0]
  58:	42b3      	cmp	r3, r6
  5a:	d0f1      	beq.n	40 <TLSX_UseSupportedCurve+0x40>
        if (list->next == NULL) {
  5c:	6865      	ldr	r5, [r4, #4]
  5e:	b945      	cbnz	r5, 72 <TLSX_UseSupportedCurve+0x72>
    *curve = (SupportedCurve*)XMALLOC(sizeof(SupportedCurve), heap,
  60:	2008      	movs	r0, #8
  62:	f7ff fffe 	bl	0 <malloc>
  66:	6060      	str	r0, [r4, #4]
    if (*curve == NULL)
  68:	2800      	cmp	r0, #0
  6a:	d0da      	beq.n	22 <TLSX_UseSupportedCurve+0x22>
    (*curve)->name = name;
  6c:	8006      	strh	r6, [r0, #0]
    (*curve)->next = NULL;
  6e:	6045      	str	r5, [r0, #4]
  70:	e7e6      	b.n	40 <TLSX_UseSupportedCurve+0x40>
  72:	462c      	mov	r4, r5
  74:	e7eb      	b.n	4e <TLSX_UseSupportedCurve+0x4e>

Disassembly of section .text.TLSX_SupportedCurve_Parse:

00000000 <TLSX_SupportedCurve_Parse>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
   4:	460e      	mov	r6, r1
   6:	4614      	mov	r4, r2
    if(!isRequest && !IsAtLeastTLSv1_3(ssl->version)) {
   8:	b11b      	cbz	r3, 12 <TLSX_SupportedCurve_Parse+0x12>
    if (OPAQUE16_LEN > length || length % OPAQUE16_LEN)
   a:	2c01      	cmp	r4, #1
   c:	d808      	bhi.n	20 <TLSX_SupportedCurve_Parse+0x20>
        return BUFFER_ERROR; /* servers doesn't send this extension. */
   e:	4813      	ldr	r0, [pc, #76]	; (5c <TLSX_SupportedCurve_Parse+0x5c>)
}
  10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(!isRequest && !IsAtLeastTLSv1_3(ssl->version)) {
  12:	f8d0 013c 	ldr.w	r0, [r0, #316]	; 0x13c
  16:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_3>
  1a:	2800      	cmp	r0, #0
  1c:	d1f5      	bne.n	a <TLSX_SupportedCurve_Parse+0xa>
  1e:	e7f6      	b.n	e <TLSX_SupportedCurve_Parse+0xe>
    if (OPAQUE16_LEN > length || length % OPAQUE16_LEN)
  20:	07e3      	lsls	r3, r4, #31
  22:	d4f4      	bmi.n	e <TLSX_SupportedCurve_Parse+0xe>
    if (length != OPAQUE16_LEN + offset)
  24:	8833      	ldrh	r3, [r6, #0]
  26:	ba5b      	rev16	r3, r3
  28:	b29b      	uxth	r3, r3
  2a:	3302      	adds	r3, #2
  2c:	429c      	cmp	r4, r3
  2e:	d1ee      	bne.n	e <TLSX_SupportedCurve_Parse+0xe>
    if (offset == length)
  30:	2c02      	cmp	r4, #2
  32:	d101      	bne.n	38 <TLSX_SupportedCurve_Parse+0x38>
        return 0;
  34:	2000      	movs	r0, #0
  36:	e7eb      	b.n	10 <TLSX_SupportedCurve_Parse+0x10>
    offset = OPAQUE16_LEN;
  38:	2702      	movs	r7, #2
        ret = TLSX_UseSupportedCurve(extensions, name, ssl->heap);
  3a:	5bf1      	ldrh	r1, [r6, r7]
  3c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  3e:	9806      	ldr	r0, [sp, #24]
  40:	ba49      	rev16	r1, r1
  42:	b289      	uxth	r1, r1
  44:	f7ff fffe 	bl	0 <TLSX_SupportedCurve_Parse>
        if (ret != WOLFSSL_SUCCESS && ret != BAD_FUNC_ARG) {
  48:	2801      	cmp	r0, #1
  4a:	d002      	beq.n	52 <TLSX_SupportedCurve_Parse+0x52>
  4c:	f110 0fad 	cmn.w	r0, #173	; 0xad
  50:	d1de      	bne.n	10 <TLSX_SupportedCurve_Parse+0x10>
    for (; offset < length; offset += OPAQUE16_LEN) {
  52:	3702      	adds	r7, #2
  54:	b2bf      	uxth	r7, r7
  56:	42a7      	cmp	r7, r4
  58:	d3ef      	bcc.n	3a <TLSX_SupportedCurve_Parse+0x3a>
  5a:	e7eb      	b.n	34 <TLSX_SupportedCurve_Parse+0x34>
  5c:	fffffeb8 	.word	0xfffffeb8

Disassembly of section .text.TLSX_SupportedCurve_Copy:

00000000 <TLSX_SupportedCurve_Copy>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
    extension = TLSX_Find(src, TLSX_SUPPORTED_GROUPS);
   4:	210a      	movs	r1, #10
{
   6:	4616      	mov	r6, r2
    extension = TLSX_Find(src, TLSX_SUPPORTED_GROUPS);
   8:	f7ff fffe 	bl	0 <TLSX_SupportedCurve_Copy>
    if (extension != NULL) {
   c:	b908      	cbnz	r0, 12 <TLSX_SupportedCurve_Copy+0x12>
    return 0;
   e:	2000      	movs	r0, #0
}
  10:	bd70      	pop	{r4, r5, r6, pc}
        for (curve = (SupportedCurve*)extension->data; curve != NULL;
  12:	6844      	ldr	r4, [r0, #4]
  14:	2c00      	cmp	r4, #0
  16:	d0fa      	beq.n	e <TLSX_SupportedCurve_Copy+0xe>
            ret = TLSX_UseSupportedCurve(dst, curve->name, heap);
  18:	8821      	ldrh	r1, [r4, #0]
  1a:	4632      	mov	r2, r6
  1c:	4628      	mov	r0, r5
  1e:	f7ff fffe 	bl	0 <TLSX_SupportedCurve_Copy>
            if (ret != WOLFSSL_SUCCESS)
  22:	2801      	cmp	r0, #1
  24:	d101      	bne.n	2a <TLSX_SupportedCurve_Copy+0x2a>
                curve = curve->next) {
  26:	6864      	ldr	r4, [r4, #4]
  28:	e7f4      	b.n	14 <TLSX_SupportedCurve_Copy+0x14>
                return MEMORY_E;
  2a:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  2e:	e7ef      	b.n	10 <TLSX_SupportedCurve_Copy+0x10>

Disassembly of section .text.TLSX_UsePointFormat:

00000000 <TLSX_UsePointFormat>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4690      	mov	r8, r2
    if (extensions == NULL)
   8:	4607      	mov	r7, r0
   a:	b308      	cbz	r0, 50 <TLSX_UsePointFormat+0x50>
    extension = TLSX_Find(*extensions, TLSX_EC_POINT_FORMATS);
   c:	6800      	ldr	r0, [r0, #0]
   e:	210b      	movs	r1, #11
  10:	f7ff fffe 	bl	0 <TLSX_UsePointFormat>
    if (!extension) {
  14:	4604      	mov	r4, r0
  16:	b9c8      	cbnz	r0, 4c <TLSX_UsePointFormat+0x4c>
    *point = (PointFormat*)XMALLOC(sizeof(PointFormat), heap,
  18:	2008      	movs	r0, #8
  1a:	f7ff fffe 	bl	0 <malloc>
    if (*point == NULL)
  1e:	4605      	mov	r5, r0
  20:	b920      	cbnz	r0, 2c <TLSX_UsePointFormat+0x2c>
        return MEMORY_E;
  22:	f06f 047c 	mvn.w	r4, #124	; 0x7c
}
  26:	4620      	mov	r0, r4
  28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    (*point)->next = NULL;
  2c:	6044      	str	r4, [r0, #4]
    (*point)->format = format;
  2e:	7006      	strb	r6, [r0, #0]
        ret = TLSX_Push(extensions, TLSX_EC_POINT_FORMATS, point, heap);
  30:	4602      	mov	r2, r0
  32:	4643      	mov	r3, r8
  34:	210b      	movs	r1, #11
  36:	4638      	mov	r0, r7
  38:	f7ff fffe 	bl	0 <TLSX_UsePointFormat>
        if (ret != 0) {
  3c:	4604      	mov	r4, r0
  3e:	b908      	cbnz	r0, 44 <TLSX_UsePointFormat+0x44>
    return WOLFSSL_SUCCESS;
  40:	2401      	movs	r4, #1
  42:	e7f0      	b.n	26 <TLSX_UsePointFormat+0x26>
            XFREE(point, heap, DYNAMIC_TYPE_TLSX);
  44:	4628      	mov	r0, r5
  46:	f7ff fffe 	bl	0 <free>
  4a:	e7ec      	b.n	26 <TLSX_UsePointFormat+0x26>
        ret = TLSX_PointFormat_Append((PointFormat*)extension->data, format,
  4c:	6844      	ldr	r4, [r0, #4]
    while (list) {
  4e:	b914      	cbnz	r4, 56 <TLSX_UsePointFormat+0x56>
        return BAD_FUNC_ARG;
  50:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  54:	e7e7      	b.n	26 <TLSX_UsePointFormat+0x26>
        if (list->format == format) {
  56:	7823      	ldrb	r3, [r4, #0]
  58:	42b3      	cmp	r3, r6
  5a:	d0f1      	beq.n	40 <TLSX_UsePointFormat+0x40>
        if (list->next == NULL) {
  5c:	6865      	ldr	r5, [r4, #4]
  5e:	b945      	cbnz	r5, 72 <TLSX_UsePointFormat+0x72>
    *point = (PointFormat*)XMALLOC(sizeof(PointFormat), heap,
  60:	2008      	movs	r0, #8
  62:	f7ff fffe 	bl	0 <malloc>
  66:	6060      	str	r0, [r4, #4]
    if (*point == NULL)
  68:	2800      	cmp	r0, #0
  6a:	d0da      	beq.n	22 <TLSX_UsePointFormat+0x22>
    (*point)->format = format;
  6c:	7006      	strb	r6, [r0, #0]
    (*point)->next = NULL;
  6e:	6045      	str	r5, [r0, #4]
  70:	e7e6      	b.n	40 <TLSX_UsePointFormat+0x40>
  72:	462c      	mov	r4, r5
  74:	e7eb      	b.n	4e <TLSX_UsePointFormat+0x4e>

Disassembly of section .text.TLSX_Remove:

00000000 <TLSX_Remove>:
{
   0:	b430      	push	{r4, r5}
    if (list == NULL)
   2:	4603      	mov	r3, r0
{
   4:	460c      	mov	r4, r1
   6:	4611      	mov	r1, r2
    if (list == NULL)
   8:	b178      	cbz	r0, 2a <TLSX_Remove+0x2a>
    extension = *list;
   a:	6800      	ldr	r0, [r0, #0]
    while (extension && extension->type != type) {
   c:	b168      	cbz	r0, 2a <TLSX_Remove+0x2a>
   e:	8805      	ldrh	r5, [r0, #0]
        extension = extension->next;
  10:	6902      	ldr	r2, [r0, #16]
    while (extension && extension->type != type) {
  12:	42a5      	cmp	r5, r4
  14:	d105      	bne.n	22 <TLSX_Remove+0x22>
        *next = extension->next;
  16:	601a      	str	r2, [r3, #0]
        extension->next = NULL;
  18:	2300      	movs	r3, #0
}
  1a:	bc30      	pop	{r4, r5}
        extension->next = NULL;
  1c:	6103      	str	r3, [r0, #16]
        TLSX_FreeAll(extension, heap);
  1e:	f7ff bffe 	b.w	0 <TLSX_Remove>
        next = &extension->next;
  22:	f100 0310 	add.w	r3, r0, #16
        extension = extension->next;
  26:	4610      	mov	r0, r2
  28:	e7f0      	b.n	c <TLSX_Remove+0xc>
}
  2a:	bc30      	pop	{r4, r5}
  2c:	4770      	bx	lr

Disassembly of section .text.TLSX_SupportExtensions:

00000000 <TLSX_SupportExtensions>:
int TLSX_SupportExtensions(WOLFSSL* ssl) {
   0:	b510      	push	{r4, lr}
    return ssl && (IsTLS(ssl) || ssl->version.major == DTLS_MAJOR);
   2:	4604      	mov	r4, r0
   4:	b140      	cbz	r0, 18 <TLSX_SupportExtensions+0x18>
   6:	f7ff fffe 	bl	0 <IsTLS>
   a:	b930      	cbnz	r0, 1a <TLSX_SupportExtensions+0x1a>
   c:	f894 013c 	ldrb.w	r0, [r4, #316]	; 0x13c
  10:	f1a0 03fe 	sub.w	r3, r0, #254	; 0xfe
  14:	4258      	negs	r0, r3
  16:	4158      	adcs	r0, r3
}
  18:	bd10      	pop	{r4, pc}
    return ssl && (IsTLS(ssl) || ssl->version.major == DTLS_MAJOR);
  1a:	2001      	movs	r0, #1
  1c:	e7fc      	b.n	18 <TLSX_SupportExtensions+0x18>

Disassembly of section .text.TLSX_PopulateExtensions:

00000000 <TLSX_PopulateExtensions>:
}

#endif /* HAVE_SUPPORTED_CURVES */

int TLSX_PopulateExtensions(WOLFSSL* ssl, byte isServer)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
#if (defined(HAVE_ECC) || defined(HAVE_CURVE25519) || \
                       defined(HAVE_CURVE448)) && defined(HAVE_SUPPORTED_CURVES)
        if (!ssl->options.userCurves && !ssl->ctx->userCurves) {
            if (TLSX_Find(ssl->ctx->extensions,
                                               TLSX_SUPPORTED_GROUPS) == NULL) {
                ret = TLSX_PopulateSupportedGroups(ssl, &ssl->extensions);
   4:	f500 7630 	add.w	r6, r0, #704	; 0x2c0
    if (!isServer) {
   8:	b1e9      	cbz	r1, 46 <TLSX_PopulateExtensions+0x46>
    if (TLSX_Find(*extensions, TLSX_SIGNATURE_ALGORITHMS) != NULL)
   a:	210d      	movs	r1, #13
   c:	f8d5 02c0 	ldr.w	r0, [r5, #704]	; 0x2c0
  10:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
  14:	4601      	mov	r1, r0
  16:	2800      	cmp	r0, #0
  18:	d157      	bne.n	ca <TLSX_PopulateExtensions+0xca>
#endif
    } /* is not server */

#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
    WOLFSSL_MSG("Adding signature algorithms extension");
    if ((ret = TLSX_SetSignatureAlgorithms(&ssl->extensions, ssl, ssl->heap))
  1a:	6a6f      	ldr	r7, [r5, #36]	; 0x24
    sa = TLSX_SignatureAlgorithms_New(ssl, 0, heap);
  1c:	4628      	mov	r0, r5
  1e:	463a      	mov	r2, r7
  20:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
    if (sa == NULL)
  24:	4605      	mov	r5, r0
  26:	2800      	cmp	r0, #0
  28:	d051      	beq.n	ce <TLSX_PopulateExtensions+0xce>
    ret = TLSX_Push(extensions, TLSX_SIGNATURE_ALGORITHMS, sa, heap);
  2a:	4602      	mov	r2, r0
  2c:	463b      	mov	r3, r7
  2e:	210d      	movs	r1, #13
  30:	4630      	mov	r0, r6
  32:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
    if (ret != 0)
  36:	4604      	mov	r4, r0
  38:	2800      	cmp	r0, #0
  3a:	d03f      	beq.n	bc <TLSX_PopulateExtensions+0xbc>
        TLSX_SignatureAlgorithms_FreeAll(sa, heap);
  3c:	4639      	mov	r1, r7
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
  44:	e03a      	b.n	bc <TLSX_PopulateExtensions+0xbc>
        if (!ssl->options.userCurves && !ssl->ctx->userCurves) {
  46:	f890 3275 	ldrb.w	r3, [r0, #629]	; 0x275
  4a:	069a      	lsls	r2, r3, #26
  4c:	d51b      	bpl.n	86 <TLSX_PopulateExtensions+0x86>
        if ((!IsAtLeastTLSv1_3(ssl->version) || ssl->options.downgrade) &&
  4e:	f8d5 013c 	ldr.w	r0, [r5, #316]	; 0x13c
  52:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_3>
  56:	2800      	cmp	r0, #0
  58:	d132      	bne.n	c0 <TLSX_PopulateExtensions+0xc0>
               TLSX_Find(ssl->ctx->extensions, TLSX_EC_POINT_FORMATS) == NULL &&
  5a:	682b      	ldr	r3, [r5, #0]
  5c:	210b      	movs	r1, #11
  5e:	6e58      	ldr	r0, [r3, #100]	; 0x64
  60:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
        if ((!IsAtLeastTLSv1_3(ssl->version) || ssl->options.downgrade) &&
  64:	2800      	cmp	r0, #0
  66:	d1d0      	bne.n	a <TLSX_PopulateExtensions+0xa>
               TLSX_Find(ssl->extensions, TLSX_EC_POINT_FORMATS) == NULL) {
  68:	f8d5 02c0 	ldr.w	r0, [r5, #704]	; 0x2c0
  6c:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
               TLSX_Find(ssl->ctx->extensions, TLSX_EC_POINT_FORMATS) == NULL &&
  70:	4601      	mov	r1, r0
  72:	2800      	cmp	r0, #0
  74:	d1c9      	bne.n	a <TLSX_PopulateExtensions+0xa>
             ret = TLSX_UsePointFormat(&ssl->extensions,
  76:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  78:	4630      	mov	r0, r6
  7a:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
             if (ret != WOLFSSL_SUCCESS)
  7e:	2801      	cmp	r0, #1
             ret = TLSX_UsePointFormat(&ssl->extensions,
  80:	4604      	mov	r4, r0
             if (ret != WOLFSSL_SUCCESS)
  82:	d11b      	bne.n	bc <TLSX_PopulateExtensions+0xbc>
  84:	e7c1      	b.n	a <TLSX_PopulateExtensions+0xa>
        if (!ssl->options.userCurves && !ssl->ctx->userCurves) {
  86:	6803      	ldr	r3, [r0, #0]
  88:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
  8c:	2a00      	cmp	r2, #0
  8e:	d1de      	bne.n	4e <TLSX_PopulateExtensions+0x4e>
            if (TLSX_Find(ssl->ctx->extensions,
  90:	6e58      	ldr	r0, [r3, #100]	; 0x64
  92:	210a      	movs	r1, #10
  94:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
  98:	2800      	cmp	r0, #0
  9a:	d1d8      	bne.n	4e <TLSX_PopulateExtensions+0x4e>
                ret = TLSX_UseSupportedCurve(extensions,
  9c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  9e:	2117      	movs	r1, #23
  a0:	4630      	mov	r0, r6
  a2:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
                if (ret != WOLFSSL_SUCCESS) return ret;
  a6:	2801      	cmp	r0, #1
                ret = TLSX_UseSupportedCurve(extensions,
  a8:	4604      	mov	r4, r0
                if (ret != WOLFSSL_SUCCESS) return ret;
  aa:	d107      	bne.n	bc <TLSX_PopulateExtensions+0xbc>
                ret = TLSX_UseSupportedCurve(extensions,
  ac:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  ae:	211d      	movs	r1, #29
  b0:	4630      	mov	r0, r6
  b2:	f7ff fffe 	bl	0 <TLSX_PopulateExtensions>
                if (ret != WOLFSSL_SUCCESS)
  b6:	2801      	cmp	r0, #1
                ret = TLSX_UseSupportedCurve(extensions,
  b8:	4604      	mov	r4, r0
                if (ret != WOLFSSL_SUCCESS)
  ba:	d0c8      	beq.n	4e <TLSX_PopulateExtensions+0x4e>
    (void)public_key;
    (void)public_key_len;
    (void)ssl;

    return ret;
}
  bc:	4620      	mov	r0, r4
  be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if ((!IsAtLeastTLSv1_3(ssl->version) || ssl->options.downgrade) &&
  c0:	f895 3271 	ldrb.w	r3, [r5, #625]	; 0x271
  c4:	075b      	lsls	r3, r3, #29
  c6:	d5a0      	bpl.n	a <TLSX_PopulateExtensions+0xa>
  c8:	e7c7      	b.n	5a <TLSX_PopulateExtensions+0x5a>
        return 0;
  ca:	2400      	movs	r4, #0
  cc:	e7f6      	b.n	bc <TLSX_PopulateExtensions+0xbc>
        return MEMORY_ERROR;
  ce:	f46f 7497 	mvn.w	r4, #302	; 0x12e
  d2:	e7f3      	b.n	bc <TLSX_PopulateExtensions+0xbc>

Disassembly of section .text.TLSX_GetRequestSize:

00000000 <TLSX_GetRequestSize>:
}
#endif

/** Tells the buffered size of extensions to be sent into the client hello. */
int TLSX_GetRequestSize(WOLFSSL* ssl, byte msgType, word16* pLength)
{
   0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    int ret = 0;
    word16 length = 0;
   2:	2300      	movs	r3, #0
    byte semaphore[SEMAPHORE_SIZE] = {0};
   4:	e9cd 3301 	strd	r3, r3, [sp, #4]
{
   8:	4604      	mov	r4, r0
   a:	460d      	mov	r5, r1
   c:	4616      	mov	r6, r2
    word16 length = 0;
   e:	f8ad 3002 	strh.w	r3, [sp, #2]
    byte semaphore[SEMAPHORE_SIZE] = {0};
  12:	f88d 300c 	strb.w	r3, [sp, #12]

    if (!TLSX_SupportExtensions(ssl))
  16:	f7ff fffe 	bl	0 <TLSX_GetRequestSize>
  1a:	b358      	cbz	r0, 74 <TLSX_GetRequestSize+0x74>
        return 0;
    if (msgType == client_hello) {
  1c:	2d01      	cmp	r5, #1
  1e:	d112      	bne.n	46 <TLSX_GetRequestSize+0x46>
        EC_VALIDATE_REQUEST(ssl, semaphore);
  20:	a901      	add	r1, sp, #4
  22:	4620      	mov	r0, r4
  24:	f7ff fffe 	bl	0 <TLSX_GetRequestSize>
        PF_VALIDATE_REQUEST(ssl, semaphore);
  28:	4620      	mov	r0, r4
  2a:	f7ff fffe 	bl	0 <TLSX_GetRequestSize>
        WOLF_STK_VALIDATE_REQUEST(ssl);
#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
        if (WOLFSSL_SUITES(ssl)->hashSigAlgoSz == 0)
  2e:	6863      	ldr	r3, [r4, #4]
  30:	b90b      	cbnz	r3, 36 <TLSX_GetRequestSize+0x36>
  32:	6823      	ldr	r3, [r4, #0]
  34:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  36:	885b      	ldrh	r3, [r3, #2]
  38:	b92b      	cbnz	r3, 46 <TLSX_GetRequestSize+0x46>
            TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SIGNATURE_ALGORITHMS));
  3a:	f89d 3005 	ldrb.w	r3, [sp, #5]
  3e:	f043 0320 	orr.w	r3, r3, #32
  42:	f88d 3005 	strb.w	r3, [sp, #5]
    }
    else
#endif /* HAVE_ECH */
#endif /* WOLFSSL_TLS13 */
    {
        if (ssl->extensions) {
  46:	f8d4 02c0 	ldr.w	r0, [r4, #704]	; 0x2c0
  4a:	b958      	cbnz	r0, 64 <TLSX_GetRequestSize+0x64>
            ret = TLSX_GetSize(ssl->extensions, semaphore, msgType, &length);
            if (ret != 0)
                return ret;
        }
        if (ssl->ctx && ssl->ctx->extensions) {
  4c:	6823      	ldr	r3, [r4, #0]
  4e:	b99b      	cbnz	r3, 78 <TLSX_GetRequestSize+0x78>
                  (!IsAtLeastTLSv1_3(ssl->version) || ssl->options.downgrade)) {
        length += HELLO_EXT_SZ;
    }
#endif

    if (length)
  50:	f8bd 3002 	ldrh.w	r3, [sp, #2]
  54:	b9e3      	cbnz	r3, 90 <TLSX_GetRequestSize+0x90>
        length += OPAQUE16_LEN; /* for total length storage. */

    *pLength += length;
  56:	8833      	ldrh	r3, [r6, #0]
  58:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  5c:	4413      	add	r3, r2
  5e:	8033      	strh	r3, [r6, #0]

    return ret;
  60:	2000      	movs	r0, #0
  62:	e007      	b.n	74 <TLSX_GetRequestSize+0x74>
            ret = TLSX_GetSize(ssl->extensions, semaphore, msgType, &length);
  64:	f10d 0302 	add.w	r3, sp, #2
  68:	462a      	mov	r2, r5
  6a:	a901      	add	r1, sp, #4
  6c:	f7ff fffe 	bl	0 <TLSX_GetRequestSize>
            if (ret != 0)
  70:	2800      	cmp	r0, #0
  72:	d0eb      	beq.n	4c <TLSX_GetRequestSize+0x4c>
}
  74:	b004      	add	sp, #16
  76:	bd70      	pop	{r4, r5, r6, pc}
        if (ssl->ctx && ssl->ctx->extensions) {
  78:	6e58      	ldr	r0, [r3, #100]	; 0x64
  7a:	2800      	cmp	r0, #0
  7c:	d0e8      	beq.n	50 <TLSX_GetRequestSize+0x50>
            ret = TLSX_GetSize(ssl->ctx->extensions, semaphore, msgType,
  7e:	f10d 0302 	add.w	r3, sp, #2
  82:	462a      	mov	r2, r5
  84:	a901      	add	r1, sp, #4
  86:	f7ff fffe 	bl	0 <TLSX_GetRequestSize>
            if (ret != 0)
  8a:	2800      	cmp	r0, #0
  8c:	d0e0      	beq.n	50 <TLSX_GetRequestSize+0x50>
  8e:	e7f1      	b.n	74 <TLSX_GetRequestSize+0x74>
        length += OPAQUE16_LEN; /* for total length storage. */
  90:	3302      	adds	r3, #2
  92:	f8ad 3002 	strh.w	r3, [sp, #2]
  96:	e7de      	b.n	56 <TLSX_GetRequestSize+0x56>

Disassembly of section .text.TLSX_WriteRequest:

00000000 <TLSX_WriteRequest>:
}
#endif

/** Writes the extensions to be sent into the client hello. */
int TLSX_WriteRequest(WOLFSSL* ssl, byte* output, byte msgType, word16* pOffset)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	b087      	sub	sp, #28
   4:	461f      	mov	r7, r3
    int ret = 0;
    word16 offset = 0;
   6:	2300      	movs	r3, #0
    byte semaphore[SEMAPHORE_SIZE] = {0};
   8:	e9cd 3303 	strd	r3, r3, [sp, #12]
{
   c:	4605      	mov	r5, r0
   e:	460c      	mov	r4, r1
  10:	4616      	mov	r6, r2
    word16 offset = 0;
  12:	f8ad 300a 	strh.w	r3, [sp, #10]
    byte semaphore[SEMAPHORE_SIZE] = {0};
  16:	f88d 3014 	strb.w	r3, [sp, #20]

    if (!TLSX_SupportExtensions(ssl) || output == NULL)
  1a:	f7ff fffe 	bl	0 <TLSX_WriteRequest>
  1e:	2800      	cmp	r0, #0
  20:	d03d      	beq.n	9e <TLSX_WriteRequest+0x9e>
  22:	2c00      	cmp	r4, #0
  24:	d04d      	beq.n	c2 <TLSX_WriteRequest+0xc2>
        return 0;

    offset += OPAQUE16_LEN; /* extensions length */
  26:	f8bd 300a 	ldrh.w	r3, [sp, #10]

    if (msgType == client_hello) {
  2a:	2e01      	cmp	r6, #1
    offset += OPAQUE16_LEN; /* extensions length */
  2c:	f103 0302 	add.w	r3, r3, #2
  30:	f8ad 300a 	strh.w	r3, [sp, #10]
    if (msgType == client_hello) {
  34:	d112      	bne.n	5c <TLSX_WriteRequest+0x5c>
        EC_VALIDATE_REQUEST(ssl, semaphore);
  36:	a903      	add	r1, sp, #12
  38:	4628      	mov	r0, r5
  3a:	f7ff fffe 	bl	0 <TLSX_WriteRequest>
        PF_VALIDATE_REQUEST(ssl, semaphore);
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <TLSX_WriteRequest>
        WOLF_STK_VALIDATE_REQUEST(ssl);
#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_SIGALG)
        if (WOLFSSL_SUITES(ssl)->hashSigAlgoSz == 0)
  44:	686b      	ldr	r3, [r5, #4]
  46:	b90b      	cbnz	r3, 4c <TLSX_WriteRequest+0x4c>
  48:	682b      	ldr	r3, [r5, #0]
  4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4c:	885b      	ldrh	r3, [r3, #2]
  4e:	b92b      	cbnz	r3, 5c <TLSX_WriteRequest+0x5c>
            TURN_ON(semaphore, TLSX_ToSemaphore(TLSX_SIGNATURE_ALGORITHMS));
  50:	f89d 300d 	ldrb.w	r3, [sp, #13]
  54:	f043 0320 	orr.w	r3, r3, #32
  58:	f88d 300d 	strb.w	r3, [sp, #13]
            return ret;
    }
    else
#endif
    {
        if (ssl->extensions) {
  5c:	f8d5 02c0 	ldr.w	r0, [r5, #704]	; 0x2c0
  60:	b988      	cbnz	r0, 86 <TLSX_WriteRequest+0x86>
            ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
                             msgType, &offset);
            if (ret != 0)
                return ret;
        }
        if (ssl->ctx && ssl->ctx->extensions) {
  62:	682b      	ldr	r3, [r5, #0]
  64:	b9eb      	cbnz	r3, a2 <TLSX_WriteRequest+0xa2>
            return ret;
    }
    #endif
#endif

    if (offset > OPAQUE16_LEN || msgType != client_hello)
  66:	f8bd 300a 	ldrh.w	r3, [sp, #10]
  6a:	2b02      	cmp	r3, #2
  6c:	d801      	bhi.n	72 <TLSX_WriteRequest+0x72>
  6e:	2e01      	cmp	r6, #1
  70:	d004      	beq.n	7c <TLSX_WriteRequest+0x7c>
        c16toa(offset - OPAQUE16_LEN, output); /* extensions length */
  72:	1e9a      	subs	r2, r3, #2
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  74:	f3c2 2107 	ubfx	r1, r2, #8, #8
  78:	7021      	strb	r1, [r4, #0]
    c[1] =  (byte)(wc_u16       & 0xff);
  7a:	7062      	strb	r2, [r4, #1]

     *pOffset += offset;
  7c:	883a      	ldrh	r2, [r7, #0]
  7e:	4413      	add	r3, r2
  80:	803b      	strh	r3, [r7, #0]

    return ret;
  82:	2000      	movs	r0, #0
  84:	e00b      	b.n	9e <TLSX_WriteRequest+0x9e>
            ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
  86:	f8bd 100a 	ldrh.w	r1, [sp, #10]
  8a:	f10d 030a 	add.w	r3, sp, #10
  8e:	9300      	str	r3, [sp, #0]
  90:	aa03      	add	r2, sp, #12
  92:	4633      	mov	r3, r6
  94:	4421      	add	r1, r4
  96:	f7ff fffe 	bl	0 <TLSX_WriteRequest>
            if (ret != 0)
  9a:	2800      	cmp	r0, #0
  9c:	d0e1      	beq.n	62 <TLSX_WriteRequest+0x62>
}
  9e:	b007      	add	sp, #28
  a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (ssl->ctx && ssl->ctx->extensions) {
  a2:	6e58      	ldr	r0, [r3, #100]	; 0x64
  a4:	2800      	cmp	r0, #0
  a6:	d0de      	beq.n	66 <TLSX_WriteRequest+0x66>
            ret = TLSX_Write(ssl->ctx->extensions, output + offset, semaphore,
  a8:	f8bd 100a 	ldrh.w	r1, [sp, #10]
  ac:	f10d 030a 	add.w	r3, sp, #10
  b0:	9300      	str	r3, [sp, #0]
  b2:	aa03      	add	r2, sp, #12
  b4:	4633      	mov	r3, r6
  b6:	4421      	add	r1, r4
  b8:	f7ff fffe 	bl	0 <TLSX_WriteRequest>
            if (ret != 0)
  bc:	2800      	cmp	r0, #0
  be:	d0d2      	beq.n	66 <TLSX_WriteRequest+0x66>
  c0:	e7ed      	b.n	9e <TLSX_WriteRequest+0x9e>
        return 0;
  c2:	4620      	mov	r0, r4
  c4:	e7eb      	b.n	9e <TLSX_WriteRequest+0x9e>

Disassembly of section .text.TLSX_GetResponseSize:

00000000 <TLSX_GetResponseSize>:

#if defined(WOLFSSL_TLS13) || !defined(NO_WOLFSSL_SERVER)

/** Tells the buffered size of extensions to be sent into the server hello. */
int TLSX_GetResponseSize(WOLFSSL* ssl, byte msgType, word16* pLength)
{
   0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    int ret = 0;
    word16 length = 0;
    byte semaphore[SEMAPHORE_SIZE] = {0};

    switch (msgType) {
   2:	2902      	cmp	r1, #2
    word16 length = 0;
   4:	f04f 0300 	mov.w	r3, #0
    byte semaphore[SEMAPHORE_SIZE] = {0};
   8:	e9cd 3301 	strd	r3, r3, [sp, #4]
{
   c:	4605      	mov	r5, r0
   e:	460c      	mov	r4, r1
  10:	4616      	mov	r6, r2
    word16 length = 0;
  12:	f8ad 3002 	strh.w	r3, [sp, #2]
    byte semaphore[SEMAPHORE_SIZE] = {0};
  16:	f88d 300c 	strb.w	r3, [sp, #12]
    switch (msgType) {
  1a:	d104      	bne.n	26 <TLSX_GetResponseSize+0x26>
#ifndef NO_WOLFSSL_SERVER
        case server_hello:
            PF_VALIDATE_RESPONSE(ssl, semaphore);
  1c:	f890 0278 	ldrb.w	r0, [r0, #632]	; 0x278
  20:	a901      	add	r1, sp, #4
  22:	f7ff fffe 	bl	0 <TLSX_GetResponseSize>
                                              !IsAtLeastTLSv1_3(ssl->version)) {
        length += HELLO_EXT_SZ;
    }
#endif

    if (TLSX_SupportExtensions(ssl)) {
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <TLSX_GetResponseSize>
  2c:	b970      	cbnz	r0, 4c <TLSX_GetResponseSize+0x4c>
            return ret;
    }

    /* All the response data is set at the ssl object only, so no ctx here. */

    if (length || msgType != server_hello)
  2e:	f8bd 3002 	ldrh.w	r3, [sp, #2]
  32:	b90b      	cbnz	r3, 38 <TLSX_GetResponseSize+0x38>
  34:	2c02      	cmp	r4, #2
  36:	d002      	beq.n	3e <TLSX_GetResponseSize+0x3e>
        length += OPAQUE16_LEN; /* for total length storage. */
  38:	3302      	adds	r3, #2
  3a:	f8ad 3002 	strh.w	r3, [sp, #2]

    *pLength += length;
  3e:	8833      	ldrh	r3, [r6, #0]
  40:	f8bd 2002 	ldrh.w	r2, [sp, #2]
  44:	4413      	add	r3, r2
  46:	8033      	strh	r3, [r6, #0]

    return ret;
  48:	2000      	movs	r0, #0
  4a:	e009      	b.n	60 <TLSX_GetResponseSize+0x60>
        ret = TLSX_GetSize(ssl->extensions, semaphore, msgType, &length);
  4c:	f8d5 02c0 	ldr.w	r0, [r5, #704]	; 0x2c0
  50:	f10d 0302 	add.w	r3, sp, #2
  54:	4622      	mov	r2, r4
  56:	a901      	add	r1, sp, #4
  58:	f7ff fffe 	bl	0 <TLSX_GetResponseSize>
        if (ret != 0)
  5c:	2800      	cmp	r0, #0
  5e:	d0e6      	beq.n	2e <TLSX_GetResponseSize+0x2e>
}
  60:	b004      	add	sp, #16
  62:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.TLSX_WriteResponse:

00000000 <TLSX_WriteResponse>:

/** Writes the server hello extensions into a buffer. */
int TLSX_WriteResponse(WOLFSSL *ssl, byte* output, byte msgType, word16* pOffset)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b086      	sub	sp, #24
    int ret = 0;
    word16 offset = 0;
   6:	f04f 0800 	mov.w	r8, #0
{
   a:	4607      	mov	r7, r0
   c:	460d      	mov	r5, r1
   e:	4616      	mov	r6, r2
  10:	461c      	mov	r4, r3
    word16 offset = 0;
  12:	f8ad 800a 	strh.w	r8, [sp, #10]

    if (TLSX_SupportExtensions(ssl) && output) {
  16:	f7ff fffe 	bl	0 <TLSX_WriteResponse>
  1a:	b338      	cbz	r0, 6c <TLSX_WriteResponse+0x6c>
  1c:	b335      	cbz	r5, 6c <TLSX_WriteResponse+0x6c>
        byte semaphore[SEMAPHORE_SIZE] = {0};

        switch (msgType) {
  1e:	2e02      	cmp	r6, #2
        byte semaphore[SEMAPHORE_SIZE] = {0};
  20:	e9cd 8803 	strd	r8, r8, [sp, #12]
  24:	f88d 8014 	strb.w	r8, [sp, #20]
        switch (msgType) {
  28:	d104      	bne.n	34 <TLSX_WriteResponse+0x34>
#ifndef NO_WOLFSSL_SERVER
            case server_hello:
                PF_VALIDATE_RESPONSE(ssl, semaphore);
  2a:	f897 0278 	ldrb.w	r0, [r7, #632]	; 0x278
  2e:	a903      	add	r1, sp, #12
  30:	f7ff fffe 	bl	0 <TLSX_WriteResponse>

            default:
                break;
        }

        offset += OPAQUE16_LEN; /* extensions length */
  34:	f8bd 100a 	ldrh.w	r1, [sp, #10]

        ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
  38:	f8d7 02c0 	ldr.w	r0, [r7, #704]	; 0x2c0
        offset += OPAQUE16_LEN; /* extensions length */
  3c:	3102      	adds	r1, #2
  3e:	b289      	uxth	r1, r1
        ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
  40:	f10d 030a 	add.w	r3, sp, #10
        offset += OPAQUE16_LEN; /* extensions length */
  44:	f8ad 100a 	strh.w	r1, [sp, #10]
        ret = TLSX_Write(ssl->extensions, output + offset, semaphore,
  48:	9300      	str	r3, [sp, #0]
  4a:	aa03      	add	r2, sp, #12
  4c:	4633      	mov	r3, r6
  4e:	4429      	add	r1, r5
  50:	f7ff fffe 	bl	0 <TLSX_WriteResponse>
                         msgType, &offset);
        if (ret != 0)
  54:	b988      	cbnz	r0, 7a <TLSX_WriteResponse+0x7a>
            c16toa(0, output + offset);
            offset += HELLO_EXT_SZ_SZ;
        }
#endif

        if (offset > OPAQUE16_LEN || msgType != server_hello)
  56:	f8bd 300a 	ldrh.w	r3, [sp, #10]
  5a:	2b02      	cmp	r3, #2
  5c:	d801      	bhi.n	62 <TLSX_WriteResponse+0x62>
  5e:	2e02      	cmp	r6, #2
  60:	d004      	beq.n	6c <TLSX_WriteResponse+0x6c>
            c16toa(offset - OPAQUE16_LEN, output); /* extensions length */
  62:	3b02      	subs	r3, #2
    c[0] = (byte)((wc_u16 >> 8) & 0xff);
  64:	f3c3 2207 	ubfx	r2, r3, #8, #8
  68:	702a      	strb	r2, [r5, #0]
    c[1] =  (byte)(wc_u16       & 0xff);
  6a:	706b      	strb	r3, [r5, #1]
    }

    if (pOffset)
  6c:	b144      	cbz	r4, 80 <TLSX_WriteResponse+0x80>
        *pOffset += offset;
  6e:	8823      	ldrh	r3, [r4, #0]
  70:	f8bd 200a 	ldrh.w	r2, [sp, #10]
  74:	4413      	add	r3, r2
  76:	8023      	strh	r3, [r4, #0]

    return ret;
  78:	2000      	movs	r0, #0
}
  7a:	b006      	add	sp, #24
  7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return ret;
  80:	4620      	mov	r0, r4
  82:	e7fa      	b.n	7a <TLSX_WriteResponse+0x7a>

Disassembly of section .text.TLSX_Parse:

00000000 <TLSX_Parse>:
#endif

/** Parses a buffer of TLS extensions. */
int TLSX_Parse(WOLFSSL* ssl, const byte* input, word16 length, byte msgType,
                                                                 Suites *suites)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b08b      	sub	sp, #44	; 0x2c
    int ret = 0;
    word16 offset = 0;
    byte isRequest = (msgType == client_hello ||
   6:	2b01      	cmp	r3, #1
{
   8:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
   c:	9202      	str	r2, [sp, #8]
   e:	4606      	mov	r6, r0
  10:	4688      	mov	r8, r1
  12:	4699      	mov	r9, r3
    byte isRequest = (msgType == client_hello ||
  14:	d024      	beq.n	60 <TLSX_Parse+0x60>
  16:	f1a3 020d 	sub.w	r2, r3, #13
  1a:	f1d2 0b00 	rsbs	fp, r2, #0
  1e:	eb4b 0b02 	adc.w	fp, fp, r2
  22:	fa5f f38b 	uxtb.w	r3, fp
  26:	9303      	str	r3, [sp, #12]
#if defined(WOLFSSL_TLS13) && (defined(HAVE_SESSION_TICKET) || !defined(NO_PSK))
    int pskDone = 0;
#endif
    byte seenType[SEMAPHORE_SIZE];  /* Seen known extensions. */

    if (!ssl || !input || (isRequest && !suites))
  28:	2e00      	cmp	r6, #0
  2a:	f000 80ed 	beq.w	208 <TLSX_Parse+0x208>
  2e:	f1b8 0f00 	cmp.w	r8, #0
  32:	f000 80e9 	beq.w	208 <TLSX_Parse+0x208>
  36:	f1bb 0f00 	cmp.w	fp, #0
  3a:	d003      	beq.n	44 <TLSX_Parse+0x44>
  3c:	f1ba 0f00 	cmp.w	sl, #0
  40:	f000 80e2 	beq.w	208 <TLSX_Parse+0x208>
        return BAD_FUNC_ARG;

    /* No known extensions seen yet. */
    XMEMSET(seenType, 0, sizeof(seenType));
  44:	2209      	movs	r2, #9
  46:	2100      	movs	r1, #0
  48:	a807      	add	r0, sp, #28
                        return EXT_NOT_ALLOWED;
                }
                else
#endif
                {
                    if (msgType != client_hello &&
  4a:	f109 37ff 	add.w	r7, r9, #4294967295	; 0xffffffff
    XMEMSET(seenType, 0, sizeof(seenType));
  4e:	f7ff fffe 	bl	0 <memset>
                    if (msgType != client_hello &&
  52:	b2ff      	uxtb	r7, r7
    word16 offset = 0;
  54:	2300      	movs	r3, #0
    while (ret == 0 && offset < length) {
  56:	9a02      	ldr	r2, [sp, #8]
  58:	429a      	cmp	r2, r3
  5a:	d803      	bhi.n	64 <TLSX_Parse+0x64>
#endif

    if (ret == 0)
        ret = SNI_VERIFY_PARSE(ssl, isRequest);
    if (ret == 0)
        ret = TCA_VERIFY_PARSE(ssl, isRequest);
  5c:	2000      	movs	r0, #0
  5e:	e006      	b.n	6e <TLSX_Parse+0x6e>
    byte isRequest = (msgType == client_hello ||
  60:	469b      	mov	fp, r3
  62:	e7de      	b.n	22 <TLSX_Parse+0x22>
        if (length - offset < HELLO_EXT_TYPE_SZ + OPAQUE16_LEN)
  64:	9a02      	ldr	r2, [sp, #8]
  66:	1ad2      	subs	r2, r2, r3
  68:	2a03      	cmp	r2, #3
  6a:	dc03      	bgt.n	74 <TLSX_Parse+0x74>
            return BUFFER_ERROR;
  6c:	4869      	ldr	r0, [pc, #420]	; (214 <TLSX_Parse+0x214>)

    return ret;
}
  6e:	b00b      	add	sp, #44	; 0x2c
  70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        offset += HELLO_EXT_TYPE_SZ;
  74:	1c99      	adds	r1, r3, #2
  76:	f838 2003 	ldrh.w	r2, [r8, r3]
        ato16(input + offset, &size);
  7a:	b289      	uxth	r1, r1
  7c:	ba52      	rev16	r2, r2
  7e:	f838 4001 	ldrh.w	r4, [r8, r1]
  82:	b292      	uxth	r2, r2
    *wc_u16 = (word16) ((c[0] << 8) | (c[1]));
  84:	ba64      	rev16	r4, r4
        offset += OPAQUE16_LEN;
  86:	3304      	adds	r3, #4
        if ((type <= 62) || (type == TLSX_RENEGOTIATION_INFO)
  88:	2a3e      	cmp	r2, #62	; 0x3e
  8a:	b2a4      	uxth	r4, r4
        offset += OPAQUE16_LEN;
  8c:	b29d      	uxth	r5, r3
        if ((type <= 62) || (type == TLSX_RENEGOTIATION_INFO)
  8e:	d92d      	bls.n	ec <TLSX_Parse+0xec>
  90:	f64f 7301 	movw	r3, #65281	; 0xff01
  94:	429a      	cmp	r2, r3
  96:	d114      	bne.n	c2 <TLSX_Parse+0xc2>
            return 63;
  98:	233f      	movs	r3, #63	; 0x3f
            if (IS_OFF(seenType, TLSX_ToSemaphore(type))) {
  9a:	a90a      	add	r1, sp, #40	; 0x28
  9c:	eb01 00d3 	add.w	r0, r1, r3, lsr #3
  a0:	f04f 0c01 	mov.w	ip, #1
  a4:	f810 1c0c 	ldrb.w	r1, [r0, #-12]
  a8:	f003 0307 	and.w	r3, r3, #7
  ac:	fa0c f303 	lsl.w	r3, ip, r3
  b0:	420b      	tst	r3, r1
  b2:	fa5f fc83 	uxtb.w	ip, r3
  b6:	f040 80aa 	bne.w	20e <TLSX_Parse+0x20e>
                TURN_ON(seenType, TLSX_ToSemaphore(type));
  ba:	ea41 010c 	orr.w	r1, r1, ip
  be:	f800 1c0c 	strb.w	r1, [r0, #-12]
        if (length - offset < size)
  c2:	9b02      	ldr	r3, [sp, #8]
  c4:	1b5b      	subs	r3, r3, r5
  c6:	42a3      	cmp	r3, r4
  c8:	dbd0      	blt.n	6c <TLSX_Parse+0x6c>
        switch (type) {
  ca:	2a11      	cmp	r2, #17
  cc:	d810      	bhi.n	f0 <TLSX_Parse+0xf0>
  ce:	b1aa      	cbz	r2, fc <TLSX_Parse+0xfc>
  d0:	3a01      	subs	r2, #1
  d2:	2a10      	cmp	r2, #16
  d4:	d812      	bhi.n	fc <TLSX_Parse+0xfc>
  d6:	e8df f002 	tbb	[pc, r2]
  da:	1114      	.short	0x1114
  dc:	11141814 	.word	0x11141814
  e0:	1c111111 	.word	0x1c111111
  e4:	1149112c 	.word	0x1149112c
  e8:	1411      	.short	0x1411
  ea:	14          	.byte	0x14
  eb:	00          	.byte	0x00
  ec:	4613      	mov	r3, r2
  ee:	e7d4      	b.n	9a <TLSX_Parse+0x9a>
  f0:	2a23      	cmp	r2, #35	; 0x23
  f2:	d006      	beq.n	102 <TLSX_Parse+0x102>
  f4:	f64f 7301 	movw	r3, #65281	; 0xff01
  f8:	429a      	cmp	r2, r3
  fa:	d002      	beq.n	102 <TLSX_Parse+0x102>
        offset += size;
  fc:	192b      	adds	r3, r5, r4
  fe:	b29b      	uxth	r3, r3
 100:	e7a9      	b.n	56 <TLSX_Parse+0x56>
                    if (msgType != client_hello &&
 102:	2f01      	cmp	r7, #1
 104:	d9fa      	bls.n	fc <TLSX_Parse+0xfc>
                        return EXT_NOT_ALLOWED;
 106:	4844      	ldr	r0, [pc, #272]	; (218 <TLSX_Parse+0x218>)
 108:	e7b1      	b.n	6e <TLSX_Parse+0x6e>
                if (msgType != client_hello)
 10a:	f1b9 0f01 	cmp.w	r9, #1
 10e:	d0f5      	beq.n	fc <TLSX_Parse+0xfc>
 110:	e7f9      	b.n	106 <TLSX_Parse+0x106>
                    if (msgType != client_hello) {
 112:	f1b9 0f01 	cmp.w	r9, #1
 116:	d1f6      	bne.n	106 <TLSX_Parse+0x106>
                ret = EC_PARSE(ssl, input + offset, size, isRequest,
 118:	f506 7330 	add.w	r3, r6, #704	; 0x2c0
 11c:	9300      	str	r3, [sp, #0]
 11e:	4622      	mov	r2, r4
 120:	9b03      	ldr	r3, [sp, #12]
 122:	eb08 0105 	add.w	r1, r8, r5
 126:	4630      	mov	r0, r6
 128:	f7ff fffe 	bl	0 <TLSX_Parse>
    while (ret == 0 && offset < length) {
 12c:	2800      	cmp	r0, #0
 12e:	d0e5      	beq.n	fc <TLSX_Parse+0xfc>
 130:	e79d      	b.n	6e <TLSX_Parse+0x6e>
                if (msgType != client_hello &&
 132:	2f01      	cmp	r7, #1
 134:	d8e7      	bhi.n	106 <TLSX_Parse+0x106>
    if (ENUM_LEN > length || length != (word16)ENUM_LEN + input[0])
 136:	2c00      	cmp	r4, #0
 138:	d098      	beq.n	6c <TLSX_Parse+0x6c>
 13a:	f818 3005 	ldrb.w	r3, [r8, r5]
 13e:	3301      	adds	r3, #1
 140:	429c      	cmp	r4, r3
 142:	d193      	bne.n	6c <TLSX_Parse+0x6c>
        offset += size;
 144:	192b      	adds	r3, r5, r4
 146:	b29b      	uxth	r3, r3
    if (isRequest) {
 148:	f1bb 0f00 	cmp.w	fp, #0
 14c:	d083      	beq.n	56 <TLSX_Parse+0x56>
        ret = TLSX_UsePointFormat(&ssl->extensions, WOLFSSL_EC_PF_UNCOMPRESSED,
 14e:	6a72      	ldr	r2, [r6, #36]	; 0x24
 150:	9304      	str	r3, [sp, #16]
 152:	2100      	movs	r1, #0
 154:	f506 7030 	add.w	r0, r6, #704	; 0x2c0
 158:	f7ff fffe 	bl	0 <TLSX_Parse>
        if (ret != WOLFSSL_SUCCESS)
 15c:	2801      	cmp	r0, #1
 15e:	d1e5      	bne.n	12c <TLSX_Parse+0x12c>
        TLSX_SetResponse(ssl, TLSX_EC_POINT_FORMATS);
 160:	210b      	movs	r1, #11
 162:	4630      	mov	r0, r6
 164:	f7ff fffe 	bl	0 <TLSX_Parse>
    while (ret == 0 && offset < length) {
 168:	9b04      	ldr	r3, [sp, #16]
 16a:	e774      	b.n	56 <TLSX_Parse+0x56>
                if (!IsAtLeastTLSv1_2(ssl))
 16c:	4630      	mov	r0, r6
 16e:	f7ff fffe 	bl	0 <IsAtLeastTLSv1_2>
 172:	2800      	cmp	r0, #0
 174:	d0c2      	beq.n	fc <TLSX_Parse+0xfc>
                    if (msgType != client_hello)
 176:	f1b9 0f01 	cmp.w	r9, #1
 17a:	d1c4      	bne.n	106 <TLSX_Parse+0x106>
                ret = SA_PARSE(ssl, input + offset, size, isRequest, suites);
 17c:	eb08 0105 	add.w	r1, r8, r5
    if (!isRequest)
 180:	f1bb 0f00 	cmp.w	fp, #0
 184:	f43f af72 	beq.w	6c <TLSX_Parse+0x6c>
    if (length < OPAQUE16_LEN + OPAQUE16_LEN || (length & 1) != 0)
 188:	2c03      	cmp	r4, #3
 18a:	f67f af6f 	bls.w	6c <TLSX_Parse+0x6c>
 18e:	07e3      	lsls	r3, r4, #31
 190:	f53f af6c 	bmi.w	6c <TLSX_Parse+0x6c>
 194:	f838 2005 	ldrh.w	r2, [r8, r5]
 198:	ba52      	rev16	r2, r2
 19a:	b293      	uxth	r3, r2
    if (length != OPAQUE16_LEN + len)
 19c:	1c98      	adds	r0, r3, #2
 19e:	4284      	cmp	r4, r0
    input += OPAQUE16_LEN;
 1a0:	f101 0102 	add.w	r1, r1, #2
    if (length != OPAQUE16_LEN + len)
 1a4:	f47f af62 	bne.w	6c <TLSX_Parse+0x6c>
    if (suites->hashSigAlgoSz % 2 != 0)
 1a8:	f8ba 0002 	ldrh.w	r0, [sl, #2]
 1ac:	07c0      	lsls	r0, r0, #31
 1ae:	f53f af5d 	bmi.w	6c <TLSX_Parse+0x6c>
    if (suites->hashSigAlgoSz > WOLFSSL_MAX_SIGALGO) {
 1b2:	2b26      	cmp	r3, #38	; 0x26
        suites->hashSigAlgoSz = WOLFSSL_MAX_SIGALGO;
 1b4:	bf88      	it	hi
 1b6:	2226      	movhi	r2, #38	; 0x26
 1b8:	f8aa 2002 	strh.w	r2, [sl, #2]
    XMEMCPY(suites->hashSigAlgo, input, suites->hashSigAlgoSz);
 1bc:	f8ba 2002 	ldrh.w	r2, [sl, #2]
 1c0:	9305      	str	r3, [sp, #20]
 1c2:	f50a 7098 	add.w	r0, sl, #304	; 0x130
 1c6:	9104      	str	r1, [sp, #16]
 1c8:	f7ff fffe 	bl	0 <memcpy>
    if ((length & 1) == 1)
 1cc:	9b05      	ldr	r3, [sp, #20]
 1ce:	f013 0201 	ands.w	r2, r3, #1
 1d2:	f47f af4b 	bne.w	6c <TLSX_Parse+0x6c>
    for (i = 0; i < length; i += 2) {
 1d6:	9904      	ldr	r1, [sp, #16]
    ssl->pssAlgo = 0;
 1d8:	f8a6 2288 	strh.w	r2, [r6, #648]	; 0x288
    for (i = 0; i < length; i += 2) {
 1dc:	429a      	cmp	r2, r3
 1de:	d28d      	bcs.n	fc <TLSX_Parse+0xfc>
        if (input[i] == rsa_pss_sa_algo && input[i + 1] <= sha512_mac)
 1e0:	5c88      	ldrb	r0, [r1, r2]
 1e2:	2808      	cmp	r0, #8
 1e4:	d10d      	bne.n	202 <TLSX_Parse+0x202>
 1e6:	1888      	adds	r0, r1, r2
 1e8:	7840      	ldrb	r0, [r0, #1]
 1ea:	2806      	cmp	r0, #6
 1ec:	d809      	bhi.n	202 <TLSX_Parse+0x202>
            ssl->pssAlgo |= 1 << input[i + 1];
 1ee:	f04f 0c01 	mov.w	ip, #1
 1f2:	fa0c f000 	lsl.w	r0, ip, r0
 1f6:	f8b6 c288 	ldrh.w	ip, [r6, #648]	; 0x288
 1fa:	ea40 000c 	orr.w	r0, r0, ip
 1fe:	f8a6 0288 	strh.w	r0, [r6, #648]	; 0x288
    for (i = 0; i < length; i += 2) {
 202:	3202      	adds	r2, #2
 204:	b292      	uxth	r2, r2
 206:	e7e9      	b.n	1dc <TLSX_Parse+0x1dc>
        return BAD_FUNC_ARG;
 208:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 20c:	e72f      	b.n	6e <TLSX_Parse+0x6e>
                return DUPLICATE_TLS_EXT_E;
 20e:	f46f 70e4 	mvn.w	r0, #456	; 0x1c8
 212:	e72c      	b.n	6e <TLSX_Parse+0x6e>
 214:	fffffeb8 	.word	0xfffffeb8
 218:	fffffe58 	.word	0xfffffe58

Disassembly of section .text.wolfTLS_client_method_ex:

00000000 <wolfTLS_client_method_ex>:
    WOLFSSL_METHOD* wolfTLS_client_method(void)
    {
        return wolfTLS_client_method_ex(NULL);
    }
    WOLFSSL_METHOD* wolfTLS_client_method_ex(void* heap)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
   2:	2004      	movs	r0, #4
   4:	f7ff fffe 	bl	0 <malloc>
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLS_client_method_ex");
        if (method) {
   8:	4604      	mov	r4, r0
   a:	b150      	cbz	r0, 22 <wolfTLS_client_method_ex+0x22>
    return pv;
   c:	2303      	movs	r3, #3
   e:	f88d 3004 	strb.w	r3, [sp, #4]
  12:	f88d 3005 	strb.w	r3, [sp, #5]
        #if defined(WOLFSSL_TLS13)
            InitSSL_Method(method, MakeTLSv1_3());
        #elif !defined(WOLFSSL_NO_TLS12)
            InitSSL_Method(method, MakeTLSv1_2());
  16:	9901      	ldr	r1, [sp, #4]
  18:	f7ff fffe 	bl	0 <InitSSL_Method>
            InitSSL_Method(method, MakeTLSv1());
        #else
            #error No TLS version enabled!
        #endif

            method->downgrade = 1;
  1c:	2301      	movs	r3, #1
  1e:	70e3      	strb	r3, [r4, #3]
            method->side      = WOLFSSL_CLIENT_END;
  20:	70a3      	strb	r3, [r4, #2]
        }
        return method;
    }
  22:	4620      	mov	r0, r4
  24:	b002      	add	sp, #8
  26:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfTLS_client_method:

00000000 <wolfTLS_client_method>:
        return wolfTLS_client_method_ex(NULL);
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfTLS_client_method>

Disassembly of section .text.wolfTLSv1_2_client_method_ex:

00000000 <wolfTLSv1_2_client_method_ex>:
    WOLFSSL_METHOD* wolfTLSv1_2_client_method(void)
    {
        return wolfTLSv1_2_client_method_ex(NULL);
    }
    WOLFSSL_METHOD* wolfTLSv1_2_client_method_ex(void* heap)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
   2:	2004      	movs	r0, #4
   4:	f7ff fffe 	bl	0 <malloc>
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLSv1_2_client_method_ex");
        if (method)
   8:	4604      	mov	r4, r0
   a:	b138      	cbz	r0, 1c <wolfTLSv1_2_client_method_ex+0x1c>
    return pv;
   c:	2303      	movs	r3, #3
   e:	f88d 3004 	strb.w	r3, [sp, #4]
  12:	f88d 3005 	strb.w	r3, [sp, #5]
            InitSSL_Method(method, MakeTLSv1_2());
  16:	9901      	ldr	r1, [sp, #4]
  18:	f7ff fffe 	bl	0 <InitSSL_Method>
        return method;
    }
  1c:	4620      	mov	r0, r4
  1e:	b002      	add	sp, #8
  20:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfTLSv1_2_client_method:

00000000 <wolfTLSv1_2_client_method>:
        return wolfTLSv1_2_client_method_ex(NULL);
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfTLSv1_2_client_method>

Disassembly of section .text.wolfTLS_server_method_ex:

00000000 <wolfTLS_server_method_ex>:
    {
        return wolfTLS_server_method_ex(NULL);
    }

    WOLFSSL_METHOD* wolfTLS_server_method_ex(void* heap)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
   2:	2004      	movs	r0, #4
   4:	f7ff fffe 	bl	0 <malloc>
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLS_server_method_ex");
        if (method) {
   8:	4604      	mov	r4, r0
   a:	b158      	cbz	r0, 24 <wolfTLS_server_method_ex+0x24>
    return pv;
   c:	2303      	movs	r3, #3
   e:	f88d 3004 	strb.w	r3, [sp, #4]
  12:	f88d 3005 	strb.w	r3, [sp, #5]
        #if defined(WOLFSSL_TLS13)
            InitSSL_Method(method, MakeTLSv1_3());
        #elif !defined(WOLFSSL_NO_TLS12)
            InitSSL_Method(method, MakeTLSv1_2());
  16:	9901      	ldr	r1, [sp, #4]
  18:	f7ff fffe 	bl	0 <InitSSL_Method>
            InitSSL_Method(method, MakeTLSv1());
        #else
            #error No TLS version enabled!
        #endif

            method->downgrade = 1;
  1c:	2301      	movs	r3, #1
  1e:	70e3      	strb	r3, [r4, #3]
            method->side      = WOLFSSL_SERVER_END;
  20:	2300      	movs	r3, #0
  22:	70a3      	strb	r3, [r4, #2]
        }
        return method;
    }
  24:	4620      	mov	r0, r4
  26:	b002      	add	sp, #8
  28:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfTLS_server_method:

00000000 <wolfTLS_server_method>:
        return wolfTLS_server_method_ex(NULL);
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfTLS_server_method>

Disassembly of section .text.wolfTLSv1_2_server_method_ex:

00000000 <wolfTLSv1_2_server_method_ex>:
    WOLFSSL_METHOD* wolfTLSv1_2_server_method(void)
    {
        return wolfTLSv1_2_server_method_ex(NULL);
    }
    WOLFSSL_METHOD* wolfTLSv1_2_server_method_ex(void* heap)
    {
   0:	b513      	push	{r0, r1, r4, lr}
        WOLFSSL_METHOD* method =
                              (WOLFSSL_METHOD*) XMALLOC(sizeof(WOLFSSL_METHOD),
   2:	2004      	movs	r0, #4
   4:	f7ff fffe 	bl	0 <malloc>
                                                     heap, DYNAMIC_TYPE_METHOD);
        (void)heap;
        WOLFSSL_ENTER("TLSv1_2_server_method_ex");
        if (method) {
   8:	4604      	mov	r4, r0
   a:	b148      	cbz	r0, 20 <wolfTLSv1_2_server_method_ex+0x20>
    return pv;
   c:	2303      	movs	r3, #3
   e:	f88d 3004 	strb.w	r3, [sp, #4]
  12:	f88d 3005 	strb.w	r3, [sp, #5]
            InitSSL_Method(method, MakeTLSv1_2());
  16:	9901      	ldr	r1, [sp, #4]
  18:	f7ff fffe 	bl	0 <InitSSL_Method>
            method->side = WOLFSSL_SERVER_END;
  1c:	2300      	movs	r3, #0
  1e:	70a3      	strb	r3, [r4, #2]
        }
        return method;
    }
  20:	4620      	mov	r0, r4
  22:	b002      	add	sp, #8
  24:	bd10      	pop	{r4, pc}

Disassembly of section .text.wolfTLSv1_2_server_method:

00000000 <wolfTLSv1_2_server_method>:
        return wolfTLSv1_2_server_method_ex(NULL);
   0:	2000      	movs	r0, #0
   2:	f7ff bffe 	b.w	0 <wolfTLSv1_2_server_method>

tls13.o:     file format elf32-littlearm


wolfio.o:     file format elf32-littlearm


Disassembly of section .text.wolfSSL_CTX_SetIORecv:

00000000 <wolfSSL_CTX_SetIORecv>:



void wolfSSL_CTX_SetIORecv(WOLFSSL_CTX *ctx, CallbackIORecv CBIORecv)
{
    if (ctx) {
   0:	b100      	cbz	r0, 4 <wolfSSL_CTX_SetIORecv+0x4>
        ctx->CBIORecv = CBIORecv;
   2:	6401      	str	r1, [r0, #64]	; 0x40
    #ifdef OPENSSL_EXTRA
        ctx->cbioFlag |= WOLFSSL_CBIO_RECV;
    #endif
    }
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_CTX_SetIOSend:

00000000 <wolfSSL_CTX_SetIOSend>:


void wolfSSL_CTX_SetIOSend(WOLFSSL_CTX *ctx, CallbackIOSend CBIOSend)
{
    if (ctx) {
   0:	b100      	cbz	r0, 4 <wolfSSL_CTX_SetIOSend+0x4>
        ctx->CBIOSend = CBIOSend;
   2:	6441      	str	r1, [r0, #68]	; 0x44
    #ifdef OPENSSL_EXTRA
        ctx->cbioFlag |= WOLFSSL_CBIO_SEND;
    #endif
    }
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SSLSetIORecv:

00000000 <wolfSSL_SSLSetIORecv>:


/* sets the IO callback to use for receives at WOLFSSL level */
void wolfSSL_SSLSetIORecv(WOLFSSL *ssl, CallbackIORecv CBIORecv)
{
    if (ssl) {
   0:	b100      	cbz	r0, 4 <wolfSSL_SSLSetIORecv+0x4>
        ssl->CBIORecv = CBIORecv;
   2:	6281      	str	r1, [r0, #40]	; 0x28
    #ifdef OPENSSL_EXTRA
        ssl->cbioFlag |= WOLFSSL_CBIO_RECV;
    #endif
    }
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SSLSetIOSend:

00000000 <wolfSSL_SSLSetIOSend>:


/* sets the IO callback to use for sends at WOLFSSL level */
void wolfSSL_SSLSetIOSend(WOLFSSL *ssl, CallbackIOSend CBIOSend)
{
    if (ssl) {
   0:	b100      	cbz	r0, 4 <wolfSSL_SSLSetIOSend+0x4>
        ssl->CBIOSend = CBIOSend;
   2:	62c1      	str	r1, [r0, #44]	; 0x2c
    #ifdef OPENSSL_EXTRA
        ssl->cbioFlag |= WOLFSSL_CBIO_SEND;
    #endif
    }
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetIOReadCtx:

00000000 <wolfSSL_SetIOReadCtx>:


void wolfSSL_SetIOReadCtx(WOLFSSL* ssl, void *rctx)
{
    if (ssl)
   0:	b100      	cbz	r0, 4 <wolfSSL_SetIOReadCtx+0x4>
        ssl->IOCB_ReadCtx = rctx;
   2:	6101      	str	r1, [r0, #16]
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetIOWriteCtx:

00000000 <wolfSSL_SetIOWriteCtx>:


void wolfSSL_SetIOWriteCtx(WOLFSSL* ssl, void *wctx)
{
    if (ssl)
   0:	b100      	cbz	r0, 4 <wolfSSL_SetIOWriteCtx+0x4>
        ssl->IOCB_WriteCtx = wctx;
   2:	6141      	str	r1, [r0, #20]
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetIOReadCtx:

00000000 <wolfSSL_GetIOReadCtx>:


void* wolfSSL_GetIOReadCtx(WOLFSSL* ssl)
{
    if (ssl)
   0:	b100      	cbz	r0, 4 <wolfSSL_GetIOReadCtx+0x4>
        return ssl->IOCB_ReadCtx;
   2:	6900      	ldr	r0, [r0, #16]

    return NULL;
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetIOWriteCtx:

00000000 <wolfSSL_GetIOWriteCtx>:


void* wolfSSL_GetIOWriteCtx(WOLFSSL* ssl)
{
    if (ssl)
   0:	b100      	cbz	r0, 4 <wolfSSL_GetIOWriteCtx+0x4>
        return ssl->IOCB_WriteCtx;
   2:	6940      	ldr	r0, [r0, #20]

    return NULL;
}
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetIOReadFlags:

00000000 <wolfSSL_SetIOReadFlags>:


void wolfSSL_SetIOReadFlags(WOLFSSL* ssl, int flags)
{
    if (ssl)
   0:	b108      	cbz	r0, 6 <wolfSSL_SetIOReadFlags+0x6>
        ssl->rflags = flags;
   2:	f8c0 1120 	str.w	r1, [r0, #288]	; 0x120
}
   6:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetIOWriteFlags:

00000000 <wolfSSL_SetIOWriteFlags>:


void wolfSSL_SetIOWriteFlags(WOLFSSL* ssl, int flags)
{
    if (ssl)
   0:	b108      	cbz	r0, 6 <wolfSSL_SetIOWriteFlags+0x6>
        ssl->wflags = flags;
   2:	f8c0 1124 	str.w	r1, [r0, #292]	; 0x124
}
   6:	4770      	bx	lr

aes.o:     file format elf32-littlearm


Disassembly of section .text.ByteReverseWord32:

00000000 <ByteReverseWord32>:
#else
    /* 6 instructions with rotate instruction, 8 without */
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
    return rotlFixed(value, 16U);
#endif
}
   0:	ba00      	rev	r0, r0
   2:	4770      	bx	lr

Disassembly of section .text.xorbufout:

00000000 <xorbufout>:
/* This routine performs a bitwise XOR operation of <*buf> and <*mask> of n
counts, placing the result in <*buf>. */

WC_MISC_STATIC WC_INLINE void xorbufout(void* out, const void* buf,
                                        const void* mask, word32 count)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    o = (byte*)out;
    b = (const byte*)buf;
    m = (const byte*)mask;


    if (((wc_ptr_t)o) % WOLFSSL_WORD_SIZE ==
   2:	ea80 0401 	eor.w	r4, r0, r1
            ((wc_ptr_t)b) % WOLFSSL_WORD_SIZE &&
            ((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
   6:	ea82 0501 	eor.w	r5, r2, r1
   a:	432c      	orrs	r4, r5
            ((wc_ptr_t)b) % WOLFSSL_WORD_SIZE &&
   c:	f014 0403 	ands.w	r4, r4, #3
  10:	d10d      	bne.n	2e <xorbufout+0x2e>
            const wolfssl_word* wp;
        } tpb, tpm;
        /* Alignment checks out. Possible to XOR words. */
        /* Move alignment so that it lines up with a
         * WOLFSSL_WORD_SIZE boundary */
        while (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
  12:	078d      	lsls	r5, r1, #30
  14:	d000      	beq.n	18 <xorbufout+0x18>
  16:	b973      	cbnz	r3, 36 <xorbufout+0x36>
            count--;
        }
        tpo.bp = o;
        tpb.bp = b;
        tpm.bp = m;
        XorWordsOut( &tpo.wp, &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
  18:	089d      	lsrs	r5, r3, #2
    for (i = 0; i < n; i++)
  1a:	42a5      	cmp	r5, r4
  1c:	d114      	bne.n	48 <xorbufout+0x48>
  1e:	eb00 0085 	add.w	r0, r0, r5, lsl #2
  22:	eb01 0185 	add.w	r1, r1, r5, lsl #2
  26:	eb02 0285 	add.w	r2, r2, r5, lsl #2
        o = tpo.bp;
        b = tpb.bp;
        m = tpm.bp;
        count %= WOLFSSL_WORD_SIZE;
  2a:	f003 0303 	and.w	r3, r3, #3
    }

    for (i = 0; i < count; i++)
  2e:	2400      	movs	r4, #0
  30:	42a3      	cmp	r3, r4
  32:	d112      	bne.n	5a <xorbufout+0x5a>
        o[i] = (byte)(b[i] ^ m[i]);
}
  34:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *(o++) = (byte)(*(b++) ^ *(m++));
  36:	f811 5b01 	ldrb.w	r5, [r1], #1
  3a:	f812 6b01 	ldrb.w	r6, [r2], #1
  3e:	4075      	eors	r5, r6
  40:	f800 5b01 	strb.w	r5, [r0], #1
            count--;
  44:	3b01      	subs	r3, #1
  46:	e7e4      	b.n	12 <xorbufout+0x12>
        *((*r)++) = *((*a)++) ^ *((*b)++);
  48:	f851 6024 	ldr.w	r6, [r1, r4, lsl #2]
  4c:	f852 7024 	ldr.w	r7, [r2, r4, lsl #2]
  50:	407e      	eors	r6, r7
  52:	f840 6024 	str.w	r6, [r0, r4, lsl #2]
    for (i = 0; i < n; i++)
  56:	3401      	adds	r4, #1
  58:	e7df      	b.n	1a <xorbufout+0x1a>
        o[i] = (byte)(b[i] ^ m[i]);
  5a:	5d0d      	ldrb	r5, [r1, r4]
  5c:	5d16      	ldrb	r6, [r2, r4]
  5e:	4075      	eors	r5, r6
  60:	5505      	strb	r5, [r0, r4]
    for (i = 0; i < count; i++)
  62:	3401      	adds	r4, #1
  64:	e7e4      	b.n	30 <xorbufout+0x30>

Disassembly of section .text.xorbuf:

00000000 <xorbuf>:
    const byte* m;

    b = (byte*)buf;
    m = (const byte*)mask;

    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
   0:	ea81 0300 	eor.w	r3, r1, r0
   4:	079b      	lsls	r3, r3, #30
{
   6:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
   8:	d10c      	bne.n	24 <xorbuf+0x24>
            const wolfssl_word* wp;
        } tpm;
        /* Alignment checks out. Possible to XOR words. */
        /* Move alignment so that it lines up with a
         * WOLFSSL_WORD_SIZE boundary */
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
   a:	f000 0403 	and.w	r4, r0, #3
   e:	b104      	cbz	r4, 12 <xorbuf+0x12>
  10:	b96a      	cbnz	r2, 2e <xorbuf+0x2e>
    for (i = 0; i < n; i++)
  12:	f022 0503 	bic.w	r5, r2, #3
  16:	194e      	adds	r6, r1, r5
  18:	4603      	mov	r3, r0
  1a:	42b1      	cmp	r1, r6
  1c:	d110      	bne.n	40 <xorbuf+0x40>
  1e:	4428      	add	r0, r5
        tpb.bp = b;
        tpm.bp = m;
        XorWords( &tpb.wp, &tpm.wp, count / WOLFSSL_WORD_SIZE);
        b = tpb.bp;
        m = tpm.bp;
        count %= WOLFSSL_WORD_SIZE;
  20:	f002 0203 	and.w	r2, r2, #3
    }

    for (i = 0; i < count; i++)
  24:	3901      	subs	r1, #1
  26:	4402      	add	r2, r0
  28:	4290      	cmp	r0, r2
  2a:	d111      	bne.n	50 <xorbuf+0x50>
        b[i] ^= m[i];
}
  2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *(b++) ^= *(m++);
  2e:	f810 3b01 	ldrb.w	r3, [r0], #1
  32:	f811 5b01 	ldrb.w	r5, [r1], #1
  36:	406b      	eors	r3, r5
  38:	f800 3c01 	strb.w	r3, [r0, #-1]
            count--;
  3c:	3a01      	subs	r2, #1
  3e:	e7e6      	b.n	e <xorbuf+0xe>
        *((*r)++) ^= *((*a)++);
  40:	f853 4b04 	ldr.w	r4, [r3], #4
  44:	f851 7b04 	ldr.w	r7, [r1], #4
  48:	407c      	eors	r4, r7
  4a:	f843 4c04 	str.w	r4, [r3, #-4]
    for (i = 0; i < n; i++)
  4e:	e7e4      	b.n	1a <xorbuf+0x1a>
        b[i] ^= m[i];
  50:	7803      	ldrb	r3, [r0, #0]
  52:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  56:	4063      	eors	r3, r4
  58:	f800 3b01 	strb.w	r3, [r0], #1
    for (i = 0; i < count; i++)
  5c:	e7e4      	b.n	28 <xorbuf+0x28>

Disassembly of section .text.IncrementGcmCounter:

00000000 <IncrementGcmCounter>:
static WC_INLINE void IncrementGcmCounter(byte* inOutCtr)
{
    int i;

    /* in network byte order so start at end and work back */
    for (i = AES_BLOCK_SIZE - 1; i >= AES_BLOCK_SIZE - CTR_SZ; i--) {
   0:	f100 0210 	add.w	r2, r0, #16
   4:	300c      	adds	r0, #12
        if (++inOutCtr[i])  /* we're done unless we overflow */
   6:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
   a:	3301      	adds	r3, #1
   c:	b2db      	uxtb	r3, r3
   e:	7013      	strb	r3, [r2, #0]
  10:	b90b      	cbnz	r3, 16 <IncrementGcmCounter+0x16>
    for (i = AES_BLOCK_SIZE - 1; i >= AES_BLOCK_SIZE - CTR_SZ; i--) {
  12:	4282      	cmp	r2, r0
  14:	d1f7      	bne.n	6 <IncrementGcmCounter+0x6>
            return;
    }
}
  16:	4770      	bx	lr

Disassembly of section .text.wc_AesEncrypt:

00000000 <wc_AesEncrypt>:
{
   0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	460d      	mov	r5, r1
   6:	4690      	mov	r8, r2
    if (aes == NULL) {
   8:	4604      	mov	r4, r0
   a:	2800      	cmp	r0, #0
   c:	f000 872d 	beq.w	e6a <wc_AesEncrypt+0xe6a>
    r = aes->rounds >> 1;
  10:	f8d0 70f0 	ldr.w	r7, [r0, #240]	; 0xf0
  14:	087f      	lsrs	r7, r7, #1
    if (r > 7 || r == 0) {
  16:	1e7b      	subs	r3, r7, #1
  18:	2b06      	cmp	r3, #6
  1a:	f200 8729 	bhi.w	e70 <wc_AesEncrypt+0xe70>
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
  1e:	2204      	movs	r2, #4
  20:	4668      	mov	r0, sp
  22:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(&s1, inBlock +     sizeof(s0), sizeof(s1));
  26:	2204      	movs	r2, #4
  28:	18a9      	adds	r1, r5, r2
  2a:	eb0d 0002 	add.w	r0, sp, r2
  2e:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
  32:	f105 0108 	add.w	r1, r5, #8
  36:	2204      	movs	r2, #4
  38:	a802      	add	r0, sp, #8
  3a:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
  3e:	f105 010c 	add.w	r1, r5, #12
  42:	2204      	movs	r2, #4
  44:	a803      	add	r0, sp, #12
  46:	f7ff fffe 	bl	0 <memcpy>
    s0 = ByteReverseWord32(s0);
  4a:	9800      	ldr	r0, [sp, #0]
  4c:	f7ff fffe 	bl	0 <wc_AesEncrypt>
  50:	4602      	mov	r2, r0
    s1 = ByteReverseWord32(s1);
  52:	9801      	ldr	r0, [sp, #4]
  54:	f7ff fffe 	bl	0 <wc_AesEncrypt>
  58:	4603      	mov	r3, r0
    s2 = ByteReverseWord32(s2);
  5a:	9802      	ldr	r0, [sp, #8]
  5c:	f7ff fffe 	bl	0 <wc_AesEncrypt>
  60:	4681      	mov	r9, r0
    s3 = ByteReverseWord32(s3);
  62:	9803      	ldr	r0, [sp, #12]
  64:	f7ff fffe 	bl	0 <wc_AesEncrypt>
    s0 ^= rk[0];
  68:	6821      	ldr	r1, [r4, #0]
  6a:	ea82 0e01 	eor.w	lr, r2, r1
    s1 ^= rk[1];
  6e:	6862      	ldr	r2, [r4, #4]
  70:	ea83 0c02 	eor.w	ip, r3, r2
    s2 ^= rk[2];
  74:	68a3      	ldr	r3, [r4, #8]
  76:	ea89 0903 	eor.w	r9, r9, r3
    s3 ^= rk[3];
  7a:	68e3      	ldr	r3, [r4, #12]
  7c:	4058      	eors	r0, r3
                       ENC_ROUND_T_S( 0);
  7e:	b2c2      	uxtb	r2, r0
  80:	4bf2      	ldr	r3, [pc, #968]	; (44c <wc_AesEncrypt+0x44c>)
  82:	ea4f 611e 	mov.w	r1, lr, lsr #24
  86:	f502 7240 	add.w	r2, r2, #768	; 0x300
  8a:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
  8e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  92:	4055      	eors	r5, r2
  94:	6922      	ldr	r2, [r4, #16]
  96:	4055      	eors	r5, r2
  98:	f3cc 4207 	ubfx	r2, ip, #16, #8
  9c:	f502 7280 	add.w	r2, r2, #256	; 0x100
  a0:	ea4f 611c 	mov.w	r1, ip, lsr #24
  a4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  a8:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
  ac:	4055      	eors	r5, r2
  ae:	f3c9 2207 	ubfx	r2, r9, #8, #8
  b2:	f502 7200 	add.w	r2, r2, #512	; 0x200
  b6:	ea4f 6619 	mov.w	r6, r9, lsr #24
  ba:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  be:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
  c2:	4055      	eors	r5, r2
  c4:	fa5f f28e 	uxtb.w	r2, lr
  c8:	f502 7240 	add.w	r2, r2, #768	; 0x300
    if (r > 5) {
  cc:	2f05      	cmp	r7, #5
                       ENC_ROUND_T_S( 0);
  ce:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  d2:	ea81 0102 	eor.w	r1, r1, r2
  d6:	6962      	ldr	r2, [r4, #20]
  d8:	ea81 0102 	eor.w	r1, r1, r2
  dc:	f3c9 4207 	ubfx	r2, r9, #16, #8
  e0:	f502 7280 	add.w	r2, r2, #256	; 0x100
  e4:	fa5f f989 	uxtb.w	r9, r9
  e8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  ec:	ea81 0102 	eor.w	r1, r1, r2
  f0:	f3c0 2207 	ubfx	r2, r0, #8, #8
  f4:	f502 7200 	add.w	r2, r2, #512	; 0x200
  f8:	f509 7940 	add.w	r9, r9, #768	; 0x300
  fc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 100:	ea81 0102 	eor.w	r1, r1, r2
 104:	fa5f f28c 	uxtb.w	r2, ip
 108:	f502 7240 	add.w	r2, r2, #768	; 0x300
 10c:	f3cc 2c07 	ubfx	ip, ip, #8, #8
 110:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 114:	ea86 0602 	eor.w	r6, r6, r2
 118:	69a2      	ldr	r2, [r4, #24]
 11a:	ea86 0602 	eor.w	r6, r6, r2
 11e:	f3c0 4207 	ubfx	r2, r0, #16, #8
 122:	f502 7280 	add.w	r2, r2, #256	; 0x100
 126:	ea4f 6010 	mov.w	r0, r0, lsr #24
 12a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 12e:	ea86 0602 	eor.w	r6, r6, r2
 132:	f3ce 2207 	ubfx	r2, lr, #8, #8
 136:	f502 7200 	add.w	r2, r2, #512	; 0x200
 13a:	f3ce 4e07 	ubfx	lr, lr, #16, #8
 13e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 142:	ea86 0602 	eor.w	r6, r6, r2
 146:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 14a:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
 14e:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
 152:	ea82 0900 	eor.w	r9, r2, r0
 156:	69e2      	ldr	r2, [r4, #28]
 158:	f50c 7c00 	add.w	ip, ip, #512	; 0x200
 15c:	ea89 0902 	eor.w	r9, r9, r2
 160:	f853 202e 	ldr.w	r2, [r3, lr, lsl #2]
 164:	ea89 0902 	eor.w	r9, r9, r2
 168:	f853 202c 	ldr.w	r2, [r3, ip, lsl #2]
 16c:	ea89 0902 	eor.w	r9, r9, r2
    ENC_ROUND_S_T( 8); ENC_ROUND_T_S( 8);
 170:	fa5f f089 	uxtb.w	r0, r9
 174:	ea4f 6215 	mov.w	r2, r5, lsr #24
 178:	f500 7040 	add.w	r0, r0, #768	; 0x300
 17c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 180:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 184:	ea82 0c00 	eor.w	ip, r2, r0
 188:	6a22      	ldr	r2, [r4, #32]
 18a:	ea8c 0c02 	eor.w	ip, ip, r2
 18e:	f3c1 4207 	ubfx	r2, r1, #16, #8
 192:	f502 7280 	add.w	r2, r2, #256	; 0x100
 196:	ea4f 6011 	mov.w	r0, r1, lsr #24
 19a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 19e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 1a2:	ea8c 0c02 	eor.w	ip, ip, r2
 1a6:	f3c6 2207 	ubfx	r2, r6, #8, #8
 1aa:	f502 7200 	add.w	r2, r2, #512	; 0x200
 1ae:	fa5f fe81 	uxtb.w	lr, r1
 1b2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1b6:	ea8c 0c02 	eor.w	ip, ip, r2
 1ba:	b2ea      	uxtb	r2, r5
 1bc:	f502 7240 	add.w	r2, r2, #768	; 0x300
 1c0:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 1c4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1c8:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
 1cc:	ea80 0002 	eor.w	r0, r0, r2
 1d0:	6a62      	ldr	r2, [r4, #36]	; 0x24
 1d2:	ea80 0002 	eor.w	r0, r0, r2
 1d6:	f3c6 4207 	ubfx	r2, r6, #16, #8
 1da:	f502 7280 	add.w	r2, r2, #256	; 0x100
 1de:	f3c1 2107 	ubfx	r1, r1, #8, #8
 1e2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1e6:	ea80 0002 	eor.w	r0, r0, r2
 1ea:	f3c9 2207 	ubfx	r2, r9, #8, #8
 1ee:	f502 7200 	add.w	r2, r2, #512	; 0x200
 1f2:	f501 7100 	add.w	r1, r1, #512	; 0x200
 1f6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1fa:	ea80 0002 	eor.w	r0, r0, r2
 1fe:	ea4f 6216 	mov.w	r2, r6, lsr #24
 202:	b2f6      	uxtb	r6, r6
 204:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 208:	ea82 0e0e 	eor.w	lr, r2, lr
 20c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 20e:	ea8e 0e02 	eor.w	lr, lr, r2
 212:	f3c9 4207 	ubfx	r2, r9, #16, #8
 216:	f502 7280 	add.w	r2, r2, #256	; 0x100
 21a:	ea4f 6919 	mov.w	r9, r9, lsr #24
 21e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 222:	ea8e 0e02 	eor.w	lr, lr, r2
 226:	f3c5 2207 	ubfx	r2, r5, #8, #8
 22a:	f502 7200 	add.w	r2, r2, #512	; 0x200
 22e:	f506 7640 	add.w	r6, r6, #768	; 0x300
 232:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 236:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 23a:	ea8e 0e02 	eor.w	lr, lr, r2
 23e:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 242:	f3c5 4507 	ubfx	r5, r5, #16, #8
 246:	ea82 0906 	eor.w	r9, r2, r6
 24a:	f505 7580 	add.w	r5, r5, #256	; 0x100
 24e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 250:	ea89 0902 	eor.w	r9, r9, r2
 254:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
 258:	ea89 0902 	eor.w	r9, r9, r2
 25c:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 260:	ea89 0902 	eor.w	r9, r9, r2
 264:	fa5f f289 	uxtb.w	r2, r9
 268:	ea4f 611c 	mov.w	r1, ip, lsr #24
 26c:	f502 7240 	add.w	r2, r2, #768	; 0x300
 270:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 274:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 278:	f3c0 4207 	ubfx	r2, r0, #16, #8
 27c:	ea85 0501 	eor.w	r5, r5, r1
 280:	f502 7280 	add.w	r2, r2, #256	; 0x100
 284:	6b21      	ldr	r1, [r4, #48]	; 0x30
 286:	ea85 0501 	eor.w	r5, r5, r1
 28a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 28e:	f3ce 2207 	ubfx	r2, lr, #8, #8
 292:	f502 7200 	add.w	r2, r2, #512	; 0x200
 296:	ea85 0501 	eor.w	r5, r5, r1
 29a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 29e:	ea85 0502 	eor.w	r5, r5, r2
 2a2:	fa5f f28c 	uxtb.w	r2, ip
 2a6:	ea4f 6110 	mov.w	r1, r0, lsr #24
 2aa:	f502 7240 	add.w	r2, r2, #768	; 0x300
 2ae:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 2b2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 2b6:	ea81 0102 	eor.w	r1, r1, r2
 2ba:	6b62      	ldr	r2, [r4, #52]	; 0x34
 2bc:	ea81 0102 	eor.w	r1, r1, r2
 2c0:	f3ce 4207 	ubfx	r2, lr, #16, #8
 2c4:	f502 7280 	add.w	r2, r2, #256	; 0x100
 2c8:	ea4f 661e 	mov.w	r6, lr, lsr #24
 2cc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 2d0:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 2d4:	ea81 0102 	eor.w	r1, r1, r2
 2d8:	f3c9 2207 	ubfx	r2, r9, #8, #8
 2dc:	f502 7200 	add.w	r2, r2, #512	; 0x200
 2e0:	fa5f fe8e 	uxtb.w	lr, lr
 2e4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 2e8:	ea81 0102 	eor.w	r1, r1, r2
 2ec:	b2c2      	uxtb	r2, r0
 2ee:	f502 7240 	add.w	r2, r2, #768	; 0x300
 2f2:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 2f6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 2fa:	ea86 0602 	eor.w	r6, r6, r2
 2fe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 300:	ea86 0602 	eor.w	r6, r6, r2
 304:	f3c9 4207 	ubfx	r2, r9, #16, #8
 308:	f502 7280 	add.w	r2, r2, #256	; 0x100
 30c:	ea4f 6919 	mov.w	r9, r9, lsr #24
 310:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 314:	ea86 0602 	eor.w	r6, r6, r2
 318:	f3cc 2207 	ubfx	r2, ip, #8, #8
 31c:	f502 7200 	add.w	r2, r2, #512	; 0x200
 320:	f3cc 4c07 	ubfx	ip, ip, #16, #8
 324:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 328:	ea86 0602 	eor.w	r6, r6, r2
 32c:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 330:	f853 902e 	ldr.w	r9, [r3, lr, lsl #2]
 334:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
 338:	ea82 0909 	eor.w	r9, r2, r9
 33c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 33e:	f3c0 2007 	ubfx	r0, r0, #8, #8
 342:	ea89 0902 	eor.w	r9, r9, r2
 346:	f500 7000 	add.w	r0, r0, #512	; 0x200
 34a:	f853 202c 	ldr.w	r2, [r3, ip, lsl #2]
 34e:	ea89 0902 	eor.w	r9, r9, r2
 352:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 356:	ea89 0902 	eor.w	r9, r9, r2
    ENC_ROUND_S_T(16); ENC_ROUND_T_S(16);
 35a:	fa5f f289 	uxtb.w	r2, r9
 35e:	ea4f 6015 	mov.w	r0, r5, lsr #24
 362:	f502 7240 	add.w	r2, r2, #768	; 0x300
 366:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 36a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 36e:	ea80 0c02 	eor.w	ip, r0, r2
 372:	f3c1 4207 	ubfx	r2, r1, #16, #8
 376:	6c20      	ldr	r0, [r4, #64]	; 0x40
 378:	f502 7280 	add.w	r2, r2, #256	; 0x100
 37c:	ea8c 0c00 	eor.w	ip, ip, r0
 380:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 384:	f3c6 2207 	ubfx	r2, r6, #8, #8
 388:	f502 7200 	add.w	r2, r2, #512	; 0x200
 38c:	ea8c 0c00 	eor.w	ip, ip, r0
 390:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 394:	ea8c 0c02 	eor.w	ip, ip, r2
 398:	b2ea      	uxtb	r2, r5
 39a:	ea4f 6011 	mov.w	r0, r1, lsr #24
 39e:	f502 7240 	add.w	r2, r2, #768	; 0x300
 3a2:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 3a6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 3aa:	ea80 0002 	eor.w	r0, r0, r2
 3ae:	6c62      	ldr	r2, [r4, #68]	; 0x44
 3b0:	ea80 0002 	eor.w	r0, r0, r2
 3b4:	f3c6 4207 	ubfx	r2, r6, #16, #8
 3b8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 3bc:	fa5f fe81 	uxtb.w	lr, r1
 3c0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 3c4:	ea80 0002 	eor.w	r0, r0, r2
 3c8:	f3c9 2207 	ubfx	r2, r9, #8, #8
 3cc:	f502 7200 	add.w	r2, r2, #512	; 0x200
 3d0:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 3d4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 3d8:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
 3dc:	ea80 0002 	eor.w	r0, r0, r2
 3e0:	ea4f 6216 	mov.w	r2, r6, lsr #24
 3e4:	b2f6      	uxtb	r6, r6
 3e6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 3ea:	ea82 0e0e 	eor.w	lr, r2, lr
 3ee:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 3f0:	ea8e 0e02 	eor.w	lr, lr, r2
 3f4:	f3c9 4207 	ubfx	r2, r9, #16, #8
 3f8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 3fc:	ea4f 6919 	mov.w	r9, r9, lsr #24
 400:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 404:	ea8e 0e02 	eor.w	lr, lr, r2
 408:	f3c5 2207 	ubfx	r2, r5, #8, #8
 40c:	f502 7200 	add.w	r2, r2, #512	; 0x200
 410:	f506 7640 	add.w	r6, r6, #768	; 0x300
 414:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 418:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 41c:	ea8e 0e02 	eor.w	lr, lr, r2
 420:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 424:	f3c5 4507 	ubfx	r5, r5, #16, #8
 428:	ea82 0906 	eor.w	r9, r2, r6
 42c:	f505 7580 	add.w	r5, r5, #256	; 0x100
 430:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 432:	f3c1 2107 	ubfx	r1, r1, #8, #8
 436:	ea89 0902 	eor.w	r9, r9, r2
 43a:	f501 7100 	add.w	r1, r1, #512	; 0x200
 43e:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
 442:	ea89 0902 	eor.w	r9, r9, r2
 446:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 44a:	e001      	b.n	450 <wc_AesEncrypt+0x450>
 44c:	00000000 	.word	0x00000000
 450:	ea89 0902 	eor.w	r9, r9, r2
 454:	fa5f f289 	uxtb.w	r2, r9
 458:	ea4f 611c 	mov.w	r1, ip, lsr #24
 45c:	f502 7240 	add.w	r2, r2, #768	; 0x300
 460:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 464:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 468:	f3c0 4207 	ubfx	r2, r0, #16, #8
 46c:	ea85 0501 	eor.w	r5, r5, r1
 470:	f502 7280 	add.w	r2, r2, #256	; 0x100
 474:	6d21      	ldr	r1, [r4, #80]	; 0x50
 476:	ea85 0501 	eor.w	r5, r5, r1
 47a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 47e:	f3ce 2207 	ubfx	r2, lr, #8, #8
 482:	f502 7200 	add.w	r2, r2, #512	; 0x200
 486:	ea85 0501 	eor.w	r5, r5, r1
 48a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 48e:	ea85 0502 	eor.w	r5, r5, r2
 492:	fa5f f28c 	uxtb.w	r2, ip
 496:	ea4f 6110 	mov.w	r1, r0, lsr #24
 49a:	f502 7240 	add.w	r2, r2, #768	; 0x300
 49e:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 4a2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 4a6:	ea81 0102 	eor.w	r1, r1, r2
 4aa:	6d62      	ldr	r2, [r4, #84]	; 0x54
 4ac:	ea81 0102 	eor.w	r1, r1, r2
 4b0:	f3ce 4207 	ubfx	r2, lr, #16, #8
 4b4:	f502 7280 	add.w	r2, r2, #256	; 0x100
 4b8:	ea4f 661e 	mov.w	r6, lr, lsr #24
 4bc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 4c0:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 4c4:	ea81 0102 	eor.w	r1, r1, r2
 4c8:	f3c9 2207 	ubfx	r2, r9, #8, #8
 4cc:	f502 7200 	add.w	r2, r2, #512	; 0x200
 4d0:	fa5f fe8e 	uxtb.w	lr, lr
 4d4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 4d8:	ea81 0102 	eor.w	r1, r1, r2
 4dc:	b2c2      	uxtb	r2, r0
 4de:	f502 7240 	add.w	r2, r2, #768	; 0x300
 4e2:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 4e6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 4ea:	ea86 0602 	eor.w	r6, r6, r2
 4ee:	6da2      	ldr	r2, [r4, #88]	; 0x58
 4f0:	ea86 0602 	eor.w	r6, r6, r2
 4f4:	f3c9 4207 	ubfx	r2, r9, #16, #8
 4f8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 4fc:	ea4f 6919 	mov.w	r9, r9, lsr #24
 500:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 504:	ea86 0602 	eor.w	r6, r6, r2
 508:	f3cc 2207 	ubfx	r2, ip, #8, #8
 50c:	f502 7200 	add.w	r2, r2, #512	; 0x200
 510:	f3cc 4c07 	ubfx	ip, ip, #16, #8
 514:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 518:	ea86 0602 	eor.w	r6, r6, r2
 51c:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 520:	f853 902e 	ldr.w	r9, [r3, lr, lsl #2]
 524:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
 528:	ea82 0909 	eor.w	r9, r2, r9
 52c:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 52e:	f3c0 2007 	ubfx	r0, r0, #8, #8
 532:	ea89 0902 	eor.w	r9, r9, r2
 536:	f500 7000 	add.w	r0, r0, #512	; 0x200
 53a:	f853 202c 	ldr.w	r2, [r3, ip, lsl #2]
 53e:	ea89 0902 	eor.w	r9, r9, r2
 542:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 546:	ea89 0902 	eor.w	r9, r9, r2
    ENC_ROUND_S_T(24); ENC_ROUND_T_S(24);
 54a:	fa5f f289 	uxtb.w	r2, r9
 54e:	ea4f 6015 	mov.w	r0, r5, lsr #24
 552:	f502 7240 	add.w	r2, r2, #768	; 0x300
 556:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 55a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 55e:	ea80 0c02 	eor.w	ip, r0, r2
 562:	f3c1 4207 	ubfx	r2, r1, #16, #8
 566:	6e20      	ldr	r0, [r4, #96]	; 0x60
 568:	f502 7280 	add.w	r2, r2, #256	; 0x100
 56c:	ea8c 0c00 	eor.w	ip, ip, r0
 570:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 574:	f3c6 2207 	ubfx	r2, r6, #8, #8
 578:	f502 7200 	add.w	r2, r2, #512	; 0x200
 57c:	ea8c 0c00 	eor.w	ip, ip, r0
 580:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 584:	ea8c 0c02 	eor.w	ip, ip, r2
 588:	b2ea      	uxtb	r2, r5
 58a:	ea4f 6011 	mov.w	r0, r1, lsr #24
 58e:	f502 7240 	add.w	r2, r2, #768	; 0x300
 592:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 596:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 59a:	ea80 0002 	eor.w	r0, r0, r2
 59e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 5a0:	ea80 0002 	eor.w	r0, r0, r2
 5a4:	f3c6 4207 	ubfx	r2, r6, #16, #8
 5a8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 5ac:	fa5f fe81 	uxtb.w	lr, r1
 5b0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 5b4:	ea80 0002 	eor.w	r0, r0, r2
 5b8:	f3c9 2207 	ubfx	r2, r9, #8, #8
 5bc:	f502 7200 	add.w	r2, r2, #512	; 0x200
 5c0:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 5c4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 5c8:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
 5cc:	ea80 0002 	eor.w	r0, r0, r2
 5d0:	ea4f 6216 	mov.w	r2, r6, lsr #24
 5d4:	b2f6      	uxtb	r6, r6
 5d6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 5da:	ea82 0e0e 	eor.w	lr, r2, lr
 5de:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 5e0:	ea8e 0e02 	eor.w	lr, lr, r2
 5e4:	f3c9 4207 	ubfx	r2, r9, #16, #8
 5e8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 5ec:	ea4f 6919 	mov.w	r9, r9, lsr #24
 5f0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 5f4:	ea8e 0e02 	eor.w	lr, lr, r2
 5f8:	f3c5 2207 	ubfx	r2, r5, #8, #8
 5fc:	f502 7200 	add.w	r2, r2, #512	; 0x200
 600:	f506 7640 	add.w	r6, r6, #768	; 0x300
 604:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 608:	ea8e 0e02 	eor.w	lr, lr, r2
 60c:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 610:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 614:	f3c5 4507 	ubfx	r5, r5, #16, #8
 618:	ea82 0906 	eor.w	r9, r2, r6
 61c:	f505 7580 	add.w	r5, r5, #256	; 0x100
 620:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 622:	f3c1 2107 	ubfx	r1, r1, #8, #8
 626:	ea89 0902 	eor.w	r9, r9, r2
 62a:	f501 7100 	add.w	r1, r1, #512	; 0x200
 62e:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
 632:	ea89 0902 	eor.w	r9, r9, r2
 636:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 63a:	ea89 0902 	eor.w	r9, r9, r2
 63e:	fa5f f289 	uxtb.w	r2, r9
 642:	ea4f 611c 	mov.w	r1, ip, lsr #24
 646:	f502 7240 	add.w	r2, r2, #768	; 0x300
 64a:	f853 5021 	ldr.w	r5, [r3, r1, lsl #2]
 64e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 652:	f3c0 4207 	ubfx	r2, r0, #16, #8
 656:	ea85 0501 	eor.w	r5, r5, r1
 65a:	f502 7280 	add.w	r2, r2, #256	; 0x100
 65e:	6f21      	ldr	r1, [r4, #112]	; 0x70
 660:	ea85 0501 	eor.w	r5, r5, r1
 664:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 668:	f3ce 2207 	ubfx	r2, lr, #8, #8
 66c:	f502 7200 	add.w	r2, r2, #512	; 0x200
 670:	ea85 0501 	eor.w	r5, r5, r1
 674:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 678:	ea85 0502 	eor.w	r5, r5, r2
 67c:	fa5f f28c 	uxtb.w	r2, ip
 680:	ea4f 6110 	mov.w	r1, r0, lsr #24
 684:	f502 7240 	add.w	r2, r2, #768	; 0x300
 688:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 68c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 690:	ea81 0102 	eor.w	r1, r1, r2
 694:	6f62      	ldr	r2, [r4, #116]	; 0x74
 696:	ea81 0102 	eor.w	r1, r1, r2
 69a:	f3ce 4207 	ubfx	r2, lr, #16, #8
 69e:	f502 7280 	add.w	r2, r2, #256	; 0x100
 6a2:	ea4f 661e 	mov.w	r6, lr, lsr #24
 6a6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 6aa:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 6ae:	ea81 0102 	eor.w	r1, r1, r2
 6b2:	f3c9 2207 	ubfx	r2, r9, #8, #8
 6b6:	f502 7200 	add.w	r2, r2, #512	; 0x200
 6ba:	fa5f fe8e 	uxtb.w	lr, lr
 6be:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 6c2:	ea81 0102 	eor.w	r1, r1, r2
 6c6:	b2c2      	uxtb	r2, r0
 6c8:	f502 7240 	add.w	r2, r2, #768	; 0x300
 6cc:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 6d0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 6d4:	ea86 0602 	eor.w	r6, r6, r2
 6d8:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 6da:	ea86 0602 	eor.w	r6, r6, r2
 6de:	f3c9 4207 	ubfx	r2, r9, #16, #8
 6e2:	f502 7280 	add.w	r2, r2, #256	; 0x100
 6e6:	ea4f 6919 	mov.w	r9, r9, lsr #24
 6ea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 6ee:	ea86 0602 	eor.w	r6, r6, r2
 6f2:	f3cc 2207 	ubfx	r2, ip, #8, #8
 6f6:	f502 7200 	add.w	r2, r2, #512	; 0x200
 6fa:	f3cc 4c07 	ubfx	ip, ip, #16, #8
 6fe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 702:	ea86 0602 	eor.w	r6, r6, r2
 706:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 70a:	f853 902e 	ldr.w	r9, [r3, lr, lsl #2]
 70e:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
 712:	ea82 0909 	eor.w	r9, r2, r9
 716:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 718:	f3c0 2007 	ubfx	r0, r0, #8, #8
 71c:	ea89 0902 	eor.w	r9, r9, r2
 720:	f500 7000 	add.w	r0, r0, #512	; 0x200
 724:	f853 202c 	ldr.w	r2, [r3, ip, lsl #2]
 728:	ea89 0902 	eor.w	r9, r9, r2
 72c:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 730:	ea89 0902 	eor.w	r9, r9, r2
    ENC_ROUND_S_T(32); ENC_ROUND_T_S(32);
 734:	fa5f f289 	uxtb.w	r2, r9
 738:	ea4f 6015 	mov.w	r0, r5, lsr #24
 73c:	f502 7240 	add.w	r2, r2, #768	; 0x300
 740:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 744:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 748:	ea80 0e02 	eor.w	lr, r0, r2
 74c:	f3c1 4207 	ubfx	r2, r1, #16, #8
 750:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 754:	f502 7280 	add.w	r2, r2, #256	; 0x100
 758:	ea8e 0e00 	eor.w	lr, lr, r0
 75c:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 760:	f3c6 2207 	ubfx	r2, r6, #8, #8
 764:	f502 7200 	add.w	r2, r2, #512	; 0x200
 768:	ea8e 0e00 	eor.w	lr, lr, r0
 76c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 770:	ea8e 0e02 	eor.w	lr, lr, r2
 774:	b2ea      	uxtb	r2, r5
 776:	ea4f 6011 	mov.w	r0, r1, lsr #24
 77a:	f502 7240 	add.w	r2, r2, #768	; 0x300
 77e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 782:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 786:	ea80 0002 	eor.w	r0, r0, r2
 78a:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 78e:	ea80 0002 	eor.w	r0, r0, r2
 792:	f3c6 4207 	ubfx	r2, r6, #16, #8
 796:	f502 7280 	add.w	r2, r2, #256	; 0x100
 79a:	fa5f fc81 	uxtb.w	ip, r1
 79e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 7a2:	ea80 0002 	eor.w	r0, r0, r2
 7a6:	f3c9 2207 	ubfx	r2, r9, #8, #8
 7aa:	f502 7200 	add.w	r2, r2, #512	; 0x200
 7ae:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
 7b2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 7b6:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 7ba:	ea80 0002 	eor.w	r0, r0, r2
 7be:	ea4f 6216 	mov.w	r2, r6, lsr #24
 7c2:	b2f6      	uxtb	r6, r6
 7c4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 7c8:	ea82 0c0c 	eor.w	ip, r2, ip
 7cc:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
 7d0:	ea8c 0c02 	eor.w	ip, ip, r2
 7d4:	f3c9 4207 	ubfx	r2, r9, #16, #8
 7d8:	f502 7280 	add.w	r2, r2, #256	; 0x100
 7dc:	ea4f 6919 	mov.w	r9, r9, lsr #24
 7e0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 7e4:	ea8c 0c02 	eor.w	ip, ip, r2
 7e8:	f3c5 2207 	ubfx	r2, r5, #8, #8
 7ec:	f502 7200 	add.w	r2, r2, #512	; 0x200
 7f0:	f506 7640 	add.w	r6, r6, #768	; 0x300
 7f4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 7f8:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 7fc:	ea8c 0c02 	eor.w	ip, ip, r2
 800:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 804:	f3c5 4507 	ubfx	r5, r5, #16, #8
 808:	ea82 0906 	eor.w	r9, r2, r6
 80c:	f505 7580 	add.w	r5, r5, #256	; 0x100
 810:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 814:	f3c1 2107 	ubfx	r1, r1, #8, #8
 818:	ea89 0902 	eor.w	r9, r9, r2
 81c:	f501 7100 	add.w	r1, r1, #512	; 0x200
 820:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
 824:	ea89 0902 	eor.w	r9, r9, r2
 828:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
 82c:	ea89 0902 	eor.w	r9, r9, r2
 830:	fa5f f289 	uxtb.w	r2, r9
 834:	ea4f 611e 	mov.w	r1, lr, lsr #24
 838:	f502 7240 	add.w	r2, r2, #768	; 0x300
 83c:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 840:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 844:	ea82 0201 	eor.w	r2, r2, r1
 848:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 84c:	ea81 0102 	eor.w	r1, r1, r2
 850:	f3c0 4207 	ubfx	r2, r0, #16, #8
 854:	f502 7280 	add.w	r2, r2, #256	; 0x100
 858:	ea4f 6510 	mov.w	r5, r0, lsr #24
 85c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 860:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
 864:	ea81 0102 	eor.w	r1, r1, r2
 868:	f3cc 2207 	ubfx	r2, ip, #8, #8
 86c:	f502 7200 	add.w	r2, r2, #512	; 0x200
 870:	ea4f 661c 	mov.w	r6, ip, lsr #24
 874:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 878:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 87c:	ea81 0102 	eor.w	r1, r1, r2
 880:	fa5f f28e 	uxtb.w	r2, lr
 884:	f502 7240 	add.w	r2, r2, #768	; 0x300
 888:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 88c:	ea85 0502 	eor.w	r5, r5, r2
 890:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 894:	ea85 0502 	eor.w	r5, r5, r2
 898:	f3cc 4207 	ubfx	r2, ip, #16, #8
 89c:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8a0:	fa5f fc8c 	uxtb.w	ip, ip
 8a4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8a8:	ea85 0502 	eor.w	r5, r5, r2
 8ac:	f3c9 2207 	ubfx	r2, r9, #8, #8
 8b0:	f502 7200 	add.w	r2, r2, #512	; 0x200
 8b4:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
 8b8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8bc:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 8c0:	ea85 0502 	eor.w	r5, r5, r2
 8c4:	b2c2      	uxtb	r2, r0
 8c6:	f502 7240 	add.w	r2, r2, #768	; 0x300
 8ca:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8ce:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8d2:	ea86 0602 	eor.w	r6, r6, r2
 8d6:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 8da:	ea86 0602 	eor.w	r6, r6, r2
 8de:	f3c9 4207 	ubfx	r2, r9, #16, #8
 8e2:	f502 7280 	add.w	r2, r2, #256	; 0x100
 8e6:	ea4f 6919 	mov.w	r9, r9, lsr #24
 8ea:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8ee:	ea86 0602 	eor.w	r6, r6, r2
 8f2:	f3ce 2207 	ubfx	r2, lr, #8, #8
 8f6:	f502 7200 	add.w	r2, r2, #512	; 0x200
 8fa:	f3ce 4e07 	ubfx	lr, lr, #16, #8
 8fe:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 902:	ea86 0602 	eor.w	r6, r6, r2
 906:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 90a:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
 90e:	ea82 0c0c 	eor.w	ip, r2, ip
 912:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
 916:	f500 7000 	add.w	r0, r0, #512	; 0x200
 91a:	ea8c 0c02 	eor.w	ip, ip, r2
 91e:	f853 202e 	ldr.w	r2, [r3, lr, lsl #2]
 922:	ea8c 0c02 	eor.w	ip, ip, r2
 926:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 92a:	ea8c 0c02 	eor.w	ip, ip, r2
    if (r > 5) {
 92e:	f240 81e5 	bls.w	cfc <wc_AesEncrypt+0xcfc>
        ENC_ROUND_S_T(40); ENC_ROUND_T_S(40);
 932:	fa5f f08c 	uxtb.w	r0, ip
 936:	0e0a      	lsrs	r2, r1, #24
 938:	f500 7040 	add.w	r0, r0, #768	; 0x300
 93c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 940:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 944:	ea82 0e00 	eor.w	lr, r2, r0
 948:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 94c:	ea8e 0e02 	eor.w	lr, lr, r2
 950:	f3c5 4207 	ubfx	r2, r5, #16, #8
 954:	f502 7280 	add.w	r2, r2, #256	; 0x100
 958:	b2c8      	uxtb	r0, r1
 95a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 95e:	ea8e 0e02 	eor.w	lr, lr, r2
 962:	f3c6 2207 	ubfx	r2, r6, #8, #8
 966:	f502 7200 	add.w	r2, r2, #512	; 0x200
 96a:	f500 7040 	add.w	r0, r0, #768	; 0x300
 96e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 972:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 976:	ea8e 0e02 	eor.w	lr, lr, r2
 97a:	0e2a      	lsrs	r2, r5, #24
        if (r > 6) {
 97c:	2f07      	cmp	r7, #7
        ENC_ROUND_S_T(40); ENC_ROUND_T_S(40);
 97e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 982:	ea82 0900 	eor.w	r9, r2, r0
 986:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 98a:	ea89 0902 	eor.w	r9, r9, r2
 98e:	f3c6 4207 	ubfx	r2, r6, #16, #8
 992:	f502 7280 	add.w	r2, r2, #256	; 0x100
 996:	b2e8      	uxtb	r0, r5
 998:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 99c:	ea89 0902 	eor.w	r9, r9, r2
 9a0:	f3cc 2207 	ubfx	r2, ip, #8, #8
 9a4:	f502 7200 	add.w	r2, r2, #512	; 0x200
 9a8:	f500 7040 	add.w	r0, r0, #768	; 0x300
 9ac:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 9b0:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 9b4:	ea89 0902 	eor.w	r9, r9, r2
 9b8:	ea4f 6216 	mov.w	r2, r6, lsr #24
 9bc:	b2f6      	uxtb	r6, r6
 9be:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 9c2:	ea80 0002 	eor.w	r0, r0, r2
 9c6:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
 9ca:	ea82 0200 	eor.w	r2, r2, r0
 9ce:	f3cc 4007 	ubfx	r0, ip, #16, #8
 9d2:	f500 7080 	add.w	r0, r0, #256	; 0x100
 9d6:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 9da:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 9de:	ea82 0200 	eor.w	r2, r2, r0
 9e2:	f3c1 2007 	ubfx	r0, r1, #8, #8
 9e6:	f500 7000 	add.w	r0, r0, #512	; 0x200
 9ea:	f506 7640 	add.w	r6, r6, #768	; 0x300
 9ee:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 9f2:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 9f6:	ea82 0200 	eor.w	r2, r2, r0
 9fa:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 9fe:	f3c1 4107 	ubfx	r1, r1, #16, #8
 a02:	ea80 0c06 	eor.w	ip, r0, r6
 a06:	f501 7180 	add.w	r1, r1, #256	; 0x100
 a0a:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 a0e:	f3c5 2507 	ubfx	r5, r5, #8, #8
 a12:	ea8c 0c00 	eor.w	ip, ip, r0
 a16:	f505 7500 	add.w	r5, r5, #512	; 0x200
 a1a:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 a1e:	ea8c 0c00 	eor.w	ip, ip, r0
 a22:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 a26:	ea8c 0c00 	eor.w	ip, ip, r0
 a2a:	fa5f f08c 	uxtb.w	r0, ip
 a2e:	ea4f 611e 	mov.w	r1, lr, lsr #24
 a32:	f500 7040 	add.w	r0, r0, #768	; 0x300
 a36:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 a3a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 a3e:	ea80 0001 	eor.w	r0, r0, r1
 a42:	f8d4 10b0 	ldr.w	r1, [r4, #176]	; 0xb0
 a46:	ea81 0100 	eor.w	r1, r1, r0
 a4a:	f3c9 4007 	ubfx	r0, r9, #16, #8
 a4e:	f500 7080 	add.w	r0, r0, #256	; 0x100
 a52:	ea4f 6519 	mov.w	r5, r9, lsr #24
 a56:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 a5a:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
 a5e:	ea81 0100 	eor.w	r1, r1, r0
 a62:	f3c2 2007 	ubfx	r0, r2, #8, #8
 a66:	f500 7000 	add.w	r0, r0, #512	; 0x200
 a6a:	ea4f 6612 	mov.w	r6, r2, lsr #24
 a6e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 a72:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 a76:	ea81 0100 	eor.w	r1, r1, r0
 a7a:	fa5f f08e 	uxtb.w	r0, lr
 a7e:	f500 7040 	add.w	r0, r0, #768	; 0x300
 a82:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 a86:	ea80 0005 	eor.w	r0, r0, r5
 a8a:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
 a8e:	ea85 0500 	eor.w	r5, r5, r0
 a92:	f3c2 4007 	ubfx	r0, r2, #16, #8
 a96:	f500 7080 	add.w	r0, r0, #256	; 0x100
 a9a:	b2d2      	uxtb	r2, r2
 a9c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 aa0:	ea85 0500 	eor.w	r5, r5, r0
 aa4:	f3cc 2007 	ubfx	r0, ip, #8, #8
 aa8:	f500 7000 	add.w	r0, r0, #512	; 0x200
 aac:	f502 7240 	add.w	r2, r2, #768	; 0x300
 ab0:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 ab4:	ea85 0500 	eor.w	r5, r5, r0
 ab8:	fa5f f089 	uxtb.w	r0, r9
 abc:	f500 7040 	add.w	r0, r0, #768	; 0x300
 ac0:	f3c9 2907 	ubfx	r9, r9, #8, #8
 ac4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 ac8:	ea86 0600 	eor.w	r6, r6, r0
 acc:	f8d4 00b8 	ldr.w	r0, [r4, #184]	; 0xb8
 ad0:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 ad4:	ea86 0600 	eor.w	r6, r6, r0
 ad8:	f3cc 4007 	ubfx	r0, ip, #16, #8
 adc:	f500 7080 	add.w	r0, r0, #256	; 0x100
 ae0:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 ae4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 ae8:	ea86 0600 	eor.w	r6, r6, r0
 aec:	f3ce 2007 	ubfx	r0, lr, #8, #8
 af0:	f500 7000 	add.w	r0, r0, #512	; 0x200
 af4:	f3ce 4e07 	ubfx	lr, lr, #16, #8
 af8:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 afc:	ea86 0600 	eor.w	r6, r6, r0
 b00:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 b04:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
 b08:	ea80 0c02 	eor.w	ip, r0, r2
 b0c:	f8d4 00bc 	ldr.w	r0, [r4, #188]	; 0xbc
 b10:	f509 7900 	add.w	r9, r9, #512	; 0x200
 b14:	ea8c 0c00 	eor.w	ip, ip, r0
 b18:	f853 002e 	ldr.w	r0, [r3, lr, lsl #2]
 b1c:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 b20:	ea8c 0c00 	eor.w	ip, ip, r0
 b24:	ea8c 0c02 	eor.w	ip, ip, r2
        if (r > 6) {
 b28:	f040 80e8 	bne.w	cfc <wc_AesEncrypt+0xcfc>
            ENC_ROUND_S_T(48); ENC_ROUND_T_S(48);
 b2c:	fa5f f08c 	uxtb.w	r0, ip
 b30:	0e0a      	lsrs	r2, r1, #24
 b32:	f500 7040 	add.w	r0, r0, #768	; 0x300
 b36:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 b3a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 b3e:	ea82 0e00 	eor.w	lr, r2, r0
 b42:	f8d4 20c0 	ldr.w	r2, [r4, #192]	; 0xc0
 b46:	ea8e 0e02 	eor.w	lr, lr, r2
 b4a:	f3c5 4207 	ubfx	r2, r5, #16, #8
 b4e:	f502 7280 	add.w	r2, r2, #256	; 0x100
 b52:	b2c8      	uxtb	r0, r1
 b54:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 b58:	ea8e 0e02 	eor.w	lr, lr, r2
 b5c:	f3c6 2207 	ubfx	r2, r6, #8, #8
 b60:	f502 7200 	add.w	r2, r2, #512	; 0x200
 b64:	f500 7040 	add.w	r0, r0, #768	; 0x300
 b68:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 b6c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 b70:	ea8e 0e02 	eor.w	lr, lr, r2
 b74:	0e2a      	lsrs	r2, r5, #24
 b76:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 b7a:	ea82 0900 	eor.w	r9, r2, r0
 b7e:	f8d4 20c4 	ldr.w	r2, [r4, #196]	; 0xc4
 b82:	ea89 0902 	eor.w	r9, r9, r2
 b86:	f3c6 4207 	ubfx	r2, r6, #16, #8
 b8a:	f502 7280 	add.w	r2, r2, #256	; 0x100
 b8e:	b2e8      	uxtb	r0, r5
 b90:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 b94:	ea89 0902 	eor.w	r9, r9, r2
 b98:	f3cc 2207 	ubfx	r2, ip, #8, #8
 b9c:	f502 7200 	add.w	r2, r2, #512	; 0x200
 ba0:	f500 7040 	add.w	r0, r0, #768	; 0x300
 ba4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 ba8:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 bac:	ea89 0902 	eor.w	r9, r9, r2
 bb0:	0e32      	lsrs	r2, r6, #24
 bb2:	b2f6      	uxtb	r6, r6
 bb4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 bb8:	4050      	eors	r0, r2
 bba:	f8d4 20c8 	ldr.w	r2, [r4, #200]	; 0xc8
 bbe:	4042      	eors	r2, r0
 bc0:	f3cc 4007 	ubfx	r0, ip, #16, #8
 bc4:	f500 7080 	add.w	r0, r0, #256	; 0x100
 bc8:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 bcc:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 bd0:	4042      	eors	r2, r0
 bd2:	f3c1 2007 	ubfx	r0, r1, #8, #8
 bd6:	f500 7000 	add.w	r0, r0, #512	; 0x200
 bda:	f506 7640 	add.w	r6, r6, #768	; 0x300
 bde:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 be2:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 be6:	4042      	eors	r2, r0
 be8:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 bec:	f3c1 4107 	ubfx	r1, r1, #16, #8
 bf0:	ea80 0c06 	eor.w	ip, r0, r6
 bf4:	f501 7180 	add.w	r1, r1, #256	; 0x100
 bf8:	f8d4 00cc 	ldr.w	r0, [r4, #204]	; 0xcc
 bfc:	f3c5 2507 	ubfx	r5, r5, #8, #8
 c00:	ea8c 0c00 	eor.w	ip, ip, r0
 c04:	f505 7500 	add.w	r5, r5, #512	; 0x200
 c08:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
 c0c:	ea8c 0c00 	eor.w	ip, ip, r0
 c10:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 c14:	ea8c 0c00 	eor.w	ip, ip, r0
 c18:	fa5f f08c 	uxtb.w	r0, ip
 c1c:	ea4f 611e 	mov.w	r1, lr, lsr #24
 c20:	f500 7040 	add.w	r0, r0, #768	; 0x300
 c24:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 c28:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 c2c:	4048      	eors	r0, r1
 c2e:	f8d4 10d0 	ldr.w	r1, [r4, #208]	; 0xd0
 c32:	4041      	eors	r1, r0
 c34:	f3c9 4007 	ubfx	r0, r9, #16, #8
 c38:	f500 7080 	add.w	r0, r0, #256	; 0x100
 c3c:	ea4f 6519 	mov.w	r5, r9, lsr #24
 c40:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 c44:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
 c48:	4041      	eors	r1, r0
 c4a:	f3c2 2007 	ubfx	r0, r2, #8, #8
 c4e:	f500 7000 	add.w	r0, r0, #512	; 0x200
 c52:	0e16      	lsrs	r6, r2, #24
 c54:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 c58:	f853 6026 	ldr.w	r6, [r3, r6, lsl #2]
 c5c:	4041      	eors	r1, r0
 c5e:	fa5f f08e 	uxtb.w	r0, lr
 c62:	f500 7040 	add.w	r0, r0, #768	; 0x300
 c66:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 c6a:	4068      	eors	r0, r5
 c6c:	f8d4 50d4 	ldr.w	r5, [r4, #212]	; 0xd4
 c70:	4045      	eors	r5, r0
 c72:	f3c2 4007 	ubfx	r0, r2, #16, #8
 c76:	f500 7080 	add.w	r0, r0, #256	; 0x100
 c7a:	b2d2      	uxtb	r2, r2
 c7c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 c80:	4045      	eors	r5, r0
 c82:	f3cc 2007 	ubfx	r0, ip, #8, #8
 c86:	f500 7000 	add.w	r0, r0, #512	; 0x200
 c8a:	f502 7240 	add.w	r2, r2, #768	; 0x300
 c8e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 c92:	4045      	eors	r5, r0
 c94:	fa5f f089 	uxtb.w	r0, r9
 c98:	f500 7040 	add.w	r0, r0, #768	; 0x300
 c9c:	f3c9 2907 	ubfx	r9, r9, #8, #8
 ca0:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 ca4:	4046      	eors	r6, r0
 ca6:	f8d4 00d8 	ldr.w	r0, [r4, #216]	; 0xd8
 caa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 cae:	4046      	eors	r6, r0
 cb0:	f3cc 4007 	ubfx	r0, ip, #16, #8
 cb4:	f500 7080 	add.w	r0, r0, #256	; 0x100
 cb8:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 cbc:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 cc0:	4046      	eors	r6, r0
 cc2:	f3ce 2007 	ubfx	r0, lr, #8, #8
 cc6:	f500 7000 	add.w	r0, r0, #512	; 0x200
 cca:	f3ce 4e07 	ubfx	lr, lr, #16, #8
 cce:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 cd2:	4046      	eors	r6, r0
 cd4:	f853 002c 	ldr.w	r0, [r3, ip, lsl #2]
 cd8:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
 cdc:	ea80 0c02 	eor.w	ip, r0, r2
 ce0:	f8d4 00dc 	ldr.w	r0, [r4, #220]	; 0xdc
 ce4:	f509 7900 	add.w	r9, r9, #512	; 0x200
 ce8:	ea8c 0c00 	eor.w	ip, ip, r0
 cec:	f853 002e 	ldr.w	r0, [r3, lr, lsl #2]
 cf0:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 cf4:	ea8c 0c00 	eor.w	ip, ip, r0
 cf8:	ea8c 0c02 	eor.w	ip, ip, r2
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 cfc:	b2ca      	uxtb	r2, r1
    rk += r * 8;
 cfe:	0178      	lsls	r0, r7, #5
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 d00:	f502 7280 	add.w	r2, r2, #256	; 0x100
    rk += r * 8;
 d04:	eb04 1747 	add.w	r7, r4, r7, lsl #5
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 d08:	f813 9022 	ldrb.w	r9, [r3, r2, lsl #2]
 d0c:	687a      	ldr	r2, [r7, #4]
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 d0e:	5824      	ldr	r4, [r4, r0]
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 d10:	ea89 0902 	eor.w	r9, r9, r2
        (GetTable(Te[0], GETBYTE(t3, 1)) & 0x0000ff00) ^
 d14:	f3cc 2207 	ubfx	r2, ip, #8, #8
 d18:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 d1c:	f402 4e7f 	and.w	lr, r2, #65280	; 0xff00
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 d20:	ea89 020e 	eor.w	r2, r9, lr
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 d24:	f3c6 4e07 	ubfx	lr, r6, #16, #8
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 d28:	ea4f 6915 	mov.w	r9, r5, lsr #24
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 d2c:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 d30:	f509 7900 	add.w	r9, r9, #512	; 0x200
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 d34:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 d38:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
        (GetTable(Te[3], GETBYTE(t2, 2)) & 0x00ff0000) ^
 d3c:	f40e 0e7f 	and.w	lr, lr, #16711680	; 0xff0000
        (GetTable(Te[2], GETBYTE(t1, 3)) & 0xff000000) ^
 d40:	f009 497f 	and.w	r9, r9, #4278190080	; 0xff000000
 d44:	ea4e 0e09 	orr.w	lr, lr, r9
        (GetTable(Te[1], GETBYTE(t0, 0)) & 0x000000ff) ^
 d48:	ea82 090e 	eor.w	r9, r2, lr
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 d4c:	b2ea      	uxtb	r2, r5
 d4e:	f502 7280 	add.w	r2, r2, #256	; 0x100
 d52:	f813 a022 	ldrb.w	sl, [r3, r2, lsl #2]
 d56:	68ba      	ldr	r2, [r7, #8]
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 d58:	68ff      	ldr	r7, [r7, #12]
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 d5a:	ea8a 0a02 	eor.w	sl, sl, r2
        (GetTable(Te[0], GETBYTE(t0, 1)) & 0x0000ff00) ^
 d5e:	f3c1 2207 	ubfx	r2, r1, #8, #8
 d62:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 d66:	f402 4e7f 	and.w	lr, r2, #65280	; 0xff00
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 d6a:	ea8a 020e 	eor.w	r2, sl, lr
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 d6e:	f3cc 4e07 	ubfx	lr, ip, #16, #8
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 d72:	ea4f 6a16 	mov.w	sl, r6, lsr #24
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 d76:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 d7a:	f50a 7a00 	add.w	sl, sl, #512	; 0x200
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 d7e:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 d82:	f853 a02a 	ldr.w	sl, [r3, sl, lsl #2]
        (GetTable(Te[3], GETBYTE(t3, 2)) & 0x00ff0000) ^
 d86:	f40e 0e7f 	and.w	lr, lr, #16711680	; 0xff0000
        (GetTable(Te[2], GETBYTE(t2, 3)) & 0xff000000) ^
 d8a:	f00a 4a7f 	and.w	sl, sl, #4278190080	; 0xff000000
 d8e:	ea4e 0e0a 	orr.w	lr, lr, sl
        (GetTable(Te[1], GETBYTE(t1, 0)) & 0x000000ff) ^
 d92:	ea82 0a0e 	eor.w	sl, r2, lr
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 d96:	b2f2      	uxtb	r2, r6
 d98:	f502 7280 	add.w	r2, r2, #256	; 0x100
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 d9c:	ea4f 6e1c 	mov.w	lr, ip, lsr #24
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 da0:	f813 2022 	ldrb.w	r2, [r3, r2, lsl #2]
 da4:	407a      	eors	r2, r7
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 da6:	f3c5 2707 	ubfx	r7, r5, #8, #8
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 daa:	f50e 7e00 	add.w	lr, lr, #512	; 0x200
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 dae:	f853 7027 	ldr.w	r7, [r3, r7, lsl #2]
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 db2:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
        (GetTable(Te[0], GETBYTE(t1, 1)) & 0x0000ff00) ^
 db6:	f407 477f 	and.w	r7, r7, #65280	; 0xff00
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 dba:	4057      	eors	r7, r2
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 dbc:	f3c1 4207 	ubfx	r2, r1, #16, #8
 dc0:	f502 7240 	add.w	r2, r2, #768	; 0x300
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 dc4:	fa5f fc8c 	uxtb.w	ip, ip
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 dc8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 dcc:	f00e 4e7f 	and.w	lr, lr, #4278190080	; 0xff000000
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 dd0:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
        (GetTable(Te[3], GETBYTE(t0, 2)) & 0x00ff0000) ^
 dd4:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 dd8:	f3c6 2607 	ubfx	r6, r6, #8, #8
        (GetTable(Te[2], GETBYTE(t3, 3)) & 0xff000000) ^
 ddc:	ea42 020e 	orr.w	r2, r2, lr
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 de0:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
        (GetTable(Te[1], GETBYTE(t2, 0)) & 0x000000ff) ^
 de4:	407a      	eors	r2, r7
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 de6:	f3c5 4507 	ubfx	r5, r5, #16, #8
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 dea:	f813 702c 	ldrb.w	r7, [r3, ip, lsl #2]
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 dee:	0e09      	lsrs	r1, r1, #24
 df0:	f501 7100 	add.w	r1, r1, #512	; 0x200
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 df4:	f505 7540 	add.w	r5, r5, #768	; 0x300
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 df8:	407c      	eors	r4, r7
        (GetTable(Te[0], GETBYTE(t2, 1)) & 0x0000ff00) ^
 dfa:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
        (GetTable(Te[1], GETBYTE(t3, 0)) & 0x000000ff) ^
 dfe:	4060      	eors	r0, r4
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 e00:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 e04:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
        (GetTable(Te[3], GETBYTE(t1, 2)) & 0x00ff0000) ^
 e08:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
        (GetTable(Te[2], GETBYTE(t0, 3)) & 0xff000000) ^
 e0c:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 e10:	4323      	orrs	r3, r4
    s0 = ByteReverseWord32(s0);
 e12:	4058      	eors	r0, r3
 e14:	f7ff fffe 	bl	0 <wc_AesEncrypt>
 e18:	9000      	str	r0, [sp, #0]
    s1 = ByteReverseWord32(s1);
 e1a:	4648      	mov	r0, r9
 e1c:	f7ff fffe 	bl	0 <wc_AesEncrypt>
 e20:	9001      	str	r0, [sp, #4]
    s2 = ByteReverseWord32(s2);
 e22:	4650      	mov	r0, sl
 e24:	f7ff fffe 	bl	0 <wc_AesEncrypt>
 e28:	9002      	str	r0, [sp, #8]
    s3 = ByteReverseWord32(s3);
 e2a:	4610      	mov	r0, r2
 e2c:	f7ff fffe 	bl	0 <wc_AesEncrypt>
    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 e30:	2204      	movs	r2, #4
    s3 = ByteReverseWord32(s3);
 e32:	9003      	str	r0, [sp, #12]
    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 e34:	4669      	mov	r1, sp
 e36:	4640      	mov	r0, r8
 e38:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(outBlock +     sizeof(s0), &s1, sizeof(s1));
 e3c:	2204      	movs	r2, #4
 e3e:	eb0d 0102 	add.w	r1, sp, r2
 e42:	eb08 0002 	add.w	r0, r8, r2
 e46:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 e4a:	2204      	movs	r2, #4
 e4c:	a902      	add	r1, sp, #8
 e4e:	f108 0008 	add.w	r0, r8, #8
 e52:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 e56:	2204      	movs	r2, #4
 e58:	a903      	add	r1, sp, #12
 e5a:	f108 000c 	add.w	r0, r8, #12
 e5e:	f7ff fffe 	bl	0 <memcpy>
    return 0;
 e62:	2000      	movs	r0, #0
} /* wc_AesEncrypt */
 e64:	b004      	add	sp, #16
 e66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return BAD_FUNC_ARG;
 e6a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 e6e:	e7f9      	b.n	e64 <wc_AesEncrypt+0xe64>
        return KEYUSAGE_E;
 e70:	f06f 00e1 	mvn.w	r0, #225	; 0xe1
 e74:	e7f6      	b.n	e64 <wc_AesEncrypt+0xe64>
 e76:	bf00      	nop

Disassembly of section .text.GMULT:

00000000 <GMULT>:

#endif /* WOLFSSL_AESNI */

#if defined(GCM_SMALL)
static void GMULT(byte* X, byte* Y)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b088      	sub	sp, #32
   6:	460c      	mov	r4, r1
   8:	4606      	mov	r6, r0
    byte Z[AES_BLOCK_SIZE];
    byte V[AES_BLOCK_SIZE];
    int i, j;

    XMEMSET(Z, 0, AES_BLOCK_SIZE);
   a:	2210      	movs	r2, #16
   c:	2100      	movs	r1, #0
   e:	4668      	mov	r0, sp
  10:	f7ff fffe 	bl	0 <memset>
    XMEMCPY(V, X, AES_BLOCK_SIZE);
  14:	2210      	movs	r2, #16
  16:	4631      	mov	r1, r6
  18:	eb0d 0002 	add.w	r0, sp, r2
  1c:	f7ff fffe 	bl	0 <memcpy>
    for (i = 0; i < AES_BLOCK_SIZE; i++)
  20:	1e67      	subs	r7, r4, #1
  22:	340f      	adds	r4, #15
    {
        byte y = Y[i];
  24:	f817 5f01 	ldrb.w	r5, [r7, #1]!
  28:	f04f 0808 	mov.w	r8, #8
        for (j = 0; j < 8; j++)
        {
            if (y & 0x80) {
  2c:	062b      	lsls	r3, r5, #24
  2e:	d505      	bpl.n	3c <GMULT+0x3c>
                xorbuf(Z, V, AES_BLOCK_SIZE);
  30:	2210      	movs	r2, #16
  32:	eb0d 0102 	add.w	r1, sp, r2
  36:	4668      	mov	r0, sp
  38:	f7ff fffe 	bl	0 <GMULT>
    byte borrow = (0x00 - (x[15] & 0x01)) & 0xE1;
  3c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    int carryIn = 0;
  40:	2100      	movs	r1, #0
    byte borrow = (0x00 - (x[15] & 0x01)) & 0xE1;
  42:	f343 0300 	sbfx	r3, r3, #0, #1
  46:	f003 03e1 	and.w	r3, r3, #225	; 0xe1
    for (i = 0; i < AES_BLOCK_SIZE; i++) {
  4a:	a804      	add	r0, sp, #16
  4c:	460a      	mov	r2, r1
        int carryOut = (x[i] & 0x01) << 7;
  4e:	f890 e000 	ldrb.w	lr, [r0]
  52:	468c      	mov	ip, r1
    for (i = 0; i < AES_BLOCK_SIZE; i++) {
  54:	3201      	adds	r2, #1
        int carryOut = (x[i] & 0x01) << 7;
  56:	ea4f 11ce 	mov.w	r1, lr, lsl #7
        x[i] = (byte) ((x[i] >> 1) | carryIn);
  5a:	ea4c 0c5e 	orr.w	ip, ip, lr, lsr #1
    for (i = 0; i < AES_BLOCK_SIZE; i++) {
  5e:	2a10      	cmp	r2, #16
        x[i] = (byte) ((x[i] >> 1) | carryIn);
  60:	f800 cb01 	strb.w	ip, [r0], #1
        int carryOut = (x[i] & 0x01) << 7;
  64:	b2c9      	uxtb	r1, r1
    for (i = 0; i < AES_BLOCK_SIZE; i++) {
  66:	d1f2      	bne.n	4e <GMULT+0x4e>
    x[0] ^= borrow;
  68:	f89d 1010 	ldrb.w	r1, [sp, #16]
            }

            RIGHTSHIFTX(V);
            y = y << 1;
  6c:	006d      	lsls	r5, r5, #1
    x[0] ^= borrow;
  6e:	404b      	eors	r3, r1
        for (j = 0; j < 8; j++)
  70:	f1b8 0801 	subs.w	r8, r8, #1
    x[0] ^= borrow;
  74:	f88d 3010 	strb.w	r3, [sp, #16]
            y = y << 1;
  78:	b2ed      	uxtb	r5, r5
        for (j = 0; j < 8; j++)
  7a:	d1d7      	bne.n	2c <GMULT+0x2c>
    for (i = 0; i < AES_BLOCK_SIZE; i++)
  7c:	42bc      	cmp	r4, r7
  7e:	d1d1      	bne.n	24 <GMULT+0x24>
        }
    }
    XMEMCPY(X, Z, AES_BLOCK_SIZE);
  80:	4669      	mov	r1, sp
  82:	4630      	mov	r0, r6
  84:	f7ff fffe 	bl	0 <memcpy>
}
  88:	b008      	add	sp, #32
  8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.wc_AesSetIV:

00000000 <wc_AesSetIV>:
{
   0:	b510      	push	{r4, lr}
    if (aes == NULL)
   2:	b148      	cbz	r0, 18 <wc_AesSetIV+0x18>
        XMEMCPY(aes->reg, iv, AES_BLOCK_SIZE);
   4:	30f8      	adds	r0, #248	; 0xf8
   6:	2210      	movs	r2, #16
    if (iv)
   8:	b119      	cbz	r1, 12 <wc_AesSetIV+0x12>
        XMEMCPY(aes->reg, iv, AES_BLOCK_SIZE);
   a:	f7ff fffe 	bl	0 <memcpy>
    return 0;
   e:	2000      	movs	r0, #0
}
  10:	bd10      	pop	{r4, pc}
        XMEMSET(aes->reg,  0, AES_BLOCK_SIZE);
  12:	f7ff fffe 	bl	0 <memset>
  16:	e7fa      	b.n	e <wc_AesSetIV+0xe>
        return BAD_FUNC_ARG;
  18:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1c:	e7f8      	b.n	10 <wc_AesSetIV+0x10>

Disassembly of section .text.wc_AesSetKey:

00000000 <wc_AesSetKey>:
    {
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
   8:	4691      	mov	r9, r2
   a:	469b      	mov	fp, r3
        if (aes == NULL) {
   c:	4605      	mov	r5, r0
   e:	2800      	cmp	r0, #0
  10:	f000 821d 	beq.w	44e <wc_AesSetKey+0x44e>
        if (keylen > sizeof(aes->key)) {
  14:	2af0      	cmp	r2, #240	; 0xf0
  16:	f200 821a 	bhi.w	44e <wc_AesSetKey+0x44e>
            if (keylen != 16 && keylen != 24 && keylen != 32) {
  1a:	f022 0308 	bic.w	r3, r2, #8
  1e:	2b10      	cmp	r3, #16
  20:	d002      	beq.n	28 <wc_AesSetKey+0x28>
  22:	2a20      	cmp	r2, #32
  24:	f040 8213 	bne.w	44e <wc_AesSetKey+0x44e>
        aes->rounds = (keylen/4) + 6;
  28:	ea4f 0a99 	mov.w	sl, r9, lsr #2
  2c:	f10a 0306 	add.w	r3, sl, #6
  30:	f8c5 30f0 	str.w	r3, [r5, #240]	; 0xf0
        aes->keylen = (int)keylen;
  34:	f8c5 90f4 	str.w	r9, [r5, #244]	; 0xf4
        XMEMCPY(rk, userKey, keylen);
  38:	464a      	mov	r2, r9
  3a:	4628      	mov	r0, r5
  3c:	f7ff fffe 	bl	0 <memcpy>
        rk = aes->key;
  40:	462c      	mov	r4, r5
        for (i = 0; i < count; i++)
  42:	462e      	mov	r6, r5
  44:	eb05 0a8a 	add.w	sl, r5, sl, lsl #2
  48:	462b      	mov	r3, r5
  4a:	459a      	cmp	sl, r3
  4c:	d149      	bne.n	e2 <wc_AesSetKey+0xe2>
        switch (keylen) {
  4e:	f1b9 0f18 	cmp.w	r9, #24
  52:	f000 80bb 	beq.w	1cc <wc_AesSetKey+0x1cc>
  56:	f1b9 0f20 	cmp.w	r9, #32
  5a:	d048      	beq.n	ee <wc_AesSetKey+0xee>
  5c:	f1b9 0f10 	cmp.w	r9, #16
  60:	f040 81f5 	bne.w	44e <wc_AesSetKey+0x44e>
  64:	f8df c210 	ldr.w	ip, [pc, #528]	; 278 <wc_AesSetKey+0x278>
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
  68:	4884      	ldr	r0, [pc, #528]	; (27c <wc_AesSetKey+0x27c>)
  6a:	f105 0e90 	add.w	lr, r5, #144	; 0x90
                temp  = rk[3];
  6e:	68e2      	ldr	r2, [r4, #12]
                    rcon[i];
  70:	f85c 9b04 	ldr.w	r9, [ip], #4
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
  74:	b2d3      	uxtb	r3, r2
                if (++i == 10)
  76:	4574      	cmp	r4, lr
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
  78:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
  7c:	6823      	ldr	r3, [r4, #0]
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
  7e:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
  82:	ea89 0303 	eor.w	r3, r9, r3
  86:	ea83 0301 	eor.w	r3, r3, r1
  8a:	ea4f 6112 	mov.w	r1, r2, lsr #24
  8e:	f501 7180 	add.w	r1, r1, #256	; 0x100
  92:	f810 1021 	ldrb.w	r1, [r0, r1, lsl #2]
  96:	ea83 0301 	eor.w	r3, r3, r1
                    (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
  9a:	f3c2 4107 	ubfx	r1, r2, #16, #8
  9e:	f501 7100 	add.w	r1, r1, #512	; 0x200
  a2:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
  a6:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
  aa:	ea83 0301 	eor.w	r3, r3, r1
                    (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
  ae:	f3c2 2107 	ubfx	r1, r2, #8, #8
  b2:	f501 7140 	add.w	r1, r1, #768	; 0x300
  b6:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
  ba:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
  be:	ea83 0301 	eor.w	r3, r3, r1
                rk[5] = rk[1] ^ rk[4];
  c2:	6861      	ldr	r1, [r4, #4]
                rk[4] = rk[0] ^
  c4:	6123      	str	r3, [r4, #16]
                rk[5] = rk[1] ^ rk[4];
  c6:	ea83 0301 	eor.w	r3, r3, r1
                rk[6] = rk[2] ^ rk[5];
  ca:	68a1      	ldr	r1, [r4, #8]
                rk[5] = rk[1] ^ rk[4];
  cc:	6163      	str	r3, [r4, #20]
                rk[6] = rk[2] ^ rk[5];
  ce:	ea83 0301 	eor.w	r3, r3, r1
  d2:	61a3      	str	r3, [r4, #24]
                rk[7] = rk[3] ^ rk[6];
  d4:	ea83 0302 	eor.w	r3, r3, r2
  d8:	61e3      	str	r3, [r4, #28]
                if (++i == 10)
  da:	f000 80ba 	beq.w	252 <wc_AesSetKey+0x252>
                rk += 4;
  de:	3410      	adds	r4, #16
                temp  = rk[3];
  e0:	e7c5      	b.n	6e <wc_AesSetKey+0x6e>
            out[i] = ByteReverseWord32(in[i]);
  e2:	6818      	ldr	r0, [r3, #0]
  e4:	f7ff fffe 	bl	0 <wc_AesSetKey>
  e8:	f843 0b04 	str.w	r0, [r3], #4
        for (i = 0; i < count; i++)
  ec:	e7ad      	b.n	4a <wc_AesSetKey+0x4a>
  ee:	4b62      	ldr	r3, [pc, #392]	; (278 <wc_AesSetKey+0x278>)
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
  f0:	4a62      	ldr	r2, [pc, #392]	; (27c <wc_AesSetKey+0x27c>)
  f2:	f105 0cc0 	add.w	ip, r5, #192	; 0xc0
                temp = rk[ 7];
  f6:	69e0      	ldr	r0, [r4, #28]
                    rcon[i];
  f8:	f853 9b04 	ldr.w	r9, [r3], #4
                rk[ 9] = rk[ 1] ^ rk[ 8];
  fc:	6867      	ldr	r7, [r4, #4]
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
  fe:	b2c1      	uxtb	r1, r0
                if (++i == 7)
 100:	4564      	cmp	r4, ip
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 102:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 106:	f401 4e7f 	and.w	lr, r1, #65280	; 0xff00
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 10a:	6821      	ldr	r1, [r4, #0]
 10c:	ea89 0101 	eor.w	r1, r9, r1
 110:	ea8e 0e01 	eor.w	lr, lr, r1
 114:	ea4f 6110 	mov.w	r1, r0, lsr #24
 118:	f501 7180 	add.w	r1, r1, #256	; 0x100
 11c:	f812 1021 	ldrb.w	r1, [r2, r1, lsl #2]
 120:	ea8e 0e01 	eor.w	lr, lr, r1
                    (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 124:	f3c0 4107 	ubfx	r1, r0, #16, #8
 128:	f501 7100 	add.w	r1, r1, #512	; 0x200
 12c:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 130:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 134:	ea8e 0e01 	eor.w	lr, lr, r1
                    (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 138:	f3c0 2107 	ubfx	r1, r0, #8, #8
 13c:	f501 7140 	add.w	r1, r1, #768	; 0x300
 140:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 144:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 148:	ea8e 0101 	eor.w	r1, lr, r1
                rk[ 8] = rk[ 0] ^
 14c:	6221      	str	r1, [r4, #32]
                rk[ 9] = rk[ 1] ^ rk[ 8];
 14e:	ea81 0107 	eor.w	r1, r1, r7
                rk[10] = rk[ 2] ^ rk[ 9];
 152:	68a7      	ldr	r7, [r4, #8]
                rk[ 9] = rk[ 1] ^ rk[ 8];
 154:	6261      	str	r1, [r4, #36]	; 0x24
                rk[10] = rk[ 2] ^ rk[ 9];
 156:	ea81 0107 	eor.w	r1, r1, r7
                rk[11] = rk[ 3] ^ rk[10];
 15a:	68e7      	ldr	r7, [r4, #12]
                rk[10] = rk[ 2] ^ rk[ 9];
 15c:	62a1      	str	r1, [r4, #40]	; 0x28
                rk[11] = rk[ 3] ^ rk[10];
 15e:	ea81 0e07 	eor.w	lr, r1, r7
 162:	f8c4 e02c 	str.w	lr, [r4, #44]	; 0x2c
                if (++i == 7)
 166:	d074      	beq.n	252 <wc_AesSetKey+0x252>
                    (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 168:	f3ce 4107 	ubfx	r1, lr, #16, #8
 16c:	f501 7140 	add.w	r1, r1, #768	; 0x300
                rk[13] = rk[ 5] ^ rk[12];
 170:	6967      	ldr	r7, [r4, #20]
                    (GetTable(Te[3], GETBYTE(temp, 2)) & 0x00ff0000) ^
 172:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 176:	f401 097f 	and.w	r9, r1, #16711680	; 0xff0000
                    (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 17a:	f3ce 2107 	ubfx	r1, lr, #8, #8
                rk += 8;
 17e:	3420      	adds	r4, #32
                    (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 180:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 184:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
 188:	ea49 0901 	orr.w	r9, r9, r1
 18c:	f854 1c10 	ldr.w	r1, [r4, #-16]
 190:	ea89 0901 	eor.w	r9, r9, r1
                    (GetTable(Te[2], GETBYTE(temp, 3)) & 0xff000000) ^
 194:	ea4f 611e 	mov.w	r1, lr, lsr #24
 198:	f501 7100 	add.w	r1, r1, #512	; 0x200
 19c:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 1a0:	f001 4a7f 	and.w	sl, r1, #4278190080	; 0xff000000
                    (GetTable(Te[1], GETBYTE(temp, 0)) & 0x000000ff);
 1a4:	fa5f f18e 	uxtb.w	r1, lr
 1a8:	f501 7180 	add.w	r1, r1, #256	; 0x100
 1ac:	f812 e021 	ldrb.w	lr, [r2, r1, lsl #2]
                    (GetTable(Te[0], GETBYTE(temp, 1)) & 0x0000ff00) ^
 1b0:	ea4a 0e0e 	orr.w	lr, sl, lr
 1b4:	ea89 010e 	eor.w	r1, r9, lr
                rk[12] = rk[ 4] ^
 1b8:	6121      	str	r1, [r4, #16]
                rk[13] = rk[ 5] ^ rk[12];
 1ba:	4079      	eors	r1, r7
                rk[14] = rk[ 6] ^ rk[13];
 1bc:	f854 7c08 	ldr.w	r7, [r4, #-8]
                rk[13] = rk[ 5] ^ rk[12];
 1c0:	6161      	str	r1, [r4, #20]
                rk[14] = rk[ 6] ^ rk[13];
 1c2:	4079      	eors	r1, r7
 1c4:	61a1      	str	r1, [r4, #24]
                rk[15] = rk[ 7] ^ rk[14];
 1c6:	4041      	eors	r1, r0
 1c8:	61e1      	str	r1, [r4, #28]
                temp = rk[ 7];
 1ca:	e794      	b.n	f6 <wc_AesSetKey+0xf6>
 1cc:	482a      	ldr	r0, [pc, #168]	; (278 <wc_AesSetKey+0x278>)
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 1ce:	4a2b      	ldr	r2, [pc, #172]	; (27c <wc_AesSetKey+0x27c>)
 1d0:	f105 0ca8 	add.w	ip, r5, #168	; 0xa8
                temp = rk[ 5];
 1d4:	6963      	ldr	r3, [r4, #20]
                    rcon[i];
 1d6:	f850 9b04 	ldr.w	r9, [r0], #4
                rk[ 7] = rk[ 1] ^ rk[ 6];
 1da:	6867      	ldr	r7, [r4, #4]
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 1dc:	b2d9      	uxtb	r1, r3
                if (++i == 8)
 1de:	4564      	cmp	r4, ip
                    (GetTable(Te[0], GETBYTE(temp, 0)) & 0x0000ff00) ^
 1e0:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 1e4:	f401 4e7f 	and.w	lr, r1, #65280	; 0xff00
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 1e8:	6821      	ldr	r1, [r4, #0]
 1ea:	ea89 0101 	eor.w	r1, r9, r1
 1ee:	ea8e 0e01 	eor.w	lr, lr, r1
 1f2:	ea4f 6113 	mov.w	r1, r3, lsr #24
 1f6:	f501 7180 	add.w	r1, r1, #256	; 0x100
 1fa:	f812 1021 	ldrb.w	r1, [r2, r1, lsl #2]
 1fe:	ea8e 0e01 	eor.w	lr, lr, r1
                    (GetTable(Te[2], GETBYTE(temp, 2)) & 0xff000000) ^
 202:	f3c3 4107 	ubfx	r1, r3, #16, #8
 206:	f501 7100 	add.w	r1, r1, #512	; 0x200
 20a:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 20e:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 212:	ea8e 0e01 	eor.w	lr, lr, r1
                    (GetTable(Te[3], GETBYTE(temp, 1)) & 0x00ff0000) ^
 216:	f3c3 2107 	ubfx	r1, r3, #8, #8
 21a:	f501 7140 	add.w	r1, r1, #768	; 0x300
 21e:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 222:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
                    (GetTable(Te[1], GETBYTE(temp, 3)) & 0x000000ff) ^
 226:	ea8e 0101 	eor.w	r1, lr, r1
                rk[ 6] = rk[ 0] ^
 22a:	61a1      	str	r1, [r4, #24]
                rk[ 7] = rk[ 1] ^ rk[ 6];
 22c:	ea81 0107 	eor.w	r1, r1, r7
                rk[ 8] = rk[ 2] ^ rk[ 7];
 230:	68a7      	ldr	r7, [r4, #8]
                rk[ 7] = rk[ 1] ^ rk[ 6];
 232:	61e1      	str	r1, [r4, #28]
                rk[ 8] = rk[ 2] ^ rk[ 7];
 234:	ea81 0107 	eor.w	r1, r1, r7
                rk[ 9] = rk[ 3] ^ rk[ 8];
 238:	68e7      	ldr	r7, [r4, #12]
                rk[ 8] = rk[ 2] ^ rk[ 7];
 23a:	6221      	str	r1, [r4, #32]
                rk[ 9] = rk[ 3] ^ rk[ 8];
 23c:	ea81 0107 	eor.w	r1, r1, r7
 240:	6261      	str	r1, [r4, #36]	; 0x24
                if (++i == 8)
 242:	d006      	beq.n	252 <wc_AesSetKey+0x252>
                rk[10] = rk[ 4] ^ rk[ 9];
 244:	6927      	ldr	r7, [r4, #16]
 246:	4079      	eors	r1, r7
 248:	62a1      	str	r1, [r4, #40]	; 0x28
                rk[11] = rk[ 5] ^ rk[10];
 24a:	4059      	eors	r1, r3
 24c:	62e1      	str	r1, [r4, #44]	; 0x2c
                rk += 6;
 24e:	3418      	adds	r4, #24
                temp = rk[ 5];
 250:	e7c0      	b.n	1d4 <wc_AesSetKey+0x1d4>
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
 252:	2200      	movs	r2, #0
        if (dir == AES_DECRYPTION) {
 254:	f1b8 0f01 	cmp.w	r8, #1
 258:	f88d 2004 	strb.w	r2, [sp, #4]
 25c:	f88d 2005 	strb.w	r2, [sp, #5]
 260:	f88d 2006 	strb.w	r2, [sp, #6]
 264:	f88d 2007 	strb.w	r2, [sp, #7]
 268:	d00a      	beq.n	280 <wc_AesSetKey+0x280>
        ret = wc_AesSetIV(aes, iv);
 26a:	4659      	mov	r1, fp
 26c:	4628      	mov	r0, r5
    } /* wc_AesSetKey() */
 26e:	b003      	add	sp, #12
 270:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        ret = wc_AesSetIV(aes, iv);
 274:	f7ff bffe 	b.w	0 <wc_AesSetKey>
	...
            for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 280:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 284:	4629      	mov	r1, r5
 286:	009c      	lsls	r4, r3, #2
 288:	eb05 1303 	add.w	r3, r5, r3, lsl #4
 28c:	1aa0      	subs	r0, r4, r2
 28e:	4282      	cmp	r2, r0
 290:	f101 0110 	add.w	r1, r1, #16
 294:	f1a3 0310 	sub.w	r3, r3, #16
 298:	f0c0 80bf 	bcc.w	41a <wc_AesSetKey+0x41a>
 29c:	2300      	movs	r3, #0
 29e:	f88d 3004 	strb.w	r3, [sp, #4]
                    GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 2a2:	4a6d      	ldr	r2, [pc, #436]	; (458 <wc_AesSetKey+0x458>)
 2a4:	f88d 3005 	strb.w	r3, [sp, #5]
 2a8:	f88d 3006 	strb.w	r3, [sp, #6]
 2ac:	f88d 3007 	strb.w	r3, [sp, #7]
 2b0:	4b6a      	ldr	r3, [pc, #424]	; (45c <wc_AesSetKey+0x45c>)
            for (i = 1; i < aes->rounds; i++) {
 2b2:	2001      	movs	r0, #1
 2b4:	f8d5 10f0 	ldr.w	r1, [r5, #240]	; 0xf0
 2b8:	4288      	cmp	r0, r1
 2ba:	d2d6      	bcs.n	26a <wc_AesSetKey+0x26a>
                    GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 2bc:	6931      	ldr	r1, [r6, #16]
 2be:	0e0c      	lsrs	r4, r1, #24
 2c0:	f504 7480 	add.w	r4, r4, #256	; 0x100
            for (i = 1; i < aes->rounds; i++) {
 2c4:	3001      	adds	r0, #1
                    GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[0], 3)) & 0xff) ^
 2c6:	f812 e024 	ldrb.w	lr, [r2, r4, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[0], 0)) & 0xff);
 2ca:	b2cc      	uxtb	r4, r1
 2cc:	f504 7480 	add.w	r4, r4, #256	; 0x100
 2d0:	3610      	adds	r6, #16
 2d2:	f812 c024 	ldrb.w	ip, [r2, r4, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 2d6:	f853 402e 	ldr.w	r4, [r3, lr, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[0], 0)) & 0xff);
 2da:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 2de:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 2e2:	ea84 040c 	eor.w	r4, r4, ip
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 2e6:	f3c1 4c07 	ubfx	ip, r1, #16, #8
 2ea:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 2ee:	f3c1 2107 	ubfx	r1, r1, #8, #8
 2f2:	f501 7180 	add.w	r1, r1, #256	; 0x100
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 2f6:	f812 c02c 	ldrb.w	ip, [r2, ip, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 2fa:	f812 1021 	ldrb.w	r1, [r2, r1, lsl #2]
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[0], 2)) & 0xff) ^
 2fe:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[0], 1)) & 0xff) ^
 302:	f501 7100 	add.w	r1, r1, #512	; 0x200
 306:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 30a:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 30e:	ea84 040c 	eor.w	r4, r4, ip
 312:	4061      	eors	r1, r4
                rk[0] =
 314:	6031      	str	r1, [r6, #0]
                    GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[1], 3)) & 0xff) ^
 316:	6871      	ldr	r1, [r6, #4]
 318:	0e0c      	lsrs	r4, r1, #24
 31a:	f504 7480 	add.w	r4, r4, #256	; 0x100
 31e:	f812 e024 	ldrb.w	lr, [r2, r4, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[1], 0)) & 0xff);
 322:	b2cc      	uxtb	r4, r1
 324:	f504 7480 	add.w	r4, r4, #256	; 0x100
 328:	f812 c024 	ldrb.w	ip, [r2, r4, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 32c:	f853 402e 	ldr.w	r4, [r3, lr, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[1], 0)) & 0xff);
 330:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 334:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 338:	ea84 040c 	eor.w	r4, r4, ip
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 33c:	f3c1 4c07 	ubfx	ip, r1, #16, #8
 340:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 344:	f3c1 2107 	ubfx	r1, r1, #8, #8
 348:	f501 7180 	add.w	r1, r1, #256	; 0x100
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 34c:	f812 c02c 	ldrb.w	ip, [r2, ip, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 350:	f812 1021 	ldrb.w	r1, [r2, r1, lsl #2]
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[1], 2)) & 0xff) ^
 354:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[1], 1)) & 0xff) ^
 358:	f501 7100 	add.w	r1, r1, #512	; 0x200
 35c:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 360:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 364:	ea84 040c 	eor.w	r4, r4, ip
 368:	4061      	eors	r1, r4
                rk[1] =
 36a:	6071      	str	r1, [r6, #4]
                    GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[2], 3)) & 0xff) ^
 36c:	68b1      	ldr	r1, [r6, #8]
 36e:	0e0c      	lsrs	r4, r1, #24
 370:	f504 7480 	add.w	r4, r4, #256	; 0x100
 374:	f812 e024 	ldrb.w	lr, [r2, r4, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[2], 0)) & 0xff);
 378:	b2cc      	uxtb	r4, r1
 37a:	f504 7480 	add.w	r4, r4, #256	; 0x100
 37e:	f812 c024 	ldrb.w	ip, [r2, r4, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 382:	f853 402e 	ldr.w	r4, [r3, lr, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[2], 0)) & 0xff);
 386:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 38a:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 38e:	ea84 040c 	eor.w	r4, r4, ip
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 392:	f3c1 4c07 	ubfx	ip, r1, #16, #8
 396:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 39a:	f3c1 2107 	ubfx	r1, r1, #8, #8
 39e:	f501 7180 	add.w	r1, r1, #256	; 0x100
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 3a2:	f812 c02c 	ldrb.w	ip, [r2, ip, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 3a6:	f812 1021 	ldrb.w	r1, [r2, r1, lsl #2]
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[2], 2)) & 0xff) ^
 3aa:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[2], 1)) & 0xff) ^
 3ae:	f501 7100 	add.w	r1, r1, #512	; 0x200
 3b2:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 3b6:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 3ba:	ea84 040c 	eor.w	r4, r4, ip
 3be:	4061      	eors	r1, r4
                rk[2] =
 3c0:	60b1      	str	r1, [r6, #8]
                    GetTable(Td[0], GetTable(Te[1], GETBYTE(rk[3], 3)) & 0xff) ^
 3c2:	68f1      	ldr	r1, [r6, #12]
 3c4:	0e0c      	lsrs	r4, r1, #24
 3c6:	f504 7480 	add.w	r4, r4, #256	; 0x100
 3ca:	f812 e024 	ldrb.w	lr, [r2, r4, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[3], 0)) & 0xff);
 3ce:	b2cc      	uxtb	r4, r1
 3d0:	f504 7480 	add.w	r4, r4, #256	; 0x100
 3d4:	f812 c024 	ldrb.w	ip, [r2, r4, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 3d8:	f853 402e 	ldr.w	r4, [r3, lr, lsl #2]
                    GetTable(Td[3], GetTable(Te[1], GETBYTE(rk[3], 0)) & 0xff);
 3dc:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 3e0:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 3e4:	ea84 040c 	eor.w	r4, r4, ip
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 3e8:	f3c1 4c07 	ubfx	ip, r1, #16, #8
 3ec:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 3f0:	f3c1 2107 	ubfx	r1, r1, #8, #8
 3f4:	f501 7180 	add.w	r1, r1, #256	; 0x100
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 3f8:	f812 c02c 	ldrb.w	ip, [r2, ip, lsl #2]
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 3fc:	f812 1021 	ldrb.w	r1, [r2, r1, lsl #2]
                    GetTable(Td[1], GetTable(Te[1], GETBYTE(rk[3], 2)) & 0xff) ^
 400:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
                    GetTable(Td[2], GetTable(Te[1], GETBYTE(rk[3], 1)) & 0xff) ^
 404:	f501 7100 	add.w	r1, r1, #512	; 0x200
 408:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 40c:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 410:	ea84 040c 	eor.w	r4, r4, ip
 414:	4061      	eors	r1, r4
                rk[3] =
 416:	60f1      	str	r1, [r6, #12]
            for (i = 1; i < aes->rounds; i++) {
 418:	e74c      	b.n	2b4 <wc_AesSetKey+0x2b4>
                temp = rk[i    ]; rk[i    ] = rk[j    ]; rk[j    ] = temp;
 41a:	f851 0c10 	ldr.w	r0, [r1, #-16]
 41e:	691f      	ldr	r7, [r3, #16]
 420:	f841 7c10 	str.w	r7, [r1, #-16]
 424:	6118      	str	r0, [r3, #16]
                temp = rk[i + 1]; rk[i + 1] = rk[j + 1]; rk[j + 1] = temp;
 426:	f851 0c0c 	ldr.w	r0, [r1, #-12]
 42a:	695f      	ldr	r7, [r3, #20]
 42c:	f841 7c0c 	str.w	r7, [r1, #-12]
 430:	6158      	str	r0, [r3, #20]
                temp = rk[i + 2]; rk[i + 2] = rk[j + 2]; rk[j + 2] = temp;
 432:	f851 0c08 	ldr.w	r0, [r1, #-8]
 436:	699f      	ldr	r7, [r3, #24]
 438:	f841 7c08 	str.w	r7, [r1, #-8]
 43c:	6198      	str	r0, [r3, #24]
                temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
 43e:	f851 0c04 	ldr.w	r0, [r1, #-4]
 442:	69df      	ldr	r7, [r3, #28]
 444:	f841 7c04 	str.w	r7, [r1, #-4]
            for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 448:	3204      	adds	r2, #4
                temp = rk[i + 3]; rk[i + 3] = rk[j + 3]; rk[j + 3] = temp;
 44a:	61d8      	str	r0, [r3, #28]
            for (i = 0, j = 4* aes->rounds; i < j; i += 4, j -= 4) {
 44c:	e71e      	b.n	28c <wc_AesSetKey+0x28c>
    } /* wc_AesSetKey() */
 44e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 452:	b003      	add	sp, #12
 454:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

Disassembly of section .text.wc_AesCbcEncrypt:

00000000 <wc_AesCbcEncrypt>:
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460d      	mov	r5, r1
   6:	4616      	mov	r6, r2
        if (aes == NULL || out == NULL || in == NULL) {
   8:	4607      	mov	r7, r0
   a:	b300      	cbz	r0, 4e <wc_AesCbcEncrypt+0x4e>
   c:	b1f9      	cbz	r1, 4e <wc_AesCbcEncrypt+0x4e>
   e:	b1f2      	cbz	r2, 4e <wc_AesCbcEncrypt+0x4e>
        if (sz == 0) {
  10:	b913      	cbnz	r3, 18 <wc_AesCbcEncrypt+0x18>
            return 0;
  12:	2000      	movs	r0, #0
    } /* wc_AesCbcEncrypt */
  14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (blocks--) {
  18:	f023 030f 	bic.w	r3, r3, #15
  1c:	18cc      	adds	r4, r1, r3
            xorbuf((byte*)aes->reg, in, AES_BLOCK_SIZE);
  1e:	f100 08f8 	add.w	r8, r0, #248	; 0xf8
        while (blocks--) {
  22:	42a5      	cmp	r5, r4
  24:	d0f5      	beq.n	12 <wc_AesCbcEncrypt+0x12>
            xorbuf((byte*)aes->reg, in, AES_BLOCK_SIZE);
  26:	2210      	movs	r2, #16
  28:	4631      	mov	r1, r6
  2a:	4640      	mov	r0, r8
  2c:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
            ret = wc_AesEncrypt(aes, (byte*)aes->reg, (byte*)aes->reg);
  30:	4642      	mov	r2, r8
  32:	4641      	mov	r1, r8
  34:	4638      	mov	r0, r7
  36:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
            if (ret != 0)
  3a:	2800      	cmp	r0, #0
  3c:	d1ea      	bne.n	14 <wc_AesCbcEncrypt+0x14>
            XMEMCPY(out, aes->reg, AES_BLOCK_SIZE);
  3e:	4628      	mov	r0, r5
  40:	2210      	movs	r2, #16
  42:	4641      	mov	r1, r8
  44:	f7ff fffe 	bl	0 <memcpy>
            out += AES_BLOCK_SIZE;
  48:	3510      	adds	r5, #16
            in  += AES_BLOCK_SIZE;
  4a:	3610      	adds	r6, #16
  4c:	e7e9      	b.n	22 <wc_AesCbcEncrypt+0x22>
            return BAD_FUNC_ARG;
  4e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  52:	e7df      	b.n	14 <wc_AesCbcEncrypt+0x14>

Disassembly of section .text.wc_AesCbcDecrypt:

00000000 <wc_AesCbcDecrypt>:
    {
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36	; 0x24
   6:	4688      	mov	r8, r1
   8:	9201      	str	r2, [sp, #4]
        if (aes == NULL || out == NULL || in == NULL) {
   a:	4605      	mov	r5, r0
   c:	2800      	cmp	r0, #0
   e:	f000 8724 	beq.w	e5a <wc_AesCbcDecrypt+0xe5a>
  12:	2900      	cmp	r1, #0
  14:	f000 8721 	beq.w	e5a <wc_AesCbcDecrypt+0xe5a>
  18:	2a00      	cmp	r2, #0
  1a:	f000 871e 	beq.w	e5a <wc_AesCbcDecrypt+0xe5a>
        if (sz == 0) {
  1e:	b91b      	cbnz	r3, 28 <wc_AesCbcDecrypt+0x28>
            return 0;
  20:	2000      	movs	r0, #0
    }
  22:	b009      	add	sp, #36	; 0x24
  24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        blocks = sz / AES_BLOCK_SIZE;
  28:	091a      	lsrs	r2, r3, #4
        if (sz % AES_BLOCK_SIZE) {
  2a:	071b      	lsls	r3, r3, #28
  2c:	f040 8715 	bne.w	e5a <wc_AesCbcDecrypt+0xe5a>
  30:	eb01 1302 	add.w	r3, r1, r2, lsl #4
  34:	9303      	str	r3, [sp, #12]
                       DEC_ROUND_T_S( 0);
  36:	4c03      	ldr	r4, [pc, #12]	; (44 <wc_AesCbcDecrypt+0x44>)
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
  38:	4f03      	ldr	r7, [pc, #12]	; (48 <wc_AesCbcDecrypt+0x48>)
            XMEMCPY(aes->tmp, in, AES_BLOCK_SIZE);
  3a:	f500 7384 	add.w	r3, r0, #264	; 0x108
  3e:	9302      	str	r3, [sp, #8]
  40:	e004      	b.n	4c <wc_AesCbcDecrypt+0x4c>
  42:	bf00      	nop
	...
        while (blocks--) {
  4c:	9b03      	ldr	r3, [sp, #12]
  4e:	4598      	cmp	r8, r3
  50:	d0e6      	beq.n	20 <wc_AesCbcDecrypt+0x20>
            XMEMCPY(aes->tmp, in, AES_BLOCK_SIZE);
  52:	e9dd 1001 	ldrd	r1, r0, [sp, #4]
  56:	2210      	movs	r2, #16
  58:	f7ff fffe 	bl	0 <memcpy>
    r = aes->rounds >> 1;
  5c:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
  60:	ea4f 0a53 	mov.w	sl, r3, lsr #1
    if (r > 7 || r == 0) {
  64:	f10a 33ff 	add.w	r3, sl, #4294967295	; 0xffffffff
  68:	2b06      	cmp	r3, #6
  6a:	f200 86f2 	bhi.w	e52 <wc_AesCbcDecrypt+0xe52>
    XMEMCPY(&s0, inBlock,                  sizeof(s0));
  6e:	9902      	ldr	r1, [sp, #8]
  70:	2204      	movs	r2, #4
  72:	a804      	add	r0, sp, #16
  74:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(&s1, inBlock + sizeof(s0),     sizeof(s1));
  78:	2204      	movs	r2, #4
  7a:	f505 7186 	add.w	r1, r5, #268	; 0x10c
  7e:	a805      	add	r0, sp, #20
  80:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(&s2, inBlock + 2 * sizeof(s0), sizeof(s2));
  84:	2204      	movs	r2, #4
  86:	f505 7188 	add.w	r1, r5, #272	; 0x110
  8a:	a806      	add	r0, sp, #24
  8c:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(&s3, inBlock + 3 * sizeof(s0), sizeof(s3));
  90:	2204      	movs	r2, #4
  92:	f505 718a 	add.w	r1, r5, #276	; 0x114
  96:	a807      	add	r0, sp, #28
  98:	f7ff fffe 	bl	0 <memcpy>
    s0 = ByteReverseWord32(s0);
  9c:	9804      	ldr	r0, [sp, #16]
  9e:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
  a2:	4681      	mov	r9, r0
    s1 = ByteReverseWord32(s1);
  a4:	9805      	ldr	r0, [sp, #20]
  a6:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
  aa:	4601      	mov	r1, r0
    s2 = ByteReverseWord32(s2);
  ac:	9806      	ldr	r0, [sp, #24]
  ae:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
  b2:	4602      	mov	r2, r0
    s3 = ByteReverseWord32(s3);
  b4:	9807      	ldr	r0, [sp, #28]
  b6:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
    s0 ^= rk[0];
  ba:	682b      	ldr	r3, [r5, #0]
  bc:	ea89 0903 	eor.w	r9, r9, r3
    s1 ^= rk[1];
  c0:	686b      	ldr	r3, [r5, #4]
  c2:	ea81 0c03 	eor.w	ip, r1, r3
    s2 ^= rk[2];
  c6:	68ab      	ldr	r3, [r5, #8]
  c8:	ea82 0e03 	eor.w	lr, r2, r3
    s3 ^= rk[3];
  cc:	68eb      	ldr	r3, [r5, #12]
  ce:	4058      	eors	r0, r3
                       DEC_ROUND_T_S( 0);
  d0:	fa5f f38c 	uxtb.w	r3, ip
  d4:	ea4f 6219 	mov.w	r2, r9, lsr #24
  d8:	f503 7340 	add.w	r3, r3, #768	; 0x300
  dc:	f854 6022 	ldr.w	r6, [r4, r2, lsl #2]
  e0:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  e4:	405e      	eors	r6, r3
  e6:	692b      	ldr	r3, [r5, #16]
  e8:	405e      	eors	r6, r3
  ea:	f3c0 4307 	ubfx	r3, r0, #16, #8
  ee:	f503 7380 	add.w	r3, r3, #256	; 0x100
  f2:	fa5f f28e 	uxtb.w	r2, lr
  f6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  fa:	405e      	eors	r6, r3
  fc:	f3ce 2307 	ubfx	r3, lr, #8, #8
 100:	f503 7300 	add.w	r3, r3, #512	; 0x200
 104:	f502 7240 	add.w	r2, r2, #768	; 0x300
 108:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 10c:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 110:	405e      	eors	r6, r3
 112:	ea4f 631c 	mov.w	r3, ip, lsr #24
 116:	b2c1      	uxtb	r1, r0
 118:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 11c:	405a      	eors	r2, r3
 11e:	696b      	ldr	r3, [r5, #20]
 120:	405a      	eors	r2, r3
 122:	f3c9 4307 	ubfx	r3, r9, #16, #8
 126:	f503 7380 	add.w	r3, r3, #256	; 0x100
 12a:	f501 7140 	add.w	r1, r1, #768	; 0x300
 12e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 132:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 136:	405a      	eors	r2, r3
 138:	f3c0 2307 	ubfx	r3, r0, #8, #8
 13c:	f503 7300 	add.w	r3, r3, #512	; 0x200
 140:	0e00      	lsrs	r0, r0, #24
 142:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 146:	405a      	eors	r2, r3
 148:	ea4f 631e 	mov.w	r3, lr, lsr #24
 14c:	f3ce 4e07 	ubfx	lr, lr, #16, #8
 150:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 154:	4059      	eors	r1, r3
 156:	69ab      	ldr	r3, [r5, #24]
 158:	4059      	eors	r1, r3
 15a:	f3cc 4307 	ubfx	r3, ip, #16, #8
 15e:	f503 7380 	add.w	r3, r3, #256	; 0x100
 162:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
 166:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 16a:	4059      	eors	r1, r3
 16c:	f3c9 2307 	ubfx	r3, r9, #8, #8
 170:	f503 7300 	add.w	r3, r3, #512	; 0x200
 174:	fa5f f989 	uxtb.w	r9, r9
 178:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 17c:	f509 7940 	add.w	r9, r9, #768	; 0x300
 180:	4059      	eors	r1, r3
 182:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
 186:	f854 0029 	ldr.w	r0, [r4, r9, lsl #2]
 18a:	ea83 0900 	eor.w	r9, r3, r0
 18e:	69eb      	ldr	r3, [r5, #28]
 190:	f3cc 2c07 	ubfx	ip, ip, #8, #8
 194:	ea89 0903 	eor.w	r9, r9, r3
 198:	f50c 7c00 	add.w	ip, ip, #512	; 0x200
 19c:	f854 302e 	ldr.w	r3, [r4, lr, lsl #2]
 1a0:	ea89 0903 	eor.w	r9, r9, r3
 1a4:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
    DEC_ROUND_S_T( 8); DEC_ROUND_T_S( 8);
 1a8:	b2d0      	uxtb	r0, r2
                       DEC_ROUND_T_S( 0);
 1aa:	ea89 0903 	eor.w	r9, r9, r3
    DEC_ROUND_S_T( 8); DEC_ROUND_T_S( 8);
 1ae:	f500 7040 	add.w	r0, r0, #768	; 0x300
 1b2:	0e33      	lsrs	r3, r6, #24
 1b4:	ea4f 6c11 	mov.w	ip, r1, lsr #24
 1b8:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 1bc:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 1c0:	f854 c02c 	ldr.w	ip, [r4, ip, lsl #2]
 1c4:	ea83 0e00 	eor.w	lr, r3, r0
 1c8:	6a2b      	ldr	r3, [r5, #32]
 1ca:	ea8e 0e03 	eor.w	lr, lr, r3
 1ce:	f3c9 4307 	ubfx	r3, r9, #16, #8
 1d2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 1d6:	b2c8      	uxtb	r0, r1
 1d8:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 1dc:	ea8e 0e03 	eor.w	lr, lr, r3
 1e0:	f3c1 2307 	ubfx	r3, r1, #8, #8
 1e4:	f503 7300 	add.w	r3, r3, #512	; 0x200
 1e8:	f500 7040 	add.w	r0, r0, #768	; 0x300
 1ec:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 1f0:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 1f4:	ea8e 0e03 	eor.w	lr, lr, r3
 1f8:	0e13      	lsrs	r3, r2, #24
 1fa:	f3c1 4107 	ubfx	r1, r1, #16, #8
 1fe:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 202:	4058      	eors	r0, r3
 204:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 206:	4058      	eors	r0, r3
 208:	f3c6 4307 	ubfx	r3, r6, #16, #8
 20c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 210:	f501 7180 	add.w	r1, r1, #256	; 0x100
 214:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 218:	4058      	eors	r0, r3
 21a:	f3c9 2307 	ubfx	r3, r9, #8, #8
 21e:	f503 7300 	add.w	r3, r3, #512	; 0x200
    if (r > 5) {
 222:	f1ba 0f05 	cmp.w	sl, #5
    DEC_ROUND_S_T( 8); DEC_ROUND_T_S( 8);
 226:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 22a:	ea80 0003 	eor.w	r0, r0, r3
 22e:	fa5f f389 	uxtb.w	r3, r9
 232:	f503 7340 	add.w	r3, r3, #768	; 0x300
 236:	ea4f 6919 	mov.w	r9, r9, lsr #24
 23a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 23e:	ea8c 0c03 	eor.w	ip, ip, r3
 242:	6aab      	ldr	r3, [r5, #40]	; 0x28
 244:	ea8c 0c03 	eor.w	ip, ip, r3
 248:	f3c2 4307 	ubfx	r3, r2, #16, #8
 24c:	f503 7380 	add.w	r3, r3, #256	; 0x100
 250:	f3c2 2207 	ubfx	r2, r2, #8, #8
 254:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 258:	ea8c 0c03 	eor.w	ip, ip, r3
 25c:	f3c6 2307 	ubfx	r3, r6, #8, #8
 260:	f503 7300 	add.w	r3, r3, #512	; 0x200
 264:	b2f6      	uxtb	r6, r6
 266:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 26a:	f506 7640 	add.w	r6, r6, #768	; 0x300
 26e:	ea8c 0c03 	eor.w	ip, ip, r3
 272:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 276:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
 27a:	ea83 0906 	eor.w	r9, r3, r6
 27e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 280:	f502 7200 	add.w	r2, r2, #512	; 0x200
 284:	ea89 0903 	eor.w	r9, r9, r3
 288:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 28c:	ea89 0903 	eor.w	r9, r9, r3
 290:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 294:	ea89 0903 	eor.w	r9, r9, r3
 298:	b2c3      	uxtb	r3, r0
 29a:	ea4f 621e 	mov.w	r2, lr, lsr #24
 29e:	f503 7340 	add.w	r3, r3, #768	; 0x300
 2a2:	f854 6022 	ldr.w	r6, [r4, r2, lsl #2]
 2a6:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 2aa:	f3c9 4307 	ubfx	r3, r9, #16, #8
 2ae:	ea86 0602 	eor.w	r6, r6, r2
 2b2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 2b6:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 2b8:	ea86 0602 	eor.w	r6, r6, r2
 2bc:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 2c0:	f3cc 2307 	ubfx	r3, ip, #8, #8
 2c4:	f503 7300 	add.w	r3, r3, #512	; 0x200
 2c8:	ea86 0602 	eor.w	r6, r6, r2
 2cc:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 2d0:	fa5f f28c 	uxtb.w	r2, ip
 2d4:	ea86 0603 	eor.w	r6, r6, r3
 2d8:	f502 7240 	add.w	r2, r2, #768	; 0x300
 2dc:	ea4f 6310 	mov.w	r3, r0, lsr #24
 2e0:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 2e4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 2e8:	ea82 0203 	eor.w	r2, r2, r3
 2ec:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 2ee:	ea82 0203 	eor.w	r2, r2, r3
 2f2:	f3ce 4307 	ubfx	r3, lr, #16, #8
 2f6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 2fa:	fa5f f189 	uxtb.w	r1, r9
 2fe:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 302:	ea82 0203 	eor.w	r2, r2, r3
 306:	f3c9 2307 	ubfx	r3, r9, #8, #8
 30a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 30e:	f501 7140 	add.w	r1, r1, #768	; 0x300
 312:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 316:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 31a:	ea82 0203 	eor.w	r2, r2, r3
 31e:	ea4f 631c 	mov.w	r3, ip, lsr #24
 322:	ea4f 6919 	mov.w	r9, r9, lsr #24
 326:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 32a:	ea81 0103 	eor.w	r1, r1, r3
 32e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 330:	ea81 0103 	eor.w	r1, r1, r3
 334:	f3c0 4307 	ubfx	r3, r0, #16, #8
 338:	f503 7380 	add.w	r3, r3, #256	; 0x100
 33c:	f3cc 4c07 	ubfx	ip, ip, #16, #8
 340:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 344:	ea81 0103 	eor.w	r1, r1, r3
 348:	f3ce 2307 	ubfx	r3, lr, #8, #8
 34c:	f503 7300 	add.w	r3, r3, #512	; 0x200
 350:	fa5f fe8e 	uxtb.w	lr, lr
 354:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 358:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 35c:	ea81 0103 	eor.w	r1, r1, r3
 360:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
 364:	f854 902e 	ldr.w	r9, [r4, lr, lsl #2]
 368:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
 36c:	ea83 0909 	eor.w	r9, r3, r9
 370:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 372:	f3c0 2007 	ubfx	r0, r0, #8, #8
 376:	ea89 0903 	eor.w	r9, r9, r3
 37a:	f500 7000 	add.w	r0, r0, #512	; 0x200
 37e:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
 382:	ea89 0903 	eor.w	r9, r9, r3
 386:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
 38a:	ea89 0903 	eor.w	r9, r9, r3
    DEC_ROUND_S_T(16); DEC_ROUND_T_S(16);
 38e:	b2d3      	uxtb	r3, r2
 390:	ea4f 6016 	mov.w	r0, r6, lsr #24
 394:	f503 7340 	add.w	r3, r3, #768	; 0x300
 398:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 39c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 3a0:	ea80 0e03 	eor.w	lr, r0, r3
 3a4:	f3c9 4307 	ubfx	r3, r9, #16, #8
 3a8:	6c28      	ldr	r0, [r5, #64]	; 0x40
 3aa:	f503 7380 	add.w	r3, r3, #256	; 0x100
 3ae:	ea8e 0e00 	eor.w	lr, lr, r0
 3b2:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 3b6:	f3c1 2307 	ubfx	r3, r1, #8, #8
 3ba:	f503 7300 	add.w	r3, r3, #512	; 0x200
 3be:	ea8e 0e00 	eor.w	lr, lr, r0
 3c2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 3c6:	b2c8      	uxtb	r0, r1
 3c8:	ea8e 0e03 	eor.w	lr, lr, r3
 3cc:	f500 7040 	add.w	r0, r0, #768	; 0x300
 3d0:	ea4f 6312 	mov.w	r3, r2, lsr #24
 3d4:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 3d8:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 3dc:	ea80 0003 	eor.w	r0, r0, r3
 3e0:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 3e2:	ea80 0003 	eor.w	r0, r0, r3
 3e6:	f3c6 4307 	ubfx	r3, r6, #16, #8
 3ea:	f503 7380 	add.w	r3, r3, #256	; 0x100
 3ee:	ea4f 6c11 	mov.w	ip, r1, lsr #24
 3f2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 3f6:	f854 c02c 	ldr.w	ip, [r4, ip, lsl #2]
 3fa:	ea80 0003 	eor.w	r0, r0, r3
 3fe:	f3c9 2307 	ubfx	r3, r9, #8, #8
 402:	f503 7300 	add.w	r3, r3, #512	; 0x200
 406:	f3c1 4107 	ubfx	r1, r1, #16, #8
 40a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 40e:	ea80 0003 	eor.w	r0, r0, r3
 412:	fa5f f389 	uxtb.w	r3, r9
 416:	f503 7340 	add.w	r3, r3, #768	; 0x300
 41a:	ea4f 6919 	mov.w	r9, r9, lsr #24
 41e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 422:	ea8c 0c03 	eor.w	ip, ip, r3
 426:	6cab      	ldr	r3, [r5, #72]	; 0x48
 428:	ea8c 0c03 	eor.w	ip, ip, r3
 42c:	f3c2 4307 	ubfx	r3, r2, #16, #8
 430:	f503 7380 	add.w	r3, r3, #256	; 0x100
 434:	f501 7180 	add.w	r1, r1, #256	; 0x100
 438:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 43c:	ea8c 0c03 	eor.w	ip, ip, r3
 440:	f3c6 2307 	ubfx	r3, r6, #8, #8
 444:	f503 7300 	add.w	r3, r3, #512	; 0x200
 448:	b2f6      	uxtb	r6, r6
 44a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 44e:	f506 7640 	add.w	r6, r6, #768	; 0x300
 452:	ea8c 0c03 	eor.w	ip, ip, r3
 456:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 45a:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
 45e:	ea83 0906 	eor.w	r9, r3, r6
 462:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
 464:	f3c2 2207 	ubfx	r2, r2, #8, #8
 468:	ea89 0903 	eor.w	r9, r9, r3
 46c:	f502 7200 	add.w	r2, r2, #512	; 0x200
 470:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 474:	ea89 0903 	eor.w	r9, r9, r3
 478:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 47c:	ea89 0903 	eor.w	r9, r9, r3
 480:	b2c3      	uxtb	r3, r0
 482:	ea4f 621e 	mov.w	r2, lr, lsr #24
 486:	f503 7340 	add.w	r3, r3, #768	; 0x300
 48a:	f854 6022 	ldr.w	r6, [r4, r2, lsl #2]
 48e:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 492:	f3c9 4307 	ubfx	r3, r9, #16, #8
 496:	ea86 0602 	eor.w	r6, r6, r2
 49a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 49e:	6d2a      	ldr	r2, [r5, #80]	; 0x50
 4a0:	ea86 0602 	eor.w	r6, r6, r2
 4a4:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 4a8:	f3cc 2307 	ubfx	r3, ip, #8, #8
 4ac:	f503 7300 	add.w	r3, r3, #512	; 0x200
 4b0:	ea86 0602 	eor.w	r6, r6, r2
 4b4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 4b8:	fa5f f28c 	uxtb.w	r2, ip
 4bc:	ea86 0603 	eor.w	r6, r6, r3
 4c0:	f502 7240 	add.w	r2, r2, #768	; 0x300
 4c4:	ea4f 6310 	mov.w	r3, r0, lsr #24
 4c8:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 4cc:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 4d0:	ea82 0203 	eor.w	r2, r2, r3
 4d4:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 4d6:	ea82 0203 	eor.w	r2, r2, r3
 4da:	f3ce 4307 	ubfx	r3, lr, #16, #8
 4de:	f503 7380 	add.w	r3, r3, #256	; 0x100
 4e2:	fa5f f189 	uxtb.w	r1, r9
 4e6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 4ea:	ea82 0203 	eor.w	r2, r2, r3
 4ee:	f3c9 2307 	ubfx	r3, r9, #8, #8
 4f2:	f503 7300 	add.w	r3, r3, #512	; 0x200
 4f6:	f501 7140 	add.w	r1, r1, #768	; 0x300
 4fa:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 4fe:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 502:	ea82 0203 	eor.w	r2, r2, r3
 506:	ea4f 631c 	mov.w	r3, ip, lsr #24
 50a:	ea4f 6919 	mov.w	r9, r9, lsr #24
 50e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 512:	ea81 0103 	eor.w	r1, r1, r3
 516:	6dab      	ldr	r3, [r5, #88]	; 0x58
 518:	ea81 0103 	eor.w	r1, r1, r3
 51c:	f3c0 4307 	ubfx	r3, r0, #16, #8
 520:	f503 7380 	add.w	r3, r3, #256	; 0x100
 524:	f3cc 4c07 	ubfx	ip, ip, #16, #8
 528:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 52c:	ea81 0103 	eor.w	r1, r1, r3
 530:	f3ce 2307 	ubfx	r3, lr, #8, #8
 534:	f503 7300 	add.w	r3, r3, #512	; 0x200
 538:	fa5f fe8e 	uxtb.w	lr, lr
 53c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 540:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 544:	ea81 0103 	eor.w	r1, r1, r3
 548:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
 54c:	f854 902e 	ldr.w	r9, [r4, lr, lsl #2]
 550:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
 554:	ea83 0909 	eor.w	r9, r3, r9
 558:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 55a:	f3c0 2007 	ubfx	r0, r0, #8, #8
 55e:	ea89 0903 	eor.w	r9, r9, r3
 562:	f500 7000 	add.w	r0, r0, #512	; 0x200
 566:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
 56a:	ea89 0903 	eor.w	r9, r9, r3
 56e:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
 572:	ea89 0903 	eor.w	r9, r9, r3
    DEC_ROUND_S_T(24); DEC_ROUND_T_S(24);
 576:	b2d3      	uxtb	r3, r2
 578:	ea4f 6016 	mov.w	r0, r6, lsr #24
 57c:	f503 7340 	add.w	r3, r3, #768	; 0x300
 580:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 584:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 588:	ea80 0e03 	eor.w	lr, r0, r3
 58c:	f3c9 4307 	ubfx	r3, r9, #16, #8
 590:	6e28      	ldr	r0, [r5, #96]	; 0x60
 592:	f503 7380 	add.w	r3, r3, #256	; 0x100
 596:	ea8e 0e00 	eor.w	lr, lr, r0
 59a:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 59e:	f3c1 2307 	ubfx	r3, r1, #8, #8
 5a2:	f503 7300 	add.w	r3, r3, #512	; 0x200
 5a6:	ea8e 0e00 	eor.w	lr, lr, r0
 5aa:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 5ae:	b2c8      	uxtb	r0, r1
 5b0:	ea8e 0e03 	eor.w	lr, lr, r3
 5b4:	f500 7040 	add.w	r0, r0, #768	; 0x300
 5b8:	ea4f 6312 	mov.w	r3, r2, lsr #24
 5bc:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 5c0:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 5c4:	ea80 0003 	eor.w	r0, r0, r3
 5c8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 5ca:	ea80 0003 	eor.w	r0, r0, r3
 5ce:	f3c6 4307 	ubfx	r3, r6, #16, #8
 5d2:	f503 7380 	add.w	r3, r3, #256	; 0x100
 5d6:	ea4f 6c11 	mov.w	ip, r1, lsr #24
 5da:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 5de:	f854 c02c 	ldr.w	ip, [r4, ip, lsl #2]
 5e2:	ea80 0003 	eor.w	r0, r0, r3
 5e6:	f3c9 2307 	ubfx	r3, r9, #8, #8
 5ea:	f503 7300 	add.w	r3, r3, #512	; 0x200
 5ee:	f3c1 4107 	ubfx	r1, r1, #16, #8
 5f2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 5f6:	ea80 0003 	eor.w	r0, r0, r3
 5fa:	fa5f f389 	uxtb.w	r3, r9
 5fe:	f503 7340 	add.w	r3, r3, #768	; 0x300
 602:	ea4f 6919 	mov.w	r9, r9, lsr #24
 606:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 60a:	ea8c 0c03 	eor.w	ip, ip, r3
 60e:	6eab      	ldr	r3, [r5, #104]	; 0x68
 610:	ea8c 0c03 	eor.w	ip, ip, r3
 614:	f3c2 4307 	ubfx	r3, r2, #16, #8
 618:	f503 7380 	add.w	r3, r3, #256	; 0x100
 61c:	f501 7180 	add.w	r1, r1, #256	; 0x100
 620:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 624:	ea8c 0c03 	eor.w	ip, ip, r3
 628:	f3c6 2307 	ubfx	r3, r6, #8, #8
 62c:	f503 7300 	add.w	r3, r3, #512	; 0x200
 630:	b2f6      	uxtb	r6, r6
 632:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 636:	f506 7640 	add.w	r6, r6, #768	; 0x300
 63a:	ea8c 0c03 	eor.w	ip, ip, r3
 63e:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
 642:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 646:	ea83 0906 	eor.w	r9, r3, r6
 64a:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
 64c:	f3c2 2207 	ubfx	r2, r2, #8, #8
 650:	ea89 0903 	eor.w	r9, r9, r3
 654:	f502 7200 	add.w	r2, r2, #512	; 0x200
 658:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 65c:	ea89 0903 	eor.w	r9, r9, r3
 660:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 664:	ea89 0903 	eor.w	r9, r9, r3
 668:	b2c3      	uxtb	r3, r0
 66a:	ea4f 621e 	mov.w	r2, lr, lsr #24
 66e:	f503 7340 	add.w	r3, r3, #768	; 0x300
 672:	f854 6022 	ldr.w	r6, [r4, r2, lsl #2]
 676:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 67a:	f3c9 4307 	ubfx	r3, r9, #16, #8
 67e:	ea86 0602 	eor.w	r6, r6, r2
 682:	f503 7380 	add.w	r3, r3, #256	; 0x100
 686:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 688:	ea86 0602 	eor.w	r6, r6, r2
 68c:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 690:	f3cc 2307 	ubfx	r3, ip, #8, #8
 694:	f503 7300 	add.w	r3, r3, #512	; 0x200
 698:	ea86 0602 	eor.w	r6, r6, r2
 69c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 6a0:	fa5f f28c 	uxtb.w	r2, ip
 6a4:	ea86 0603 	eor.w	r6, r6, r3
 6a8:	f502 7240 	add.w	r2, r2, #768	; 0x300
 6ac:	ea4f 6310 	mov.w	r3, r0, lsr #24
 6b0:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 6b4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 6b8:	ea82 0203 	eor.w	r2, r2, r3
 6bc:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 6be:	ea82 0203 	eor.w	r2, r2, r3
 6c2:	f3ce 4307 	ubfx	r3, lr, #16, #8
 6c6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 6ca:	fa5f f189 	uxtb.w	r1, r9
 6ce:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 6d2:	ea82 0203 	eor.w	r2, r2, r3
 6d6:	f3c9 2307 	ubfx	r3, r9, #8, #8
 6da:	f503 7300 	add.w	r3, r3, #512	; 0x200
 6de:	f501 7140 	add.w	r1, r1, #768	; 0x300
 6e2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 6e6:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 6ea:	ea82 0203 	eor.w	r2, r2, r3
 6ee:	ea4f 631c 	mov.w	r3, ip, lsr #24
 6f2:	ea4f 6919 	mov.w	r9, r9, lsr #24
 6f6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 6fa:	ea81 0103 	eor.w	r1, r1, r3
 6fe:	6fab      	ldr	r3, [r5, #120]	; 0x78
 700:	ea81 0103 	eor.w	r1, r1, r3
 704:	f3c0 4307 	ubfx	r3, r0, #16, #8
 708:	f503 7380 	add.w	r3, r3, #256	; 0x100
 70c:	f3cc 4c07 	ubfx	ip, ip, #16, #8
 710:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 714:	ea81 0103 	eor.w	r1, r1, r3
 718:	f3ce 2307 	ubfx	r3, lr, #8, #8
 71c:	f503 7300 	add.w	r3, r3, #512	; 0x200
 720:	fa5f fe8e 	uxtb.w	lr, lr
 724:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 728:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 72c:	ea81 0103 	eor.w	r1, r1, r3
 730:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
 734:	f854 902e 	ldr.w	r9, [r4, lr, lsl #2]
 738:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
 73c:	ea83 0909 	eor.w	r9, r3, r9
 740:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 742:	f3c0 2007 	ubfx	r0, r0, #8, #8
 746:	ea89 0903 	eor.w	r9, r9, r3
 74a:	f500 7000 	add.w	r0, r0, #512	; 0x200
 74e:	f854 302c 	ldr.w	r3, [r4, ip, lsl #2]
 752:	ea89 0903 	eor.w	r9, r9, r3
 756:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
 75a:	ea89 0903 	eor.w	r9, r9, r3
    DEC_ROUND_S_T(32); DEC_ROUND_T_S(32);
 75e:	b2d3      	uxtb	r3, r2
 760:	ea4f 6016 	mov.w	r0, r6, lsr #24
 764:	f503 7340 	add.w	r3, r3, #768	; 0x300
 768:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 76c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 770:	ea83 0300 	eor.w	r3, r3, r0
 774:	f8d5 0080 	ldr.w	r0, [r5, #128]	; 0x80
 778:	ea80 0003 	eor.w	r0, r0, r3
 77c:	f3c9 4307 	ubfx	r3, r9, #16, #8
 780:	f503 7380 	add.w	r3, r3, #256	; 0x100
 784:	ea4f 6c12 	mov.w	ip, r2, lsr #24
 788:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 78c:	f854 c02c 	ldr.w	ip, [r4, ip, lsl #2]
 790:	ea80 0003 	eor.w	r0, r0, r3
 794:	f3c1 2307 	ubfx	r3, r1, #8, #8
 798:	f503 7300 	add.w	r3, r3, #512	; 0x200
 79c:	ea4f 6e11 	mov.w	lr, r1, lsr #24
 7a0:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 7a4:	ea80 0003 	eor.w	r0, r0, r3
 7a8:	b2cb      	uxtb	r3, r1
 7aa:	f503 7340 	add.w	r3, r3, #768	; 0x300
 7ae:	f3c1 4107 	ubfx	r1, r1, #16, #8
 7b2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 7b6:	ea8c 0c03 	eor.w	ip, ip, r3
 7ba:	f8d5 3084 	ldr.w	r3, [r5, #132]	; 0x84
 7be:	ea8c 0c03 	eor.w	ip, ip, r3
 7c2:	f3c6 4307 	ubfx	r3, r6, #16, #8
 7c6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 7ca:	f501 7180 	add.w	r1, r1, #256	; 0x100
 7ce:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 7d2:	f854 e02e 	ldr.w	lr, [r4, lr, lsl #2]
 7d6:	ea8c 0c03 	eor.w	ip, ip, r3
 7da:	f3c9 2307 	ubfx	r3, r9, #8, #8
 7de:	f503 7300 	add.w	r3, r3, #512	; 0x200
 7e2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 7e6:	ea8c 0c03 	eor.w	ip, ip, r3
 7ea:	fa5f f389 	uxtb.w	r3, r9
 7ee:	f503 7340 	add.w	r3, r3, #768	; 0x300
 7f2:	ea4f 6919 	mov.w	r9, r9, lsr #24
 7f6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 7fa:	ea8e 0e03 	eor.w	lr, lr, r3
 7fe:	f8d5 3088 	ldr.w	r3, [r5, #136]	; 0x88
 802:	ea8e 0e03 	eor.w	lr, lr, r3
 806:	f3c2 4307 	ubfx	r3, r2, #16, #8
 80a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80e:	f3c2 2207 	ubfx	r2, r2, #8, #8
 812:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 816:	ea8e 0e03 	eor.w	lr, lr, r3
 81a:	f3c6 2307 	ubfx	r3, r6, #8, #8
 81e:	f503 7300 	add.w	r3, r3, #512	; 0x200
 822:	b2f6      	uxtb	r6, r6
 824:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 828:	f506 7640 	add.w	r6, r6, #768	; 0x300
 82c:	ea8e 0e03 	eor.w	lr, lr, r3
 830:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 834:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
 838:	ea86 0603 	eor.w	r6, r6, r3
 83c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
 840:	f502 7200 	add.w	r2, r2, #512	; 0x200
 844:	ea86 0603 	eor.w	r6, r6, r3
 848:	f854 3021 	ldr.w	r3, [r4, r1, lsl #2]
 84c:	ea86 0603 	eor.w	r6, r6, r3
 850:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 854:	ea86 0603 	eor.w	r6, r6, r3
 858:	fa5f f38c 	uxtb.w	r3, ip
 85c:	ea4f 6210 	mov.w	r2, r0, lsr #24
 860:	f503 7340 	add.w	r3, r3, #768	; 0x300
 864:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 868:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 86c:	f3c6 4307 	ubfx	r3, r6, #16, #8
 870:	ea81 0102 	eor.w	r1, r1, r2
 874:	f503 7380 	add.w	r3, r3, #256	; 0x100
 878:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 87c:	ea81 0102 	eor.w	r1, r1, r2
 880:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 884:	f3ce 2307 	ubfx	r3, lr, #8, #8
 888:	f503 7300 	add.w	r3, r3, #512	; 0x200
 88c:	ea81 0102 	eor.w	r1, r1, r2
 890:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 894:	fa5f f28e 	uxtb.w	r2, lr
 898:	ea81 0103 	eor.w	r1, r1, r3
 89c:	f502 7240 	add.w	r2, r2, #768	; 0x300
 8a0:	ea4f 631c 	mov.w	r3, ip, lsr #24
 8a4:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 8a8:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8ac:	ea82 0203 	eor.w	r2, r2, r3
 8b0:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 8b4:	ea82 0203 	eor.w	r2, r2, r3
 8b8:	f3c0 4307 	ubfx	r3, r0, #16, #8
 8bc:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8c0:	ea4f 691e 	mov.w	r9, lr, lsr #24
 8c4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8c8:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 8cc:	ea82 0203 	eor.w	r2, r2, r3
 8d0:	f3c6 2307 	ubfx	r3, r6, #8, #8
 8d4:	f503 7300 	add.w	r3, r3, #512	; 0x200
 8d8:	f3ce 4e07 	ubfx	lr, lr, #16, #8
 8dc:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8e0:	ea82 0203 	eor.w	r2, r2, r3
 8e4:	b2f3      	uxtb	r3, r6
 8e6:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8ea:	ea4f 6616 	mov.w	r6, r6, lsr #24
 8ee:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 8f2:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 8f6:	ea89 0903 	eor.w	r9, r9, r3
 8fa:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 8fe:	ea89 0303 	eor.w	r3, r9, r3
 902:	f3cc 4907 	ubfx	r9, ip, #16, #8
 906:	f509 7980 	add.w	r9, r9, #256	; 0x100
 90a:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
 90e:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 912:	ea83 0309 	eor.w	r3, r3, r9
 916:	f3c0 2907 	ubfx	r9, r0, #8, #8
 91a:	b2c0      	uxtb	r0, r0
 91c:	f500 7040 	add.w	r0, r0, #768	; 0x300
 920:	f3cc 2c07 	ubfx	ip, ip, #8, #8
 924:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 928:	ea86 0600 	eor.w	r6, r6, r0
 92c:	f8d5 009c 	ldr.w	r0, [r5, #156]	; 0x9c
 930:	f509 7900 	add.w	r9, r9, #512	; 0x200
 934:	ea86 0600 	eor.w	r6, r6, r0
 938:	f50c 7c00 	add.w	ip, ip, #512	; 0x200
 93c:	f854 002e 	ldr.w	r0, [r4, lr, lsl #2]
 940:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 944:	ea86 0600 	eor.w	r6, r6, r0
 948:	f854 002c 	ldr.w	r0, [r4, ip, lsl #2]
 94c:	ea83 0309 	eor.w	r3, r3, r9
 950:	ea86 0600 	eor.w	r6, r6, r0
    if (r > 5) {
 954:	f240 81e8 	bls.w	d28 <wc_AesCbcDecrypt+0xd28>
        DEC_ROUND_S_T(40); DEC_ROUND_T_S(40);
 958:	fa5f fc82 	uxtb.w	ip, r2
 95c:	0e08      	lsrs	r0, r1, #24
 95e:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
 962:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 966:	f854 e02c 	ldr.w	lr, [r4, ip, lsl #2]
 96a:	ea80 0e0e 	eor.w	lr, r0, lr
 96e:	f8d5 00a0 	ldr.w	r0, [r5, #160]	; 0xa0
 972:	ea8e 0e00 	eor.w	lr, lr, r0
 976:	f3c6 4007 	ubfx	r0, r6, #16, #8
 97a:	f500 7080 	add.w	r0, r0, #256	; 0x100
 97e:	ea4f 6c12 	mov.w	ip, r2, lsr #24
 982:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 986:	f854 c02c 	ldr.w	ip, [r4, ip, lsl #2]
 98a:	ea8e 0e00 	eor.w	lr, lr, r0
 98e:	f3c3 2007 	ubfx	r0, r3, #8, #8
 992:	f500 7000 	add.w	r0, r0, #512	; 0x200
 996:	ea4f 6913 	mov.w	r9, r3, lsr #24
 99a:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 99e:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 9a2:	ea8e 0e00 	eor.w	lr, lr, r0
 9a6:	b2d8      	uxtb	r0, r3
 9a8:	f500 7040 	add.w	r0, r0, #768	; 0x300
 9ac:	f3c3 4307 	ubfx	r3, r3, #16, #8
 9b0:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 9b4:	ea8c 0c00 	eor.w	ip, ip, r0
 9b8:	f8d5 00a4 	ldr.w	r0, [r5, #164]	; 0xa4
 9bc:	ea8c 0c00 	eor.w	ip, ip, r0
 9c0:	f3c1 4007 	ubfx	r0, r1, #16, #8
 9c4:	f500 7080 	add.w	r0, r0, #256	; 0x100
 9c8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 9cc:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 9d0:	ea8c 0c00 	eor.w	ip, ip, r0
 9d4:	f3c6 2007 	ubfx	r0, r6, #8, #8
 9d8:	f500 7000 	add.w	r0, r0, #512	; 0x200
        if (r > 6) {
 9dc:	f1ba 0f07 	cmp.w	sl, #7
        DEC_ROUND_S_T(40); DEC_ROUND_T_S(40);
 9e0:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 9e4:	ea8c 0c00 	eor.w	ip, ip, r0
 9e8:	b2f0      	uxtb	r0, r6
 9ea:	f500 7040 	add.w	r0, r0, #768	; 0x300
 9ee:	ea4f 6616 	mov.w	r6, r6, lsr #24
 9f2:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 9f6:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 9fa:	ea89 0900 	eor.w	r9, r9, r0
 9fe:	f8d5 00a8 	ldr.w	r0, [r5, #168]	; 0xa8
 a02:	ea89 0000 	eor.w	r0, r9, r0
 a06:	f3c2 4907 	ubfx	r9, r2, #16, #8
 a0a:	f509 7980 	add.w	r9, r9, #256	; 0x100
 a0e:	f3c2 2207 	ubfx	r2, r2, #8, #8
 a12:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 a16:	ea80 0009 	eor.w	r0, r0, r9
 a1a:	f3c1 2907 	ubfx	r9, r1, #8, #8
 a1e:	b2c9      	uxtb	r1, r1
 a20:	f501 7140 	add.w	r1, r1, #768	; 0x300
 a24:	f502 7200 	add.w	r2, r2, #512	; 0x200
 a28:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 a2c:	ea86 0601 	eor.w	r6, r6, r1
 a30:	f8d5 10ac 	ldr.w	r1, [r5, #172]	; 0xac
 a34:	ea86 0601 	eor.w	r6, r6, r1
 a38:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 a3c:	fa5f f38c 	uxtb.w	r3, ip
 a40:	ea86 0601 	eor.w	r6, r6, r1
 a44:	f503 7340 	add.w	r3, r3, #768	; 0x300
 a48:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 a4c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 a50:	ea4f 621e 	mov.w	r2, lr, lsr #24
 a54:	ea86 0601 	eor.w	r6, r6, r1
 a58:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 a5c:	ea81 0103 	eor.w	r1, r1, r3
 a60:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
 a64:	f509 7900 	add.w	r9, r9, #512	; 0x200
 a68:	ea81 0103 	eor.w	r1, r1, r3
 a6c:	f3c6 4307 	ubfx	r3, r6, #16, #8
 a70:	f503 7380 	add.w	r3, r3, #256	; 0x100
 a74:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 a78:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 a7c:	ea80 0009 	eor.w	r0, r0, r9
 a80:	ea81 0103 	eor.w	r1, r1, r3
 a84:	f3c0 2307 	ubfx	r3, r0, #8, #8
 a88:	f503 7300 	add.w	r3, r3, #512	; 0x200
 a8c:	b2c2      	uxtb	r2, r0
 a8e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 a92:	f502 7240 	add.w	r2, r2, #768	; 0x300
 a96:	ea81 0103 	eor.w	r1, r1, r3
 a9a:	ea4f 631c 	mov.w	r3, ip, lsr #24
 a9e:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 aa2:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 aa6:	ea82 0203 	eor.w	r2, r2, r3
 aaa:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
 aae:	ea82 0203 	eor.w	r2, r2, r3
 ab2:	f3ce 4307 	ubfx	r3, lr, #16, #8
 ab6:	f503 7380 	add.w	r3, r3, #256	; 0x100
 aba:	ea4f 6910 	mov.w	r9, r0, lsr #24
 abe:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 ac2:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 ac6:	ea82 0203 	eor.w	r2, r2, r3
 aca:	f3c6 2307 	ubfx	r3, r6, #8, #8
 ace:	f503 7300 	add.w	r3, r3, #512	; 0x200
 ad2:	f3c0 4007 	ubfx	r0, r0, #16, #8
 ad6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 ada:	ea82 0203 	eor.w	r2, r2, r3
 ade:	b2f3      	uxtb	r3, r6
 ae0:	f503 7340 	add.w	r3, r3, #768	; 0x300
 ae4:	ea4f 6616 	mov.w	r6, r6, lsr #24
 ae8:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 aec:	ea89 0903 	eor.w	r9, r9, r3
 af0:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
 af4:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 af8:	ea89 0303 	eor.w	r3, r9, r3
 afc:	f3cc 4907 	ubfx	r9, ip, #16, #8
 b00:	f509 7980 	add.w	r9, r9, #256	; 0x100
 b04:	f500 7080 	add.w	r0, r0, #256	; 0x100
 b08:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 b0c:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 b10:	ea83 0309 	eor.w	r3, r3, r9
 b14:	f3ce 2907 	ubfx	r9, lr, #8, #8
 b18:	fa5f fe8e 	uxtb.w	lr, lr
 b1c:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 b20:	f3cc 2c07 	ubfx	ip, ip, #8, #8
 b24:	f854 e02e 	ldr.w	lr, [r4, lr, lsl #2]
 b28:	ea86 0e0e 	eor.w	lr, r6, lr
 b2c:	f8d5 60bc 	ldr.w	r6, [r5, #188]	; 0xbc
 b30:	f509 7900 	add.w	r9, r9, #512	; 0x200
 b34:	f50c 7c00 	add.w	ip, ip, #512	; 0x200
 b38:	ea8e 0606 	eor.w	r6, lr, r6
 b3c:	ea86 0600 	eor.w	r6, r6, r0
 b40:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 b44:	f854 002c 	ldr.w	r0, [r4, ip, lsl #2]
 b48:	ea83 0309 	eor.w	r3, r3, r9
 b4c:	ea86 0600 	eor.w	r6, r6, r0
        if (r > 6) {
 b50:	f040 80ea 	bne.w	d28 <wc_AesCbcDecrypt+0xd28>
            DEC_ROUND_S_T(48); DEC_ROUND_T_S(48);
 b54:	fa5f fc82 	uxtb.w	ip, r2
 b58:	0e08      	lsrs	r0, r1, #24
 b5a:	f50c 7c40 	add.w	ip, ip, #768	; 0x300
 b5e:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 b62:	f854 e02c 	ldr.w	lr, [r4, ip, lsl #2]
 b66:	ea80 0e0e 	eor.w	lr, r0, lr
 b6a:	f8d5 00c0 	ldr.w	r0, [r5, #192]	; 0xc0
 b6e:	ea8e 0e00 	eor.w	lr, lr, r0
 b72:	f3c6 4007 	ubfx	r0, r6, #16, #8
 b76:	f500 7080 	add.w	r0, r0, #256	; 0x100
 b7a:	ea4f 6c12 	mov.w	ip, r2, lsr #24
 b7e:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 b82:	f854 c02c 	ldr.w	ip, [r4, ip, lsl #2]
 b86:	ea8e 0e00 	eor.w	lr, lr, r0
 b8a:	f3c3 2007 	ubfx	r0, r3, #8, #8
 b8e:	f500 7000 	add.w	r0, r0, #512	; 0x200
 b92:	ea4f 6913 	mov.w	r9, r3, lsr #24
 b96:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 b9a:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 b9e:	ea8e 0e00 	eor.w	lr, lr, r0
 ba2:	b2d8      	uxtb	r0, r3
 ba4:	f500 7040 	add.w	r0, r0, #768	; 0x300
 ba8:	f3c3 4307 	ubfx	r3, r3, #16, #8
 bac:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 bb0:	ea8c 0c00 	eor.w	ip, ip, r0
 bb4:	f8d5 00c4 	ldr.w	r0, [r5, #196]	; 0xc4
 bb8:	ea8c 0c00 	eor.w	ip, ip, r0
 bbc:	f3c1 4007 	ubfx	r0, r1, #16, #8
 bc0:	f500 7080 	add.w	r0, r0, #256	; 0x100
 bc4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 bc8:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 bcc:	ea8c 0c00 	eor.w	ip, ip, r0
 bd0:	f3c6 2007 	ubfx	r0, r6, #8, #8
 bd4:	f500 7000 	add.w	r0, r0, #512	; 0x200
 bd8:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 bdc:	ea8c 0c00 	eor.w	ip, ip, r0
 be0:	b2f0      	uxtb	r0, r6
 be2:	f500 7040 	add.w	r0, r0, #768	; 0x300
 be6:	0e36      	lsrs	r6, r6, #24
 be8:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 bec:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 bf0:	ea89 0900 	eor.w	r9, r9, r0
 bf4:	f8d5 00c8 	ldr.w	r0, [r5, #200]	; 0xc8
 bf8:	ea89 0000 	eor.w	r0, r9, r0
 bfc:	f3c2 4907 	ubfx	r9, r2, #16, #8
 c00:	f509 7980 	add.w	r9, r9, #256	; 0x100
 c04:	f3c2 2207 	ubfx	r2, r2, #8, #8
 c08:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 c0c:	ea80 0009 	eor.w	r0, r0, r9
 c10:	f3c1 2907 	ubfx	r9, r1, #8, #8
 c14:	b2c9      	uxtb	r1, r1
 c16:	f501 7140 	add.w	r1, r1, #768	; 0x300
 c1a:	f502 7200 	add.w	r2, r2, #512	; 0x200
 c1e:	f854 1021 	ldr.w	r1, [r4, r1, lsl #2]
 c22:	404e      	eors	r6, r1
 c24:	f8d5 10cc 	ldr.w	r1, [r5, #204]	; 0xcc
 c28:	404e      	eors	r6, r1
 c2a:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 c2e:	fa5f f38c 	uxtb.w	r3, ip
 c32:	404e      	eors	r6, r1
 c34:	f503 7340 	add.w	r3, r3, #768	; 0x300
 c38:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 c3c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 c40:	ea4f 621e 	mov.w	r2, lr, lsr #24
 c44:	404e      	eors	r6, r1
 c46:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 c4a:	4059      	eors	r1, r3
 c4c:	f8d5 30d0 	ldr.w	r3, [r5, #208]	; 0xd0
 c50:	f509 7900 	add.w	r9, r9, #512	; 0x200
 c54:	4059      	eors	r1, r3
 c56:	f3c6 4307 	ubfx	r3, r6, #16, #8
 c5a:	f503 7380 	add.w	r3, r3, #256	; 0x100
 c5e:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 c62:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 c66:	ea80 0009 	eor.w	r0, r0, r9
 c6a:	4059      	eors	r1, r3
 c6c:	f3c0 2307 	ubfx	r3, r0, #8, #8
 c70:	f503 7300 	add.w	r3, r3, #512	; 0x200
 c74:	b2c2      	uxtb	r2, r0
 c76:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 c7a:	f502 7240 	add.w	r2, r2, #768	; 0x300
 c7e:	4059      	eors	r1, r3
 c80:	ea4f 631c 	mov.w	r3, ip, lsr #24
 c84:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 c88:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 c8c:	405a      	eors	r2, r3
 c8e:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
 c92:	405a      	eors	r2, r3
 c94:	f3ce 4307 	ubfx	r3, lr, #16, #8
 c98:	f503 7380 	add.w	r3, r3, #256	; 0x100
 c9c:	ea4f 6910 	mov.w	r9, r0, lsr #24
 ca0:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 ca4:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 ca8:	405a      	eors	r2, r3
 caa:	f3c6 2307 	ubfx	r3, r6, #8, #8
 cae:	f503 7300 	add.w	r3, r3, #512	; 0x200
 cb2:	f3c0 4007 	ubfx	r0, r0, #16, #8
 cb6:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 cba:	405a      	eors	r2, r3
 cbc:	b2f3      	uxtb	r3, r6
 cbe:	f503 7340 	add.w	r3, r3, #768	; 0x300
 cc2:	0e36      	lsrs	r6, r6, #24
 cc4:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 cc8:	ea89 0903 	eor.w	r9, r9, r3
 ccc:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
 cd0:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 cd4:	ea89 0303 	eor.w	r3, r9, r3
 cd8:	f3cc 4907 	ubfx	r9, ip, #16, #8
 cdc:	f509 7980 	add.w	r9, r9, #256	; 0x100
 ce0:	f500 7080 	add.w	r0, r0, #256	; 0x100
 ce4:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 ce8:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 cec:	ea83 0309 	eor.w	r3, r3, r9
 cf0:	f3ce 2907 	ubfx	r9, lr, #8, #8
 cf4:	fa5f fe8e 	uxtb.w	lr, lr
 cf8:	f50e 7e40 	add.w	lr, lr, #768	; 0x300
 cfc:	f3cc 2c07 	ubfx	ip, ip, #8, #8
 d00:	f854 e02e 	ldr.w	lr, [r4, lr, lsl #2]
 d04:	ea86 0e0e 	eor.w	lr, r6, lr
 d08:	f8d5 60dc 	ldr.w	r6, [r5, #220]	; 0xdc
 d0c:	f509 7900 	add.w	r9, r9, #512	; 0x200
 d10:	f50c 7c00 	add.w	ip, ip, #512	; 0x200
 d14:	ea8e 0606 	eor.w	r6, lr, r6
 d18:	4046      	eors	r6, r0
 d1a:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
 d1e:	f854 002c 	ldr.w	r0, [r4, ip, lsl #2]
 d22:	ea83 0309 	eor.w	r3, r3, r9
 d26:	4046      	eors	r6, r0
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 d28:	0e10      	lsrs	r0, r2, #24
    rk += r * 8;
 d2a:	eb05 1e4a 	add.w	lr, r5, sl, lsl #5
 d2e:	ea4f 1c4a 	mov.w	ip, sl, lsl #5
    s1 = GetTable8_4(Td4, GETBYTE(t1, 3), GETBYTE(t0, 2),
 d32:	f817 a000 	ldrb.w	sl, [r7, r0]
 d36:	b2d8      	uxtb	r0, r3
 d38:	f3c1 4907 	ubfx	r9, r1, #16, #8
 d3c:	5c38      	ldrb	r0, [r7, r0]
 d3e:	ea40 600a 	orr.w	r0, r0, sl, lsl #24
 d42:	f817 a009 	ldrb.w	sl, [r7, r9]
 d46:	f3c6 2907 	ubfx	r9, r6, #8, #8
 d4a:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
 d4e:	f817 a009 	ldrb.w	sl, [r7, r9]
 d52:	ea40 2a0a 	orr.w	sl, r0, sl, lsl #8
                          GETBYTE(t3, 1), GETBYTE(t2, 0)) ^ rk[1];
 d56:	f8de 0004 	ldr.w	r0, [lr, #4]
 d5a:	ea8a 0a00 	eor.w	sl, sl, r0
    s2 = GetTable8_4(Td4, GETBYTE(t2, 3), GETBYTE(t1, 2),
 d5e:	0e18      	lsrs	r0, r3, #24
 d60:	f3c2 4907 	ubfx	r9, r2, #16, #8
 d64:	f817 b000 	ldrb.w	fp, [r7, r0]
 d68:	b2f0      	uxtb	r0, r6
 d6a:	5c38      	ldrb	r0, [r7, r0]
 d6c:	ea40 600b 	orr.w	r0, r0, fp, lsl #24
 d70:	f817 b009 	ldrb.w	fp, [r7, r9]
 d74:	f3c1 2907 	ubfx	r9, r1, #8, #8
 d78:	ea40 400b 	orr.w	r0, r0, fp, lsl #16
 d7c:	f817 b009 	ldrb.w	fp, [r7, r9]
 d80:	ea40 2b0b 	orr.w	fp, r0, fp, lsl #8
                          GETBYTE(t0, 1), GETBYTE(t3, 0)) ^ rk[2];
 d84:	f8de 0008 	ldr.w	r0, [lr, #8]
 d88:	ea8b 0b00 	eor.w	fp, fp, r0
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 d8c:	0e30      	lsrs	r0, r6, #24
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 d8e:	f3c6 4607 	ubfx	r6, r6, #16, #8
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 d92:	f817 9000 	ldrb.w	r9, [r7, r0]
 d96:	b2c8      	uxtb	r0, r1
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 d98:	0e09      	lsrs	r1, r1, #24
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 d9a:	5c38      	ldrb	r0, [r7, r0]
 d9c:	ea40 6009 	orr.w	r0, r0, r9, lsl #24
 da0:	f3c3 4907 	ubfx	r9, r3, #16, #8
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 da4:	f3c3 2307 	ubfx	r3, r3, #8, #8
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 da8:	f817 9009 	ldrb.w	r9, [r7, r9]
 dac:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 db0:	f3c2 2907 	ubfx	r9, r2, #8, #8
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 db4:	b2d2      	uxtb	r2, r2
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 db6:	f817 9009 	ldrb.w	r9, [r7, r9]
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 dba:	5cba      	ldrb	r2, [r7, r2]
    s3 = GetTable8_4(Td4, GETBYTE(t3, 3), GETBYTE(t2, 2),
 dbc:	ea40 2909 	orr.w	r9, r0, r9, lsl #8
                          GETBYTE(t1, 1), GETBYTE(t0, 0)) ^ rk[3];
 dc0:	f8de 000c 	ldr.w	r0, [lr, #12]
 dc4:	ea89 0900 	eor.w	r9, r9, r0
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 dc8:	5c78      	ldrb	r0, [r7, r1]
 dca:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 dce:	5dba      	ldrb	r2, [r7, r6]
 dd0:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 dd4:	5cfa      	ldrb	r2, [r7, r3]
                          GETBYTE(t2, 1), GETBYTE(t1, 0)) ^ rk[0];
 dd6:	f855 300c 	ldr.w	r3, [r5, ip]
    s0 = GetTable8_4(Td4, GETBYTE(t0, 3), GETBYTE(t3, 2),
 dda:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
    s0 = ByteReverseWord32(s0);
 dde:	4058      	eors	r0, r3
 de0:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
 de4:	9004      	str	r0, [sp, #16]
    s1 = ByteReverseWord32(s1);
 de6:	4650      	mov	r0, sl
 de8:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
 dec:	9005      	str	r0, [sp, #20]
    s2 = ByteReverseWord32(s2);
 dee:	4658      	mov	r0, fp
 df0:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
 df4:	9006      	str	r0, [sp, #24]
    s3 = ByteReverseWord32(s3);
 df6:	4648      	mov	r0, r9
 df8:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 dfc:	2204      	movs	r2, #4
    s3 = ByteReverseWord32(s3);
 dfe:	9007      	str	r0, [sp, #28]
    XMEMCPY(outBlock,                  &s0, sizeof(s0));
 e00:	a904      	add	r1, sp, #16
 e02:	4640      	mov	r0, r8
 e04:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(outBlock + sizeof(s0),     &s1, sizeof(s1));
 e08:	2204      	movs	r2, #4
 e0a:	eb08 0002 	add.w	r0, r8, r2
 e0e:	a905      	add	r1, sp, #20
 e10:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(outBlock + 2 * sizeof(s0), &s2, sizeof(s2));
 e14:	2204      	movs	r2, #4
 e16:	a906      	add	r1, sp, #24
 e18:	f108 0008 	add.w	r0, r8, #8
 e1c:	f7ff fffe 	bl	0 <memcpy>
            xorbuf(out, (byte*)aes->reg, AES_BLOCK_SIZE);
 e20:	f105 06f8 	add.w	r6, r5, #248	; 0xf8
    XMEMCPY(outBlock + 3 * sizeof(s0), &s3, sizeof(s3));
 e24:	2204      	movs	r2, #4
 e26:	a907      	add	r1, sp, #28
 e28:	f108 000c 	add.w	r0, r8, #12
 e2c:	f7ff fffe 	bl	0 <memcpy>
            xorbuf(out, (byte*)aes->reg, AES_BLOCK_SIZE);
 e30:	4640      	mov	r0, r8
 e32:	2210      	movs	r2, #16
 e34:	4631      	mov	r1, r6
 e36:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
            XMEMCPY(aes->reg, aes->tmp, AES_BLOCK_SIZE);
 e3a:	9902      	ldr	r1, [sp, #8]
 e3c:	2210      	movs	r2, #16
 e3e:	4630      	mov	r0, r6
 e40:	f7ff fffe 	bl	0 <memcpy>
            in  += AES_BLOCK_SIZE;
 e44:	9b01      	ldr	r3, [sp, #4]
 e46:	3310      	adds	r3, #16
            out += AES_BLOCK_SIZE;
 e48:	f108 0810 	add.w	r8, r8, #16
            in  += AES_BLOCK_SIZE;
 e4c:	9301      	str	r3, [sp, #4]
 e4e:	f7ff b8fd 	b.w	4c <wc_AesCbcDecrypt+0x4c>
        return KEYUSAGE_E;
 e52:	f06f 00e1 	mvn.w	r0, #225	; 0xe1
 e56:	f7ff b8e4 	b.w	22 <wc_AesCbcDecrypt+0x22>
            return BAD_FUNC_ARG;
 e5a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 e5e:	f7ff b8e0 	b.w	22 <wc_AesCbcDecrypt+0x22>
 e62:	bf00      	nop

Disassembly of section .text.wc_AesGcmSetKey:

00000000 <wc_AesGcmSetKey>:
{
   0:	b570      	push	{r4, r5, r6, lr}
    if (!((len == 16) || (len == 24) || (len == 32)))
   2:	f022 0308 	bic.w	r3, r2, #8
   6:	2b10      	cmp	r3, #16
{
   8:	b086      	sub	sp, #24
   a:	4604      	mov	r4, r0
   c:	460e      	mov	r6, r1
   e:	4615      	mov	r5, r2
    if (!((len == 16) || (len == 24) || (len == 32)))
  10:	d001      	beq.n	16 <wc_AesGcmSetKey+0x16>
  12:	2a20      	cmp	r2, #32
  14:	d116      	bne.n	44 <wc_AesGcmSetKey+0x44>
    if (aes == NULL) {
  16:	b1ac      	cbz	r4, 44 <wc_AesGcmSetKey+0x44>
    XMEMSET(iv, 0, AES_BLOCK_SIZE);
  18:	2210      	movs	r2, #16
  1a:	2100      	movs	r1, #0
  1c:	a802      	add	r0, sp, #8
  1e:	f7ff fffe 	bl	0 <memset>
    ret = wc_AesSetKey(aes, key, len, iv, AES_ENCRYPTION);
  22:	2300      	movs	r3, #0
  24:	9300      	str	r3, [sp, #0]
  26:	462a      	mov	r2, r5
  28:	ab02      	add	r3, sp, #8
  2a:	4631      	mov	r1, r6
  2c:	4620      	mov	r0, r4
  2e:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
    if (ret == 0)
  32:	b928      	cbnz	r0, 40 <wc_AesGcmSetKey+0x40>
        ret = wc_AesEncrypt(aes, iv, aes->gcm.H);
  34:	f504 7292 	add.w	r2, r4, #292	; 0x124
  38:	a902      	add	r1, sp, #8
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <wc_AesGcmSetKey>
}
  40:	b006      	add	sp, #24
  42:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  44:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  48:	e7fa      	b.n	40 <wc_AesGcmSetKey+0x40>

Disassembly of section .text.GHASH:

00000000 <GHASH>:


void GHASH(Gcm* gcm, const byte* a, word32 aSz, const byte* c,
    word32 cSz, byte* s, word32 sSz)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	b088      	sub	sp, #32
   6:	460f      	mov	r7, r1
   8:	9d10      	ldr	r5, [sp, #64]	; 0x40
   a:	4614      	mov	r4, r2
   c:	461e      	mov	r6, r3
    byte x[AES_BLOCK_SIZE];
    byte scratch[AES_BLOCK_SIZE];
    word32 blocks, partial;
    byte* h;

    if (gcm == NULL) {
   e:	4680      	mov	r8, r0
  10:	2800      	cmp	r0, #0
  12:	f000 8087 	beq.w	124 <GHASH+0x124>
        return;
    }

    h = gcm->H;
    XMEMSET(x, 0, AES_BLOCK_SIZE);
  16:	2210      	movs	r2, #16
  18:	2100      	movs	r1, #0
  1a:	4668      	mov	r0, sp
  1c:	f7ff fffe 	bl	0 <memset>

    /* Hash in A, the Additional Authentication Data */
    if (aSz != 0 && a != NULL) {
  20:	b1fc      	cbz	r4, 62 <GHASH+0x62>
  22:	b1f7      	cbz	r7, 62 <GHASH+0x62>
        blocks = aSz / AES_BLOCK_SIZE;
        partial = aSz % AES_BLOCK_SIZE;
  24:	f024 090f 	bic.w	r9, r4, #15
  28:	f004 0a0f 	and.w	sl, r4, #15
        while (blocks--) {
  2c:	44b9      	add	r9, r7
  2e:	454f      	cmp	r7, r9
  30:	d17b      	bne.n	12a <GHASH+0x12a>
            xorbuf(x, a, AES_BLOCK_SIZE);
            GMULT(x, h);
            a += AES_BLOCK_SIZE;
        }
        if (partial != 0) {
  32:	f1ba 0f00 	cmp.w	sl, #0
  36:	d014      	beq.n	62 <GHASH+0x62>
            XMEMSET(scratch, 0, AES_BLOCK_SIZE);
  38:	2210      	movs	r2, #16
  3a:	2100      	movs	r1, #0
  3c:	eb0d 0002 	add.w	r0, sp, r2
  40:	f7ff fffe 	bl	0 <memset>
            XMEMCPY(scratch, a, partial);
  44:	4652      	mov	r2, sl
  46:	4639      	mov	r1, r7
  48:	a804      	add	r0, sp, #16
  4a:	f7ff fffe 	bl	0 <memcpy>
            xorbuf(x, scratch, AES_BLOCK_SIZE);
  4e:	2210      	movs	r2, #16
  50:	eb0d 0102 	add.w	r1, sp, r2
  54:	4668      	mov	r0, sp
  56:	f7ff fffe 	bl	0 <GHASH>
            GMULT(x, h);
  5a:	4641      	mov	r1, r8
  5c:	4668      	mov	r0, sp
  5e:	f7ff fffe 	bl	0 <GHASH>
        }
    }

    /* Hash in C, the Ciphertext */
    if (cSz != 0 && c != NULL) {
  62:	b1fd      	cbz	r5, a4 <GHASH+0xa4>
  64:	b1f6      	cbz	r6, a4 <GHASH+0xa4>
        blocks = cSz / AES_BLOCK_SIZE;
        partial = cSz % AES_BLOCK_SIZE;
  66:	f025 070f 	bic.w	r7, r5, #15
  6a:	f005 090f 	and.w	r9, r5, #15
        while (blocks--) {
  6e:	4437      	add	r7, r6
  70:	42be      	cmp	r6, r7
  72:	d165      	bne.n	140 <GHASH+0x140>
            xorbuf(x, c, AES_BLOCK_SIZE);
            GMULT(x, h);
            c += AES_BLOCK_SIZE;
        }
        if (partial != 0) {
  74:	f1b9 0f00 	cmp.w	r9, #0
  78:	d014      	beq.n	a4 <GHASH+0xa4>
            XMEMSET(scratch, 0, AES_BLOCK_SIZE);
  7a:	2210      	movs	r2, #16
  7c:	2100      	movs	r1, #0
  7e:	eb0d 0002 	add.w	r0, sp, r2
  82:	f7ff fffe 	bl	0 <memset>
            XMEMCPY(scratch, c, partial);
  86:	464a      	mov	r2, r9
  88:	4631      	mov	r1, r6
  8a:	a804      	add	r0, sp, #16
  8c:	f7ff fffe 	bl	0 <memcpy>
            xorbuf(x, scratch, AES_BLOCK_SIZE);
  90:	2210      	movs	r2, #16
  92:	eb0d 0102 	add.w	r1, sp, r2
  96:	4668      	mov	r0, sp
  98:	f7ff fffe 	bl	0 <GHASH>
            GMULT(x, h);
  9c:	4641      	mov	r1, r8
  9e:	4668      	mov	r0, sp
  a0:	f7ff fffe 	bl	0 <GHASH>
    buf[0] = (byte)(szHi >> 24);
  a4:	2300      	movs	r3, #0
    sz <<= 3;
  a6:	00e2      	lsls	r2, r4, #3
    word32 szHi = (sz >> (8*sizeof(sz) - 3));
  a8:	0f61      	lsrs	r1, r4, #29
    buf[0] = (byte)(szHi >> 24);
  aa:	f88d 3010 	strb.w	r3, [sp, #16]
    buf[1] = (byte)(szHi >> 16);
  ae:	f88d 3011 	strb.w	r3, [sp, #17]
    buf[2] = (byte)(szHi >>  8);
  b2:	f88d 3012 	strb.w	r3, [sp, #18]
    buf[0] = (byte)(szHi >> 24);
  b6:	f88d 3018 	strb.w	r3, [sp, #24]
    buf[1] = (byte)(szHi >> 16);
  ba:	f88d 3019 	strb.w	r3, [sp, #25]
    buf[2] = (byte)(szHi >>  8);
  be:	f88d 301a 	strb.w	r3, [sp, #26]
    word32 szHi = (sz >> (8*sizeof(sz) - 3));
  c2:	0f6b      	lsrs	r3, r5, #29
    buf[3] = (byte)szHi;
  c4:	f88d 1013 	strb.w	r1, [sp, #19]
    buf[7] = (byte)sz;
  c8:	f88d 2017 	strb.w	r2, [sp, #23]
    buf[4] = (byte)(sz >> 24);
  cc:	f3c4 5147 	ubfx	r1, r4, #21, #8
    sz <<= 3;
  d0:	00ea      	lsls	r2, r5, #3
    buf[3] = (byte)szHi;
  d2:	f88d 301b 	strb.w	r3, [sp, #27]
    buf[4] = (byte)(sz >> 24);
  d6:	f3c5 5347 	ubfx	r3, r5, #21, #8
  da:	f88d 1014 	strb.w	r1, [sp, #20]
  de:	f88d 301c 	strb.w	r3, [sp, #28]
    buf[5] = (byte)(sz >> 16);
  e2:	f3c4 314f 	ubfx	r1, r4, #13, #16
  e6:	f3c5 334f 	ubfx	r3, r5, #13, #16
    buf[7] = (byte)sz;
  ea:	f88d 201f 	strb.w	r2, [sp, #31]
    }

    /* Hash in the lengths of A and C in bits */
    FlattenSzInBits(&scratch[0], aSz);
    FlattenSzInBits(&scratch[8], cSz);
    xorbuf(x, scratch, AES_BLOCK_SIZE);
  ee:	2210      	movs	r2, #16
    buf[5] = (byte)(sz >> 16);
  f0:	f88d 1015 	strb.w	r1, [sp, #21]
  f4:	f88d 301d 	strb.w	r3, [sp, #29]
    xorbuf(x, scratch, AES_BLOCK_SIZE);
  f8:	eb0d 0102 	add.w	r1, sp, r2
    buf[6] = (byte)(sz >>  8);
  fc:	f3c5 1357 	ubfx	r3, r5, #5, #24
    xorbuf(x, scratch, AES_BLOCK_SIZE);
 100:	4668      	mov	r0, sp
    buf[6] = (byte)(sz >>  8);
 102:	f3c4 1457 	ubfx	r4, r4, #5, #24
 106:	f88d 301e 	strb.w	r3, [sp, #30]
 10a:	f88d 4016 	strb.w	r4, [sp, #22]
    xorbuf(x, scratch, AES_BLOCK_SIZE);
 10e:	f7ff fffe 	bl	0 <GHASH>
    GMULT(x, h);
 112:	4641      	mov	r1, r8
 114:	4668      	mov	r0, sp
 116:	f7ff fffe 	bl	0 <GHASH>

    /* Copy the result into s. */
    XMEMCPY(s, x, sSz);
 11a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 11c:	9811      	ldr	r0, [sp, #68]	; 0x44
 11e:	4669      	mov	r1, sp
 120:	f7ff fffe 	bl	0 <memcpy>
}
 124:	b008      	add	sp, #32
 126:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            xorbuf(x, a, AES_BLOCK_SIZE);
 12a:	4639      	mov	r1, r7
 12c:	2210      	movs	r2, #16
 12e:	4668      	mov	r0, sp
 130:	f7ff fffe 	bl	0 <GHASH>
            GMULT(x, h);
 134:	4641      	mov	r1, r8
 136:	4668      	mov	r0, sp
 138:	f7ff fffe 	bl	0 <GHASH>
            a += AES_BLOCK_SIZE;
 13c:	3710      	adds	r7, #16
 13e:	e776      	b.n	2e <GHASH+0x2e>
            xorbuf(x, c, AES_BLOCK_SIZE);
 140:	4631      	mov	r1, r6
 142:	2210      	movs	r2, #16
 144:	4668      	mov	r0, sp
 146:	f7ff fffe 	bl	0 <GHASH>
            GMULT(x, h);
 14a:	4641      	mov	r1, r8
 14c:	4668      	mov	r0, sp
 14e:	f7ff fffe 	bl	0 <GHASH>
            c += AES_BLOCK_SIZE;
 152:	3610      	adds	r6, #16
 154:	e78c      	b.n	70 <GHASH+0x70>

Disassembly of section .text.wc_AesGcmEncrypt:

00000000 <wc_AesGcmEncrypt>:
/* Software AES - GCM Encrypt */
int wc_AesGcmEncrypt(Aes* aes, byte* out, const byte* in, word32 sz,
                   const byte* iv, word32 ivSz,
                   byte* authTag, word32 authTagSz,
                   const byte* authIn, word32 authInSz)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b093      	sub	sp, #76	; 0x4c
   6:	4690      	mov	r8, r2
   8:	461f      	mov	r7, r3
   a:	f8dd b078 	ldr.w	fp, [sp, #120]	; 0x78
   e:	e9dd 321c 	ldrd	r3, r2, [sp, #112]	; 0x70
  12:	4689      	mov	r9, r1
    /* argument checks */
    if (aes == NULL || authTagSz > AES_BLOCK_SIZE || ivSz == 0) {
  14:	4605      	mov	r5, r0
  16:	2800      	cmp	r0, #0
  18:	d077      	beq.n	10a <wc_AesGcmEncrypt+0x10a>
  1a:	2a00      	cmp	r2, #0
  1c:	d075      	beq.n	10a <wc_AesGcmEncrypt+0x10a>
        return BAD_FUNC_ARG;
    }

    if (authTagSz < WOLFSSL_MIN_AUTH_TAG_SZ) {
  1e:	991f      	ldr	r1, [sp, #124]	; 0x7c
  20:	390c      	subs	r1, #12
  22:	2904      	cmp	r1, #4
  24:	d871      	bhi.n	10a <wc_AesGcmEncrypt+0x10a>
    if (ivSz == GCM_NONCE_MID_SZ) {
  26:	2a0c      	cmp	r2, #12
    word32 blocks = sz / AES_BLOCK_SIZE;
  28:	ea4f 1417 	mov.w	r4, r7, lsr #4
    if (ivSz == GCM_NONCE_MID_SZ) {
  2c:	ae06      	add	r6, sp, #24
  2e:	d149      	bne.n	c4 <wc_AesGcmEncrypt+0xc4>
        XMEMCPY(counter, iv, ivSz);
  30:	4619      	mov	r1, r3
  32:	4630      	mov	r0, r6
  34:	f7ff fffe 	bl	0 <memcpy>
        XMEMSET(counter + GCM_NONCE_MID_SZ, 0,
  38:	2203      	movs	r2, #3
  3a:	2100      	movs	r1, #0
  3c:	a809      	add	r0, sp, #36	; 0x24
  3e:	f7ff fffe 	bl	0 <memset>
        counter[AES_BLOCK_SIZE - 1] = 1;
  42:	2301      	movs	r3, #1
  44:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    XMEMCPY(initialCounter, counter, AES_BLOCK_SIZE);
  48:	2210      	movs	r2, #16
  4a:	4631      	mov	r1, r6
  4c:	a80a      	add	r0, sp, #40	; 0x28
  4e:	f7ff fffe 	bl	0 <memcpy>
        while (blocks--) {
  52:	eb09 1304 	add.w	r3, r9, r4, lsl #4
  56:	9305      	str	r3, [sp, #20]
    byte* c = out;
  58:	46ca      	mov	sl, r9
        while (blocks--) {
  5a:	9b05      	ldr	r3, [sp, #20]
  5c:	459a      	cmp	sl, r3
  5e:	d13c      	bne.n	da <wc_AesGcmEncrypt+0xda>
    if (partial != 0) {
  60:	f017 030f 	ands.w	r3, r7, #15
  64:	d010      	beq.n	88 <wc_AesGcmEncrypt+0x88>
        IncrementGcmCounter(counter);
  66:	4630      	mov	r0, r6
  68:	9305      	str	r3, [sp, #20]
        ret = wc_AesEncrypt(aes, counter, scratch);
  6a:	4631      	mov	r1, r6
        IncrementGcmCounter(counter);
  6c:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        ret = wc_AesEncrypt(aes, counter, scratch);
  70:	aa0e      	add	r2, sp, #56	; 0x38
  72:	4628      	mov	r0, r5
  74:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        if (ret != 0)
  78:	4604      	mov	r4, r0
  7a:	b9f8      	cbnz	r0, bc <wc_AesGcmEncrypt+0xbc>
        xorbufout(c, scratch, p, partial);
  7c:	9b05      	ldr	r3, [sp, #20]
  7e:	4642      	mov	r2, r8
  80:	a90e      	add	r1, sp, #56	; 0x38
  82:	4650      	mov	r0, sl
  84:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
    if (authTag) {
  88:	f1bb 0f00 	cmp.w	fp, #0
  8c:	d03b      	beq.n	106 <wc_AesGcmEncrypt+0x106>
        GHASH(&aes->gcm, authIn, authInSz, out, sz, authTag, authTagSz);
  8e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  90:	9700      	str	r7, [sp, #0]
  92:	e9dd 1220 	ldrd	r1, r2, [sp, #128]	; 0x80
  96:	e9cd b301 	strd	fp, r3, [sp, #4]
  9a:	f505 7092 	add.w	r0, r5, #292	; 0x124
  9e:	464b      	mov	r3, r9
  a0:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        ret = wc_AesEncrypt(aes, initialCounter, scratch);
  a4:	aa0e      	add	r2, sp, #56	; 0x38
  a6:	a90a      	add	r1, sp, #40	; 0x28
  a8:	4628      	mov	r0, r5
  aa:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
        if (ret != 0)
  ae:	4604      	mov	r4, r0
  b0:	b920      	cbnz	r0, bc <wc_AesGcmEncrypt+0xbc>
        xorbuf(authTag, scratch, authTagSz);
  b2:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
  b4:	a90e      	add	r1, sp, #56	; 0x38
  b6:	4658      	mov	r0, fp
  b8:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
#endif
    {
        return AES_GCM_encrypt_C(aes, out, in, sz, iv, ivSz, authTag, authTagSz,
                                                              authIn, authInSz);
    }
}
  bc:	4620      	mov	r0, r4
  be:	b013      	add	sp, #76	; 0x4c
  c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        GHASH(&aes->gcm, NULL, 0, iv, ivSz, counter, AES_BLOCK_SIZE);
  c4:	2110      	movs	r1, #16
  c6:	9200      	str	r2, [sp, #0]
  c8:	2200      	movs	r2, #0
  ca:	e9cd 6101 	strd	r6, r1, [sp, #4]
  ce:	f500 7092 	add.w	r0, r0, #292	; 0x124
  d2:	4611      	mov	r1, r2
  d4:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
  d8:	e7b6      	b.n	48 <wc_AesGcmEncrypt+0x48>
            IncrementGcmCounter(counter);
  da:	4630      	mov	r0, r6
  dc:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
            ret = wc_AesEncrypt(aes, counter, scratch);
  e0:	4631      	mov	r1, r6
  e2:	aa0e      	add	r2, sp, #56	; 0x38
  e4:	4628      	mov	r0, r5
  e6:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
            if (ret != 0)
  ea:	4604      	mov	r4, r0
  ec:	2800      	cmp	r0, #0
  ee:	d1e5      	bne.n	bc <wc_AesGcmEncrypt+0xbc>
            xorbufout(c, scratch, p, AES_BLOCK_SIZE);
  f0:	4642      	mov	r2, r8
  f2:	4650      	mov	r0, sl
  f4:	2310      	movs	r3, #16
  f6:	a90e      	add	r1, sp, #56	; 0x38
  f8:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt>
            p += AES_BLOCK_SIZE;
  fc:	f108 0810 	add.w	r8, r8, #16
            c += AES_BLOCK_SIZE;
 100:	f10a 0a10 	add.w	sl, sl, #16
 104:	e7a9      	b.n	5a <wc_AesGcmEncrypt+0x5a>
 106:	465c      	mov	r4, fp
        return AES_GCM_encrypt_C(aes, out, in, sz, iv, ivSz, authTag, authTagSz,
 108:	e7d8      	b.n	bc <wc_AesGcmEncrypt+0xbc>
        return BAD_FUNC_ARG;
 10a:	f06f 04ac 	mvn.w	r4, #172	; 0xac
 10e:	e7d5      	b.n	bc <wc_AesGcmEncrypt+0xbc>

Disassembly of section .text.wc_AesGcmDecrypt:

00000000 <wc_AesGcmDecrypt>:
/* Software AES - GCM Decrypt */
int wc_AesGcmDecrypt(Aes* aes, byte* out, const byte* in, word32 sz,
                     const byte* iv, word32 ivSz,
                     const byte* authTag, word32 authTagSz,
                     const byte* authIn, word32 authInSz)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b095      	sub	sp, #84	; 0x54
   6:	4616      	mov	r6, r2
   8:	461c      	mov	r4, r3
   a:	460d      	mov	r5, r1
   c:	e9dd 321e 	ldrd	r3, r2, [sp, #120]	; 0x78
#endif

    /* argument checks */
    /* If the sz is non-zero, both in and out must be set. If sz is 0,
     * in and out are don't cares, as this is is the GMAC case. */
    if (aes == NULL || iv == NULL || (sz != 0 && (in == NULL || out == NULL)) ||
  10:	4680      	mov	r8, r0
  12:	2800      	cmp	r0, #0
  14:	f000 808b 	beq.w	12e <wc_AesGcmDecrypt+0x12e>
  18:	2b00      	cmp	r3, #0
  1a:	f000 8088 	beq.w	12e <wc_AesGcmDecrypt+0x12e>
  1e:	b12c      	cbz	r4, 2c <wc_AesGcmDecrypt+0x2c>
  20:	2e00      	cmp	r6, #0
  22:	f000 8084 	beq.w	12e <wc_AesGcmDecrypt+0x12e>
  26:	2900      	cmp	r1, #0
  28:	f000 8081 	beq.w	12e <wc_AesGcmDecrypt+0x12e>
  2c:	9920      	ldr	r1, [sp, #128]	; 0x80
  2e:	2900      	cmp	r1, #0
  30:	d07d      	beq.n	12e <wc_AesGcmDecrypt+0x12e>
        authTag == NULL || authTagSz > AES_BLOCK_SIZE || authTagSz == 0 ||
  32:	9921      	ldr	r1, [sp, #132]	; 0x84
  34:	3901      	subs	r1, #1
  36:	290f      	cmp	r1, #15
  38:	d879      	bhi.n	12e <wc_AesGcmDecrypt+0x12e>
  3a:	2a00      	cmp	r2, #0
  3c:	d077      	beq.n	12e <wc_AesGcmDecrypt+0x12e>
    if (ivSz == GCM_NONCE_MID_SZ) {
  3e:	2a0c      	cmp	r2, #12
        GHASH(&aes->gcm, NULL, 0, iv, ivSz, counter, AES_BLOCK_SIZE);
  40:	f508 7792 	add.w	r7, r8, #292	; 0x124
  44:	f10d 0910 	add.w	r9, sp, #16
    if (ivSz == GCM_NONCE_MID_SZ) {
  48:	d154      	bne.n	f4 <wc_AesGcmDecrypt+0xf4>
        XMEMCPY(counter, iv, ivSz);
  4a:	4619      	mov	r1, r3
  4c:	4648      	mov	r0, r9
  4e:	f7ff fffe 	bl	0 <memcpy>
        XMEMSET(counter + GCM_NONCE_MID_SZ, 0,
  52:	2203      	movs	r2, #3
  54:	2100      	movs	r1, #0
  56:	a807      	add	r0, sp, #28
  58:	f7ff fffe 	bl	0 <memset>
        counter[AES_BLOCK_SIZE - 1] = 1;
  5c:	2301      	movs	r3, #1
  5e:	f88d 301f 	strb.w	r3, [sp, #31]
    GHASH(&aes->gcm, authIn, authInSz, in, sz, Tprime, sizeof(Tprime));
  62:	f04f 0b10 	mov.w	fp, #16
  66:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
  6a:	e9dd 1222 	ldrd	r1, r2, [sp, #136]	; 0x88
  6e:	4638      	mov	r0, r7
  70:	4633      	mov	r3, r6
  72:	e9cd 4a00 	strd	r4, sl, [sp]
  76:	f8cd b008 	str.w	fp, [sp, #8]
  7a:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
    ret = wc_AesEncrypt(aes, counter, EKY0);
  7e:	aa10      	add	r2, sp, #64	; 0x40
  80:	4649      	mov	r1, r9
  82:	4640      	mov	r0, r8
  84:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
    if (ret != 0)
  88:	4607      	mov	r7, r0
  8a:	bb80      	cbnz	r0, ee <wc_AesGcmDecrypt+0xee>
    xorbuf(Tprime, EKY0, sizeof(Tprime));
  8c:	465a      	mov	r2, fp
  8e:	a910      	add	r1, sp, #64	; 0x40
  90:	4650      	mov	r0, sl
  92:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        while (blocks--) {
  96:	f024 0b0f 	bic.w	fp, r4, #15
  9a:	44ab      	add	fp, r5
  9c:	455d      	cmp	r5, fp
  9e:	d133      	bne.n	108 <wc_AesGcmDecrypt+0x108>
    if (partial != 0) {
  a0:	f014 040f 	ands.w	r4, r4, #15
  a4:	d012      	beq.n	cc <wc_AesGcmDecrypt+0xcc>
        IncrementGcmCounter(counter);
  a6:	4648      	mov	r0, r9
  a8:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        ret = wc_AesEncrypt(aes, counter, scratch);
  ac:	4649      	mov	r1, r9
  ae:	aa08      	add	r2, sp, #32
  b0:	4640      	mov	r0, r8
  b2:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        if (ret != 0)
  b6:	b9d0      	cbnz	r0, ee <wc_AesGcmDecrypt+0xee>
        xorbuf(scratch, c, partial);
  b8:	4622      	mov	r2, r4
  ba:	4631      	mov	r1, r6
  bc:	a808      	add	r0, sp, #32
  be:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
        XMEMCPY(p, scratch, partial);
  c2:	4622      	mov	r2, r4
  c4:	a908      	add	r1, sp, #32
  c6:	4628      	mov	r0, r5
  c8:	f7ff fffe 	bl	0 <memcpy>
                                             int length)
{
    int i;
    int compareSum = 0;

    for (i = 0; i < length; i++) {
  cc:	e9dd 3220 	ldrd	r3, r2, [sp, #128]	; 0x80
  d0:	189a      	adds	r2, r3, r2
        compareSum |= a[i] ^ b[i];
  d2:	f813 1b01 	ldrb.w	r1, [r3], #1
  d6:	f81a 0b01 	ldrb.w	r0, [sl], #1
    for (i = 0; i < length; i++) {
  da:	429a      	cmp	r2, r3
        compareSum |= a[i] ^ b[i];
  dc:	ea81 0100 	eor.w	r1, r1, r0
  e0:	ea47 0701 	orr.w	r7, r7, r1
    for (i = 0; i < length; i++) {
  e4:	d1f5      	bne.n	d2 <wc_AesGcmDecrypt+0xd2>
    res = 0 - (sword32)(((word32)(0 - res)) >> 31U);
  e6:	4278      	negs	r0, r7
  e8:	17c0      	asrs	r0, r0, #31
    ret = (ret & ~res) | (res & AES_GCM_AUTH_E);
  ea:	f020 00b3 	bic.w	r0, r0, #179	; 0xb3
#endif
    {
        return AES_GCM_decrypt_C(aes, out, in, sz, iv, ivSz, authTag, authTagSz,
                                                              authIn, authInSz);
    }
}
  ee:	b015      	add	sp, #84	; 0x54
  f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        GHASH(&aes->gcm, NULL, 0, iv, ivSz, counter, AES_BLOCK_SIZE);
  f4:	2110      	movs	r1, #16
  f6:	9200      	str	r2, [sp, #0]
  f8:	2200      	movs	r2, #0
  fa:	e9cd 9101 	strd	r9, r1, [sp, #4]
  fe:	4638      	mov	r0, r7
 100:	4611      	mov	r1, r2
 102:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
 106:	e7ac      	b.n	62 <wc_AesGcmDecrypt+0x62>
            IncrementGcmCounter(counter);
 108:	4648      	mov	r0, r9
 10a:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
            ret = wc_AesEncrypt(aes, counter, scratch);
 10e:	4649      	mov	r1, r9
 110:	aa08      	add	r2, sp, #32
 112:	4640      	mov	r0, r8
 114:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
            if (ret != 0)
 118:	2800      	cmp	r0, #0
 11a:	d1e8      	bne.n	ee <wc_AesGcmDecrypt+0xee>
            xorbufout(p, scratch, c, AES_BLOCK_SIZE);
 11c:	4632      	mov	r2, r6
 11e:	4628      	mov	r0, r5
 120:	2310      	movs	r3, #16
 122:	a908      	add	r1, sp, #32
 124:	f7ff fffe 	bl	0 <wc_AesGcmDecrypt>
            p += AES_BLOCK_SIZE;
 128:	3510      	adds	r5, #16
            c += AES_BLOCK_SIZE;
 12a:	3610      	adds	r6, #16
 12c:	e7b6      	b.n	9c <wc_AesGcmDecrypt+0x9c>
        return BAD_FUNC_ARG;
 12e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 132:	e7dc      	b.n	ee <wc_AesGcmDecrypt+0xee>

Disassembly of section .text.wc_AesGcmSetExtIV:

00000000 <wc_AesGcmSetExtIV>:
            ivSz == GCM_NONCE_MAX_SZ);
}


int wc_AesGcmSetExtIV(Aes* aes, const byte* iv, word32 ivSz)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4615      	mov	r5, r2
    int ret = 0;

    if (aes == NULL || iv == NULL || !CheckAesGcmIvSize((int)ivSz)) {
   4:	4604      	mov	r4, r0
   6:	b1b0      	cbz	r0, 36 <wc_AesGcmSetExtIV+0x36>
   8:	b1a9      	cbz	r1, 36 <wc_AesGcmSetExtIV+0x36>
            ivSz == GCM_NONCE_MID_SZ ||
   a:	f022 0304 	bic.w	r3, r2, #4
   e:	2b08      	cmp	r3, #8
  10:	d001      	beq.n	16 <wc_AesGcmSetExtIV+0x16>
  12:	2a10      	cmp	r2, #16
  14:	d10f      	bne.n	36 <wc_AesGcmSetExtIV+0x36>
        ret = BAD_FUNC_ARG;
    }

    if (ret == 0) {
        XMEMCPY((byte*)aes->reg, iv, ivSz);
  16:	462a      	mov	r2, r5
  18:	f104 00f8 	add.w	r0, r4, #248	; 0xf8
  1c:	f7ff fffe 	bl	0 <memcpy>

        /* If the IV is 96, allow for a 2^64 invocation counter.
         * For any other size for the nonce, limit the invocation
         * counter to 32-bits. (SP 800-38D 8.3) */
        aes->invokeCtr[0] = 0;
        aes->invokeCtr[1] = (ivSz == GCM_NONCE_MID_SZ) ? 0 : 0xFFFFFFFF;
  20:	f1b5 030c 	subs.w	r3, r5, #12
  24:	bf18      	it	ne
  26:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
    #ifdef WOLFSSL_AESGCM_STREAM
        aes->ctrSet = 1;
    #endif
        aes->nonceSz = ivSz;
  2a:	e9c4 3547 	strd	r3, r5, [r4, #284]	; 0x11c
        aes->invokeCtr[0] = 0;
  2e:	2000      	movs	r0, #0
  30:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
    }

    return ret;
}
  34:	bd38      	pop	{r3, r4, r5, pc}
        ret = BAD_FUNC_ARG;
  36:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    return ret;
  3a:	e7fb      	b.n	34 <wc_AesGcmSetExtIV+0x34>

Disassembly of section .text.wc_AesGcmSetIV:

00000000 <wc_AesGcmSetIV>:


int wc_AesGcmSetIV(Aes* aes, word32 ivSz,
                   const byte* ivFixed, word32 ivFixedSz,
                   WC_RNG* rng)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	9f06      	ldr	r7, [sp, #24]
   6:	460e      	mov	r6, r1
   8:	461c      	mov	r4, r3
   a:	4611      	mov	r1, r2
    int ret = 0;

    if (aes == NULL || rng == NULL || !CheckAesGcmIvSize((int)ivSz) ||
   c:	4605      	mov	r5, r0
   e:	b140      	cbz	r0, 22 <wc_AesGcmSetIV+0x22>
  10:	b13f      	cbz	r7, 22 <wc_AesGcmSetIV+0x22>
            ivSz == GCM_NONCE_MID_SZ ||
  12:	f026 0304 	bic.w	r3, r6, #4
  16:	2b08      	cmp	r3, #8
  18:	d001      	beq.n	1e <wc_AesGcmSetIV+0x1e>
  1a:	2e10      	cmp	r6, #16
  1c:	d101      	bne.n	22 <wc_AesGcmSetIV+0x22>
    if (aes == NULL || rng == NULL || !CheckAesGcmIvSize((int)ivSz) ||
  1e:	b919      	cbnz	r1, 28 <wc_AesGcmSetIV+0x28>
        (ivFixed == NULL && ivFixedSz != 0) ||
  20:	b124      	cbz	r4, 2c <wc_AesGcmSetIV+0x2c>
        (ivFixed != NULL && ivFixedSz != AES_IV_FIXED_SZ)) {

        ret = BAD_FUNC_ARG;
  22:	f06f 00ac 	mvn.w	r0, #172	; 0xac
        aes->ctrSet = 1;
    #endif
        aes->nonceSz = ivSz;
    }

    return ret;
  26:	e018      	b.n	5a <wc_AesGcmSetIV+0x5a>
        (ivFixed != NULL && ivFixedSz != AES_IV_FIXED_SZ)) {
  28:	2c04      	cmp	r4, #4
  2a:	d1fa      	bne.n	22 <wc_AesGcmSetIV+0x22>
        byte* iv = (byte*)aes->reg;
  2c:	f105 08f8 	add.w	r8, r5, #248	; 0xf8
        if (ivFixedSz)
  30:	b11c      	cbz	r4, 3a <wc_AesGcmSetIV+0x3a>
            XMEMCPY(iv, ivFixed, ivFixedSz);
  32:	4622      	mov	r2, r4
  34:	4640      	mov	r0, r8
  36:	f7ff fffe 	bl	0 <memcpy>
        ret = wc_RNG_GenerateBlock(rng, iv + ivFixedSz, ivSz - ivFixedSz);
  3a:	1b32      	subs	r2, r6, r4
  3c:	eb08 0104 	add.w	r1, r8, r4
  40:	4638      	mov	r0, r7
  42:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
    if (ret == 0) {
  46:	b940      	cbnz	r0, 5a <wc_AesGcmSetIV+0x5a>
        aes->invokeCtr[1] = (ivSz == GCM_NONCE_MID_SZ) ? 0 : 0xFFFFFFFF;
  48:	f1b6 030c 	subs.w	r3, r6, #12
  4c:	bf18      	it	ne
  4e:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
        aes->nonceSz = ivSz;
  52:	e9c5 3647 	strd	r3, r6, [r5, #284]	; 0x11c
        aes->invokeCtr[0] = 0;
  56:	f8c5 0118 	str.w	r0, [r5, #280]	; 0x118
}
  5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.wc_AesGcmEncrypt_ex:

00000000 <wc_AesGcmEncrypt_ex>:

int wc_AesGcmEncrypt_ex(Aes* aes, byte* out, const byte* in, word32 sz,
                        byte* ivOut, word32 ivOutSz,
                        byte* authTag, word32 authTagSz,
                        const byte* authIn, word32 authInSz)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4604      	mov	r4, r0
   6:	b087      	sub	sp, #28
   8:	e9dd 0510 	ldrd	r0, r5, [sp, #64]	; 0x40
   c:	e9dd 9a14 	ldrd	r9, sl, [sp, #80]	; 0x50
  10:	460f      	mov	r7, r1
  12:	4690      	mov	r8, r2
  14:	469b      	mov	fp, r3
    int ret = 0;

    if (aes == NULL || (sz != 0 && (in == NULL || out == NULL)) ||
  16:	2c00      	cmp	r4, #0
  18:	d047      	beq.n	aa <wc_AesGcmEncrypt_ex+0xaa>
  1a:	b11b      	cbz	r3, 24 <wc_AesGcmEncrypt_ex+0x24>
  1c:	2a00      	cmp	r2, #0
  1e:	d044      	beq.n	aa <wc_AesGcmEncrypt_ex+0xaa>
  20:	2900      	cmp	r1, #0
  22:	d042      	beq.n	aa <wc_AesGcmEncrypt_ex+0xaa>
  24:	2800      	cmp	r0, #0
  26:	d040      	beq.n	aa <wc_AesGcmEncrypt_ex+0xaa>
        ivOut == NULL || ivOutSz != aes->nonceSz ||
  28:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
  2c:	42ab      	cmp	r3, r5
  2e:	d13c      	bne.n	aa <wc_AesGcmEncrypt_ex+0xaa>
  30:	f1b9 0f00 	cmp.w	r9, #0
  34:	d102      	bne.n	3c <wc_AesGcmEncrypt_ex+0x3c>
        (authIn == NULL && authInSz != 0)) {
  36:	f1ba 0f00 	cmp.w	sl, #0
  3a:	d136      	bne.n	aa <wc_AesGcmEncrypt_ex+0xaa>

        ret = BAD_FUNC_ARG;
    }

    if (ret == 0) {
        aes->invokeCtr[0]++;
  3c:	f8d4 3118 	ldr.w	r3, [r4, #280]	; 0x118
  40:	3301      	adds	r3, #1
  42:	f8c4 3118 	str.w	r3, [r4, #280]	; 0x118
        if (aes->invokeCtr[0] == 0) {
  46:	b33b      	cbz	r3, 98 <wc_AesGcmEncrypt_ex+0x98>
                ret = AES_GCM_OVERFLOW_E;
        }
    }

    if (ret == 0) {
        XMEMCPY(ivOut, aes->reg, ivOutSz);
  48:	f104 06f8 	add.w	r6, r4, #248	; 0xf8
  4c:	462a      	mov	r2, r5
  4e:	4631      	mov	r1, r6
  50:	f7ff fffe 	bl	0 <memcpy>
        ret = wc_AesGcmEncrypt(aes, out, in, sz,
  54:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  56:	9303      	str	r3, [sp, #12]
  58:	9b12      	ldr	r3, [sp, #72]	; 0x48
  5a:	9600      	str	r6, [sp, #0]
  5c:	e9cd 5301 	strd	r5, r3, [sp, #4]
  60:	e9cd 9a04 	strd	r9, sl, [sp, #16]
  64:	465b      	mov	r3, fp
  66:	4642      	mov	r2, r8
  68:	4639      	mov	r1, r7
  6a:	4620      	mov	r0, r4
  6c:	f7ff fffe 	bl	0 <wc_AesGcmEncrypt_ex>
                               (byte*)aes->reg, ivOutSz,
                               authTag, authTagSz,
                               authIn, authInSz);
        if (ret == 0)
  70:	b978      	cbnz	r0, 92 <wc_AesGcmEncrypt_ex+0x92>
    for (i = (int)ctrSz - 1; i >= 0; i--) {
  72:	35f8      	adds	r5, #248	; 0xf8
  74:	4425      	add	r5, r4
  76:	f1c4 24ff 	rsb	r4, r4, #4278255360	; 0xff00ff00
  7a:	f504 047f 	add.w	r4, r4, #16711680	; 0xff0000
  7e:	3407      	adds	r4, #7
  80:	42ec      	cmn	r4, r5
  82:	d406      	bmi.n	92 <wc_AesGcmEncrypt_ex+0x92>
        if (++ctr[i])
  84:	f815 3d01 	ldrb.w	r3, [r5, #-1]!
  88:	3301      	adds	r3, #1
  8a:	b2db      	uxtb	r3, r3
  8c:	702b      	strb	r3, [r5, #0]
  8e:	2b00      	cmp	r3, #0
  90:	d0f6      	beq.n	80 <wc_AesGcmEncrypt_ex+0x80>
            IncCtr((byte*)aes->reg, ivOutSz);
    }

    return ret;
}
  92:	b007      	add	sp, #28
  94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            aes->invokeCtr[1]++;
  98:	f8d4 611c 	ldr.w	r6, [r4, #284]	; 0x11c
  9c:	3601      	adds	r6, #1
  9e:	f8c4 611c 	str.w	r6, [r4, #284]	; 0x11c
            if (aes->invokeCtr[1] == 0)
  a2:	2e00      	cmp	r6, #0
  a4:	d1d0      	bne.n	48 <wc_AesGcmEncrypt_ex+0x48>
                ret = AES_GCM_OVERFLOW_E;
  a6:	4802      	ldr	r0, [pc, #8]	; (b0 <wc_AesGcmEncrypt_ex+0xb0>)
    return ret;
  a8:	e7f3      	b.n	92 <wc_AesGcmEncrypt_ex+0x92>
        ret = BAD_FUNC_ARG;
  aa:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  ae:	e7f0      	b.n	92 <wc_AesGcmEncrypt_ex+0x92>
  b0:	fffffefc 	.word	0xfffffefc

Disassembly of section .text.wc_Gmac:

00000000 <wc_Gmac>:

int wc_Gmac(const byte* key, word32 keySz, byte* iv, word32 ivSz,
            const byte* authIn, word32 authInSz,
            byte* authTag, word32 authTagSz, WC_RNG* rng)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b087      	sub	sp, #28
   6:	e9dd 9a10 	ldrd	r9, sl, [sp, #64]	; 0x40
   a:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
   e:	4688      	mov	r8, r1
  10:	4615      	mov	r5, r2
  12:	461e      	mov	r6, r3
#else
    Aes aes[1];
#endif
    int ret;

    if (key == NULL || iv == NULL || (authIn == NULL && authInSz != 0) ||
  14:	4607      	mov	r7, r0
  16:	2800      	cmp	r0, #0
  18:	d048      	beq.n	ac <wc_Gmac+0xac>
  1a:	2a00      	cmp	r2, #0
  1c:	d046      	beq.n	ac <wc_Gmac+0xac>
  1e:	f1b9 0f00 	cmp.w	r9, #0
  22:	d102      	bne.n	2a <wc_Gmac+0x2a>
  24:	f1ba 0f00 	cmp.w	sl, #0
  28:	d140      	bne.n	ac <wc_Gmac+0xac>
  2a:	9b12      	ldr	r3, [sp, #72]	; 0x48
  2c:	2b00      	cmp	r3, #0
  2e:	d03d      	beq.n	ac <wc_Gmac+0xac>
        authTag == NULL || authTagSz == 0 || rng == NULL) {
  30:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  32:	2b00      	cmp	r3, #0
  34:	d03a      	beq.n	ac <wc_Gmac+0xac>
  36:	f1bb 0f00 	cmp.w	fp, #0
  3a:	d037      	beq.n	ac <wc_Gmac+0xac>

        return BAD_FUNC_ARG;
    }

#ifdef WOLFSSL_SMALL_STACK
    if ((aes = (Aes *)XMALLOC(sizeof *aes, NULL,
  3c:	f44f 709c 	mov.w	r0, #312	; 0x138
  40:	f7ff fffe 	bl	0 <malloc>
  44:	4604      	mov	r4, r0
  46:	b3a0      	cbz	r0, b2 <wc_Gmac+0xb2>
    int ret = 0;

    if (aes == NULL)
        return BAD_FUNC_ARG;

    aes->heap = heap;
  48:	2200      	movs	r2, #0
  4a:	f8c0 2134 	str.w	r2, [r0, #308]	; 0x134
        ret = wc_AesGcmSetKey(aes, key, keySz);
  4e:	4639      	mov	r1, r7
  50:	4642      	mov	r2, r8
  52:	f7ff fffe 	bl	0 <wc_Gmac>
        if (ret == 0)
  56:	4607      	mov	r7, r0
  58:	b9c0      	cbnz	r0, 8c <wc_Gmac+0x8c>
            ret = wc_AesGcmSetIV(aes, ivSz, NULL, 0, rng);
  5a:	4603      	mov	r3, r0
  5c:	4602      	mov	r2, r0
  5e:	f8cd b000 	str.w	fp, [sp]
  62:	4631      	mov	r1, r6
  64:	4620      	mov	r0, r4
  66:	f7ff fffe 	bl	0 <wc_Gmac>
        if (ret == 0)
  6a:	4607      	mov	r7, r0
  6c:	b970      	cbnz	r0, 8c <wc_Gmac+0x8c>
            ret = wc_AesGcmEncrypt_ex(aes, NULL, NULL, 0, iv, ivSz,
  6e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  70:	9303      	str	r3, [sp, #12]
  72:	9b12      	ldr	r3, [sp, #72]	; 0x48
  74:	9500      	str	r5, [sp, #0]
  76:	e9cd 6301 	strd	r6, r3, [sp, #4]
  7a:	4602      	mov	r2, r0
  7c:	4603      	mov	r3, r0
  7e:	4601      	mov	r1, r0
  80:	e9cd 9a04 	strd	r9, sl, [sp, #16]
  84:	4620      	mov	r0, r4
  86:	f7ff fffe 	bl	0 <wc_Gmac>
  8a:	4607      	mov	r7, r0
    while (len--) *z++ = 0;
  8c:	f504 719c 	add.w	r1, r4, #312	; 0x138
  90:	4622      	mov	r2, r4
  92:	2000      	movs	r0, #0
  94:	428a      	cmp	r2, r1
  96:	d106      	bne.n	a6 <wc_Gmac+0xa6>
    XFREE(aes, NULL, DYNAMIC_TYPE_AES);
  98:	4620      	mov	r0, r4
  9a:	f7ff fffe 	bl	0 <free>
}
  9e:	4638      	mov	r0, r7
  a0:	b007      	add	sp, #28
  a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  a6:	f802 0b01 	strb.w	r0, [r2], #1
  aa:	e7f3      	b.n	94 <wc_Gmac+0x94>
        return BAD_FUNC_ARG;
  ac:	f06f 07ac 	mvn.w	r7, #172	; 0xac
  b0:	e7f5      	b.n	9e <wc_Gmac+0x9e>
        return MEMORY_E;
  b2:	f06f 077c 	mvn.w	r7, #124	; 0x7c
  b6:	e7f2      	b.n	9e <wc_Gmac+0x9e>

Disassembly of section .text.wc_GmacVerify:

00000000 <wc_GmacVerify>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b087      	sub	sp, #28
   6:	e9dd ab10 	ldrd	sl, fp, [sp, #64]	; 0x40
   a:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
   e:	4688      	mov	r8, r1
  10:	4616      	mov	r6, r2
  12:	461f      	mov	r7, r3
    if (key == NULL || iv == NULL || (authIn == NULL && authInSz != 0) ||
  14:	4604      	mov	r4, r0
  16:	2800      	cmp	r0, #0
  18:	d03a      	beq.n	90 <wc_GmacVerify+0x90>
  1a:	b3ca      	cbz	r2, 90 <wc_GmacVerify+0x90>
  1c:	f1ba 0f00 	cmp.w	sl, #0
  20:	d102      	bne.n	28 <wc_GmacVerify+0x28>
  22:	f1bb 0f00 	cmp.w	fp, #0
  26:	d133      	bne.n	90 <wc_GmacVerify+0x90>
  28:	9b12      	ldr	r3, [sp, #72]	; 0x48
  2a:	b38b      	cbz	r3, 90 <wc_GmacVerify+0x90>
        authTag == NULL || authTagSz == 0 || authTagSz > AES_BLOCK_SIZE) {
  2c:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
  30:	2b0f      	cmp	r3, #15
  32:	d82d      	bhi.n	90 <wc_GmacVerify+0x90>
    if ((aes = (Aes *)XMALLOC(sizeof *aes, NULL,
  34:	f44f 709c 	mov.w	r0, #312	; 0x138
  38:	f7ff fffe 	bl	0 <malloc>
  3c:	4605      	mov	r5, r0
  3e:	b350      	cbz	r0, 96 <wc_GmacVerify+0x96>
    aes->heap = heap;
  40:	2300      	movs	r3, #0
        ret = wc_AesGcmSetKey(aes, key, keySz);
  42:	4621      	mov	r1, r4
    aes->heap = heap;
  44:	f8c0 3134 	str.w	r3, [r0, #308]	; 0x134
        ret = wc_AesGcmSetKey(aes, key, keySz);
  48:	4642      	mov	r2, r8
  4a:	f7ff fffe 	bl	0 <wc_GmacVerify>
        if (ret == 0)
  4e:	4604      	mov	r4, r0
  50:	b970      	cbnz	r0, 70 <wc_GmacVerify+0x70>
            ret = wc_AesGcmDecrypt(aes, NULL, NULL, 0, iv, ivSz,
  52:	9b12      	ldr	r3, [sp, #72]	; 0x48
  54:	f8cd 900c 	str.w	r9, [sp, #12]
  58:	e9cd 7301 	strd	r7, r3, [sp, #4]
  5c:	4602      	mov	r2, r0
  5e:	4603      	mov	r3, r0
  60:	4601      	mov	r1, r0
  62:	e9cd ab04 	strd	sl, fp, [sp, #16]
  66:	9600      	str	r6, [sp, #0]
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <wc_GmacVerify>
  6e:	4604      	mov	r4, r0
  70:	f505 729c 	add.w	r2, r5, #312	; 0x138
  74:	462b      	mov	r3, r5
  76:	2100      	movs	r1, #0
  78:	4293      	cmp	r3, r2
  7a:	d106      	bne.n	8a <wc_GmacVerify+0x8a>
    XFREE(aes, NULL, DYNAMIC_TYPE_AES);
  7c:	4628      	mov	r0, r5
  7e:	f7ff fffe 	bl	0 <free>
}
  82:	4620      	mov	r0, r4
  84:	b007      	add	sp, #28
  86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  8a:	f803 1b01 	strb.w	r1, [r3], #1
  8e:	e7f3      	b.n	78 <wc_GmacVerify+0x78>
        return BAD_FUNC_ARG;
  90:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  94:	e7f5      	b.n	82 <wc_GmacVerify+0x82>
        return MEMORY_E;
  96:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  9a:	e7f2      	b.n	82 <wc_GmacVerify+0x82>

Disassembly of section .text.wc_GmacSetKey:

00000000 <wc_GmacSetKey>:
    if (gmac == NULL || key == NULL) {
   0:	b110      	cbz	r0, 8 <wc_GmacSetKey+0x8>
   2:	b109      	cbz	r1, 8 <wc_GmacSetKey+0x8>
    return wc_AesGcmSetKey(&gmac->aes, key, len);
   4:	f7ff bffe 	b.w	0 <wc_GmacSetKey>
}
   8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   c:	4770      	bx	lr

Disassembly of section .text.wc_GmacUpdate:

00000000 <wc_GmacUpdate>:
{
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
    if (gmac == NULL) {
   4:	b178      	cbz	r0, 26 <wc_GmacUpdate+0x26>
    return wc_AesGcmEncrypt(&gmac->aes, NULL, NULL, 0, iv, ivSz,
   6:	9c08      	ldr	r4, [sp, #32]
   8:	9100      	str	r1, [sp, #0]
   a:	e9cd 3404 	strd	r3, r4, [sp, #16]
   e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  10:	9303      	str	r3, [sp, #12]
  12:	9b09      	ldr	r3, [sp, #36]	; 0x24
  14:	e9cd 2301 	strd	r2, r3, [sp, #4]
  18:	2300      	movs	r3, #0
  1a:	461a      	mov	r2, r3
  1c:	4619      	mov	r1, r3
  1e:	f7ff fffe 	bl	0 <wc_GmacUpdate>
}
  22:	b006      	add	sp, #24
  24:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  26:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2a:	e7fa      	b.n	22 <wc_GmacUpdate+0x22>

Disassembly of section .text.wc_AesInit:

00000000 <wc_AesInit>:
    if (aes == NULL)
   0:	b118      	cbz	r0, a <wc_AesInit+0xa>
    aes->heap = heap;
   2:	f8c0 1134 	str.w	r1, [r0, #308]	; 0x134
#endif

#if defined(WOLFSSL_RENESAS_FSPSM)
    XMEMSET(&aes->ctx, 0, sizeof(aes->ctx));
#endif
    return ret;
   6:	2000      	movs	r0, #0
   8:	4770      	bx	lr
        return BAD_FUNC_ARG;
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   e:	4770      	bx	lr

Disassembly of section .text.wc_AesFree:

00000000 <wc_AesFree>:
#if ((defined(WOLFSSL_RENESAS_FSPSM_TLS) || \
    defined(WOLFSSL_RENESAS_FSPSM_CRYPTONLY)) && \
    !defined(NO_WOLFSSL_RENESAS_FSPSM_AES))
    wc_fspsm_Aesfree(aes);
#endif
}
   0:	4770      	bx	lr

Disassembly of section .text.wc_AesGetKeySize:

00000000 <wc_AesGetKeySize>:

int wc_AesGetKeySize(Aes* aes, word32* keySize)
{
    int ret = 0;

    if (aes == NULL || keySize == NULL) {
   0:	b1a0      	cbz	r0, 2c <wc_AesGetKeySize+0x2c>
   2:	b199      	cbz	r1, 2c <wc_AesGetKeySize+0x2c>
#endif
#if defined(WOLFSSL_CRYPTOCELL) && defined(WOLFSSL_CRYPTOCELL_AES)
    *keySize = aes->ctx.key.keySize;
    return ret;
#endif
    switch (aes->rounds) {
   4:	f8d0 30f0 	ldr.w	r3, [r0, #240]	; 0xf0
   8:	2b0c      	cmp	r3, #12
   a:	d008      	beq.n	1e <wc_AesGetKeySize+0x1e>
   c:	2b0e      	cmp	r3, #14
   e:	f04f 0000 	mov.w	r0, #0
  12:	d008      	beq.n	26 <wc_AesGetKeySize+0x26>
  14:	2b0a      	cmp	r3, #10
  16:	d108      	bne.n	2a <wc_AesGetKeySize+0x2a>
#ifdef WOLFSSL_AES_128
    case 10:
        *keySize = 16;
  18:	2310      	movs	r3, #16
        *keySize = 24;
        break;
#endif
#ifdef WOLFSSL_AES_256
    case 14:
        *keySize = 32;
  1a:	600b      	str	r3, [r1, #0]
        break;
  1c:	4770      	bx	lr
        *keySize = 24;
  1e:	2318      	movs	r3, #24
  20:	600b      	str	r3, [r1, #0]
    int ret = 0;
  22:	2000      	movs	r0, #0
        break;
  24:	4770      	bx	lr
        *keySize = 32;
  26:	2320      	movs	r3, #32
  28:	e7f7      	b.n	1a <wc_AesGetKeySize+0x1a>
#endif
    default:
        *keySize = 0;
  2a:	6008      	str	r0, [r1, #0]
        return BAD_FUNC_ARG;
  2c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
        ret = BAD_FUNC_ARG;
    }

    return ret;
}
  30:	4770      	bx	lr

cmac.o:     file format elf32-littlearm


des3.o:     file format elf32-littlearm


Disassembly of section .text.ByteReverseWord32:

00000000 <ByteReverseWord32>:
#else
    /* 6 instructions with rotate instruction, 8 without */
    value = ((value & 0xFF00FF00) >> 8) | ((value & 0x00FF00FF) << 8);
    return rotlFixed(value, 16U);
#endif
}
   0:	ba00      	rev	r0, r0
   2:	4770      	bx	lr

Disassembly of section .text.IPERM:

00000000 <IPERM>:
        return (x << y) | (x >> (sizeof(x) * 8 - y));
   0:	680b      	ldr	r3, [r1, #0]
   2:	ea4f 7333 	mov.w	r3, r3, ror #28

    static WC_INLINE void IPERM(word32* left, word32* right)
    {
        word32 work;

        *right = rotlFixed(*right, 4U);
   6:	600b      	str	r3, [r1, #0]
        work = (*left ^ *right) & 0xf0f0f0f0;
   8:	6802      	ldr	r2, [r0, #0]
   a:	4053      	eors	r3, r2
   c:	f003 33f0 	and.w	r3, r3, #4042322160	; 0xf0f0f0f0
        *left ^= work;
  10:	405a      	eors	r2, r3
  12:	6002      	str	r2, [r0, #0]

        *right = rotrFixed(*right^work, 20U);
  14:	680a      	ldr	r2, [r1, #0]
  16:	4053      	eors	r3, r2
        return (x >> y) | (x << (sizeof(x) * 8 - y));
  18:	ea4f 5333 	mov.w	r3, r3, ror #20
  1c:	600b      	str	r3, [r1, #0]
        work = (*left ^ *right) & 0xffff0000;
  1e:	6802      	ldr	r2, [r0, #0]
  20:	4053      	eors	r3, r2
  22:	0c1b      	lsrs	r3, r3, #16
  24:	041b      	lsls	r3, r3, #16
        *left ^= work;
  26:	405a      	eors	r2, r3
  28:	6002      	str	r2, [r0, #0]

        *right = rotrFixed(*right^work, 18U);
  2a:	680a      	ldr	r2, [r1, #0]
  2c:	4053      	eors	r3, r2
  2e:	ea4f 43b3 	mov.w	r3, r3, ror #18
  32:	600b      	str	r3, [r1, #0]
        work = (*left ^ *right) & 0x33333333;
  34:	6802      	ldr	r2, [r0, #0]
  36:	4053      	eors	r3, r2
  38:	f003 3333 	and.w	r3, r3, #858993459	; 0x33333333
        *left ^= work;
  3c:	405a      	eors	r2, r3
  3e:	6002      	str	r2, [r0, #0]

        *right = rotrFixed(*right^work, 6U);
  40:	680a      	ldr	r2, [r1, #0]
  42:	4053      	eors	r3, r2
  44:	ea4f 13b3 	mov.w	r3, r3, ror #6
  48:	600b      	str	r3, [r1, #0]
        work = (*left ^ *right) & 0x00ff00ff;
  4a:	6802      	ldr	r2, [r0, #0]
  4c:	4053      	eors	r3, r2
  4e:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
        *left ^= work;
  52:	405a      	eors	r2, r3
  54:	6002      	str	r2, [r0, #0]

        *right = rotlFixed(*right^work, 9U);
  56:	680a      	ldr	r2, [r1, #0]
  58:	4053      	eors	r3, r2
        return (x << y) | (x >> (sizeof(x) * 8 - y));
  5a:	ea4f 53f3 	mov.w	r3, r3, ror #23
  5e:	600b      	str	r3, [r1, #0]
        work = (*left ^ *right) & 0xaaaaaaaa;
  60:	6802      	ldr	r2, [r0, #0]
  62:	4053      	eors	r3, r2
  64:	f003 33aa 	and.w	r3, r3, #2863311530	; 0xaaaaaaaa
        *left = rotlFixed(*left^work, 1U);
  68:	405a      	eors	r2, r3
  6a:	ea4f 72f2 	mov.w	r2, r2, ror #31
  6e:	6002      	str	r2, [r0, #0]
        *right ^= work;
  70:	680a      	ldr	r2, [r1, #0]
  72:	4053      	eors	r3, r2
  74:	600b      	str	r3, [r1, #0]
    }
  76:	4770      	bx	lr

Disassembly of section .text.FPERM:

00000000 <FPERM>:
        return (x >> y) | (x << (sizeof(x) * 8 - y));
   0:	680a      	ldr	r2, [r1, #0]
   2:	ea4f 0272 	mov.w	r2, r2, ror #1

    static WC_INLINE void FPERM(word32* left, word32* right)
    {
        word32 work;

        *right = rotrFixed(*right, 1U);
   6:	600a      	str	r2, [r1, #0]
        work = (*left ^ *right) & 0xaaaaaaaa;
   8:	6803      	ldr	r3, [r0, #0]
   a:	4053      	eors	r3, r2
   c:	f003 33aa 	and.w	r3, r3, #2863311530	; 0xaaaaaaaa
        *right ^= work;
  10:	405a      	eors	r2, r3
  12:	600a      	str	r2, [r1, #0]

        *left = rotrFixed(*left^work, 9U);
  14:	6802      	ldr	r2, [r0, #0]
  16:	4053      	eors	r3, r2
  18:	ea4f 2373 	mov.w	r3, r3, ror #9
  1c:	6003      	str	r3, [r0, #0]
        work = (*left ^ *right) & 0x00ff00ff;
  1e:	680a      	ldr	r2, [r1, #0]
  20:	4053      	eors	r3, r2
  22:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
        *right ^= work;
  26:	405a      	eors	r2, r3
  28:	600a      	str	r2, [r1, #0]

        *left = rotlFixed(*left^work, 6U);
  2a:	6802      	ldr	r2, [r0, #0]
  2c:	4053      	eors	r3, r2
        return (x << y) | (x >> (sizeof(x) * 8 - y));
  2e:	ea4f 63b3 	mov.w	r3, r3, ror #26
  32:	6003      	str	r3, [r0, #0]
        work = (*left ^ *right) & 0x33333333;
  34:	680a      	ldr	r2, [r1, #0]
  36:	4053      	eors	r3, r2
  38:	f003 3333 	and.w	r3, r3, #858993459	; 0x33333333
        *right ^= work;
  3c:	405a      	eors	r2, r3
  3e:	600a      	str	r2, [r1, #0]

        *left = rotlFixed(*left^work, 18U);
  40:	6802      	ldr	r2, [r0, #0]
  42:	4053      	eors	r3, r2
  44:	ea4f 33b3 	mov.w	r3, r3, ror #14
  48:	6003      	str	r3, [r0, #0]
        work = (*left ^ *right) & 0xffff0000;
  4a:	680a      	ldr	r2, [r1, #0]
  4c:	4053      	eors	r3, r2
  4e:	0c1b      	lsrs	r3, r3, #16
  50:	041b      	lsls	r3, r3, #16
        *right ^= work;
  52:	405a      	eors	r2, r3
  54:	600a      	str	r2, [r1, #0]

        *left = rotlFixed(*left^work, 20U);
  56:	6802      	ldr	r2, [r0, #0]
  58:	4053      	eors	r3, r2
  5a:	ea4f 3333 	mov.w	r3, r3, ror #12
  5e:	6003      	str	r3, [r0, #0]
        work = (*left ^ *right) & 0xf0f0f0f0;
  60:	680a      	ldr	r2, [r1, #0]
  62:	4053      	eors	r3, r2
  64:	f003 33f0 	and.w	r3, r3, #4042322160	; 0xf0f0f0f0
        *right ^= work;
  68:	405a      	eors	r2, r3
  6a:	600a      	str	r2, [r1, #0]

        *left = rotrFixed(*left^work, 4U);
  6c:	6802      	ldr	r2, [r0, #0]
  6e:	4053      	eors	r3, r2
        return (x >> y) | (x << (sizeof(x) * 8 - y));
  70:	ea4f 1333 	mov.w	r3, r3, ror #4
  74:	6003      	str	r3, [r0, #0]
    }
  76:	4770      	bx	lr

Disassembly of section .text.DesRawProcessBlock:

00000000 <DesRawProcessBlock>:

        return wc_Des3_SetIV(des, iv);
    }

    static void DesRawProcessBlock(word32* lIn, word32* rIn, const word32* kptr)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        word32 l = *lIn, r = *rIn, i;
   4:	f8d1 c000 	ldr.w	ip, [r1]
   8:	6806      	ldr	r6, [r0, #0]

        for (i=0; i<8; i++)
        {
            word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];
            l ^= Spbox[6][(work) & 0x3f]
   a:	4b49      	ldr	r3, [pc, #292]	; (130 <DesRawProcessBlock+0x130>)
   c:	f102 0780 	add.w	r7, r2, #128	; 0x80
            word32 work = rotrFixed(r, 4U) ^ kptr[4*i+0];
  10:	6814      	ldr	r4, [r2, #0]
  12:	ea84 1e3c 	eor.w	lr, r4, ip, ror #4
              ^  Spbox[4][(work >> 8) & 0x3f]
              ^  Spbox[2][(work >> 16) & 0x3f]
              ^  Spbox[0][(work >> 24) & 0x3f];
            work = r ^ kptr[4*i+1];
  16:	6854      	ldr	r4, [r2, #4]
  18:	ea8c 0404 	eor.w	r4, ip, r4
            l ^= Spbox[6][(work) & 0x3f]
  1c:	f00e 053f 	and.w	r5, lr, #63	; 0x3f
            l ^= Spbox[7][(work) & 0x3f]
  20:	f004 083f 	and.w	r8, r4, #63	; 0x3f
            l ^= Spbox[6][(work) & 0x3f]
  24:	f505 75c0 	add.w	r5, r5, #384	; 0x180
            l ^= Spbox[7][(work) & 0x3f]
  28:	f508 78e0 	add.w	r8, r8, #448	; 0x1c0
  2c:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
  30:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
  34:	ea85 0508 	eor.w	r5, r5, r8
              ^  Spbox[4][(work >> 8) & 0x3f]
  38:	f3ce 2805 	ubfx	r8, lr, #8, #6
  3c:	f508 7880 	add.w	r8, r8, #256	; 0x100
        for (i=0; i<8; i++)
  40:	3210      	adds	r2, #16
            l ^= Spbox[7][(work) & 0x3f]
  42:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
  46:	ea85 0508 	eor.w	r5, r5, r8
              ^  Spbox[2][(work >> 16) & 0x3f]
  4a:	f3ce 4805 	ubfx	r8, lr, #16, #6
  4e:	f108 0880 	add.w	r8, r8, #128	; 0x80
              ^  Spbox[0][(work >> 24) & 0x3f];
  52:	f3ce 6e05 	ubfx	lr, lr, #24, #6
            l ^= Spbox[7][(work) & 0x3f]
  56:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
  5a:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
  5e:	ea85 0508 	eor.w	r5, r5, r8
  62:	ea85 050e 	eor.w	r5, r5, lr
              ^  Spbox[5][(work >> 8) & 0x3f]
  66:	f3c4 2e05 	ubfx	lr, r4, #8, #6
  6a:	f50e 7ea0 	add.w	lr, lr, #320	; 0x140
            l ^= Spbox[7][(work) & 0x3f]
  6e:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
  72:	ea85 050e 	eor.w	r5, r5, lr
              ^  Spbox[3][(work >> 16) & 0x3f]
  76:	f3c4 4e05 	ubfx	lr, r4, #16, #6
  7a:	f10e 0ec0 	add.w	lr, lr, #192	; 0xc0
              ^  Spbox[1][(work >> 24) & 0x3f];
  7e:	f3c4 6405 	ubfx	r4, r4, #24, #6
  82:	3440      	adds	r4, #64	; 0x40
            l ^= Spbox[7][(work) & 0x3f]
  84:	f853 e02e 	ldr.w	lr, [r3, lr, lsl #2]
  88:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
  8c:	ea85 050e 	eor.w	r5, r5, lr
  90:	4065      	eors	r5, r4
  92:	406e      	eors	r6, r5
            work = rotrFixed(l, 4U) ^ kptr[4*i+2];
            r ^= Spbox[6][(work) & 0x3f]
              ^  Spbox[4][(work >> 8) & 0x3f]
              ^  Spbox[2][(work >> 16) & 0x3f]
              ^  Spbox[0][(work >> 24) & 0x3f];
            work = l ^ kptr[4*i+3];
  94:	f852 4c04 	ldr.w	r4, [r2, #-4]
            work = rotrFixed(l, 4U) ^ kptr[4*i+2];
  98:	f852 5c08 	ldr.w	r5, [r2, #-8]
            work = l ^ kptr[4*i+3];
  9c:	ea86 0e04 	eor.w	lr, r6, r4
            work = rotrFixed(l, 4U) ^ kptr[4*i+2];
  a0:	ea85 1536 	eor.w	r5, r5, r6, ror #4
            r ^= Spbox[6][(work) & 0x3f]
  a4:	f005 043f 	and.w	r4, r5, #63	; 0x3f
            r ^= Spbox[7][(work) & 0x3f]
  a8:	f00e 083f 	and.w	r8, lr, #63	; 0x3f
            r ^= Spbox[6][(work) & 0x3f]
  ac:	f504 74c0 	add.w	r4, r4, #384	; 0x180
            r ^= Spbox[7][(work) & 0x3f]
  b0:	f508 78e0 	add.w	r8, r8, #448	; 0x1c0
  b4:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
  b8:	f853 8028 	ldr.w	r8, [r3, r8, lsl #2]
  bc:	ea84 0408 	eor.w	r4, r4, r8
  c0:	ea84 040c 	eor.w	r4, r4, ip
              ^  Spbox[5][(work >> 8) & 0x3f]
  c4:	f3ce 2c05 	ubfx	ip, lr, #8, #6
  c8:	f50c 7ca0 	add.w	ip, ip, #320	; 0x140
        for (i=0; i<8; i++)
  cc:	4297      	cmp	r7, r2
  ce:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
  d2:	ea84 040c 	eor.w	r4, r4, ip
              ^  Spbox[3][(work >> 16) & 0x3f]
  d6:	f3ce 4c05 	ubfx	ip, lr, #16, #6
  da:	f10c 0cc0 	add.w	ip, ip, #192	; 0xc0
              ^  Spbox[1][(work >> 24) & 0x3f];
  de:	f3ce 6e05 	ubfx	lr, lr, #24, #6
  e2:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
  e6:	f10e 0e40 	add.w	lr, lr, #64	; 0x40
  ea:	ea84 040c 	eor.w	r4, r4, ip
  ee:	f853 c02e 	ldr.w	ip, [r3, lr, lsl #2]
  f2:	ea84 040c 	eor.w	r4, r4, ip
              ^  Spbox[4][(work >> 8) & 0x3f]
  f6:	f3c5 2c05 	ubfx	ip, r5, #8, #6
  fa:	f50c 7c80 	add.w	ip, ip, #256	; 0x100
  fe:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
 102:	ea84 040c 	eor.w	r4, r4, ip
              ^  Spbox[2][(work >> 16) & 0x3f]
 106:	f3c5 4c05 	ubfx	ip, r5, #16, #6
 10a:	f10c 0c80 	add.w	ip, ip, #128	; 0x80
              ^  Spbox[0][(work >> 24) & 0x3f];
 10e:	f3c5 6505 	ubfx	r5, r5, #24, #6
 112:	f853 c02c 	ldr.w	ip, [r3, ip, lsl #2]
            r ^= Spbox[7][(work) & 0x3f]
 116:	f853 5025 	ldr.w	r5, [r3, r5, lsl #2]
 11a:	ea84 040c 	eor.w	r4, r4, ip
 11e:	ea84 0c05 	eor.w	ip, r4, r5
        for (i=0; i<8; i++)
 122:	f47f af75 	bne.w	10 <DesRawProcessBlock+0x10>
        }

        *lIn = l; *rIn = r;
 126:	6006      	str	r6, [r0, #0]
 128:	f8c1 c000 	str.w	ip, [r1]
    }
 12c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 130:	00000000 	.word	0x00000000

Disassembly of section .text.DesSetKey:

00000000 <DesSetKey>:
    {
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4606      	mov	r6, r0
        byte* buffer = (byte*)XMALLOC(DES_KEY_BUFFER_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);
   6:	2078      	movs	r0, #120	; 0x78
    {
   8:	468b      	mov	fp, r1
   a:	4615      	mov	r5, r2
        byte* buffer = (byte*)XMALLOC(DES_KEY_BUFFER_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER);
   c:	f7ff fffe 	bl	0 <malloc>
        if (buffer == NULL)
  10:	4604      	mov	r4, r0
  12:	2800      	cmp	r0, #0
  14:	f000 8095 	beq.w	142 <DesSetKey+0x142>
            byte* const  pcr  = pc1m + 56;         /* place to rotate pc1 into */
  18:	494b      	ldr	r1, [pc, #300]	; (148 <DesSetKey+0x148>)
                    bytebit[m])                    /* and which bit of that byte  */
  1a:	4f4c      	ldr	r7, [pc, #304]	; (14c <DesSetKey+0x14c>)
            byte* const  pcr  = pc1m + 56;         /* place to rotate pc1 into */
  1c:	f100 0938 	add.w	r9, r0, #56	; 0x38
            byte* const  ks   = pcr  + 56;
  20:	f100 0870 	add.w	r8, r0, #112	; 0x70
            for (j = 0; j < 56; j++) {             /* convert pc1 to bits of key  */
  24:	1e42      	subs	r2, r0, #1
  26:	3037      	adds	r0, #55	; 0x37
                l = pc1[j] - 1;                    /* integer bit location        */
  28:	f811 3b01 	ldrb.w	r3, [r1], #1
  2c:	3b01      	subs	r3, #1
                pc1m[j] = (key[l >> 3] &           /* find which key byte l is in */
  2e:	ea4f 0ce3 	mov.w	ip, r3, asr #3
                m = l & 07;                        /* find bit                    */
  32:	f003 0307 	and.w	r3, r3, #7
                pc1m[j] = (key[l >> 3] &           /* find which key byte l is in */
  36:	f816 c00c 	ldrb.w	ip, [r6, ip]
  3a:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
                    ? 1 : 0;                       /* and store 1-bit result      */
  3e:	ea1c 0f03 	tst.w	ip, r3
  42:	bf14      	ite	ne
  44:	2301      	movne	r3, #1
  46:	2300      	moveq	r3, #0
  48:	f802 3f01 	strb.w	r3, [r2, #1]!
            for (j = 0; j < 56; j++) {             /* convert pc1 to bits of key  */
  4c:	4290      	cmp	r0, r2
  4e:	d1eb      	bne.n	28 <DesSetKey+0x28>
  50:	f105 0380 	add.w	r3, r5, #128	; 0x80
  54:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 150 <DesSetKey+0x150>
  58:	9301      	str	r3, [sp, #4]
  5a:	462e      	mov	r6, r5
  5c:	462f      	mov	r7, r5
                XMEMSET(ks, 0, 8);                /* Clear key schedule */
  5e:	2208      	movs	r2, #8
  60:	2100      	movs	r1, #0
  62:	4640      	mov	r0, r8
  64:	f7ff fffe 	bl	0 <memset>
                for (j = 0; j < 56; j++)          /* rotate pc1 the right amount  */
  68:	f81a 3b01 	ldrb.w	r3, [sl], #1
  6c:	4649      	mov	r1, r9
  6e:	2200      	movs	r2, #0
                          pc1m[(l = j + totrot[i]) < (j < 28 ? 28 : 56) ? l : l-28];
  70:	201c      	movs	r0, #28
  72:	4298      	cmp	r0, r3
  74:	bfd4      	ite	le
  76:	f1a3 001c 	suble.w	r0, r3, #28
  7a:	4618      	movgt	r0, r3
                for (j = 0; j < 56; j++)          /* rotate pc1 the right amount  */
  7c:	3201      	adds	r2, #1
                          pc1m[(l = j + totrot[i]) < (j < 28 ? 28 : 56) ? l : l-28];
  7e:	5c20      	ldrb	r0, [r4, r0]
                    pcr[j] =
  80:	f801 0b01 	strb.w	r0, [r1], #1
                for (j = 0; j < 56; j++)          /* rotate pc1 the right amount  */
  84:	2a38      	cmp	r2, #56	; 0x38
  86:	f103 0301 	add.w	r3, r3, #1
  8a:	d155      	bne.n	138 <DesSetKey+0x138>
  8c:	4831      	ldr	r0, [pc, #196]	; (154 <DesSetKey+0x154>)
                for (j = 0; j < 48; j++) {        /* select bits individually     */
  8e:	2300      	movs	r3, #0
                        ks[j/6] |= (byte)(bytebit[l] >> 2);
  90:	f04f 0c06 	mov.w	ip, #6
                    if (pcr[pc2[j] - 1]) {        /* check bit that goes to ks[j] */
  94:	f810 2b01 	ldrb.w	r2, [r0], #1
  98:	444a      	add	r2, r9
  9a:	f812 2c01 	ldrb.w	r2, [r2, #-1]
  9e:	b16a      	cbz	r2, bc <DesSetKey+0xbc>
                        ks[j/6] |= (byte)(bytebit[l] >> 2);
  a0:	fbb3 f2fc 	udiv	r2, r3, ip
  a4:	f8df e0a4 	ldr.w	lr, [pc, #164]	; 14c <DesSetKey+0x14c>
                        l= j % 6;                 /* mask it in if it's there     */
  a8:	fb0c 3112 	mls	r1, ip, r2, r3
                        ks[j/6] |= (byte)(bytebit[l] >> 2);
  ac:	f85e e021 	ldr.w	lr, [lr, r1, lsl #2]
  b0:	f818 1002 	ldrb.w	r1, [r8, r2]
  b4:	ea41 01ae 	orr.w	r1, r1, lr, asr #2
  b8:	f808 1002 	strb.w	r1, [r8, r2]
                for (j = 0; j < 48; j++) {        /* select bits individually     */
  bc:	3301      	adds	r3, #1
  be:	2b30      	cmp	r3, #48	; 0x30
  c0:	d1e8      	bne.n	94 <DesSetKey+0x94>
                         | ((word32) ks[2] << 16)
  c2:	f894 3072 	ldrb.w	r3, [r4, #114]	; 0x72
                out[2*i] = ((word32) ks[0] << 24)
  c6:	f894 2070 	ldrb.w	r2, [r4, #112]	; 0x70
                         | ((word32) ks[2] << 16)
  ca:	041b      	lsls	r3, r3, #16
  cc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                         | ((word32) ks[6]);
  d0:	f894 2076 	ldrb.w	r2, [r4, #118]	; 0x76
  d4:	4313      	orrs	r3, r2
                         | ((word32) ks[4] << 8)
  d6:	f894 2074 	ldrb.w	r2, [r4, #116]	; 0x74
                         | ((word32) ks[6]);
  da:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                out[2*i] = ((word32) ks[0] << 24)
  de:	603b      	str	r3, [r7, #0]
                             | ((word32) ks[3] << 16)
  e0:	f894 3073 	ldrb.w	r3, [r4, #115]	; 0x73
                out[2*i + 1] = ((word32) ks[1] << 24)
  e4:	f894 2071 	ldrb.w	r2, [r4, #113]	; 0x71
                             | ((word32) ks[3] << 16)
  e8:	041b      	lsls	r3, r3, #16
  ea:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
                             | ((word32) ks[7]);
  ee:	f894 2077 	ldrb.w	r2, [r4, #119]	; 0x77
  f2:	4313      	orrs	r3, r2
                             | ((word32) ks[5] << 8)
  f4:	f894 2075 	ldrb.w	r2, [r4, #117]	; 0x75
                             | ((word32) ks[7]);
  f8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                out[2*i + 1] = ((word32) ks[1] << 24)
  fc:	607b      	str	r3, [r7, #4]
            for (i = 0; i < 16; i++) {            /* key chunk for each iteration */
  fe:	9b01      	ldr	r3, [sp, #4]
 100:	3708      	adds	r7, #8
 102:	42bb      	cmp	r3, r7
 104:	d1ab      	bne.n	5e <DesSetKey+0x5e>
            if (dir == DES_DECRYPTION) {
 106:	f1bb 0f01 	cmp.w	fp, #1
 10a:	d10e      	bne.n	12a <DesSetKey+0x12a>
 10c:	f105 0340 	add.w	r3, r5, #64	; 0x40
                    out[i] = out[DES_KS_SIZE - 2 - i];
 110:	6fa9      	ldr	r1, [r5, #120]	; 0x78
                    word32 swap = out[i];
 112:	6832      	ldr	r2, [r6, #0]
                    out[i] = out[DES_KS_SIZE - 2 - i];
 114:	6031      	str	r1, [r6, #0]
                    out[i + 1] = out[DES_KS_SIZE - 1 - i];
 116:	6fe9      	ldr	r1, [r5, #124]	; 0x7c
                    out[DES_KS_SIZE - 2 - i] = swap;
 118:	67aa      	str	r2, [r5, #120]	; 0x78
                    swap = out[i + 1];
 11a:	6872      	ldr	r2, [r6, #4]
                    out[i + 1] = out[DES_KS_SIZE - 1 - i];
 11c:	6071      	str	r1, [r6, #4]
                for (i = 0; i < 16; i += 2) {
 11e:	3608      	adds	r6, #8
 120:	42b3      	cmp	r3, r6
                    out[DES_KS_SIZE - 1 - i] = swap;
 122:	67ea      	str	r2, [r5, #124]	; 0x7c
                for (i = 0; i < 16; i += 2) {
 124:	f1a5 0508 	sub.w	r5, r5, #8
 128:	d1f2      	bne.n	110 <DesSetKey+0x110>
            XFREE(buffer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 12a:	4620      	mov	r0, r4
 12c:	f7ff fffe 	bl	0 <free>
        return 0;
 130:	2000      	movs	r0, #0
    }
 132:	b003      	add	sp, #12
 134:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                          pc1m[(l = j + totrot[i]) < (j < 28 ? 28 : 56) ? l : l-28];
 138:	2a1c      	cmp	r2, #28
 13a:	bfb4      	ite	lt
 13c:	201c      	movlt	r0, #28
 13e:	2038      	movge	r0, #56	; 0x38
 140:	e797      	b.n	72 <DesSetKey+0x72>
            return MEMORY_E;
 142:	f06f 007c 	mvn.w	r0, #124	; 0x7c
 146:	e7f4      	b.n	132 <DesSetKey+0x132>
	...

Disassembly of section .text.DesProcessBlock:

00000000 <DesProcessBlock>:

    static void DesProcessBlock(Des* des, const byte* in, byte* out)
    {
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2:	4614      	mov	r4, r2
   4:	4605      	mov	r5, r0
        word32 l, r;

        XMEMCPY(&l, in, sizeof(l));
   6:	2204      	movs	r2, #4
   8:	4668      	mov	r0, sp
    {
   a:	460e      	mov	r6, r1
        XMEMCPY(&l, in, sizeof(l));
   c:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(&r, in + sizeof(l), sizeof(r));
  10:	2204      	movs	r2, #4
  12:	18b1      	adds	r1, r6, r2
  14:	eb0d 0002 	add.w	r0, sp, r2
  18:	f7ff fffe 	bl	0 <memcpy>
        #ifdef LITTLE_ENDIAN_ORDER
            l = ByteReverseWord32(l);
  1c:	9800      	ldr	r0, [sp, #0]
  1e:	f7ff fffe 	bl	0 <DesProcessBlock>
  22:	9000      	str	r0, [sp, #0]
            r = ByteReverseWord32(r);
  24:	9801      	ldr	r0, [sp, #4]
  26:	f7ff fffe 	bl	0 <DesProcessBlock>
        #endif
        IPERM(&l,&r);
  2a:	a901      	add	r1, sp, #4
            r = ByteReverseWord32(r);
  2c:	9001      	str	r0, [sp, #4]
        IPERM(&l,&r);
  2e:	4668      	mov	r0, sp
  30:	f7ff fffe 	bl	0 <DesProcessBlock>

        DesRawProcessBlock(&l, &r, des->key);
  34:	f105 0210 	add.w	r2, r5, #16
  38:	f7ff fffe 	bl	0 <DesProcessBlock>

        FPERM(&l,&r);
  3c:	f7ff fffe 	bl	0 <DesProcessBlock>
        #ifdef LITTLE_ENDIAN_ORDER
            l = ByteReverseWord32(l);
  40:	9800      	ldr	r0, [sp, #0]
  42:	f7ff fffe 	bl	0 <DesProcessBlock>
  46:	9000      	str	r0, [sp, #0]
            r = ByteReverseWord32(r);
  48:	9801      	ldr	r0, [sp, #4]
  4a:	f7ff fffe 	bl	0 <DesProcessBlock>
        #endif
        XMEMCPY(out, &r, sizeof(r));
  4e:	2204      	movs	r2, #4
            r = ByteReverseWord32(r);
  50:	9001      	str	r0, [sp, #4]
        XMEMCPY(out, &r, sizeof(r));
  52:	4620      	mov	r0, r4
  54:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(out + sizeof(r), &l, sizeof(l));
  58:	2204      	movs	r2, #4
  5a:	4669      	mov	r1, sp
  5c:	18a0      	adds	r0, r4, r2
  5e:	f7ff fffe 	bl	0 <memcpy>
    }
  62:	b002      	add	sp, #8
  64:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.Des3ProcessBlock:

00000000 <Des3ProcessBlock>:

    static void Des3ProcessBlock(Des3* des, const byte* in, byte* out)
    {
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
   4:	4615      	mov	r5, r2
        word32 l, r;

        XMEMCPY(&l, in, sizeof(l));
   6:	4668      	mov	r0, sp
   8:	2204      	movs	r2, #4
    {
   a:	460e      	mov	r6, r1
        XMEMCPY(&l, in, sizeof(l));
   c:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(&r, in + sizeof(l), sizeof(r));
  10:	2204      	movs	r2, #4
  12:	18b1      	adds	r1, r6, r2
  14:	eb0d 0002 	add.w	r0, sp, r2
  18:	f7ff fffe 	bl	0 <memcpy>
        #ifdef LITTLE_ENDIAN_ORDER
            l = ByteReverseWord32(l);
  1c:	9800      	ldr	r0, [sp, #0]
  1e:	f7ff fffe 	bl	0 <Des3ProcessBlock>
  22:	9000      	str	r0, [sp, #0]
            r = ByteReverseWord32(r);
  24:	9801      	ldr	r0, [sp, #4]
  26:	f7ff fffe 	bl	0 <Des3ProcessBlock>
        #endif
        IPERM(&l,&r);
  2a:	a901      	add	r1, sp, #4
            r = ByteReverseWord32(r);
  2c:	9001      	str	r0, [sp, #4]
        IPERM(&l,&r);
  2e:	4668      	mov	r0, sp
  30:	f7ff fffe 	bl	0 <Des3ProcessBlock>

        DesRawProcessBlock(&l, &r, des->key[0]);
  34:	4622      	mov	r2, r4
  36:	f7ff fffe 	bl	0 <Des3ProcessBlock>
        DesRawProcessBlock(&r, &l, des->key[1]);
  3a:	a801      	add	r0, sp, #4
  3c:	f104 0280 	add.w	r2, r4, #128	; 0x80
  40:	4669      	mov	r1, sp
  42:	f7ff fffe 	bl	0 <Des3ProcessBlock>
        DesRawProcessBlock(&l, &r, des->key[2]);
  46:	4601      	mov	r1, r0
  48:	f504 7280 	add.w	r2, r4, #256	; 0x100
  4c:	4668      	mov	r0, sp
  4e:	f7ff fffe 	bl	0 <Des3ProcessBlock>

        FPERM(&l,&r);
  52:	f7ff fffe 	bl	0 <Des3ProcessBlock>
        #ifdef LITTLE_ENDIAN_ORDER
            l = ByteReverseWord32(l);
  56:	9800      	ldr	r0, [sp, #0]
  58:	f7ff fffe 	bl	0 <Des3ProcessBlock>
  5c:	9000      	str	r0, [sp, #0]
            r = ByteReverseWord32(r);
  5e:	9801      	ldr	r0, [sp, #4]
  60:	f7ff fffe 	bl	0 <Des3ProcessBlock>
        #endif
        XMEMCPY(out, &r, sizeof(r));
  64:	2204      	movs	r2, #4
            r = ByteReverseWord32(r);
  66:	9001      	str	r0, [sp, #4]
        XMEMCPY(out, &r, sizeof(r));
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(out + sizeof(r), &l, sizeof(l));
  6e:	2204      	movs	r2, #4
  70:	4669      	mov	r1, sp
  72:	18a8      	adds	r0, r5, r2
  74:	f7ff fffe 	bl	0 <memcpy>
    }
  78:	b002      	add	sp, #8
  7a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.xorbuf.constprop.0:

00000000 <xorbuf.constprop.0>:
    const byte* m;

    b = (byte*)buf;
    m = (const byte*)mask;

    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
   0:	ea81 0300 	eor.w	r3, r1, r0
   4:	f013 0f03 	tst.w	r3, #3
WC_MISC_STATIC WC_INLINE void xorbuf(void* buf, const void* mask, word32 count)
   8:	b5f0      	push	{r4, r5, r6, r7, lr}
   a:	f04f 0308 	mov.w	r3, #8
    if (((wc_ptr_t)b) % WOLFSSL_WORD_SIZE ==
   e:	d019      	beq.n	44 <xorbuf.constprop.0+0x44>
        b = tpb.bp;
        m = tpm.bp;
        count %= WOLFSSL_WORD_SIZE;
    }

    for (i = 0; i < count; i++)
  10:	3901      	subs	r1, #1
  12:	4403      	add	r3, r0
  14:	4298      	cmp	r0, r3
  16:	d120      	bne.n	5a <xorbuf.constprop.0+0x5a>
        b[i] ^= m[i];
}
  18:	bdf0      	pop	{r4, r5, r6, r7, pc}
            *(b++) ^= *(m++);
  1a:	f811 2b01 	ldrb.w	r2, [r1], #1
  1e:	f810 5b01 	ldrb.w	r5, [r0], #1
  22:	406a      	eors	r2, r5
  24:	f800 2c01 	strb.w	r2, [r0, #-1]
            count--;
  28:	3b01      	subs	r3, #1
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
  2a:	b10c      	cbz	r4, 30 <xorbuf.constprop.0+0x30>
  2c:	2b00      	cmp	r3, #0
  2e:	d1f4      	bne.n	1a <xorbuf.constprop.0+0x1a>
    for (i = 0; i < n; i++)
  30:	f023 0503 	bic.w	r5, r3, #3
  34:	194e      	adds	r6, r1, r5
  36:	4602      	mov	r2, r0
  38:	42b1      	cmp	r1, r6
  3a:	d106      	bne.n	4a <xorbuf.constprop.0+0x4a>
  3c:	4428      	add	r0, r5
        count %= WOLFSSL_WORD_SIZE;
  3e:	f003 0303 	and.w	r3, r3, #3
  42:	e7e5      	b.n	10 <xorbuf.constprop.0+0x10>
        while (((wc_ptr_t)buf) % WOLFSSL_WORD_SIZE != 0 && count > 0) {
  44:	f000 0403 	and.w	r4, r0, #3
  48:	e7ef      	b.n	2a <xorbuf.constprop.0+0x2a>
        *((*r)++) ^= *((*a)++);
  4a:	f852 4b04 	ldr.w	r4, [r2], #4
  4e:	f851 7b04 	ldr.w	r7, [r1], #4
  52:	407c      	eors	r4, r7
  54:	f842 4c04 	str.w	r4, [r2, #-4]
    for (i = 0; i < n; i++)
  58:	e7ee      	b.n	38 <xorbuf.constprop.0+0x38>
        b[i] ^= m[i];
  5a:	7802      	ldrb	r2, [r0, #0]
  5c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  60:	4062      	eors	r2, r4
  62:	f800 2b01 	strb.w	r2, [r0], #1
    for (i = 0; i < count; i++)
  66:	e7d5      	b.n	14 <xorbuf.constprop.0+0x14>

Disassembly of section .text.wc_Des_CbcEncrypt:

00000000 <wc_Des_CbcEncrypt>:

    int wc_Des_CbcEncrypt(Des* des, byte* out, const byte* in, word32 sz)
    {
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	f023 0607 	bic.w	r6, r3, #7
   6:	4605      	mov	r5, r0
   8:	460f      	mov	r7, r1
   a:	4614      	mov	r4, r2
   c:	4416      	add	r6, r2
        word32 blocks = sz / DES_BLOCK_SIZE;

        while (blocks--) {
   e:	42b4      	cmp	r4, r6
  10:	d101      	bne.n	16 <wc_Des_CbcEncrypt+0x16>

            out += DES_BLOCK_SIZE;
            in  += DES_BLOCK_SIZE;
        }
        return 0;
    }
  12:	2000      	movs	r0, #0
  14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            xorbuf((byte*)des->reg, in, DES_BLOCK_SIZE);
  16:	4621      	mov	r1, r4
  18:	4628      	mov	r0, r5
  1a:	f7ff fffe 	bl	0 <wc_Des_CbcEncrypt>
            DesProcessBlock(des, (byte*)des->reg, (byte*)des->reg);
  1e:	462a      	mov	r2, r5
  20:	4629      	mov	r1, r5
  22:	4628      	mov	r0, r5
  24:	f7ff fffe 	bl	0 <wc_Des_CbcEncrypt>
            XMEMCPY(out, des->reg, DES_BLOCK_SIZE);
  28:	4638      	mov	r0, r7
  2a:	2208      	movs	r2, #8
  2c:	4629      	mov	r1, r5
  2e:	f7ff fffe 	bl	0 <memcpy>
            out += DES_BLOCK_SIZE;
  32:	3708      	adds	r7, #8
            in  += DES_BLOCK_SIZE;
  34:	3408      	adds	r4, #8
  36:	e7ea      	b.n	e <wc_Des_CbcEncrypt+0xe>

Disassembly of section .text.wc_Des_CbcDecrypt:

00000000 <wc_Des_CbcDecrypt>:

    int wc_Des_CbcDecrypt(Des* des, byte* out, const byte* in, word32 sz)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	f023 0707 	bic.w	r7, r3, #7
   8:	4605      	mov	r5, r0
   a:	460e      	mov	r6, r1
   c:	4614      	mov	r4, r2
   e:	4417      	add	r7, r2
        word32 blocks = sz / DES_BLOCK_SIZE;

        while (blocks--) {
            XMEMCPY(des->tmp, in, DES_BLOCK_SIZE);
  10:	f100 0808 	add.w	r8, r0, #8
        while (blocks--) {
  14:	42bc      	cmp	r4, r7
  16:	d102      	bne.n	1e <wc_Des_CbcDecrypt+0x1e>

            out += DES_BLOCK_SIZE;
            in  += DES_BLOCK_SIZE;
        }
        return 0;
    }
  18:	2000      	movs	r0, #0
  1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            XMEMCPY(des->tmp, in, DES_BLOCK_SIZE);
  1e:	4621      	mov	r1, r4
  20:	2208      	movs	r2, #8
  22:	4640      	mov	r0, r8
  24:	f7ff fffe 	bl	0 <memcpy>
            DesProcessBlock(des, (byte*)des->tmp, out);
  28:	4632      	mov	r2, r6
  2a:	4641      	mov	r1, r8
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <wc_Des_CbcDecrypt>
            xorbuf(out, (byte*)des->reg, DES_BLOCK_SIZE);
  32:	4630      	mov	r0, r6
  34:	4629      	mov	r1, r5
  36:	f7ff fffe 	bl	0 <wc_Des_CbcDecrypt>
            XMEMCPY(des->reg, des->tmp, DES_BLOCK_SIZE);
  3a:	2208      	movs	r2, #8
  3c:	4641      	mov	r1, r8
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <memcpy>
            out += DES_BLOCK_SIZE;
  44:	3608      	adds	r6, #8
            in  += DES_BLOCK_SIZE;
  46:	3408      	adds	r4, #8
  48:	e7e4      	b.n	14 <wc_Des_CbcDecrypt+0x14>

Disassembly of section .text.wc_Des3_CbcEncrypt:

00000000 <wc_Des3_CbcEncrypt>:

    int wc_Des3_CbcEncrypt(Des3* des, byte* out, const byte* in, word32 sz)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4614      	mov	r4, r2
        word32 blocks;

        if (des == NULL || out == NULL || in == NULL) {
   8:	4607      	mov	r7, r0
   a:	b1e0      	cbz	r0, 46 <wc_Des3_CbcEncrypt+0x46>
   c:	b1d9      	cbz	r1, 46 <wc_Des3_CbcEncrypt+0x46>
   e:	b1d2      	cbz	r2, 46 <wc_Des3_CbcEncrypt+0x46>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        blocks = sz / DES_BLOCK_SIZE;
        while (blocks--) {
  10:	f023 0307 	bic.w	r3, r3, #7
  14:	18d5      	adds	r5, r2, r3
            xorbuf((byte*)des->reg, in, DES_BLOCK_SIZE);
  16:	f500 78c0 	add.w	r8, r0, #384	; 0x180
        while (blocks--) {
  1a:	42ac      	cmp	r4, r5
  1c:	d102      	bne.n	24 <wc_Des3_CbcEncrypt+0x24>
            XMEMCPY(out, des->reg, DES_BLOCK_SIZE);

            out += DES_BLOCK_SIZE;
            in  += DES_BLOCK_SIZE;
        }
        return 0;
  1e:	2000      	movs	r0, #0
    }
  20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            xorbuf((byte*)des->reg, in, DES_BLOCK_SIZE);
  24:	4621      	mov	r1, r4
  26:	4640      	mov	r0, r8
  28:	f7ff fffe 	bl	0 <wc_Des3_CbcEncrypt>
            Des3ProcessBlock(des, (byte*)des->reg, (byte*)des->reg);
  2c:	4642      	mov	r2, r8
  2e:	4641      	mov	r1, r8
  30:	4638      	mov	r0, r7
  32:	f7ff fffe 	bl	0 <wc_Des3_CbcEncrypt>
            XMEMCPY(out, des->reg, DES_BLOCK_SIZE);
  36:	4630      	mov	r0, r6
  38:	2208      	movs	r2, #8
  3a:	4641      	mov	r1, r8
  3c:	f7ff fffe 	bl	0 <memcpy>
            out += DES_BLOCK_SIZE;
  40:	3608      	adds	r6, #8
            in  += DES_BLOCK_SIZE;
  42:	3408      	adds	r4, #8
  44:	e7e9      	b.n	1a <wc_Des3_CbcEncrypt+0x1a>
            return BAD_FUNC_ARG;
  46:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  4a:	e7e9      	b.n	20 <wc_Des3_CbcEncrypt+0x20>

Disassembly of section .text.wc_Des3_CbcDecrypt:

00000000 <wc_Des3_CbcDecrypt>:


    int wc_Des3_CbcDecrypt(Des3* des, byte* out, const byte* in, word32 sz)
    {
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	460e      	mov	r6, r1
   6:	4614      	mov	r4, r2
        word32 blocks;

        if (des == NULL || out == NULL || in == NULL) {
   8:	4607      	mov	r7, r0
   a:	b318      	cbz	r0, 54 <wc_Des3_CbcDecrypt+0x54>
   c:	b311      	cbz	r1, 54 <wc_Des3_CbcDecrypt+0x54>
   e:	b30a      	cbz	r2, 54 <wc_Des3_CbcDecrypt+0x54>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        blocks = sz / DES_BLOCK_SIZE;
        while (blocks--) {
  10:	f023 0307 	bic.w	r3, r3, #7
  14:	18d5      	adds	r5, r2, r3
            XMEMCPY(des->tmp, in, DES_BLOCK_SIZE);
  16:	f500 78c4 	add.w	r8, r0, #392	; 0x188
            Des3ProcessBlock(des, (byte*)des->tmp, out);
            xorbuf(out, (byte*)des->reg, DES_BLOCK_SIZE);
  1a:	f500 79c0 	add.w	r9, r0, #384	; 0x180
        while (blocks--) {
  1e:	42ac      	cmp	r4, r5
  20:	d102      	bne.n	28 <wc_Des3_CbcDecrypt+0x28>
            XMEMCPY(des->reg, des->tmp, DES_BLOCK_SIZE);

            out += DES_BLOCK_SIZE;
            in  += DES_BLOCK_SIZE;
        }
        return 0;
  22:	2000      	movs	r0, #0
    }
  24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            XMEMCPY(des->tmp, in, DES_BLOCK_SIZE);
  28:	4621      	mov	r1, r4
  2a:	2208      	movs	r2, #8
  2c:	4640      	mov	r0, r8
  2e:	f7ff fffe 	bl	0 <memcpy>
            Des3ProcessBlock(des, (byte*)des->tmp, out);
  32:	4632      	mov	r2, r6
  34:	4641      	mov	r1, r8
  36:	4638      	mov	r0, r7
  38:	f7ff fffe 	bl	0 <wc_Des3_CbcDecrypt>
            xorbuf(out, (byte*)des->reg, DES_BLOCK_SIZE);
  3c:	4630      	mov	r0, r6
  3e:	4649      	mov	r1, r9
  40:	f7ff fffe 	bl	0 <wc_Des3_CbcDecrypt>
            XMEMCPY(des->reg, des->tmp, DES_BLOCK_SIZE);
  44:	2208      	movs	r2, #8
  46:	4641      	mov	r1, r8
  48:	4648      	mov	r0, r9
  4a:	f7ff fffe 	bl	0 <memcpy>
            out += DES_BLOCK_SIZE;
  4e:	3608      	adds	r6, #8
            in  += DES_BLOCK_SIZE;
  50:	3408      	adds	r4, #8
  52:	e7e4      	b.n	1e <wc_Des3_CbcDecrypt+0x1e>
            return BAD_FUNC_ARG;
  54:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  58:	e7e4      	b.n	24 <wc_Des3_CbcDecrypt+0x24>

Disassembly of section .text.wc_Des_SetIV:

00000000 <wc_Des_SetIV>:
#endif /* NEED_SOFT_DES */


void wc_Des_SetIV(Des* des, const byte* iv)
{
    if (des && iv) {
   0:	b128      	cbz	r0, e <wc_Des_SetIV+0xe>
        XMEMCPY(des->reg, iv, DES_BLOCK_SIZE);
   2:	2208      	movs	r2, #8
    if (des && iv) {
   4:	b109      	cbz	r1, a <wc_Des_SetIV+0xa>
        XMEMCPY(des->reg, iv, DES_BLOCK_SIZE);
   6:	f7ff bffe 	b.w	0 <memcpy>
    #if defined(STM32_CRYPTO) && !defined(STM32_CRYPTO_AES_ONLY) && defined(STM32_HAL_V2)
        ByteReverseWords(des->reg, des->reg, DES_BLOCK_SIZE);
    #endif
    }
    else if (des)
        XMEMSET(des->reg,  0, DES_BLOCK_SIZE);
   a:	f7ff bffe 	b.w	0 <memset>
}
   e:	4770      	bx	lr

Disassembly of section .text.wc_Des_SetKey:

00000000 <wc_Des_SetKey>:
    {
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4606      	mov	r6, r0
   4:	460c      	mov	r4, r1
   6:	461d      	mov	r5, r3
        wc_Des_SetIV(des, iv);
   8:	4611      	mov	r1, r2
   a:	f7ff fffe 	bl	0 <wc_Des_SetKey>
        return DesSetKey(key, dir, des->key);
   e:	f106 0210 	add.w	r2, r6, #16
  12:	4629      	mov	r1, r5
  14:	4620      	mov	r0, r4
    }
  16:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        return DesSetKey(key, dir, des->key);
  1a:	f7ff bffe 	b.w	0 <wc_Des_SetKey>

Disassembly of section .text.wc_Des3_SetIV:

00000000 <wc_Des3_SetIV>:

int wc_Des3_SetIV(Des3* des, const byte* iv)
{
   0:	b510      	push	{r4, lr}
    if (des == NULL) {
   2:	b150      	cbz	r0, 1a <wc_Des3_SetIV+0x1a>
        return BAD_FUNC_ARG;
    }
    if (iv) {
        XMEMCPY(des->reg, iv, DES_BLOCK_SIZE);
   4:	f500 70c0 	add.w	r0, r0, #384	; 0x180
   8:	2208      	movs	r2, #8
    if (iv) {
   a:	b119      	cbz	r1, 14 <wc_Des3_SetIV+0x14>
        XMEMCPY(des->reg, iv, DES_BLOCK_SIZE);
   c:	f7ff fffe 	bl	0 <memcpy>
    #endif
    }
    else
        XMEMSET(des->reg,  0, DES_BLOCK_SIZE);

    return 0;
  10:	2000      	movs	r0, #0
}
  12:	bd10      	pop	{r4, pc}
        XMEMSET(des->reg,  0, DES_BLOCK_SIZE);
  14:	f7ff fffe 	bl	0 <memset>
  18:	e7fa      	b.n	10 <wc_Des3_SetIV+0x10>
        return BAD_FUNC_ARG;
  1a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1e:	e7f8      	b.n	12 <wc_Des3_SetIV+0x12>

Disassembly of section .text.wc_Des3_SetKey:

00000000 <wc_Des3_SetKey>:
    {
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460e      	mov	r6, r1
   4:	4617      	mov	r7, r2
   6:	461d      	mov	r5, r3
        if (des == NULL || key == NULL || dir < 0) {
   8:	4604      	mov	r4, r0
   a:	b3b8      	cbz	r0, 7c <wc_Des3_SetKey+0x7c>
   c:	b3b1      	cbz	r1, 7c <wc_Des3_SetKey+0x7c>
   e:	2b00      	cmp	r3, #0
  10:	db34      	blt.n	7c <wc_Des3_SetKey+0x7c>
        XMEMSET(des->key, 0, sizeof(*(des->key)));
  12:	2280      	movs	r2, #128	; 0x80
  14:	2100      	movs	r1, #0
  16:	f7ff fffe 	bl	0 <memset>
        XMEMSET(des->reg, 0, sizeof(*(des->reg)));
  1a:	2204      	movs	r2, #4
  1c:	2100      	movs	r1, #0
  1e:	f504 70c0 	add.w	r0, r4, #384	; 0x180
  22:	f7ff fffe 	bl	0 <memset>
        XMEMSET(des->tmp, 0, sizeof(*(des->tmp)));
  26:	2204      	movs	r2, #4
  28:	2100      	movs	r1, #0
  2a:	f504 70c4 	add.w	r0, r4, #392	; 0x188
  2e:	f7ff fffe 	bl	0 <memset>
        ret = DesSetKey(key + (dir == DES_ENCRYPTION ? 0:16), dir, des->key[0]);
  32:	2d00      	cmp	r5, #0
  34:	bf0c      	ite	eq
  36:	2000      	moveq	r0, #0
  38:	2010      	movne	r0, #16
  3a:	4622      	mov	r2, r4
  3c:	4629      	mov	r1, r5
  3e:	4430      	add	r0, r6
  40:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
        if (ret != 0)
  44:	b9e0      	cbnz	r0, 80 <wc_Des3_SetKey+0x80>
        ret = DesSetKey(key + 8, !dir, des->key[1]);
  46:	fab5 f185 	clz	r1, r5
  4a:	f104 0280 	add.w	r2, r4, #128	; 0x80
  4e:	0949      	lsrs	r1, r1, #5
  50:	f106 0008 	add.w	r0, r6, #8
  54:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
        if (ret != 0)
  58:	b990      	cbnz	r0, 80 <wc_Des3_SetKey+0x80>
        ret = DesSetKey(key + (dir == DES_DECRYPTION ? 0:16), dir, des->key[2]);
  5a:	2d01      	cmp	r5, #1
  5c:	bf0c      	ite	eq
  5e:	2000      	moveq	r0, #0
  60:	2010      	movne	r0, #16
  62:	f504 7280 	add.w	r2, r4, #256	; 0x100
  66:	4629      	mov	r1, r5
  68:	4430      	add	r0, r6
  6a:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
        if (ret != 0)
  6e:	b938      	cbnz	r0, 80 <wc_Des3_SetKey+0x80>
        return wc_Des3_SetIV(des, iv);
  70:	4639      	mov	r1, r7
  72:	4620      	mov	r0, r4
    }
  74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        return wc_Des3_SetIV(des, iv);
  78:	f7ff bffe 	b.w	0 <wc_Des3_SetKey>
            return BAD_FUNC_ARG;
  7c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }
  80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text.wc_Des3Init:

00000000 <wc_Des3Init>:

/* Initialize Des3 for use with async device */
int wc_Des3Init(Des3* des3, void* heap, int devId)
{
    int ret = 0;
    if (des3 == NULL)
   0:	b118      	cbz	r0, a <wc_Des3Init+0xa>
        return BAD_FUNC_ARG;

    des3->heap = heap;
   2:	f8c0 1190 	str.w	r1, [r0, #400]	; 0x190
#if defined(WOLFSSL_CHECK_MEM_ZERO) && (defined(WOLF_CRYPTO_CB) || \
        (defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_3DES)))
    wc_MemZero_Add("DES3 devKey", &des3->devKey, sizeof(des3->devKey));
#endif

    return ret;
   6:	2000      	movs	r0, #0
   8:	4770      	bx	lr
        return BAD_FUNC_ARG;
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
   e:	4770      	bx	lr

Disassembly of section .text.wc_Des3Free:

00000000 <wc_Des3Free>:
    ForceZero(des3->devKey, sizeof(des3->devKey));
#endif
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(des3, sizeof(Des3));
#endif
}
   0:	4770      	bx	lr

dh.o:     file format elf32-littlearm


ecc.o:     file format elf32-littlearm


Disassembly of section .text.wc_ecc_cmp_param:

00000000 <wc_ecc_cmp_param>:
 * parameter for equality.
 * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR
 * Returns MP_EQ on success, negative on error */
static int wc_ecc_cmp_param(const char* curveParam,
                            const byte* param, word32 paramSz, int encType)
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4607      	mov	r7, r0
   6:	4691      	mov	r9, r2
    mp_int* b = NULL;
#else
    mp_int  a[1], b[1];
#endif

    if (param == NULL || curveParam == NULL)
   8:	4688      	mov	r8, r1
   a:	2900      	cmp	r1, #0
   c:	d04d      	beq.n	aa <wc_ecc_cmp_param+0xaa>
   e:	2800      	cmp	r0, #0
  10:	d04b      	beq.n	aa <wc_ecc_cmp_param+0xaa>
        return BAD_FUNC_ARG;

    if (encType == WC_TYPE_HEX_STR)
  12:	2b01      	cmp	r3, #1
  14:	d104      	bne.n	20 <wc_ecc_cmp_param+0x20>
    XFREE(b, NULL, DYNAMIC_TYPE_ECC);
    XFREE(a, NULL, DYNAMIC_TYPE_ECC);
#endif

    return err;
}
  16:	b003      	add	sp, #12
  18:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return XSTRNCMP(curveParam, (char*) param, paramSz);
  1c:	f7ff bffe 	b.w	0 <strncmp>
    a = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
  20:	2068      	movs	r0, #104	; 0x68
  22:	f7ff fffe 	bl	0 <malloc>
    if (a == NULL)
  26:	4605      	mov	r5, r0
  28:	b138      	cbz	r0, 3a <wc_ecc_cmp_param+0x3a>
    b = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
  2a:	2068      	movs	r0, #104	; 0x68
  2c:	f7ff fffe 	bl	0 <malloc>
    if (b == NULL) {
  30:	4606      	mov	r6, r0
  32:	b928      	cbnz	r0, 40 <wc_ecc_cmp_param+0x40>
        XFREE(a, NULL, DYNAMIC_TYPE_ECC);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <free>
        return MEMORY_E;
  3a:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  3e:	e00f      	b.n	60 <wc_ecc_cmp_param+0x60>
    if ((err = mp_init_multi(a, b, NULL, NULL, NULL, NULL)) != MP_OKAY) {
  40:	2300      	movs	r3, #0
  42:	4601      	mov	r1, r0
  44:	e9cd 3300 	strd	r3, r3, [sp]
  48:	461a      	mov	r2, r3
  4a:	4628      	mov	r0, r5
  4c:	f7ff fffe 	bl	0 <mp_init_multi>
  50:	4604      	mov	r4, r0
  52:	b148      	cbz	r0, 68 <wc_ecc_cmp_param+0x68>
        XFREE(a, NULL, DYNAMIC_TYPE_ECC);
  54:	4628      	mov	r0, r5
  56:	f7ff fffe 	bl	0 <free>
        XFREE(b, NULL, DYNAMIC_TYPE_ECC);
  5a:	4630      	mov	r0, r6
    XFREE(a, NULL, DYNAMIC_TYPE_ECC);
  5c:	f7ff fffe 	bl	0 <free>
}
  60:	4620      	mov	r0, r4
  62:	b003      	add	sp, #12
  64:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        err = mp_read_unsigned_bin(a, param, paramSz);
  68:	464a      	mov	r2, r9
  6a:	4641      	mov	r1, r8
  6c:	4628      	mov	r0, r5
  6e:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
    if (err == MP_OKAY)
  72:	4604      	mov	r4, r0
  74:	b970      	cbnz	r0, 94 <wc_ecc_cmp_param+0x94>
        err = mp_read_radix(b, curveParam, MP_RADIX_HEX);
  76:	2210      	movs	r2, #16
  78:	4639      	mov	r1, r7
  7a:	4630      	mov	r0, r6
  7c:	f7ff fffe 	bl	0 <mp_read_radix>
    if (err == MP_OKAY) {
  80:	4604      	mov	r4, r0
  82:	b938      	cbnz	r0, 94 <wc_ecc_cmp_param+0x94>
        if (mp_cmp(a, b) != MP_EQ) {
  84:	4631      	mov	r1, r6
  86:	4628      	mov	r0, r5
  88:	f7ff fffe 	bl	0 <mp_cmp>
  8c:	1e04      	subs	r4, r0, #0
  8e:	bf18      	it	ne
  90:	2401      	movne	r4, #1
  92:	4264      	negs	r4, r4
    mp_clear(a);
  94:	4628      	mov	r0, r5
  96:	f7ff fffe 	bl	0 <mp_clear>
    mp_clear(b);
  9a:	4630      	mov	r0, r6
  9c:	f7ff fffe 	bl	0 <mp_clear>
    XFREE(b, NULL, DYNAMIC_TYPE_ECC);
  a0:	4630      	mov	r0, r6
  a2:	f7ff fffe 	bl	0 <free>
    XFREE(a, NULL, DYNAMIC_TYPE_ECC);
  a6:	4628      	mov	r0, r5
  a8:	e7d8      	b.n	5c <wc_ecc_cmp_param+0x5c>
        return BAD_FUNC_ARG;
  aa:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  ae:	e7d7      	b.n	60 <wc_ecc_cmp_param+0x60>

Disassembly of section .text._ecc_is_point.constprop.0:

00000000 <_ecc_is_point.constprop.0>:
#if !defined(WOLFSSL_ATECC508A) && !defined(WOLFSSL_ATECC608A) && \
    !defined(WOLFSSL_CRYPTOCELL) && !defined(WOLFSSL_SE050) && \
    !defined(WOLF_CRYPTO_CB_ONLY_ECC) && !defined(WOLFSSL_STM32_PKA)

/* is ecc point on curve described by dp ? */
static int _ecc_is_point(ecc_point* ecp, mp_int* a, mp_int* b, mp_int* prime)
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4681      	mov	r9, r0
#else
   mp_int  t1[1], t2[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
   t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
   6:	2068      	movs	r0, #104	; 0x68
static int _ecc_is_point(ecc_point* ecp, mp_int* a, mp_int* b, mp_int* prime)
   8:	4688      	mov	r8, r1
   a:	4617      	mov	r7, r2
   t1 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
   c:	f7ff fffe 	bl	0 <malloc>
   if (t1 == NULL)
  10:	4605      	mov	r5, r0
  12:	b138      	cbz	r0, 24 <_ecc_is_point.constprop.0+0x24>
       return MEMORY_E;
   t2 = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
  14:	2068      	movs	r0, #104	; 0x68
  16:	f7ff fffe 	bl	0 <malloc>
   if (t2 == NULL) {
  1a:	4606      	mov	r6, r0
  1c:	b928      	cbnz	r0, 2a <_ecc_is_point.constprop.0+0x2a>
       XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
  1e:	4628      	mov	r0, r5
  20:	f7ff fffe 	bl	0 <free>
       return MEMORY_E;
  24:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  28:	e00f      	b.n	4a <_ecc_is_point.constprop.0+0x4a>
       return MEMORY_E;
   }
#endif

   if ((err = mp_init_multi(t1, t2, NULL, NULL, NULL, NULL)) != MP_OKAY) {
  2a:	2300      	movs	r3, #0
  2c:	4601      	mov	r1, r0
  2e:	e9cd 3300 	strd	r3, r3, [sp]
  32:	461a      	mov	r2, r3
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <mp_init_multi>
  3a:	4604      	mov	r4, r0
  3c:	b148      	cbz	r0, 52 <_ecc_is_point.constprop.0+0x52>
   mp_clear(t2);

   RESTORE_VECTOR_REGISTERS();

#ifdef WOLFSSL_SMALL_STACK
   XFREE(t2, NULL, DYNAMIC_TYPE_ECC);
  3e:	4630      	mov	r0, r6
  40:	f7ff fffe 	bl	0 <free>
   XFREE(t1, NULL, DYNAMIC_TYPE_ECC);
  44:	4628      	mov	r0, r5
  46:	f7ff fffe 	bl	0 <free>
   (void)ecp;
   (void)prime;
#endif
   return WC_KEY_SIZE_E;
#endif
}
  4a:	4620      	mov	r0, r4
  4c:	b003      	add	sp, #12
  4e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
       err = mp_sqr(ecp->y, t1);
  52:	4629      	mov	r1, r5
  54:	f109 0068 	add.w	r0, r9, #104	; 0x68
  58:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
  5c:	4604      	mov	r4, r0
  5e:	2800      	cmp	r0, #0
  60:	d159      	bne.n	116 <_ecc_is_point.constprop.0+0x116>
       err = mp_sqr(ecp->x, t2);
  62:	4631      	mov	r1, r6
  64:	4648      	mov	r0, r9
  66:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
  6a:	4604      	mov	r4, r0
  6c:	2800      	cmp	r0, #0
  6e:	d152      	bne.n	116 <_ecc_is_point.constprop.0+0x116>
       err = mp_mod(t2, prime, t2);
  70:	4632      	mov	r2, r6
  72:	4639      	mov	r1, r7
  74:	4630      	mov	r0, r6
  76:	f7ff fffe 	bl	0 <mp_mod>
   if (err == MP_OKAY)
  7a:	4604      	mov	r4, r0
  7c:	2800      	cmp	r0, #0
  7e:	d14a      	bne.n	116 <_ecc_is_point.constprop.0+0x116>
       err = mp_mul(ecp->x, t2, t2);
  80:	4632      	mov	r2, r6
  82:	4631      	mov	r1, r6
  84:	4648      	mov	r0, r9
  86:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
  8a:	4604      	mov	r4, r0
  8c:	2800      	cmp	r0, #0
  8e:	d142      	bne.n	116 <_ecc_is_point.constprop.0+0x116>
       err = mp_submod(t1, t2, prime, t1);
  90:	462b      	mov	r3, r5
  92:	463a      	mov	r2, r7
  94:	4631      	mov	r1, r6
  96:	4628      	mov	r0, r5
  98:	f7ff fffe 	bl	0 <mp_submod>
      if (err == MP_OKAY)
  9c:	4604      	mov	r4, r0
  9e:	bbd0      	cbnz	r0, 116 <_ecc_is_point.constprop.0+0x116>
          err = mp_add(t1, ecp->x, t1);
  a0:	462a      	mov	r2, r5
  a2:	4649      	mov	r1, r9
  a4:	4628      	mov	r0, r5
  a6:	f7ff fffe 	bl	0 <mp_add>
      if (err == MP_OKAY)
  aa:	4604      	mov	r4, r0
  ac:	bb98      	cbnz	r0, 116 <_ecc_is_point.constprop.0+0x116>
          err = mp_add(t1, ecp->x, t1);
  ae:	462a      	mov	r2, r5
  b0:	4649      	mov	r1, r9
  b2:	4628      	mov	r0, r5
  b4:	f7ff fffe 	bl	0 <mp_add>
      if (err == MP_OKAY)
  b8:	4604      	mov	r4, r0
  ba:	bb60      	cbnz	r0, 116 <_ecc_is_point.constprop.0+0x116>
          err = mp_add(t1, ecp->x, t1);
  bc:	462a      	mov	r2, r5
  be:	4649      	mov	r1, r9
  c0:	4628      	mov	r0, r5
  c2:	f7ff fffe 	bl	0 <mp_add>
      if (err == MP_OKAY)
  c6:	4604      	mov	r4, r0
  c8:	bb28      	cbnz	r0, 116 <_ecc_is_point.constprop.0+0x116>
          err = mp_mod(t1, prime, t1);
  ca:	462a      	mov	r2, r5
  cc:	4639      	mov	r1, r7
  ce:	4628      	mov	r0, r5
  d0:	f7ff fffe 	bl	0 <mp_mod>
      err = mp_add(t1, prime, t1);
  d4:	4604      	mov	r4, r0
   while (err == MP_OKAY && mp_isneg(t1)) {
  d6:	b9f0      	cbnz	r0, 116 <_ecc_is_point.constprop.0+0x116>
  d8:	686b      	ldr	r3, [r5, #4]
  da:	b973      	cbnz	r3, fa <_ecc_is_point.constprop.0+0xfa>
   while (err == MP_OKAY && mp_cmp(t1, prime) != MP_LT) {
  dc:	4639      	mov	r1, r7
  de:	4628      	mov	r0, r5
  e0:	f7ff fffe 	bl	0 <mp_cmp>
  e4:	3001      	adds	r0, #1
  e6:	d10e      	bne.n	106 <_ecc_is_point.constprop.0+0x106>
       if (mp_cmp(t1, b) != MP_EQ) {
  e8:	4641      	mov	r1, r8
  ea:	4628      	mov	r0, r5
  ec:	f7ff fffe 	bl	0 <mp_cmp>
          err = IS_POINT_E;
  f0:	1e04      	subs	r4, r0, #0
  f2:	bf18      	it	ne
  f4:	f06f 04d5 	mvnne.w	r4, #213	; 0xd5
  f8:	e00d      	b.n	116 <_ecc_is_point.constprop.0+0x116>
      err = mp_add(t1, prime, t1);
  fa:	462a      	mov	r2, r5
  fc:	4639      	mov	r1, r7
  fe:	4628      	mov	r0, r5
 100:	f7ff fffe 	bl	0 <mp_add>
 104:	e7e6      	b.n	d4 <_ecc_is_point.constprop.0+0xd4>
      err = mp_sub(t1, prime, t1);
 106:	462a      	mov	r2, r5
 108:	4639      	mov	r1, r7
 10a:	4628      	mov	r0, r5
 10c:	f7ff fffe 	bl	0 <mp_sub>
   while (err == MP_OKAY && mp_cmp(t1, prime) != MP_LT) {
 110:	4604      	mov	r4, r0
 112:	2800      	cmp	r0, #0
 114:	d0e2      	beq.n	dc <_ecc_is_point.constprop.0+0xdc>
   mp_clear(t1);
 116:	4628      	mov	r0, r5
 118:	f7ff fffe 	bl	0 <mp_clear>
   mp_clear(t2);
 11c:	4630      	mov	r0, r6
 11e:	f7ff fffe 	bl	0 <mp_clear>
 122:	e78c      	b.n	3e <_ecc_is_point.constprop.0+0x3e>

Disassembly of section .text.wc_ecc_new_point_ex.constprop.0:

00000000 <wc_ecc_new_point_ex.constprop.0>:
static int wc_ecc_new_point_ex(ecc_point** point, void* heap)
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   p = *point;
   2:	6804      	ldr	r4, [r0, #0]
static int wc_ecc_new_point_ex(ecc_point** point, void* heap)
   4:	4606      	mov	r6, r0
   if (p == NULL) {
   6:	b92c      	cbnz	r4, 14 <wc_ecc_new_point_ex.constprop.0+0x14>
      p = (ecc_point*)XMALLOC(sizeof(ecc_point), heap, DYNAMIC_TYPE_ECC);
   8:	f44f 709c 	mov.w	r0, #312	; 0x138
   c:	f7ff fffe 	bl	0 <malloc>
   if (p == NULL) {
  10:	4604      	mov	r4, r0
  12:	b1c8      	cbz	r0, 48 <wc_ecc_new_point_ex.constprop.0+0x48>
   XMEMSET(p, 0, sizeof(ecc_point));
  14:	f44f 729c 	mov.w	r2, #312	; 0x138
  18:	2100      	movs	r1, #0
  1a:	4620      	mov	r0, r4
  1c:	f7ff fffe 	bl	0 <memset>
   err = mp_init_multi(p->x, p->y, p->z, NULL, NULL, NULL);
  20:	2300      	movs	r3, #0
  22:	e9cd 3300 	strd	r3, r3, [sp]
  26:	f104 02d0 	add.w	r2, r4, #208	; 0xd0
  2a:	f104 0168 	add.w	r1, r4, #104	; 0x68
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <mp_init_multi>
   if (err != MP_OKAY) {
  34:	4605      	mov	r5, r0
  36:	b128      	cbz	r0, 44 <wc_ecc_new_point_ex.constprop.0+0x44>
      XFREE(p, heap, DYNAMIC_TYPE_ECC);
  38:	4620      	mov	r0, r4
  3a:	f7ff fffe 	bl	0 <free>
}
  3e:	4628      	mov	r0, r5
  40:	b002      	add	sp, #8
  42:	bd70      	pop	{r4, r5, r6, pc}
   *point = p;
  44:	6034      	str	r4, [r6, #0]
   return err;
  46:	e7fa      	b.n	3e <wc_ecc_new_point_ex.constprop.0+0x3e>
      return MEMORY_E;
  48:	f06f 057c 	mvn.w	r5, #124	; 0x7c
  4c:	e7f7      	b.n	3e <wc_ecc_new_point_ex.constprop.0+0x3e>

Disassembly of section .text.wc_ecc_del_point_ex.constprop.0:

00000000 <wc_ecc_del_point_ex.constprop.0>:
static void wc_ecc_del_point_ex(ecc_point* p, void* heap)
   0:	b510      	push	{r4, lr}
   if (p != NULL) {
   2:	4604      	mov	r4, r0
   4:	b170      	cbz	r0, 24 <wc_ecc_del_point_ex.constprop.0+0x24>
      mp_clear(p->x);
   6:	f7ff fffe 	bl	0 <mp_clear>
      mp_clear(p->y);
   a:	f104 0068 	add.w	r0, r4, #104	; 0x68
   e:	f7ff fffe 	bl	0 <mp_clear>
      mp_clear(p->z);
  12:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
  16:	f7ff fffe 	bl	0 <mp_clear>
      XFREE(p, heap, DYNAMIC_TYPE_ECC);
  1a:	4620      	mov	r0, r4
}
  1c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      XFREE(p, heap, DYNAMIC_TYPE_ECC);
  20:	f7ff bffe 	b.w	0 <free>
}
  24:	bd10      	pop	{r4, pc}

Disassembly of section .text.ecc_point_to_mont.constprop.0:

00000000 <ecc_point_to_mont.constprop.0>:
static int ecc_point_to_mont(ecc_point* p, ecc_point* r, mp_int* modulus,
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4606      	mov	r6, r0
   NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
   6:	2068      	movs	r0, #104	; 0x68
static int ecc_point_to_mont(ecc_point* p, ecc_point* r, mp_int* modulus,
   8:	460f      	mov	r7, r1
   a:	4690      	mov	r8, r2
   NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
   c:	f7ff fffe 	bl	0 <malloc>
  10:	4605      	mov	r5, r0
  12:	2800      	cmp	r0, #0
  14:	d04c      	beq.n	b0 <ecc_point_to_mont.constprop.0+0xb0>
  16:	2268      	movs	r2, #104	; 0x68
  18:	2100      	movs	r1, #0
  1a:	f7ff fffe 	bl	0 <memset>
       err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
  1e:	4628      	mov	r0, r5
  20:	f7ff fffe 	bl	0 <mp_init>
   if (err == MP_OKAY) {
  24:	4604      	mov	r4, r0
  26:	bb10      	cbnz	r0, 6e <ecc_point_to_mont.constprop.0+0x6e>
       err = mp_montgomery_calc_normalization(mu, modulus);
  28:	4641      	mov	r1, r8
  2a:	4628      	mov	r0, r5
  2c:	f7ff fffe 	bl	0 <mp_montgomery_calc_normalization>
       if (err == MP_OKAY) {
  30:	4604      	mov	r4, r0
  32:	b9c8      	cbnz	r0, 68 <ecc_point_to_mont.constprop.0+0x68>
           if (mp_cmp_d(mu, 1) == MP_EQ) {
  34:	2101      	movs	r1, #1
  36:	4628      	mov	r0, r5
  38:	f7ff fffe 	bl	0 <mp_cmp_d>
  3c:	b9d8      	cbnz	r0, 76 <ecc_point_to_mont.constprop.0+0x76>
               err = mp_copy(p->x, r->x);
  3e:	4639      	mov	r1, r7
  40:	4630      	mov	r0, r6
  42:	f7ff fffe 	bl	0 <mp_copy>
               if (err == MP_OKAY)
  46:	4604      	mov	r4, r0
  48:	b970      	cbnz	r0, 68 <ecc_point_to_mont.constprop.0+0x68>
                   err = mp_copy(p->y, r->y);
  4a:	f107 0168 	add.w	r1, r7, #104	; 0x68
  4e:	f106 0068 	add.w	r0, r6, #104	; 0x68
  52:	f7ff fffe 	bl	0 <mp_copy>
               if (err == MP_OKAY)
  56:	4604      	mov	r4, r0
  58:	b930      	cbnz	r0, 68 <ecc_point_to_mont.constprop.0+0x68>
                   err = mp_copy(p->z, r->z);
  5a:	f107 01d0 	add.w	r1, r7, #208	; 0xd0
  5e:	f106 00d0 	add.w	r0, r6, #208	; 0xd0
  62:	f7ff fffe 	bl	0 <mp_copy>
                   err = mp_mulmod(p->z, mu, modulus, r->z);
  66:	4604      	mov	r4, r0
       mp_clear(mu);
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <mp_clear>
   FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
  6e:	4628      	mov	r0, r5
  70:	f7ff fffe 	bl	0 <free>
  74:	e01e      	b.n	b4 <ecc_point_to_mont.constprop.0+0xb4>
               err = mp_mulmod(p->x, mu, modulus, r->x);
  76:	463b      	mov	r3, r7
  78:	4642      	mov	r2, r8
  7a:	4629      	mov	r1, r5
  7c:	4630      	mov	r0, r6
  7e:	f7ff fffe 	bl	0 <mp_mulmod>
               if (err == MP_OKAY)
  82:	4604      	mov	r4, r0
  84:	2800      	cmp	r0, #0
  86:	d1ef      	bne.n	68 <ecc_point_to_mont.constprop.0+0x68>
                   err = mp_mulmod(p->y, mu, modulus, r->y);
  88:	f107 0368 	add.w	r3, r7, #104	; 0x68
  8c:	4642      	mov	r2, r8
  8e:	4629      	mov	r1, r5
  90:	f106 0068 	add.w	r0, r6, #104	; 0x68
  94:	f7ff fffe 	bl	0 <mp_mulmod>
               if (err == MP_OKAY)
  98:	4604      	mov	r4, r0
  9a:	2800      	cmp	r0, #0
  9c:	d1e4      	bne.n	68 <ecc_point_to_mont.constprop.0+0x68>
                   err = mp_mulmod(p->z, mu, modulus, r->z);
  9e:	f107 03d0 	add.w	r3, r7, #208	; 0xd0
  a2:	4642      	mov	r2, r8
  a4:	4629      	mov	r1, r5
  a6:	f106 00d0 	add.w	r0, r6, #208	; 0xd0
  aa:	f7ff fffe 	bl	0 <mp_mulmod>
  ae:	e7da      	b.n	66 <ecc_point_to_mont.constprop.0+0x66>
       err = MEMORY_E;
  b0:	f06f 047c 	mvn.w	r4, #124	; 0x7c
}
  b4:	4620      	mov	r0, r4
  b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text._ecc_projective_dbl_point.constprop.0:

00000000 <_ecc_projective_dbl_point.constprop.0>:
static int _ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	9001      	str	r0, [sp, #4]
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
   6:	2068      	movs	r0, #104	; 0x68
static int _ecc_projective_dbl_point(ecc_point *P, ecc_point *R, mp_int* a,
   8:	4689      	mov	r9, r1
   a:	4616      	mov	r6, r2
   c:	469a      	mov	sl, r3
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
   e:	f7ff fffe 	bl	0 <malloc>
  12:	4605      	mov	r5, r0
  14:	b118      	cbz	r0, 1e <_ecc_projective_dbl_point.constprop.0+0x1e>
  16:	2268      	movs	r2, #104	; 0x68
  18:	2100      	movs	r1, #0
  1a:	f7ff fffe 	bl	0 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
  1e:	2068      	movs	r0, #104	; 0x68
  20:	f7ff fffe 	bl	0 <malloc>
  24:	4607      	mov	r7, r0
  26:	2800      	cmp	r0, #0
  28:	f000 8123 	beq.w	272 <_ecc_projective_dbl_point.constprop.0+0x272>
  2c:	2268      	movs	r2, #104	; 0x68
  2e:	2100      	movs	r1, #0
  30:	f7ff fffe 	bl	0 <memset>
      if (t1 == NULL || t2 == NULL) {
  34:	b92d      	cbnz	r5, 42 <_ecc_projective_dbl_point.constprop.0+0x42>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  36:	4638      	mov	r0, r7
  38:	e000      	b.n	3c <_ecc_projective_dbl_point.constprop.0+0x3c>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
  3a:	4628      	mov	r0, r5
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  3c:	f7ff fffe 	bl	0 <free>
  40:	e11a      	b.n	278 <_ecc_projective_dbl_point.constprop.0+0x278>
   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
  42:	4628      	mov	r0, r5
  44:	f7ff fffe 	bl	0 <mp_init>
   if (err == MP_OKAY) {
  48:	4604      	mov	r4, r0
  4a:	b920      	cbnz	r0, 56 <_ecc_projective_dbl_point.constprop.0+0x56>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
  4c:	4638      	mov	r0, r7
  4e:	f7ff fffe 	bl	0 <mp_init>
   if (err != MP_OKAY) {
  52:	4604      	mov	r4, r0
  54:	b148      	cbz	r0, 6a <_ecc_projective_dbl_point.constprop.0+0x6a>
       FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  56:	4638      	mov	r0, r7
  58:	f7ff fffe 	bl	0 <free>
       FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
  5c:	4628      	mov	r0, r5
  5e:	f7ff fffe 	bl	0 <free>
}
  62:	4620      	mov	r0, r4
  64:	b003      	add	sp, #12
  66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
       err = mp_copy(P->x, x);
  6a:	9801      	ldr	r0, [sp, #4]
  6c:	4649      	mov	r1, r9
  6e:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
  72:	4604      	mov	r4, r0
  74:	2800      	cmp	r0, #0
  76:	f040 80f5 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_copy(P->y, y);
  7a:	9b01      	ldr	r3, [sp, #4]
   y = R->y;
  7c:	f109 0868 	add.w	r8, r9, #104	; 0x68
       err = mp_copy(P->y, y);
  80:	4641      	mov	r1, r8
  82:	f103 0068 	add.w	r0, r3, #104	; 0x68
  86:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
  8a:	4604      	mov	r4, r0
  8c:	2800      	cmp	r0, #0
  8e:	f040 80e9 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_copy(P->z, z);
  92:	9801      	ldr	r0, [sp, #4]
   z = R->z;
  94:	f109 0bd0 	add.w	fp, r9, #208	; 0xd0
       err = mp_copy(P->z, z);
  98:	4659      	mov	r1, fp
  9a:	30d0      	adds	r0, #208	; 0xd0
  9c:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
  a0:	4604      	mov	r4, r0
  a2:	2800      	cmp	r0, #0
  a4:	f040 80de 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_sqr(z, t1);
  a8:	4629      	mov	r1, r5
  aa:	4658      	mov	r0, fp
  ac:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
  b0:	4604      	mov	r4, r0
  b2:	2800      	cmp	r0, #0
  b4:	f040 80d6 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_montgomery_reduce(t1, modulus, mp);
  b8:	4652      	mov	r2, sl
  ba:	4631      	mov	r1, r6
  bc:	4628      	mov	r0, r5
  be:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
  c2:	4604      	mov	r4, r0
  c4:	2800      	cmp	r0, #0
  c6:	f040 80cd 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_mul(z, y, z);
  ca:	465a      	mov	r2, fp
  cc:	4641      	mov	r1, r8
  ce:	4658      	mov	r0, fp
  d0:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
  d4:	4604      	mov	r4, r0
  d6:	2800      	cmp	r0, #0
  d8:	f040 80c4 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_montgomery_reduce(z, modulus, mp);
  dc:	4652      	mov	r2, sl
  de:	4631      	mov	r1, r6
  e0:	4658      	mov	r0, fp
  e2:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
  e6:	4604      	mov	r4, r0
  e8:	2800      	cmp	r0, #0
  ea:	f040 80bb 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_addmod_ct(z, z, modulus, z);
  ee:	465b      	mov	r3, fp
  f0:	4632      	mov	r2, r6
  f2:	4659      	mov	r1, fp
  f4:	4658      	mov	r0, fp
  f6:	f7ff fffe 	bl	0 <mp_addmod_ct>
      if (err == MP_OKAY)
  fa:	4604      	mov	r4, r0
  fc:	2800      	cmp	r0, #0
  fe:	f040 80b1 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
          err = mp_submod_ct(x, t1, modulus, t2);
 102:	463b      	mov	r3, r7
 104:	4632      	mov	r2, r6
 106:	4629      	mov	r1, r5
 108:	4648      	mov	r0, r9
 10a:	f7ff fffe 	bl	0 <mp_submod_ct>
      if (err == MP_OKAY)
 10e:	4604      	mov	r4, r0
 110:	2800      	cmp	r0, #0
 112:	f040 80a7 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
          err = mp_addmod_ct(t1, x, modulus, t1);
 116:	462b      	mov	r3, r5
 118:	4632      	mov	r2, r6
 11a:	4649      	mov	r1, r9
 11c:	4628      	mov	r0, r5
 11e:	f7ff fffe 	bl	0 <mp_addmod_ct>
      if (err == MP_OKAY)
 122:	4604      	mov	r4, r0
 124:	2800      	cmp	r0, #0
 126:	f040 809d 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
          err = mp_mul(t1, t2, t2);
 12a:	463a      	mov	r2, r7
 12c:	4639      	mov	r1, r7
 12e:	4628      	mov	r0, r5
 130:	f7ff fffe 	bl	0 <mp_mul>
      if (err == MP_OKAY)
 134:	4604      	mov	r4, r0
 136:	2800      	cmp	r0, #0
 138:	f040 8094 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
          err = mp_montgomery_reduce(t2, modulus, mp);
 13c:	4652      	mov	r2, sl
 13e:	4631      	mov	r1, r6
 140:	4638      	mov	r0, r7
 142:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
      if (err == MP_OKAY)
 146:	4604      	mov	r4, r0
 148:	2800      	cmp	r0, #0
 14a:	f040 808b 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
          err = mp_addmod_ct(t2, t2, modulus, t1);
 14e:	462b      	mov	r3, r5
 150:	4632      	mov	r2, r6
 152:	4639      	mov	r1, r7
 154:	4638      	mov	r0, r7
 156:	f7ff fffe 	bl	0 <mp_addmod_ct>
      if (err == MP_OKAY)
 15a:	4604      	mov	r4, r0
 15c:	2800      	cmp	r0, #0
 15e:	f040 8081 	bne.w	264 <_ecc_projective_dbl_point.constprop.0+0x264>
          err = mp_addmod_ct(t1, t2, modulus, t1);
 162:	462b      	mov	r3, r5
 164:	4632      	mov	r2, r6
 166:	4639      	mov	r1, r7
 168:	4628      	mov	r0, r5
 16a:	f7ff fffe 	bl	0 <mp_addmod_ct>
   if (err == MP_OKAY)
 16e:	4604      	mov	r4, r0
 170:	2800      	cmp	r0, #0
 172:	d177      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_addmod_ct(y, y, modulus, y);
 174:	4643      	mov	r3, r8
 176:	4632      	mov	r2, r6
 178:	4641      	mov	r1, r8
 17a:	4640      	mov	r0, r8
 17c:	f7ff fffe 	bl	0 <mp_addmod_ct>
   if (err == MP_OKAY)
 180:	4604      	mov	r4, r0
 182:	2800      	cmp	r0, #0
 184:	d16e      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_sqr(y, y);
 186:	4641      	mov	r1, r8
 188:	4640      	mov	r0, r8
 18a:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
 18e:	4604      	mov	r4, r0
 190:	2800      	cmp	r0, #0
 192:	d167      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_montgomery_reduce(y, modulus, mp);
 194:	4652      	mov	r2, sl
 196:	4631      	mov	r1, r6
 198:	4640      	mov	r0, r8
 19a:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 19e:	4604      	mov	r4, r0
 1a0:	2800      	cmp	r0, #0
 1a2:	d15f      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_sqr(y, t2);
 1a4:	4639      	mov	r1, r7
 1a6:	4640      	mov	r0, r8
 1a8:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
 1ac:	4604      	mov	r4, r0
 1ae:	2800      	cmp	r0, #0
 1b0:	d158      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_montgomery_reduce(t2, modulus, mp);
 1b2:	4652      	mov	r2, sl
 1b4:	4631      	mov	r1, r6
 1b6:	4638      	mov	r0, r7
 1b8:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 1bc:	4604      	mov	r4, r0
 1be:	2800      	cmp	r0, #0
 1c0:	d150      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_div_2_mod_ct(t2, modulus, t2);
 1c2:	463a      	mov	r2, r7
 1c4:	4631      	mov	r1, r6
 1c6:	4638      	mov	r0, r7
 1c8:	f7ff fffe 	bl	0 <mp_div_2_mod_ct>
   if (err == MP_OKAY)
 1cc:	4604      	mov	r4, r0
 1ce:	2800      	cmp	r0, #0
 1d0:	d148      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_mul(y, x, y);
 1d2:	4642      	mov	r2, r8
 1d4:	4649      	mov	r1, r9
 1d6:	4640      	mov	r0, r8
 1d8:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 1dc:	4604      	mov	r4, r0
 1de:	2800      	cmp	r0, #0
 1e0:	d140      	bne.n	264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_montgomery_reduce(y, modulus, mp);
 1e2:	4652      	mov	r2, sl
 1e4:	4631      	mov	r1, r6
 1e6:	4640      	mov	r0, r8
 1e8:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 1ec:	4604      	mov	r4, r0
 1ee:	bbc8      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_sqr(t1, x);
 1f0:	4649      	mov	r1, r9
 1f2:	4628      	mov	r0, r5
 1f4:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
 1f8:	4604      	mov	r4, r0
 1fa:	bb98      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_montgomery_reduce(x, modulus, mp);
 1fc:	4652      	mov	r2, sl
 1fe:	4631      	mov	r1, r6
 200:	4648      	mov	r0, r9
 202:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 206:	4604      	mov	r4, r0
 208:	bb60      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_submod_ct(x, y, modulus, x);
 20a:	464b      	mov	r3, r9
 20c:	4632      	mov	r2, r6
 20e:	4641      	mov	r1, r8
 210:	4648      	mov	r0, r9
 212:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 216:	4604      	mov	r4, r0
 218:	bb20      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_submod_ct(x, y, modulus, x);
 21a:	464b      	mov	r3, r9
 21c:	4632      	mov	r2, r6
 21e:	4641      	mov	r1, r8
 220:	4648      	mov	r0, r9
 222:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 226:	4604      	mov	r4, r0
 228:	b9e0      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_submod_ct(y, x, modulus, y);
 22a:	4643      	mov	r3, r8
 22c:	4632      	mov	r2, r6
 22e:	4649      	mov	r1, r9
 230:	4640      	mov	r0, r8
 232:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 236:	4604      	mov	r4, r0
 238:	b9a0      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_mul(y, t1, y);
 23a:	4642      	mov	r2, r8
 23c:	4629      	mov	r1, r5
 23e:	4640      	mov	r0, r8
 240:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 244:	4604      	mov	r4, r0
 246:	b968      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_montgomery_reduce(y, modulus, mp);
 248:	4652      	mov	r2, sl
 24a:	4631      	mov	r1, r6
 24c:	4640      	mov	r0, r8
 24e:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 252:	4604      	mov	r4, r0
 254:	b930      	cbnz	r0, 264 <_ecc_projective_dbl_point.constprop.0+0x264>
       err = mp_submod_ct(y, t2, modulus, y);
 256:	4643      	mov	r3, r8
 258:	4632      	mov	r2, r6
 25a:	4639      	mov	r1, r7
 25c:	4640      	mov	r0, r8
 25e:	f7ff fffe 	bl	0 <mp_submod_ct>
 262:	4604      	mov	r4, r0
   mp_clear(t1);
 264:	4628      	mov	r0, r5
 266:	f7ff fffe 	bl	0 <mp_clear>
   mp_clear(t2);
 26a:	4638      	mov	r0, r7
 26c:	f7ff fffe 	bl	0 <mp_clear>
 270:	e6f1      	b.n	56 <_ecc_projective_dbl_point.constprop.0+0x56>
      if (t1 == NULL || t2 == NULL) {
 272:	2d00      	cmp	r5, #0
 274:	f47f aee1 	bne.w	3a <_ecc_projective_dbl_point.constprop.0+0x3a>
         return MEMORY_E;
 278:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 27c:	e6f1      	b.n	62 <_ecc_projective_dbl_point.constprop.0+0x62>

Disassembly of section .text.wc_ecc_curve_cache_load_item:

00000000 <wc_ecc_curve_cache_load_item>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4616      	mov	r6, r2
   4:	461d      	mov	r5, r3
    if (curve->spec_use >= curve->spec_count) {
   6:	e9d0 2307 	ldrd	r2, r3, [r0, #28]
   a:	4293      	cmp	r3, r2
{
   c:	4604      	mov	r4, r0
   e:	460f      	mov	r7, r1
    if (curve->spec_use >= curve->spec_count) {
  10:	d215      	bcs.n	3e <wc_ecc_curve_cache_load_item+0x3e>
    *dst = &curve->spec_ints[curve->spec_use++];
  12:	6980      	ldr	r0, [r0, #24]
  14:	1c5a      	adds	r2, r3, #1
  16:	6222      	str	r2, [r4, #32]
  18:	2268      	movs	r2, #104	; 0x68
  1a:	fb02 0003 	mla	r0, r2, r3, r0
  1e:	6030      	str	r0, [r6, #0]
    err = mp_init(*dst);
  20:	f7ff fffe 	bl	0 <mp_init>
    if (err == MP_OKAY) {
  24:	b968      	cbnz	r0, 42 <wc_ecc_curve_cache_load_item+0x42>
        curve->load_mask |= mask;
  26:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  2a:	6830      	ldr	r0, [r6, #0]
  2c:	431d      	orrs	r5, r3
  2e:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
        err = mp_read_radix(*dst, src, MP_RADIX_HEX);
  32:	4639      	mov	r1, r7
  34:	2210      	movs	r2, #16
}
  36:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        err = mp_read_radix(*dst, src, MP_RADIX_HEX);
  3a:	f7ff bffe 	b.w	0 <mp_read_radix>
        return ECC_BAD_ARG_E;
  3e:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
}
  42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

Disassembly of section .text._ecc_projective_add_point.isra.0:

00000000 <_ecc_projective_add_point.isra.0>:
static int _ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   if (Q == R) {
   4:	4291      	cmp	r1, r2
static int _ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
   6:	4681      	mov	r9, r0
   8:	9100      	str	r1, [sp, #0]
      Q = tPt;
   a:	bf08      	it	eq
   c:	9000      	streq	r0, [sp, #0]
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
   e:	f04f 0068 	mov.w	r0, #104	; 0x68
static int _ecc_projective_add_point(ecc_point* P, ecc_point* Q, ecc_point* R,
  12:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
  16:	4617      	mov	r7, r2
  18:	461d      	mov	r5, r3
   if (Q == R) {
  1a:	bf08      	it	eq
  1c:	4691      	moveq	r9, r2
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
  1e:	f7ff fffe 	bl	0 <malloc>
  22:	4604      	mov	r4, r0
  24:	b118      	cbz	r0, 2e <_ecc_projective_add_point.isra.0+0x2e>
  26:	2268      	movs	r2, #104	; 0x68
  28:	2100      	movs	r1, #0
  2a:	f7ff fffe 	bl	0 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
  2e:	2068      	movs	r0, #104	; 0x68
  30:	f7ff fffe 	bl	0 <malloc>
  34:	4606      	mov	r6, r0
  36:	2800      	cmp	r0, #0
  38:	f000 8208 	beq.w	44c <_ecc_projective_add_point.isra.0+0x44c>
  3c:	2268      	movs	r2, #104	; 0x68
  3e:	2100      	movs	r1, #0
  40:	f7ff fffe 	bl	0 <memset>
      if (t1 == NULL || t2 == NULL) {
  44:	b92c      	cbnz	r4, 52 <_ecc_projective_add_point.isra.0+0x52>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  46:	4630      	mov	r0, r6
  48:	e000      	b.n	4c <_ecc_projective_add_point.isra.0+0x4c>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
  4a:	4620      	mov	r0, r4
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  4c:	f7ff fffe 	bl	0 <free>
  50:	e1ff      	b.n	452 <_ecc_projective_add_point.isra.0+0x452>
   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
  52:	4620      	mov	r0, r4
  54:	f7ff fffe 	bl	0 <mp_init>
   if (err == MP_OKAY) {
  58:	4603      	mov	r3, r0
  5a:	b920      	cbnz	r0, 66 <_ecc_projective_add_point.isra.0+0x66>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
  5c:	4630      	mov	r0, r6
  5e:	f7ff fffe 	bl	0 <mp_init>
   if (err != MP_OKAY) {
  62:	4603      	mov	r3, r0
  64:	b158      	cbz	r0, 7e <_ecc_projective_add_point.isra.0+0x7e>
  66:	9300      	str	r3, [sp, #0]
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  68:	4630      	mov	r0, r6
  6a:	f7ff fffe 	bl	0 <free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
  6e:	4620      	mov	r0, r4
  70:	f7ff fffe 	bl	0 <free>
   return err;
  74:	9b00      	ldr	r3, [sp, #0]
}
  76:	4618      	mov	r0, r3
  78:	b003      	add	sp, #12
  7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      err = mp_submod_ct(modulus, Q->y, modulus, t1);
  7e:	9b00      	ldr	r3, [sp, #0]
  80:	3368      	adds	r3, #104	; 0x68
  82:	9301      	str	r3, [sp, #4]
  84:	9901      	ldr	r1, [sp, #4]
  86:	4623      	mov	r3, r4
  88:	462a      	mov	r2, r5
  8a:	4628      	mov	r0, r5
  8c:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY) {
  90:	4603      	mov	r3, r0
  92:	2800      	cmp	r0, #0
  94:	d159      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
  96:	9900      	ldr	r1, [sp, #0]
  98:	4648      	mov	r0, r9
  9a:	f7ff fffe 	bl	0 <mp_cmp>
  9e:	bb70      	cbnz	r0, fe <_ecc_projective_add_point.isra.0+0xfe>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
  a0:	9b00      	ldr	r3, [sp, #0]
  a2:	f103 0ad0 	add.w	sl, r3, #208	; 0xd0
  a6:	4650      	mov	r0, sl
  a8:	f7ff fffe 	bl	0 <get_digit_count>
      if ( (mp_cmp(P->x, Q->x) == MP_EQ) &&
  ac:	b338      	cbz	r0, fe <_ecc_projective_add_point.isra.0+0xfe>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
  ae:	4651      	mov	r1, sl
  b0:	f109 00d0 	add.w	r0, r9, #208	; 0xd0
  b4:	f7ff fffe 	bl	0 <mp_cmp>
  b8:	bb08      	cbnz	r0, fe <_ecc_projective_add_point.isra.0+0xfe>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
  ba:	f109 0a68 	add.w	sl, r9, #104	; 0x68
  be:	9901      	ldr	r1, [sp, #4]
  c0:	4650      	mov	r0, sl
  c2:	f7ff fffe 	bl	0 <mp_cmp>
           (get_digit_count(Q->z) && mp_cmp(P->z, Q->z) == MP_EQ) &&
  c6:	b9a0      	cbnz	r0, f2 <_ecc_projective_add_point.isra.0+0xf2>
          mp_clear(t1);
  c8:	4620      	mov	r0, r4
  ca:	f7ff fffe 	bl	0 <mp_clear>
          mp_clear(t2);
  ce:	4630      	mov	r0, r6
  d0:	f7ff fffe 	bl	0 <mp_clear>
            FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  d4:	4630      	mov	r0, r6
  d6:	f7ff fffe 	bl	0 <free>
            FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
  da:	4620      	mov	r0, r4
  dc:	f7ff fffe 	bl	0 <free>
         return _ecc_projective_dbl_point(P, R, a, modulus, mp);
  e0:	4643      	mov	r3, r8
  e2:	462a      	mov	r2, r5
  e4:	4639      	mov	r1, r7
  e6:	4648      	mov	r0, r9
}
  e8:	b003      	add	sp, #12
  ea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
         return _ecc_projective_dbl_point(P, R, a, modulus, mp);
  ee:	f7ff bffe 	b.w	0 <_ecc_projective_add_point.isra.0>
           (mp_cmp(P->y, Q->y) == MP_EQ || mp_cmp(P->y, t1) == MP_EQ)) {
  f2:	4621      	mov	r1, r4
  f4:	4650      	mov	r0, sl
  f6:	f7ff fffe 	bl	0 <mp_cmp>
  fa:	2800      	cmp	r0, #0
  fc:	d0e4      	beq.n	c8 <_ecc_projective_add_point.isra.0+0xc8>
       err = mp_copy(P->x, x);
  fe:	4639      	mov	r1, r7
 100:	4648      	mov	r0, r9
 102:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
 106:	4603      	mov	r3, r0
 108:	b9f8      	cbnz	r0, 14a <_ecc_projective_add_point.isra.0+0x14a>
   y = R->y;
 10a:	f107 0a68 	add.w	sl, r7, #104	; 0x68
       err = mp_copy(P->y, y);
 10e:	4651      	mov	r1, sl
 110:	f109 0068 	add.w	r0, r9, #104	; 0x68
 114:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
 118:	4603      	mov	r3, r0
 11a:	b9b0      	cbnz	r0, 14a <_ecc_projective_add_point.isra.0+0x14a>
   z = R->z;
 11c:	f107 0bd0 	add.w	fp, r7, #208	; 0xd0
       err = mp_copy(P->z, z);
 120:	4659      	mov	r1, fp
 122:	f109 00d0 	add.w	r0, r9, #208	; 0xd0
 126:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY) {
 12a:	4603      	mov	r3, r0
 12c:	b968      	cbnz	r0, 14a <_ecc_projective_add_point.isra.0+0x14a>
       if (!mp_iszero(Q->z)) {
 12e:	9b00      	ldr	r3, [sp, #0]
 130:	f103 09d0 	add.w	r9, r3, #208	; 0xd0
 134:	4648      	mov	r0, r9
 136:	f7ff fffe 	bl	0 <mp_iszero>
 13a:	b170      	cbz	r0, 15a <_ecc_projective_add_point.isra.0+0x15a>
       err = mp_sqr(z, t1);
 13c:	4621      	mov	r1, r4
 13e:	4658      	mov	r0, fp
 140:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
 144:	4603      	mov	r3, r0
 146:	2800      	cmp	r0, #0
 148:	d047      	beq.n	1da <_ecc_projective_add_point.isra.0+0x1da>
   mp_clear(t1);
 14a:	4620      	mov	r0, r4
 14c:	9300      	str	r3, [sp, #0]
 14e:	f7ff fffe 	bl	0 <mp_clear>
   mp_clear(t2);
 152:	4630      	mov	r0, r6
 154:	f7ff fffe 	bl	0 <mp_clear>
 158:	e786      	b.n	68 <_ecc_projective_add_point.isra.0+0x68>
           err = mp_sqr(Q->z, t1);
 15a:	4621      	mov	r1, r4
 15c:	4648      	mov	r0, r9
 15e:	f7ff fffe 	bl	0 <mp_sqr>
           if (err == MP_OKAY)
 162:	4603      	mov	r3, r0
 164:	2800      	cmp	r0, #0
 166:	d1f0      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_montgomery_reduce(t1, modulus, mp);
 168:	4642      	mov	r2, r8
 16a:	4629      	mov	r1, r5
 16c:	4620      	mov	r0, r4
 16e:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
           if (err == MP_OKAY)
 172:	4603      	mov	r3, r0
 174:	2800      	cmp	r0, #0
 176:	d1e8      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_mul(t1, x, x);
 178:	463a      	mov	r2, r7
 17a:	4639      	mov	r1, r7
 17c:	4620      	mov	r0, r4
 17e:	f7ff fffe 	bl	0 <mp_mul>
           if (err == MP_OKAY)
 182:	4603      	mov	r3, r0
 184:	2800      	cmp	r0, #0
 186:	d1e0      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_montgomery_reduce(x, modulus, mp);
 188:	4642      	mov	r2, r8
 18a:	4629      	mov	r1, r5
 18c:	4638      	mov	r0, r7
 18e:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
           if (err == MP_OKAY)
 192:	4603      	mov	r3, r0
 194:	2800      	cmp	r0, #0
 196:	d1d8      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_mul(Q->z, t1, t1);
 198:	4622      	mov	r2, r4
 19a:	4621      	mov	r1, r4
 19c:	4648      	mov	r0, r9
 19e:	f7ff fffe 	bl	0 <mp_mul>
           if (err == MP_OKAY)
 1a2:	4603      	mov	r3, r0
 1a4:	2800      	cmp	r0, #0
 1a6:	d1d0      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_montgomery_reduce(t1, modulus, mp);
 1a8:	4642      	mov	r2, r8
 1aa:	4629      	mov	r1, r5
 1ac:	4620      	mov	r0, r4
 1ae:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
           if (err == MP_OKAY)
 1b2:	4603      	mov	r3, r0
 1b4:	2800      	cmp	r0, #0
 1b6:	d1c8      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_mul(t1, y, y);
 1b8:	4652      	mov	r2, sl
 1ba:	4651      	mov	r1, sl
 1bc:	4620      	mov	r0, r4
 1be:	f7ff fffe 	bl	0 <mp_mul>
           if (err == MP_OKAY)
 1c2:	4603      	mov	r3, r0
 1c4:	2800      	cmp	r0, #0
 1c6:	d1c0      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_montgomery_reduce(y, modulus, mp);
 1c8:	4642      	mov	r2, r8
 1ca:	4629      	mov	r1, r5
 1cc:	4650      	mov	r0, sl
 1ce:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 1d2:	4603      	mov	r3, r0
 1d4:	2800      	cmp	r0, #0
 1d6:	d0b1      	beq.n	13c <_ecc_projective_add_point.isra.0+0x13c>
 1d8:	e7b7      	b.n	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t1, modulus, mp);
 1da:	4642      	mov	r2, r8
 1dc:	4629      	mov	r1, r5
 1de:	4620      	mov	r0, r4
 1e0:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 1e4:	4603      	mov	r3, r0
 1e6:	2800      	cmp	r0, #0
 1e8:	d1af      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_mul(Q->x, t1, t2);
 1ea:	9800      	ldr	r0, [sp, #0]
 1ec:	4632      	mov	r2, r6
 1ee:	4621      	mov	r1, r4
 1f0:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 1f4:	4603      	mov	r3, r0
 1f6:	2800      	cmp	r0, #0
 1f8:	d1a7      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t2, modulus, mp);
 1fa:	4642      	mov	r2, r8
 1fc:	4629      	mov	r1, r5
 1fe:	4630      	mov	r0, r6
 200:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 204:	4603      	mov	r3, r0
 206:	2800      	cmp	r0, #0
 208:	d19f      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_mul(z, t1, t1);
 20a:	4622      	mov	r2, r4
 20c:	4621      	mov	r1, r4
 20e:	4658      	mov	r0, fp
 210:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 214:	4603      	mov	r3, r0
 216:	2800      	cmp	r0, #0
 218:	d197      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t1, modulus, mp);
 21a:	4642      	mov	r2, r8
 21c:	4629      	mov	r1, r5
 21e:	4620      	mov	r0, r4
 220:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 224:	4603      	mov	r3, r0
 226:	2800      	cmp	r0, #0
 228:	d18f      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_mul(Q->y, t1, t1);
 22a:	9801      	ldr	r0, [sp, #4]
 22c:	4622      	mov	r2, r4
 22e:	4621      	mov	r1, r4
 230:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 234:	4603      	mov	r3, r0
 236:	2800      	cmp	r0, #0
 238:	d187      	bne.n	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t1, modulus, mp);
 23a:	4642      	mov	r2, r8
 23c:	4629      	mov	r1, r5
 23e:	4620      	mov	r0, r4
 240:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 244:	4603      	mov	r3, r0
 246:	2800      	cmp	r0, #0
 248:	f47f af7f 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_submod_ct(y, t1, modulus, y);
 24c:	4653      	mov	r3, sl
 24e:	462a      	mov	r2, r5
 250:	4621      	mov	r1, r4
 252:	4650      	mov	r0, sl
 254:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 258:	4603      	mov	r3, r0
 25a:	2800      	cmp	r0, #0
 25c:	f47f af75 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_addmod_ct(t1, t1, modulus, t1);
 260:	4623      	mov	r3, r4
 262:	462a      	mov	r2, r5
 264:	4621      	mov	r1, r4
 266:	4620      	mov	r0, r4
 268:	f7ff fffe 	bl	0 <mp_addmod_ct>
   if (err == MP_OKAY)
 26c:	4603      	mov	r3, r0
 26e:	2800      	cmp	r0, #0
 270:	f47f af6b 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_addmod_ct(t1, y, modulus, t1);
 274:	4623      	mov	r3, r4
 276:	462a      	mov	r2, r5
 278:	4651      	mov	r1, sl
 27a:	4620      	mov	r0, r4
 27c:	f7ff fffe 	bl	0 <mp_addmod_ct>
   if (err == MP_OKAY)
 280:	4603      	mov	r3, r0
 282:	2800      	cmp	r0, #0
 284:	f47f af61 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_submod_ct(x, t2, modulus, x);
 288:	463b      	mov	r3, r7
 28a:	462a      	mov	r2, r5
 28c:	4631      	mov	r1, r6
 28e:	4638      	mov	r0, r7
 290:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 294:	4603      	mov	r3, r0
 296:	2800      	cmp	r0, #0
 298:	f47f af57 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_addmod_ct(t2, t2, modulus, t2);
 29c:	4633      	mov	r3, r6
 29e:	462a      	mov	r2, r5
 2a0:	4631      	mov	r1, r6
 2a2:	4630      	mov	r0, r6
 2a4:	f7ff fffe 	bl	0 <mp_addmod_ct>
   if (err == MP_OKAY)
 2a8:	4603      	mov	r3, r0
 2aa:	2800      	cmp	r0, #0
 2ac:	f47f af4d 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_addmod_ct(t2, x, modulus, t2);
 2b0:	4633      	mov	r3, r6
 2b2:	462a      	mov	r2, r5
 2b4:	4639      	mov	r1, r7
 2b6:	4630      	mov	r0, r6
 2b8:	f7ff fffe 	bl	0 <mp_addmod_ct>
   if (err == MP_OKAY) {
 2bc:	4603      	mov	r3, r0
 2be:	2800      	cmp	r0, #0
 2c0:	f47f af43 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       if (!mp_iszero(Q->z)) {
 2c4:	4648      	mov	r0, r9
 2c6:	f7ff fffe 	bl	0 <mp_iszero>
 2ca:	2800      	cmp	r0, #0
 2cc:	f000 80ab 	beq.w	426 <_ecc_projective_add_point.isra.0+0x426>
       err = mp_mul(z, x, z);
 2d0:	465a      	mov	r2, fp
 2d2:	4639      	mov	r1, r7
 2d4:	4658      	mov	r0, fp
 2d6:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 2da:	4603      	mov	r3, r0
 2dc:	2800      	cmp	r0, #0
 2de:	f47f af34 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(z, modulus, mp);
 2e2:	4642      	mov	r2, r8
 2e4:	4629      	mov	r1, r5
 2e6:	4658      	mov	r0, fp
 2e8:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 2ec:	4603      	mov	r3, r0
 2ee:	2800      	cmp	r0, #0
 2f0:	f47f af2b 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_mul(t1, x, t1);
 2f4:	4622      	mov	r2, r4
 2f6:	4639      	mov	r1, r7
 2f8:	4620      	mov	r0, r4
 2fa:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 2fe:	4603      	mov	r3, r0
 300:	2800      	cmp	r0, #0
 302:	f47f af22 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t1, modulus, mp);
 306:	4642      	mov	r2, r8
 308:	4629      	mov	r1, r5
 30a:	4620      	mov	r0, r4
 30c:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 310:	4603      	mov	r3, r0
 312:	2800      	cmp	r0, #0
 314:	f47f af19 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_sqr(x, x);
 318:	4639      	mov	r1, r7
 31a:	4638      	mov	r0, r7
 31c:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
 320:	4603      	mov	r3, r0
 322:	2800      	cmp	r0, #0
 324:	f47f af11 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(x, modulus, mp);
 328:	4642      	mov	r2, r8
 32a:	4629      	mov	r1, r5
 32c:	4638      	mov	r0, r7
 32e:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 332:	4603      	mov	r3, r0
 334:	2800      	cmp	r0, #0
 336:	f47f af08 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_mul(t2, x, t2);
 33a:	4632      	mov	r2, r6
 33c:	4639      	mov	r1, r7
 33e:	4630      	mov	r0, r6
 340:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 344:	4603      	mov	r3, r0
 346:	2800      	cmp	r0, #0
 348:	f47f aeff 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t2, modulus, mp);
 34c:	4642      	mov	r2, r8
 34e:	4629      	mov	r1, r5
 350:	4630      	mov	r0, r6
 352:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 356:	4603      	mov	r3, r0
 358:	2800      	cmp	r0, #0
 35a:	f47f aef6 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_mul(t1, x, t1);
 35e:	4622      	mov	r2, r4
 360:	4639      	mov	r1, r7
 362:	4620      	mov	r0, r4
 364:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 368:	4603      	mov	r3, r0
 36a:	2800      	cmp	r0, #0
 36c:	f47f aeed 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t1, modulus, mp);
 370:	4642      	mov	r2, r8
 372:	4629      	mov	r1, r5
 374:	4620      	mov	r0, r4
 376:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 37a:	4603      	mov	r3, r0
 37c:	2800      	cmp	r0, #0
 37e:	f47f aee4 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_sqr(y, x);
 382:	4639      	mov	r1, r7
 384:	4650      	mov	r0, sl
 386:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
 38a:	4603      	mov	r3, r0
 38c:	2800      	cmp	r0, #0
 38e:	f47f aedc 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(x, modulus, mp);
 392:	4642      	mov	r2, r8
 394:	4629      	mov	r1, r5
 396:	4638      	mov	r0, r7
 398:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 39c:	4603      	mov	r3, r0
 39e:	2800      	cmp	r0, #0
 3a0:	f47f aed3 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_submod_ct(x, t2, modulus, x);
 3a4:	463b      	mov	r3, r7
 3a6:	462a      	mov	r2, r5
 3a8:	4631      	mov	r1, r6
 3aa:	4638      	mov	r0, r7
 3ac:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 3b0:	4603      	mov	r3, r0
 3b2:	2800      	cmp	r0, #0
 3b4:	f47f aec9 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_submod_ct(t2, x, modulus, t2);
 3b8:	4633      	mov	r3, r6
 3ba:	462a      	mov	r2, r5
 3bc:	4639      	mov	r1, r7
 3be:	4630      	mov	r0, r6
 3c0:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 3c4:	4603      	mov	r3, r0
 3c6:	2800      	cmp	r0, #0
 3c8:	f47f aebf 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_submod_ct(t2, x, modulus, t2);
 3cc:	4633      	mov	r3, r6
 3ce:	462a      	mov	r2, r5
 3d0:	4639      	mov	r1, r7
 3d2:	4630      	mov	r0, r6
 3d4:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 3d8:	4603      	mov	r3, r0
 3da:	2800      	cmp	r0, #0
 3dc:	f47f aeb5 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_mul(t2, y, t2);
 3e0:	4632      	mov	r2, r6
 3e2:	4651      	mov	r1, sl
 3e4:	4630      	mov	r0, r6
 3e6:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 3ea:	4603      	mov	r3, r0
 3ec:	2800      	cmp	r0, #0
 3ee:	f47f aeac 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_montgomery_reduce(t2, modulus, mp);
 3f2:	4642      	mov	r2, r8
 3f4:	4629      	mov	r1, r5
 3f6:	4630      	mov	r0, r6
 3f8:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 3fc:	4603      	mov	r3, r0
 3fe:	2800      	cmp	r0, #0
 400:	f47f aea3 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_submod_ct(t2, t1, modulus, y);
 404:	4653      	mov	r3, sl
 406:	462a      	mov	r2, r5
 408:	4621      	mov	r1, r4
 40a:	4630      	mov	r0, r6
 40c:	f7ff fffe 	bl	0 <mp_submod_ct>
   if (err == MP_OKAY)
 410:	4603      	mov	r3, r0
 412:	2800      	cmp	r0, #0
 414:	f47f ae99 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
       err = mp_div_2_mod_ct(y, modulus, y);
 418:	4652      	mov	r2, sl
 41a:	4629      	mov	r1, r5
 41c:	4650      	mov	r0, sl
 41e:	f7ff fffe 	bl	0 <mp_div_2_mod_ct>
 422:	4603      	mov	r3, r0
 424:	e691      	b.n	14a <_ecc_projective_add_point.isra.0+0x14a>
           err = mp_mul(z, Q->z, z);
 426:	465a      	mov	r2, fp
 428:	4649      	mov	r1, r9
 42a:	4658      	mov	r0, fp
 42c:	f7ff fffe 	bl	0 <mp_mul>
           if (err == MP_OKAY)
 430:	4603      	mov	r3, r0
 432:	2800      	cmp	r0, #0
 434:	f47f ae89 	bne.w	14a <_ecc_projective_add_point.isra.0+0x14a>
               err = mp_montgomery_reduce(z, modulus, mp);
 438:	4642      	mov	r2, r8
 43a:	4629      	mov	r1, r5
 43c:	4658      	mov	r0, fp
 43e:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 442:	4603      	mov	r3, r0
 444:	2800      	cmp	r0, #0
 446:	f43f af43 	beq.w	2d0 <_ecc_projective_add_point.isra.0+0x2d0>
 44a:	e67e      	b.n	14a <_ecc_projective_add_point.isra.0+0x14a>
      if (t1 == NULL || t2 == NULL) {
 44c:	2c00      	cmp	r4, #0
 44e:	f47f adfc 	bne.w	4a <_ecc_projective_add_point.isra.0+0x4a>
         return MEMORY_E;
 452:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 456:	e60e      	b.n	76 <_ecc_projective_add_point.isra.0+0x76>

Disassembly of section .text.wc_ecc_curve_free:

00000000 <wc_ecc_curve_free>:
{
   0:	b510      	push	{r4, lr}
    if (curve) {
   2:	4604      	mov	r4, r0
   4:	2800      	cmp	r0, #0
   6:	d042      	beq.n	8e <wc_ecc_curve_free+0x8e>
    if (curve->load_mask & ECC_CURVE_FIELD_PRIME)
   8:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
   c:	07db      	lsls	r3, r3, #31
   e:	d509      	bpl.n	24 <wc_ecc_curve_free+0x24>
        wc_ecc_curve_cache_free_spec_item(curve, curve->prime, ECC_CURVE_FIELD_PRIME);
  10:	6840      	ldr	r0, [r0, #4]
    if (item) {
  12:	b108      	cbz	r0, 18 <wc_ecc_curve_free+0x18>
        mp_clear(item);
  14:	f7ff fffe 	bl	0 <mp_clear>
    curve->load_mask &= ~mask;
  18:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  1c:	f023 0301 	bic.w	r3, r3, #1
  20:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    if (curve->load_mask & ECC_CURVE_FIELD_AF)
  24:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  28:	0798      	lsls	r0, r3, #30
  2a:	d509      	bpl.n	40 <wc_ecc_curve_free+0x40>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Af, ECC_CURVE_FIELD_AF);
  2c:	68a0      	ldr	r0, [r4, #8]
    if (item) {
  2e:	b108      	cbz	r0, 34 <wc_ecc_curve_free+0x34>
        mp_clear(item);
  30:	f7ff fffe 	bl	0 <mp_clear>
    curve->load_mask &= ~mask;
  34:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  38:	f023 0302 	bic.w	r3, r3, #2
  3c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    if (curve->load_mask & ECC_CURVE_FIELD_ORDER)
  40:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  44:	0719      	lsls	r1, r3, #28
  46:	d509      	bpl.n	5c <wc_ecc_curve_free+0x5c>
        wc_ecc_curve_cache_free_spec_item(curve, curve->order, ECC_CURVE_FIELD_ORDER);
  48:	68e0      	ldr	r0, [r4, #12]
    if (item) {
  4a:	b108      	cbz	r0, 50 <wc_ecc_curve_free+0x50>
        mp_clear(item);
  4c:	f7ff fffe 	bl	0 <mp_clear>
    curve->load_mask &= ~mask;
  50:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  54:	f023 0308 	bic.w	r3, r3, #8
  58:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    if (curve->load_mask & ECC_CURVE_FIELD_GX)
  5c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  60:	06da      	lsls	r2, r3, #27
  62:	d509      	bpl.n	78 <wc_ecc_curve_free+0x78>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gx, ECC_CURVE_FIELD_GX);
  64:	6920      	ldr	r0, [r4, #16]
    if (item) {
  66:	b108      	cbz	r0, 6c <wc_ecc_curve_free+0x6c>
        mp_clear(item);
  68:	f7ff fffe 	bl	0 <mp_clear>
    curve->load_mask &= ~mask;
  6c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  70:	f023 0310 	bic.w	r3, r3, #16
  74:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    if (curve->load_mask & ECC_CURVE_FIELD_GY)
  78:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  7c:	069b      	lsls	r3, r3, #26
  7e:	d503      	bpl.n	88 <wc_ecc_curve_free+0x88>
        wc_ecc_curve_cache_free_spec_item(curve, curve->Gy, ECC_CURVE_FIELD_GY);
  80:	6960      	ldr	r0, [r4, #20]
    if (item) {
  82:	b108      	cbz	r0, 88 <wc_ecc_curve_free+0x88>
        mp_clear(item);
  84:	f7ff fffe 	bl	0 <mp_clear>
    curve->load_mask = 0;
  88:	2300      	movs	r3, #0
  8a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
  8e:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_curve_load:

00000000 <wc_ecc_curve_load>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (dp == NULL || pCurve == NULL)
   2:	4606      	mov	r6, r0
   4:	2800      	cmp	r0, #0
   6:	d048      	beq.n	9a <wc_ecc_curve_load+0x9a>
    curve = *pCurve;
   8:	680d      	ldr	r5, [r1, #0]
    if (curve->dp != dp) {
   a:	682b      	ldr	r3, [r5, #0]
    curve->dp = dp; /* set dp info */
   c:	6028      	str	r0, [r5, #0]
    if (curve->dp != dp) {
   e:	4283      	cmp	r3, r0
        curve->load_mask = 0;
  10:	bf1c      	itt	ne
  12:	2300      	movne	r3, #0
  14:	f885 3024 	strbne.w	r3, [r5, #36]	; 0x24
    load_items = (byte)(((byte)~(word32)curve->load_mask) & load_mask);
  18:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
  1c:	ea22 0703 	bic.w	r7, r2, r3
    if (load_items & ECC_CURVE_FIELD_PRIME)
  20:	f017 0401 	ands.w	r4, r7, #1
    curve->load_mask |= load_items;
  24:	ea43 0302 	orr.w	r3, r3, r2
  28:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
    if (load_items & ECC_CURVE_FIELD_PRIME)
  2c:	d006      	beq.n	3c <wc_ecc_curve_load+0x3c>
        ret += wc_ecc_curve_cache_load_item(curve, dp->prime, &curve->prime,
  2e:	68c1      	ldr	r1, [r0, #12]
  30:	2301      	movs	r3, #1
  32:	1d2a      	adds	r2, r5, #4
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <wc_ecc_curve_load>
  3a:	4604      	mov	r4, r0
    if (load_items & ECC_CURVE_FIELD_AF)
  3c:	07b8      	lsls	r0, r7, #30
  3e:	d507      	bpl.n	50 <wc_ecc_curve_load+0x50>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Af, &curve->Af,
  40:	6931      	ldr	r1, [r6, #16]
  42:	2302      	movs	r3, #2
  44:	f105 0208 	add.w	r2, r5, #8
  48:	4628      	mov	r0, r5
  4a:	f7ff fffe 	bl	0 <wc_ecc_curve_load>
  4e:	4404      	add	r4, r0
    if (load_items & ECC_CURVE_FIELD_ORDER)
  50:	0739      	lsls	r1, r7, #28
  52:	d507      	bpl.n	64 <wc_ecc_curve_load+0x64>
        ret += wc_ecc_curve_cache_load_item(curve, dp->order, &curve->order,
  54:	69b1      	ldr	r1, [r6, #24]
  56:	2308      	movs	r3, #8
  58:	f105 020c 	add.w	r2, r5, #12
  5c:	4628      	mov	r0, r5
  5e:	f7ff fffe 	bl	0 <wc_ecc_curve_load>
  62:	4404      	add	r4, r0
    if (load_items & ECC_CURVE_FIELD_GX)
  64:	06fa      	lsls	r2, r7, #27
  66:	d506      	bpl.n	76 <wc_ecc_curve_load+0x76>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gx, &curve->Gx,
  68:	2310      	movs	r3, #16
  6a:	69f1      	ldr	r1, [r6, #28]
  6c:	18ea      	adds	r2, r5, r3
  6e:	4628      	mov	r0, r5
  70:	f7ff fffe 	bl	0 <wc_ecc_curve_load>
  74:	4404      	add	r4, r0
    if (load_items & ECC_CURVE_FIELD_GY)
  76:	06bb      	lsls	r3, r7, #26
  78:	d507      	bpl.n	8a <wc_ecc_curve_load+0x8a>
        ret += wc_ecc_curve_cache_load_item(curve, dp->Gy, &curve->Gy,
  7a:	6a31      	ldr	r1, [r6, #32]
  7c:	2320      	movs	r3, #32
  7e:	f105 0214 	add.w	r2, r5, #20
  82:	4628      	mov	r0, r5
  84:	f7ff fffe 	bl	0 <wc_ecc_curve_load>
  88:	4404      	add	r4, r0
    if (ret != 0) {
  8a:	b124      	cbz	r4, 96 <wc_ecc_curve_load+0x96>
        wc_ecc_curve_free(curve);
  8c:	4628      	mov	r0, r5
  8e:	f7ff fffe 	bl	0 <wc_ecc_curve_load>
        ret = MP_READ_E;
  92:	f06f 046e 	mvn.w	r4, #110	; 0x6e
}
  96:	4620      	mov	r0, r4
  98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
  9a:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  9e:	e7fa      	b.n	96 <wc_ecc_curve_load+0x96>

Disassembly of section .text.wc_ecc_set_curve:

00000000 <wc_ecc_set_curve>:
    if (key == NULL || (keysize <= 0 && curve_id < 0)) {
   0:	4603      	mov	r3, r0
   2:	b118      	cbz	r0, c <wc_ecc_set_curve+0xc>
   4:	2900      	cmp	r1, #0
   6:	dc04      	bgt.n	12 <wc_ecc_set_curve+0x12>
   8:	2a00      	cmp	r2, #0
   a:	da04      	bge.n	16 <wc_ecc_set_curve+0x16>
        return BAD_FUNC_ARG;
   c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  10:	4770      	bx	lr
    if (keysize > ECC_MAXSIZE) {
  12:	2942      	cmp	r1, #66	; 0x42
  14:	dc13      	bgt.n	3e <wc_ecc_set_curve+0x3e>
    if (key->idx != ECC_CUSTOM_IDX) {
  16:	6858      	ldr	r0, [r3, #4]
  18:	3001      	adds	r0, #1
  1a:	f04f 0000 	mov.w	r0, #0
  1e:	d007      	beq.n	30 <wc_ecc_set_curve+0x30>
            if (curve_id > ECC_CURVE_DEF) {
  20:	4282      	cmp	r2, r0
        key->idx = 0;
  22:	6058      	str	r0, [r3, #4]
        key->dp = NULL;
  24:	6118      	str	r0, [r3, #16]
            if (curve_id > ECC_CURVE_DEF) {
  26:	dc04      	bgt.n	32 <wc_ecc_set_curve+0x32>
            else if (keysize <= ecc_sets[x].size) {
  28:	2920      	cmp	r1, #32
  2a:	dd04      	ble.n	36 <wc_ecc_set_curve+0x36>
            return ECC_CURVE_OID_E;
  2c:	f06f 00ab 	mvn.w	r0, #171	; 0xab
}
  30:	4770      	bx	lr
                if (curve_id == ecc_sets[x].id)
  32:	2a07      	cmp	r2, #7
  34:	d1fa      	bne.n	2c <wc_ecc_set_curve+0x2c>
        key->dp  = &ecc_sets[x];
  36:	4a03      	ldr	r2, [pc, #12]	; (44 <wc_ecc_set_curve+0x44>)
  38:	611a      	str	r2, [r3, #16]
    return 0;
  3a:	2000      	movs	r0, #0
  3c:	4770      	bx	lr
        return ECC_BAD_ARG_E;
  3e:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  42:	4770      	bx	lr
  44:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_import_raw_private:

00000000 <wc_ecc_import_raw_private>:
#endif /* !NO_ASN */

#ifdef HAVE_ECC_KEY_IMPORT
static int wc_ecc_import_raw_private(ecc_key* key, const char* qx,
          const char* qy, const char* d, int curve_id, int encType)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b085      	sub	sp, #20
   6:	468a      	mov	sl, r1
   8:	4691      	mov	r9, r2
   a:	9303      	str	r3, [sp, #12]
    defined(WOLFSSL_CRYPTOCELL)
    word32 keySz = 0;
#endif

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || qy == NULL) {
   c:	4604      	mov	r4, r0
   e:	2800      	cmp	r0, #0
  10:	f000 80a8 	beq.w	164 <wc_ecc_import_raw_private+0x164>
  14:	2900      	cmp	r1, #0
  16:	f000 80a5 	beq.w	164 <wc_ecc_import_raw_private+0x164>
  1a:	2a00      	cmp	r2, #0
  1c:	f000 80a2 	beq.w	164 <wc_ecc_import_raw_private+0x164>
    key->state = ECC_STATE_NONE;
  20:	2100      	movs	r1, #0

    /* make sure required variables are reset */
    wc_ecc_reset(key);

    /* set curve type and index */
    err = wc_ecc_set_curve(key, 0, curve_id);
  22:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    key->state = ECC_STATE_NONE;
  24:	6081      	str	r1, [r0, #8]
    err = wc_ecc_set_curve(key, 0, curve_id);
  26:	f7ff fffe 	bl	0 <wc_ecc_import_raw_private>
    if (err != 0) {
  2a:	4680      	mov	r8, r0
  2c:	2800      	cmp	r0, #0
  2e:	f040 8095 	bne.w	15c <wc_ecc_import_raw_private+0x15c>
    alt_fp_init(key->pubkey.y);
    alt_fp_init(key->pubkey.z);
    key->k = (mp_int*)key->ka;
    alt_fp_init(key->k);
#else
    err = mp_init_multi(key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,
  32:	f504 77a8 	add.w	r7, r4, #336	; 0x150
  36:	f104 0618 	add.w	r6, r4, #24
  3a:	f104 0580 	add.w	r5, r4, #128	; 0x80
  3e:	f104 0be8 	add.w	fp, r4, #232	; 0xe8
  42:	e9cd 0000 	strd	r0, r0, [sp]
  46:	465b      	mov	r3, fp
  48:	462a      	mov	r2, r5
  4a:	4631      	mov	r1, r6
  4c:	4638      	mov	r0, r7
  4e:	f7ff fffe 	bl	0 <mp_init_multi>
                                                                  NULL, NULL);
#endif
    if (err != MP_OKAY)
  52:	2800      	cmp	r0, #0
  54:	f040 8089 	bne.w	16a <wc_ecc_import_raw_private+0x16a>
        return MEMORY_E;

    /* read Qx */
    if (err == MP_OKAY) {
        if (encType == WC_TYPE_HEX_STR)
  58:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  5a:	2b01      	cmp	r3, #1
  5c:	d120      	bne.n	a0 <wc_ecc_import_raw_private+0xa0>
            err = mp_read_radix(key->pubkey.x, qx, MP_RADIX_HEX);
  5e:	2210      	movs	r2, #16
  60:	4651      	mov	r1, sl
  62:	4630      	mov	r0, r6
  64:	f7ff fffe 	bl	0 <mp_read_radix>
        else
            err = mp_read_unsigned_bin(key->pubkey.x, (const byte*)qx,
                (word32)key->dp->size);

        if (mp_isneg(key->pubkey.x)) {
  68:	69e2      	ldr	r2, [r4, #28]
            err = mp_read_unsigned_bin(key->pubkey.x, (const byte*)qx,
  6a:	4680      	mov	r8, r0
            WOLFSSL_MSG("Invalid Qx");
            err = BAD_FUNC_ARG;
  6c:	2a00      	cmp	r2, #0
        }
        if (mp_unsigned_bin_size(key->pubkey.x) > key->dp->size) {
  6e:	4630      	mov	r0, r6
            err = BAD_FUNC_ARG;
  70:	bf18      	it	ne
  72:	f06f 08ac 	mvnne.w	r8, #172	; 0xac
        if (mp_unsigned_bin_size(key->pubkey.x) > key->dp->size) {
  76:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  7a:	6922      	ldr	r2, [r4, #16]
  7c:	6812      	ldr	r2, [r2, #0]
  7e:	4290      	cmp	r0, r2
  80:	dd15      	ble.n	ae <wc_ecc_import_raw_private+0xae>
            err = BAD_FUNC_ARG;
  82:	f06f 08ac 	mvn.w	r8, #172	; 0xac
        err = silabs_ecc_import(key, key->dp->size, 1, (d != NULL));
    }
#endif

    if (err != MP_OKAY) {
        mp_clear(key->pubkey.x);
  86:	4630      	mov	r0, r6
  88:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(key->pubkey.y);
  8c:	4628      	mov	r0, r5
  8e:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(key->pubkey.z);
  92:	4658      	mov	r0, fp
  94:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(key->k);
  98:	4638      	mov	r0, r7
  9a:	f7ff fffe 	bl	0 <mp_clear>
  9e:	e05d      	b.n	15c <wc_ecc_import_raw_private+0x15c>
                (word32)key->dp->size);
  a0:	6923      	ldr	r3, [r4, #16]
            err = mp_read_unsigned_bin(key->pubkey.x, (const byte*)qx,
  a2:	4651      	mov	r1, sl
  a4:	681a      	ldr	r2, [r3, #0]
  a6:	4630      	mov	r0, r6
  a8:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
  ac:	e7dc      	b.n	68 <wc_ecc_import_raw_private+0x68>
    if (err == MP_OKAY) {
  ae:	f1b8 0f00 	cmp.w	r8, #0
  b2:	d1e8      	bne.n	86 <wc_ecc_import_raw_private+0x86>
        if (encType == WC_TYPE_HEX_STR)
  b4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  b6:	2b01      	cmp	r3, #1
  b8:	d13a      	bne.n	130 <wc_ecc_import_raw_private+0x130>
            err = mp_read_radix(key->pubkey.y, qy, MP_RADIX_HEX);
  ba:	2210      	movs	r2, #16
  bc:	4649      	mov	r1, r9
  be:	4628      	mov	r0, r5
  c0:	f7ff fffe 	bl	0 <mp_read_radix>
        if (mp_isneg(key->pubkey.y)) {
  c4:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
            err = mp_read_unsigned_bin(key->pubkey.y, (const byte*)qy,
  c8:	4680      	mov	r8, r0
            err = BAD_FUNC_ARG;
  ca:	2a00      	cmp	r2, #0
        if (mp_unsigned_bin_size(key->pubkey.y) > key->dp->size) {
  cc:	4628      	mov	r0, r5
            err = BAD_FUNC_ARG;
  ce:	bf18      	it	ne
  d0:	f06f 08ac 	mvnne.w	r8, #172	; 0xac
        if (mp_unsigned_bin_size(key->pubkey.y) > key->dp->size) {
  d4:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  d8:	6922      	ldr	r2, [r4, #16]
  da:	6812      	ldr	r2, [r2, #0]
  dc:	4290      	cmp	r0, r2
  de:	dcd0      	bgt.n	82 <wc_ecc_import_raw_private+0x82>
    if (err == MP_OKAY) {
  e0:	f1b8 0f00 	cmp.w	r8, #0
  e4:	d1cf      	bne.n	86 <wc_ecc_import_raw_private+0x86>
        if (mp_iszero(key->pubkey.x) && mp_iszero(key->pubkey.y)) {
  e6:	4630      	mov	r0, r6
  e8:	f7ff fffe 	bl	0 <mp_iszero>
  ec:	bb28      	cbnz	r0, 13a <wc_ecc_import_raw_private+0x13a>
        err = mp_set(key->pubkey.z, 1);
  ee:	2101      	movs	r1, #1
  f0:	4658      	mov	r0, fp
  f2:	f7ff fffe 	bl	0 <mp_set>
    if (err == MP_OKAY) {
  f6:	4680      	mov	r8, r0
  f8:	2800      	cmp	r0, #0
  fa:	d1c4      	bne.n	86 <wc_ecc_import_raw_private+0x86>
        if (d != NULL) {
  fc:	9b03      	ldr	r3, [sp, #12]
  fe:	b35b      	cbz	r3, 158 <wc_ecc_import_raw_private+0x158>
            key->type = ECC_PRIVATEKEY;
 100:	2302      	movs	r3, #2
 102:	6023      	str	r3, [r4, #0]
            if (encType == WC_TYPE_HEX_STR)
 104:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 106:	2b01      	cmp	r3, #1
 108:	d11f      	bne.n	14a <wc_ecc_import_raw_private+0x14a>
                err = mp_read_radix(key->k, d, MP_RADIX_HEX);
 10a:	9903      	ldr	r1, [sp, #12]
 10c:	2210      	movs	r2, #16
 10e:	4638      	mov	r0, r7
 110:	f7ff fffe 	bl	0 <mp_read_radix>
                    err = mp_read_unsigned_bin(key->k, (const byte*)d,
 114:	4680      	mov	r8, r0
            if (mp_iszero(key->k) || mp_isneg(key->k)) {
 116:	4638      	mov	r0, r7
 118:	f7ff fffe 	bl	0 <mp_iszero>
 11c:	2800      	cmp	r0, #0
 11e:	d1b0      	bne.n	82 <wc_ecc_import_raw_private+0x82>
 120:	f8d4 2154 	ldr.w	r2, [r4, #340]	; 0x154
 124:	2a00      	cmp	r2, #0
 126:	d1ac      	bne.n	82 <wc_ecc_import_raw_private+0x82>
    if (err != MP_OKAY) {
 128:	f1b8 0f00 	cmp.w	r8, #0
 12c:	d016      	beq.n	15c <wc_ecc_import_raw_private+0x15c>
 12e:	e7aa      	b.n	86 <wc_ecc_import_raw_private+0x86>
            err = mp_read_unsigned_bin(key->pubkey.y, (const byte*)qy,
 130:	4649      	mov	r1, r9
 132:	4628      	mov	r0, r5
 134:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
 138:	e7c4      	b.n	c4 <wc_ecc_import_raw_private+0xc4>
        if (mp_iszero(key->pubkey.x) && mp_iszero(key->pubkey.y)) {
 13a:	4628      	mov	r0, r5
 13c:	f7ff fffe 	bl	0 <mp_iszero>
 140:	2800      	cmp	r0, #0
 142:	d0d4      	beq.n	ee <wc_ecc_import_raw_private+0xee>
            err = ECC_INF_E;
 144:	f06f 08d6 	mvn.w	r8, #214	; 0xd6
 148:	e79d      	b.n	86 <wc_ecc_import_raw_private+0x86>
                        (word32)key->dp->size);
 14a:	6923      	ldr	r3, [r4, #16]
                    err = mp_read_unsigned_bin(key->k, (const byte*)d,
 14c:	9903      	ldr	r1, [sp, #12]
 14e:	681a      	ldr	r2, [r3, #0]
 150:	4638      	mov	r0, r7
 152:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
 156:	e7dd      	b.n	114 <wc_ecc_import_raw_private+0x114>
            key->type = ECC_PUBLICKEY;
 158:	2201      	movs	r2, #1
 15a:	6022      	str	r2, [r4, #0]
        ForceZero(key->keyRaw, sizeof(key->keyRaw));
#endif
    }

    return err;
}
 15c:	4640      	mov	r0, r8
 15e:	b005      	add	sp, #20
 160:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return BAD_FUNC_ARG;
 164:	f06f 08ac 	mvn.w	r8, #172	; 0xac
 168:	e7f8      	b.n	15c <wc_ecc_import_raw_private+0x15c>
        return MEMORY_E;
 16a:	f06f 087c 	mvn.w	r8, #124	; 0x7c
 16e:	e7f5      	b.n	15c <wc_ecc_import_raw_private+0x15c>

Disassembly of section .text.ecc_projective_add_point:

00000000 <ecc_projective_add_point>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460d      	mov	r5, r1
   6:	e9dd 4806 	ldrd	r4, r8, [sp, #24]
   a:	4617      	mov	r7, r2
    if (P == NULL || Q == NULL || R == NULL || modulus == NULL) {
   c:	4606      	mov	r6, r0
   e:	b3b8      	cbz	r0, 80 <ecc_projective_add_point+0x80>
  10:	b3b1      	cbz	r1, 80 <ecc_projective_add_point+0x80>
  12:	b3aa      	cbz	r2, 80 <ecc_projective_add_point+0x80>
  14:	b3a4      	cbz	r4, 80 <ecc_projective_add_point+0x80>
    if (mp_cmp(P->x, modulus) != MP_LT ||
  16:	4621      	mov	r1, r4
  18:	f7ff fffe 	bl	0 <mp_cmp>
  1c:	3001      	adds	r0, #1
  1e:	d003      	beq.n	28 <ecc_projective_add_point+0x28>
        return ECC_OUT_OF_RANGE_E;
  20:	f06f 00d8 	mvn.w	r0, #216	; 0xd8
}
  24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mp_cmp(P->y, modulus) != MP_LT ||
  28:	4621      	mov	r1, r4
  2a:	f106 0068 	add.w	r0, r6, #104	; 0x68
  2e:	f7ff fffe 	bl	0 <mp_cmp>
    if (mp_cmp(P->x, modulus) != MP_LT ||
  32:	3001      	adds	r0, #1
  34:	d1f4      	bne.n	20 <ecc_projective_add_point+0x20>
        mp_cmp(P->z, modulus) != MP_LT ||
  36:	4621      	mov	r1, r4
  38:	f106 00d0 	add.w	r0, r6, #208	; 0xd0
  3c:	f7ff fffe 	bl	0 <mp_cmp>
        mp_cmp(P->y, modulus) != MP_LT ||
  40:	3001      	adds	r0, #1
  42:	d1ed      	bne.n	20 <ecc_projective_add_point+0x20>
        mp_cmp(Q->x, modulus) != MP_LT ||
  44:	4621      	mov	r1, r4
  46:	4628      	mov	r0, r5
  48:	f7ff fffe 	bl	0 <mp_cmp>
        mp_cmp(P->z, modulus) != MP_LT ||
  4c:	3001      	adds	r0, #1
  4e:	d1e7      	bne.n	20 <ecc_projective_add_point+0x20>
        mp_cmp(Q->y, modulus) != MP_LT ||
  50:	4621      	mov	r1, r4
  52:	f105 0068 	add.w	r0, r5, #104	; 0x68
  56:	f7ff fffe 	bl	0 <mp_cmp>
        mp_cmp(Q->x, modulus) != MP_LT ||
  5a:	3001      	adds	r0, #1
  5c:	d1e0      	bne.n	20 <ecc_projective_add_point+0x20>
        mp_cmp(Q->z, modulus) != MP_LT) {
  5e:	4621      	mov	r1, r4
  60:	f105 00d0 	add.w	r0, r5, #208	; 0xd0
  64:	f7ff fffe 	bl	0 <mp_cmp>
        mp_cmp(Q->y, modulus) != MP_LT ||
  68:	3001      	adds	r0, #1
  6a:	d1d9      	bne.n	20 <ecc_projective_add_point+0x20>
    return _ecc_projective_add_point(P, Q, R, a, modulus, mp);
  6c:	f8cd 8018 	str.w	r8, [sp, #24]
  70:	4623      	mov	r3, r4
  72:	463a      	mov	r2, r7
  74:	4629      	mov	r1, r5
  76:	4630      	mov	r0, r6
}
  78:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return _ecc_projective_add_point(P, Q, R, a, modulus, mp);
  7c:	f7ff bffe 	b.w	0 <ecc_projective_add_point>
        return ECC_BAD_ARG_E;
  80:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  84:	e7ce      	b.n	24 <ecc_projective_add_point+0x24>

Disassembly of section .text.ecc_projective_dbl_point:

00000000 <ecc_projective_dbl_point>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	9f06      	ldr	r7, [sp, #24]
   6:	460e      	mov	r6, r1
   8:	461c      	mov	r4, r3
    if (P == NULL || R == NULL || modulus == NULL)
   a:	4605      	mov	r5, r0
   c:	b300      	cbz	r0, 50 <ecc_projective_dbl_point+0x50>
   e:	b1f9      	cbz	r1, 50 <ecc_projective_dbl_point+0x50>
  10:	b1f3      	cbz	r3, 50 <ecc_projective_dbl_point+0x50>
    if (mp_cmp(P->x, modulus) != MP_LT ||
  12:	4619      	mov	r1, r3
  14:	f7ff fffe 	bl	0 <mp_cmp>
  18:	3001      	adds	r0, #1
  1a:	d003      	beq.n	24 <ecc_projective_dbl_point+0x24>
        return ECC_OUT_OF_RANGE_E;
  1c:	f06f 00d8 	mvn.w	r0, #216	; 0xd8
}
  20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mp_cmp(P->y, modulus) != MP_LT ||
  24:	4621      	mov	r1, r4
  26:	f105 0068 	add.w	r0, r5, #104	; 0x68
  2a:	f7ff fffe 	bl	0 <mp_cmp>
    if (mp_cmp(P->x, modulus) != MP_LT ||
  2e:	3001      	adds	r0, #1
  30:	d1f4      	bne.n	1c <ecc_projective_dbl_point+0x1c>
        mp_cmp(P->z, modulus) != MP_LT) {
  32:	4621      	mov	r1, r4
  34:	f105 00d0 	add.w	r0, r5, #208	; 0xd0
  38:	f7ff fffe 	bl	0 <mp_cmp>
        mp_cmp(P->y, modulus) != MP_LT ||
  3c:	3001      	adds	r0, #1
  3e:	d1ed      	bne.n	1c <ecc_projective_dbl_point+0x1c>
    return _ecc_projective_dbl_point(P, R, a, modulus, mp);
  40:	463b      	mov	r3, r7
  42:	4622      	mov	r2, r4
  44:	4631      	mov	r1, r6
  46:	4628      	mov	r0, r5
}
  48:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return _ecc_projective_dbl_point(P, R, a, modulus, mp);
  4c:	f7ff bffe 	b.w	0 <ecc_projective_dbl_point>
        return ECC_BAD_ARG_E;
  50:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  54:	e7e4      	b.n	20 <ecc_projective_dbl_point+0x20>

Disassembly of section .text.ecc_map_ex:

00000000 <ecc_map_ex>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	460f      	mov	r7, r1
   6:	4691      	mov	r9, r2
   8:	461c      	mov	r4, r3
   if (P == NULL || modulus == NULL)
   a:	4682      	mov	sl, r0
   c:	2800      	cmp	r0, #0
   e:	f000 80b5 	beq.w	17c <ecc_map_ex+0x17c>
  12:	2900      	cmp	r1, #0
  14:	f000 80b2 	beq.w	17c <ecc_map_ex+0x17c>
   if (mp_cmp_d(P->z, 0) == MP_EQ) {
  18:	f100 08d0 	add.w	r8, r0, #208	; 0xd0
  1c:	2100      	movs	r1, #0
  1e:	4640      	mov	r0, r8
  20:	f7ff fffe 	bl	0 <mp_cmp_d>
  24:	4601      	mov	r1, r0
  26:	b9a8      	cbnz	r0, 54 <ecc_map_ex+0x54>
       err = mp_set(P->x, 0);
  28:	4650      	mov	r0, sl
  2a:	f7ff fffe 	bl	0 <mp_set>
       if (err == MP_OKAY)
  2e:	4604      	mov	r4, r0
  30:	2800      	cmp	r0, #0
  32:	f040 8092 	bne.w	15a <ecc_map_ex+0x15a>
           err = mp_set(P->y, 0);
  36:	4601      	mov	r1, r0
  38:	f10a 0068 	add.w	r0, sl, #104	; 0x68
  3c:	f7ff fffe 	bl	0 <mp_set>
       if (err == MP_OKAY)
  40:	4604      	mov	r4, r0
  42:	2800      	cmp	r0, #0
  44:	f040 8089 	bne.w	15a <ecc_map_ex+0x15a>
           err = mp_set(P->z, 1);
  48:	4640      	mov	r0, r8
  4a:	2101      	movs	r1, #1
}
  4c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
           err = mp_set(P->z, 1);
  50:	f7ff bffe 	b.w	0 <mp_set>
      NEW_MP_INT_SIZE(t1, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
  54:	2068      	movs	r0, #104	; 0x68
  56:	f7ff fffe 	bl	0 <malloc>
  5a:	4605      	mov	r5, r0
  5c:	b118      	cbz	r0, 66 <ecc_map_ex+0x66>
  5e:	2268      	movs	r2, #104	; 0x68
  60:	2100      	movs	r1, #0
  62:	f7ff fffe 	bl	0 <memset>
      NEW_MP_INT_SIZE(t2, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
  66:	2068      	movs	r0, #104	; 0x68
  68:	f7ff fffe 	bl	0 <malloc>
  6c:	4606      	mov	r6, r0
  6e:	2800      	cmp	r0, #0
  70:	f000 8087 	beq.w	182 <ecc_map_ex+0x182>
  74:	2268      	movs	r2, #104	; 0x68
  76:	2100      	movs	r1, #0
  78:	f7ff fffe 	bl	0 <memset>
      if (t1 == NULL || t2 == NULL) {
  7c:	b90d      	cbnz	r5, 82 <ecc_map_ex+0x82>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  7e:	4630      	mov	r0, r6
  80:	e007      	b.n	92 <ecc_map_ex+0x92>
   err = INIT_MP_INT_SIZE(t1, mp_bitsused(modulus));
  82:	4628      	mov	r0, r5
  84:	f7ff fffe 	bl	0 <mp_init>
   if (err == MP_OKAY) {
  88:	b130      	cbz	r0, 98 <ecc_map_ex+0x98>
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  8a:	4630      	mov	r0, r6
  8c:	f7ff fffe 	bl	0 <free>
         FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
  90:	4628      	mov	r0, r5
         FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
  92:	f7ff fffe 	bl	0 <free>
  96:	e076      	b.n	186 <ecc_map_ex+0x186>
      err = INIT_MP_INT_SIZE(t2, mp_bitsused(modulus));
  98:	4630      	mov	r0, r6
  9a:	f7ff fffe 	bl	0 <mp_init>
   if (err != MP_OKAY) {
  9e:	2800      	cmp	r0, #0
  a0:	d1f3      	bne.n	8a <ecc_map_ex+0x8a>
       if (ct) {
  a2:	2c00      	cmp	r4, #0
  a4:	d05c      	beq.n	160 <ecc_map_ex+0x160>
           err = mp_invmod_mont_ct(z, modulus, t1, mp);
  a6:	464b      	mov	r3, r9
  a8:	462a      	mov	r2, r5
  aa:	4639      	mov	r1, r7
  ac:	4640      	mov	r0, r8
  ae:	f7ff fffe 	bl	0 <mp_invmod_mont_ct>
           if (err == MP_OKAY)
  b2:	4604      	mov	r4, r0
  b4:	2800      	cmp	r0, #0
  b6:	d144      	bne.n	142 <ecc_map_ex+0x142>
               err = mp_montgomery_reduce(t1, modulus, mp);
  b8:	464a      	mov	r2, r9
  ba:	4639      	mov	r1, r7
  bc:	4628      	mov	r0, r5
  be:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
               err = mp_invmod(z, modulus, t1);
  c2:	4604      	mov	r4, r0
   if (err == MP_OKAY)
  c4:	bbe8      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_sqr(t1, t2);
  c6:	4631      	mov	r1, r6
  c8:	4628      	mov	r0, r5
  ca:	f7ff fffe 	bl	0 <mp_sqr>
   if (err == MP_OKAY)
  ce:	4604      	mov	r4, r0
  d0:	bbb8      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_mod(t2, modulus, t2);
  d2:	4632      	mov	r2, r6
  d4:	4639      	mov	r1, r7
  d6:	4630      	mov	r0, r6
  d8:	f7ff fffe 	bl	0 <mp_mod>
   if (err == MP_OKAY)
  dc:	4604      	mov	r4, r0
  de:	bb80      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_mul(t1, t2, t1);
  e0:	462a      	mov	r2, r5
  e2:	4631      	mov	r1, r6
  e4:	4628      	mov	r0, r5
  e6:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
  ea:	4604      	mov	r4, r0
  ec:	bb48      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_mod(t1, modulus, t1);
  ee:	462a      	mov	r2, r5
  f0:	4639      	mov	r1, r7
  f2:	4628      	mov	r0, r5
  f4:	f7ff fffe 	bl	0 <mp_mod>
   if (err == MP_OKAY)
  f8:	4604      	mov	r4, r0
  fa:	bb10      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_mul(x, t2, x);
  fc:	4652      	mov	r2, sl
  fe:	4631      	mov	r1, r6
 100:	4650      	mov	r0, sl
 102:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 106:	4604      	mov	r4, r0
 108:	b9d8      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_montgomery_reduce(x, modulus, mp);
 10a:	464a      	mov	r2, r9
 10c:	4639      	mov	r1, r7
 10e:	4650      	mov	r0, sl
 110:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 114:	4604      	mov	r4, r0
 116:	b9a0      	cbnz	r0, 142 <ecc_map_ex+0x142>
   y = P->y;
 118:	f10a 0a68 	add.w	sl, sl, #104	; 0x68
       err = mp_mul(y, t1, y);
 11c:	4652      	mov	r2, sl
 11e:	4629      	mov	r1, r5
 120:	4650      	mov	r0, sl
 122:	f7ff fffe 	bl	0 <mp_mul>
   if (err == MP_OKAY)
 126:	4604      	mov	r4, r0
 128:	b958      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_montgomery_reduce(y, modulus, mp);
 12a:	464a      	mov	r2, r9
 12c:	4639      	mov	r1, r7
 12e:	4650      	mov	r0, sl
 130:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
   if (err == MP_OKAY)
 134:	4604      	mov	r4, r0
 136:	b920      	cbnz	r0, 142 <ecc_map_ex+0x142>
       err = mp_set(z, 1);
 138:	2101      	movs	r1, #1
 13a:	4640      	mov	r0, r8
 13c:	f7ff fffe 	bl	0 <mp_set>
 140:	4604      	mov	r4, r0
   mp_clear(t1);
 142:	4628      	mov	r0, r5
 144:	f7ff fffe 	bl	0 <mp_clear>
   mp_clear(t2);
 148:	4630      	mov	r0, r6
 14a:	f7ff fffe 	bl	0 <mp_clear>
      FREE_MP_INT_SIZE(t2, NULL, DYNAMIC_TYPE_ECC);
 14e:	4630      	mov	r0, r6
 150:	f7ff fffe 	bl	0 <free>
      FREE_MP_INT_SIZE(t1, NULL, DYNAMIC_TYPE_ECC);
 154:	4628      	mov	r0, r5
 156:	f7ff fffe 	bl	0 <free>
}
 15a:	4620      	mov	r0, r4
 15c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
           err = mp_montgomery_reduce(z, modulus, mp);
 160:	464a      	mov	r2, r9
 162:	4639      	mov	r1, r7
 164:	4640      	mov	r0, r8
 166:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
           if (err == MP_OKAY)
 16a:	4604      	mov	r4, r0
 16c:	2800      	cmp	r0, #0
 16e:	d1e8      	bne.n	142 <ecc_map_ex+0x142>
               err = mp_invmod(z, modulus, t1);
 170:	462a      	mov	r2, r5
 172:	4639      	mov	r1, r7
 174:	4640      	mov	r0, r8
 176:	f7ff fffe 	bl	0 <mp_invmod>
 17a:	e7a2      	b.n	c2 <ecc_map_ex+0xc2>
       return ECC_BAD_ARG_E;
 17c:	f06f 04a9 	mvn.w	r4, #169	; 0xa9
 180:	e7eb      	b.n	15a <ecc_map_ex+0x15a>
      if (t1 == NULL || t2 == NULL) {
 182:	2d00      	cmp	r5, #0
 184:	d184      	bne.n	90 <ecc_map_ex+0x90>
         return MEMORY_E;
 186:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 18a:	e7e6      	b.n	15a <ecc_map_ex+0x15a>

Disassembly of section .text.ecc_map:

00000000 <ecc_map>:
    return ecc_map_ex(P, modulus, mp, 0);
   0:	2300      	movs	r3, #0
   2:	f7ff bffe 	b.w	0 <ecc_map>

Disassembly of section .text.wc_ecc_new_point_h:

00000000 <wc_ecc_new_point_h>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    ecc_point* p = NULL;
   2:	2300      	movs	r3, #0
    (void)wc_ecc_new_point_ex(&p, heap);
   4:	a801      	add	r0, sp, #4
    ecc_point* p = NULL;
   6:	9301      	str	r3, [sp, #4]
    (void)wc_ecc_new_point_ex(&p, heap);
   8:	f7ff fffe 	bl	0 <wc_ecc_new_point_h>
}
   c:	9801      	ldr	r0, [sp, #4]
   e:	b003      	add	sp, #12
  10:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.wc_ecc_new_point:

00000000 <wc_ecc_new_point>:
{
   0:	b507      	push	{r0, r1, r2, lr}
   ecc_point* p = NULL;
   2:	2300      	movs	r3, #0
   (void)wc_ecc_new_point_ex(&p, NULL);
   4:	a801      	add	r0, sp, #4
   ecc_point* p = NULL;
   6:	9301      	str	r3, [sp, #4]
   (void)wc_ecc_new_point_ex(&p, NULL);
   8:	f7ff fffe 	bl	0 <wc_ecc_new_point>
}
   c:	9801      	ldr	r0, [sp, #4]
   e:	b003      	add	sp, #12
  10:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.wc_ecc_del_point_h:

00000000 <wc_ecc_del_point_h>:
   wc_ecc_del_point_ex(p, heap);
   0:	f7ff bffe 	b.w	0 <wc_ecc_del_point_h>

Disassembly of section .text.wc_ecc_del_point:

00000000 <wc_ecc_del_point>:
    wc_ecc_del_point_ex(p, NULL);
   0:	f7ff bffe 	b.w	0 <wc_ecc_del_point>

Disassembly of section .text.wc_ecc_forcezero_point:

00000000 <wc_ecc_forcezero_point>:
{
   0:	b510      	push	{r4, lr}
    if (p != NULL) {
   2:	4604      	mov	r4, r0
   4:	b158      	cbz	r0, 1e <wc_ecc_forcezero_point+0x1e>
        mp_forcezero(p->x);
   6:	f7ff fffe 	bl	0 <mp_forcezero>
        mp_forcezero(p->y);
   a:	f104 0068 	add.w	r0, r4, #104	; 0x68
   e:	f7ff fffe 	bl	0 <mp_forcezero>
        mp_forcezero(p->z);
  12:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
}
  16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        mp_forcezero(p->z);
  1a:	f7ff bffe 	b.w	0 <mp_forcezero>
}
  1e:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_copy_point:

00000000 <wc_ecc_copy_point>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    if (p == NULL || r == NULL)
   4:	4604      	mov	r4, r0
   6:	b190      	cbz	r0, 2e <wc_ecc_copy_point+0x2e>
   8:	b189      	cbz	r1, 2e <wc_ecc_copy_point+0x2e>
    ret = mp_copy(p->x, r->x);
   a:	f7ff fffe 	bl	0 <mp_copy>
    if (ret != MP_OKAY)
   e:	b980      	cbnz	r0, 32 <wc_ecc_copy_point+0x32>
    ret = mp_copy(p->y, r->y);
  10:	f105 0168 	add.w	r1, r5, #104	; 0x68
  14:	f104 0068 	add.w	r0, r4, #104	; 0x68
  18:	f7ff fffe 	bl	0 <mp_copy>
    if (ret != MP_OKAY)
  1c:	b948      	cbnz	r0, 32 <wc_ecc_copy_point+0x32>
    ret = mp_copy(p->z, r->z);
  1e:	f105 01d0 	add.w	r1, r5, #208	; 0xd0
  22:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
}
  26:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = mp_copy(p->z, r->z);
  2a:	f7ff bffe 	b.w	0 <mp_copy>
        return ECC_BAD_ARG_E;
  2e:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
}
  32:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.wc_ecc_cmp_point:

00000000 <wc_ecc_cmp_point>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    if (a == NULL || b == NULL)
   4:	4604      	mov	r4, r0
   6:	b190      	cbz	r0, 2e <wc_ecc_cmp_point+0x2e>
   8:	b189      	cbz	r1, 2e <wc_ecc_cmp_point+0x2e>
    ret = mp_cmp(a->x, b->x);
   a:	f7ff fffe 	bl	0 <mp_cmp>
    if (ret != MP_EQ)
   e:	b980      	cbnz	r0, 32 <wc_ecc_cmp_point+0x32>
    ret = mp_cmp(a->y, b->y);
  10:	f105 0168 	add.w	r1, r5, #104	; 0x68
  14:	f104 0068 	add.w	r0, r4, #104	; 0x68
  18:	f7ff fffe 	bl	0 <mp_cmp>
    if (ret != MP_EQ)
  1c:	b948      	cbnz	r0, 32 <wc_ecc_cmp_point+0x32>
    ret = mp_cmp(a->z, b->z);
  1e:	f105 01d0 	add.w	r1, r5, #208	; 0xd0
  22:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
}
  26:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = mp_cmp(a->z, b->z);
  2a:	f7ff bffe 	b.w	0 <mp_cmp>
        return BAD_FUNC_ARG;
  2e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  32:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.wc_ecc_is_valid_idx:

00000000 <wc_ecc_is_valid_idx>:
   if (n >= (int)ECC_SET_COUNT)
   0:	3001      	adds	r0, #1
}
   2:	2801      	cmp	r0, #1
   4:	bf8c      	ite	hi
   6:	2000      	movhi	r0, #0
   8:	2001      	movls	r0, #1
   a:	4770      	bx	lr

Disassembly of section .text.wc_ecc_get_curve_idx:

00000000 <wc_ecc_get_curve_idx>:
}
   0:	3807      	subs	r0, #7
   2:	bf18      	it	ne
   4:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   8:	4770      	bx	lr

Disassembly of section .text.wc_ecc_get_name:

00000000 <wc_ecc_get_name>:
{
   0:	b508      	push	{r3, lr}
    int curve_idx = wc_ecc_get_curve_idx(curve_id);
   2:	f7ff fffe 	bl	0 <wc_ecc_get_name>
    if (curve_idx == ECC_CURVE_INVALID)
   6:	1c43      	adds	r3, r0, #1
    return ecc_sets[curve_idx].name;
   8:	bf1d      	ittte	ne
   a:	4b04      	ldrne	r3, [pc, #16]	; (1c <wc_ecc_get_name+0x1c>)
   c:	2234      	movne	r2, #52	; 0x34
   e:	fb02 3000 	mlane	r0, r2, r0, r3
        return NULL;
  12:	2000      	moveq	r0, #0
    return ecc_sets[curve_idx].name;
  14:	bf18      	it	ne
  16:	6880      	ldrne	r0, [r0, #8]
}
  18:	bd08      	pop	{r3, pc}
  1a:	bf00      	nop
  1c:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_id:

00000000 <wc_ecc_get_curve_id>:
{
   0:	b508      	push	{r3, lr}
   2:	4602      	mov	r2, r0
    if (wc_ecc_is_valid_idx(curve_idx)) {
   4:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id>
   8:	b128      	cbz	r0, 16 <wc_ecc_get_curve_id+0x16>
        return ecc_sets[curve_idx].id;
   a:	4b04      	ldr	r3, [pc, #16]	; (1c <wc_ecc_get_curve_id+0x1c>)
   c:	2034      	movs	r0, #52	; 0x34
   e:	fb00 3002 	mla	r0, r0, r2, r3
  12:	6840      	ldr	r0, [r0, #4]
}
  14:	bd08      	pop	{r3, pc}
    return ECC_CURVE_INVALID;
  16:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1a:	e7fb      	b.n	14 <wc_ecc_get_curve_id+0x14>
  1c:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_size_from_id:

00000000 <wc_ecc_get_curve_size_from_id>:
{
   0:	b508      	push	{r3, lr}
    int curve_idx = wc_ecc_get_curve_idx(curve_id);
   2:	f7ff fffe 	bl	0 <wc_ecc_get_curve_size_from_id>
    if (curve_idx == ECC_CURVE_INVALID)
   6:	1c43      	adds	r3, r0, #1
    return ecc_sets[curve_idx].size;
   8:	bf1d      	ittte	ne
   a:	2334      	movne	r3, #52	; 0x34
   c:	4358      	mulne	r0, r3
   e:	4b03      	ldrne	r3, [pc, #12]	; (1c <wc_ecc_get_curve_size_from_id+0x1c>)
        return ECC_BAD_ARG_E;
  10:	f06f 00a9 	mvneq.w	r0, #169	; 0xa9
    return ecc_sets[curve_idx].size;
  14:	bf18      	it	ne
  16:	5818      	ldrne	r0, [r3, r0]
}
  18:	bd08      	pop	{r3, pc}
  1a:	bf00      	nop
  1c:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_idx_from_name:

00000000 <wc_ecc_get_curve_idx_from_name>:
{
   0:	b508      	push	{r3, lr}
    if (curveName == NULL)
   2:	4601      	mov	r1, r0
   4:	b138      	cbz	r0, 16 <wc_ecc_get_curve_idx_from_name+0x16>
                XSTRCASECMP(ecc_sets[curve_idx].name, curveName) == 0) {
   6:	4805      	ldr	r0, [pc, #20]	; (1c <wc_ecc_get_curve_idx_from_name+0x1c>)
   8:	f7ff fffe 	bl	0 <strcasecmp>
            ecc_sets[curve_idx].name &&
   c:	3800      	subs	r0, #0
   e:	bf18      	it	ne
  10:	2001      	movne	r0, #1
  12:	4240      	negs	r0, r0
}
  14:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1a:	e7fb      	b.n	14 <wc_ecc_get_curve_idx_from_name+0x14>
  1c:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_size_from_name:

00000000 <wc_ecc_get_curve_size_from_name>:
{
   0:	b508      	push	{r3, lr}
    if (curveName == NULL)
   2:	b140      	cbz	r0, 16 <wc_ecc_get_curve_size_from_name+0x16>
    curve_idx = wc_ecc_get_curve_idx_from_name(curveName);
   4:	f7ff fffe 	bl	0 <wc_ecc_get_curve_size_from_name>
    if (curve_idx < 0)
   8:	2800      	cmp	r0, #0
   a:	db03      	blt.n	14 <wc_ecc_get_curve_size_from_name+0x14>
    return ecc_sets[curve_idx].size;
   c:	2334      	movs	r3, #52	; 0x34
   e:	4358      	muls	r0, r3
  10:	4b02      	ldr	r3, [pc, #8]	; (1c <wc_ecc_get_curve_size_from_name+0x1c>)
  12:	5818      	ldr	r0, [r3, r0]
}
  14:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1a:	e7fb      	b.n	14 <wc_ecc_get_curve_size_from_name+0x14>
  1c:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_id_from_name:

00000000 <wc_ecc_get_curve_id_from_name>:
{
   0:	b508      	push	{r3, lr}
    if (curveName == NULL)
   2:	b148      	cbz	r0, 18 <wc_ecc_get_curve_id_from_name+0x18>
    curve_idx = wc_ecc_get_curve_idx_from_name(curveName);
   4:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_name>
    if (curve_idx < 0)
   8:	2800      	cmp	r0, #0
   a:	db04      	blt.n	16 <wc_ecc_get_curve_id_from_name+0x16>
    return ecc_sets[curve_idx].id;
   c:	4b04      	ldr	r3, [pc, #16]	; (20 <wc_ecc_get_curve_id_from_name+0x20>)
   e:	2234      	movs	r2, #52	; 0x34
  10:	fb02 3000 	mla	r0, r2, r0, r3
  14:	6840      	ldr	r0, [r0, #4]
}
  16:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
  18:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1c:	e7fb      	b.n	16 <wc_ecc_get_curve_id_from_name+0x16>
  1e:	bf00      	nop
  20:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_id_from_params:

00000000 <wc_ecc_get_curve_id_from_params>:
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
   8:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
   c:	4691      	mov	r9, r2
   e:	461f      	mov	r7, r3
    if (prime == NULL || Af == NULL || Bf == NULL || order == NULL ||
  10:	460e      	mov	r6, r1
  12:	2900      	cmp	r1, #0
  14:	d05c      	beq.n	d0 <wc_ecc_get_curve_id_from_params+0xd0>
  16:	2b00      	cmp	r3, #0
  18:	d05a      	beq.n	d0 <wc_ecc_get_curve_id_from_params+0xd0>
  1a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  1c:	2b00      	cmp	r3, #0
  1e:	d057      	beq.n	d0 <wc_ecc_get_curve_id_from_params+0xd0>
  20:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  22:	2b00      	cmp	r3, #0
  24:	d054      	beq.n	d0 <wc_ecc_get_curve_id_from_params+0xd0>
  26:	f1ba 0f00 	cmp.w	sl, #0
  2a:	d051      	beq.n	d0 <wc_ecc_get_curve_id_from_params+0xd0>
        Gx == NULL || Gy == NULL)
  2c:	f1bb 0f00 	cmp.w	fp, #0
  30:	d04e      	beq.n	d0 <wc_ecc_get_curve_id_from_params+0xd0>
    curveSz = (fieldSize + 1) / 8;    /* round up */
  32:	1c45      	adds	r5, r0, #1
  34:	bf48      	it	mi
  36:	f100 0508 	addmi.w	r5, r0, #8
  3a:	4c27      	ldr	r4, [pc, #156]	; (d8 <wc_ecc_get_curve_id_from_params+0xd8>)
  3c:	10ed      	asrs	r5, r5, #3
    for (idx = 0; ecc_sets[idx].size != 0; idx++) {
  3e:	f04f 0800 	mov.w	r8, #0
  42:	6823      	ldr	r3, [r4, #0]
  44:	b91b      	cbnz	r3, 4e <wc_ecc_get_curve_id_from_params+0x4e>
        return ECC_CURVE_INVALID;
  46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  4a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (curveSz == ecc_sets[idx].size) {
  4e:	42ab      	cmp	r3, r5
  50:	d003      	beq.n	5a <wc_ecc_get_curve_id_from_params+0x5a>
    for (idx = 0; ecc_sets[idx].size != 0; idx++) {
  52:	f108 0801 	add.w	r8, r8, #1
  56:	3434      	adds	r4, #52	; 0x34
  58:	e7f3      	b.n	42 <wc_ecc_get_curve_id_from_params+0x42>
            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, prime,
  5a:	68e0      	ldr	r0, [r4, #12]
  5c:	2302      	movs	r3, #2
  5e:	464a      	mov	r2, r9
  60:	4631      	mov	r1, r6
  62:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_params>
  66:	2800      	cmp	r0, #0
  68:	d1f3      	bne.n	52 <wc_ecc_get_curve_id_from_params+0x52>
                (wc_ecc_cmp_param(ecc_sets[idx].Af, Af, AfSz,
  6a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  6c:	6920      	ldr	r0, [r4, #16]
  6e:	2302      	movs	r3, #2
  70:	4639      	mov	r1, r7
  72:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_params>
                            primeSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
  76:	2800      	cmp	r0, #0
  78:	d1eb      	bne.n	52 <wc_ecc_get_curve_id_from_params+0x52>
                (wc_ecc_cmp_param(ecc_sets[idx].Bf, Bf, BfSz,
  7a:	e9dd 120b 	ldrd	r1, r2, [sp, #44]	; 0x2c
  7e:	6960      	ldr	r0, [r4, #20]
  80:	2302      	movs	r3, #2
  82:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_params>
                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
  86:	2800      	cmp	r0, #0
  88:	d1e3      	bne.n	52 <wc_ecc_get_curve_id_from_params+0x52>
                (wc_ecc_cmp_param(ecc_sets[idx].order, order,
  8a:	e9dd 120d 	ldrd	r1, r2, [sp, #52]	; 0x34
  8e:	69a0      	ldr	r0, [r4, #24]
  90:	2302      	movs	r3, #2
  92:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_params>
                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
  96:	2800      	cmp	r0, #0
  98:	d1db      	bne.n	52 <wc_ecc_get_curve_id_from_params+0x52>
                (wc_ecc_cmp_param(ecc_sets[idx].Gx, Gx, GxSz,
  9a:	9a10      	ldr	r2, [sp, #64]	; 0x40
  9c:	69e0      	ldr	r0, [r4, #28]
  9e:	2302      	movs	r3, #2
  a0:	4651      	mov	r1, sl
  a2:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_params>
                                  orderSz, WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
  a6:	2800      	cmp	r0, #0
  a8:	d1d3      	bne.n	52 <wc_ecc_get_curve_id_from_params+0x52>
                (wc_ecc_cmp_param(ecc_sets[idx].Gy, Gy, GySz,
  aa:	9a12      	ldr	r2, [sp, #72]	; 0x48
  ac:	6a20      	ldr	r0, [r4, #32]
  ae:	2302      	movs	r3, #2
  b0:	4659      	mov	r1, fp
  b2:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_params>
                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
  b6:	2800      	cmp	r0, #0
  b8:	d1cb      	bne.n	52 <wc_ecc_get_curve_id_from_params+0x52>
                                  WC_TYPE_UNSIGNED_BIN) == MP_EQ) &&
  ba:	6b23      	ldr	r3, [r4, #48]	; 0x30
  bc:	9a13      	ldr	r2, [sp, #76]	; 0x4c
  be:	4293      	cmp	r3, r2
  c0:	d1c7      	bne.n	52 <wc_ecc_get_curve_id_from_params+0x52>
    return ecc_sets[idx].id;
  c2:	4b05      	ldr	r3, [pc, #20]	; (d8 <wc_ecc_get_curve_id_from_params+0xd8>)
  c4:	2234      	movs	r2, #52	; 0x34
  c6:	fb02 3808 	mla	r8, r2, r8, r3
  ca:	f8d8 0004 	ldr.w	r0, [r8, #4]
  ce:	e7bc      	b.n	4a <wc_ecc_get_curve_id_from_params+0x4a>
        return BAD_FUNC_ARG;
  d0:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  d4:	e7b9      	b.n	4a <wc_ecc_get_curve_id_from_params+0x4a>
  d6:	bf00      	nop
  d8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_id_from_dp_params:

00000000 <wc_ecc_get_curve_id_from_dp_params>:
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if (dp == NULL
   4:	4604      	mov	r4, r0
   6:	2800      	cmp	r0, #0
   8:	f000 8085 	beq.w	116 <wc_ecc_get_curve_id_from_dp_params+0x116>
         || dp->prime == NULL ||  dp->Af == NULL ||
   c:	68c3      	ldr	r3, [r0, #12]
   e:	2b00      	cmp	r3, #0
  10:	f000 8081 	beq.w	116 <wc_ecc_get_curve_id_from_dp_params+0x116>
  14:	6903      	ldr	r3, [r0, #16]
  16:	2b00      	cmp	r3, #0
  18:	d07d      	beq.n	116 <wc_ecc_get_curve_id_from_dp_params+0x116>
  1a:	6943      	ldr	r3, [r0, #20]
  1c:	2b00      	cmp	r3, #0
  1e:	d07a      	beq.n	116 <wc_ecc_get_curve_id_from_dp_params+0x116>
        dp->Bf == NULL || dp->order == NULL || dp->Gx == NULL || dp->Gy == NULL
  20:	6983      	ldr	r3, [r0, #24]
  22:	2b00      	cmp	r3, #0
  24:	d077      	beq.n	116 <wc_ecc_get_curve_id_from_dp_params+0x116>
  26:	69c3      	ldr	r3, [r0, #28]
  28:	2b00      	cmp	r3, #0
  2a:	d074      	beq.n	116 <wc_ecc_get_curve_id_from_dp_params+0x116>
  2c:	6a03      	ldr	r3, [r0, #32]
  2e:	2b00      	cmp	r3, #0
  30:	d071      	beq.n	116 <wc_ecc_get_curve_id_from_dp_params+0x116>
  32:	4d3a      	ldr	r5, [pc, #232]	; (11c <wc_ecc_get_curve_id_from_dp_params+0x11c>)
    for (idx = 0; ecc_sets[idx].size != 0; idx++) {
  34:	2700      	movs	r7, #0
  36:	462e      	mov	r6, r5
  38:	682b      	ldr	r3, [r5, #0]
  3a:	b91b      	cbnz	r3, 44 <wc_ecc_get_curve_id_from_dp_params+0x44>
        return ECC_CURVE_INVALID;
  3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if (dp->size == ecc_sets[idx].size) {
  44:	6822      	ldr	r2, [r4, #0]
  46:	429a      	cmp	r2, r3
  48:	d002      	beq.n	50 <wc_ecc_get_curve_id_from_dp_params+0x50>
    for (idx = 0; ecc_sets[idx].size != 0; idx++) {
  4a:	3701      	adds	r7, #1
  4c:	3534      	adds	r5, #52	; 0x34
  4e:	e7f3      	b.n	38 <wc_ecc_get_curve_id_from_dp_params+0x38>
            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,
  50:	f8d4 800c 	ldr.w	r8, [r4, #12]
  54:	f8d5 900c 	ldr.w	r9, [r5, #12]
                    (word32)XSTRLEN(dp->prime), WC_TYPE_HEX_STR) == MP_EQ) &&
  58:	4640      	mov	r0, r8
  5a:	f7ff fffe 	bl	0 <strlen>
            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,
  5e:	2301      	movs	r3, #1
                    (word32)XSTRLEN(dp->prime), WC_TYPE_HEX_STR) == MP_EQ) &&
  60:	4602      	mov	r2, r0
            if ((wc_ecc_cmp_param(ecc_sets[idx].prime, (const byte*)dp->prime,
  62:	4641      	mov	r1, r8
  64:	4648      	mov	r0, r9
  66:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_dp_params>
  6a:	2800      	cmp	r0, #0
  6c:	d1ed      	bne.n	4a <wc_ecc_get_curve_id_from_dp_params+0x4a>
                (wc_ecc_cmp_param(ecc_sets[idx].Af, (const byte*)dp->Af,
  6e:	f8d4 8010 	ldr.w	r8, [r4, #16]
  72:	f8d5 9010 	ldr.w	r9, [r5, #16]
                    (word32)XSTRLEN(dp->Af),WC_TYPE_HEX_STR) == MP_EQ) &&
  76:	4640      	mov	r0, r8
  78:	f7ff fffe 	bl	0 <strlen>
                (wc_ecc_cmp_param(ecc_sets[idx].Af, (const byte*)dp->Af,
  7c:	2301      	movs	r3, #1
                    (word32)XSTRLEN(dp->Af),WC_TYPE_HEX_STR) == MP_EQ) &&
  7e:	4602      	mov	r2, r0
                (wc_ecc_cmp_param(ecc_sets[idx].Af, (const byte*)dp->Af,
  80:	4641      	mov	r1, r8
  82:	4648      	mov	r0, r9
  84:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_dp_params>
                    (word32)XSTRLEN(dp->prime), WC_TYPE_HEX_STR) == MP_EQ) &&
  88:	2800      	cmp	r0, #0
  8a:	d1de      	bne.n	4a <wc_ecc_get_curve_id_from_dp_params+0x4a>
                (wc_ecc_cmp_param(ecc_sets[idx].Bf, (const byte*)dp->Bf,
  8c:	f8d4 8014 	ldr.w	r8, [r4, #20]
  90:	f8d5 9014 	ldr.w	r9, [r5, #20]
                    (word32)XSTRLEN(dp->Bf),WC_TYPE_HEX_STR) == MP_EQ) &&
  94:	4640      	mov	r0, r8
  96:	f7ff fffe 	bl	0 <strlen>
                (wc_ecc_cmp_param(ecc_sets[idx].Bf, (const byte*)dp->Bf,
  9a:	2301      	movs	r3, #1
                    (word32)XSTRLEN(dp->Bf),WC_TYPE_HEX_STR) == MP_EQ) &&
  9c:	4602      	mov	r2, r0
                (wc_ecc_cmp_param(ecc_sets[idx].Bf, (const byte*)dp->Bf,
  9e:	4641      	mov	r1, r8
  a0:	4648      	mov	r0, r9
  a2:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_dp_params>
                    (word32)XSTRLEN(dp->Af),WC_TYPE_HEX_STR) == MP_EQ) &&
  a6:	2800      	cmp	r0, #0
  a8:	d1cf      	bne.n	4a <wc_ecc_get_curve_id_from_dp_params+0x4a>
                (wc_ecc_cmp_param(ecc_sets[idx].order, (const byte*)dp->order,
  aa:	f8d4 8018 	ldr.w	r8, [r4, #24]
  ae:	f8d5 9018 	ldr.w	r9, [r5, #24]
                    (word32)XSTRLEN(dp->order),WC_TYPE_HEX_STR) == MP_EQ) &&
  b2:	4640      	mov	r0, r8
  b4:	f7ff fffe 	bl	0 <strlen>
                (wc_ecc_cmp_param(ecc_sets[idx].order, (const byte*)dp->order,
  b8:	2301      	movs	r3, #1
                    (word32)XSTRLEN(dp->order),WC_TYPE_HEX_STR) == MP_EQ) &&
  ba:	4602      	mov	r2, r0
                (wc_ecc_cmp_param(ecc_sets[idx].order, (const byte*)dp->order,
  bc:	4641      	mov	r1, r8
  be:	4648      	mov	r0, r9
  c0:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_dp_params>
                    (word32)XSTRLEN(dp->Bf),WC_TYPE_HEX_STR) == MP_EQ) &&
  c4:	2800      	cmp	r0, #0
  c6:	d1c0      	bne.n	4a <wc_ecc_get_curve_id_from_dp_params+0x4a>
                (wc_ecc_cmp_param(ecc_sets[idx].Gx, (const byte*)dp->Gx,
  c8:	f8d4 801c 	ldr.w	r8, [r4, #28]
  cc:	f8d5 901c 	ldr.w	r9, [r5, #28]
                    (word32)XSTRLEN(dp->Gx),WC_TYPE_HEX_STR) == MP_EQ) &&
  d0:	4640      	mov	r0, r8
  d2:	f7ff fffe 	bl	0 <strlen>
                (wc_ecc_cmp_param(ecc_sets[idx].Gx, (const byte*)dp->Gx,
  d6:	2301      	movs	r3, #1
                    (word32)XSTRLEN(dp->Gx),WC_TYPE_HEX_STR) == MP_EQ) &&
  d8:	4602      	mov	r2, r0
                (wc_ecc_cmp_param(ecc_sets[idx].Gx, (const byte*)dp->Gx,
  da:	4641      	mov	r1, r8
  dc:	4648      	mov	r0, r9
  de:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_dp_params>
                    (word32)XSTRLEN(dp->order),WC_TYPE_HEX_STR) == MP_EQ) &&
  e2:	2800      	cmp	r0, #0
  e4:	d1b1      	bne.n	4a <wc_ecc_get_curve_id_from_dp_params+0x4a>
                (wc_ecc_cmp_param(ecc_sets[idx].Gy, (const byte*)dp->Gy,
  e6:	f8d4 8020 	ldr.w	r8, [r4, #32]
  ea:	f8d5 9020 	ldr.w	r9, [r5, #32]
                    (word32)XSTRLEN(dp->Gy),WC_TYPE_HEX_STR) == MP_EQ) &&
  ee:	4640      	mov	r0, r8
  f0:	f7ff fffe 	bl	0 <strlen>
                (wc_ecc_cmp_param(ecc_sets[idx].Gy, (const byte*)dp->Gy,
  f4:	2301      	movs	r3, #1
                    (word32)XSTRLEN(dp->Gy),WC_TYPE_HEX_STR) == MP_EQ) &&
  f6:	4602      	mov	r2, r0
                (wc_ecc_cmp_param(ecc_sets[idx].Gy, (const byte*)dp->Gy,
  f8:	4641      	mov	r1, r8
  fa:	4648      	mov	r0, r9
  fc:	f7ff fffe 	bl	0 <wc_ecc_get_curve_id_from_dp_params>
                    (word32)XSTRLEN(dp->Gx),WC_TYPE_HEX_STR) == MP_EQ) &&
 100:	2800      	cmp	r0, #0
 102:	d1a2      	bne.n	4a <wc_ecc_get_curve_id_from_dp_params+0x4a>
                    (word32)XSTRLEN(dp->Gy),WC_TYPE_HEX_STR) == MP_EQ) &&
 104:	6b22      	ldr	r2, [r4, #48]	; 0x30
 106:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 108:	429a      	cmp	r2, r3
 10a:	d19e      	bne.n	4a <wc_ecc_get_curve_id_from_dp_params+0x4a>
    return ecc_sets[idx].id;
 10c:	2334      	movs	r3, #52	; 0x34
 10e:	fb03 6607 	mla	r6, r3, r7, r6
 112:	6870      	ldr	r0, [r6, #4]
 114:	e794      	b.n	40 <wc_ecc_get_curve_id_from_dp_params+0x40>
        return BAD_FUNC_ARG;
 116:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 11a:	e791      	b.n	40 <wc_ecc_get_curve_id_from_dp_params+0x40>
 11c:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_id_from_oid:

00000000 <wc_ecc_get_curve_id_from_oid>:
{
   0:	460a      	mov	r2, r1
   2:	b508      	push	{r3, lr}
    if (oid == NULL)
   4:	4601      	mov	r1, r0
   6:	b158      	cbz	r0, 20 <wc_ecc_get_curve_id_from_oid+0x20>
            ecc_sets[curve_idx].oid &&
   8:	2a08      	cmp	r2, #8
   a:	d002      	beq.n	12 <wc_ecc_get_curve_id_from_oid+0x12>
        return ECC_CURVE_INVALID;
   c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10:	bd08      	pop	{r3, pc}
                XMEMCMP(ecc_sets[curve_idx].oid, oid, len) == 0
  12:	4805      	ldr	r0, [pc, #20]	; (28 <wc_ecc_get_curve_id_from_oid+0x28>)
  14:	f7ff fffe 	bl	0 <memcmp>
            ecc_sets[curve_idx].oidSz == len &&
  18:	2800      	cmp	r0, #0
  1a:	d1f7      	bne.n	c <wc_ecc_get_curve_id_from_oid+0xc>
    return ecc_sets[curve_idx].id;
  1c:	2007      	movs	r0, #7
  1e:	e7f7      	b.n	10 <wc_ecc_get_curve_id_from_oid+0x10>
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  24:	e7f4      	b.n	10 <wc_ecc_get_curve_id_from_oid+0x10>
  26:	bf00      	nop
  28:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_get_curve_params:

00000000 <wc_ecc_get_curve_params>:
    if (curve_idx >= 0 && curve_idx < (int)ECC_SET_COUNT) {
   0:	2801      	cmp	r0, #1
        ecc_set = &ecc_sets[curve_idx];
   2:	bf9d      	ittte	ls
   4:	4b02      	ldrls	r3, [pc, #8]	; (10 <wc_ecc_get_curve_params+0x10>)
   6:	2234      	movls	r2, #52	; 0x34
   8:	fb02 3000 	mlals	r0, r2, r0, r3
    const ecc_set_type* ecc_set = NULL;
   c:	2000      	movhi	r0, #0
}
   e:	4770      	bx	lr
  10:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_point_is_at_infinity:

00000000 <wc_ecc_point_is_at_infinity>:
{
   0:	b510      	push	{r4, lr}
    if (p == NULL)
   2:	4604      	mov	r4, r0
   4:	b150      	cbz	r0, 1c <wc_ecc_point_is_at_infinity+0x1c>
    if (mp_iszero(p->x) && mp_iszero(p->y))
   6:	f7ff fffe 	bl	0 <mp_iszero>
   a:	b130      	cbz	r0, 1a <wc_ecc_point_is_at_infinity+0x1a>
   c:	f104 0068 	add.w	r0, r4, #104	; 0x68
  10:	f7ff fffe 	bl	0 <mp_iszero>
  14:	3800      	subs	r0, #0
  16:	bf18      	it	ne
  18:	2001      	movne	r0, #1
}
  1a:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  1c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  20:	e7fb      	b.n	1a <wc_ecc_point_is_at_infinity+0x1a>

Disassembly of section .text.wc_ecc_gen_k:

00000000 <wc_ecc_gen_k>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	4615      	mov	r5, r2
   4:	b095      	sub	sp, #84	; 0x54
   6:	461f      	mov	r7, r3
    if (rng == NULL || size < 0 || size + 8 > ECC_MAXSIZE_GEN || k == NULL ||
   8:	b3a0      	cbz	r0, 74 <wc_ecc_gen_k+0x74>
   a:	2942      	cmp	r1, #66	; 0x42
   c:	d832      	bhi.n	74 <wc_ecc_gen_k+0x74>
   e:	b38a      	cbz	r2, 74 <wc_ecc_gen_k+0x74>
  10:	b383      	cbz	r3, 74 <wc_ecc_gen_k+0x74>
    size += 8;
  12:	f101 0608 	add.w	r6, r1, #8
    err = wc_RNG_GenerateBlock(rng, buf, (word32)size);
  16:	4632      	mov	r2, r6
  18:	a901      	add	r1, sp, #4
  1a:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
    if (err == 0)
  1e:	4604      	mov	r4, r0
  20:	b998      	cbnz	r0, 4a <wc_ecc_gen_k+0x4a>
        err = mp_read_unsigned_bin(k, buf, (word32)size);
  22:	4632      	mov	r2, r6
  24:	a901      	add	r1, sp, #4
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
    if (err == MP_OKAY) {
  2c:	4604      	mov	r4, r0
  2e:	b960      	cbnz	r0, 4a <wc_ecc_gen_k+0x4a>
        if (mp_cmp(k, order) != MP_LT) {
  30:	4639      	mov	r1, r7
  32:	4628      	mov	r0, r5
  34:	f7ff fffe 	bl	0 <mp_cmp>
  38:	3001      	adds	r0, #1
  3a:	d110      	bne.n	5e <wc_ecc_gen_k+0x5e>
        if (mp_iszero(k) == MP_YES)
  3c:	4628      	mov	r0, r5
  3e:	f7ff fffe 	bl	0 <mp_iszero>
          err = MP_ZERO_E;
  42:	2801      	cmp	r0, #1
  44:	bf08      	it	eq
  46:	f06f 0478 	mvneq.w	r4, #120	; 0x78
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
  4a:	2300      	movs	r3, #0
  4c:	4619      	mov	r1, r3
  4e:	aa01      	add	r2, sp, #4
  50:	441a      	add	r2, r3
  52:	3301      	adds	r3, #1
  54:	2b4b      	cmp	r3, #75	; 0x4b
  56:	d10b      	bne.n	70 <wc_ecc_gen_k+0x70>
}
  58:	4620      	mov	r0, r4
  5a:	b015      	add	sp, #84	; 0x54
  5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
            err = mp_mod(k, order, k);
  5e:	462a      	mov	r2, r5
  60:	4639      	mov	r1, r7
  62:	4628      	mov	r0, r5
  64:	f7ff fffe 	bl	0 <mp_mod>
    if (err == MP_OKAY) {
  68:	2800      	cmp	r0, #0
  6a:	d0e7      	beq.n	3c <wc_ecc_gen_k+0x3c>
  6c:	4604      	mov	r4, r0
  6e:	e7ec      	b.n	4a <wc_ecc_gen_k+0x4a>
  70:	7011      	strb	r1, [r2, #0]
  72:	e7ec      	b.n	4e <wc_ecc_gen_k+0x4e>
        return BAD_FUNC_ARG;
  74:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  78:	e7ee      	b.n	58 <wc_ecc_gen_k+0x58>

Disassembly of section .text.wc_ecc_gen_z:

00000000 <wc_ecc_gen_z>:
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	e9dd 6b0c 	ldrd	r6, fp, [sp, #48]	; 0x30
   8:	4681      	mov	r9, r0
   a:	468a      	mov	sl, r1
    err = mp_montgomery_calc_normalization(mu, modulus);
   c:	4658      	mov	r0, fp
   e:	4619      	mov	r1, r3
{
  10:	e9dd 780a 	ldrd	r7, r8, [sp, #40]	; 0x28
  14:	4614      	mov	r4, r2
  16:	461d      	mov	r5, r3
    err = mp_montgomery_calc_normalization(mu, modulus);
  18:	f7ff fffe 	bl	0 <mp_montgomery_calc_normalization>
    if (err == MP_OKAY)
  1c:	2800      	cmp	r0, #0
  1e:	d14d      	bne.n	bc <wc_ecc_gen_z+0xbc>
        err = wc_ecc_gen_k(rng, size, ty, modulus);
  20:	462b      	mov	r3, r5
  22:	4632      	mov	r2, r6
  24:	4651      	mov	r1, sl
  26:	4648      	mov	r0, r9
  28:	f7ff fffe 	bl	0 <wc_ecc_gen_z>
    if (err == MP_OKAY)
  2c:	2800      	cmp	r0, #0
  2e:	d145      	bne.n	bc <wc_ecc_gen_z+0xbc>
        err = mp_mulmod(ty, mu, modulus, ty);
  30:	4633      	mov	r3, r6
  32:	462a      	mov	r2, r5
  34:	4659      	mov	r1, fp
  36:	4630      	mov	r0, r6
  38:	f7ff fffe 	bl	0 <mp_mulmod>
    if (err == MP_OKAY)
  3c:	bbf0      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_mul(p->z, ty, p->z);
  3e:	f104 09d0 	add.w	r9, r4, #208	; 0xd0
  42:	464a      	mov	r2, r9
  44:	4631      	mov	r1, r6
  46:	4648      	mov	r0, r9
  48:	f7ff fffe 	bl	0 <mp_mul>
    if (err == MP_OKAY)
  4c:	bbb0      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_montgomery_reduce(p->z, modulus, mp);
  4e:	463a      	mov	r2, r7
  50:	4629      	mov	r1, r5
  52:	4648      	mov	r0, r9
  54:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
    if (err == MP_OKAY)
  58:	bb80      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_sqr(ty, tx);
  5a:	4641      	mov	r1, r8
  5c:	4630      	mov	r0, r6
  5e:	f7ff fffe 	bl	0 <mp_sqr>
    if (err == MP_OKAY)
  62:	bb58      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_montgomery_reduce(tx, modulus, mp);
  64:	463a      	mov	r2, r7
  66:	4629      	mov	r1, r5
  68:	4640      	mov	r0, r8
  6a:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
    if (err == MP_OKAY)
  6e:	bb28      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_mul(ty, tx, ty);
  70:	4632      	mov	r2, r6
  72:	4641      	mov	r1, r8
  74:	4630      	mov	r0, r6
  76:	f7ff fffe 	bl	0 <mp_mul>
    if (err == MP_OKAY)
  7a:	b9f8      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_montgomery_reduce(ty, modulus, mp);
  7c:	463a      	mov	r2, r7
  7e:	4629      	mov	r1, r5
  80:	4630      	mov	r0, r6
  82:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
    if (err == MP_OKAY)
  86:	b9c8      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_mul(p->x, tx, p->x);
  88:	4622      	mov	r2, r4
  8a:	4641      	mov	r1, r8
  8c:	4620      	mov	r0, r4
  8e:	f7ff fffe 	bl	0 <mp_mul>
    if (err == MP_OKAY)
  92:	b998      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_montgomery_reduce(p->x, modulus, mp);
  94:	463a      	mov	r2, r7
  96:	4629      	mov	r1, r5
  98:	4620      	mov	r0, r4
  9a:	f7ff fffe 	bl	0 <mp_montgomery_reduce>
    if (err == MP_OKAY)
  9e:	b968      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_mul(p->y, ty, p->y);
  a0:	3468      	adds	r4, #104	; 0x68
  a2:	4622      	mov	r2, r4
  a4:	4631      	mov	r1, r6
  a6:	4620      	mov	r0, r4
  a8:	f7ff fffe 	bl	0 <mp_mul>
    if (err == MP_OKAY)
  ac:	b930      	cbnz	r0, bc <wc_ecc_gen_z+0xbc>
        err = mp_montgomery_reduce(p->y, modulus, mp);
  ae:	463a      	mov	r2, r7
  b0:	4629      	mov	r1, r5
  b2:	4620      	mov	r0, r4
}
  b4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        err = mp_montgomery_reduce(p->y, modulus, mp);
  b8:	f7ff bffe 	b.w	0 <mp_montgomery_reduce>
}
  bc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.wc_ecc_init_ex:

00000000 <wc_ecc_init_ex>:
{
   0:	b537      	push	{r0, r1, r2, r4, r5, lr}
   2:	460d      	mov	r5, r1
    if (key == NULL) {
   4:	4604      	mov	r4, r0
   6:	b1b0      	cbz	r0, 36 <wc_ecc_init_ex+0x36>
    XMEMSET(key, 0, sizeof(ecc_key));
   8:	f44f 72de 	mov.w	r2, #444	; 0x1bc
   c:	2100      	movs	r1, #0
   e:	f7ff fffe 	bl	0 <memset>
    key->state = ECC_STATE_NONE;
  12:	2300      	movs	r3, #0
  14:	60a3      	str	r3, [r4, #8]
    ret = mp_init_multi(key->k, key->pubkey.x, key->pubkey.y, key->pubkey.z,
  16:	f104 0280 	add.w	r2, r4, #128	; 0x80
  1a:	e9cd 3300 	strd	r3, r3, [sp]
  1e:	f104 0118 	add.w	r1, r4, #24
  22:	f104 03e8 	add.w	r3, r4, #232	; 0xe8
  26:	f504 70a8 	add.w	r0, r4, #336	; 0x150
  2a:	f7ff fffe 	bl	0 <mp_init_multi>
    if (ret != MP_OKAY) {
  2e:	b928      	cbnz	r0, 3c <wc_ecc_init_ex+0x3c>
    key->heap = heap;
  30:	6165      	str	r5, [r4, #20]
}
  32:	b003      	add	sp, #12
  34:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  36:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  3a:	e7fa      	b.n	32 <wc_ecc_init_ex+0x32>
        return MEMORY_E;
  3c:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  40:	e7f7      	b.n	32 <wc_ecc_init_ex+0x32>

Disassembly of section .text.wc_ecc_key_new:

00000000 <wc_ecc_key_new>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4605      	mov	r5, r0
    key = (ecc_key*)XMALLOC(sizeof(ecc_key), heap, DYNAMIC_TYPE_ECC);
   4:	f44f 70de 	mov.w	r0, #444	; 0x1bc
   8:	f7ff fffe 	bl	0 <malloc>
    if (key) {
   c:	4604      	mov	r4, r0
   e:	b148      	cbz	r0, 24 <wc_ecc_key_new+0x24>
        if (wc_ecc_init_ex(key, heap, devId) != 0) {
  10:	f06f 0201 	mvn.w	r2, #1
  14:	4629      	mov	r1, r5
  16:	f7ff fffe 	bl	0 <wc_ecc_key_new>
  1a:	b118      	cbz	r0, 24 <wc_ecc_key_new+0x24>
            XFREE(key, heap, DYNAMIC_TYPE_ECC);
  1c:	4620      	mov	r0, r4
  1e:	f7ff fffe 	bl	0 <free>
            key = NULL;
  22:	2400      	movs	r4, #0
}
  24:	4620      	mov	r0, r4
  26:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.wc_ecc_init:

00000000 <wc_ecc_init>:
    return wc_ecc_init_ex(key, NULL, INVALID_DEVID);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_ecc_init>

Disassembly of section .text.wc_ecc_set_flags:

00000000 <wc_ecc_set_flags>:
    if (key == NULL) {
   0:	b120      	cbz	r0, c <wc_ecc_set_flags+0xc>
    key->flags |= flags;
   2:	68c3      	ldr	r3, [r0, #12]
   4:	430b      	orrs	r3, r1
   6:	60c3      	str	r3, [r0, #12]
    return 0;
   8:	2000      	movs	r0, #0
   a:	4770      	bx	lr
        return BAD_FUNC_ARG;
   c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  10:	4770      	bx	lr

Disassembly of section .text.wc_ecc_free:

00000000 <wc_ecc_free>:
{
   0:	b510      	push	{r4, lr}
    if (key == NULL) {
   2:	4604      	mov	r4, r0
   4:	b170      	cbz	r0, 24 <wc_ecc_free+0x24>
    mp_clear(key->pubkey.x);
   6:	3018      	adds	r0, #24
   8:	f7ff fffe 	bl	0 <mp_clear>
    mp_clear(key->pubkey.y);
   c:	f104 0080 	add.w	r0, r4, #128	; 0x80
  10:	f7ff fffe 	bl	0 <mp_clear>
    mp_clear(key->pubkey.z);
  14:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
  18:	f7ff fffe 	bl	0 <mp_clear>
        mp_forcezero(key->k);
  1c:	f504 70a8 	add.w	r0, r4, #336	; 0x150
  20:	f7ff fffe 	bl	0 <mp_forcezero>
}
  24:	2000      	movs	r0, #0
  26:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_key_free:

00000000 <wc_ecc_key_free>:
{
   0:	b510      	push	{r4, lr}
    if (key) {
   2:	4604      	mov	r4, r0
   4:	b178      	cbz	r0, 26 <wc_ecc_key_free+0x26>
        wc_ecc_free(key);
   6:	f7ff fffe 	bl	0 <wc_ecc_key_free>
   a:	f504 72de 	add.w	r2, r4, #444	; 0x1bc
   e:	4623      	mov	r3, r4
  10:	2100      	movs	r1, #0
  12:	4293      	cmp	r3, r2
  14:	d104      	bne.n	20 <wc_ecc_key_free+0x20>
        XFREE(key, heap, DYNAMIC_TYPE_ECC);
  16:	4620      	mov	r0, r4
}
  18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        XFREE(key, heap, DYNAMIC_TYPE_ECC);
  1c:	f7ff bffe 	b.w	0 <free>
  20:	f803 1b01 	strb.w	r1, [r3], #1
  24:	e7f5      	b.n	12 <wc_ecc_key_free+0x12>
}
  26:	bd10      	pop	{r4, pc}

Disassembly of section .text.ecc_projective_add_point_safe:

00000000 <ecc_projective_add_point_safe>:
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
   6:	e9dd 580a 	ldrd	r5, r8, [sp, #40]	; 0x28
   a:	4606      	mov	r6, r0
   c:	4689      	mov	r9, r1
   e:	4614      	mov	r4, r2
    if (mp_iszero(A->x) && mp_iszero(A->y)) {
  10:	f7ff fffe 	bl	0 <mp_iszero>
  14:	b158      	cbz	r0, 2e <ecc_projective_add_point_safe+0x2e>
  16:	f106 0068 	add.w	r0, r6, #104	; 0x68
  1a:	f7ff fffe 	bl	0 <mp_iszero>
  1e:	b130      	cbz	r0, 2e <ecc_projective_add_point_safe+0x2e>
        err = wc_ecc_copy_point(B, R);
  20:	4621      	mov	r1, r4
  22:	4648      	mov	r0, r9
}
  24:	b002      	add	sp, #8
  26:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        err = wc_ecc_copy_point(A, R);
  2a:	f7ff bffe 	b.w	0 <ecc_projective_add_point_safe>
    else if (mp_iszero(B->x) && mp_iszero(B->y)) {
  2e:	4648      	mov	r0, r9
  30:	f7ff fffe 	bl	0 <mp_iszero>
  34:	b138      	cbz	r0, 46 <ecc_projective_add_point_safe+0x46>
  36:	f109 0068 	add.w	r0, r9, #104	; 0x68
  3a:	f7ff fffe 	bl	0 <mp_iszero>
  3e:	b110      	cbz	r0, 46 <ecc_projective_add_point_safe+0x46>
        err = wc_ecc_copy_point(A, R);
  40:	4621      	mov	r1, r4
  42:	4630      	mov	r0, r6
  44:	e7ee      	b.n	24 <ecc_projective_add_point_safe+0x24>
    else if ((mp_cmp(A->x, B->x) == MP_EQ) && (mp_cmp(A->z, B->z) == MP_EQ)) {
  46:	4649      	mov	r1, r9
  48:	4630      	mov	r0, r6
  4a:	f7ff fffe 	bl	0 <mp_cmp>
  4e:	bb60      	cbnz	r0, aa <ecc_projective_add_point_safe+0xaa>
  50:	f109 01d0 	add.w	r1, r9, #208	; 0xd0
  54:	f106 00d0 	add.w	r0, r6, #208	; 0xd0
  58:	f7ff fffe 	bl	0 <mp_cmp>
  5c:	4682      	mov	sl, r0
  5e:	bb20      	cbnz	r0, aa <ecc_projective_add_point_safe+0xaa>
        if (mp_cmp(A->y, B->y) == MP_EQ) {
  60:	f109 0168 	add.w	r1, r9, #104	; 0x68
  64:	f106 0068 	add.w	r0, r6, #104	; 0x68
  68:	f7ff fffe 	bl	0 <mp_cmp>
  6c:	b920      	cbnz	r0, 78 <ecc_projective_add_point_safe+0x78>
                    err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
  6e:	4643      	mov	r3, r8
  70:	462a      	mov	r2, r5
  72:	4621      	mov	r1, r4
  74:	4648      	mov	r0, r9
  76:	e048      	b.n	10a <ecc_projective_add_point_safe+0x10a>
            err = mp_set(R->x, 0);
  78:	4651      	mov	r1, sl
  7a:	4620      	mov	r0, r4
  7c:	f7ff fffe 	bl	0 <mp_set>
            if (err == MP_OKAY)
  80:	b968      	cbnz	r0, 9e <ecc_projective_add_point_safe+0x9e>
                err = mp_set(R->y, 0);
  82:	4601      	mov	r1, r0
  84:	f104 0068 	add.w	r0, r4, #104	; 0x68
  88:	f7ff fffe 	bl	0 <mp_set>
            if (err == MP_OKAY)
  8c:	b938      	cbnz	r0, 9e <ecc_projective_add_point_safe+0x9e>
                err = mp_set(R->z, 1);
  8e:	2101      	movs	r1, #1
  90:	f104 00d0 	add.w	r0, r4, #208	; 0xd0
  94:	f7ff fffe 	bl	0 <mp_set>
            if ((err == MP_OKAY) && (infinity != NULL))
  98:	b908      	cbnz	r0, 9e <ecc_projective_add_point_safe+0x9e>
  9a:	b91f      	cbnz	r7, a4 <ecc_projective_add_point_safe+0xa4>
                *infinity = 1;
  9c:	2000      	movs	r0, #0
}
  9e:	b002      	add	sp, #8
  a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                *infinity = 1;
  a4:	2301      	movs	r3, #1
  a6:	603b      	str	r3, [r7, #0]
  a8:	e7f8      	b.n	9c <ecc_projective_add_point_safe+0x9c>
        err = _ecc_projective_add_point(A, B, R, a, modulus, mp);
  aa:	f8cd 8000 	str.w	r8, [sp]
  ae:	462b      	mov	r3, r5
  b0:	4622      	mov	r2, r4
  b2:	4649      	mov	r1, r9
  b4:	4630      	mov	r0, r6
  b6:	f7ff fffe 	bl	0 <ecc_projective_add_point_safe>
        if ((err == MP_OKAY) && mp_iszero(R->z)) {
  ba:	2800      	cmp	r0, #0
  bc:	d1ef      	bne.n	9e <ecc_projective_add_point_safe+0x9e>
  be:	f104 06d0 	add.w	r6, r4, #208	; 0xd0
  c2:	4630      	mov	r0, r6
  c4:	f7ff fffe 	bl	0 <mp_iszero>
  c8:	2800      	cmp	r0, #0
  ca:	d0e7      	beq.n	9c <ecc_projective_add_point_safe+0x9c>
            if (mp_iszero(R->x) && mp_iszero(R->y)) {
  cc:	4620      	mov	r0, r4
  ce:	f7ff fffe 	bl	0 <mp_iszero>
  d2:	b1f8      	cbz	r0, 114 <ecc_projective_add_point_safe+0x114>
  d4:	f104 0068 	add.w	r0, r4, #104	; 0x68
  d8:	f7ff fffe 	bl	0 <mp_iszero>
  dc:	b1d0      	cbz	r0, 114 <ecc_projective_add_point_safe+0x114>
                if (mp_iszero(B->z)) {
  de:	f109 00d0 	add.w	r0, r9, #208	; 0xd0
  e2:	f7ff fffe 	bl	0 <mp_iszero>
  e6:	2800      	cmp	r0, #0
  e8:	d0c1      	beq.n	6e <ecc_projective_add_point_safe+0x6e>
                    err = wc_ecc_copy_point(B, R);
  ea:	4621      	mov	r1, r4
  ec:	4648      	mov	r0, r9
  ee:	f7ff fffe 	bl	0 <ecc_projective_add_point_safe>
                    if (err == MP_OKAY) {
  f2:	2800      	cmp	r0, #0
  f4:	d1d3      	bne.n	9e <ecc_projective_add_point_safe+0x9e>
                        err = mp_montgomery_calc_normalization(R->z, modulus);
  f6:	4629      	mov	r1, r5
  f8:	4630      	mov	r0, r6
  fa:	f7ff fffe 	bl	0 <mp_montgomery_calc_normalization>
                    if (err == MP_OKAY) {
  fe:	2800      	cmp	r0, #0
 100:	d1cd      	bne.n	9e <ecc_projective_add_point_safe+0x9e>
                        err = _ecc_projective_dbl_point(R, R, a, modulus, mp);
 102:	4643      	mov	r3, r8
 104:	462a      	mov	r2, r5
 106:	4621      	mov	r1, r4
 108:	4620      	mov	r0, r4
}
 10a:	b002      	add	sp, #8
 10c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                    err = _ecc_projective_dbl_point(B, R, a, modulus, mp);
 110:	f7ff bffe 	b.w	0 <ecc_projective_add_point_safe>
                err = mp_set(R->x, 0);
 114:	2100      	movs	r1, #0
 116:	4620      	mov	r0, r4
 118:	f7ff fffe 	bl	0 <mp_set>
                if (err == MP_OKAY)
 11c:	2800      	cmp	r0, #0
 11e:	d1be      	bne.n	9e <ecc_projective_add_point_safe+0x9e>
                    err = mp_set(R->y, 0);
 120:	4601      	mov	r1, r0
 122:	f104 0068 	add.w	r0, r4, #104	; 0x68
 126:	f7ff fffe 	bl	0 <mp_set>
                if (err == MP_OKAY)
 12a:	2800      	cmp	r0, #0
 12c:	d1b7      	bne.n	9e <ecc_projective_add_point_safe+0x9e>
                    err = mp_set(R->z, 1);
 12e:	2101      	movs	r1, #1
 130:	4630      	mov	r0, r6
 132:	e7af      	b.n	94 <ecc_projective_add_point_safe+0x94>

Disassembly of section .text.ecc_projective_dbl_point_safe:

00000000 <ecc_projective_dbl_point_safe>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	9f06      	ldr	r7, [sp, #24]
   6:	4604      	mov	r4, r0
   8:	460d      	mov	r5, r1
   a:	461e      	mov	r6, r3
    if (mp_iszero(P->x) && mp_iszero(P->y)) {
   c:	f7ff fffe 	bl	0 <mp_iszero>
  10:	b150      	cbz	r0, 28 <ecc_projective_dbl_point_safe+0x28>
  12:	f104 0068 	add.w	r0, r4, #104	; 0x68
  16:	f7ff fffe 	bl	0 <mp_iszero>
  1a:	b128      	cbz	r0, 28 <ecc_projective_dbl_point_safe+0x28>
        err = wc_ecc_copy_point(P, R);
  1c:	4629      	mov	r1, r5
  1e:	4620      	mov	r0, r4
}
  20:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        err = wc_ecc_copy_point(P, R);
  24:	f7ff bffe 	b.w	0 <ecc_projective_dbl_point_safe>
        err = _ecc_projective_dbl_point(P, R, a, modulus, mp);
  28:	463b      	mov	r3, r7
  2a:	4632      	mov	r2, r6
  2c:	4629      	mov	r1, r5
  2e:	4620      	mov	r0, r4
}
  30:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        err = _ecc_projective_dbl_point(P, R, a, modulus, mp);
  34:	f7ff bffe 	b.w	0 <ecc_projective_dbl_point_safe>

Disassembly of section .text.ecc_mulmod:

00000000 <ecc_mulmod>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b08d      	sub	sp, #52	; 0x34
   6:	4688      	mov	r8, r1
   8:	9d17      	ldr	r5, [sp, #92]	; 0x5c
   a:	9005      	str	r0, [sp, #20]
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
   c:	4628      	mov	r0, r5
{
   e:	9206      	str	r2, [sp, #24]
  10:	461c      	mov	r4, r3
  12:	f8dd 9064 	ldr.w	r9, [sp, #100]	; 0x64
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
  16:	f7ff fffe 	bl	0 <mp_count_bits>
    mp_int*  kt = R[2]->x;
  1a:	68a3      	ldr	r3, [r4, #8]
  1c:	9304      	str	r3, [sp, #16]
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
  1e:	4607      	mov	r7, r0
    tmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
  20:	2068      	movs	r0, #104	; 0x68
  22:	f7ff fffe 	bl	0 <malloc>
    if (tmp == NULL) {
  26:	4606      	mov	r6, r0
  28:	2800      	cmp	r0, #0
  2a:	f000 818a 	beq.w	342 <ecc_mulmod+0x342>
        err = mp_init(tmp);
  2e:	f7ff fffe 	bl	0 <mp_init>
    if (err == MP_OKAY)
  32:	4602      	mov	r2, r0
  34:	2800      	cmp	r0, #0
  36:	d147      	bne.n	c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->x, R[0]->x);
  38:	6821      	ldr	r1, [r4, #0]
  3a:	4640      	mov	r0, r8
  3c:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
  40:	4602      	mov	r2, r0
  42:	2800      	cmp	r0, #0
  44:	d140      	bne.n	c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->y, R[0]->y);
  46:	6821      	ldr	r1, [r4, #0]
  48:	f108 0b68 	add.w	fp, r8, #104	; 0x68
  4c:	3168      	adds	r1, #104	; 0x68
  4e:	4658      	mov	r0, fp
  50:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
  54:	4602      	mov	r2, r0
  56:	2800      	cmp	r0, #0
  58:	d136      	bne.n	c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->z, R[0]->z);
  5a:	6821      	ldr	r1, [r4, #0]
  5c:	f108 0ad0 	add.w	sl, r8, #208	; 0xd0
  60:	31d0      	adds	r1, #208	; 0xd0
  62:	4650      	mov	r0, sl
  64:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
  68:	4602      	mov	r2, r0
  6a:	bb68      	cbnz	r0, c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->x, R[1]->x);
  6c:	6861      	ldr	r1, [r4, #4]
  6e:	4640      	mov	r0, r8
  70:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
  74:	4602      	mov	r2, r0
  76:	bb38      	cbnz	r0, c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->y, R[1]->y);
  78:	6861      	ldr	r1, [r4, #4]
  7a:	4658      	mov	r0, fp
  7c:	3168      	adds	r1, #104	; 0x68
  7e:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
  82:	4602      	mov	r2, r0
  84:	bb00      	cbnz	r0, c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->z, R[1]->z);
  86:	6861      	ldr	r1, [r4, #4]
  88:	4650      	mov	r0, sl
  8a:	31d0      	adds	r1, #208	; 0xd0
  8c:	f7ff fffe 	bl	0 <mp_copy>
    if ((err == MP_OKAY) && (rng != NULL))
  90:	4602      	mov	r2, r0
  92:	b9c8      	cbnz	r0, c8 <ecc_mulmod+0xc8>
  94:	f1b9 0f00 	cmp.w	r9, #0
  98:	d11c      	bne.n	d4 <ecc_mulmod+0xd4>
        t = mp_count_bits(modulus) + 1;
  9a:	4628      	mov	r0, r5
  9c:	f7ff fffe 	bl	0 <mp_count_bits>
  a0:	1c43      	adds	r3, r0, #1
  a2:	9307      	str	r3, [sp, #28]
    int      cnt = DIGIT_BIT;
  a4:	f8dd 901c 	ldr.w	r9, [sp, #28]
        v = k->dp[0] >> 1;
  a8:	9b05      	ldr	r3, [sp, #20]
        err = mp_copy(k, kt);
  aa:	9904      	ldr	r1, [sp, #16]
        v = k->dp[0] >> 1;
  ac:	689f      	ldr	r7, [r3, #8]
    int      cnt = DIGIT_BIT;
  ae:	f1b9 0f20 	cmp.w	r9, #32
        err = mp_copy(k, kt);
  b2:	4618      	mov	r0, r3
    int      cnt = DIGIT_BIT;
  b4:	bfa8      	it	ge
  b6:	f04f 0920 	movge.w	r9, #32
        err = mp_copy(k, kt);
  ba:	f7ff fffe 	bl	0 <mp_copy>
        v = k->dp[0] >> 1;
  be:	087f      	lsrs	r7, r7, #1
    if (err == MP_OKAY) {
  c0:	4602      	mov	r2, r0
  c2:	2800      	cmp	r0, #0
  c4:	f000 8139 	beq.w	33a <ecc_mulmod+0x33a>
    XFREE(tmp, NULL, DYNAMIC_TYPE_ECC);
  c8:	4630      	mov	r0, r6
  ca:	9204      	str	r2, [sp, #16]
  cc:	f7ff fffe 	bl	0 <free>
  d0:	9a04      	ldr	r2, [sp, #16]
  d2:	e138      	b.n	346 <ecc_mulmod+0x346>
        err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y, kt);
  d4:	68a3      	ldr	r3, [r4, #8]
  d6:	9a04      	ldr	r2, [sp, #16]
  d8:	9203      	str	r2, [sp, #12]
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
  da:	3707      	adds	r7, #7
        err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y, kt);
  dc:	f103 0268 	add.w	r2, r3, #104	; 0x68
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
  e0:	bf48      	it	mi
  e2:	3707      	addmi	r7, #7
        err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y, kt);
  e4:	e9cd 3201 	strd	r3, r2, [sp, #4]
    int      bytes = (mp_count_bits(modulus) + 7) / 8;
  e8:	10ff      	asrs	r7, r7, #3
        err = wc_ecc_gen_z(rng, bytes, R[0], modulus, mp, R[2]->x, R[2]->y, kt);
  ea:	9b18      	ldr	r3, [sp, #96]	; 0x60
  ec:	6822      	ldr	r2, [r4, #0]
  ee:	9300      	str	r3, [sp, #0]
  f0:	4639      	mov	r1, r7
  f2:	462b      	mov	r3, r5
  f4:	4648      	mov	r0, r9
  f6:	f7ff fffe 	bl	0 <ecc_mulmod>
    if ((err == MP_OKAY) && (rng != NULL))
  fa:	4602      	mov	r2, r0
  fc:	2800      	cmp	r0, #0
  fe:	d1e3      	bne.n	c8 <ecc_mulmod+0xc8>
        err = wc_ecc_gen_z(rng, bytes, R[1], modulus, mp, R[2]->x, R[2]->y, kt);
 100:	68a3      	ldr	r3, [r4, #8]
 102:	9a04      	ldr	r2, [sp, #16]
 104:	9203      	str	r2, [sp, #12]
 106:	f103 0268 	add.w	r2, r3, #104	; 0x68
 10a:	e9cd 3201 	strd	r3, r2, [sp, #4]
 10e:	9b18      	ldr	r3, [sp, #96]	; 0x60
 110:	6862      	ldr	r2, [r4, #4]
 112:	9300      	str	r3, [sp, #0]
 114:	4639      	mov	r1, r7
 116:	462b      	mov	r3, r5
 118:	4648      	mov	r0, r9
 11a:	f7ff fffe 	bl	0 <ecc_mulmod>
    if (err == MP_OKAY) {
 11e:	4602      	mov	r2, r0
 120:	2800      	cmp	r0, #0
 122:	d1d1      	bne.n	c8 <ecc_mulmod+0xc8>
 124:	e7b9      	b.n	9a <ecc_mulmod+0x9a>
        if (--cnt == 0) {
 126:	f1b9 0901 	subs.w	r9, r9, #1
 12a:	d108      	bne.n	13e <ecc_mulmod+0x13e>
            v = kt->dp[j++];
 12c:	f10a 0202 	add.w	r2, sl, #2
 130:	9904      	ldr	r1, [sp, #16]
 132:	f851 7022 	ldr.w	r7, [r1, r2, lsl #2]
 136:	f10a 0a01 	add.w	sl, sl, #1
            cnt = DIGIT_BIT;
 13a:	f04f 0920 	mov.w	r9, #32
        b = v & 1;
 13e:	f007 0201 	and.w	r2, r7, #1
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 142:	9600      	str	r6, [sp, #0]
        swap ^= (int)b;
 144:	4053      	eors	r3, r2
        b = v & 1;
 146:	9208      	str	r2, [sp, #32]
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 148:	e9d4 0100 	ldrd	r0, r1, [r4]
 14c:	682a      	ldr	r2, [r5, #0]
 14e:	9309      	str	r3, [sp, #36]	; 0x24
 150:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        v >>= 1;
 154:	087f      	lsrs	r7, r7, #1
        if (err == MP_OKAY) {
 156:	9b09      	ldr	r3, [sp, #36]	; 0x24
 158:	4602      	mov	r2, r0
 15a:	bb50      	cbnz	r0, 1b2 <ecc_mulmod+0x1b2>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 15c:	e9d4 0100 	ldrd	r0, r1, [r4]
 160:	9600      	str	r6, [sp, #0]
 162:	682a      	ldr	r2, [r5, #0]
 164:	3168      	adds	r1, #104	; 0x68
 166:	3068      	adds	r0, #104	; 0x68
 168:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        if (err == MP_OKAY) {
 16c:	4602      	mov	r2, r0
 16e:	bb00      	cbnz	r0, 1b2 <ecc_mulmod+0x1b2>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 170:	e9d4 0100 	ldrd	r0, r1, [r4]
 174:	9600      	str	r6, [sp, #0]
 176:	682a      	ldr	r2, [r5, #0]
 178:	9b09      	ldr	r3, [sp, #36]	; 0x24
 17a:	31d0      	adds	r1, #208	; 0xd0
 17c:	30d0      	adds	r0, #208	; 0xd0
 17e:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        if (err == MP_OKAY)
 182:	4602      	mov	r2, r0
 184:	b9a8      	cbnz	r0, 1b2 <ecc_mulmod+0x1b2>
            err = ecc_projective_dbl_point_safe(R[0], R[0], a, modulus, mp);
 186:	6821      	ldr	r1, [r4, #0]
 188:	9b18      	ldr	r3, [sp, #96]	; 0x60
 18a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 18c:	9300      	str	r3, [sp, #0]
 18e:	4608      	mov	r0, r1
 190:	462b      	mov	r3, r5
 192:	f7ff fffe 	bl	0 <ecc_mulmod>
        if (err == MP_OKAY) {
 196:	4602      	mov	r2, r0
 198:	b958      	cbnz	r0, 1b2 <ecc_mulmod+0x1b2>
            err = ecc_projective_add_point_safe(R[0], R[1], R[0], a, modulus,
 19a:	e9d4 2100 	ldrd	r2, r1, [r4]
 19e:	ab0b      	add	r3, sp, #44	; 0x2c
 1a0:	9302      	str	r3, [sp, #8]
 1a2:	9b18      	ldr	r3, [sp, #96]	; 0x60
 1a4:	4610      	mov	r0, r2
 1a6:	e9cd 5300 	strd	r5, r3, [sp]
 1aa:	9b16      	ldr	r3, [sp, #88]	; 0x58
 1ac:	f7ff fffe 	bl	0 <ecc_mulmod>
 1b0:	4602      	mov	r2, r0
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 1b2:	f10b 0b01 	add.w	fp, fp, #1
 1b6:	2a00      	cmp	r2, #0
 1b8:	d186      	bne.n	c8 <ecc_mulmod+0xc8>
        swap = (int)b;
 1ba:	9b08      	ldr	r3, [sp, #32]
    for (i = 1; (err == MP_OKAY) && (i < t); i++) {
 1bc:	9a07      	ldr	r2, [sp, #28]
 1be:	455a      	cmp	r2, fp
 1c0:	dcb1      	bgt.n	126 <ecc_mulmod+0x126>
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 1c2:	9600      	str	r6, [sp, #0]
    swap ^= 1;
 1c4:	f083 0701 	eor.w	r7, r3, #1
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, swap,
 1c8:	682a      	ldr	r2, [r5, #0]
 1ca:	e9d4 0100 	ldrd	r0, r1, [r4]
 1ce:	463b      	mov	r3, r7
 1d0:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
    if (err == MP_OKAY) {
 1d4:	4602      	mov	r2, r0
 1d6:	2800      	cmp	r0, #0
 1d8:	f47f af76 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used, swap,
 1dc:	e9d4 0100 	ldrd	r0, r1, [r4]
 1e0:	9600      	str	r6, [sp, #0]
 1e2:	682a      	ldr	r2, [r5, #0]
 1e4:	463b      	mov	r3, r7
 1e6:	3168      	adds	r1, #104	; 0x68
 1e8:	3068      	adds	r0, #104	; 0x68
 1ea:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
    if (err == MP_OKAY) {
 1ee:	4602      	mov	r2, r0
 1f0:	2800      	cmp	r0, #0
 1f2:	f47f af69 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used, swap,
 1f6:	e9d4 0100 	ldrd	r0, r1, [r4]
 1fa:	9600      	str	r6, [sp, #0]
 1fc:	682a      	ldr	r2, [r5, #0]
 1fe:	463b      	mov	r3, r7
 200:	31d0      	adds	r1, #208	; 0xd0
 202:	30d0      	adds	r0, #208	; 0xd0
 204:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
    if (err == MP_OKAY)
 208:	4602      	mov	r2, r0
 20a:	2800      	cmp	r0, #0
 20c:	f47f af5c 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->x, R[2]->x);
 210:	68a1      	ldr	r1, [r4, #8]
 212:	4640      	mov	r0, r8
 214:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
 218:	4602      	mov	r2, r0
 21a:	2800      	cmp	r0, #0
 21c:	f47f af54 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_sub(modulus, P->y, R[2]->y);
 220:	68a2      	ldr	r2, [r4, #8]
 222:	f108 0168 	add.w	r1, r8, #104	; 0x68
 226:	3268      	adds	r2, #104	; 0x68
 228:	4628      	mov	r0, r5
 22a:	f7ff fffe 	bl	0 <mp_sub>
    if (err == MP_OKAY)
 22e:	4602      	mov	r2, r0
 230:	2800      	cmp	r0, #0
 232:	f47f af49 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_copy(P->z, R[2]->z);
 236:	68a1      	ldr	r1, [r4, #8]
 238:	f108 00d0 	add.w	r0, r8, #208	; 0xd0
 23c:	31d0      	adds	r1, #208	; 0xd0
 23e:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY) {
 242:	4602      	mov	r2, r0
 244:	2800      	cmp	r0, #0
 246:	f47f af3f 	bne.w	c8 <ecc_mulmod+0xc8>
        b = k->dp[0] & 1;
 24a:	9b05      	ldr	r3, [sp, #20]
 24c:	689f      	ldr	r7, [r3, #8]
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, (int)b,
 24e:	9600      	str	r6, [sp, #0]
        b = k->dp[0] & 1;
 250:	f007 0701 	and.w	r7, r7, #1
        err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used, (int)b,
 254:	682a      	ldr	r2, [r5, #0]
 256:	e9d4 0100 	ldrd	r0, r1, [r4]
 25a:	463b      	mov	r3, r7
 25c:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        if (err == MP_OKAY) {
 260:	4602      	mov	r2, r0
 262:	2800      	cmp	r0, #0
 264:	f47f af30 	bne.w	c8 <ecc_mulmod+0xc8>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 268:	e9d4 0100 	ldrd	r0, r1, [r4]
 26c:	9600      	str	r6, [sp, #0]
 26e:	682a      	ldr	r2, [r5, #0]
 270:	463b      	mov	r3, r7
 272:	3168      	adds	r1, #104	; 0x68
 274:	3068      	adds	r0, #104	; 0x68
 276:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        if (err == MP_OKAY) {
 27a:	4602      	mov	r2, r0
 27c:	2800      	cmp	r0, #0
 27e:	f47f af23 	bne.w	c8 <ecc_mulmod+0xc8>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 282:	e9d4 0100 	ldrd	r0, r1, [r4]
 286:	9600      	str	r6, [sp, #0]
 288:	682a      	ldr	r2, [r5, #0]
 28a:	463b      	mov	r3, r7
 28c:	31d0      	adds	r1, #208	; 0xd0
 28e:	30d0      	adds	r0, #208	; 0xd0
 290:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        if (err == MP_OKAY)
 294:	4602      	mov	r2, r0
 296:	2800      	cmp	r0, #0
 298:	f47f af16 	bne.w	c8 <ecc_mulmod+0xc8>
            err = ecc_projective_add_point_safe(R[0], R[2], R[0], a, modulus,
 29c:	ab0b      	add	r3, sp, #44	; 0x2c
 29e:	6822      	ldr	r2, [r4, #0]
 2a0:	9302      	str	r3, [sp, #8]
 2a2:	9b18      	ldr	r3, [sp, #96]	; 0x60
 2a4:	68a1      	ldr	r1, [r4, #8]
 2a6:	e9cd 5300 	strd	r5, r3, [sp]
 2aa:	4610      	mov	r0, r2
 2ac:	9b16      	ldr	r3, [sp, #88]	; 0x58
 2ae:	f7ff fffe 	bl	0 <ecc_mulmod>
        if (err == MP_OKAY) {
 2b2:	4602      	mov	r2, r0
 2b4:	2800      	cmp	r0, #0
 2b6:	f47f af07 	bne.w	c8 <ecc_mulmod+0xc8>
            err = mp_cond_swap_ct_ex(R[0]->x, R[1]->x, (int)modulus->used,
 2ba:	9600      	str	r6, [sp, #0]
 2bc:	682a      	ldr	r2, [r5, #0]
 2be:	e9d4 0100 	ldrd	r0, r1, [r4]
 2c2:	463b      	mov	r3, r7
 2c4:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        if (err == MP_OKAY) {
 2c8:	4602      	mov	r2, r0
 2ca:	2800      	cmp	r0, #0
 2cc:	f47f aefc 	bne.w	c8 <ecc_mulmod+0xc8>
            err = mp_cond_swap_ct_ex(R[0]->y, R[1]->y, (int)modulus->used,
 2d0:	e9d4 0100 	ldrd	r0, r1, [r4]
 2d4:	9600      	str	r6, [sp, #0]
 2d6:	682a      	ldr	r2, [r5, #0]
 2d8:	463b      	mov	r3, r7
 2da:	3168      	adds	r1, #104	; 0x68
 2dc:	3068      	adds	r0, #104	; 0x68
 2de:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
        if (err == MP_OKAY) {
 2e2:	4602      	mov	r2, r0
 2e4:	2800      	cmp	r0, #0
 2e6:	f47f aeef 	bne.w	c8 <ecc_mulmod+0xc8>
            err = mp_cond_swap_ct_ex(R[0]->z, R[1]->z, (int)modulus->used,
 2ea:	e9d4 0100 	ldrd	r0, r1, [r4]
 2ee:	9600      	str	r6, [sp, #0]
 2f0:	682a      	ldr	r2, [r5, #0]
 2f2:	463b      	mov	r3, r7
 2f4:	31d0      	adds	r1, #208	; 0xd0
 2f6:	30d0      	adds	r0, #208	; 0xd0
 2f8:	f7ff fffe 	bl	0 <mp_cond_swap_ct_ex>
    if (err == MP_OKAY)
 2fc:	4602      	mov	r2, r0
 2fe:	2800      	cmp	r0, #0
 300:	f47f aee2 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_copy(R[0]->x, Q->x);
 304:	9906      	ldr	r1, [sp, #24]
 306:	6820      	ldr	r0, [r4, #0]
 308:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
 30c:	4602      	mov	r2, r0
 30e:	2800      	cmp	r0, #0
 310:	f47f aeda 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_copy(R[0]->y, Q->y);
 314:	6820      	ldr	r0, [r4, #0]
 316:	9b06      	ldr	r3, [sp, #24]
 318:	3068      	adds	r0, #104	; 0x68
 31a:	f103 0168 	add.w	r1, r3, #104	; 0x68
 31e:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY)
 322:	4602      	mov	r2, r0
 324:	2800      	cmp	r0, #0
 326:	f47f aecf 	bne.w	c8 <ecc_mulmod+0xc8>
        err = mp_copy(R[0]->z, Q->z);
 32a:	6820      	ldr	r0, [r4, #0]
 32c:	9906      	ldr	r1, [sp, #24]
 32e:	30d0      	adds	r0, #208	; 0xd0
 330:	31d0      	adds	r1, #208	; 0xd0
 332:	f7ff fffe 	bl	0 <mp_copy>
 336:	4602      	mov	r2, r0
 338:	e6c6      	b.n	c8 <ecc_mulmod+0xc8>
 33a:	2301      	movs	r3, #1
 33c:	469a      	mov	sl, r3
 33e:	469b      	mov	fp, r3
 340:	e73c      	b.n	1bc <ecc_mulmod+0x1bc>
        err = MEMORY_E;
 342:	f06f 027c 	mvn.w	r2, #124	; 0x7c
}
 346:	4610      	mov	r0, r2
 348:	b00d      	add	sp, #52	; 0x34
 34a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.wc_ecc_mulmod_ex:

00000000 <wc_ecc_mulmod_ex>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   tG = NULL;
   4:	2400      	movs	r4, #0
{
   6:	b08b      	sub	sp, #44	; 0x2c
   8:	4605      	mov	r5, r0
   a:	468a      	mov	sl, r1
   c:	4617      	mov	r7, r2
   XMEMSET(M, 0, sizeof(M));
   e:	4621      	mov	r1, r4
  10:	220c      	movs	r2, #12
  12:	a807      	add	r0, sp, #28
{
  14:	9e14      	ldr	r6, [sp, #80]	; 0x50
   tG = NULL;
  16:	9405      	str	r4, [sp, #20]
{
  18:	4699      	mov	r9, r3
   XMEMSET(M, 0, sizeof(M));
  1a:	f7ff fffe 	bl	0 <memset>
   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
  1e:	2d00      	cmp	r5, #0
  20:	d057      	beq.n	d2 <wc_ecc_mulmod_ex+0xd2>
  22:	f1ba 0f00 	cmp.w	sl, #0
  26:	d054      	beq.n	d2 <wc_ecc_mulmod_ex+0xd2>
  28:	2f00      	cmp	r7, #0
  2a:	d052      	beq.n	d2 <wc_ecc_mulmod_ex+0xd2>
  2c:	2e00      	cmp	r6, #0
  2e:	d050      	beq.n	d2 <wc_ecc_mulmod_ex+0xd2>
   if (mp_count_bits(k) > mp_count_bits(modulus) + 1) {
  30:	4628      	mov	r0, r5
  32:	f7ff fffe 	bl	0 <mp_count_bits>
  36:	4683      	mov	fp, r0
  38:	4630      	mov	r0, r6
  3a:	f7ff fffe 	bl	0 <mp_count_bits>
  3e:	1c43      	adds	r3, r0, #1
  40:	459b      	cmp	fp, r3
  42:	dc49      	bgt.n	d8 <wc_ecc_mulmod_ex+0xd8>
  44:	f10d 081c 	add.w	r8, sp, #28
  for (i = 0; i < M_POINTS; i++) {
  48:	46a3      	mov	fp, r4
      err = wc_ecc_new_point_ex(&M[i], heap);
  4a:	4640      	mov	r0, r8
  4c:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
      if (err != MP_OKAY) {
  50:	4604      	mov	r4, r0
  52:	bb70      	cbnz	r0, b2 <wc_ecc_mulmod_ex+0xb2>
  for (i = 0; i < M_POINTS; i++) {
  54:	f10b 0b01 	add.w	fp, fp, #1
  58:	f1bb 0f03 	cmp.w	fp, #3
  5c:	f108 0804 	add.w	r8, r8, #4
  60:	d1f3      	bne.n	4a <wc_ecc_mulmod_ex+0x4a>
   err = wc_ecc_new_point_ex(&tG, heap);
  62:	a805      	add	r0, sp, #20
  64:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
   if (err != MP_OKAY) {
  68:	4604      	mov	r4, r0
  6a:	bb10      	cbnz	r0, b2 <wc_ecc_mulmod_ex+0xb2>
   if ((err = ecc_point_to_mont(G, tG, modulus, heap)) != MP_OKAY) {
  6c:	9905      	ldr	r1, [sp, #20]
  6e:	4632      	mov	r2, r6
  70:	4650      	mov	r0, sl
  72:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
  76:	4604      	mov	r4, r0
  78:	b9d8      	cbnz	r0, b2 <wc_ecc_mulmod_ex+0xb2>
   if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
  7a:	a906      	add	r1, sp, #24
  7c:	4630      	mov	r0, r6
  7e:	f7ff fffe 	bl	0 <mp_montgomery_setup>
  82:	4604      	mov	r4, r0
  84:	b9a8      	cbnz	r0, b2 <wc_ecc_mulmod_ex+0xb2>
   err = ecc_mulmod(k, tG, R, M, a, modulus, mp, NULL);
  86:	9b06      	ldr	r3, [sp, #24]
  88:	9003      	str	r0, [sp, #12]
  8a:	e9cd 6301 	strd	r6, r3, [sp, #4]
  8e:	9905      	ldr	r1, [sp, #20]
  90:	f8cd 9000 	str.w	r9, [sp]
  94:	ab07      	add	r3, sp, #28
  96:	463a      	mov	r2, r7
  98:	4628      	mov	r0, r5
  9a:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
   if (err == MP_OKAY && map)
  9e:	4604      	mov	r4, r0
  a0:	b938      	cbnz	r0, b2 <wc_ecc_mulmod_ex+0xb2>
  a2:	9b15      	ldr	r3, [sp, #84]	; 0x54
  a4:	b12b      	cbz	r3, b2 <wc_ecc_mulmod_ex+0xb2>
       err = ecc_map(R, modulus, mp);
  a6:	9a06      	ldr	r2, [sp, #24]
  a8:	4631      	mov	r1, r6
  aa:	4638      	mov	r0, r7
  ac:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
  b0:	4604      	mov	r4, r0
   wc_ecc_del_point_ex(tG, heap);
  b2:	9805      	ldr	r0, [sp, #20]
  b4:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
       wc_ecc_del_point_ex(M[i], heap);
  b8:	9807      	ldr	r0, [sp, #28]
  ba:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
  be:	9808      	ldr	r0, [sp, #32]
  c0:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
  c4:	9809      	ldr	r0, [sp, #36]	; 0x24
  c6:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex>
}
  ca:	4620      	mov	r0, r4
  cc:	b00b      	add	sp, #44	; 0x2c
  ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
       err = ECC_BAD_ARG_E;
  d2:	f06f 04a9 	mvn.w	r4, #169	; 0xa9
  d6:	e7ec      	b.n	b2 <wc_ecc_mulmod_ex+0xb2>
       err = ECC_OUT_OF_RANGE_E;
  d8:	f06f 04d8 	mvn.w	r4, #216	; 0xd8
  dc:	e7e9      	b.n	b2 <wc_ecc_mulmod_ex+0xb2>

Disassembly of section .text.wc_ecc_mulmod:

00000000 <wc_ecc_mulmod>:
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return wc_ecc_mulmod_ex(k, G, R, a, modulus, map, NULL);
   2:	2400      	movs	r4, #0
   4:	9402      	str	r4, [sp, #8]
   6:	9c07      	ldr	r4, [sp, #28]
   8:	9401      	str	r4, [sp, #4]
   a:	9c06      	ldr	r4, [sp, #24]
   c:	9400      	str	r4, [sp, #0]
   e:	f7ff fffe 	bl	0 <wc_ecc_mulmod>
}
  12:	b004      	add	sp, #16
  14:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_mulmod_ex2:

00000000 <wc_ecc_mulmod_ex2>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b08d      	sub	sp, #52	; 0x34
   6:	e9dd 7b16 	ldrd	r7, fp, [sp, #88]	; 0x58
   a:	460d      	mov	r5, r1
   c:	4616      	mov	r6, r2
   e:	9305      	str	r3, [sp, #20]
   if (k == NULL || G == NULL || R == NULL || modulus == NULL) {
  10:	4680      	mov	r8, r0
  12:	2800      	cmp	r0, #0
  14:	f000 80af 	beq.w	176 <wc_ecc_mulmod_ex2+0x176>
  18:	2900      	cmp	r1, #0
  1a:	f000 80ac 	beq.w	176 <wc_ecc_mulmod_ex2+0x176>
  1e:	2a00      	cmp	r2, #0
  20:	f000 80a9 	beq.w	176 <wc_ecc_mulmod_ex2+0x176>
  24:	2f00      	cmp	r7, #0
  26:	f000 80a6 	beq.w	176 <wc_ecc_mulmod_ex2+0x176>
   if (mp_count_bits(k) > mp_count_bits(order)) {
  2a:	f7ff fffe 	bl	0 <mp_count_bits>
  2e:	4604      	mov	r4, r0
  30:	4658      	mov	r0, fp
  32:	f7ff fffe 	bl	0 <mp_count_bits>
  36:	4284      	cmp	r4, r0
  38:	f300 80a0 	bgt.w	17c <wc_ecc_mulmod_ex2+0x17c>
   tG = NULL;
  3c:	2400      	movs	r4, #0
   XMEMSET(M, 0, sizeof(M));
  3e:	220c      	movs	r2, #12
  40:	4621      	mov	r1, r4
  42:	a809      	add	r0, sp, #36	; 0x24
   tG = NULL;
  44:	9407      	str	r4, [sp, #28]
   XMEMSET(M, 0, sizeof(M));
  46:	f7ff fffe 	bl	0 <memset>
   for (i = 0; i < M_POINTS; i++) {
  4a:	f10d 0a24 	add.w	sl, sp, #36	; 0x24
  4e:	46a1      	mov	r9, r4
      err = wc_ecc_new_point_ex(&M[i], heap);
  50:	4650      	mov	r0, sl
  52:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
      if (err != MP_OKAY) {
  56:	4604      	mov	r4, r0
  58:	2800      	cmp	r0, #0
  5a:	d179      	bne.n	150 <wc_ecc_mulmod_ex2+0x150>
   for (i = 0; i < M_POINTS; i++) {
  5c:	f109 0901 	add.w	r9, r9, #1
  60:	f1b9 0f03 	cmp.w	r9, #3
  64:	f10a 0a04 	add.w	sl, sl, #4
  68:	d1f2      	bne.n	50 <wc_ecc_mulmod_ex2+0x50>
   err = wc_ecc_new_point_ex(&tG, heap);
  6a:	a807      	add	r0, sp, #28
  6c:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
   if (err != MP_OKAY) {
  70:	4604      	mov	r4, r0
  72:	2800      	cmp	r0, #0
  74:	d16c      	bne.n	150 <wc_ecc_mulmod_ex2+0x150>
   if ((err = ecc_point_to_mont(G, tG, modulus, heap)) != MP_OKAY) {
  76:	9907      	ldr	r1, [sp, #28]
  78:	463a      	mov	r2, r7
  7a:	4628      	mov	r0, r5
  7c:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
  80:	4604      	mov	r4, r0
  82:	2800      	cmp	r0, #0
  84:	d164      	bne.n	150 <wc_ecc_mulmod_ex2+0x150>
   if ((err = mp_montgomery_setup(modulus, &mp)) != MP_OKAY) {
  86:	a908      	add	r1, sp, #32
  88:	4638      	mov	r0, r7
  8a:	f7ff fffe 	bl	0 <mp_montgomery_setup>
  8e:	4604      	mov	r4, r0
  90:	2800      	cmp	r0, #0
  92:	d15d      	bne.n	150 <wc_ecc_mulmod_ex2+0x150>
   err = ecc_mulmod(k, tG, R, M, a, modulus, mp, rng);
  94:	9b18      	ldr	r3, [sp, #96]	; 0x60
  96:	9303      	str	r3, [sp, #12]
  98:	9b08      	ldr	r3, [sp, #32]
  9a:	9907      	ldr	r1, [sp, #28]
  9c:	e9cd 7301 	strd	r7, r3, [sp, #4]
  a0:	9b05      	ldr	r3, [sp, #20]
  a2:	9300      	str	r3, [sp, #0]
  a4:	4632      	mov	r2, r6
  a6:	ab09      	add	r3, sp, #36	; 0x24
  a8:	4640      	mov	r0, r8
  aa:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
   if (err == MP_OKAY) {
  ae:	4604      	mov	r4, r0
  b0:	2800      	cmp	r0, #0
  b2:	d14d      	bne.n	150 <wc_ecc_mulmod_ex2+0x150>
    NEW_MP_INT_SIZE(t, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
  b4:	2068      	movs	r0, #104	; 0x68
       err = ecc_check_order_minus_1(k, tG, R, modulus, order);
  b6:	f8dd a01c 	ldr.w	sl, [sp, #28]
    NEW_MP_INT_SIZE(t, mp_bitsused(modulus), NULL, DYNAMIC_TYPE_ECC);
  ba:	f7ff fffe 	bl	0 <malloc>
  be:	4605      	mov	r5, r0
  c0:	2800      	cmp	r0, #0
  c2:	d055      	beq.n	170 <wc_ecc_mulmod_ex2+0x170>
  c4:	4621      	mov	r1, r4
  c6:	2268      	movs	r2, #104	; 0x68
  c8:	f7ff fffe 	bl	0 <memset>
        err = INIT_MP_INT_SIZE(t, mp_bitsused(modulus));
  cc:	4628      	mov	r0, r5
  ce:	f7ff fffe 	bl	0 <mp_init>
    if (err == MP_OKAY) {
  d2:	4604      	mov	r4, r0
  d4:	bb80      	cbnz	r0, 138 <wc_ecc_mulmod_ex2+0x138>
        err = mp_sub_d(order, 1, t);
  d6:	462a      	mov	r2, r5
  d8:	2101      	movs	r1, #1
  da:	4658      	mov	r0, fp
  dc:	f7ff fffe 	bl	0 <mp_sub_d>
        if (err == MP_OKAY) {
  e0:	4604      	mov	r4, r0
  e2:	bb30      	cbnz	r0, 132 <wc_ecc_mulmod_ex2+0x132>
            int kIsMinusOne = (mp_cmp((mp_int*)k, t) == MP_EQ);
  e4:	4629      	mov	r1, r5
  e6:	4640      	mov	r0, r8
  e8:	f7ff fffe 	bl	0 <mp_cmp>
  ec:	fab0 f880 	clz	r8, r0
  f0:	ea4f 1858 	mov.w	r8, r8, lsr #5
            err = mp_cond_copy(tG->x, kIsMinusOne, R->x);
  f4:	4632      	mov	r2, r6
  f6:	4641      	mov	r1, r8
  f8:	4650      	mov	r0, sl
  fa:	f7ff fffe 	bl	0 <mp_cond_copy>
            if (err == MP_OKAY) {
  fe:	4604      	mov	r4, r0
 100:	b9b8      	cbnz	r0, 132 <wc_ecc_mulmod_ex2+0x132>
                err = mp_sub(modulus, tG->y, t);
 102:	462a      	mov	r2, r5
 104:	f10a 0168 	add.w	r1, sl, #104	; 0x68
 108:	4638      	mov	r0, r7
 10a:	f7ff fffe 	bl	0 <mp_sub>
            if (err == MP_OKAY) {
 10e:	4604      	mov	r4, r0
 110:	b978      	cbnz	r0, 132 <wc_ecc_mulmod_ex2+0x132>
                err = mp_cond_copy(t, kIsMinusOne, R->y);
 112:	f106 0268 	add.w	r2, r6, #104	; 0x68
 116:	4641      	mov	r1, r8
 118:	4628      	mov	r0, r5
 11a:	f7ff fffe 	bl	0 <mp_cond_copy>
            if (err == MP_OKAY) {
 11e:	4604      	mov	r4, r0
 120:	b938      	cbnz	r0, 132 <wc_ecc_mulmod_ex2+0x132>
                err = mp_cond_copy(tG->z, kIsMinusOne, R->z);
 122:	f106 02d0 	add.w	r2, r6, #208	; 0xd0
 126:	4641      	mov	r1, r8
 128:	f10a 00d0 	add.w	r0, sl, #208	; 0xd0
 12c:	f7ff fffe 	bl	0 <mp_cond_copy>
 130:	4604      	mov	r4, r0
        mp_free(t);
 132:	4628      	mov	r0, r5
 134:	f7ff fffe 	bl	0 <mp_free>
    FREE_MP_INT_SIZE(t, NULL, DYNAMIC_TYPE_ECC);
 138:	4628      	mov	r0, r5
 13a:	f7ff fffe 	bl	0 <free>
   if (err == MP_OKAY && map)
 13e:	b93c      	cbnz	r4, 150 <wc_ecc_mulmod_ex2+0x150>
 140:	9b19      	ldr	r3, [sp, #100]	; 0x64
 142:	b12b      	cbz	r3, 150 <wc_ecc_mulmod_ex2+0x150>
      err = ecc_map(R, modulus, mp);
 144:	9a08      	ldr	r2, [sp, #32]
 146:	4639      	mov	r1, r7
 148:	4630      	mov	r0, r6
 14a:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
 14e:	4604      	mov	r4, r0
   wc_ecc_del_point_ex(tG, heap);
 150:	9807      	ldr	r0, [sp, #28]
 152:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
      wc_ecc_del_point_ex(M[i], heap);
 156:	9809      	ldr	r0, [sp, #36]	; 0x24
 158:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
 15c:	980a      	ldr	r0, [sp, #40]	; 0x28
 15e:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
 162:	980b      	ldr	r0, [sp, #44]	; 0x2c
 164:	f7ff fffe 	bl	0 <wc_ecc_mulmod_ex2>
}
 168:	4620      	mov	r0, r4
 16a:	b00d      	add	sp, #52	; 0x34
 16c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        err = MEMORY_E;
 170:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 174:	e7ec      	b.n	150 <wc_ecc_mulmod_ex2+0x150>
      return ECC_BAD_ARG_E;
 176:	f06f 04a9 	mvn.w	r4, #169	; 0xa9
 17a:	e7f5      	b.n	168 <wc_ecc_mulmod_ex2+0x168>
      return ECC_OUT_OF_RANGE_E;
 17c:	f06f 04d8 	mvn.w	r4, #216	; 0xd8
 180:	e7f2      	b.n	168 <wc_ecc_mulmod_ex2+0x168>

Disassembly of section .text.wc_ecc_shared_secret_gen_sync:

00000000 <wc_ecc_shared_secret_gen_sync>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        ecc_point* result = NULL;
   4:	f04f 0900 	mov.w	r9, #0
{
   8:	b094      	sub	sp, #80	; 0x50
   a:	4605      	mov	r5, r0
   c:	468a      	mov	sl, r1
        DECLARE_CURVE_SPECS(3);
   e:	a80a      	add	r0, sp, #40	; 0x28
  10:	4649      	mov	r1, r9
{
  12:	4617      	mov	r7, r2
        DECLARE_CURVE_SPECS(3);
  14:	2228      	movs	r2, #40	; 0x28
{
  16:	4698      	mov	r8, r3
        mp_digit mp = 0;
  18:	e9cd 9907 	strd	r9, r9, [sp, #28]
        DECLARE_CURVE_SPECS(3);
  1c:	9009      	str	r0, [sp, #36]	; 0x24
  1e:	f7ff fffe 	bl	0 <memset>
  22:	9b09      	ldr	r3, [sp, #36]	; 0x24
  24:	2203      	movs	r2, #3
  26:	61da      	str	r2, [r3, #28]
        ALLOC_CURVE_SPECS(3, err);
  28:	f44f 709c 	mov.w	r0, #312	; 0x138
  2c:	f7ff fffe 	bl	0 <malloc>
  30:	4606      	mov	r6, r0
  32:	2800      	cmp	r0, #0
  34:	d067      	beq.n	106 <wc_ecc_shared_secret_gen_sync+0x106>
  36:	9b09      	ldr	r3, [sp, #36]	; 0x24
            err = wc_ecc_curve_load(private_key->dp, &curve,
  38:	220b      	movs	r2, #11
        ALLOC_CURVE_SPECS(3, err);
  3a:	6198      	str	r0, [r3, #24]
            err = wc_ecc_curve_load(private_key->dp, &curve,
  3c:	a909      	add	r1, sp, #36	; 0x24
  3e:	6928      	ldr	r0, [r5, #16]
  40:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_gen_sync>
        if (err != MP_OKAY) {
  44:	4604      	mov	r4, r0
  46:	b938      	cbnz	r0, 58 <wc_ecc_shared_secret_gen_sync+0x58>
        err = wc_ecc_new_point_ex(&result, private_key->heap);
  48:	a807      	add	r0, sp, #28
  4a:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_gen_sync>
        if (err != MP_OKAY) {
  4e:	4604      	mov	r4, r0
  50:	b130      	cbz	r0, 60 <wc_ecc_shared_secret_gen_sync+0x60>
            wc_ecc_curve_free(curve);
  52:	9809      	ldr	r0, [sp, #36]	; 0x24
  54:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_gen_sync>
            FREE_CURVE_SPECS();
  58:	4630      	mov	r0, r6
  5a:	f7ff fffe 	bl	0 <free>
  5e:	e04b      	b.n	f8 <wc_ecc_shared_secret_gen_sync+0xf8>
        if (private_key->rng == NULL) {
  60:	f8d5 21b8 	ldr.w	r2, [r5, #440]	; 0x1b8
  64:	2a00      	cmp	r2, #0
  66:	d032      	beq.n	ce <wc_ecc_shared_secret_gen_sync+0xce>
            err = wc_ecc_mulmod_ex2(k, point, result, curve->Af, curve->prime,
  68:	6969      	ldr	r1, [r5, #20]
  6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  6c:	9202      	str	r2, [sp, #8]
  6e:	e9cd 0103 	strd	r0, r1, [sp, #12]
  72:	68da      	ldr	r2, [r3, #12]
  74:	9201      	str	r2, [sp, #4]
  76:	685a      	ldr	r2, [r3, #4]
  78:	9200      	str	r2, [sp, #0]
  7a:	f505 70a8 	add.w	r0, r5, #336	; 0x150
  7e:	689b      	ldr	r3, [r3, #8]
  80:	9a07      	ldr	r2, [sp, #28]
  82:	4651      	mov	r1, sl
  84:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_gen_sync>
        if (err == MP_OKAY) {
  88:	4605      	mov	r5, r0
  8a:	bb10      	cbnz	r0, d2 <wc_ecc_shared_secret_gen_sync+0xd2>
            err = mp_montgomery_setup(curve->prime, &mp);
  8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
  8e:	a908      	add	r1, sp, #32
  90:	6858      	ldr	r0, [r3, #4]
  92:	f7ff fffe 	bl	0 <mp_montgomery_setup>
        if (err == MP_OKAY) {
  96:	4604      	mov	r4, r0
  98:	bb90      	cbnz	r0, 100 <wc_ecc_shared_secret_gen_sync+0x100>
            err = ecc_map_ex(result, curve->prime, mp, 1);
  9a:	e9dd 2108 	ldrd	r2, r1, [sp, #32]
  9e:	9807      	ldr	r0, [sp, #28]
  a0:	6849      	ldr	r1, [r1, #4]
  a2:	2301      	movs	r3, #1
  a4:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_gen_sync>
        if (err == MP_OKAY) {
  a8:	4605      	mov	r5, r0
  aa:	b990      	cbnz	r0, d2 <wc_ecc_shared_secret_gen_sync+0xd2>
            x = mp_unsigned_bin_size(curve->prime);
  ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
  ae:	6858      	ldr	r0, [r3, #4]
  b0:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
            if (*outlen < (word32)x || x < mp_unsigned_bin_size(result->x)) {
  b4:	f8d8 3000 	ldr.w	r3, [r8]
  b8:	4283      	cmp	r3, r0
            x = mp_unsigned_bin_size(curve->prime);
  ba:	4604      	mov	r4, r0
            if (*outlen < (word32)x || x < mp_unsigned_bin_size(result->x)) {
  bc:	d304      	bcc.n	c8 <wc_ecc_shared_secret_gen_sync+0xc8>
  be:	9807      	ldr	r0, [sp, #28]
  c0:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  c4:	42a0      	cmp	r0, r4
  c6:	dd21      	ble.n	10c <wc_ecc_shared_secret_gen_sync+0x10c>
                err = BUFFER_E;
  c8:	f06f 0583 	mvn.w	r5, #131	; 0x83
  cc:	e001      	b.n	d2 <wc_ecc_shared_secret_gen_sync+0xd2>
            err = MISSING_RNG_E;
  ce:	f06f 05eb 	mvn.w	r5, #235	; 0xeb
        mp_forcezero(result->x);
  d2:	9807      	ldr	r0, [sp, #28]
        *outlen = (word32)x;
  d4:	f8c8 4000 	str.w	r4, [r8]
        mp_forcezero(result->x);
  d8:	f7ff fffe 	bl	0 <mp_forcezero>
        mp_forcezero(result->y);
  dc:	9807      	ldr	r0, [sp, #28]
  de:	3068      	adds	r0, #104	; 0x68
  e0:	f7ff fffe 	bl	0 <mp_forcezero>
        wc_ecc_del_point_ex(result, private_key->heap);
  e4:	9807      	ldr	r0, [sp, #28]
  e6:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_gen_sync>
        wc_ecc_curve_free(curve);
  ea:	9809      	ldr	r0, [sp, #36]	; 0x24
  ec:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_gen_sync>
        FREE_CURVE_SPECS();
  f0:	4630      	mov	r0, r6
  f2:	f7ff fffe 	bl	0 <free>
  f6:	462c      	mov	r4, r5
}
  f8:	4620      	mov	r0, r4
  fa:	b014      	add	sp, #80	; 0x50
  fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100:	4605      	mov	r5, r0
        int x = 0;
 102:	464c      	mov	r4, r9
 104:	e7e5      	b.n	d2 <wc_ecc_shared_secret_gen_sync+0xd2>
        ALLOC_CURVE_SPECS(3, err);
 106:	f06f 047c 	mvn.w	r4, #124	; 0x7c
    return err;
 10a:	e7f5      	b.n	f8 <wc_ecc_shared_secret_gen_sync+0xf8>
            XMEMSET(out, 0, (size_t)x);
 10c:	4629      	mov	r1, r5
 10e:	4622      	mov	r2, r4
 110:	4638      	mov	r0, r7
 112:	f7ff fffe 	bl	0 <memset>
            err = mp_to_unsigned_bin(result->x, out +
 116:	9d07      	ldr	r5, [sp, #28]
                                     (x - mp_unsigned_bin_size(result->x)));
 118:	4628      	mov	r0, r5
 11a:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
 11e:	1a21      	subs	r1, r4, r0
            err = mp_to_unsigned_bin(result->x, out +
 120:	4439      	add	r1, r7
 122:	4628      	mov	r0, r5
 124:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
 128:	4605      	mov	r5, r0
 12a:	e7d2      	b.n	d2 <wc_ecc_shared_secret_gen_sync+0xd2>

Disassembly of section .text.wc_ecc_shared_secret_ex:

00000000 <wc_ecc_shared_secret_ex>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (private_key == NULL || point == NULL || out == NULL ||
   2:	4604      	mov	r4, r0
   4:	b348      	cbz	r0, 5a <wc_ecc_shared_secret_ex+0x5a>
   6:	b341      	cbz	r1, 5a <wc_ecc_shared_secret_ex+0x5a>
   8:	b33a      	cbz	r2, 5a <wc_ecc_shared_secret_ex+0x5a>
   a:	b333      	cbz	r3, 5a <wc_ecc_shared_secret_ex+0x5a>
    if (private_key->type != ECC_PRIVATEKEY &&
   c:	6800      	ldr	r0, [r0, #0]
   e:	3802      	subs	r0, #2
  10:	2801      	cmp	r0, #1
  12:	d825      	bhi.n	60 <wc_ecc_shared_secret_ex+0x60>
    if (wc_ecc_is_valid_idx(private_key->idx) == 0 || private_key->dp == NULL) {
  14:	6860      	ldr	r0, [r4, #4]
  16:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_ex>
  1a:	b308      	cbz	r0, 60 <wc_ecc_shared_secret_ex+0x60>
  1c:	6920      	ldr	r0, [r4, #16]
  1e:	b1f8      	cbz	r0, 60 <wc_ecc_shared_secret_ex+0x60>
    switch (private_key->state) {
  20:	68a0      	ldr	r0, [r4, #8]
  22:	2801      	cmp	r0, #1
  24:	dc06      	bgt.n	34 <wc_ecc_shared_secret_ex+0x34>
  26:	2800      	cmp	r0, #0
  28:	da0a      	bge.n	40 <wc_ecc_shared_secret_ex+0x40>
            err = BAD_STATE_E;
  2a:	f06f 00bf 	mvn.w	r0, #191	; 0xbf
    private_key->state = ECC_STATE_NONE;
  2e:	2300      	movs	r3, #0
  30:	60a3      	str	r3, [r4, #8]
    return err;
  32:	e00f      	b.n	54 <wc_ecc_shared_secret_ex+0x54>
    switch (private_key->state) {
  34:	2802      	cmp	r0, #2
  36:	bf14      	ite	ne
  38:	f06f 00bf 	mvnne.w	r0, #191	; 0xbf
  3c:	2000      	moveq	r0, #0
  3e:	e7f6      	b.n	2e <wc_ecc_shared_secret_ex+0x2e>
            private_key->state = ECC_STATE_SHARED_SEC_GEN;
  40:	2001      	movs	r0, #1
  42:	60a0      	str	r0, [r4, #8]
                err = wc_ecc_shared_secret_gen_sync(private_key, point,
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <wc_ecc_shared_secret_ex>
            if (err < 0) {
  4a:	2800      	cmp	r0, #0
  4c:	da03      	bge.n	56 <wc_ecc_shared_secret_ex+0x56>
    if (err == WC_PENDING_E) {
  4e:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
  52:	d1ec      	bne.n	2e <wc_ecc_shared_secret_ex+0x2e>
}
  54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            err = 0;
  56:	2000      	movs	r0, #0
  58:	e7e9      	b.n	2e <wc_ecc_shared_secret_ex+0x2e>
        return BAD_FUNC_ARG;
  5a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  5e:	e7f9      	b.n	54 <wc_ecc_shared_secret_ex+0x54>
        return ECC_BAD_ARG_E;
  60:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  64:	e7f6      	b.n	54 <wc_ecc_shared_secret_ex+0x54>

Disassembly of section .text.wc_ecc_shared_secret:

00000000 <wc_ecc_shared_secret>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   if (private_key == NULL || public_key == NULL || out == NULL ||
   2:	4604      	mov	r4, r0
   4:	b1e0      	cbz	r0, 40 <wc_ecc_shared_secret+0x40>
   6:	b1d9      	cbz	r1, 40 <wc_ecc_shared_secret+0x40>
   8:	b1d2      	cbz	r2, 40 <wc_ecc_shared_secret+0x40>
   a:	b1cb      	cbz	r3, 40 <wc_ecc_shared_secret+0x40>
   if (private_key->type != ECC_PRIVATEKEY &&
   c:	6800      	ldr	r0, [r0, #0]
   e:	3802      	subs	r0, #2
  10:	2801      	cmp	r0, #1
  12:	d818      	bhi.n	46 <wc_ecc_shared_secret+0x46>
   if (wc_ecc_is_valid_idx(private_key->idx) == 0 || private_key->dp == NULL ||
  14:	6860      	ldr	r0, [r4, #4]
  16:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
  1a:	b1a0      	cbz	r0, 46 <wc_ecc_shared_secret+0x46>
  1c:	6925      	ldr	r5, [r4, #16]
  1e:	b195      	cbz	r5, 46 <wc_ecc_shared_secret+0x46>
       wc_ecc_is_valid_idx(public_key->idx)  == 0 || public_key->dp == NULL) {
  20:	6848      	ldr	r0, [r1, #4]
  22:	f7ff fffe 	bl	0 <wc_ecc_shared_secret>
   if (wc_ecc_is_valid_idx(private_key->idx) == 0 || private_key->dp == NULL ||
  26:	b170      	cbz	r0, 46 <wc_ecc_shared_secret+0x46>
       wc_ecc_is_valid_idx(public_key->idx)  == 0 || public_key->dp == NULL) {
  28:	6908      	ldr	r0, [r1, #16]
  2a:	b160      	cbz	r0, 46 <wc_ecc_shared_secret+0x46>
   if (private_key->dp->id != public_key->dp->id) {
  2c:	686d      	ldr	r5, [r5, #4]
  2e:	6840      	ldr	r0, [r0, #4]
  30:	4285      	cmp	r5, r0
  32:	d108      	bne.n	46 <wc_ecc_shared_secret+0x46>
   err = wc_ecc_shared_secret_ex(private_key, &public_key->pubkey, out, outlen);
  34:	4620      	mov	r0, r4
  36:	3118      	adds	r1, #24
}
  38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   err = wc_ecc_shared_secret_ex(private_key, &public_key->pubkey, out, outlen);
  3c:	f7ff bffe 	b.w	0 <wc_ecc_shared_secret>
       return BAD_FUNC_ARG;
  40:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  44:	bd70      	pop	{r4, r5, r6, pc}
      return ECC_BAD_ARG_E;
  46:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  4a:	e7fb      	b.n	44 <wc_ecc_shared_secret+0x44>

Disassembly of section .text.ecc_make_pub_ex:

00000000 <ecc_make_pub_ex>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	460c      	mov	r4, r1
   6:	b08b      	sub	sp, #44	; 0x2c
   8:	4617      	mov	r7, r2
   a:	4699      	mov	r9, r3
    if (key == NULL) {
   c:	4605      	mov	r5, r0
   e:	2800      	cmp	r0, #0
  10:	f000 8085 	beq.w	11e <ecc_make_pub_ex+0x11e>
    if (pubOut != NULL) {
  14:	b9da      	cbnz	r2, 4e <ecc_make_pub_ex+0x4e>
        pub = &key->pubkey;
  16:	4606      	mov	r6, r0
        key->type = ECC_PRIVATEKEY_ONLY;
  18:	2303      	movs	r3, #3
  1a:	f846 3b18 	str.w	r3, [r6], #24
    if ((err == MP_OKAY) && (mp_iszero(key->k) || mp_isneg(key->k) ||
  1e:	f505 78a8 	add.w	r8, r5, #336	; 0x150
  22:	4640      	mov	r0, r8
  24:	f7ff fffe 	bl	0 <mp_iszero>
        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);
  28:	f106 0b68 	add.w	fp, r6, #104	; 0x68
  2c:	f106 0ad0 	add.w	sl, r6, #208	; 0xd0
    if ((err == MP_OKAY) && (mp_iszero(key->k) || mp_isneg(key->k) ||
  30:	b178      	cbz	r0, 52 <ecc_make_pub_ex+0x52>
        err = ECC_PRIV_KEY_E;
  32:	f06f 03d7 	mvn.w	r3, #215	; 0xd7
        mp_clear(pub->x);
  36:	4630      	mov	r0, r6
  38:	9307      	str	r3, [sp, #28]
  3a:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(pub->y);
  3e:	4658      	mov	r0, fp
  40:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(pub->z);
  44:	4650      	mov	r0, sl
  46:	f7ff fffe 	bl	0 <mp_clear>
  4a:	9b07      	ldr	r3, [sp, #28]
  4c:	e05a      	b.n	104 <ecc_make_pub_ex+0x104>
  4e:	4616      	mov	r6, r2
  50:	e7e5      	b.n	1e <ecc_make_pub_ex+0x1e>
    if ((err == MP_OKAY) && (mp_iszero(key->k) || mp_isneg(key->k) ||
  52:	f8d5 3154 	ldr.w	r3, [r5, #340]	; 0x154
  56:	2b00      	cmp	r3, #0
  58:	d1eb      	bne.n	32 <ecc_make_pub_ex+0x32>
                                      (mp_cmp(key->k, curve->order) != MP_LT)))
  5a:	68e1      	ldr	r1, [r4, #12]
  5c:	9307      	str	r3, [sp, #28]
  5e:	4640      	mov	r0, r8
  60:	f7ff fffe 	bl	0 <mp_cmp>
    if ((err == MP_OKAY) && (mp_iszero(key->k) || mp_isneg(key->k) ||
  64:	3001      	adds	r0, #1
  66:	9b07      	ldr	r3, [sp, #28]
  68:	d1e3      	bne.n	32 <ecc_make_pub_ex+0x32>
        err = mp_init_multi(pub->x, pub->y, pub->z, NULL, NULL, NULL);
  6a:	e9cd 3300 	strd	r3, r3, [sp]
  6e:	4652      	mov	r2, sl
  70:	4659      	mov	r1, fp
  72:	4630      	mov	r0, r6
  74:	f7ff fffe 	bl	0 <mp_init_multi>
    if (err == MP_OKAY) {
  78:	4603      	mov	r3, r0
  7a:	2800      	cmp	r0, #0
  7c:	d1db      	bne.n	36 <ecc_make_pub_ex+0x36>
        ecc_point* base = NULL;
  7e:	e9cd 0008 	strd	r0, r0, [sp, #32]
        err = wc_ecc_new_point_ex(&base, key->heap);
  82:	a809      	add	r0, sp, #36	; 0x24
  84:	f7ff fffe 	bl	0 <ecc_make_pub_ex>
        if (err == MP_OKAY)
  88:	4603      	mov	r3, r0
  8a:	2800      	cmp	r0, #0
  8c:	d133      	bne.n	f6 <ecc_make_pub_ex+0xf6>
            err = mp_copy(curve->Gx, base->x);
  8e:	9909      	ldr	r1, [sp, #36]	; 0x24
  90:	6920      	ldr	r0, [r4, #16]
  92:	f7ff fffe 	bl	0 <mp_copy>
        if (err == MP_OKAY)
  96:	4603      	mov	r3, r0
  98:	bb68      	cbnz	r0, f6 <ecc_make_pub_ex+0xf6>
            err = mp_copy(curve->Gy, base->y);
  9a:	9909      	ldr	r1, [sp, #36]	; 0x24
  9c:	6960      	ldr	r0, [r4, #20]
  9e:	3168      	adds	r1, #104	; 0x68
  a0:	f7ff fffe 	bl	0 <mp_copy>
        if (err == MP_OKAY)
  a4:	4603      	mov	r3, r0
  a6:	bb30      	cbnz	r0, f6 <ecc_make_pub_ex+0xf6>
            err = mp_montgomery_setup(curve->prime, &mp);
  a8:	6860      	ldr	r0, [r4, #4]
  aa:	a908      	add	r1, sp, #32
  ac:	f7ff fffe 	bl	0 <mp_montgomery_setup>
        if (err == MP_OKAY)
  b0:	4603      	mov	r3, r0
  b2:	bb00      	cbnz	r0, f6 <ecc_make_pub_ex+0xf6>
            err = mp_set(base->z, 1);
  b4:	9809      	ldr	r0, [sp, #36]	; 0x24
  b6:	2101      	movs	r1, #1
  b8:	30d0      	adds	r0, #208	; 0xd0
  ba:	f7ff fffe 	bl	0 <mp_set>
        if (err == MP_OKAY) {
  be:	4603      	mov	r3, r0
  c0:	b9c8      	cbnz	r0, f6 <ecc_make_pub_ex+0xf6>
            err = wc_ecc_mulmod_ex2(key->k, base, pub, curve->Af, curve->prime,
  c2:	696a      	ldr	r2, [r5, #20]
  c4:	68e3      	ldr	r3, [r4, #12]
  c6:	9301      	str	r3, [sp, #4]
  c8:	6863      	ldr	r3, [r4, #4]
  ca:	9300      	str	r3, [sp, #0]
  cc:	e9cd 0203 	strd	r0, r2, [sp, #12]
  d0:	68a3      	ldr	r3, [r4, #8]
  d2:	9909      	ldr	r1, [sp, #36]	; 0x24
  d4:	f8cd 9008 	str.w	r9, [sp, #8]
  d8:	4632      	mov	r2, r6
  da:	4640      	mov	r0, r8
  dc:	f7ff fffe 	bl	0 <ecc_make_pub_ex>
            if (err == MP_MEM) {
  e0:	1c82      	adds	r2, r0, #2
            err = wc_ecc_mulmod_ex2(key->k, base, pub, curve->Af, curve->prime,
  e2:	4603      	mov	r3, r0
            if (err == MP_MEM) {
  e4:	d018      	beq.n	118 <ecc_make_pub_ex+0x118>
        if (err == MP_OKAY) {
  e6:	b930      	cbnz	r0, f6 <ecc_make_pub_ex+0xf6>
            err = ecc_map_ex(pub, curve->prime, mp, 1);
  e8:	2301      	movs	r3, #1
  ea:	9a08      	ldr	r2, [sp, #32]
  ec:	6861      	ldr	r1, [r4, #4]
  ee:	4630      	mov	r0, r6
  f0:	f7ff fffe 	bl	0 <ecc_make_pub_ex>
  f4:	4603      	mov	r3, r0
        wc_ecc_del_point_ex(base, key->heap);
  f6:	9809      	ldr	r0, [sp, #36]	; 0x24
  f8:	9307      	str	r3, [sp, #28]
  fa:	f7ff fffe 	bl	0 <ecc_make_pub_ex>
    if (err != MP_OKAY
  fe:	9b07      	ldr	r3, [sp, #28]
 100:	2b00      	cmp	r3, #0
 102:	d198      	bne.n	36 <ecc_make_pub_ex+0x36>
    if (key->type == ECC_PRIVATEKEY_ONLY && pubOut == NULL) {
 104:	682a      	ldr	r2, [r5, #0]
 106:	2a03      	cmp	r2, #3
 108:	d102      	bne.n	110 <ecc_make_pub_ex+0x110>
 10a:	b90f      	cbnz	r7, 110 <ecc_make_pub_ex+0x110>
        key->type = ECC_PRIVATEKEY;
 10c:	2202      	movs	r2, #2
 10e:	602a      	str	r2, [r5, #0]
}
 110:	4618      	mov	r0, r3
 112:	b00b      	add	sp, #44	; 0x2c
 114:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
               err = MEMORY_E;
 118:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 11c:	e7eb      	b.n	f6 <ecc_make_pub_ex+0xf6>
        return BAD_FUNC_ARG;
 11e:	f06f 03ac 	mvn.w	r3, #172	; 0xac
 122:	e7f5      	b.n	110 <ecc_make_pub_ex+0x110>

Disassembly of section .text.wc_ecc_make_pub_ex:

00000000 <wc_ecc_make_pub_ex>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b08c      	sub	sp, #48	; 0x30
   6:	4606      	mov	r6, r0
   8:	460f      	mov	r7, r1
    DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
   a:	a802      	add	r0, sp, #8
{
   c:	4690      	mov	r8, r2
    DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
   e:	2100      	movs	r1, #0
  10:	2228      	movs	r2, #40	; 0x28
  12:	9001      	str	r0, [sp, #4]
  14:	f7ff fffe 	bl	0 <memset>
  18:	9b01      	ldr	r3, [sp, #4]
  1a:	2205      	movs	r2, #5
  1c:	61da      	str	r2, [r3, #28]
    if (key == NULL) {
  1e:	b31e      	cbz	r6, 68 <wc_ecc_make_pub_ex+0x68>
    ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  20:	f44f 7002 	mov.w	r0, #520	; 0x208
  24:	f7ff fffe 	bl	0 <malloc>
  28:	4605      	mov	r5, r0
  2a:	b1d0      	cbz	r0, 62 <wc_ecc_make_pub_ex+0x62>
  2c:	9b01      	ldr	r3, [sp, #4]
        err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
  2e:	223b      	movs	r2, #59	; 0x3b
    ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  30:	6198      	str	r0, [r3, #24]
        err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
  32:	a901      	add	r1, sp, #4
  34:	6930      	ldr	r0, [r6, #16]
  36:	f7ff fffe 	bl	0 <wc_ecc_make_pub_ex>
    if (err == MP_OKAY) {
  3a:	4604      	mov	r4, r0
  3c:	b930      	cbnz	r0, 4c <wc_ecc_make_pub_ex+0x4c>
        err = ecc_make_pub_ex(key, curve, pubOut, rng);
  3e:	9901      	ldr	r1, [sp, #4]
  40:	4643      	mov	r3, r8
  42:	463a      	mov	r2, r7
  44:	4630      	mov	r0, r6
  46:	f7ff fffe 	bl	0 <wc_ecc_make_pub_ex>
  4a:	4604      	mov	r4, r0
    wc_ecc_curve_free(curve);
  4c:	9801      	ldr	r0, [sp, #4]
  4e:	f7ff fffe 	bl	0 <wc_ecc_make_pub_ex>
    FREE_CURVE_SPECS();
  52:	b115      	cbz	r5, 5a <wc_ecc_make_pub_ex+0x5a>
  54:	4628      	mov	r0, r5
  56:	f7ff fffe 	bl	0 <free>
}
  5a:	4620      	mov	r0, r4
  5c:	b00c      	add	sp, #48	; 0x30
  5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  62:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  66:	e7f1      	b.n	4c <wc_ecc_make_pub_ex+0x4c>
        return BAD_FUNC_ARG;
  68:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  6c:	e7f5      	b.n	5a <wc_ecc_make_pub_ex+0x5a>

Disassembly of section .text.wc_ecc_make_pub:

00000000 <wc_ecc_make_pub>:
    return wc_ecc_make_pub_ex(key, pubOut, NULL);
   0:	2200      	movs	r2, #0
   2:	f7ff bffe 	b.w	0 <wc_ecc_make_pub>

Disassembly of section .text._ecc_make_key_ex:

00000000 <_ecc_make_key_ex>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4606      	mov	r6, r0
   6:	b08c      	sub	sp, #48	; 0x30
    if (key == NULL || rng == NULL) {
   8:	4615      	mov	r5, r2
   a:	2a00      	cmp	r2, #0
   c:	d055      	beq.n	ba <_ecc_make_key_ex+0xba>
   e:	2800      	cmp	r0, #0
  10:	d053      	beq.n	ba <_ecc_make_key_ex+0xba>
    key->state = ECC_STATE_NONE;
  12:	f04f 0800 	mov.w	r8, #0
  16:	f8c2 8008 	str.w	r8, [r2, #8]
    err = wc_ecc_set_curve(key, keysize, curve_id);
  1a:	4628      	mov	r0, r5
  1c:	461a      	mov	r2, r3
  1e:	f7ff fffe 	bl	0 <_ecc_make_key_ex>
    if (err != 0) {
  22:	4604      	mov	r4, r0
  24:	2800      	cmp	r0, #0
  26:	d13e      	bne.n	a6 <_ecc_make_key_ex+0xa6>
    key->flags = (byte)flags;
  28:	f89d 3048 	ldrb.w	r3, [sp, #72]	; 0x48
  2c:	60eb      	str	r3, [r5, #12]
        DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
  2e:	4621      	mov	r1, r4
  30:	a802      	add	r0, sp, #8
  32:	2228      	movs	r2, #40	; 0x28
  34:	9001      	str	r0, [sp, #4]
  36:	f7ff fffe 	bl	0 <memset>
  3a:	9b01      	ldr	r3, [sp, #4]
  3c:	2205      	movs	r2, #5
        err = mp_init(key->k);
  3e:	f505 77a8 	add.w	r7, r5, #336	; 0x150
        DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
  42:	61da      	str	r2, [r3, #28]
        err = mp_init(key->k);
  44:	4638      	mov	r0, r7
  46:	f7ff fffe 	bl	0 <mp_init>
        if (err == MP_OKAY) {
  4a:	4604      	mov	r4, r0
  4c:	bb88      	cbnz	r0, b2 <_ecc_make_key_ex+0xb2>
            ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  4e:	f44f 7002 	mov.w	r0, #520	; 0x208
  52:	f7ff fffe 	bl	0 <malloc>
  56:	4680      	mov	r8, r0
  58:	b348      	cbz	r0, ae <_ecc_make_key_ex+0xae>
  5a:	9b01      	ldr	r3, [sp, #4]
            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
  5c:	223b      	movs	r2, #59	; 0x3b
            ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  5e:	6198      	str	r0, [r3, #24]
            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
  60:	a901      	add	r1, sp, #4
  62:	6928      	ldr	r0, [r5, #16]
  64:	f7ff fffe 	bl	0 <_ecc_make_key_ex>
        if (err == MP_OKAY) {
  68:	4604      	mov	r4, r0
  6a:	bb10      	cbnz	r0, b2 <_ecc_make_key_ex+0xb2>
            err = wc_ecc_gen_k(rng, key->dp->size, key->k, curve->order);
  6c:	6929      	ldr	r1, [r5, #16]
  6e:	9b01      	ldr	r3, [sp, #4]
  70:	6809      	ldr	r1, [r1, #0]
  72:	68db      	ldr	r3, [r3, #12]
  74:	463a      	mov	r2, r7
  76:	4630      	mov	r0, r6
  78:	f7ff fffe 	bl	0 <_ecc_make_key_ex>
        if (err == MP_OKAY) {
  7c:	4604      	mov	r4, r0
  7e:	b9c0      	cbnz	r0, b2 <_ecc_make_key_ex+0xb2>
            err = ecc_make_pub_ex(key, curve, NULL, rng);
  80:	4602      	mov	r2, r0
  82:	9901      	ldr	r1, [sp, #4]
  84:	4633      	mov	r3, r6
  86:	4628      	mov	r0, r5
  88:	f7ff fffe 	bl	0 <_ecc_make_key_ex>
        if (err == MP_OKAY
  8c:	4604      	mov	r4, r0
  8e:	b980      	cbnz	r0, b2 <_ecc_make_key_ex+0xb2>
            key->type = ECC_PRIVATEKEY;
  90:	2302      	movs	r3, #2
  92:	602b      	str	r3, [r5, #0]
        wc_ecc_curve_free(curve);
  94:	9801      	ldr	r0, [sp, #4]
  96:	f7ff fffe 	bl	0 <_ecc_make_key_ex>
        FREE_CURVE_SPECS();
  9a:	f1b8 0f00 	cmp.w	r8, #0
  9e:	d002      	beq.n	a6 <_ecc_make_key_ex+0xa6>
  a0:	4640      	mov	r0, r8
  a2:	f7ff fffe 	bl	0 <free>
}
  a6:	4620      	mov	r0, r4
  a8:	b00c      	add	sp, #48	; 0x30
  aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  ae:	f06f 047c 	mvn.w	r4, #124	; 0x7c
            mp_forcezero(key->k);
  b2:	4638      	mov	r0, r7
  b4:	f7ff fffe 	bl	0 <mp_forcezero>
  b8:	e7ec      	b.n	94 <_ecc_make_key_ex+0x94>
        return BAD_FUNC_ARG;
  ba:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  be:	e7f2      	b.n	a6 <_ecc_make_key_ex+0xa6>

Disassembly of section .text.wc_ecc_make_key_ex2:

00000000 <wc_ecc_make_key_ex2>:
    err = _ecc_make_key_ex(rng, keysize, key, curve_id, flags);
   0:	f7ff bffe 	b.w	0 <wc_ecc_make_key_ex2>

Disassembly of section .text.wc_ecc_make_key_ex:

00000000 <wc_ecc_make_key_ex>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    err = _ecc_make_key_ex(rng, keysize, key, curve_id, flags);
   2:	2400      	movs	r4, #0
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <wc_ecc_make_key_ex>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_make_key:

00000000 <wc_ecc_make_key>:
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
   0:	2300      	movs	r3, #0
   2:	f7ff bffe 	b.w	0 <wc_ecc_make_key>

Disassembly of section .text.wc_ecc_sign_hash_ex:

00000000 <wc_ecc_sign_hash_ex>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b095      	sub	sp, #84	; 0x54
   6:	4607      	mov	r7, r0
   8:	9203      	str	r2, [sp, #12]
   DECLARE_CURVE_SPECS(1);
   a:	a80a      	add	r0, sp, #40	; 0x28
   c:	2228      	movs	r2, #40	; 0x28
{
   e:	460e      	mov	r6, r1
   DECLARE_CURVE_SPECS(1);
  10:	2100      	movs	r1, #0
{
  12:	461c      	mov	r4, r3
  14:	f8dd 807c 	ldr.w	r8, [sp, #124]	; 0x7c
   DECLARE_CURVE_SPECS(1);
  18:	9009      	str	r0, [sp, #36]	; 0x24
  1a:	f7ff fffe 	bl	0 <memset>
  1e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  20:	2201      	movs	r2, #1
  22:	61da      	str	r2, [r3, #28]
   if (in == NULL || r == NULL || s == NULL || key == NULL || rng == NULL) {
  24:	2f00      	cmp	r7, #0
  26:	f000 8141 	beq.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
  2a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
  2c:	2b00      	cmp	r3, #0
  2e:	f000 813d 	beq.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
  32:	f1b8 0f00 	cmp.w	r8, #0
  36:	f000 8139 	beq.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
  3a:	2c00      	cmp	r4, #0
  3c:	f000 8136 	beq.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
  40:	9b03      	ldr	r3, [sp, #12]
  42:	2b00      	cmp	r3, #0
  44:	f000 8132 	beq.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
   if (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY) {
  48:	6823      	ldr	r3, [r4, #0]
  4a:	3b02      	subs	r3, #2
  4c:	4293      	cmp	r3, r2
  4e:	f200 812d 	bhi.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
   if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
  52:	6860      	ldr	r0, [r4, #4]
  54:	f7ff fffe 	bl	0 <wc_ecc_sign_hash_ex>
  58:	2800      	cmp	r0, #0
  5a:	f000 8127 	beq.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
  5e:	6923      	ldr	r3, [r4, #16]
  60:	2b00      	cmp	r3, #0
  62:	f000 8123 	beq.w	2ac <wc_ecc_sign_hash_ex+0x2ac>
   NEW_MP_INT_SIZE(e_lcl, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
  66:	2068      	movs	r0, #104	; 0x68
  68:	f7ff fffe 	bl	0 <malloc>
  6c:	4605      	mov	r5, r0
  6e:	2800      	cmp	r0, #0
  70:	f000 811f 	beq.w	2b2 <wc_ecc_sign_hash_ex+0x2b2>
  74:	2268      	movs	r2, #104	; 0x68
  76:	2100      	movs	r1, #0
  78:	f7ff fffe 	bl	0 <memset>
   if ((err = INIT_MP_INT_SIZE(e, ECC_KEY_MAX_BITS(key))) != MP_OKAY) {
  7c:	4628      	mov	r0, r5
  7e:	f7ff fffe 	bl	0 <mp_init>
  82:	4683      	mov	fp, r0
  84:	b130      	cbz	r0, 94 <wc_ecc_sign_hash_ex+0x94>
      FREE_MP_INT_SIZE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
  86:	4628      	mov	r0, r5
   FREE_CURVE_SPECS();
  88:	f7ff fffe 	bl	0 <free>
}
  8c:	4658      	mov	r0, fp
  8e:	b015      	add	sp, #84	; 0x54
  90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ALLOC_CURVE_SPECS(1, err);
  94:	2068      	movs	r0, #104	; 0x68
  96:	f7ff fffe 	bl	0 <malloc>
  9a:	9002      	str	r0, [sp, #8]
  9c:	b978      	cbnz	r0, be <wc_ecc_sign_hash_ex+0xbe>
  9e:	f06f 0b7c 	mvn.w	fp, #124	; 0x7c
   mp_clear(e);
  a2:	4628      	mov	r0, r5
  a4:	f7ff fffe 	bl	0 <mp_clear>
   wc_ecc_curve_free(curve);
  a8:	9809      	ldr	r0, [sp, #36]	; 0x24
  aa:	f7ff fffe 	bl	0 <wc_ecc_sign_hash_ex>
   FREE_MP_INT_SIZE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
  ae:	4628      	mov	r0, r5
  b0:	f7ff fffe 	bl	0 <free>
   FREE_CURVE_SPECS();
  b4:	9b02      	ldr	r3, [sp, #8]
  b6:	2b00      	cmp	r3, #0
  b8:	d0e8      	beq.n	8c <wc_ecc_sign_hash_ex+0x8c>
  ba:	4618      	mov	r0, r3
  bc:	e7e4      	b.n	88 <wc_ecc_sign_hash_ex+0x88>
        ALLOC_CURVE_SPECS(1, err);
  be:	9b09      	ldr	r3, [sp, #36]	; 0x24
  c0:	9a02      	ldr	r2, [sp, #8]
  c2:	619a      	str	r2, [r3, #24]
            err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
  c4:	6920      	ldr	r0, [r4, #16]
  c6:	2208      	movs	r2, #8
  c8:	a909      	add	r1, sp, #36	; 0x24
  ca:	f7ff fffe 	bl	0 <wc_ecc_sign_hash_ex>
   if (err == MP_OKAY) {
  ce:	4683      	mov	fp, r0
  d0:	2800      	cmp	r0, #0
  d2:	d1e6      	bne.n	a2 <wc_ecc_sign_hash_ex+0xa2>
       word32 orderBits = (word32)mp_count_bits(curve->order);
  d4:	9b09      	ldr	r3, [sp, #36]	; 0x24
  d6:	68d8      	ldr	r0, [r3, #12]
  d8:	f7ff fffe 	bl	0 <mp_count_bits>
       if ((WOLFSSL_BIT_SIZE * inlen) > orderBits)
  dc:	ebb0 0fc6 	cmp.w	r0, r6, lsl #3
           inlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
  e0:	bf3c      	itt	cc
  e2:	1dc6      	addcc	r6, r0, #7
  e4:	08f6      	lsrcc	r6, r6, #3
       word32 orderBits = (word32)mp_count_bits(curve->order);
  e6:	4681      	mov	r9, r0
       err = mp_read_unsigned_bin(e, in, inlen);
  e8:	4632      	mov	r2, r6
  ea:	4639      	mov	r1, r7
  ec:	4628      	mov	r0, r5
  ee:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * inlen) > orderBits)
  f2:	4683      	mov	fp, r0
  f4:	2800      	cmp	r0, #0
  f6:	d1d4      	bne.n	a2 <wc_ecc_sign_hash_ex+0xa2>
  f8:	ebb9 0fc6 	cmp.w	r9, r6, lsl #3
  fc:	d206      	bcs.n	10c <wc_ecc_sign_hash_ex+0x10c>
           mp_rshb(e, (int)(WOLFSSL_BIT_SIZE - (orderBits & 0x7)));
  fe:	f009 0107 	and.w	r1, r9, #7
 102:	f1c1 0108 	rsb	r1, r1, #8
 106:	4628      	mov	r0, r5
 108:	f7ff fffe 	bl	0 <mp_rshb>
       pubkey = (ecc_key*)XMALLOC(sizeof(ecc_key), key->heap, DYNAMIC_TYPE_ECC);
 10c:	f44f 70de 	mov.w	r0, #444	; 0x1bc
 110:	f7ff fffe 	bl	0 <malloc>
       if (pubkey == NULL)
 114:	4606      	mov	r6, r0
 116:	2800      	cmp	r0, #0
 118:	d0c1      	beq.n	9e <wc_ecc_sign_hash_ex+0x9e>
           err = wc_ecc_init_ex(pubkey, key->heap, INVALID_DEVID);
 11a:	6961      	ldr	r1, [r4, #20]
 11c:	f06f 0201 	mvn.w	r2, #1
 120:	f7ff fffe 	bl	0 <wc_ecc_sign_hash_ex>
           if (err == MP_OKAY) {
 124:	4683      	mov	fp, r0
 126:	2800      	cmp	r0, #0
 128:	d1bb      	bne.n	a2 <wc_ecc_sign_hash_ex+0xa2>
    NEW_MP_INT_SIZE(b, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
 12a:	2068      	movs	r0, #104	; 0x68
              err = ecc_sign_hash_sw(key, pubkey, rng, curve, e, r, s);
 12c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    NEW_MP_INT_SIZE(b, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
 130:	f7ff fffe 	bl	0 <malloc>
 134:	4607      	mov	r7, r0
 136:	2800      	cmp	r0, #0
 138:	f000 80b5 	beq.w	2a6 <wc_ecc_sign_hash_ex+0x2a6>
 13c:	4659      	mov	r1, fp
 13e:	2268      	movs	r2, #104	; 0x68
 140:	f7ff fffe 	bl	0 <memset>
        err = INIT_MP_INT_SIZE(b, ECC_KEY_MAX_BITS(key));
 144:	4638      	mov	r0, r7
 146:	f7ff fffe 	bl	0 <mp_init>
    if (err == MP_OKAY) {
 14a:	4683      	mov	fp, r0
 14c:	b930      	cbnz	r0, 15c <wc_ecc_sign_hash_ex+0x15c>
 14e:	f04f 0a41 	mov.w	sl, #65	; 0x41
            if (++loop_check > 64) {
 152:	f1ba 0a01 	subs.w	sl, sl, #1
 156:	d10f      	bne.n	178 <wc_ecc_sign_hash_ex+0x178>
                 err = RNG_FAILURE_E;
 158:	f06f 0bc6 	mvn.w	fp, #198	; 0xc6
    mp_forcezero(b);
 15c:	4638      	mov	r0, r7
 15e:	f7ff fffe 	bl	0 <mp_forcezero>
    FREE_MP_INT_SIZE(b, key->heap, DYNAMIC_TYPE_ECC);
 162:	b117      	cbz	r7, 16a <wc_ecc_sign_hash_ex+0x16a>
 164:	4638      	mov	r0, r7
 166:	f7ff fffe 	bl	0 <free>
              wc_ecc_free(pubkey);
 16a:	4630      	mov	r0, r6
 16c:	f7ff fffe 	bl	0 <wc_ecc_sign_hash_ex>
              XFREE(pubkey, key->heap, DYNAMIC_TYPE_ECC);
 170:	4630      	mov	r0, r6
 172:	f7ff fffe 	bl	0 <free>
 176:	e794      	b.n	a2 <wc_ecc_sign_hash_ex+0xa2>
            err = wc_ecc_gen_k(rng, key->dp->size, b, curve->order);
 178:	6921      	ldr	r1, [r4, #16]
 17a:	f8d9 300c 	ldr.w	r3, [r9, #12]
 17e:	6809      	ldr	r1, [r1, #0]
 180:	9803      	ldr	r0, [sp, #12]
 182:	463a      	mov	r2, r7
 184:	f7ff fffe 	bl	0 <wc_ecc_sign_hash_ex>
        while (err == MP_ZERO_E);
 188:	f110 0f79 	cmn.w	r0, #121	; 0x79
            err = wc_ecc_gen_k(rng, key->dp->size, b, curve->order);
 18c:	4683      	mov	fp, r0
        while (err == MP_ZERO_E);
 18e:	d0e0      	beq.n	152 <wc_ecc_sign_hash_ex+0x152>
    for (; err == MP_OKAY;) {
 190:	f1bb 0f00 	cmp.w	fp, #0
 194:	d1e2      	bne.n	15c <wc_ecc_sign_hash_ex+0x15c>
 196:	2341      	movs	r3, #65	; 0x41
 198:	9304      	str	r3, [sp, #16]
        err = mp_mod(pubkey->pubkey.x, curve->order, r);
 19a:	f106 0318 	add.w	r3, r6, #24
            err = _ecc_make_key_ex(rng, key->dp->size, pubkey, key->dp->id,
 19e:	f8cd b018 	str.w	fp, [sp, #24]
        err = mp_mod(pubkey->pubkey.x, curve->order, r);
 1a2:	9305      	str	r3, [sp, #20]
            mp_int* ep = pubkey->k;
 1a4:	f506 7aa8 	add.w	sl, r6, #336	; 0x150
        if (++loop_check > 64) {
 1a8:	9b04      	ldr	r3, [sp, #16]
 1aa:	3b01      	subs	r3, #1
 1ac:	9304      	str	r3, [sp, #16]
 1ae:	d0d3      	beq.n	158 <wc_ecc_sign_hash_ex+0x158>
            err = _ecc_make_key_ex(rng, key->dp->size, pubkey, key->dp->id,
 1b0:	6921      	ldr	r1, [r4, #16]
 1b2:	9b06      	ldr	r3, [sp, #24]
 1b4:	9300      	str	r3, [sp, #0]
 1b6:	684b      	ldr	r3, [r1, #4]
 1b8:	9803      	ldr	r0, [sp, #12]
 1ba:	6809      	ldr	r1, [r1, #0]
 1bc:	4632      	mov	r2, r6
 1be:	f7ff fffe 	bl	0 <wc_ecc_sign_hash_ex>
        if (err != MP_OKAY) break;
 1c2:	4683      	mov	fp, r0
 1c4:	2800      	cmp	r0, #0
 1c6:	d1c9      	bne.n	15c <wc_ecc_sign_hash_ex+0x15c>
        err = mp_mod(pubkey->pubkey.x, curve->order, r);
 1c8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 1ca:	f8d9 100c 	ldr.w	r1, [r9, #12]
 1ce:	9805      	ldr	r0, [sp, #20]
 1d0:	f7ff fffe 	bl	0 <mp_mod>
        if (err != MP_OKAY) break;
 1d4:	4683      	mov	fp, r0
 1d6:	2800      	cmp	r0, #0
 1d8:	d1c0      	bne.n	15c <wc_ecc_sign_hash_ex+0x15c>
        if (mp_iszero(r) == MP_NO) {
 1da:	981e      	ldr	r0, [sp, #120]	; 0x78
 1dc:	f7ff fffe 	bl	0 <mp_iszero>
 1e0:	b170      	cbz	r0, 200 <wc_ecc_sign_hash_ex+0x200>
         mp_clear(pubkey->pubkey.x);
 1e2:	9805      	ldr	r0, [sp, #20]
 1e4:	f7ff fffe 	bl	0 <mp_clear>
         mp_clear(pubkey->pubkey.y);
 1e8:	f106 0080 	add.w	r0, r6, #128	; 0x80
 1ec:	f7ff fffe 	bl	0 <mp_clear>
         mp_clear(pubkey->pubkey.z);
 1f0:	f106 00e8 	add.w	r0, r6, #232	; 0xe8
 1f4:	f7ff fffe 	bl	0 <mp_clear>
         mp_forcezero(pubkey->k);
 1f8:	4650      	mov	r0, sl
 1fa:	f7ff fffe 	bl	0 <mp_forcezero>
    for (; err == MP_OKAY;) {
 1fe:	e7d3      	b.n	1a8 <wc_ecc_sign_hash_ex+0x1a8>
            mp_int* x  = key->k;
 200:	f504 73a8 	add.w	r3, r4, #336	; 0x150
 204:	9307      	str	r3, [sp, #28]
            err = mp_mulmod(pubkey->k, b, curve->order, kp);
 206:	f8d9 200c 	ldr.w	r2, [r9, #12]
 20a:	4653      	mov	r3, sl
 20c:	4639      	mov	r1, r7
 20e:	4650      	mov	r0, sl
 210:	f7ff fffe 	bl	0 <mp_mulmod>
            if (err != MP_OKAY) break;
 214:	4683      	mov	fp, r0
 216:	2800      	cmp	r0, #0
 218:	d1a0      	bne.n	15c <wc_ecc_sign_hash_ex+0x15c>
            err = mp_invmod(kp, curve->order, kp);
 21a:	f8d9 100c 	ldr.w	r1, [r9, #12]
 21e:	4652      	mov	r2, sl
 220:	4650      	mov	r0, sl
 222:	f7ff fffe 	bl	0 <mp_invmod>
            if (err != MP_OKAY) break;
 226:	4683      	mov	fp, r0
 228:	2800      	cmp	r0, #0
 22a:	d197      	bne.n	15c <wc_ecc_sign_hash_ex+0x15c>
            err = mp_mulmod(x, r, curve->order, s);
 22c:	f8d9 200c 	ldr.w	r2, [r9, #12]
 230:	991e      	ldr	r1, [sp, #120]	; 0x78
 232:	4643      	mov	r3, r8
 234:	f504 70a8 	add.w	r0, r4, #336	; 0x150
 238:	f7ff fffe 	bl	0 <mp_mulmod>
            if (err != MP_OKAY) break;
 23c:	4683      	mov	fp, r0
 23e:	2800      	cmp	r0, #0
 240:	d18c      	bne.n	15c <wc_ecc_sign_hash_ex+0x15c>
            err = mp_mulmod(kp, s, curve->order, s);
 242:	f8d9 200c 	ldr.w	r2, [r9, #12]
 246:	4643      	mov	r3, r8
 248:	4641      	mov	r1, r8
 24a:	4650      	mov	r0, sl
 24c:	f7ff fffe 	bl	0 <mp_mulmod>
            if (err != MP_OKAY) break;
 250:	4683      	mov	fp, r0
 252:	2800      	cmp	r0, #0
 254:	d182      	bne.n	15c <wc_ecc_sign_hash_ex+0x15c>
            err = mp_mulmod(kp, e, curve->order, ep);
 256:	f8d9 200c 	ldr.w	r2, [r9, #12]
 25a:	4653      	mov	r3, sl
 25c:	4629      	mov	r1, r5
 25e:	4650      	mov	r0, sl
 260:	f7ff fffe 	bl	0 <mp_mulmod>
            if (err != MP_OKAY) break;
 264:	4683      	mov	fp, r0
 266:	2800      	cmp	r0, #0
 268:	f47f af78 	bne.w	15c <wc_ecc_sign_hash_ex+0x15c>
            err = mp_addmod_ct(ep, s, curve->order, s);
 26c:	f8d9 200c 	ldr.w	r2, [r9, #12]
 270:	4643      	mov	r3, r8
 272:	4641      	mov	r1, r8
 274:	4650      	mov	r0, sl
 276:	f7ff fffe 	bl	0 <mp_addmod_ct>
            if (err != MP_OKAY) break;
 27a:	4683      	mov	fp, r0
 27c:	2800      	cmp	r0, #0
 27e:	f47f af6d 	bne.w	15c <wc_ecc_sign_hash_ex+0x15c>
            err = mp_mulmod(s, b, curve->order, s);
 282:	f8d9 200c 	ldr.w	r2, [r9, #12]
 286:	4643      	mov	r3, r8
 288:	4639      	mov	r1, r7
 28a:	4640      	mov	r0, r8
 28c:	f7ff fffe 	bl	0 <mp_mulmod>
            if (err != MP_OKAY) break;
 290:	4683      	mov	fp, r0
 292:	2800      	cmp	r0, #0
 294:	f47f af62 	bne.w	15c <wc_ecc_sign_hash_ex+0x15c>
            if (mp_iszero(s) == MP_NO) {
 298:	4640      	mov	r0, r8
 29a:	f7ff fffe 	bl	0 <mp_iszero>
 29e:	4683      	mov	fp, r0
 2a0:	2800      	cmp	r0, #0
 2a2:	d19e      	bne.n	1e2 <wc_ecc_sign_hash_ex+0x1e2>
 2a4:	e75a      	b.n	15c <wc_ecc_sign_hash_ex+0x15c>
        err = MEMORY_E;
 2a6:	f06f 0b7c 	mvn.w	fp, #124	; 0x7c
 2aa:	e757      	b.n	15c <wc_ecc_sign_hash_ex+0x15c>
       return ECC_BAD_ARG_E;
 2ac:	f06f 0ba9 	mvn.w	fp, #169	; 0xa9
 2b0:	e6ec      	b.n	8c <wc_ecc_sign_hash_ex+0x8c>
      return MEMORY_E;
 2b2:	f06f 0b7c 	mvn.w	fp, #124	; 0x7c
 2b6:	e6e9      	b.n	8c <wc_ecc_sign_hash_ex+0x8c>

Disassembly of section .text.wc_ecc_sign_hash:

00000000 <wc_ecc_sign_hash>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
   8:	4689      	mov	r9, r1
   a:	4616      	mov	r6, r2
   c:	461f      	mov	r7, r3
    if (in == NULL || out == NULL || outlen == NULL || key == NULL) {
   e:	4680      	mov	r8, r0
  10:	2800      	cmp	r0, #0
  12:	d04d      	beq.n	b0 <wc_ecc_sign_hash+0xb0>
  14:	2a00      	cmp	r2, #0
  16:	d04b      	beq.n	b0 <wc_ecc_sign_hash+0xb0>
  18:	2b00      	cmp	r3, #0
  1a:	d049      	beq.n	b0 <wc_ecc_sign_hash+0xb0>
  1c:	f1bb 0f00 	cmp.w	fp, #0
  20:	d046      	beq.n	b0 <wc_ecc_sign_hash+0xb0>
    if (rng == NULL) {
  22:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  24:	2b00      	cmp	r3, #0
  26:	d043      	beq.n	b0 <wc_ecc_sign_hash+0xb0>
    NEW_MP_INT_SIZE(r, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
  28:	2068      	movs	r0, #104	; 0x68
  2a:	f7ff fffe 	bl	0 <malloc>
  2e:	4604      	mov	r4, r0
  30:	2800      	cmp	r0, #0
  32:	d043      	beq.n	bc <wc_ecc_sign_hash+0xbc>
  34:	2268      	movs	r2, #104	; 0x68
  36:	2100      	movs	r1, #0
  38:	f7ff fffe 	bl	0 <memset>
    NEW_MP_INT_SIZE(s, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
  3c:	2068      	movs	r0, #104	; 0x68
  3e:	f7ff fffe 	bl	0 <malloc>
  42:	4605      	mov	r5, r0
  44:	b3b8      	cbz	r0, b6 <wc_ecc_sign_hash+0xb6>
  46:	2268      	movs	r2, #104	; 0x68
  48:	2100      	movs	r1, #0
  4a:	f7ff fffe 	bl	0 <memset>
    err = INIT_MP_INT_SIZE(r, ECC_KEY_MAX_BITS(key));
  4e:	4620      	mov	r0, r4
  50:	f7ff fffe 	bl	0 <mp_init>
    if (err != 0) {
  54:	4682      	mov	sl, r0
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  56:	4628      	mov	r0, r5
    if (err != 0) {
  58:	f1ba 0f00 	cmp.w	sl, #0
  5c:	d008      	beq.n	70 <wc_ecc_sign_hash+0x70>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  5e:	f7ff fffe 	bl	0 <free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
  62:	4620      	mov	r0, r4
  64:	f7ff fffe 	bl	0 <free>
}
  68:	4650      	mov	r0, sl
  6a:	b003      	add	sp, #12
  6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    err = INIT_MP_INT_SIZE(s, ECC_KEY_MAX_BITS(key));
  70:	f7ff fffe 	bl	0 <mp_init>
    if (err != 0) {
  74:	4682      	mov	sl, r0
  76:	b108      	cbz	r0, 7c <wc_ecc_sign_hash+0x7c>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  78:	4628      	mov	r0, r5
  7a:	e7f0      	b.n	5e <wc_ecc_sign_hash+0x5e>
    err = wc_ecc_sign_hash_ex(in, inlen, rng, key, r, s);
  7c:	e9cd 4500 	strd	r4, r5, [sp]
  80:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  82:	465b      	mov	r3, fp
  84:	4649      	mov	r1, r9
  86:	4640      	mov	r0, r8
  88:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
    if (err < 0) {
  8c:	f1b0 0a00 	subs.w	sl, r0, #0
  90:	da06      	bge.n	a0 <wc_ecc_sign_hash+0xa0>
    mp_clear(r);
  92:	4620      	mov	r0, r4
  94:	f7ff fffe 	bl	0 <mp_clear>
    mp_clear(s);
  98:	4628      	mov	r0, r5
  9a:	f7ff fffe 	bl	0 <mp_clear>
    FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  9e:	e7eb      	b.n	78 <wc_ecc_sign_hash+0x78>
    err = StoreECC_DSA_Sig(out, outlen, r, s);
  a0:	462b      	mov	r3, r5
  a2:	4622      	mov	r2, r4
  a4:	4639      	mov	r1, r7
  a6:	4630      	mov	r0, r6
  a8:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig>
  ac:	4682      	mov	sl, r0
  ae:	e7f0      	b.n	92 <wc_ecc_sign_hash+0x92>
        return ECC_BAD_ARG_E;
  b0:	f06f 0aa9 	mvn.w	sl, #169	; 0xa9
  b4:	e7d8      	b.n	68 <wc_ecc_sign_hash+0x68>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
  b6:	4620      	mov	r0, r4
  b8:	f7ff fffe 	bl	0 <free>
        return MEMORY_E;
  bc:	f06f 0a7c 	mvn.w	sl, #124	; 0x7c
  c0:	e7d2      	b.n	68 <wc_ecc_sign_hash+0x68>

Disassembly of section .text.ecc_mul2add:

00000000 <ecc_mul2add>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b08d      	sub	sp, #52	; 0x34
  mp_digit       mp = 0;
   6:	f04f 0b00 	mov.w	fp, #0
{
   a:	9f16      	ldr	r7, [sp, #88]	; 0x58
   c:	9d18      	ldr	r5, [sp, #96]	; 0x60
   e:	9205      	str	r2, [sp, #20]
  10:	468a      	mov	sl, r1
  12:	461e      	mov	r6, r3
  mp_digit       mp = 0;
  14:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
  if (A == NULL || kA == NULL || B == NULL || kB == NULL || C == NULL ||
  18:	4680      	mov	r8, r0
  1a:	2800      	cmp	r0, #0
  1c:	f000 81b0 	beq.w	380 <ecc_mul2add+0x380>
  20:	2900      	cmp	r1, #0
  22:	f000 81ad 	beq.w	380 <ecc_mul2add+0x380>
  26:	2a00      	cmp	r2, #0
  28:	f000 81aa 	beq.w	380 <ecc_mul2add+0x380>
  2c:	2e00      	cmp	r6, #0
  2e:	f000 81a7 	beq.w	380 <ecc_mul2add+0x380>
  32:	2f00      	cmp	r7, #0
  34:	f000 81a4 	beq.w	380 <ecc_mul2add+0x380>
  38:	2d00      	cmp	r5, #0
  3a:	f000 81a1 	beq.w	380 <ecc_mul2add+0x380>
  tA = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
  3e:	f240 1001 	movw	r0, #257	; 0x101
  42:	f7ff fffe 	bl	0 <malloc>
  if (tA == NULL) {
  46:	4681      	mov	r9, r0
  48:	b140      	cbz	r0, 5c <ecc_mul2add+0x5c>
  tB = (unsigned char*)XMALLOC(ECC_BUFSIZE, heap, DYNAMIC_TYPE_ECC_BUFFER);
  4a:	f240 1001 	movw	r0, #257	; 0x101
  4e:	f7ff fffe 	bl	0 <malloc>
  if (tB == NULL) {
  52:	9004      	str	r0, [sp, #16]
  54:	b928      	cbnz	r0, 62 <ecc_mul2add+0x62>
     XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
  56:	4648      	mov	r0, r9
  58:	f7ff fffe 	bl	0 <free>
     return GEN_MEM_ERR;
  5c:	f06f 0101 	mvn.w	r1, #1
  60:	e109      	b.n	276 <ecc_mul2add+0x276>
  precomp = (ecc_point**)XMALLOC(sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ, heap,
  62:	2040      	movs	r0, #64	; 0x40
  64:	f7ff fffe 	bl	0 <malloc>
  if (precomp == NULL) {
  68:	4604      	mov	r4, r0
  6a:	b918      	cbnz	r0, 74 <ecc_mul2add+0x74>
     XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
  6c:	9804      	ldr	r0, [sp, #16]
  6e:	f7ff fffe 	bl	0 <free>
  72:	e7f0      	b.n	56 <ecc_mul2add+0x56>
  XMEMSET(tA, 0, ECC_BUFSIZE);
  74:	4659      	mov	r1, fp
  76:	f240 1201 	movw	r2, #257	; 0x101
  7a:	4648      	mov	r0, r9
  7c:	f7ff fffe 	bl	0 <memset>
  XMEMSET(tB, 0, ECC_BUFSIZE);
  80:	4659      	mov	r1, fp
  82:	f240 1201 	movw	r2, #257	; 0x101
  86:	9804      	ldr	r0, [sp, #16]
  88:	f7ff fffe 	bl	0 <memset>
  XMEMSET(precomp, 0, sizeof(ecc_point*) * SHAMIR_PRECOMP_SZ);
  8c:	4659      	mov	r1, fp
  8e:	2240      	movs	r2, #64	; 0x40
  90:	4620      	mov	r0, r4
  92:	f7ff fffe 	bl	0 <memset>
  lenA = (unsigned int)mp_unsigned_bin_size(kA);
  96:	4650      	mov	r0, sl
  98:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  9c:	9006      	str	r0, [sp, #24]
  lenB = (unsigned int)mp_unsigned_bin_size(kB);
  9e:	4630      	mov	r0, r6
  a0:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {
  a4:	9906      	ldr	r1, [sp, #24]
  a6:	f5b1 7f81 	cmp.w	r1, #258	; 0x102
  lenB = (unsigned int)mp_unsigned_bin_size(kB);
  aa:	4683      	mov	fp, r0
  if ((lenA > ECC_BUFSIZE) || (lenB > ECC_BUFSIZE)) {
  ac:	f080 815c 	bcs.w	368 <ecc_mul2add+0x368>
  b0:	f5b0 7f81 	cmp.w	r0, #258	; 0x102
  b4:	f080 8158 	bcs.w	368 <ecc_mul2add+0x368>
  len  = MAX(lenA, lenB);
  b8:	4281      	cmp	r1, r0
  ba:	460b      	mov	r3, r1
  bc:	bf38      	it	cc
  be:	4603      	movcc	r3, r0
    err = mp_to_unsigned_bin(kA, (len - lenA) + tA);
  c0:	1a59      	subs	r1, r3, r1
  c2:	4449      	add	r1, r9
  c4:	4650      	mov	r0, sl
  len  = MAX(lenA, lenB);
  c6:	9306      	str	r3, [sp, #24]
    err = mp_to_unsigned_bin(kA, (len - lenA) + tA);
  c8:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
    if (err == MP_OKAY)
  cc:	4601      	mov	r1, r0
  ce:	2800      	cmp	r0, #0
  d0:	f040 80ad 	bne.w	22e <ecc_mul2add+0x22e>
        err = mp_to_unsigned_bin(kB, (len - lenB) + tB);
  d4:	9b06      	ldr	r3, [sp, #24]
  d6:	eba3 010b 	sub.w	r1, r3, fp
  da:	9b04      	ldr	r3, [sp, #16]
  dc:	4630      	mov	r0, r6
  de:	4419      	add	r1, r3
  e0:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
    if (err == MP_OKAY) {
  e4:	4601      	mov	r1, r0
  e6:	2800      	cmp	r0, #0
  e8:	f040 80a1 	bne.w	22e <ecc_mul2add+0x22e>
  ec:	f104 0340 	add.w	r3, r4, #64	; 0x40
  f0:	4626      	mov	r6, r4
  f2:	9307      	str	r3, [sp, #28]
            err = wc_ecc_new_point_ex(&precomp[x], heap);
  f4:	4630      	mov	r0, r6
  f6:	f7ff fffe 	bl	0 <ecc_mul2add>
            if (err != MP_OKAY)
  fa:	4601      	mov	r1, r0
  fc:	2800      	cmp	r0, #0
  fe:	f040 8096 	bne.w	22e <ecc_mul2add+0x22e>
        for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 102:	9b07      	ldr	r3, [sp, #28]
 104:	3604      	adds	r6, #4
 106:	429e      	cmp	r6, r3
 108:	d1f4      	bne.n	f4 <ecc_mul2add+0xf4>
    err = mp_montgomery_setup(modulus, &mp);
 10a:	a90b      	add	r1, sp, #44	; 0x2c
 10c:	4628      	mov	r0, r5
 10e:	f7ff fffe 	bl	0 <mp_montgomery_setup>
  if (err == MP_OKAY) {
 112:	4601      	mov	r1, r0
 114:	2800      	cmp	r0, #0
 116:	f040 808a 	bne.w	22e <ecc_mul2add+0x22e>
    NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 11a:	2068      	movs	r0, #104	; 0x68
    err = ecc_mont_norm_points(A, precomp[1], B, precomp[1<<2], modulus, heap);
 11c:	f8d4 b004 	ldr.w	fp, [r4, #4]
 120:	f8d4 a010 	ldr.w	sl, [r4, #16]
 124:	9108      	str	r1, [sp, #32]
    NEW_MP_INT_SIZE(mu, mp_bitsused(modulus), heap, DYNAMIC_TYPE_ECC);
 126:	f7ff fffe 	bl	0 <malloc>
 12a:	4606      	mov	r6, r0
 12c:	2800      	cmp	r0, #0
 12e:	f000 811e 	beq.w	36e <ecc_mul2add+0x36e>
 132:	9908      	ldr	r1, [sp, #32]
 134:	2268      	movs	r2, #104	; 0x68
 136:	f7ff fffe 	bl	0 <memset>
        err = INIT_MP_INT_SIZE(mu, mp_bitsused(modulus));
 13a:	4630      	mov	r0, r6
 13c:	f7ff fffe 	bl	0 <mp_init>
    if (err == MP_OKAY) {
 140:	4601      	mov	r1, r0
 142:	2800      	cmp	r0, #0
 144:	d141      	bne.n	1ca <ecc_mul2add+0x1ca>
        err = mp_montgomery_calc_normalization(mu, modulus);
 146:	4629      	mov	r1, r5
 148:	4630      	mov	r0, r6
 14a:	f7ff fffe 	bl	0 <mp_montgomery_calc_normalization>
        if (err == MP_OKAY) {
 14e:	4601      	mov	r1, r0
 150:	bbb0      	cbnz	r0, 1c0 <ecc_mul2add+0x1c0>
            err = mp_mulmod(A->x, mu, modulus, Am->x);
 152:	4631      	mov	r1, r6
 154:	465b      	mov	r3, fp
 156:	462a      	mov	r2, r5
 158:	4640      	mov	r0, r8
 15a:	f7ff fffe 	bl	0 <mp_mulmod>
        if (err == MP_OKAY)
 15e:	4601      	mov	r1, r0
 160:	bb70      	cbnz	r0, 1c0 <ecc_mul2add+0x1c0>
            err = mp_mulmod(A->y, mu, modulus, Am->y);
 162:	4631      	mov	r1, r6
 164:	f10b 0368 	add.w	r3, fp, #104	; 0x68
 168:	462a      	mov	r2, r5
 16a:	f108 0068 	add.w	r0, r8, #104	; 0x68
 16e:	f7ff fffe 	bl	0 <mp_mulmod>
        if (err == MP_OKAY)
 172:	4601      	mov	r1, r0
 174:	bb20      	cbnz	r0, 1c0 <ecc_mul2add+0x1c0>
            err = mp_mulmod(A->z, mu, modulus, Am->z);
 176:	4631      	mov	r1, r6
 178:	f10b 03d0 	add.w	r3, fp, #208	; 0xd0
 17c:	462a      	mov	r2, r5
 17e:	f108 00d0 	add.w	r0, r8, #208	; 0xd0
 182:	f7ff fffe 	bl	0 <mp_mulmod>
        if (err == MP_OKAY)
 186:	4601      	mov	r1, r0
 188:	b9d0      	cbnz	r0, 1c0 <ecc_mul2add+0x1c0>
            err = mp_mulmod(B->x, mu, modulus, Bm->x);
 18a:	4631      	mov	r1, r6
 18c:	9805      	ldr	r0, [sp, #20]
 18e:	4653      	mov	r3, sl
 190:	462a      	mov	r2, r5
 192:	f7ff fffe 	bl	0 <mp_mulmod>
        if (err == MP_OKAY)
 196:	4601      	mov	r1, r0
 198:	b990      	cbnz	r0, 1c0 <ecc_mul2add+0x1c0>
            err = mp_mulmod(B->y, mu, modulus, Bm->y);
 19a:	9805      	ldr	r0, [sp, #20]
 19c:	4631      	mov	r1, r6
 19e:	f10a 0368 	add.w	r3, sl, #104	; 0x68
 1a2:	462a      	mov	r2, r5
 1a4:	3068      	adds	r0, #104	; 0x68
 1a6:	f7ff fffe 	bl	0 <mp_mulmod>
        if (err == MP_OKAY)
 1aa:	4601      	mov	r1, r0
 1ac:	b940      	cbnz	r0, 1c0 <ecc_mul2add+0x1c0>
            err = mp_mulmod(B->z, mu, modulus, Bm->z);
 1ae:	9805      	ldr	r0, [sp, #20]
 1b0:	4631      	mov	r1, r6
 1b2:	f10a 03d0 	add.w	r3, sl, #208	; 0xd0
 1b6:	462a      	mov	r2, r5
 1b8:	30d0      	adds	r0, #208	; 0xd0
 1ba:	f7ff fffe 	bl	0 <mp_mulmod>
 1be:	4601      	mov	r1, r0
        mp_clear(mu);
 1c0:	4630      	mov	r0, r6
 1c2:	9105      	str	r1, [sp, #20]
 1c4:	f7ff fffe 	bl	0 <mp_clear>
 1c8:	9905      	ldr	r1, [sp, #20]
 1ca:	9105      	str	r1, [sp, #20]
    FREE_MP_INT_SIZE(mu, heap, DYNAMIC_TYPE_ECC);
 1cc:	4630      	mov	r0, r6
 1ce:	f7ff fffe 	bl	0 <free>
  if (err == MP_OKAY) {
 1d2:	9905      	ldr	r1, [sp, #20]
 1d4:	bb59      	cbnz	r1, 22e <ecc_mul2add+0x22e>
    err = ecc_projective_dbl_point_safe(precomp[1], precomp[2], a, modulus, mp);
 1d6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 1d8:	9300      	str	r3, [sp, #0]
 1da:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 1de:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 1e0:	462b      	mov	r3, r5
 1e2:	f7ff fffe 	bl	0 <ecc_mul2add>
  if (err == MP_OKAY) {
 1e6:	4601      	mov	r1, r0
 1e8:	bb08      	cbnz	r0, 22e <ecc_mul2add+0x22e>
    err = ecc_projective_add_point_safe(precomp[1], precomp[2], precomp[3],
 1ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 1ec:	9002      	str	r0, [sp, #8]
 1ee:	e9cd 5300 	strd	r5, r3, [sp]
 1f2:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 1f4:	6860      	ldr	r0, [r4, #4]
 1f6:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 1fa:	f7ff fffe 	bl	0 <ecc_mul2add>
  if (err == MP_OKAY) {
 1fe:	4601      	mov	r1, r0
 200:	b9a8      	cbnz	r0, 22e <ecc_mul2add+0x22e>
    err = ecc_projective_dbl_point_safe(precomp[4], precomp[8], a, modulus, mp);
 202:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 204:	9300      	str	r3, [sp, #0]
 206:	6a21      	ldr	r1, [r4, #32]
 208:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 20a:	6920      	ldr	r0, [r4, #16]
 20c:	462b      	mov	r3, r5
 20e:	f7ff fffe 	bl	0 <ecc_mul2add>
  if (err == MP_OKAY) {
 212:	4601      	mov	r1, r0
 214:	b958      	cbnz	r0, 22e <ecc_mul2add+0x22e>
    err = ecc_projective_add_point_safe(precomp[4], precomp[8], precomp[12], a,
 216:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 218:	9002      	str	r0, [sp, #8]
 21a:	e9cd 5300 	strd	r5, r3, [sp]
 21e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 220:	6a21      	ldr	r1, [r4, #32]
 222:	6b22      	ldr	r2, [r4, #48]	; 0x30
 224:	6920      	ldr	r0, [r4, #16]
 226:	f7ff fffe 	bl	0 <ecc_mul2add>
  if (err == MP_OKAY) {
 22a:	4601      	mov	r1, r0
 22c:	b338      	cbz	r0, 27e <ecc_mul2add+0x27e>
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 22e:	1f25      	subs	r5, r4, #4
 230:	f104 063c 	add.w	r6, r4, #60	; 0x3c
     wc_ecc_del_point_ex(precomp[x], heap);
 234:	f855 0f04 	ldr.w	r0, [r5, #4]!
 238:	9105      	str	r1, [sp, #20]
 23a:	f7ff fffe 	bl	0 <ecc_mul2add>
  for (x = 0; x < SHAMIR_PRECOMP_SZ; x++) {
 23e:	42ae      	cmp	r6, r5
 240:	9905      	ldr	r1, [sp, #20]
 242:	d1f7      	bne.n	234 <ecc_mul2add+0x234>
 244:	f209 1201 	addw	r2, r9, #257	; 0x101
 248:	464b      	mov	r3, r9
 24a:	2000      	movs	r0, #0
 24c:	4293      	cmp	r3, r2
 24e:	f040 8091 	bne.w	374 <ecc_mul2add+0x374>
 252:	9b04      	ldr	r3, [sp, #16]
 254:	2000      	movs	r0, #0
 256:	f203 1201 	addw	r2, r3, #257	; 0x101
 25a:	4293      	cmp	r3, r2
 25c:	f040 808d 	bne.w	37a <ecc_mul2add+0x37a>
  XFREE(precomp, heap, DYNAMIC_TYPE_ECC_BUFFER);
 260:	4620      	mov	r0, r4
 262:	9105      	str	r1, [sp, #20]
 264:	f7ff fffe 	bl	0 <free>
  XFREE(tB, heap, DYNAMIC_TYPE_ECC_BUFFER);
 268:	9804      	ldr	r0, [sp, #16]
 26a:	f7ff fffe 	bl	0 <free>
  XFREE(tA, heap, DYNAMIC_TYPE_ECC_BUFFER);
 26e:	4648      	mov	r0, r9
 270:	f7ff fffe 	bl	0 <free>
  return err;
 274:	9905      	ldr	r1, [sp, #20]
}
 276:	4608      	mov	r0, r1
 278:	b00d      	add	sp, #52	; 0x34
 27a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (x = 1; x < 4; x++) {
 27e:	f04f 0801 	mov.w	r8, #1
      for (y = 1; y < 4; y++) {
 282:	f104 0610 	add.w	r6, r4, #16
        if (err == MP_OKAY) {
 286:	b961      	cbnz	r1, 2a2 <ecc_mul2add+0x2a2>
          err = ecc_projective_add_point_safe(precomp[x], precomp[(y<<2)],
 288:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 28a:	9102      	str	r1, [sp, #8]
 28c:	e9cd 5300 	strd	r5, r3, [sp]
 290:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 292:	6831      	ldr	r1, [r6, #0]
 294:	f856 2028 	ldr.w	r2, [r6, r8, lsl #2]
 298:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
 29c:	f7ff fffe 	bl	0 <ecc_mul2add>
 2a0:	4601      	mov	r1, r0
      for (y = 1; y < 4; y++) {
 2a2:	9b07      	ldr	r3, [sp, #28]
 2a4:	3610      	adds	r6, #16
 2a6:	42b3      	cmp	r3, r6
 2a8:	d1ed      	bne.n	286 <ecc_mul2add+0x286>
    for (x = 1; x < 4; x++) {
 2aa:	f108 0801 	add.w	r8, r8, #1
 2ae:	f1b8 0f04 	cmp.w	r8, #4
 2b2:	d1e6      	bne.n	282 <ecc_mul2add+0x282>
  if (err == MP_OKAY) {
 2b4:	2900      	cmp	r1, #0
 2b6:	d1ba      	bne.n	22e <ecc_mul2add+0x22e>
    first   = 1;
 2b8:	2301      	movs	r3, #1
 2ba:	930a      	str	r3, [sp, #40]	; 0x28
    bitbufB = tB[0];
 2bc:	9b04      	ldr	r3, [sp, #16]
    bitbufA = tA[0];
 2be:	f899 a000 	ldrb.w	sl, [r9]
    bitbufB = tB[0];
 2c2:	781b      	ldrb	r3, [r3, #0]
 2c4:	9305      	str	r3, [sp, #20]
                    err = mp_copy(precomp[i]->y, C->y);
 2c6:	f107 0368 	add.w	r3, r7, #104	; 0x68
    for (x = 0; x < (int)len || nibble != 3; ) {
 2ca:	4688      	mov	r8, r1
    nibble  = 3;
 2cc:	f04f 0b03 	mov.w	fp, #3
                    err = mp_copy(precomp[i]->y, C->y);
 2d0:	9309      	str	r3, [sp, #36]	; 0x24
    for (x = 0; x < (int)len || nibble != 3; ) {
 2d2:	9b06      	ldr	r3, [sp, #24]
 2d4:	4543      	cmp	r3, r8
 2d6:	dc0b      	bgt.n	2f0 <ecc_mul2add+0x2f0>
 2d8:	f1bb 0f03 	cmp.w	fp, #3
 2dc:	d108      	bne.n	2f0 <ecc_mul2add+0x2f0>
  if (err == MP_OKAY)
 2de:	2900      	cmp	r1, #0
 2e0:	d1a5      	bne.n	22e <ecc_mul2add+0x22e>
    err = ecc_map(C, modulus, mp);
 2e2:	4629      	mov	r1, r5
 2e4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 2e6:	4638      	mov	r0, r7
 2e8:	f7ff fffe 	bl	0 <ecc_mul2add>
 2ec:	4601      	mov	r1, r0
 2ee:	e79e      	b.n	22e <ecc_mul2add+0x22e>
        if (++nibble == 4) {
 2f0:	f10b 0b01 	add.w	fp, fp, #1
 2f4:	f1bb 0f04 	cmp.w	fp, #4
 2f8:	d10c      	bne.n	314 <ecc_mul2add+0x314>
            if (x == (int)len) break;
 2fa:	9b06      	ldr	r3, [sp, #24]
 2fc:	4543      	cmp	r3, r8
 2fe:	d0ee      	beq.n	2de <ecc_mul2add+0x2de>
            bitbufB = tB[x];
 300:	9b04      	ldr	r3, [sp, #16]
            bitbufA = tA[x];
 302:	f819 a008 	ldrb.w	sl, [r9, r8]
            bitbufB = tB[x];
 306:	f813 3008 	ldrb.w	r3, [r3, r8]
 30a:	9305      	str	r3, [sp, #20]
            x++;
 30c:	f108 0801 	add.w	r8, r8, #1
            nibble  = 0;
 310:	f04f 0b00 	mov.w	fp, #0
        nA = (bitbufA >> 6) & 0x03;
 314:	ea4f 139a 	mov.w	r3, sl, lsr #6
 318:	9307      	str	r3, [sp, #28]
        nB = (bitbufB >> 6) & 0x03;
 31a:	9b05      	ldr	r3, [sp, #20]
        if ((nA == 0) && (nB == 0) && (first == 1)) {
 31c:	9a07      	ldr	r2, [sp, #28]
        nB = (bitbufB >> 6) & 0x03;
 31e:	099e      	lsrs	r6, r3, #6
        bitbufA = (bitbufA << 2) & 0xFF;
 320:	ea4f 038a 	mov.w	r3, sl, lsl #2
 324:	fa5f fa83 	uxtb.w	sl, r3
        bitbufB = (bitbufB << 2) & 0xFF;
 328:	9b05      	ldr	r3, [sp, #20]
 32a:	009b      	lsls	r3, r3, #2
 32c:	b2db      	uxtb	r3, r3
        if ((nA == 0) && (nB == 0) && (first == 1)) {
 32e:	4332      	orrs	r2, r6
        bitbufB = (bitbufB << 2) & 0xFF;
 330:	9305      	str	r3, [sp, #20]
        if ((nA == 0) && (nB == 0) && (first == 1)) {
 332:	9208      	str	r2, [sp, #32]
 334:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 336:	d126      	bne.n	386 <ecc_mul2add+0x386>
 338:	2b01      	cmp	r3, #1
 33a:	d0ca      	beq.n	2d2 <ecc_mul2add+0x2d2>
        if (first == 0) {
 33c:	2b00      	cmp	r3, #0
 33e:	d1c8      	bne.n	2d2 <ecc_mul2add+0x2d2>
 340:	e022      	b.n	388 <ecc_mul2add+0x388>
                if (err == MP_OKAY)
 342:	2900      	cmp	r1, #0
 344:	f47f af73 	bne.w	22e <ecc_mul2add+0x22e>
                    err = ecc_projective_add_point_safe(C, precomp[i],
 348:	ab0a      	add	r3, sp, #40	; 0x28
 34a:	9302      	str	r3, [sp, #8]
 34c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 34e:	e9cd 5300 	strd	r5, r3, [sp]
 352:	463a      	mov	r2, r7
 354:	f854 1026 	ldr.w	r1, [r4, r6, lsl #2]
 358:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 35a:	4638      	mov	r0, r7
 35c:	f7ff fffe 	bl	0 <ecc_mul2add>
                if (err != MP_OKAY)
 360:	4601      	mov	r1, r0
 362:	2800      	cmp	r0, #0
 364:	d0b5      	beq.n	2d2 <ecc_mul2add+0x2d2>
 366:	e762      	b.n	22e <ecc_mul2add+0x22e>
    err = BAD_FUNC_ARG;
 368:	f06f 01ac 	mvn.w	r1, #172	; 0xac
 36c:	e75f      	b.n	22e <ecc_mul2add+0x22e>
       err = MEMORY_E;
 36e:	f06f 017c 	mvn.w	r1, #124	; 0x7c
 372:	e75c      	b.n	22e <ecc_mul2add+0x22e>
 374:	f803 0b01 	strb.w	r0, [r3], #1
 378:	e768      	b.n	24c <ecc_mul2add+0x24c>
 37a:	f803 0b01 	strb.w	r0, [r3], #1
 37e:	e76c      	b.n	25a <ecc_mul2add+0x25a>
     return ECC_BAD_ARG_E;
 380:	f06f 01a9 	mvn.w	r1, #169	; 0xa9
 384:	e777      	b.n	276 <ecc_mul2add+0x276>
        if (first == 0) {
 386:	b9d3      	cbnz	r3, 3be <ecc_mul2add+0x3be>
            if (err == MP_OKAY)
 388:	2900      	cmp	r1, #0
 38a:	f47f af50 	bne.w	22e <ecc_mul2add+0x22e>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 38e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 390:	9300      	str	r3, [sp, #0]
 392:	4639      	mov	r1, r7
 394:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 396:	462b      	mov	r3, r5
 398:	4638      	mov	r0, r7
 39a:	f7ff fffe 	bl	0 <ecc_mul2add>
            if (err == MP_OKAY)
 39e:	4601      	mov	r1, r0
 3a0:	2800      	cmp	r0, #0
 3a2:	f47f af44 	bne.w	22e <ecc_mul2add+0x22e>
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 3a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 3a8:	9300      	str	r3, [sp, #0]
 3aa:	4639      	mov	r1, r7
 3ac:	462b      	mov	r3, r5
 3ae:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 3b0:	4638      	mov	r0, r7
 3b2:	f7ff fffe 	bl	0 <ecc_mul2add>
        if ((nA != 0) || (nB != 0)) {
 3b6:	9b08      	ldr	r3, [sp, #32]
                err = ecc_projective_dbl_point_safe(C, C, a, modulus, mp);
 3b8:	4601      	mov	r1, r0
        if ((nA != 0) || (nB != 0)) {
 3ba:	2b00      	cmp	r3, #0
 3bc:	d089      	beq.n	2d2 <ecc_mul2add+0x2d2>
            unsigned int i = nA + (nB<<2);
 3be:	9b07      	ldr	r3, [sp, #28]
 3c0:	eb03 0686 	add.w	r6, r3, r6, lsl #2
            if (first == 1) {
 3c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 3c6:	2b01      	cmp	r3, #1
 3c8:	d1bb      	bne.n	342 <ecc_mul2add+0x342>
                first = 0;
 3ca:	2300      	movs	r3, #0
 3cc:	930a      	str	r3, [sp, #40]	; 0x28
                if (err == MP_OKAY)
 3ce:	2900      	cmp	r1, #0
 3d0:	f47f af2d 	bne.w	22e <ecc_mul2add+0x22e>
                    err = mp_copy(precomp[i]->x, C->x);
 3d4:	4639      	mov	r1, r7
 3d6:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
 3da:	f7ff fffe 	bl	0 <mp_copy>
                if (err == MP_OKAY)
 3de:	4601      	mov	r1, r0
 3e0:	2800      	cmp	r0, #0
 3e2:	f47f af24 	bne.w	22e <ecc_mul2add+0x22e>
                    err = mp_copy(precomp[i]->y, C->y);
 3e6:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
 3ea:	9909      	ldr	r1, [sp, #36]	; 0x24
 3ec:	3068      	adds	r0, #104	; 0x68
 3ee:	f7ff fffe 	bl	0 <mp_copy>
                if (err == MP_OKAY)
 3f2:	4601      	mov	r1, r0
 3f4:	2800      	cmp	r0, #0
 3f6:	f47f af1a 	bne.w	22e <ecc_mul2add+0x22e>
                    err = mp_copy(precomp[i]->z, C->z);
 3fa:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
 3fe:	f107 01d0 	add.w	r1, r7, #208	; 0xd0
 402:	30d0      	adds	r0, #208	; 0xd0
 404:	f7ff fffe 	bl	0 <mp_copy>
 408:	4601      	mov	r1, r0
 40a:	e762      	b.n	2d2 <ecc_mul2add+0x2d2>

Disassembly of section .text.wc_ecc_verify_hash_ex:

00000000 <wc_ecc_verify_hash_ex>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b09f      	sub	sp, #124	; 0x7c
   6:	4681      	mov	r9, r0
   8:	9206      	str	r2, [sp, #24]
   DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
   a:	a80a      	add	r0, sp, #40	; 0x28
   c:	2228      	movs	r2, #40	; 0x28
{
   e:	468a      	mov	sl, r1
   DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
  10:	2100      	movs	r1, #0
{
  12:	4698      	mov	r8, r3
  14:	9e29      	ldr	r6, [sp, #164]	; 0xa4
   DECLARE_CURVE_SPECS(ECC_CURVE_FIELD_COUNT);
  16:	9008      	str	r0, [sp, #32]
  18:	f7ff fffe 	bl	0 <memset>
  1c:	9b08      	ldr	r3, [sp, #32]
  1e:	2205      	movs	r2, #5
  20:	61da      	str	r2, [r3, #28]
   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)
  22:	f1b9 0f00 	cmp.w	r9, #0
  26:	d105      	bne.n	34 <wc_ecc_verify_hash_ex+0x34>
       return ECC_BAD_ARG_E;
  28:	f06f 04a9 	mvn.w	r4, #169	; 0xa9
}
  2c:	4620      	mov	r0, r4
  2e:	b01f      	add	sp, #124	; 0x7c
  30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (r == NULL || s == NULL || hash == NULL || res == NULL || key == NULL)
  34:	f1ba 0f00 	cmp.w	sl, #0
  38:	d0f6      	beq.n	28 <wc_ecc_verify_hash_ex+0x28>
  3a:	9b06      	ldr	r3, [sp, #24]
  3c:	2b00      	cmp	r3, #0
  3e:	d0f3      	beq.n	28 <wc_ecc_verify_hash_ex+0x28>
  40:	9b28      	ldr	r3, [sp, #160]	; 0xa0
  42:	2b00      	cmp	r3, #0
  44:	d0f0      	beq.n	28 <wc_ecc_verify_hash_ex+0x28>
  46:	2e00      	cmp	r6, #0
  48:	d0ee      	beq.n	28 <wc_ecc_verify_hash_ex+0x28>
   *res = 0;
  4a:	2100      	movs	r1, #0
  4c:	6019      	str	r1, [r3, #0]
   if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
  4e:	6870      	ldr	r0, [r6, #4]
  50:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
  54:	2800      	cmp	r0, #0
  56:	d0e7      	beq.n	28 <wc_ecc_verify_hash_ex+0x28>
  58:	6933      	ldr	r3, [r6, #16]
  5a:	2b00      	cmp	r3, #0
  5c:	d0e4      	beq.n	28 <wc_ecc_verify_hash_ex+0x28>
    DECLARE_CURVE_SPECS(1);
  5e:	f10d 0b50 	add.w	fp, sp, #80	; 0x50
  62:	2228      	movs	r2, #40	; 0x28
  64:	4658      	mov	r0, fp
  66:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
  6a:	f7ff fffe 	bl	0 <memset>
  6e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  70:	2201      	movs	r2, #1
  72:	61da      	str	r2, [r3, #28]
    ALLOC_CURVE_SPECS(1, err);
  74:	2068      	movs	r0, #104	; 0x68
  76:	f7ff fffe 	bl	0 <malloc>
  7a:	4605      	mov	r5, r0
  7c:	b308      	cbz	r0, c2 <wc_ecc_verify_hash_ex+0xc2>
  7e:	9b09      	ldr	r3, [sp, #36]	; 0x24
        err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
  80:	2208      	movs	r2, #8
    ALLOC_CURVE_SPECS(1, err);
  82:	6198      	str	r0, [r3, #24]
        err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ORDER);
  84:	a909      	add	r1, sp, #36	; 0x24
  86:	6930      	ldr	r0, [r6, #16]
  88:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
    if (err != 0) {
  8c:	4604      	mov	r4, r0
  8e:	2800      	cmp	r0, #0
  90:	d13c      	bne.n	10c <wc_ecc_verify_hash_ex+0x10c>
    if (mp_iszero(r) || mp_iszero(s)) {
  92:	4648      	mov	r0, r9
  94:	f7ff fffe 	bl	0 <mp_iszero>
  98:	b1b0      	cbz	r0, c8 <wc_ecc_verify_hash_ex+0xc8>
        err = MP_ZERO_E;
  9a:	f06f 0478 	mvn.w	r4, #120	; 0x78
    wc_ecc_curve_free(curve);
  9e:	9809      	ldr	r0, [sp, #36]	; 0x24
  a0:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
    FREE_CURVE_SPECS();
  a4:	4628      	mov	r0, r5
  a6:	f7ff fffe 	bl	0 <free>
   if (err != MP_OKAY) {
  aa:	2c00      	cmp	r4, #0
  ac:	d1be      	bne.n	2c <wc_ecc_verify_hash_ex+0x2c>
  if (key->type == ECC_PRIVATEKEY_ONLY) {
  ae:	6833      	ldr	r3, [r6, #0]
  b0:	2b03      	cmp	r3, #3
      ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  b2:	f44f 7002 	mov.w	r0, #520	; 0x208
  if (key->type == ECC_PRIVATEKEY_ONLY) {
  b6:	d137      	bne.n	128 <wc_ecc_verify_hash_ex+0x128>
      ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  b8:	f7ff fffe 	bl	0 <malloc>
  bc:	4605      	mov	r5, r0
  be:	9005      	str	r0, [sp, #20]
  c0:	b9d8      	cbnz	r0, fa <wc_ecc_verify_hash_ex+0xfa>
    ALLOC_CURVE_SPECS(1, err);
  c2:	f06f 047c 	mvn.w	r4, #124	; 0x7c
   if (err != MP_OKAY) {
  c6:	e7b1      	b.n	2c <wc_ecc_verify_hash_ex+0x2c>
    if (mp_iszero(r) || mp_iszero(s)) {
  c8:	4650      	mov	r0, sl
  ca:	f7ff fffe 	bl	0 <mp_iszero>
  ce:	2800      	cmp	r0, #0
  d0:	d1e3      	bne.n	9a <wc_ecc_verify_hash_ex+0x9a>
    if ((err == 0) && (mp_cmp(r, curve->order) != MP_LT)) {
  d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  d4:	4648      	mov	r0, r9
  d6:	68d9      	ldr	r1, [r3, #12]
  d8:	f7ff fffe 	bl	0 <mp_cmp>
  dc:	3001      	adds	r0, #1
  de:	d109      	bne.n	f4 <wc_ecc_verify_hash_ex+0xf4>
    if ((err == 0) && (mp_cmp(s, curve->order) != MP_LT)) {
  e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
  e2:	4650      	mov	r0, sl
  e4:	68d9      	ldr	r1, [r3, #12]
  e6:	f7ff fffe 	bl	0 <mp_cmp>
  ea:	1c44      	adds	r4, r0, #1
  ec:	bf18      	it	ne
  ee:	f04f 34ff 	movne.w	r4, #4294967295	; 0xffffffff
  f2:	e7d4      	b.n	9e <wc_ecc_verify_hash_ex+0x9e>
        err = MP_VAL;
  f4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  f8:	e7d1      	b.n	9e <wc_ecc_verify_hash_ex+0x9e>
      ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  fa:	9b08      	ldr	r3, [sp, #32]
      err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
  fc:	223b      	movs	r2, #59	; 0x3b
      ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
  fe:	6198      	str	r0, [r3, #24]
      err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 100:	a908      	add	r1, sp, #32
 102:	6930      	ldr	r0, [r6, #16]
 104:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
      if (err != MP_OKAY) {
 108:	4604      	mov	r4, r0
 10a:	b108      	cbz	r0, 110 <wc_ecc_verify_hash_ex+0x110>
        FREE_CURVE_SPECS();
 10c:	4628      	mov	r0, r5
 10e:	e072      	b.n	1f6 <wc_ecc_verify_hash_ex+0x1f6>
      err = ecc_make_pub_ex(key, curve, NULL, NULL);
 110:	4603      	mov	r3, r0
 112:	4602      	mov	r2, r0
 114:	9908      	ldr	r1, [sp, #32]
 116:	4630      	mov	r0, r6
 118:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
      if (err != MP_OKAY) {
 11c:	4604      	mov	r4, r0
 11e:	b198      	cbz	r0, 148 <wc_ecc_verify_hash_ex+0x148>
           wc_ecc_curve_free(curve);
 120:	9808      	ldr	r0, [sp, #32]
 122:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
           FREE_CURVE_SPECS();
 126:	e7f1      	b.n	10c <wc_ecc_verify_hash_ex+0x10c>
       ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 128:	f7ff fffe 	bl	0 <malloc>
 12c:	4605      	mov	r5, r0
 12e:	9005      	str	r0, [sp, #20]
 130:	2800      	cmp	r0, #0
 132:	d0c6      	beq.n	c2 <wc_ecc_verify_hash_ex+0xc2>
 134:	9b08      	ldr	r3, [sp, #32]
       err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 136:	223b      	movs	r2, #59	; 0x3b
       ALLOC_CURVE_SPECS(ECC_CURVE_FIELD_COUNT, err);
 138:	6198      	str	r0, [r3, #24]
       err = wc_ecc_curve_load(key->dp, &curve, ECC_CURVE_FIELD_ALL);
 13a:	a908      	add	r1, sp, #32
 13c:	6930      	ldr	r0, [r6, #16]
 13e:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
       if (err != 0) {
 142:	4604      	mov	r4, r0
 144:	2800      	cmp	r0, #0
 146:	d1e1      	bne.n	10c <wc_ecc_verify_hash_ex+0x10c>
   ecc_point* mG = NULL;
 148:	2400      	movs	r4, #0
   NEW_MP_INT_SIZE(e_lcl, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
 14a:	2068      	movs	r0, #104	; 0x68
   err = ecc_verify_hash(r, s, hash, hashlen, res, key, curve);
 14c:	9f08      	ldr	r7, [sp, #32]
   ecc_point* mG = NULL;
 14e:	9409      	str	r4, [sp, #36]	; 0x24
   ecc_point* mQ = NULL;
 150:	9414      	str	r4, [sp, #80]	; 0x50
   NEW_MP_INT_SIZE(e_lcl, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
 152:	f7ff fffe 	bl	0 <malloc>
 156:	4605      	mov	r5, r0
 158:	b150      	cbz	r0, 170 <wc_ecc_verify_hash_ex+0x170>
 15a:	2268      	movs	r2, #104	; 0x68
 15c:	4621      	mov	r1, r4
 15e:	f7ff fffe 	bl	0 <memset>
   err = INIT_MP_INT_SIZE(e, ECC_KEY_MAX_BITS(key));
 162:	4628      	mov	r0, r5
 164:	f7ff fffe 	bl	0 <mp_init>
   if (err != MP_OKAY) {
 168:	b128      	cbz	r0, 176 <wc_ecc_verify_hash_ex+0x176>
      XFREE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 16a:	4628      	mov	r0, r5
 16c:	f7ff fffe 	bl	0 <free>
       return MEMORY_E;
 170:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 174:	e03b      	b.n	1ee <wc_ecc_verify_hash_ex+0x1ee>
       unsigned int orderBits = (unsigned int)mp_count_bits(curve->order);
 176:	68f8      	ldr	r0, [r7, #12]
 178:	f7ff fffe 	bl	0 <mp_count_bits>
       if ( (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 17c:	ebb0 0fc8 	cmp.w	r0, r8, lsl #3
           hashlen = (orderBits + WOLFSSL_BIT_SIZE - 1) / WOLFSSL_BIT_SIZE;
 180:	bf3c      	itt	cc
 182:	f100 0807 	addcc.w	r8, r0, #7
 186:	ea4f 08d8 	movcc.w	r8, r8, lsr #3
 18a:	9007      	str	r0, [sp, #28]
       err = mp_read_unsigned_bin(e, hash, hashlen);
 18c:	9906      	ldr	r1, [sp, #24]
 18e:	4642      	mov	r2, r8
 190:	4628      	mov	r0, r5
 192:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
       if (err == MP_OKAY && (WOLFSSL_BIT_SIZE * hashlen) > orderBits)
 196:	4604      	mov	r4, r0
 198:	b950      	cbnz	r0, 1b0 <wc_ecc_verify_hash_ex+0x1b0>
 19a:	9b07      	ldr	r3, [sp, #28]
 19c:	ebb3 0fc8 	cmp.w	r3, r8, lsl #3
 1a0:	d206      	bcs.n	1b0 <wc_ecc_verify_hash_ex+0x1b0>
           mp_rshb(e, (int)(WOLFSSL_BIT_SIZE - (orderBits & 0x7)));
 1a2:	f003 0107 	and.w	r1, r3, #7
 1a6:	f1c1 0108 	rsb	r1, r1, #8
 1aa:	4628      	mov	r0, r5
 1ac:	f7ff fffe 	bl	0 <mp_rshb>
   NEW_MP_INT_SIZE(w, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
 1b0:	2068      	movs	r0, #104	; 0x68
 1b2:	f7ff fffe 	bl	0 <malloc>
 1b6:	4680      	mov	r8, r0
 1b8:	b300      	cbz	r0, 1fc <wc_ecc_verify_hash_ex+0x1fc>
 1ba:	2268      	movs	r2, #104	; 0x68
 1bc:	2100      	movs	r1, #0
 1be:	f7ff fffe 	bl	0 <memset>
   if (err == MP_OKAY) {
 1c2:	b1f4      	cbz	r4, 202 <wc_ecc_verify_hash_ex+0x202>
   wc_ecc_del_point_ex(mG, key->heap);
 1c4:	9809      	ldr	r0, [sp, #36]	; 0x24
 1c6:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
   wc_ecc_del_point_ex(mQ, key->heap);
 1ca:	9814      	ldr	r0, [sp, #80]	; 0x50
 1cc:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
   mp_clear(e);
 1d0:	4628      	mov	r0, r5
 1d2:	f7ff fffe 	bl	0 <mp_clear>
   mp_clear(w);
 1d6:	4640      	mov	r0, r8
 1d8:	f7ff fffe 	bl	0 <mp_clear>
   FREE_MP_INT_SIZE(w, key->heap, DYNAMIC_TYPE_ECC);
 1dc:	f1b8 0f00 	cmp.w	r8, #0
 1e0:	d002      	beq.n	1e8 <wc_ecc_verify_hash_ex+0x1e8>
 1e2:	4640      	mov	r0, r8
 1e4:	f7ff fffe 	bl	0 <free>
   FREE_MP_INT_SIZE(e_lcl, key->heap, DYNAMIC_TYPE_ECC);
 1e8:	4628      	mov	r0, r5
 1ea:	f7ff fffe 	bl	0 <free>
   wc_ecc_curve_free(curve);
 1ee:	9808      	ldr	r0, [sp, #32]
 1f0:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
   FREE_CURVE_SPECS();
 1f4:	9805      	ldr	r0, [sp, #20]
        FREE_CURVE_SPECS();
 1f6:	f7ff fffe 	bl	0 <free>
 1fa:	e717      	b.n	2c <wc_ecc_verify_hash_ex+0x2c>
       err = MEMORY_E;
 1fc:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 200:	e7e0      	b.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = INIT_MP_INT_SIZE(w, ECC_KEY_MAX_BITS(key));
 202:	4640      	mov	r0, r8
 204:	f7ff fffe 	bl	0 <mp_init>
   if (err == MP_OKAY) {
 208:	4604      	mov	r4, r0
 20a:	2800      	cmp	r0, #0
 20c:	d1da      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = wc_ecc_new_point_ex(&mG, key->heap);
 20e:	a809      	add	r0, sp, #36	; 0x24
 210:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
   if (err == MP_OKAY) {
 214:	4604      	mov	r4, r0
 216:	2800      	cmp	r0, #0
 218:	d1d4      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = wc_ecc_new_point_ex(&mQ, key->heap);
 21a:	4658      	mov	r0, fp
 21c:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
   if (err == MP_OKAY)
 220:	4604      	mov	r4, r0
 222:	2800      	cmp	r0, #0
 224:	d1ce      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_invmod(s, curve->order, w);
 226:	68f9      	ldr	r1, [r7, #12]
 228:	4642      	mov	r2, r8
 22a:	4650      	mov	r0, sl
 22c:	f7ff fffe 	bl	0 <mp_invmod>
   if (err == MP_OKAY)
 230:	4604      	mov	r4, r0
 232:	2800      	cmp	r0, #0
 234:	d1c6      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_mulmod(e, w, curve->order, u1);
 236:	68fa      	ldr	r2, [r7, #12]
 238:	462b      	mov	r3, r5
 23a:	4641      	mov	r1, r8
 23c:	4628      	mov	r0, r5
 23e:	f7ff fffe 	bl	0 <mp_mulmod>
   if (err == MP_OKAY)
 242:	4604      	mov	r4, r0
 244:	2800      	cmp	r0, #0
 246:	d1bd      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_mulmod(r, w, curve->order, u2);
 248:	68fa      	ldr	r2, [r7, #12]
 24a:	4643      	mov	r3, r8
 24c:	4641      	mov	r1, r8
 24e:	4648      	mov	r0, r9
 250:	f7ff fffe 	bl	0 <mp_mulmod>
   if (err == MP_OKAY)
 254:	4604      	mov	r4, r0
 256:	2800      	cmp	r0, #0
 258:	d1b4      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_copy(curve->Gx, mG->x);
 25a:	9909      	ldr	r1, [sp, #36]	; 0x24
 25c:	6938      	ldr	r0, [r7, #16]
 25e:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
 262:	4604      	mov	r4, r0
 264:	2800      	cmp	r0, #0
 266:	d1ad      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_copy(curve->Gy, mG->y);
 268:	9909      	ldr	r1, [sp, #36]	; 0x24
 26a:	6978      	ldr	r0, [r7, #20]
 26c:	3168      	adds	r1, #104	; 0x68
 26e:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
 272:	4604      	mov	r4, r0
 274:	2800      	cmp	r0, #0
 276:	d1a5      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_set(mG->z, 1);
 278:	9809      	ldr	r0, [sp, #36]	; 0x24
 27a:	2101      	movs	r1, #1
 27c:	30d0      	adds	r0, #208	; 0xd0
 27e:	f7ff fffe 	bl	0 <mp_set>
   if (err == MP_OKAY)
 282:	4604      	mov	r4, r0
 284:	2800      	cmp	r0, #0
 286:	d19d      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_copy(key->pubkey.x, mQ->x);
 288:	9914      	ldr	r1, [sp, #80]	; 0x50
 28a:	f106 0018 	add.w	r0, r6, #24
 28e:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
 292:	4604      	mov	r4, r0
 294:	2800      	cmp	r0, #0
 296:	d195      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_copy(key->pubkey.y, mQ->y);
 298:	9914      	ldr	r1, [sp, #80]	; 0x50
 29a:	f106 0080 	add.w	r0, r6, #128	; 0x80
 29e:	3168      	adds	r1, #104	; 0x68
 2a0:	f7ff fffe 	bl	0 <mp_copy>
   if (err == MP_OKAY)
 2a4:	4604      	mov	r4, r0
 2a6:	2800      	cmp	r0, #0
 2a8:	d18c      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_copy(key->pubkey.z, mQ->z);
 2aa:	9914      	ldr	r1, [sp, #80]	; 0x50
 2ac:	f106 00e8 	add.w	r0, r6, #232	; 0xe8
 2b0:	31d0      	adds	r1, #208	; 0xd0
 2b2:	f7ff fffe 	bl	0 <mp_copy>
    if (err == MP_OKAY) {
 2b6:	4604      	mov	r4, r0
 2b8:	2800      	cmp	r0, #0
 2ba:	d183      	bne.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>
        err = ecc_mul2add(mG, u1, mQ, u2, mG, curve->Af, curve->prime,
 2bc:	6973      	ldr	r3, [r6, #20]
 2be:	9303      	str	r3, [sp, #12]
 2c0:	687b      	ldr	r3, [r7, #4]
 2c2:	9302      	str	r3, [sp, #8]
 2c4:	68bb      	ldr	r3, [r7, #8]
 2c6:	9809      	ldr	r0, [sp, #36]	; 0x24
 2c8:	9a14      	ldr	r2, [sp, #80]	; 0x50
 2ca:	e9cd 0300 	strd	r0, r3, [sp]
 2ce:	4629      	mov	r1, r5
 2d0:	4643      	mov	r3, r8
 2d2:	f7ff fffe 	bl	0 <wc_ecc_verify_hash_ex>
   if (err == MP_OKAY)
 2d6:	4604      	mov	r4, r0
 2d8:	2800      	cmp	r0, #0
 2da:	f47f af73 	bne.w	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       err = mp_mod(mG->x, curve->order, v);
 2de:	68f9      	ldr	r1, [r7, #12]
 2e0:	9809      	ldr	r0, [sp, #36]	; 0x24
 2e2:	4642      	mov	r2, r8
 2e4:	f7ff fffe 	bl	0 <mp_mod>
   if (err == MP_OKAY) {
 2e8:	4604      	mov	r4, r0
 2ea:	2800      	cmp	r0, #0
 2ec:	f47f af6a 	bne.w	1c4 <wc_ecc_verify_hash_ex+0x1c4>
       if (mp_cmp(v, r) == MP_EQ)
 2f0:	4649      	mov	r1, r9
 2f2:	4640      	mov	r0, r8
 2f4:	f7ff fffe 	bl	0 <mp_cmp>
 2f8:	2800      	cmp	r0, #0
 2fa:	f47f af63 	bne.w	1c4 <wc_ecc_verify_hash_ex+0x1c4>
           *res = 1;
 2fe:	9a28      	ldr	r2, [sp, #160]	; 0xa0
 300:	2301      	movs	r3, #1
 302:	6013      	str	r3, [r2, #0]
 304:	e75e      	b.n	1c4 <wc_ecc_verify_hash_ex+0x1c4>

Disassembly of section .text.wc_ecc_verify_hash:

00000000 <wc_ecc_verify_hash>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	9e0d      	ldr	r6, [sp, #52]	; 0x34
   6:	468b      	mov	fp, r1
   8:	4617      	mov	r7, r2
   a:	4699      	mov	r9, r3
    if (sig == NULL || hash == NULL || res == NULL || key == NULL) {
   c:	4680      	mov	r8, r0
   e:	2800      	cmp	r0, #0
  10:	d078      	beq.n	104 <wc_ecc_verify_hash+0x104>
  12:	2a00      	cmp	r2, #0
  14:	d076      	beq.n	104 <wc_ecc_verify_hash+0x104>
  16:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  18:	2b00      	cmp	r3, #0
  1a:	d073      	beq.n	104 <wc_ecc_verify_hash+0x104>
  1c:	2e00      	cmp	r6, #0
  1e:	d071      	beq.n	104 <wc_ecc_verify_hash+0x104>
    NEW_MP_INT_SIZE(r, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
  20:	2068      	movs	r0, #104	; 0x68
  22:	f7ff fffe 	bl	0 <malloc>
  26:	4604      	mov	r4, r0
  28:	2800      	cmp	r0, #0
  2a:	d071      	beq.n	110 <wc_ecc_verify_hash+0x110>
  2c:	2268      	movs	r2, #104	; 0x68
  2e:	2100      	movs	r1, #0
  30:	f7ff fffe 	bl	0 <memset>
    NEW_MP_INT_SIZE(s, ECC_KEY_MAX_BITS(key), key->heap, DYNAMIC_TYPE_ECC);
  34:	2068      	movs	r0, #104	; 0x68
  36:	f7ff fffe 	bl	0 <malloc>
  3a:	4605      	mov	r5, r0
  3c:	2800      	cmp	r0, #0
  3e:	d064      	beq.n	10a <wc_ecc_verify_hash+0x10a>
  40:	2268      	movs	r2, #104	; 0x68
  42:	2100      	movs	r1, #0
  44:	f7ff fffe 	bl	0 <memset>
    err = INIT_MP_INT_SIZE(r, ECC_KEY_MAX_BITS(key));
  48:	4620      	mov	r0, r4
  4a:	f7ff fffe 	bl	0 <mp_init>
    if (err != 0) {
  4e:	4682      	mov	sl, r0
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  50:	4628      	mov	r0, r5
    if (err != 0) {
  52:	f1ba 0f00 	cmp.w	sl, #0
  56:	d008      	beq.n	6a <wc_ecc_verify_hash+0x6a>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  58:	f7ff fffe 	bl	0 <free>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
  5c:	4620      	mov	r0, r4
  5e:	f7ff fffe 	bl	0 <free>
}
  62:	4650      	mov	r0, sl
  64:	b003      	add	sp, #12
  66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    err = INIT_MP_INT_SIZE(s, ECC_KEY_MAX_BITS(key));
  6a:	f7ff fffe 	bl	0 <mp_init>
    if (err != 0) {
  6e:	4682      	mov	sl, r0
  70:	b108      	cbz	r0, 76 <wc_ecc_verify_hash+0x76>
        FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  72:	4628      	mov	r0, r5
  74:	e7f0      	b.n	58 <wc_ecc_verify_hash+0x58>
    switch (key->state) {
  76:	68b3      	ldr	r3, [r6, #8]
  78:	2b07      	cmp	r3, #7
  7a:	d840      	bhi.n	fe <wc_ecc_verify_hash+0xfe>
  7c:	e8df f003 	tbb	[pc, r3]
  80:	3f3f3f04 	.word	0x3f3f3f04
  84:	3013043f 	.word	0x3013043f
            *res = 0;
  88:	9a0c      	ldr	r2, [sp, #48]	; 0x30
            key->state = ECC_STATE_VERIFY_DECODE;
  8a:	2305      	movs	r3, #5
  8c:	60b3      	str	r3, [r6, #8]
            *res = 0;
  8e:	2300      	movs	r3, #0
  90:	6013      	str	r3, [r2, #0]
            err = DecodeECC_DSA_Sig_Ex(sig, siglen, r, s, 0);
  92:	4659      	mov	r1, fp
  94:	9300      	str	r3, [sp, #0]
  96:	4622      	mov	r2, r4
  98:	462b      	mov	r3, r5
  9a:	4640      	mov	r0, r8
  9c:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig_Ex>
            if (err < 0) {
  a0:	f1b0 0a00 	subs.w	sl, r0, #0
  a4:	db21      	blt.n	ea <wc_ecc_verify_hash+0xea>
            key->state = ECC_STATE_VERIFY_DO;
  a6:	2306      	movs	r3, #6
  a8:	60b3      	str	r3, [r6, #8]
            err = wc_ecc_verify_hash_ex(r, s, hash, hashlen, res, key);
  aa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  ac:	9300      	str	r3, [sp, #0]
  ae:	463a      	mov	r2, r7
  b0:	464b      	mov	r3, r9
  b2:	4629      	mov	r1, r5
  b4:	9601      	str	r6, [sp, #4]
  b6:	4620      	mov	r0, r4
  b8:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
  bc:	4682      	mov	sl, r0
            mp_clear(r);
  be:	4620      	mov	r0, r4
  c0:	f7ff fffe 	bl	0 <mp_clear>
            mp_clear(s);
  c4:	4628      	mov	r0, r5
  c6:	f7ff fffe 	bl	0 <mp_clear>
            FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  ca:	4628      	mov	r0, r5
  cc:	f7ff fffe 	bl	0 <free>
            FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
  d0:	4620      	mov	r0, r4
  d2:	f7ff fffe 	bl	0 <free>
            if (err < 0) {
  d6:	f1ba 0f00 	cmp.w	sl, #0
  da:	db0d      	blt.n	f8 <wc_ecc_verify_hash+0xf8>
            s = NULL;
  dc:	2500      	movs	r5, #0
            r = NULL;
  de:	462c      	mov	r4, r5
            key->state = ECC_STATE_VERIFY_RES;
  e0:	2307      	movs	r3, #7
  e2:	60b3      	str	r3, [r6, #8]
            err = 0;
  e4:	f04f 0a00 	mov.w	sl, #0
    FREE_MP_INT_SIZE(s, key->heap, DYNAMIC_TYPE_ECC);
  e8:	b115      	cbz	r5, f0 <wc_ecc_verify_hash+0xf0>
  ea:	4628      	mov	r0, r5
  ec:	f7ff fffe 	bl	0 <free>
    FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
  f0:	b114      	cbz	r4, f8 <wc_ecc_verify_hash+0xf8>
  f2:	4620      	mov	r0, r4
  f4:	f7ff fffe 	bl	0 <free>
    key->state = ECC_STATE_NONE;
  f8:	2300      	movs	r3, #0
  fa:	60b3      	str	r3, [r6, #8]
    return err;
  fc:	e7b1      	b.n	62 <wc_ecc_verify_hash+0x62>
    switch (key->state) {
  fe:	f06f 0abf 	mvn.w	sl, #191	; 0xbf
 102:	e7f1      	b.n	e8 <wc_ecc_verify_hash+0xe8>
        return ECC_BAD_ARG_E;
 104:	f06f 0aa9 	mvn.w	sl, #169	; 0xa9
 108:	e7ab      	b.n	62 <wc_ecc_verify_hash+0x62>
        FREE_MP_INT_SIZE(r, key->heap, DYNAMIC_TYPE_ECC);
 10a:	4620      	mov	r0, r4
 10c:	f7ff fffe 	bl	0 <free>
        return MEMORY_E;
 110:	f06f 0a7c 	mvn.w	sl, #124	; 0x7c
 114:	e7a5      	b.n	62 <wc_ecc_verify_hash+0x62>

Disassembly of section .text.wc_ecc_import_point_der_ex:

00000000 <wc_ecc_import_point_der_ex>:
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4688      	mov	r8, r1
   6:	461d      	mov	r5, r3
    if (in == NULL || point == NULL || (curve_idx < 0) ||
   8:	4681      	mov	r9, r0
   a:	2800      	cmp	r0, #0
   c:	d05b      	beq.n	c6 <wc_ecc_import_point_der_ex+0xc6>
   e:	2b00      	cmp	r3, #0
  10:	d059      	beq.n	c6 <wc_ecc_import_point_der_ex+0xc6>
  12:	2a00      	cmp	r2, #0
  14:	db57      	blt.n	c6 <wc_ecc_import_point_der_ex+0xc6>
        (wc_ecc_is_valid_idx(curve_idx) == 0))
  16:	4610      	mov	r0, r2
  18:	f7ff fffe 	bl	0 <wc_ecc_import_point_der_ex>
    if (in == NULL || point == NULL || (curve_idx < 0) ||
  1c:	2800      	cmp	r0, #0
  1e:	d052      	beq.n	c6 <wc_ecc_import_point_der_ex+0xc6>
    if ((inLen & 1) == 0) {
  20:	f011 0f01 	tst.w	r1, #1
  24:	d04f      	beq.n	c6 <wc_ecc_import_point_der_ex+0xc6>
    mp_clear(point->x);
  26:	4618      	mov	r0, r3
    mp_clear(point->y);
  28:	f105 0768 	add.w	r7, r5, #104	; 0x68
    mp_clear(point->x);
  2c:	f7ff fffe 	bl	0 <mp_clear>
    mp_clear(point->z);
  30:	f105 06d0 	add.w	r6, r5, #208	; 0xd0
    mp_clear(point->y);
  34:	4638      	mov	r0, r7
  36:	f7ff fffe 	bl	0 <mp_clear>
    mp_clear(point->z);
  3a:	4630      	mov	r0, r6
  3c:	f7ff fffe 	bl	0 <mp_clear>
    err = mp_init_multi(point->x, point->y, point->z, NULL, NULL, NULL);
  40:	2300      	movs	r3, #0
  42:	e9cd 3300 	strd	r3, r3, [sp]
  46:	4632      	mov	r2, r6
  48:	4639      	mov	r1, r7
  4a:	4628      	mov	r0, r5
  4c:	f7ff fffe 	bl	0 <mp_init_multi>
    if (err != MP_OKAY)
  50:	4604      	mov	r4, r0
  52:	bbd8      	cbnz	r0, cc <wc_ecc_import_point_der_ex+0xcc>
    pointType = in[0];
  54:	f899 3000 	ldrb.w	r3, [r9]
    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
  58:	2b04      	cmp	r3, #4
  5a:	d005      	beq.n	68 <wc_ecc_import_point_der_ex+0x68>
  5c:	2b02      	cmp	r3, #2
  5e:	d003      	beq.n	68 <wc_ecc_import_point_der_ex+0x68>
        err = ASN_PARSE_E;
  60:	2b03      	cmp	r3, #3
  62:	bf18      	it	ne
  64:	f06f 048b 	mvnne.w	r4, #139	; 0x8b
    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
  68:	3b02      	subs	r3, #2
  6a:	2b01      	cmp	r3, #1
  6c:	d928      	bls.n	c0 <wc_ecc_import_point_der_ex+0xc0>
    if (err == MP_OKAY)
  6e:	b9d4      	cbnz	r4, a6 <wc_ecc_import_point_der_ex+0xa6>
    inLen -= 1;
  70:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
    in += 1;
  74:	f109 0901 	add.w	r9, r9, #1
    keysize = (int)(inLen>>1);
  78:	ea4f 0858 	mov.w	r8, r8, lsr #1
        err = mp_read_unsigned_bin(point->x, in, (word32)keysize);
  7c:	4642      	mov	r2, r8
  7e:	4649      	mov	r1, r9
  80:	4628      	mov	r0, r5
  82:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
    if (err == MP_OKAY) {
  86:	4604      	mov	r4, r0
  88:	b968      	cbnz	r0, a6 <wc_ecc_import_point_der_ex+0xa6>
            err = mp_read_unsigned_bin(point->y, in + keysize, (word32)keysize);
  8a:	4642      	mov	r2, r8
  8c:	eb09 0108 	add.w	r1, r9, r8
  90:	4638      	mov	r0, r7
  92:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
    if (err == MP_OKAY)
  96:	4604      	mov	r4, r0
  98:	b928      	cbnz	r0, a6 <wc_ecc_import_point_der_ex+0xa6>
        err = mp_set(point->z, 1);
  9a:	2101      	movs	r1, #1
  9c:	4630      	mov	r0, r6
  9e:	f7ff fffe 	bl	0 <mp_set>
    if (err != MP_OKAY) {
  a2:	4604      	mov	r4, r0
  a4:	b140      	cbz	r0, b8 <wc_ecc_import_point_der_ex+0xb8>
        mp_clear(point->x);
  a6:	4628      	mov	r0, r5
  a8:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(point->y);
  ac:	4638      	mov	r0, r7
  ae:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(point->z);
  b2:	4630      	mov	r0, r6
  b4:	f7ff fffe 	bl	0 <mp_clear>
}
  b8:	4620      	mov	r0, r4
  ba:	b003      	add	sp, #12
  bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        err = NOT_COMPILED_IN;
  c0:	f06f 04ad 	mvn.w	r4, #173	; 0xad
  c4:	e7ef      	b.n	a6 <wc_ecc_import_point_der_ex+0xa6>
        return ECC_BAD_ARG_E;
  c6:	f06f 04a9 	mvn.w	r4, #169	; 0xa9
  ca:	e7f5      	b.n	b8 <wc_ecc_import_point_der_ex+0xb8>
        return MEMORY_E;
  cc:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  d0:	e7f2      	b.n	b8 <wc_ecc_import_point_der_ex+0xb8>

Disassembly of section .text.wc_ecc_import_point_der:

00000000 <wc_ecc_import_point_der>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_ecc_import_point_der_ex(in, inLen, curve_idx, point, 1);
   2:	2401      	movs	r4, #1
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <wc_ecc_import_point_der>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_export_point_der:

00000000 <wc_ecc_export_point_der>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	461f      	mov	r7, r3
    if ((curve_idx < 0) || (wc_ecc_is_valid_idx(curve_idx) == 0))
   6:	1e03      	subs	r3, r0, #0
{
   8:	460d      	mov	r5, r1
   a:	4690      	mov	r8, r2
    if ((curve_idx < 0) || (wc_ecc_is_valid_idx(curve_idx) == 0))
   c:	da04      	bge.n	18 <wc_ecc_export_point_der+0x18>
        return ECC_BAD_ARG_E;
   e:	f06f 05a9 	mvn.w	r5, #169	; 0xa9
}
  12:	4628      	mov	r0, r5
  14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((curve_idx < 0) || (wc_ecc_is_valid_idx(curve_idx) == 0))
  18:	f7ff fffe 	bl	0 <wc_ecc_export_point_der>
  1c:	2800      	cmp	r0, #0
  1e:	d0f6      	beq.n	e <wc_ecc_export_point_der+0xe>
    if (point != NULL && out == NULL && outLen != NULL) {
  20:	2900      	cmp	r1, #0
  22:	d0f4      	beq.n	e <wc_ecc_export_point_der+0xe>
    numlen = (word32)ecc_sets[curve_idx].size;
  24:	2034      	movs	r0, #52	; 0x34
  26:	4358      	muls	r0, r3
  28:	4b30      	ldr	r3, [pc, #192]	; (ec <wc_ecc_export_point_der+0xec>)
  2a:	581c      	ldr	r4, [r3, r0]
    if (point != NULL && out == NULL && outLen != NULL) {
  2c:	b93a      	cbnz	r2, 3e <wc_ecc_export_point_der+0x3e>
  2e:	2f00      	cmp	r7, #0
  30:	d0ed      	beq.n	e <wc_ecc_export_point_der+0xe>
        *outLen = 1 + 2*numlen;
  32:	0064      	lsls	r4, r4, #1
  34:	3401      	adds	r4, #1
  36:	603c      	str	r4, [r7, #0]
        return LENGTH_ONLY_E;
  38:	f06f 05c9 	mvn.w	r5, #201	; 0xc9
  3c:	e7e9      	b.n	12 <wc_ecc_export_point_der+0x12>
    if (point == NULL || out == NULL || outLen == NULL)
  3e:	2f00      	cmp	r7, #0
  40:	d0e5      	beq.n	e <wc_ecc_export_point_der+0xe>
    if (*outLen < (1 + 2*numlen)) {
  42:	683b      	ldr	r3, [r7, #0]
  44:	ea4f 0944 	mov.w	r9, r4, lsl #1
  48:	f109 0901 	add.w	r9, r9, #1
  4c:	454b      	cmp	r3, r9
  4e:	d204      	bcs.n	5a <wc_ecc_export_point_der+0x5a>
        *outLen = 1 + 2*numlen;
  50:	f8c7 9000 	str.w	r9, [r7]
        return BUFFER_E;
  54:	f06f 0583 	mvn.w	r5, #131	; 0x83
  58:	e7db      	b.n	12 <wc_ecc_export_point_der+0x12>
    if (((word32)mp_unsigned_bin_size(point->x) > numlen) ||
  5a:	4608      	mov	r0, r1
  5c:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  60:	42a0      	cmp	r0, r4
  62:	d8d4      	bhi.n	e <wc_ecc_export_point_der+0xe>
        ((word32)mp_unsigned_bin_size(point->y) > numlen)) {
  64:	f105 0a68 	add.w	sl, r5, #104	; 0x68
  68:	4650      	mov	r0, sl
  6a:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
    if (((word32)mp_unsigned_bin_size(point->x) > numlen) ||
  6e:	42a0      	cmp	r0, r4
  70:	d8cd      	bhi.n	e <wc_ecc_export_point_der+0xe>
    out[0] = ECC_POINT_UNCOMP;
  72:	2304      	movs	r3, #4
  74:	f888 3000 	strb.w	r3, [r8]
    buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
  78:	f240 1001 	movw	r0, #257	; 0x101
  7c:	f7ff fffe 	bl	0 <malloc>
    if (buf == NULL)
  80:	4606      	mov	r6, r0
  82:	b380      	cbz	r0, e6 <wc_ecc_export_point_der+0xe6>
    XMEMSET(buf, 0, ECC_BUFSIZE);
  84:	f240 1201 	movw	r2, #257	; 0x101
  88:	2100      	movs	r1, #0
  8a:	f7ff fffe 	bl	0 <memset>
        (numlen - (word32)mp_unsigned_bin_size(point->x)));
  8e:	4628      	mov	r0, r5
  90:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  94:	1a21      	subs	r1, r4, r0
    ret = mp_to_unsigned_bin(point->x, buf +
  96:	4431      	add	r1, r6
  98:	4628      	mov	r0, r5
  9a:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
    if (ret != MP_OKAY)
  9e:	4605      	mov	r5, r0
  a0:	b9e8      	cbnz	r0, de <wc_ecc_export_point_der+0xde>
    XMEMCPY(out+1, buf, numlen);
  a2:	4622      	mov	r2, r4
  a4:	4631      	mov	r1, r6
  a6:	f108 0001 	add.w	r0, r8, #1
  aa:	f7ff fffe 	bl	0 <memcpy>
    XMEMSET(buf, 0, ECC_BUFSIZE);
  ae:	f240 1201 	movw	r2, #257	; 0x101
  b2:	2100      	movs	r1, #0
  b4:	4630      	mov	r0, r6
  b6:	f7ff fffe 	bl	0 <memset>
        (numlen - (word32)mp_unsigned_bin_size(point->y)));
  ba:	4650      	mov	r0, sl
  bc:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  c0:	1a21      	subs	r1, r4, r0
    ret = mp_to_unsigned_bin(point->y, buf +
  c2:	4431      	add	r1, r6
  c4:	4650      	mov	r0, sl
  c6:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
    if (ret != MP_OKAY)
  ca:	4605      	mov	r5, r0
  cc:	b938      	cbnz	r0, de <wc_ecc_export_point_der+0xde>
    XMEMCPY(out+1+numlen, buf, numlen);
  ce:	1c60      	adds	r0, r4, #1
  d0:	4622      	mov	r2, r4
  d2:	4631      	mov	r1, r6
  d4:	4440      	add	r0, r8
  d6:	f7ff fffe 	bl	0 <memcpy>
    *outLen = 1 + 2*numlen;
  da:	f8c7 9000 	str.w	r9, [r7]
    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);
  de:	4630      	mov	r0, r6
  e0:	f7ff fffe 	bl	0 <free>
    return ret;
  e4:	e795      	b.n	12 <wc_ecc_export_point_der+0x12>
        return MEMORY_E;
  e6:	f06f 057c 	mvn.w	r5, #124	; 0x7c
  ea:	e792      	b.n	12 <wc_ecc_export_point_der+0x12>
  ec:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_export_point_der_ex:

00000000 <wc_ecc_export_point_der_ex>:
{
   0:	b410      	push	{r4}
   2:	9c01      	ldr	r4, [sp, #4]
    if (compressed == 0)
   4:	b914      	cbnz	r4, c <wc_ecc_export_point_der_ex+0xc>
}
   6:	bc10      	pop	{r4}
        return wc_ecc_export_point_der(curve_idx, point, out, outLen);
   8:	f7ff bffe 	b.w	0 <wc_ecc_export_point_der_ex>
}
   c:	f06f 00ad 	mvn.w	r0, #173	; 0xad
  10:	bc10      	pop	{r4}
  12:	4770      	bx	lr

Disassembly of section .text.wc_ecc_export_x963:

00000000 <wc_ecc_export_x963>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4688      	mov	r8, r1
   6:	4616      	mov	r6, r2
   if (key != NULL && out == NULL && outLen != NULL) {
   8:	4604      	mov	r4, r0
   a:	2800      	cmp	r0, #0
   c:	d074      	beq.n	f8 <wc_ecc_export_x963+0xf8>
   e:	b979      	cbnz	r1, 30 <wc_ecc_export_x963+0x30>
  10:	2a00      	cmp	r2, #0
  12:	d071      	beq.n	f8 <wc_ecc_export_x963+0xf8>
      numlen = key->dp ? (word32)key->dp->size : MAX_ECC_BYTES;
  14:	6903      	ldr	r3, [r0, #16]
  16:	b14b      	cbz	r3, 2c <wc_ecc_export_x963+0x2c>
  18:	681b      	ldr	r3, [r3, #0]
      *outLen = 1 + 2 * numlen;
  1a:	005b      	lsls	r3, r3, #1
  1c:	3301      	adds	r3, #1
  1e:	6033      	str	r3, [r6, #0]
      return LENGTH_ONLY_E;
  20:	f06f 09c9 	mvn.w	r9, #201	; 0xc9
}
  24:	4648      	mov	r0, r9
  26:	b003      	add	sp, #12
  28:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      numlen = key->dp ? (word32)key->dp->size : MAX_ECC_BYTES;
  2c:	2320      	movs	r3, #32
  2e:	e7f4      	b.n	1a <wc_ecc_export_x963+0x1a>
   if (key == NULL || out == NULL || outLen == NULL)
  30:	2a00      	cmp	r2, #0
  32:	d061      	beq.n	f8 <wc_ecc_export_x963+0xf8>
   if (key->type == ECC_PRIVATEKEY_ONLY)
  34:	6803      	ldr	r3, [r0, #0]
  36:	2b03      	cmp	r3, #3
  38:	d05b      	beq.n	f2 <wc_ecc_export_x963+0xf2>
   if (key->type == 0 || wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL){
  3a:	2b00      	cmp	r3, #0
  3c:	d05c      	beq.n	f8 <wc_ecc_export_x963+0xf8>
  3e:	6840      	ldr	r0, [r0, #4]
  40:	f7ff fffe 	bl	0 <wc_ecc_export_x963>
  44:	2800      	cmp	r0, #0
  46:	d057      	beq.n	f8 <wc_ecc_export_x963+0xf8>
  48:	6923      	ldr	r3, [r4, #16]
  4a:	2b00      	cmp	r3, #0
  4c:	d054      	beq.n	f8 <wc_ecc_export_x963+0xf8>
   numlen = (word32)key->dp->size;
  4e:	681f      	ldr	r7, [r3, #0]
   if (*outLen < (1 + 2*numlen)) {
  50:	6813      	ldr	r3, [r2, #0]
  52:	ea4f 0a47 	mov.w	sl, r7, lsl #1
  56:	f10a 0a01 	add.w	sl, sl, #1
  5a:	4553      	cmp	r3, sl
  5c:	d204      	bcs.n	68 <wc_ecc_export_x963+0x68>
      *outLen = 1 + 2*numlen;
  5e:	f8c2 a000 	str.w	sl, [r2]
      return BUFFER_E;
  62:	f06f 0983 	mvn.w	r9, #131	; 0x83
  66:	e7dd      	b.n	24 <wc_ecc_export_x963+0x24>
   pubxlen = (word32)mp_unsigned_bin_size(key->pubkey.x);
  68:	f104 0b18 	add.w	fp, r4, #24
  6c:	4658      	mov	r0, fp
  6e:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
   pubylen = (word32)mp_unsigned_bin_size(key->pubkey.y);
  72:	3480      	adds	r4, #128	; 0x80
   pubxlen = (word32)mp_unsigned_bin_size(key->pubkey.x);
  74:	4681      	mov	r9, r0
   pubylen = (word32)mp_unsigned_bin_size(key->pubkey.y);
  76:	4620      	mov	r0, r4
  78:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
   if ((pubxlen > numlen) || (pubylen > numlen)) {
  7c:	454f      	cmp	r7, r9
   pubylen = (word32)mp_unsigned_bin_size(key->pubkey.y);
  7e:	9001      	str	r0, [sp, #4]
   if ((pubxlen > numlen) || (pubylen > numlen)) {
  80:	d3ef      	bcc.n	62 <wc_ecc_export_x963+0x62>
  82:	4287      	cmp	r7, r0
  84:	d3ed      	bcc.n	62 <wc_ecc_export_x963+0x62>
   out[0] = ECC_POINT_UNCOMP;
  86:	2304      	movs	r3, #4
  88:	f888 3000 	strb.w	r3, [r8]
   buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);
  8c:	f240 1001 	movw	r0, #257	; 0x101
  90:	f7ff fffe 	bl	0 <malloc>
   if (buf == NULL)
  94:	4605      	mov	r5, r0
  96:	b390      	cbz	r0, fe <wc_ecc_export_x963+0xfe>
   XMEMSET(buf, 0, ECC_BUFSIZE);
  98:	f240 1201 	movw	r2, #257	; 0x101
  9c:	2100      	movs	r1, #0
  9e:	f7ff fffe 	bl	0 <memset>
   ret = mp_to_unsigned_bin(key->pubkey.x, buf + (numlen - pubxlen));
  a2:	eba7 0109 	sub.w	r1, r7, r9
  a6:	4429      	add	r1, r5
  a8:	4658      	mov	r0, fp
  aa:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
   if (ret != MP_OKAY)
  ae:	4681      	mov	r9, r0
  b0:	b9d8      	cbnz	r0, ea <wc_ecc_export_x963+0xea>
   XMEMCPY(out+1, buf, numlen);
  b2:	463a      	mov	r2, r7
  b4:	4629      	mov	r1, r5
  b6:	f108 0001 	add.w	r0, r8, #1
  ba:	f7ff fffe 	bl	0 <memcpy>
   XMEMSET(buf, 0, ECC_BUFSIZE);
  be:	4649      	mov	r1, r9
  c0:	f240 1201 	movw	r2, #257	; 0x101
  c4:	4628      	mov	r0, r5
  c6:	f7ff fffe 	bl	0 <memset>
   ret = mp_to_unsigned_bin(key->pubkey.y, buf + (numlen - pubylen));
  ca:	9b01      	ldr	r3, [sp, #4]
  cc:	1af9      	subs	r1, r7, r3
  ce:	4429      	add	r1, r5
  d0:	4620      	mov	r0, r4
  d2:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
   if (ret != MP_OKAY)
  d6:	4681      	mov	r9, r0
  d8:	b938      	cbnz	r0, ea <wc_ecc_export_x963+0xea>
   XMEMCPY(out+1+numlen, buf, numlen);
  da:	1c78      	adds	r0, r7, #1
  dc:	463a      	mov	r2, r7
  de:	4629      	mov	r1, r5
  e0:	4440      	add	r0, r8
  e2:	f7ff fffe 	bl	0 <memcpy>
   *outLen = 1 + 2*numlen;
  e6:	f8c6 a000 	str.w	sl, [r6]
   XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);
  ea:	4628      	mov	r0, r5
  ec:	f7ff fffe 	bl	0 <free>
   return ret;
  f0:	e798      	b.n	24 <wc_ecc_export_x963+0x24>
       return ECC_PRIVATEONLY_E;
  f2:	f06f 09f5 	mvn.w	r9, #245	; 0xf5
  f6:	e795      	b.n	24 <wc_ecc_export_x963+0x24>
      return ECC_BAD_ARG_E;
  f8:	f06f 09a9 	mvn.w	r9, #169	; 0xa9
  fc:	e792      	b.n	24 <wc_ecc_export_x963+0x24>
      return MEMORY_E;
  fe:	f06f 097c 	mvn.w	r9, #124	; 0x7c
 102:	e78f      	b.n	24 <wc_ecc_export_x963+0x24>

Disassembly of section .text.wc_ecc_export_x963_ex:

00000000 <wc_ecc_export_x963_ex>:
    if (compressed == 0)
   0:	b90b      	cbnz	r3, 6 <wc_ecc_export_x963_ex+0x6>
        return wc_ecc_export_x963(key, out, outLen);
   2:	f7ff bffe 	b.w	0 <wc_ecc_export_x963_ex>
}
   6:	f06f 00ad 	mvn.w	r0, #173	; 0xad
   a:	4770      	bx	lr

Disassembly of section .text.wc_ecc_is_point:

00000000 <wc_ecc_is_point>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4616      	mov	r6, r2
   4:	461d      	mov	r5, r3
    if ((ecp == NULL) || (a == NULL) || (b == NULL) || (prime == NULL)) {
   6:	4604      	mov	r4, r0
   8:	b348      	cbz	r0, 5e <wc_ecc_is_point+0x5e>
   a:	b341      	cbz	r1, 5e <wc_ecc_is_point+0x5e>
   c:	b33a      	cbz	r2, 5e <wc_ecc_is_point+0x5e>
   e:	b333      	cbz	r3, 5e <wc_ecc_is_point+0x5e>
        if ((mp_cmp(ecp->x, prime) != MP_LT) || mp_isneg(ecp->x)) {
  10:	4619      	mov	r1, r3
  12:	f7ff fffe 	bl	0 <mp_cmp>
  16:	3001      	adds	r0, #1
  18:	d002      	beq.n	20 <wc_ecc_is_point+0x20>
            err = ECC_OUT_OF_RANGE_E;
  1a:	f06f 00d8 	mvn.w	r0, #216	; 0xd8
}
  1e:	bd70      	pop	{r4, r5, r6, pc}
        if ((mp_cmp(ecp->x, prime) != MP_LT) || mp_isneg(ecp->x)) {
  20:	6863      	ldr	r3, [r4, #4]
  22:	2b00      	cmp	r3, #0
  24:	d1f9      	bne.n	1a <wc_ecc_is_point+0x1a>
        if ((mp_cmp(ecp->y, prime) != MP_LT) || mp_isneg(ecp->y)) {
  26:	4629      	mov	r1, r5
  28:	f104 0068 	add.w	r0, r4, #104	; 0x68
  2c:	f7ff fffe 	bl	0 <mp_cmp>
  30:	3001      	adds	r0, #1
  32:	d1f2      	bne.n	1a <wc_ecc_is_point+0x1a>
  34:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
  36:	2b00      	cmp	r3, #0
  38:	d1ef      	bne.n	1a <wc_ecc_is_point+0x1a>
        if (!mp_isone(ecp->z)) {
  3a:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
  3e:	2b01      	cmp	r3, #1
  40:	d110      	bne.n	64 <wc_ecc_is_point+0x64>
  42:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
  46:	2b01      	cmp	r3, #1
  48:	d10c      	bne.n	64 <wc_ecc_is_point+0x64>
  4a:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
  4e:	b94b      	cbnz	r3, 64 <wc_ecc_is_point+0x64>
        err = _ecc_is_point(ecp, a, b, prime);
  50:	462a      	mov	r2, r5
  52:	4631      	mov	r1, r6
  54:	4620      	mov	r0, r4
}
  56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        err = _ecc_is_point(ecp, a, b, prime);
  5a:	f7ff bffe 	b.w	0 <wc_ecc_is_point>
  5e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  62:	e7dc      	b.n	1e <wc_ecc_is_point+0x1e>
            err = ECC_BAD_ARG_E;
  64:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
    return err;
  68:	e7d9      	b.n	1e <wc_ecc_is_point+0x1e>

Disassembly of section .text.wc_ecc_check_key:

00000000 <wc_ecc_check_key>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b093      	sub	sp, #76	; 0x4c
        DECLARE_CURVE_SPECS(3);
   6:	2228      	movs	r2, #40	; 0x28
{
   8:	4604      	mov	r4, r0
        DECLARE_CURVE_SPECS(3);
   a:	2100      	movs	r1, #0
   c:	a808      	add	r0, sp, #32
   e:	9006      	str	r0, [sp, #24]
  10:	f7ff fffe 	bl	0 <memset>
  14:	9b06      	ldr	r3, [sp, #24]
  16:	2203      	movs	r2, #3
  18:	61da      	str	r2, [r3, #28]
    if (key == NULL)
  1a:	2c00      	cmp	r4, #0
  1c:	f000 80d3 	beq.w	1c6 <wc_ecc_check_key+0x1c6>
        ALLOC_CURVE_SPECS(3, err);
  20:	f44f 709c 	mov.w	r0, #312	; 0x138
  24:	f7ff fffe 	bl	0 <malloc>
  28:	4605      	mov	r5, r0
  2a:	b178      	cbz	r0, 4c <wc_ecc_check_key+0x4c>
  2c:	9b06      	ldr	r3, [sp, #24]
    int err = MP_OKAY;
  2e:	f04f 0a00 	mov.w	sl, #0
        ALLOC_CURVE_SPECS(3, err);
  32:	6198      	str	r0, [r3, #24]
            b = (mp_int*)XMALLOC(sizeof(mp_int), key->heap, DYNAMIC_TYPE_ECC);
  34:	2068      	movs	r0, #104	; 0x68
  36:	f7ff fffe 	bl	0 <malloc>
            if (b == NULL) {
  3a:	4606      	mov	r6, r0
  3c:	b948      	cbnz	r0, 52 <wc_ecc_check_key+0x52>
                FREE_CURVE_SPECS();
  3e:	b115      	cbz	r5, 46 <wc_ecc_check_key+0x46>
  40:	4628      	mov	r0, r5
  42:	f7ff fffe 	bl	0 <free>
                return MEMORY_E;
  46:	f06f 0a7c 	mvn.w	sl, #124	; 0x7c
  4a:	e043      	b.n	d4 <wc_ecc_check_key+0xd4>
        ALLOC_CURVE_SPECS(3, err);
  4c:	f06f 0a7c 	mvn.w	sl, #124	; 0x7c
  50:	e7f0      	b.n	34 <wc_ecc_check_key+0x34>
        XMEMSET(b, 0, sizeof(mp_int));
  52:	2268      	movs	r2, #104	; 0x68
  54:	2100      	movs	r1, #0
    if (wc_ecc_point_is_at_infinity(&key->pubkey)) {
  56:	f104 0718 	add.w	r7, r4, #24
        XMEMSET(b, 0, sizeof(mp_int));
  5a:	f7ff fffe 	bl	0 <memset>
    if (wc_ecc_point_is_at_infinity(&key->pubkey)) {
  5e:	4638      	mov	r0, r7
  60:	f7ff fffe 	bl	0 <wc_ecc_check_key>
  64:	b148      	cbz	r0, 7a <wc_ecc_check_key+0x7a>
        XFREE(b, key->heap, DYNAMIC_TYPE_ECC);
  66:	4630      	mov	r0, r6
  68:	f7ff fffe 	bl	0 <free>
        FREE_CURVE_SPECS();
  6c:	b115      	cbz	r5, 74 <wc_ecc_check_key+0x74>
  6e:	4628      	mov	r0, r5
  70:	f7ff fffe 	bl	0 <free>
        return ECC_INF_E;
  74:	f06f 0ad6 	mvn.w	sl, #214	; 0xd6
    return ret;
  78:	e02c      	b.n	d4 <wc_ecc_check_key+0xd4>
    if (err == MP_OKAY)
  7a:	f1ba 0f00 	cmp.w	sl, #0
  7e:	d11c      	bne.n	ba <wc_ecc_check_key+0xba>
        err = wc_ecc_curve_load(key->dp, &curve, (ECC_CURVE_FIELD_PRIME |
  80:	6920      	ldr	r0, [r4, #16]
  82:	220b      	movs	r2, #11
  84:	a906      	add	r1, sp, #24
  86:	f7ff fffe 	bl	0 <wc_ecc_check_key>
    if (err == MP_OKAY)
  8a:	4682      	mov	sl, r0
  8c:	b9a8      	cbnz	r0, ba <wc_ecc_check_key+0xba>
        err = mp_init(b);
  8e:	4630      	mov	r0, r6
  90:	f7ff fffe 	bl	0 <mp_init>
    if (err == MP_OKAY)
  94:	4682      	mov	sl, r0
  96:	b980      	cbnz	r0, ba <wc_ecc_check_key+0xba>
        err = mp_read_radix(b, key->dp->Bf, MP_RADIX_HEX);
  98:	6923      	ldr	r3, [r4, #16]
  9a:	2210      	movs	r2, #16
  9c:	6959      	ldr	r1, [r3, #20]
  9e:	4630      	mov	r0, r6
  a0:	f7ff fffe 	bl	0 <mp_read_radix>
    if (err == MP_OKAY) {
  a4:	4682      	mov	sl, r0
  a6:	b940      	cbnz	r0, ba <wc_ecc_check_key+0xba>
        if ((mp_cmp(key->pubkey.x, curve->prime) != MP_LT) ||
  a8:	9b06      	ldr	r3, [sp, #24]
  aa:	4638      	mov	r0, r7
  ac:	6859      	ldr	r1, [r3, #4]
  ae:	f7ff fffe 	bl	0 <mp_cmp>
  b2:	3001      	adds	r0, #1
  b4:	d012      	beq.n	dc <wc_ecc_check_key+0xdc>
            err = ECC_OUT_OF_RANGE_E;
  b6:	f06f 0ad8 	mvn.w	sl, #216	; 0xd8
    wc_ecc_curve_free(curve);
  ba:	9806      	ldr	r0, [sp, #24]
  bc:	f7ff fffe 	bl	0 <wc_ecc_check_key>
    mp_clear(b);
  c0:	4630      	mov	r0, r6
  c2:	f7ff fffe 	bl	0 <mp_clear>
        XFREE(b, key->heap, DYNAMIC_TYPE_ECC);
  c6:	4630      	mov	r0, r6
  c8:	f7ff fffe 	bl	0 <free>
    FREE_CURVE_SPECS();
  cc:	b115      	cbz	r5, d4 <wc_ecc_check_key+0xd4>
  ce:	4628      	mov	r0, r5
  d0:	f7ff fffe 	bl	0 <free>
}
  d4:	4650      	mov	r0, sl
  d6:	b013      	add	sp, #76	; 0x4c
  d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((mp_cmp(key->pubkey.x, curve->prime) != MP_LT) ||
  dc:	69e2      	ldr	r2, [r4, #28]
        if ((mp_cmp(key->pubkey.y, curve->prime) != MP_LT) ||
  de:	9b06      	ldr	r3, [sp, #24]
        if ((mp_cmp(key->pubkey.x, curve->prime) != MP_LT) ||
  e0:	2a00      	cmp	r2, #0
  e2:	d1e8      	bne.n	b6 <wc_ecc_check_key+0xb6>
        if ((mp_cmp(key->pubkey.y, curve->prime) != MP_LT) ||
  e4:	f104 0980 	add.w	r9, r4, #128	; 0x80
  e8:	6859      	ldr	r1, [r3, #4]
  ea:	4648      	mov	r0, r9
  ec:	f7ff fffe 	bl	0 <mp_cmp>
  f0:	3001      	adds	r0, #1
  f2:	d1e0      	bne.n	b6 <wc_ecc_check_key+0xb6>
  f4:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
        err = _ecc_is_point(&key->pubkey, curve->Af, b, curve->prime);
  f8:	9b06      	ldr	r3, [sp, #24]
        if ((mp_cmp(key->pubkey.y, curve->prime) != MP_LT) ||
  fa:	2a00      	cmp	r2, #0
  fc:	d1db      	bne.n	b6 <wc_ecc_check_key+0xb6>
        err = _ecc_is_point(&key->pubkey, curve->Af, b, curve->prime);
  fe:	685a      	ldr	r2, [r3, #4]
 100:	4631      	mov	r1, r6
 102:	4638      	mov	r0, r7
 104:	f7ff fffe 	bl	0 <wc_ecc_check_key>
        if (err == MP_OKAY)
 108:	4682      	mov	sl, r0
 10a:	2800      	cmp	r0, #0
 10c:	d1d5      	bne.n	ba <wc_ecc_check_key+0xba>
            err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af,
 10e:	9a06      	ldr	r2, [sp, #24]
    ecc_point* inf = NULL;
 110:	9007      	str	r0, [sp, #28]
            err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af,
 112:	68d3      	ldr	r3, [r2, #12]
 114:	9305      	str	r3, [sp, #20]
   if (mp_count_bits(pubkey->x) > mp_count_bits(prime) ||
 116:	4638      	mov	r0, r7
            err = ecc_check_pubkey_order(key, &key->pubkey, curve->Af,
 118:	e9d2 8b01 	ldrd	r8, fp, [r2, #4]
   if (mp_count_bits(pubkey->x) > mp_count_bits(prime) ||
 11c:	f7ff fffe 	bl	0 <mp_count_bits>
 120:	4682      	mov	sl, r0
 122:	4640      	mov	r0, r8
 124:	f7ff fffe 	bl	0 <mp_count_bits>
 128:	4582      	cmp	sl, r0
 12a:	dd02      	ble.n	132 <wc_ecc_check_key+0x132>
       return IS_POINT_E;
 12c:	f06f 0ad5 	mvn.w	sl, #213	; 0xd5
 130:	e7c3      	b.n	ba <wc_ecc_check_key+0xba>
       mp_count_bits(pubkey->y) > mp_count_bits(prime) ||
 132:	4648      	mov	r0, r9
 134:	f7ff fffe 	bl	0 <mp_count_bits>
 138:	4681      	mov	r9, r0
 13a:	4640      	mov	r0, r8
 13c:	f7ff fffe 	bl	0 <mp_count_bits>
   if (mp_count_bits(pubkey->x) > mp_count_bits(prime) ||
 140:	4581      	cmp	r9, r0
 142:	dcf3      	bgt.n	12c <wc_ecc_check_key+0x12c>
       mp_count_bits(pubkey->z) > mp_count_bits(prime)) {
 144:	f104 00e8 	add.w	r0, r4, #232	; 0xe8
 148:	f7ff fffe 	bl	0 <mp_count_bits>
 14c:	4681      	mov	r9, r0
 14e:	4640      	mov	r0, r8
 150:	f7ff fffe 	bl	0 <mp_count_bits>
       mp_count_bits(pubkey->y) > mp_count_bits(prime) ||
 154:	4581      	cmp	r9, r0
 156:	dce9      	bgt.n	12c <wc_ecc_check_key+0x12c>
    err = wc_ecc_new_point_ex(&inf, key->heap);
 158:	a807      	add	r0, sp, #28
 15a:	f7ff fffe 	bl	0 <wc_ecc_check_key>
    if (err == MP_OKAY) {
 15e:	4682      	mov	sl, r0
 160:	b998      	cbnz	r0, 18a <wc_ecc_check_key+0x18a>
            err = wc_ecc_mulmod_ex(order, pubkey, inf, a, prime, 1, key->heap);
 162:	6963      	ldr	r3, [r4, #20]
 164:	9302      	str	r3, [sp, #8]
 166:	2301      	movs	r3, #1
 168:	e9cd 8300 	strd	r8, r3, [sp]
 16c:	9a07      	ldr	r2, [sp, #28]
 16e:	9805      	ldr	r0, [sp, #20]
 170:	465b      	mov	r3, fp
 172:	4639      	mov	r1, r7
 174:	f7ff fffe 	bl	0 <wc_ecc_check_key>
        if (err == MP_OKAY && !wc_ecc_point_is_at_infinity(inf))
 178:	4682      	mov	sl, r0
 17a:	b930      	cbnz	r0, 18a <wc_ecc_check_key+0x18a>
 17c:	9807      	ldr	r0, [sp, #28]
 17e:	f7ff fffe 	bl	0 <wc_ecc_check_key>
            err = ECC_INF_E;
 182:	2800      	cmp	r0, #0
 184:	bf08      	it	eq
 186:	f06f 0ad6 	mvneq.w	sl, #214	; 0xd6
    wc_ecc_del_point_ex(inf, key->heap);
 18a:	9807      	ldr	r0, [sp, #28]
 18c:	f7ff fffe 	bl	0 <wc_ecc_check_key>
        if ((err == MP_OKAY) && (key->type == ECC_PRIVATEKEY) &&
 190:	f1ba 0f00 	cmp.w	sl, #0
 194:	d191      	bne.n	ba <wc_ecc_check_key+0xba>
 196:	6822      	ldr	r2, [r4, #0]
 198:	2a02      	cmp	r2, #2
 19a:	d18e      	bne.n	ba <wc_ecc_check_key+0xba>
            (mp_iszero(key->k) || mp_isneg(key->k) ||
 19c:	f504 77a8 	add.w	r7, r4, #336	; 0x150
 1a0:	4638      	mov	r0, r7
 1a2:	f7ff fffe 	bl	0 <mp_iszero>
        if ((err == MP_OKAY) && (key->type == ECC_PRIVATEKEY) &&
 1a6:	b110      	cbz	r0, 1ae <wc_ecc_check_key+0x1ae>
            err = ECC_PRIV_KEY_E;
 1a8:	f06f 0ad7 	mvn.w	sl, #215	; 0xd7
 1ac:	e785      	b.n	ba <wc_ecc_check_key+0xba>
            (mp_iszero(key->k) || mp_isneg(key->k) ||
 1ae:	f8d4 2154 	ldr.w	r2, [r4, #340]	; 0x154
 1b2:	2a00      	cmp	r2, #0
 1b4:	d1f8      	bne.n	1a8 <wc_ecc_check_key+0x1a8>
            (mp_cmp(key->k, curve->order) != MP_LT))
 1b6:	9a06      	ldr	r2, [sp, #24]
 1b8:	4638      	mov	r0, r7
 1ba:	68d1      	ldr	r1, [r2, #12]
 1bc:	f7ff fffe 	bl	0 <mp_cmp>
            (mp_iszero(key->k) || mp_isneg(key->k) ||
 1c0:	3001      	adds	r0, #1
 1c2:	d1f1      	bne.n	1a8 <wc_ecc_check_key+0x1a8>
 1c4:	e779      	b.n	ba <wc_ecc_check_key+0xba>
        return BAD_FUNC_ARG;
 1c6:	f06f 0aac 	mvn.w	sl, #172	; 0xac
 1ca:	e783      	b.n	d4 <wc_ecc_check_key+0xd4>

Disassembly of section .text.wc_ecc_import_x963_ex:

00000000 <wc_ecc_import_x963_ex>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	460c      	mov	r4, r1
   6:	b085      	sub	sp, #20
   8:	4615      	mov	r5, r2
   a:	469a      	mov	sl, r3
    if (in == NULL || key == NULL)
   c:	4606      	mov	r6, r0
   e:	2800      	cmp	r0, #0
  10:	d05c      	beq.n	cc <wc_ecc_import_x963_ex+0xcc>
  12:	2a00      	cmp	r2, #0
  14:	d05a      	beq.n	cc <wc_ecc_import_x963_ex+0xcc>
    if ((inLen & 1) == 0) {
  16:	07cb      	lsls	r3, r1, #31
  18:	d55b      	bpl.n	d2 <wc_ecc_import_x963_ex+0xd2>
    key->state = ECC_STATE_NONE;
  1a:	2300      	movs	r3, #0
        err = mp_init_multi(key->k,
  1c:	f502 7ba8 	add.w	fp, r2, #336	; 0x150
                    key->pubkey.x, key->pubkey.y, key->pubkey.z, NULL, NULL);
  20:	f102 0918 	add.w	r9, r2, #24
  24:	f102 07e8 	add.w	r7, r2, #232	; 0xe8
  28:	f102 0880 	add.w	r8, r2, #128	; 0x80
    key->state = ECC_STATE_NONE;
  2c:	6093      	str	r3, [r2, #8]
        err = mp_init_multi(key->k,
  2e:	4649      	mov	r1, r9
  30:	e9cd 3300 	strd	r3, r3, [sp]
  34:	4642      	mov	r2, r8
  36:	463b      	mov	r3, r7
  38:	4658      	mov	r0, fp
  3a:	f7ff fffe 	bl	0 <mp_init_multi>
    if (err != MP_OKAY)
  3e:	4603      	mov	r3, r0
  40:	2800      	cmp	r0, #0
  42:	d149      	bne.n	d8 <wc_ecc_import_x963_ex+0xd8>
    pointType = in[0];
  44:	7832      	ldrb	r2, [r6, #0]
    if (pointType != ECC_POINT_UNCOMP && pointType != ECC_POINT_COMP_EVEN &&
  46:	2a04      	cmp	r2, #4
  48:	d005      	beq.n	56 <wc_ecc_import_x963_ex+0x56>
  4a:	2a02      	cmp	r2, #2
  4c:	d003      	beq.n	56 <wc_ecc_import_x963_ex+0x56>
        err = ASN_PARSE_E;
  4e:	2a03      	cmp	r2, #3
  50:	bf18      	it	ne
  52:	f06f 038b 	mvnne.w	r3, #139	; 0x8b
    if (pointType == ECC_POINT_COMP_EVEN || pointType == ECC_POINT_COMP_ODD) {
  56:	3a02      	subs	r2, #2
  58:	2a01      	cmp	r2, #1
  5a:	d934      	bls.n	c6 <wc_ecc_import_x963_ex+0xc6>
    if (err == MP_OKAY) {
  5c:	bb0b      	cbnz	r3, a2 <wc_ecc_import_x963_ex+0xa2>
    inLen -= 1;
  5e:	3c01      	subs	r4, #1
        keysize = (int)(inLen>>1);
  60:	0864      	lsrs	r4, r4, #1
        err = wc_ecc_set_curve(key, keysize, curve_id);
  62:	4652      	mov	r2, sl
  64:	4621      	mov	r1, r4
  66:	4628      	mov	r0, r5
  68:	f7ff fffe 	bl	0 <wc_ecc_import_x963_ex>
        key->type = ECC_PUBLICKEY;
  6c:	f04f 0a01 	mov.w	sl, #1
  70:	f8c5 a000 	str.w	sl, [r5]
    if (err == MP_OKAY)
  74:	4603      	mov	r3, r0
  76:	b9a0      	cbnz	r0, a2 <wc_ecc_import_x963_ex+0xa2>
    in += 1;
  78:	4456      	add	r6, sl
        err = mp_read_unsigned_bin(key->pubkey.x, in, (word32)keysize);
  7a:	4622      	mov	r2, r4
  7c:	4631      	mov	r1, r6
  7e:	4648      	mov	r0, r9
  80:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
    if (err == MP_OKAY) {
  84:	4603      	mov	r3, r0
  86:	b960      	cbnz	r0, a2 <wc_ecc_import_x963_ex+0xa2>
            err = mp_read_unsigned_bin(key->pubkey.y, in + keysize,
  88:	4622      	mov	r2, r4
  8a:	1931      	adds	r1, r6, r4
  8c:	4640      	mov	r0, r8
  8e:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
    if (err == MP_OKAY)
  92:	4603      	mov	r3, r0
  94:	b928      	cbnz	r0, a2 <wc_ecc_import_x963_ex+0xa2>
        err = mp_set(key->pubkey.z, 1);
  96:	4651      	mov	r1, sl
  98:	4638      	mov	r0, r7
  9a:	f7ff fffe 	bl	0 <mp_set>
    if (err != MP_OKAY) {
  9e:	4603      	mov	r3, r0
  a0:	b168      	cbz	r0, be <wc_ecc_import_x963_ex+0xbe>
        mp_clear(key->pubkey.x);
  a2:	4648      	mov	r0, r9
  a4:	9303      	str	r3, [sp, #12]
  a6:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(key->pubkey.y);
  aa:	4640      	mov	r0, r8
  ac:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(key->pubkey.z);
  b0:	4638      	mov	r0, r7
  b2:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(key->k);
  b6:	4658      	mov	r0, fp
  b8:	f7ff fffe 	bl	0 <mp_clear>
  bc:	9b03      	ldr	r3, [sp, #12]
}
  be:	4618      	mov	r0, r3
  c0:	b005      	add	sp, #20
  c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        err = NOT_COMPILED_IN;
  c6:	f06f 03ad 	mvn.w	r3, #173	; 0xad
  ca:	e7ea      	b.n	a2 <wc_ecc_import_x963_ex+0xa2>
        return BAD_FUNC_ARG;
  cc:	f06f 03ac 	mvn.w	r3, #172	; 0xac
  d0:	e7f5      	b.n	be <wc_ecc_import_x963_ex+0xbe>
        return ECC_BAD_ARG_E;
  d2:	f06f 03a9 	mvn.w	r3, #169	; 0xa9
  d6:	e7f2      	b.n	be <wc_ecc_import_x963_ex+0xbe>
        return MEMORY_E;
  d8:	f06f 037c 	mvn.w	r3, #124	; 0x7c
  dc:	e7ef      	b.n	be <wc_ecc_import_x963_ex+0xbe>

Disassembly of section .text.wc_ecc_import_x963:

00000000 <wc_ecc_import_x963>:
    return wc_ecc_import_x963_ex(in, inLen, key, ECC_CURVE_DEF);
   0:	2300      	movs	r3, #0
   2:	f7ff bffe 	b.w	0 <wc_ecc_import_x963>

Disassembly of section .text.wc_ecc_export_ex:

00000000 <wc_ecc_export_ex>:
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	460e      	mov	r6, r1
   6:	4617      	mov	r7, r2
   8:	e9dd 910a 	ldrd	r9, r1, [sp, #40]	; 0x28
   c:	e9dd 280c 	ldrd	r2, r8, [sp, #48]	; 0x30
  10:	461d      	mov	r5, r3
    if (key == NULL) {
  12:	4604      	mov	r4, r0
  14:	b920      	cbnz	r0, 20 <wc_ecc_export_ex+0x20>
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  1a:	b002      	add	sp, #8
  1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (wc_ecc_is_valid_idx(key->idx) == 0 || key->dp == NULL) {
  20:	6840      	ldr	r0, [r0, #4]
  22:	f7ff fffe 	bl	0 <wc_ecc_export_ex>
  26:	2800      	cmp	r0, #0
  28:	d03c      	beq.n	a4 <wc_ecc_export_ex+0xa4>
  2a:	6923      	ldr	r3, [r4, #16]
  2c:	2b00      	cmp	r3, #0
  2e:	d039      	beq.n	a4 <wc_ecc_export_ex+0xa4>
    keySz = (word32)key->dp->size;
  30:	f8d3 a000 	ldr.w	sl, [r3]
    if (d != NULL) {
  34:	b919      	cbnz	r1, 3e <wc_ecc_export_ex+0x3e>
    if (qx != NULL) {
  36:	b996      	cbnz	r6, 5e <wc_ecc_export_ex+0x5e>
    if (qy != NULL) {
  38:	bb15      	cbnz	r5, 80 <wc_ecc_export_ex+0x80>
  3a:	4628      	mov	r0, r5
  3c:	e7ed      	b.n	1a <wc_ecc_export_ex+0x1a>
        if (dLen == NULL ||
  3e:	2a00      	cmp	r2, #0
  40:	d0e9      	beq.n	16 <wc_ecc_export_ex+0x16>
            (key->type != ECC_PRIVATEKEY && key->type != ECC_PRIVATEKEY_ONLY))
  42:	6823      	ldr	r3, [r4, #0]
  44:	3b02      	subs	r3, #2
        if (dLen == NULL ||
  46:	2b01      	cmp	r3, #1
  48:	d8e5      	bhi.n	16 <wc_ecc_export_ex+0x16>
            err = wc_export_int(key->k, d, dLen, keySz, encType);
  4a:	f8cd 8000 	str.w	r8, [sp]
  4e:	4653      	mov	r3, sl
  50:	f504 70a8 	add.w	r0, r4, #336	; 0x150
  54:	f7ff fffe 	bl	0 <wc_export_int>
            if (err != MP_OKAY)
  58:	2800      	cmp	r0, #0
  5a:	d0ec      	beq.n	36 <wc_ecc_export_ex+0x36>
  5c:	e7dd      	b.n	1a <wc_ecc_export_ex+0x1a>
        if (qxLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)
  5e:	2f00      	cmp	r7, #0
  60:	d0d9      	beq.n	16 <wc_ecc_export_ex+0x16>
  62:	6823      	ldr	r3, [r4, #0]
  64:	2b03      	cmp	r3, #3
  66:	d0d6      	beq.n	16 <wc_ecc_export_ex+0x16>
        err = wc_export_int(key->pubkey.x, qx, qxLen, keySz, encType);
  68:	f8cd 8000 	str.w	r8, [sp]
  6c:	4653      	mov	r3, sl
  6e:	463a      	mov	r2, r7
  70:	4631      	mov	r1, r6
  72:	f104 0018 	add.w	r0, r4, #24
  76:	f7ff fffe 	bl	0 <wc_export_int>
        if (err != MP_OKAY)
  7a:	2800      	cmp	r0, #0
  7c:	d0dc      	beq.n	38 <wc_ecc_export_ex+0x38>
  7e:	e7cc      	b.n	1a <wc_ecc_export_ex+0x1a>
        if (qyLen == NULL || key->type == ECC_PRIVATEKEY_ONLY)
  80:	f1b9 0f00 	cmp.w	r9, #0
  84:	d0c7      	beq.n	16 <wc_ecc_export_ex+0x16>
  86:	6823      	ldr	r3, [r4, #0]
  88:	2b03      	cmp	r3, #3
  8a:	d0c4      	beq.n	16 <wc_ecc_export_ex+0x16>
        err = wc_export_int(key->pubkey.y, qy, qyLen, keySz, encType);
  8c:	4653      	mov	r3, sl
  8e:	464a      	mov	r2, r9
  90:	4629      	mov	r1, r5
  92:	f104 0080 	add.w	r0, r4, #128	; 0x80
  96:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
}
  9a:	b002      	add	sp, #8
  9c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        err = wc_export_int(key->pubkey.y, qy, qyLen, keySz, encType);
  a0:	f7ff bffe 	b.w	0 <wc_export_int>
        return ECC_BAD_ARG_E;
  a4:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  a8:	e7b7      	b.n	1a <wc_ecc_export_ex+0x1a>

Disassembly of section .text.wc_ecc_export_private_only:

00000000 <wc_ecc_export_private_only>:
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (out == NULL || outLen == NULL) {
   2:	b169      	cbz	r1, 20 <wc_ecc_export_private_only+0x20>
   4:	b162      	cbz	r2, 20 <wc_ecc_export_private_only+0x20>
    return wc_ecc_export_ex(key, NULL, NULL, NULL, NULL, out, outLen,
   6:	2302      	movs	r3, #2
   8:	e9cd 2302 	strd	r2, r3, [sp, #8]
   c:	2300      	movs	r3, #0
   e:	9101      	str	r1, [sp, #4]
  10:	9300      	str	r3, [sp, #0]
  12:	461a      	mov	r2, r3
  14:	4619      	mov	r1, r3
  16:	f7ff fffe 	bl	0 <wc_ecc_export_private_only>
}
  1a:	b005      	add	sp, #20
  1c:	f85d fb04 	ldr.w	pc, [sp], #4
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  24:	e7f9      	b.n	1a <wc_ecc_export_private_only+0x1a>

Disassembly of section .text.wc_ecc_export_public_raw:

00000000 <wc_ecc_export_public_raw>:
{
   0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
   2:	9e08      	ldr	r6, [sp, #32]
    if (qx == NULL || qxLen == NULL || qy == NULL || qyLen == NULL) {
   4:	b161      	cbz	r1, 20 <wc_ecc_export_public_raw+0x20>
   6:	b15a      	cbz	r2, 20 <wc_ecc_export_public_raw+0x20>
   8:	b153      	cbz	r3, 20 <wc_ecc_export_public_raw+0x20>
   a:	b14e      	cbz	r6, 20 <wc_ecc_export_public_raw+0x20>
    return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, NULL, NULL,
   c:	2400      	movs	r4, #0
   e:	2502      	movs	r5, #2
  10:	e9cd 4502 	strd	r4, r5, [sp, #8]
  14:	e9cd 6400 	strd	r6, r4, [sp]
  18:	f7ff fffe 	bl	0 <wc_ecc_export_public_raw>
}
  1c:	b004      	add	sp, #16
  1e:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  24:	e7fa      	b.n	1c <wc_ecc_export_public_raw+0x1c>

Disassembly of section .text.wc_ecc_export_private_raw:

00000000 <wc_ecc_export_private_raw>:
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return wc_ecc_export_ex(key, qx, qxLen, qy, qyLen, d, dLen,
   2:	2402      	movs	r4, #2
   4:	9403      	str	r4, [sp, #12]
   6:	9c08      	ldr	r4, [sp, #32]
   8:	9402      	str	r4, [sp, #8]
   a:	9c07      	ldr	r4, [sp, #28]
   c:	9401      	str	r4, [sp, #4]
   e:	9c06      	ldr	r4, [sp, #24]
  10:	9400      	str	r4, [sp, #0]
  12:	f7ff fffe 	bl	0 <wc_ecc_export_private_raw>
}
  16:	b004      	add	sp, #16
  18:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_import_private_key_ex:

00000000 <wc_ecc_import_private_key_ex>:
{
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   4:	4698      	mov	r8, r3
   6:	e9dd 4308 	ldrd	r4, r3, [sp, #32]
   a:	4606      	mov	r6, r0
   c:	460f      	mov	r7, r1
   e:	4615      	mov	r5, r2
    if (key == NULL || priv == NULL)
  10:	b31c      	cbz	r4, 5a <wc_ecc_import_private_key_ex+0x5a>
  12:	b310      	cbz	r0, 5a <wc_ecc_import_private_key_ex+0x5a>
    if (pub != NULL) {
  14:	b1d2      	cbz	r2, 4c <wc_ecc_import_private_key_ex+0x4c>
        word32 idx = 0;
  16:	2200      	movs	r2, #0
  18:	9201      	str	r2, [sp, #4]
        ret = wc_ecc_import_x963_ex(pub, pubSz, key, curve_id);
  1a:	4641      	mov	r1, r8
  1c:	4622      	mov	r2, r4
  1e:	4628      	mov	r0, r5
  20:	f7ff fffe 	bl	0 <wc_ecc_import_private_key_ex>
        if (ret < 0)
  24:	2800      	cmp	r0, #0
  26:	da05      	bge.n	34 <wc_ecc_import_private_key_ex+0x34>
            ret = wc_EccPublicKeyDecode(pub, &idx, key, pubSz);
  28:	4643      	mov	r3, r8
  2a:	4622      	mov	r2, r4
  2c:	a901      	add	r1, sp, #4
  2e:	4628      	mov	r0, r5
  30:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
        key->type = ECC_PRIVATEKEY;
  34:	2302      	movs	r3, #2
        key->type = ECC_PRIVATEKEY_ONLY;
  36:	6023      	str	r3, [r4, #0]
    if (ret != 0)
  38:	b988      	cbnz	r0, 5e <wc_ecc_import_private_key_ex+0x5e>
    ret = mp_read_unsigned_bin(key->k, priv, privSz);
  3a:	463a      	mov	r2, r7
  3c:	4631      	mov	r1, r6
  3e:	f504 70a8 	add.w	r0, r4, #336	; 0x150
}
  42:	b002      	add	sp, #8
  44:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ret = mp_read_unsigned_bin(key->k, priv, privSz);
  48:	f7ff bffe 	b.w	0 <mp_read_unsigned_bin>
    key->state = ECC_STATE_NONE;
  4c:	60a2      	str	r2, [r4, #8]
        ret = wc_ecc_set_curve(key, (int)privSz, curve_id);
  4e:	4620      	mov	r0, r4
  50:	461a      	mov	r2, r3
  52:	f7ff fffe 	bl	0 <wc_ecc_import_private_key_ex>
        key->type = ECC_PRIVATEKEY_ONLY;
  56:	2303      	movs	r3, #3
  58:	e7ed      	b.n	36 <wc_ecc_import_private_key_ex+0x36>
        return BAD_FUNC_ARG;
  5a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  5e:	b002      	add	sp, #8
  60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.wc_ecc_import_private_key:

00000000 <wc_ecc_import_private_key>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_ecc_import_private_key_ex(priv, privSz, pub, pubSz, key,
   2:	2400      	movs	r4, #0
   4:	9401      	str	r4, [sp, #4]
   6:	9c04      	ldr	r4, [sp, #16]
   8:	9400      	str	r4, [sp, #0]
   a:	f7ff fffe 	bl	0 <wc_ecc_import_private_key>
}
   e:	b002      	add	sp, #8
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_rs_to_sig:

00000000 <wc_ecc_rs_to_sig>:
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4689      	mov	r9, r1
   6:	4617      	mov	r7, r2
   8:	4698      	mov	r8, r3
    if (r == NULL || s == NULL || out == NULL || outlen == NULL)
   a:	4682      	mov	sl, r0
   c:	2800      	cmp	r0, #0
   e:	d059      	beq.n	c4 <wc_ecc_rs_to_sig+0xc4>
  10:	2900      	cmp	r1, #0
  12:	d057      	beq.n	c4 <wc_ecc_rs_to_sig+0xc4>
  14:	2a00      	cmp	r2, #0
  16:	d055      	beq.n	c4 <wc_ecc_rs_to_sig+0xc4>
  18:	2b00      	cmp	r3, #0
  1a:	d053      	beq.n	c4 <wc_ecc_rs_to_sig+0xc4>
    rtmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
  1c:	2068      	movs	r0, #104	; 0x68
  1e:	f7ff fffe 	bl	0 <malloc>
    if (rtmp == NULL)
  22:	4605      	mov	r5, r0
  24:	b138      	cbz	r0, 36 <wc_ecc_rs_to_sig+0x36>
    stmp = (mp_int*)XMALLOC(sizeof(mp_int), NULL, DYNAMIC_TYPE_ECC);
  26:	2068      	movs	r0, #104	; 0x68
  28:	f7ff fffe 	bl	0 <malloc>
    if (stmp == NULL) {
  2c:	4606      	mov	r6, r0
  2e:	b928      	cbnz	r0, 3c <wc_ecc_rs_to_sig+0x3c>
        XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);
  30:	4628      	mov	r0, r5
  32:	f7ff fffe 	bl	0 <free>
        return MEMORY_E;
  36:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  3a:	e00f      	b.n	5c <wc_ecc_rs_to_sig+0x5c>
    err = mp_init_multi(rtmp, stmp, NULL, NULL, NULL, NULL);
  3c:	2300      	movs	r3, #0
  3e:	4601      	mov	r1, r0
  40:	e9cd 3300 	strd	r3, r3, [sp]
  44:	461a      	mov	r2, r3
  46:	4628      	mov	r0, r5
  48:	f7ff fffe 	bl	0 <mp_init_multi>
    if (err != MP_OKAY) {
  4c:	4604      	mov	r4, r0
  4e:	b148      	cbz	r0, 64 <wc_ecc_rs_to_sig+0x64>
    XFREE(stmp, NULL, DYNAMIC_TYPE_ECC);
  50:	4630      	mov	r0, r6
  52:	f7ff fffe 	bl	0 <free>
    XFREE(rtmp, NULL, DYNAMIC_TYPE_ECC);
  56:	4628      	mov	r0, r5
  58:	f7ff fffe 	bl	0 <free>
}
  5c:	4620      	mov	r0, r4
  5e:	b002      	add	sp, #8
  60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    err = mp_read_radix(rtmp, r, MP_RADIX_HEX);
  64:	2210      	movs	r2, #16
  66:	4651      	mov	r1, sl
  68:	4628      	mov	r0, r5
  6a:	f7ff fffe 	bl	0 <mp_read_radix>
    if (err == MP_OKAY)
  6e:	4604      	mov	r4, r0
  70:	b968      	cbnz	r0, 8e <wc_ecc_rs_to_sig+0x8e>
        err = mp_read_radix(stmp, s, MP_RADIX_HEX);
  72:	2210      	movs	r2, #16
  74:	4649      	mov	r1, r9
  76:	4630      	mov	r0, r6
  78:	f7ff fffe 	bl	0 <mp_read_radix>
    if (err == MP_OKAY) {
  7c:	4604      	mov	r4, r0
  7e:	b930      	cbnz	r0, 8e <wc_ecc_rs_to_sig+0x8e>
        if (mp_iszero(rtmp) == MP_YES || mp_iszero(stmp) == MP_YES)
  80:	4628      	mov	r0, r5
  82:	f7ff fffe 	bl	0 <mp_iszero>
  86:	2801      	cmp	r0, #1
  88:	d108      	bne.n	9c <wc_ecc_rs_to_sig+0x9c>
            err = MP_ZERO_E;
  8a:	f06f 0478 	mvn.w	r4, #120	; 0x78
    mp_clear(rtmp);
  8e:	4628      	mov	r0, r5
  90:	f7ff fffe 	bl	0 <mp_clear>
    mp_clear(stmp);
  94:	4630      	mov	r0, r6
  96:	f7ff fffe 	bl	0 <mp_clear>
  9a:	e7d9      	b.n	50 <wc_ecc_rs_to_sig+0x50>
        if (mp_iszero(rtmp) == MP_YES || mp_iszero(stmp) == MP_YES)
  9c:	4630      	mov	r0, r6
  9e:	f7ff fffe 	bl	0 <mp_iszero>
  a2:	2801      	cmp	r0, #1
  a4:	d0f1      	beq.n	8a <wc_ecc_rs_to_sig+0x8a>
        if (mp_isneg(rtmp) == MP_YES || mp_isneg(stmp) == MP_YES) {
  a6:	686b      	ldr	r3, [r5, #4]
  a8:	b94b      	cbnz	r3, be <wc_ecc_rs_to_sig+0xbe>
  aa:	6873      	ldr	r3, [r6, #4]
  ac:	b93b      	cbnz	r3, be <wc_ecc_rs_to_sig+0xbe>
        err = StoreECC_DSA_Sig(out, outlen, rtmp, stmp);
  ae:	4633      	mov	r3, r6
  b0:	462a      	mov	r2, r5
  b2:	4641      	mov	r1, r8
  b4:	4638      	mov	r0, r7
  b6:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig>
  ba:	4604      	mov	r4, r0
  bc:	e7e7      	b.n	8e <wc_ecc_rs_to_sig+0x8e>
            err = MP_READ_E;
  be:	f06f 046e 	mvn.w	r4, #110	; 0x6e
  c2:	e7e4      	b.n	8e <wc_ecc_rs_to_sig+0x8e>
        return ECC_BAD_ARG_E;
  c4:	f06f 04a9 	mvn.w	r4, #169	; 0xa9
  c8:	e7c8      	b.n	5c <wc_ecc_rs_to_sig+0x5c>

Disassembly of section .text.wc_ecc_rs_raw_to_sig:

00000000 <wc_ecc_rs_raw_to_sig>:
{
   0:	b470      	push	{r4, r5, r6}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
   6:	e9dd 6103 	ldrd	r6, r1, [sp, #12]
    if (r == NULL || s == NULL || out == NULL || outlen == NULL)
   a:	4602      	mov	r2, r0
   c:	b148      	cbz	r0, 22 <wc_ecc_rs_raw_to_sig+0x22>
   e:	b144      	cbz	r4, 22 <wc_ecc_rs_raw_to_sig+0x22>
  10:	b13e      	cbz	r6, 22 <wc_ecc_rs_raw_to_sig+0x22>
  12:	b131      	cbz	r1, 22 <wc_ecc_rs_raw_to_sig+0x22>
    return StoreECC_DSA_Sig_Bin(out, outlen, r, rSz, s, sSz);
  14:	e9cd 4303 	strd	r4, r3, [sp, #12]
  18:	4630      	mov	r0, r6
  1a:	462b      	mov	r3, r5
}
  1c:	bc70      	pop	{r4, r5, r6}
    return StoreECC_DSA_Sig_Bin(out, outlen, r, rSz, s, sSz);
  1e:	f7ff bffe 	b.w	0 <StoreECC_DSA_Sig_Bin>
}
  22:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  26:	bc70      	pop	{r4, r5, r6}
  28:	4770      	bx	lr

Disassembly of section .text.wc_ecc_sig_to_rs:

00000000 <wc_ecc_sig_to_rs>:
{
   0:	b4f0      	push	{r4, r5, r6, r7}
   2:	e9dd 6704 	ldrd	r6, r7, [sp, #16]
    if (sig == NULL || r == NULL || rLen == NULL || s == NULL || sLen == NULL)
   6:	b130      	cbz	r0, 16 <wc_ecc_sig_to_rs+0x16>
   8:	b12a      	cbz	r2, 16 <wc_ecc_sig_to_rs+0x16>
   a:	b123      	cbz	r3, 16 <wc_ecc_sig_to_rs+0x16>
   c:	b11e      	cbz	r6, 16 <wc_ecc_sig_to_rs+0x16>
   e:	b117      	cbz	r7, 16 <wc_ecc_sig_to_rs+0x16>
}
  10:	bcf0      	pop	{r4, r5, r6, r7}
    return DecodeECC_DSA_Sig_Bin(sig, sigLen, r, rLen, s, sLen);
  12:	f7ff bffe 	b.w	0 <DecodeECC_DSA_Sig_Bin>
}
  16:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  1a:	bcf0      	pop	{r4, r5, r6, r7}
  1c:	4770      	bx	lr

Disassembly of section .text.wc_ecc_import_raw_ex:

00000000 <wc_ecc_import_raw_ex>:
   dp        Custom ecc_set_type
   return    MP_OKAY on success
*/
int wc_ecc_import_raw_ex(ecc_key* key, const char* qx, const char* qy,
                   const char* d, int curve_id)
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_ecc_import_raw_private(key, qx, qy, d, curve_id,
   2:	2401      	movs	r4, #1
   4:	9401      	str	r4, [sp, #4]
   6:	9c04      	ldr	r4, [sp, #16]
   8:	9400      	str	r4, [sp, #0]
   a:	f7ff fffe 	bl	0 <wc_ecc_import_raw_ex>
        WC_TYPE_HEX_STR);

}
   e:	b002      	add	sp, #8
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_import_unsigned:

00000000 <wc_ecc_import_unsigned>:

/* Import x, y and optional private (d) as unsigned binary */
int wc_ecc_import_unsigned(ecc_key* key, const byte* qx, const byte* qy,
                   const byte* d, int curve_id)
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_ecc_import_raw_private(key, (const char*)qx, (const char*)qy,
   2:	2402      	movs	r4, #2
   4:	9401      	str	r4, [sp, #4]
   6:	9c04      	ldr	r4, [sp, #16]
   8:	9400      	str	r4, [sp, #0]
   a:	f7ff fffe 	bl	0 <wc_ecc_import_unsigned>
        (const char*)d, curve_id, WC_TYPE_UNSIGNED_BIN);
}
   e:	b002      	add	sp, #8
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ecc_import_raw:

00000000 <wc_ecc_import_raw>:
   return    MP_OKAY on success
*/
WOLFSSL_ABI
int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   4:	f8dd 8020 	ldr.w	r8, [sp, #32]
   8:	460d      	mov	r5, r1
   a:	4616      	mov	r6, r2
   c:	461f      	mov	r7, r3
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
   e:	4604      	mov	r4, r0
  10:	b1d0      	cbz	r0, 48 <wc_ecc_import_raw+0x48>
  12:	b1c9      	cbz	r1, 48 <wc_ecc_import_raw+0x48>
  14:	b1c2      	cbz	r2, 48 <wc_ecc_import_raw+0x48>
  16:	f1b8 0f00 	cmp.w	r8, #0
  1a:	d015      	beq.n	48 <wc_ecc_import_raw+0x48>
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
  1c:	4640      	mov	r0, r8
  1e:	f7ff fffe 	bl	0 <strlen>
  22:	4641      	mov	r1, r8
  24:	4602      	mov	r2, r0
  26:	480b      	ldr	r0, [pc, #44]	; (54 <wc_ecc_import_raw+0x54>)
  28:	f7ff fffe 	bl	0 <strncmp>
  2c:	b978      	cbnz	r0, 4e <wc_ecc_import_raw+0x4e>

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG("ecc_set curve name not found");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
  2e:	2307      	movs	r3, #7
  30:	2201      	movs	r2, #1
  32:	e9cd 3200 	strd	r3, r2, [sp]
  36:	4629      	mov	r1, r5
  38:	463b      	mov	r3, r7
  3a:	4632      	mov	r2, r6
  3c:	4620      	mov	r0, r4
  3e:	f7ff fffe 	bl	0 <wc_ecc_import_raw>
            WC_TYPE_HEX_STR);
    }

    return err;
}
  42:	b002      	add	sp, #8
  44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return BAD_FUNC_ARG;
  48:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  4c:	e7f9      	b.n	42 <wc_ecc_import_raw+0x42>
    return err;
  4e:	f06f 008b 	mvn.w	r0, #139	; 0x8b
  52:	e7f6      	b.n	42 <wc_ecc_import_raw+0x42>
  54:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ecc_size:

00000000 <wc_ecc_size>:

/* key size in octets */
WOLFSSL_ABI
int wc_ecc_size(ecc_key* key)
{
    if (key == NULL || key->dp == NULL)
   0:	b110      	cbz	r0, 8 <wc_ecc_size+0x8>
   2:	6900      	ldr	r0, [r0, #16]
   4:	b100      	cbz	r0, 8 <wc_ecc_size+0x8>
        return 0;

    return key->dp->size;
   6:	6800      	ldr	r0, [r0, #0]
}
   8:	4770      	bx	lr

Disassembly of section .text.wc_ecc_sig_size_calc:

00000000 <wc_ecc_sig_size_calc>:
{
    int maxSigSz = 0;

    /* calculate based on key bits */
    /* maximum possible signature header size is 7 bytes plus 2 bytes padding */
    maxSigSz = (sz * 2) + SIG_HEADER_SZ + ECC_MAX_PAD_SZ;
   0:	0043      	lsls	r3, r0, #1
   2:	f103 0009 	add.w	r0, r3, #9

    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */
    if (maxSigSz < (128 + 2)) {
   6:	2881      	cmp	r0, #129	; 0x81
        maxSigSz -= 1;
   8:	bfd8      	it	le
   a:	f103 0008 	addle.w	r0, r3, #8
    }

    return maxSigSz;
}
   e:	4770      	bx	lr

Disassembly of section .text.wc_ecc_sig_size:

00000000 <wc_ecc_sig_size>:

/* maximum signature size based on actual key curve */
WOLFSSL_ABI
int wc_ecc_sig_size(const ecc_key* key)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b08c      	sub	sp, #48	; 0x30
    int maxSigSz;
    int orderBits, keySz;

    if (key == NULL || key->dp == NULL)
   4:	2800      	cmp	r0, #0
   6:	d03a      	beq.n	7e <wc_ecc_sig_size+0x7e>
   8:	6904      	ldr	r4, [r0, #16]
   a:	2c00      	cmp	r4, #0
   c:	d039      	beq.n	82 <wc_ecc_sig_size+0x82>
    DECLARE_CURVE_SPECS(1);
   e:	a802      	add	r0, sp, #8
  10:	2228      	movs	r2, #40	; 0x28
  12:	2100      	movs	r1, #0
        return 0;

    /* the signature r and s will always be less than order */
    /* if the order MSB (top bit of byte) is set then ASN encoding needs
        extra byte for r and s, so add 2 */
    keySz = key->dp->size;
  14:	6826      	ldr	r6, [r4, #0]
    DECLARE_CURVE_SPECS(1);
  16:	9001      	str	r0, [sp, #4]
  18:	f7ff fffe 	bl	0 <memset>
  1c:	9b01      	ldr	r3, [sp, #4]
  1e:	2201      	movs	r2, #1
  20:	61da      	str	r2, [r3, #28]
    ALLOC_CURVE_SPECS(1, err);
  22:	2068      	movs	r0, #104	; 0x68
  24:	f7ff fffe 	bl	0 <malloc>
  28:	4605      	mov	r5, r0
  2a:	b1a0      	cbz	r0, 56 <wc_ecc_sig_size+0x56>
  2c:	9b01      	ldr	r3, [sp, #4]
        err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);
  2e:	2208      	movs	r2, #8
    ALLOC_CURVE_SPECS(1, err);
  30:	6198      	str	r0, [r3, #24]
        err = wc_ecc_curve_load(dp, &curve, ECC_CURVE_FIELD_ORDER);
  32:	a901      	add	r1, sp, #4
  34:	4620      	mov	r0, r4
  36:	f7ff fffe 	bl	0 <wc_ecc_sig_size>
    if (err != 0) {
  3a:	4604      	mov	r4, r0
  3c:	b938      	cbnz	r0, 4e <wc_ecc_sig_size+0x4e>
    orderBits = mp_count_bits(curve->order);
  3e:	9b01      	ldr	r3, [sp, #4]
  40:	68d8      	ldr	r0, [r3, #12]
  42:	f7ff fffe 	bl	0 <mp_count_bits>
  46:	4604      	mov	r4, r0
    wc_ecc_curve_free(curve);
  48:	9801      	ldr	r0, [sp, #4]
  4a:	f7ff fffe 	bl	0 <wc_ecc_sig_size>
       FREE_CURVE_SPECS();
  4e:	4628      	mov	r0, r5
  50:	f7ff fffe 	bl	0 <free>
  54:	e001      	b.n	5a <wc_ecc_sig_size+0x5a>
    ALLOC_CURVE_SPECS(1, err);
  56:	f06f 047c 	mvn.w	r4, #124	; 0x7c
    orderBits = wc_ecc_get_curve_order_bit_count(key->dp);
    if (orderBits > keySz * 8) {
  5a:	ebb4 0fc6 	cmp.w	r4, r6, lsl #3
  5e:	dd04      	ble.n	6a <wc_ecc_sig_size+0x6a>
        keySz = (orderBits + 7) / 8;
  60:	1de3      	adds	r3, r4, #7
  62:	bf48      	it	mi
  64:	f104 030e 	addmi.w	r3, r4, #14
  68:	10de      	asrs	r6, r3, #3
    }
    /* maximum possible signature header size is 7 bytes */
    maxSigSz = (keySz * 2) + SIG_HEADER_SZ;
    if ((orderBits % 8) == 0) {
  6a:	0762      	lsls	r2, r4, #29
    maxSigSz = (keySz * 2) + SIG_HEADER_SZ;
  6c:	ea4f 0346 	mov.w	r3, r6, lsl #1
  70:	bf14      	ite	ne
  72:	1dd8      	addne	r0, r3, #7
        /* MSB can be set, so add 2 */
        maxSigSz += ECC_MAX_PAD_SZ;
  74:	f103 0009 	addeq.w	r0, r3, #9
    }
    /* if total length is less than 128 + SEQ(1)+LEN(1) then subtract 1 */
    if (maxSigSz < (128 + 2)) {
  78:	2881      	cmp	r0, #129	; 0x81
  7a:	dc00      	bgt.n	7e <wc_ecc_sig_size+0x7e>
        maxSigSz -= 1;
  7c:	3801      	subs	r0, #1
    }

    return maxSigSz;
}
  7e:	b00c      	add	sp, #48	; 0x30
  80:	bd70      	pop	{r4, r5, r6, pc}
        return 0;
  82:	4620      	mov	r0, r4
  84:	e7fb      	b.n	7e <wc_ecc_sig_size+0x7e>

Disassembly of section .text.wc_ecc_set_rng:

00000000 <wc_ecc_set_rng>:
int wc_ecc_set_rng(ecc_key* key, WC_RNG* rng)
{
    int err = 0;

#ifdef ECC_TIMING_RESISTANT
    if (key == NULL) {
   0:	b118      	cbz	r0, a <wc_ecc_set_rng+0xa>
        err = BAD_FUNC_ARG;
    }
    else {
        key->rng = rng;
   2:	f8c0 11b8 	str.w	r1, [r0, #440]	; 0x1b8
    int err = 0;
   6:	2000      	movs	r0, #0
   8:	4770      	bx	lr
        err = BAD_FUNC_ARG;
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    (void)rng;
    /* report success, not an error if ECC_TIMING_RESISTANT is not defined */
#endif

    return err;
}
   e:	4770      	bx	lr

Disassembly of section .text.wc_ecc_get_oid:

00000000 <wc_ecc_get_oid>:

int wc_ecc_get_oid(word32 oidSum, const byte** oid, word32* oidSz)
{
    int x;

    if (oidSum == 0) {
   0:	b158      	cbz	r0, 1a <wc_ecc_get_oid+0x1a>
        return BAD_FUNC_ARG;
    }

    /* find matching OID sum (based on encoded value) */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (ecc_sets[x].oidSum == oidSum) {
   2:	f240 230e 	movw	r3, #526	; 0x20e
   6:	4298      	cmp	r0, r3
   8:	d10a      	bne.n	20 <wc_ecc_get_oid+0x20>
            /* on success return curve id */
            if (ret == 0) {
                ret = ecc_sets[x].id;
            }
        #else
            if (oidSz) {
   a:	b10a      	cbz	r2, 10 <wc_ecc_get_oid+0x10>
                *oidSz = ecc_sets[x].oidSz;
   c:	2308      	movs	r3, #8
   e:	6013      	str	r3, [r2, #0]
            }
            if (oid) {
  10:	b109      	cbz	r1, 16 <wc_ecc_get_oid+0x16>
                *oid = ecc_sets[x].oid;
  12:	4b05      	ldr	r3, [pc, #20]	; (28 <wc_ecc_get_oid+0x28>)
  14:	600b      	str	r3, [r1, #0]
            }
            ret = ecc_sets[x].id;
        #endif
            return ret;
  16:	2007      	movs	r0, #7
        }
    }

    return NOT_COMPILED_IN;
}
  18:	4770      	bx	lr
        return BAD_FUNC_ARG;
  1a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1e:	4770      	bx	lr
    return NOT_COMPILED_IN;
  20:	f06f 00ad 	mvn.w	r0, #173	; 0xad
  24:	4770      	bx	lr
  26:	bf00      	nop
  28:	00000000 	.word	0x00000000

hmac.o:     file format elf32-littlearm


Disassembly of section .text.HmacKeyInnerHash:

00000000 <HmacKeyInnerHash>:
#endif /* WOLFSSL_MAXQ108X */
}


static int HmacKeyInnerHash(Hmac* hmac)
{
   0:	b510      	push	{r4, lr}
    int ret = 0;

    switch (hmac->macType) {
   2:	f890 3224 	ldrb.w	r3, [r0, #548]	; 0x224
   6:	2b06      	cmp	r3, #6
{
   8:	4604      	mov	r4, r0
    switch (hmac->macType) {
   a:	d00e      	beq.n	2a <HmacKeyInnerHash+0x2a>
   c:	2b08      	cmp	r3, #8
   e:	d012      	beq.n	36 <HmacKeyInnerHash+0x36>
  10:	2b04      	cmp	r3, #4
  12:	d105      	bne.n	20 <HmacKeyInnerHash+0x20>
            break;
    #endif /* !NO_MD5 */

    #ifndef NO_SHA
        case WC_SHA:
            ret = wc_ShaUpdate(&hmac->hash.sha, (byte*)hmac->ipad,
  14:	2240      	movs	r2, #64	; 0x40
  16:	f100 01e0 	add.w	r1, r0, #224	; 0xe0
  1a:	f7ff fffe 	bl	0 <wc_ShaUpdate>

        default:
            break;
    }

    if (ret == 0)
  1e:	b918      	cbnz	r0, 28 <HmacKeyInnerHash+0x28>
        hmac->innerHashKeyed = WC_HMAC_INNER_HASH_KEYED_SW;
  20:	2301      	movs	r3, #1
  22:	f884 3225 	strb.w	r3, [r4, #549]	; 0x225
  26:	2000      	movs	r0, #0

    return ret;
}
  28:	bd10      	pop	{r4, pc}
            ret = wc_Sha256Update(&hmac->hash.sha256, (byte*)hmac->ipad,
  2a:	2240      	movs	r2, #64	; 0x40
  2c:	f100 01e0 	add.w	r1, r0, #224	; 0xe0
  30:	f7ff fffe 	bl	0 <wc_Sha256Update>
            break;
  34:	e7f3      	b.n	1e <HmacKeyInnerHash+0x1e>
            ret = wc_Sha512Update(&hmac->hash.sha512, (byte*)hmac->ipad,
  36:	2280      	movs	r2, #128	; 0x80
  38:	f100 01e0 	add.w	r1, r0, #224	; 0xe0
  3c:	f7ff fffe 	bl	0 <wc_Sha512Update>
            break;
  40:	e7ed      	b.n	1e <HmacKeyInnerHash+0x1e>

Disassembly of section .text.wc_HmacSizeByType:

00000000 <wc_HmacSizeByType>:
            type == WC_SHA384 || type == WC_SHA512 ||
   0:	1ec3      	subs	r3, r0, #3
    if (!(type == WC_MD5 || type == WC_SHA ||
   2:	2b05      	cmp	r3, #5
   4:	d903      	bls.n	e <wc_HmacSizeByType+0xe>
            type == WC_SHA384 || type == WC_SHA512 ||
   6:	f1a0 030a 	sub.w	r3, r0, #10
   a:	2b03      	cmp	r3, #3
   c:	d806      	bhi.n	1c <wc_HmacSizeByType+0x1c>
    switch (type) {
   e:	3804      	subs	r0, #4
  10:	2804      	cmp	r0, #4
  12:	d803      	bhi.n	1c <wc_HmacSizeByType+0x1c>
  14:	4b03      	ldr	r3, [pc, #12]	; (24 <wc_HmacSizeByType+0x24>)
  16:	f933 0010 	ldrsh.w	r0, [r3, r0, lsl #1]
  1a:	4770      	bx	lr
        return BAD_FUNC_ARG;
  1c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  20:	4770      	bx	lr
  22:	bf00      	nop
  24:	00000000 	.word	0x00000000

Disassembly of section .text._InitHmac:

00000000 <_InitHmac>:
    switch (type) {
   0:	2906      	cmp	r1, #6
{
   2:	b538      	push	{r3, r4, r5, lr}
   4:	4605      	mov	r5, r0
   6:	4614      	mov	r4, r2
    switch (type) {
   8:	d00b      	beq.n	22 <_InitHmac+0x22>
   a:	2908      	cmp	r1, #8
   c:	d00f      	beq.n	2e <_InitHmac+0x2e>
   e:	2904      	cmp	r1, #4
  10:	d113      	bne.n	3a <_InitHmac+0x3a>
            ret = wc_InitSha_ex(&hmac->hash.sha, heap, devId);
  12:	f06f 0201 	mvn.w	r2, #1
  16:	4621      	mov	r1, r4
  18:	f7ff fffe 	bl	0 <wc_InitSha_ex>
    hmac->heap = heap;
  1c:	f8c5 4220 	str.w	r4, [r5, #544]	; 0x220
}
  20:	bd38      	pop	{r3, r4, r5, pc}
            ret = wc_InitSha256_ex(&hmac->hash.sha256, heap, devId);
  22:	f06f 0201 	mvn.w	r2, #1
  26:	4621      	mov	r1, r4
  28:	f7ff fffe 	bl	0 <wc_InitSha256_ex>
            break;
  2c:	e7f6      	b.n	1c <_InitHmac+0x1c>
            ret = wc_InitSha512_ex(&hmac->hash.sha512, heap, devId);
  2e:	f06f 0201 	mvn.w	r2, #1
  32:	4621      	mov	r1, r4
  34:	f7ff fffe 	bl	0 <wc_InitSha512_ex>
            break;
  38:	e7f0      	b.n	1c <_InitHmac+0x1c>
    switch (type) {
  3a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  3e:	e7ed      	b.n	1c <_InitHmac+0x1c>

Disassembly of section .text.wc_HmacUpdate:

00000000 <wc_HmacUpdate>:


int wc_HmacUpdate(Hmac* hmac, const byte* msg, word32 length)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4616      	mov	r6, r2
    int ret = 0;

    if (hmac == NULL || (msg == NULL && length > 0)) {
   6:	4604      	mov	r4, r0
   8:	b348      	cbz	r0, 5e <wc_HmacUpdate+0x5e>
   a:	b901      	cbnz	r1, e <wc_HmacUpdate+0xe>
   c:	bb3a      	cbnz	r2, 5e <wc_HmacUpdate+0x5e>
        }
    #endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    if (!hmac->innerHashKeyed) {
   e:	f894 3225 	ldrb.w	r3, [r4, #549]	; 0x225
  12:	b14b      	cbz	r3, 28 <wc_HmacUpdate+0x28>
        ret = HmacKeyInnerHash(hmac);
        if (ret != 0)
            return ret;
    }

    switch (hmac->macType) {
  14:	f894 3224 	ldrb.w	r3, [r4, #548]	; 0x224
  18:	2b06      	cmp	r3, #6
  1a:	d012      	beq.n	42 <wc_HmacUpdate+0x42>
  1c:	2b08      	cmp	r3, #8
  1e:	d017      	beq.n	50 <wc_HmacUpdate+0x50>
  20:	2b04      	cmp	r3, #4
  22:	d007      	beq.n	34 <wc_HmacUpdate+0x34>
  24:	2000      	movs	r0, #0
        default:
            break;
    }

    return ret;
}
  26:	bd70      	pop	{r4, r5, r6, pc}
        ret = HmacKeyInnerHash(hmac);
  28:	4620      	mov	r0, r4
  2a:	f7ff fffe 	bl	0 <wc_HmacUpdate>
        if (ret != 0)
  2e:	2800      	cmp	r0, #0
  30:	d0f0      	beq.n	14 <wc_HmacUpdate+0x14>
  32:	e7f8      	b.n	26 <wc_HmacUpdate+0x26>
            ret = wc_ShaUpdate(&hmac->hash.sha, msg, length);
  34:	4632      	mov	r2, r6
  36:	4629      	mov	r1, r5
  38:	4620      	mov	r0, r4
}
  3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_ShaUpdate(&hmac->hash.sha, msg, length);
  3e:	f7ff bffe 	b.w	0 <wc_ShaUpdate>
            ret = wc_Sha256Update(&hmac->hash.sha256, msg, length);
  42:	4632      	mov	r2, r6
  44:	4629      	mov	r1, r5
  46:	4620      	mov	r0, r4
}
  48:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_Sha256Update(&hmac->hash.sha256, msg, length);
  4c:	f7ff bffe 	b.w	0 <wc_Sha256Update>
            ret = wc_Sha512Update(&hmac->hash.sha512, msg, length);
  50:	4632      	mov	r2, r6
  52:	4629      	mov	r1, r5
  54:	4620      	mov	r0, r4
}
  56:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_Sha512Update(&hmac->hash.sha512, msg, length);
  5a:	f7ff bffe 	b.w	0 <wc_Sha512Update>
        return BAD_FUNC_ARG;
  5e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  62:	e7e0      	b.n	26 <wc_HmacUpdate+0x26>

Disassembly of section .text.wc_HmacFinal:

00000000 <wc_HmacFinal>:


int wc_HmacFinal(Hmac* hmac, byte* hash)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
    int ret;

    if (hmac == NULL || hash == NULL) {
   4:	4604      	mov	r4, r0
   6:	b158      	cbz	r0, 20 <wc_HmacFinal+0x20>
   8:	b151      	cbz	r1, 20 <wc_HmacFinal+0x20>
        }
    #endif
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    if (!hmac->innerHashKeyed) {
   a:	f890 3225 	ldrb.w	r3, [r0, #549]	; 0x225
   e:	b153      	cbz	r3, 26 <wc_HmacFinal+0x26>
        ret = HmacKeyInnerHash(hmac);
        if (ret != 0)
            return ret;
    }

    switch (hmac->macType) {
  10:	f894 3224 	ldrb.w	r3, [r4, #548]	; 0x224
  14:	2b06      	cmp	r3, #6
  16:	d02b      	beq.n	70 <wc_HmacFinal+0x70>
  18:	2b08      	cmp	r3, #8
  1a:	d045      	beq.n	a8 <wc_HmacFinal+0xa8>
  1c:	2b04      	cmp	r3, #4
  1e:	d007      	beq.n	30 <wc_HmacFinal+0x30>
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  24:	e003      	b.n	2e <wc_HmacFinal+0x2e>
        ret = HmacKeyInnerHash(hmac);
  26:	f7ff fffe 	bl	0 <wc_HmacFinal>
        if (ret != 0)
  2a:	2800      	cmp	r0, #0
  2c:	d0f0      	beq.n	10 <wc_HmacFinal+0x10>
    if (ret == 0) {
        hmac->innerHashKeyed = 0;
    }

    return ret;
}
  2e:	bd70      	pop	{r4, r5, r6, pc}
            ret = wc_ShaFinal(&hmac->hash.sha, (byte*)hmac->innerHash);
  30:	f504 76f0 	add.w	r6, r4, #480	; 0x1e0
  34:	4631      	mov	r1, r6
  36:	4620      	mov	r0, r4
  38:	f7ff fffe 	bl	0 <wc_ShaFinal>
            if (ret != 0)
  3c:	2800      	cmp	r0, #0
  3e:	d1f6      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_ShaUpdate(&hmac->hash.sha, (byte*)hmac->opad,
  40:	2240      	movs	r2, #64	; 0x40
  42:	f504 71b0 	add.w	r1, r4, #352	; 0x160
  46:	4620      	mov	r0, r4
  48:	f7ff fffe 	bl	0 <wc_ShaUpdate>
            if (ret != 0)
  4c:	2800      	cmp	r0, #0
  4e:	d1ee      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_ShaUpdate(&hmac->hash.sha, (byte*)hmac->innerHash,
  50:	2214      	movs	r2, #20
  52:	4631      	mov	r1, r6
  54:	4620      	mov	r0, r4
  56:	f7ff fffe 	bl	0 <wc_ShaUpdate>
            if (ret != 0)
  5a:	2800      	cmp	r0, #0
  5c:	d1e7      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_ShaFinal(&hmac->hash.sha, hash);
  5e:	4629      	mov	r1, r5
  60:	4620      	mov	r0, r4
  62:	f7ff fffe 	bl	0 <wc_ShaFinal>
    if (ret == 0) {
  66:	2800      	cmp	r0, #0
  68:	d1e1      	bne.n	2e <wc_HmacFinal+0x2e>
        hmac->innerHashKeyed = 0;
  6a:	f884 0225 	strb.w	r0, [r4, #549]	; 0x225
  6e:	e7de      	b.n	2e <wc_HmacFinal+0x2e>
            ret = wc_Sha256Final(&hmac->hash.sha256, (byte*)hmac->innerHash);
  70:	f504 76f0 	add.w	r6, r4, #480	; 0x1e0
  74:	4631      	mov	r1, r6
  76:	4620      	mov	r0, r4
  78:	f7ff fffe 	bl	0 <wc_Sha256Final>
            if (ret != 0)
  7c:	2800      	cmp	r0, #0
  7e:	d1d6      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_Sha256Update(&hmac->hash.sha256, (byte*)hmac->opad,
  80:	2240      	movs	r2, #64	; 0x40
  82:	f504 71b0 	add.w	r1, r4, #352	; 0x160
  86:	4620      	mov	r0, r4
  88:	f7ff fffe 	bl	0 <wc_Sha256Update>
            if (ret != 0)
  8c:	2800      	cmp	r0, #0
  8e:	d1ce      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_Sha256Update(&hmac->hash.sha256, (byte*)hmac->innerHash,
  90:	2220      	movs	r2, #32
  92:	4631      	mov	r1, r6
  94:	4620      	mov	r0, r4
  96:	f7ff fffe 	bl	0 <wc_Sha256Update>
            if (ret != 0)
  9a:	2800      	cmp	r0, #0
  9c:	d1c7      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_Sha256Final(&hmac->hash.sha256, hash);
  9e:	4629      	mov	r1, r5
  a0:	4620      	mov	r0, r4
  a2:	f7ff fffe 	bl	0 <wc_Sha256Final>
            break;
  a6:	e7de      	b.n	66 <wc_HmacFinal+0x66>
            ret = wc_Sha512Final(&hmac->hash.sha512, (byte*)hmac->innerHash);
  a8:	f504 76f0 	add.w	r6, r4, #480	; 0x1e0
  ac:	4631      	mov	r1, r6
  ae:	4620      	mov	r0, r4
  b0:	f7ff fffe 	bl	0 <wc_Sha512Final>
            if (ret != 0)
  b4:	2800      	cmp	r0, #0
  b6:	d1ba      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_Sha512Update(&hmac->hash.sha512, (byte*)hmac->opad,
  b8:	2280      	movs	r2, #128	; 0x80
  ba:	f504 71b0 	add.w	r1, r4, #352	; 0x160
  be:	4620      	mov	r0, r4
  c0:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret != 0)
  c4:	2800      	cmp	r0, #0
  c6:	d1b2      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_Sha512Update(&hmac->hash.sha512, (byte*)hmac->innerHash,
  c8:	2240      	movs	r2, #64	; 0x40
  ca:	4631      	mov	r1, r6
  cc:	4620      	mov	r0, r4
  ce:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret != 0)
  d2:	2800      	cmp	r0, #0
  d4:	d1ab      	bne.n	2e <wc_HmacFinal+0x2e>
            ret = wc_Sha512Final(&hmac->hash.sha512, hash);
  d6:	4629      	mov	r1, r5
  d8:	4620      	mov	r0, r4
  da:	f7ff fffe 	bl	0 <wc_Sha512Final>
            break;
  de:	e7c2      	b.n	66 <wc_HmacFinal+0x66>

Disassembly of section .text.wc_HmacInit:

00000000 <wc_HmacInit>:
    #undef wc_HmacFinal

#else
/* Initialize Hmac for use with async device */
int wc_HmacInit(Hmac* hmac, void* heap, int devId)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    int ret = 0;

    if (hmac == NULL)
   4:	4604      	mov	r4, r0
   6:	b150      	cbz	r0, 1e <wc_HmacInit+0x1e>
        return BAD_FUNC_ARG;

    XMEMSET(hmac, 0, sizeof(Hmac));
   8:	f44f 720a 	mov.w	r2, #552	; 0x228
   c:	2100      	movs	r1, #0
   e:	f7ff fffe 	bl	0 <memset>
    hmac->macType = WC_HASH_TYPE_NONE;
  12:	2000      	movs	r0, #0
  14:	f884 0224 	strb.w	r0, [r4, #548]	; 0x224
    hmac->heap = heap;
  18:	f8c4 5220 	str.w	r5, [r4, #544]	; 0x220
#else
    (void)devId;
#endif /* WOLFSSL_ASYNC_CRYPT */

    return ret;
}
  1c:	bd38      	pop	{r3, r4, r5, pc}
        return BAD_FUNC_ARG;
  1e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  22:	e7fb      	b.n	1c <wc_HmacInit+0x1c>

Disassembly of section .text.wc_HmacFree:

00000000 <wc_HmacFree>:
}
#endif /* WOLF_PRIVATE_KEY_ID */

/* Free Hmac from use with async device */
void wc_HmacFree(Hmac* hmac)
{
   0:	b510      	push	{r4, lr}
    if (hmac == NULL)
   2:	4604      	mov	r4, r0
   4:	b170      	cbz	r0, 24 <wc_HmacFree+0x24>

#if defined(WOLFSSL_ASYNC_CRYPT) && defined(WC_ASYNC_ENABLE_HMAC)
    wolfAsync_DevCtxFree(&hmac->asyncDev, WOLFSSL_ASYNC_MARKER_HMAC);
#endif /* WOLFSSL_ASYNC_CRYPT */

    switch (hmac->macType) {
   6:	f890 3224 	ldrb.w	r3, [r0, #548]	; 0x224
   a:	2b06      	cmp	r3, #6
   c:	d00b      	beq.n	26 <wc_HmacFree+0x26>
   e:	2b08      	cmp	r3, #8
  10:	d00c      	beq.n	2c <wc_HmacFree+0x2c>
  12:	2b04      	cmp	r3, #4
  14:	d101      	bne.n	1a <wc_HmacFree+0x1a>
            break;
    #endif /* !NO_MD5 */

    #ifndef NO_SHA
        case WC_SHA:
            wc_ShaFree(&hmac->hash.sha);
  16:	f7ff fffe 	bl	0 <wc_ShaFree>
            break;
  1a:	f504 730a 	add.w	r3, r4, #552	; 0x228
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
  1e:	2200      	movs	r2, #0
  20:	429c      	cmp	r4, r3
  22:	d106      	bne.n	32 <wc_HmacFree+0x32>
        default:
            break;
    }

    ForceZero(hmac, sizeof(*hmac));
}
  24:	bd10      	pop	{r4, pc}
            wc_Sha256Free(&hmac->hash.sha256);
  26:	f7ff fffe 	bl	0 <wc_Sha256Free>
            break;
  2a:	e7f6      	b.n	1a <wc_HmacFree+0x1a>
            wc_Sha512Free(&hmac->hash.sha512);
  2c:	f7ff fffe 	bl	0 <wc_Sha512Free>
            break;
  30:	e7f3      	b.n	1a <wc_HmacFree+0x1a>
  32:	f804 2b01 	strb.w	r2, [r4], #1
  36:	e7f3      	b.n	20 <wc_HmacFree+0x20>

Disassembly of section .text.wc_HmacSetKey:

00000000 <wc_HmacSetKey>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460f      	mov	r7, r1
   6:	4616      	mov	r6, r2
   8:	461d      	mov	r5, r3
    if (hmac == NULL || (key == NULL && length != 0) ||
   a:	4604      	mov	r4, r0
   c:	2800      	cmp	r0, #0
   e:	d07c      	beq.n	10a <wc_HmacSetKey+0x10a>
  10:	b90a      	cbnz	r2, 16 <wc_HmacSetKey+0x16>
  12:	2b00      	cmp	r3, #0
  14:	d179      	bne.n	10a <wc_HmacSetKey+0x10a>
            type == WC_SHA384 || type == WC_SHA512 ||
  16:	1efb      	subs	r3, r7, #3
    if (hmac == NULL || (key == NULL && length != 0) ||
  18:	2b05      	cmp	r3, #5
  1a:	d903      	bls.n	24 <wc_HmacSetKey+0x24>
            type == WC_SHA384 || type == WC_SHA512 ||
  1c:	f1a7 030a 	sub.w	r3, r7, #10
  20:	2b03      	cmp	r3, #3
  22:	d872      	bhi.n	10a <wc_HmacSetKey+0x10a>
    if (hmac->macType != WC_HASH_TYPE_NONE) {
  24:	f894 3224 	ldrb.w	r3, [r4, #548]	; 0x224
  28:	b113      	cbz	r3, 30 <wc_HmacSetKey+0x30>
        wc_HmacFree(hmac);
  2a:	4620      	mov	r0, r4
  2c:	f7ff fffe 	bl	0 <wc_HmacSetKey>
    hmac->innerHashKeyed = 0;
  30:	2200      	movs	r2, #0
  32:	f884 2225 	strb.w	r2, [r4, #549]	; 0x225
    hmac->macType = (byte)type;
  36:	f884 7224 	strb.w	r7, [r4, #548]	; 0x224
    ret = _InitHmac(hmac, type, heap);
  3a:	4639      	mov	r1, r7
  3c:	4620      	mov	r0, r4
  3e:	f7ff fffe 	bl	0 <wc_HmacSetKey>
    if (ret != 0)
  42:	4680      	mov	r8, r0
  44:	bbb0      	cbnz	r0, b4 <wc_HmacSetKey+0xb4>
    switch (hmac->macType) {
  46:	f894 3224 	ldrb.w	r3, [r4, #548]	; 0x224
  4a:	2b06      	cmp	r3, #6
    ip = (byte*)hmac->ipad;
  4c:	f104 07e0 	add.w	r7, r4, #224	; 0xe0
    switch (hmac->macType) {
  50:	d033      	beq.n	ba <wc_HmacSetKey+0xba>
  52:	2b08      	cmp	r3, #8
  54:	d041      	beq.n	da <wc_HmacSetKey+0xda>
  56:	2b04      	cmp	r3, #4
  58:	d157      	bne.n	10a <wc_HmacSetKey+0x10a>
            if (length <= WC_SHA_BLOCK_SIZE) {
  5a:	2d40      	cmp	r5, #64	; 0x40
  5c:	d809      	bhi.n	72 <wc_HmacSetKey+0x72>
                if (key != NULL) {
  5e:	b126      	cbz	r6, 6a <wc_HmacSetKey+0x6a>
                    XMEMCPY(ip, key, length);
  60:	462a      	mov	r2, r5
  62:	4631      	mov	r1, r6
  64:	4638      	mov	r0, r7
  66:	f7ff fffe 	bl	0 <memcpy>
            hmac_block_size = WC_SHA_BLOCK_SIZE;
  6a:	2640      	movs	r6, #64	; 0x40
        if (length < hmac_block_size)
  6c:	42b5      	cmp	r5, r6
  6e:	d214      	bcs.n	9a <wc_HmacSetKey+0x9a>
  70:	e00e      	b.n	90 <wc_HmacSetKey+0x90>
                ret = wc_ShaUpdate(&hmac->hash.sha, key, length);
  72:	462a      	mov	r2, r5
  74:	4631      	mov	r1, r6
  76:	4620      	mov	r0, r4
  78:	f7ff fffe 	bl	0 <wc_ShaUpdate>
                if (ret != 0)
  7c:	2800      	cmp	r0, #0
  7e:	d147      	bne.n	110 <wc_HmacSetKey+0x110>
                ret = wc_ShaFinal(&hmac->hash.sha, ip);
  80:	4639      	mov	r1, r7
  82:	4620      	mov	r0, r4
  84:	f7ff fffe 	bl	0 <wc_ShaFinal>
                if (ret != 0)
  88:	2800      	cmp	r0, #0
  8a:	d141      	bne.n	110 <wc_HmacSetKey+0x110>
            hmac_block_size = WC_SHA_BLOCK_SIZE;
  8c:	2640      	movs	r6, #64	; 0x40
                length = WC_SHA_DIGEST_SIZE;
  8e:	2514      	movs	r5, #20
            XMEMSET(ip + length, 0, hmac_block_size - length);
  90:	1b72      	subs	r2, r6, r5
  92:	2100      	movs	r1, #0
  94:	1978      	adds	r0, r7, r5
  96:	f7ff fffe 	bl	0 <memset>
  9a:	34df      	adds	r4, #223	; 0xdf
  9c:	4426      	add	r6, r4
            op[i] = (byte)(ip[i] ^ OPAD);
  9e:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  a2:	f083 025c 	eor.w	r2, r3, #92	; 0x5c
        for(i = 0; i < hmac_block_size; i++) {
  a6:	42b4      	cmp	r4, r6
            ip[i] ^= IPAD;
  a8:	f083 0336 	eor.w	r3, r3, #54	; 0x36
            op[i] = (byte)(ip[i] ^ OPAD);
  ac:	f884 2080 	strb.w	r2, [r4, #128]	; 0x80
            ip[i] ^= IPAD;
  b0:	7023      	strb	r3, [r4, #0]
        for(i = 0; i < hmac_block_size; i++) {
  b2:	d1f4      	bne.n	9e <wc_HmacSetKey+0x9e>
}
  b4:	4640      	mov	r0, r8
  b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if (length <= WC_SHA256_BLOCK_SIZE) {
  ba:	2d40      	cmp	r5, #64	; 0x40
  bc:	d9cf      	bls.n	5e <wc_HmacSetKey+0x5e>
                ret = wc_Sha256Update(&hmac->hash.sha256, key, length);
  be:	462a      	mov	r2, r5
  c0:	4631      	mov	r1, r6
  c2:	4620      	mov	r0, r4
  c4:	f7ff fffe 	bl	0 <wc_Sha256Update>
                if (ret != 0)
  c8:	bb10      	cbnz	r0, 110 <wc_HmacSetKey+0x110>
                ret = wc_Sha256Final(&hmac->hash.sha256, ip);
  ca:	4639      	mov	r1, r7
  cc:	4620      	mov	r0, r4
  ce:	f7ff fffe 	bl	0 <wc_Sha256Final>
                if (ret != 0)
  d2:	b9e8      	cbnz	r0, 110 <wc_HmacSetKey+0x110>
            hmac_block_size = WC_SHA256_BLOCK_SIZE;
  d4:	2640      	movs	r6, #64	; 0x40
                length = WC_SHA256_DIGEST_SIZE;
  d6:	2520      	movs	r5, #32
  d8:	e7da      	b.n	90 <wc_HmacSetKey+0x90>
            if (length <= WC_SHA512_BLOCK_SIZE) {
  da:	2d80      	cmp	r5, #128	; 0x80
  dc:	d807      	bhi.n	ee <wc_HmacSetKey+0xee>
                if (key != NULL) {
  de:	b126      	cbz	r6, ea <wc_HmacSetKey+0xea>
                    XMEMCPY(ip, key, length);
  e0:	462a      	mov	r2, r5
  e2:	4631      	mov	r1, r6
  e4:	4638      	mov	r0, r7
  e6:	f7ff fffe 	bl	0 <memcpy>
            hmac_block_size = WC_SHA512_BLOCK_SIZE;
  ea:	2680      	movs	r6, #128	; 0x80
  ec:	e7be      	b.n	6c <wc_HmacSetKey+0x6c>
                ret = wc_Sha512Update(&hmac->hash.sha512, key, length);
  ee:	462a      	mov	r2, r5
  f0:	4631      	mov	r1, r6
  f2:	4620      	mov	r0, r4
  f4:	f7ff fffe 	bl	0 <wc_Sha512Update>
                if (ret != 0)
  f8:	b950      	cbnz	r0, 110 <wc_HmacSetKey+0x110>
                ret = wc_Sha512Final(&hmac->hash.sha512, ip);
  fa:	4639      	mov	r1, r7
  fc:	4620      	mov	r0, r4
  fe:	f7ff fffe 	bl	0 <wc_Sha512Final>
                if (ret != 0)
 102:	b928      	cbnz	r0, 110 <wc_HmacSetKey+0x110>
            hmac_block_size = WC_SHA512_BLOCK_SIZE;
 104:	2680      	movs	r6, #128	; 0x80
                length = WC_SHA512_DIGEST_SIZE;
 106:	2540      	movs	r5, #64	; 0x40
 108:	e7c2      	b.n	90 <wc_HmacSetKey+0x90>
    switch (hmac->macType) {
 10a:	f06f 08ac 	mvn.w	r8, #172	; 0xac
 10e:	e7d1      	b.n	b4 <wc_HmacSetKey+0xb4>
    if (ret == 0) {
 110:	4680      	mov	r8, r0
 112:	e7cf      	b.n	b4 <wc_HmacSetKey+0xb4>

Disassembly of section .text.wolfSSL_GetHmacMaxSize:

00000000 <wolfSSL_GetHmacMaxSize>:
#endif /* WOLFSSL_KCAPI_HMAC */

int wolfSSL_GetHmacMaxSize(void)
{
    return WC_MAX_DIGEST_SIZE;
}
   0:	2040      	movs	r0, #64	; 0x40
   2:	4770      	bx	lr

kdf.o:     file format elf32-littlearm


Disassembly of section .text.wc_PRF:

00000000 <wc_PRF>:

/* Pseudo Random Function for MD5, SHA-1, SHA-256, SHA-384, or SHA-512 */
int wc_PRF(byte* result, word32 resLen, const byte* secret,
                  word32 secLen, const byte* seed, word32 seedLen, int hash,
                  void* heap, int devId)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b085      	sub	sp, #20
   6:	4692      	mov	sl, r2
   8:	9302      	str	r3, [sp, #8]
   a:	9b10      	ldr	r3, [sp, #64]	; 0x40
   c:	9003      	str	r0, [sp, #12]
    byte   previous[P_HASH_MAX_SIZE];  /* max size */
    byte   current[P_HASH_MAX_SIZE];   /* max size */
    Hmac   hmac[1];
#endif

    switch (hash) {
   e:	2b04      	cmp	r3, #4
  10:	d02d      	beq.n	6e <wc_PRF+0x6e>
  12:	2b06      	cmp	r3, #6
  14:	d02f      	beq.n	76 <wc_PRF+0x76>
  16:	2b02      	cmp	r3, #2
  18:	f040 80b9 	bne.w	18e <wc_PRF+0x18e>
    #endif

    #ifndef NO_SHA
        case sha_mac:
            hash = WC_SHA;
            len  = WC_SHA_DIGEST_SIZE;
  1c:	2714      	movs	r7, #20
            hash = WC_SHA;
  1e:	f04f 0904 	mov.w	r9, #4
    #endif
        default:
            return HASH_TYPE_E;
    }

    times   = resLen / len;
  22:	fbb1 f8f7 	udiv	r8, r1, r7
    lastLen = resLen % len;
  26:	fb07 1318 	mls	r3, r7, r8, r1
  2a:	9301      	str	r3, [sp, #4]

    if (lastLen)
  2c:	b33b      	cbz	r3, 7e <wc_PRF+0x7e>
        times += 1;
  2e:	f108 0801 	add.w	r8, r8, #1
        return BAD_FUNC_ARG;

    lastTime = times - 1;

#ifdef WOLFSSL_SMALL_STACK
    previous = (byte*)XMALLOC(P_HASH_MAX_SIZE, heap, DYNAMIC_TYPE_DIGEST);
  32:	2040      	movs	r0, #64	; 0x40
  34:	f7ff fffe 	bl	0 <malloc>
  38:	4606      	mov	r6, r0
    current  = (byte*)XMALLOC(P_HASH_MAX_SIZE, heap, DYNAMIC_TYPE_DIGEST);
  3a:	2040      	movs	r0, #64	; 0x40
  3c:	f7ff fffe 	bl	0 <malloc>
  40:	4605      	mov	r5, r0
    hmac     = (Hmac*)XMALLOC(sizeof(Hmac),    heap, DYNAMIC_TYPE_HMAC);
  42:	f44f 700a 	mov.w	r0, #552	; 0x228
  46:	f7ff fffe 	bl	0 <malloc>
  4a:	4604      	mov	r4, r0
    if (previous == NULL || current == NULL || hmac == NULL) {
  4c:	b126      	cbz	r6, 58 <wc_PRF+0x58>
  4e:	b105      	cbz	r5, 52 <wc_PRF+0x52>
  50:	b9d0      	cbnz	r0, 88 <wc_PRF+0x88>
        if (previous) XFREE(previous, heap, DYNAMIC_TYPE_DIGEST);
  52:	4630      	mov	r0, r6
  54:	f7ff fffe 	bl	0 <free>
        if (current)  XFREE(current,  heap, DYNAMIC_TYPE_DIGEST);
  58:	b115      	cbz	r5, 60 <wc_PRF+0x60>
  5a:	4628      	mov	r0, r5
  5c:	f7ff fffe 	bl	0 <free>
        if (hmac)     XFREE(hmac,     heap, DYNAMIC_TYPE_HMAC);
  60:	b114      	cbz	r4, 68 <wc_PRF+0x68>
  62:	4620      	mov	r0, r4
  64:	f7ff fffe 	bl	0 <free>
        return MEMORY_E;
  68:	f06f 0b7c 	mvn.w	fp, #124	; 0x7c
  6c:	e06f      	b.n	14e <wc_PRF+0x14e>
            len  = WC_SHA256_DIGEST_SIZE;
  6e:	2720      	movs	r7, #32
            hash = WC_SHA256;
  70:	f04f 0906 	mov.w	r9, #6
  74:	e7d5      	b.n	22 <wc_PRF+0x22>
    switch (hash) {
  76:	2740      	movs	r7, #64	; 0x40
  78:	f04f 0908 	mov.w	r9, #8
  7c:	e7d1      	b.n	22 <wc_PRF+0x22>
    if (times == 0)
  7e:	428f      	cmp	r7, r1
  80:	d9d7      	bls.n	32 <wc_PRF+0x32>
        return BAD_FUNC_ARG;
  82:	f06f 0bac 	mvn.w	fp, #172	; 0xac
  86:	e062      	b.n	14e <wc_PRF+0x14e>
    wc_MemZero_Add("wc_PRF previous", previous, P_HASH_MAX_SIZE);
    wc_MemZero_Add("wc_PRF current", current, P_HASH_MAX_SIZE);
    wc_MemZero_Add("wc_PRF hmac", hmac, sizeof(Hmac));
#endif

    ret = wc_HmacInit(hmac, heap, devId);
  88:	e9dd 1211 	ldrd	r1, r2, [sp, #68]	; 0x44
  8c:	f7ff fffe 	bl	0 <wc_HmacInit>
    if (ret == 0) {
  90:	4683      	mov	fp, r0
  92:	2800      	cmp	r0, #0
  94:	d140      	bne.n	118 <wc_PRF+0x118>
        ret = wc_HmacSetKey(hmac, hash, secret, secLen);
  96:	9b02      	ldr	r3, [sp, #8]
  98:	4652      	mov	r2, sl
  9a:	4649      	mov	r1, r9
  9c:	4620      	mov	r0, r4
  9e:	f7ff fffe 	bl	0 <wc_HmacSetKey>
        if (ret == 0)
  a2:	4683      	mov	fp, r0
  a4:	bba8      	cbnz	r0, 112 <wc_PRF+0x112>
            ret = wc_HmacUpdate(hmac, seed, seedLen); /* A0 = seed */
  a6:	e9dd 120e 	ldrd	r1, r2, [sp, #56]	; 0x38
  aa:	4620      	mov	r0, r4
  ac:	f7ff fffe 	bl	0 <wc_HmacUpdate>
        if (ret == 0)
  b0:	4683      	mov	fp, r0
  b2:	bb70      	cbnz	r0, 112 <wc_PRF+0x112>
            ret = wc_HmacFinal(hmac, previous);       /* A1 */
  b4:	4631      	mov	r1, r6
  b6:	4620      	mov	r0, r4
  b8:	f7ff fffe 	bl	0 <wc_HmacFinal>
        if (ret == 0) {
  bc:	4683      	mov	fp, r0
  be:	bb40      	cbnz	r0, 112 <wc_PRF+0x112>
    lastTime = times - 1;
  c0:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
  c4:	9302      	str	r3, [sp, #8]
            word32 i;
            word32 idx = 0;
  c6:	4682      	mov	sl, r0

            for (i = 0; i < times; i++) {
  c8:	4681      	mov	r9, r0
                ret = wc_HmacUpdate(hmac, previous, len);
  ca:	463a      	mov	r2, r7
  cc:	4631      	mov	r1, r6
  ce:	4620      	mov	r0, r4
  d0:	f7ff fffe 	bl	0 <wc_HmacUpdate>
                if (ret != 0)
  d4:	4683      	mov	fp, r0
  d6:	b9e0      	cbnz	r0, 112 <wc_PRF+0x112>
                    break;
                ret = wc_HmacUpdate(hmac, seed, seedLen);
  d8:	e9dd 120e 	ldrd	r1, r2, [sp, #56]	; 0x38
  dc:	4620      	mov	r0, r4
  de:	f7ff fffe 	bl	0 <wc_HmacUpdate>
                if (ret != 0)
  e2:	4683      	mov	fp, r0
  e4:	b9a8      	cbnz	r0, 112 <wc_PRF+0x112>
                    break;
                ret = wc_HmacFinal(hmac, current);
  e6:	4629      	mov	r1, r5
  e8:	4620      	mov	r0, r4
  ea:	f7ff fffe 	bl	0 <wc_HmacFinal>
                if (ret != 0)
  ee:	4683      	mov	fp, r0
  f0:	b978      	cbnz	r0, 112 <wc_PRF+0x112>
                    break;

                if ((i == lastTime) && lastLen)
                    XMEMCPY(&result[idx], current,
  f2:	9b03      	ldr	r3, [sp, #12]
  f4:	eb03 000a 	add.w	r0, r3, sl
                if ((i == lastTime) && lastLen)
  f8:	9b02      	ldr	r3, [sp, #8]
  fa:	454b      	cmp	r3, r9
  fc:	d12b      	bne.n	156 <wc_PRF+0x156>
  fe:	9b01      	ldr	r3, [sp, #4]
 100:	b34b      	cbz	r3, 156 <wc_PRF+0x156>
                    XMEMCPY(&result[idx], current,
 102:	461a      	mov	r2, r3
 104:	4629      	mov	r1, r5
 106:	f7ff fffe 	bl	0 <memcpy>
            for (i = 0; i < times; i++) {
 10a:	f109 0901 	add.w	r9, r9, #1
 10e:	45c1      	cmp	r9, r8
 110:	d3db      	bcc.n	ca <wc_PRF+0xca>
                    if (ret != 0)
                        break;
                }
            }
        }
        wc_HmacFree(hmac);
 112:	4620      	mov	r0, r4
 114:	f7ff fffe 	bl	0 <wc_HmacFree>
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
 118:	f106 0140 	add.w	r1, r6, #64	; 0x40
 11c:	4632      	mov	r2, r6
 11e:	2000      	movs	r0, #0
 120:	4291      	cmp	r1, r2
 122:	d12b      	bne.n	17c <wc_PRF+0x17c>
 124:	f105 0140 	add.w	r1, r5, #64	; 0x40
 128:	462a      	mov	r2, r5
 12a:	2000      	movs	r0, #0
 12c:	428a      	cmp	r2, r1
 12e:	d128      	bne.n	182 <wc_PRF+0x182>
 130:	f504 710a 	add.w	r1, r4, #552	; 0x228
 134:	4622      	mov	r2, r4
 136:	2000      	movs	r0, #0
 138:	428a      	cmp	r2, r1
 13a:	d125      	bne.n	188 <wc_PRF+0x188>
    wc_MemZero_Check(current,  P_HASH_MAX_SIZE);
    wc_MemZero_Check(hmac,     sizeof(Hmac));
#endif

#ifdef WOLFSSL_SMALL_STACK
    XFREE(previous, heap, DYNAMIC_TYPE_DIGEST);
 13c:	4630      	mov	r0, r6
 13e:	f7ff fffe 	bl	0 <free>
    XFREE(current,  heap, DYNAMIC_TYPE_DIGEST);
 142:	4628      	mov	r0, r5
 144:	f7ff fffe 	bl	0 <free>
    XFREE(hmac,     heap, DYNAMIC_TYPE_HMAC);
 148:	4620      	mov	r0, r4
 14a:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
}
 14e:	4658      	mov	r0, fp
 150:	b005      	add	sp, #20
 152:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    XMEMCPY(&result[idx], current, len);
 156:	463a      	mov	r2, r7
 158:	4629      	mov	r1, r5
 15a:	f7ff fffe 	bl	0 <memcpy>
                    ret = wc_HmacUpdate(hmac, previous, len);
 15e:	463a      	mov	r2, r7
 160:	4631      	mov	r1, r6
 162:	4620      	mov	r0, r4
                    idx += len;
 164:	44ba      	add	sl, r7
                    ret = wc_HmacUpdate(hmac, previous, len);
 166:	f7ff fffe 	bl	0 <wc_HmacUpdate>
                    if (ret != 0)
 16a:	b928      	cbnz	r0, 178 <wc_PRF+0x178>
                    ret = wc_HmacFinal(hmac, previous);
 16c:	4631      	mov	r1, r6
 16e:	4620      	mov	r0, r4
 170:	f7ff fffe 	bl	0 <wc_HmacFinal>
                    if (ret != 0)
 174:	2800      	cmp	r0, #0
 176:	d0c8      	beq.n	10a <wc_PRF+0x10a>
 178:	4683      	mov	fp, r0
 17a:	e7ca      	b.n	112 <wc_PRF+0x112>
 17c:	f802 0b01 	strb.w	r0, [r2], #1
 180:	e7ce      	b.n	120 <wc_PRF+0x120>
 182:	f802 0b01 	strb.w	r0, [r2], #1
 186:	e7d1      	b.n	12c <wc_PRF+0x12c>
 188:	f802 0b01 	strb.w	r0, [r2], #1
 18c:	e7d4      	b.n	138 <wc_PRF+0x138>
    switch (hash) {
 18e:	f06f 0be7 	mvn.w	fp, #231	; 0xe7
 192:	e7dc      	b.n	14e <wc_PRF+0x14e>

Disassembly of section .text.wc_PRF_TLSv1:

00000000 <wc_PRF_TLSv1>:

/* compute PRF (pseudo random function) using SHA1 and MD5 for TLSv1 */
int wc_PRF_TLSv1(byte* digest, word32 digLen, const byte* secret,
           word32 secLen, const byte* label, word32 labLen,
           const byte* seed, word32 seedLen, void* heap, int devId)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
#else
    byte       sha_result[MAX_PRF_DIG];    /* digLen is real size */
    byte       labelSeed[MAX_PRF_LABSEED];
#endif

    if (half > MAX_PRF_HALF ||
   2:	f240 2209 	movw	r2, #521	; 0x209
    word32      half = (secLen + 1) / 2;
   6:	3301      	adds	r3, #1
    if (half > MAX_PRF_HALF ||
   8:	4293      	cmp	r3, r2
{
   a:	9e07      	ldr	r6, [sp, #28]
   c:	9f09      	ldr	r7, [sp, #36]	; 0x24
    if (half > MAX_PRF_HALF ||
   e:	d829      	bhi.n	64 <wc_PRF_TLSv1+0x64>
        labLen + seedLen > MAX_PRF_LABSEED ||
  10:	19f3      	adds	r3, r6, r7
    if (half > MAX_PRF_HALF ||
  12:	2b80      	cmp	r3, #128	; 0x80
  14:	d826      	bhi.n	64 <wc_PRF_TLSv1+0x64>
        labLen + seedLen > MAX_PRF_LABSEED ||
  16:	29e0      	cmp	r1, #224	; 0xe0
  18:	d824      	bhi.n	64 <wc_PRF_TLSv1+0x64>
    {
        return BUFFER_E;
    }

#ifdef WOLFSSL_SMALL_STACK
    sha_result = (byte*)XMALLOC(MAX_PRF_DIG, heap, DYNAMIC_TYPE_DIGEST);
  1a:	20e0      	movs	r0, #224	; 0xe0
  1c:	f7ff fffe 	bl	0 <malloc>
  20:	4605      	mov	r5, r0
    labelSeed = (byte*)XMALLOC(MAX_PRF_LABSEED, heap, DYNAMIC_TYPE_DIGEST);
  22:	2080      	movs	r0, #128	; 0x80
  24:	f7ff fffe 	bl	0 <malloc>
  28:	4604      	mov	r4, r0
    if (sha_result == NULL || labelSeed == NULL) {
  2a:	b125      	cbz	r5, 36 <wc_PRF_TLSv1+0x36>
  2c:	b940      	cbnz	r0, 40 <wc_PRF_TLSv1+0x40>
        XFREE(sha_result, heap, DYNAMIC_TYPE_DIGEST);
  2e:	4628      	mov	r0, r5
        XFREE(labelSeed, heap, DYNAMIC_TYPE_DIGEST);
  30:	f7ff fffe 	bl	0 <free>
  34:	e001      	b.n	3a <wc_PRF_TLSv1+0x3a>
  36:	2800      	cmp	r0, #0
  38:	d1fa      	bne.n	30 <wc_PRF_TLSv1+0x30>
        return MEMORY_E;
  3a:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  3e:	e010      	b.n	62 <wc_PRF_TLSv1+0x62>

    md5_half = secret;
    sha_half = secret + half - secLen % 2;
    md5_result = digest;

    XMEMCPY(labelSeed, label, labLen);
  40:	9906      	ldr	r1, [sp, #24]
  42:	4632      	mov	r2, r6
  44:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(labelSeed + labLen, seed, seedLen);
  48:	9908      	ldr	r1, [sp, #32]
  4a:	463a      	mov	r2, r7
  4c:	19a0      	adds	r0, r4, r6
  4e:	f7ff fffe 	bl	0 <memcpy>
#if defined(WOLFSSL_CHECK_MEM_ZERO)
    wc_MemZero_Check(sha_result, MAX_PRF_DIG);
#endif

#ifdef WOLFSSL_SMALL_STACK
    XFREE(sha_result, heap, DYNAMIC_TYPE_DIGEST);
  52:	4628      	mov	r0, r5
  54:	f7ff fffe 	bl	0 <free>
    XFREE(labelSeed, heap, DYNAMIC_TYPE_DIGEST);
  58:	4620      	mov	r0, r4
  5a:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
  5e:	f06f 00e7 	mvn.w	r0, #231	; 0xe7
}
  62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BUFFER_E;
  64:	f06f 0083 	mvn.w	r0, #131	; 0x83
  68:	e7fb      	b.n	62 <wc_PRF_TLSv1+0x62>

Disassembly of section .text.wc_PRF_TLS:

00000000 <wc_PRF_TLS>:
/* Wrapper for TLS 1.2 and TLSv1 cases to calculate PRF */
/* In TLS 1.2 case call straight thru to wc_PRF */
int wc_PRF_TLS(byte* digest, word32 digLen, const byte* secret, word32 secLen,
            const byte* label, word32 labLen, const byte* seed, word32 seedLen,
            int useAtLeastSha256, int hash_type, void* heap, int devId)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b087      	sub	sp, #28
   6:	4617      	mov	r7, r2
   8:	e9dd 2b14 	ldrd	r2, fp, [sp, #80]	; 0x50
   c:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
  10:	4604      	mov	r4, r0
  12:	460e      	mov	r6, r1
  14:	4698      	mov	r8, r3
    int ret = 0;

    if (useAtLeastSha256) {
  16:	b3a2      	cbz	r2, 82 <wc_PRF_TLS+0x82>
        byte* labelSeed;
    #else
        byte  labelSeed[MAX_PRF_LABSEED];
    #endif

        if (labLen + seedLen > MAX_PRF_LABSEED) {
  18:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  1a:	eb09 0a03 	add.w	sl, r9, r3
  1e:	f1ba 0f80 	cmp.w	sl, #128	; 0x80
  22:	d831      	bhi.n	88 <wc_PRF_TLS+0x88>
            return BUFFER_E;
        }

    #ifdef WOLFSSL_SMALL_STACK
        labelSeed = (byte*)XMALLOC(MAX_PRF_LABSEED, heap, DYNAMIC_TYPE_DIGEST);
  24:	2080      	movs	r0, #128	; 0x80
  26:	f7ff fffe 	bl	0 <malloc>
        if (labelSeed == NULL) {
  2a:	4605      	mov	r5, r0
  2c:	b378      	cbz	r0, 8e <wc_PRF_TLS+0x8e>
            return MEMORY_E;
        }
    #endif

        XMEMCPY(labelSeed, label, labLen);
  2e:	9910      	ldr	r1, [sp, #64]	; 0x40
  30:	464a      	mov	r2, r9
  32:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(labelSeed + labLen, seed, seedLen);
  36:	e9dd 1212 	ldrd	r1, r2, [sp, #72]	; 0x48
  3a:	eb05 0009 	add.w	r0, r5, r9
  3e:	f7ff fffe 	bl	0 <memcpy>

        /* If a cipher suite wants an algorithm better than sha256, it
         * should use better. */
        if (hash_type < sha256_mac || hash_type == blake2b_mac) {
  42:	f1bb 0f03 	cmp.w	fp, #3
  46:	dd19      	ble.n	7c <wc_PRF_TLS+0x7c>
            hash_type = sha256_mac;
  48:	f1bb 0f08 	cmp.w	fp, #8
  4c:	bf08      	it	eq
  4e:	f04f 0b04 	moveq.w	fp, #4
        }
        /* compute PRF for MD5, SHA-1, SHA-256, or SHA-384 for TLSv1.2 PRF */
        ret = wc_PRF(digest, digLen, secret, secLen, labelSeed,
  52:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  54:	9204      	str	r2, [sp, #16]
  56:	9a16      	ldr	r2, [sp, #88]	; 0x58
  58:	4620      	mov	r0, r4
  5a:	e9cd b202 	strd	fp, r2, [sp, #8]
  5e:	e9cd 5a00 	strd	r5, sl, [sp]
  62:	4643      	mov	r3, r8
  64:	463a      	mov	r2, r7
  66:	4631      	mov	r1, r6
  68:	f7ff fffe 	bl	0 <wc_PRF_TLS>
  6c:	4604      	mov	r4, r0
                     labLen + seedLen, hash_type, heap, devId);

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(labelSeed, heap, DYNAMIC_TYPE_DIGEST);
  6e:	4628      	mov	r0, r5
  70:	f7ff fffe 	bl	0 <free>
        ret = BAD_FUNC_ARG;
#endif
    }

    return ret;
}
  74:	4620      	mov	r0, r4
  76:	b007      	add	sp, #28
  78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            hash_type = sha256_mac;
  7c:	f04f 0b04 	mov.w	fp, #4
  80:	e7e7      	b.n	52 <wc_PRF_TLS+0x52>
        ret = BAD_FUNC_ARG;
  82:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  86:	e7f5      	b.n	74 <wc_PRF_TLS+0x74>
            return BUFFER_E;
  88:	f06f 0483 	mvn.w	r4, #131	; 0x83
  8c:	e7f2      	b.n	74 <wc_PRF_TLS+0x74>
            return MEMORY_E;
  8e:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  92:	e7ef      	b.n	74 <wc_PRF_TLS+0x74>

random.o:     file format elf32-littlearm


Disassembly of section .text.wc_rng_new:

00000000 <wc_rng_new>:
}


WOLFSSL_ABI
WC_RNG* wc_rng_new(byte* nonce, word32 nonceSz, void* heap)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
    WC_RNG* rng;

    rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), heap, DYNAMIC_TYPE_RNG);
   4:	2008      	movs	r0, #8
{
   6:	460e      	mov	r6, r1
   8:	4615      	mov	r5, r2
    rng = (WC_RNG*)XMALLOC(sizeof(WC_RNG), heap, DYNAMIC_TYPE_RNG);
   a:	f7ff fffe 	bl	0 <malloc>
   e:	4603      	mov	r3, r0
    if (rng) {
  10:	b110      	cbz	r0, 18 <wc_rng_new+0x18>
    if (nonce == NULL && nonceSz != 0)
  12:	b904      	cbnz	r4, 16 <wc_rng_new+0x16>
  14:	b916      	cbnz	r6, 1c <wc_rng_new+0x1c>
    rng->heap = heap;
  16:	605d      	str	r5, [r3, #4]
            rng = NULL;
        }
    }

    return rng;
}
  18:	4618      	mov	r0, r3
  1a:	bd70      	pop	{r4, r5, r6, pc}
            XFREE(rng, heap, DYNAMIC_TYPE_RNG);
  1c:	f7ff fffe 	bl	0 <free>
            rng = NULL;
  20:	4623      	mov	r3, r4
    return rng;
  22:	e7f9      	b.n	18 <wc_rng_new+0x18>

Disassembly of section .text.wc_rng_free:

00000000 <wc_rng_free>:


WOLFSSL_ABI
void wc_rng_free(WC_RNG* rng)
{
    if (rng) {
   0:	b150      	cbz	r0, 18 <wc_rng_free+0x18>
   2:	f100 0208 	add.w	r2, r0, #8
   6:	4603      	mov	r3, r0
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
   8:	2100      	movs	r1, #0
   a:	4293      	cmp	r3, r2
   c:	d101      	bne.n	12 <wc_rng_free+0x12>
        void* heap = rng->heap;

        wc_FreeRng(rng);
        ForceZero(rng, sizeof(WC_RNG));
        XFREE(rng, heap, DYNAMIC_TYPE_RNG);
   e:	f7ff bffe 	b.w	0 <free>
  12:	f803 1b01 	strb.w	r1, [r3], #1
  16:	e7f8      	b.n	a <wc_rng_free+0xa>
        (void)heap;
    }
}
  18:	4770      	bx	lr

Disassembly of section .text.wc_InitRng:

00000000 <wc_InitRng>:
    if (rng == NULL)
   0:	4603      	mov	r3, r0
   2:	b110      	cbz	r0, a <wc_InitRng+0xa>
    rng->heap = heap;
   4:	2000      	movs	r0, #0
   6:	6058      	str	r0, [r3, #4]
    return ret;
   8:	4770      	bx	lr
        return BAD_FUNC_ARG;
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac

WOLFSSL_ABI
int wc_InitRng(WC_RNG* rng)
{
    return _InitRng(rng, NULL, 0, NULL, INVALID_DEVID);
}
   e:	4770      	bx	lr

Disassembly of section .text.wc_InitRng_ex:

00000000 <wc_InitRng_ex>:
    if (rng == NULL)
   0:	b110      	cbz	r0, 8 <wc_InitRng_ex+0x8>
    rng->heap = heap;
   2:	6041      	str	r1, [r0, #4]
    return ret;
   4:	2000      	movs	r0, #0
   6:	4770      	bx	lr
        return BAD_FUNC_ARG;
   8:	f06f 00ac 	mvn.w	r0, #172	; 0xac


int wc_InitRng_ex(WC_RNG* rng, void* heap, int devId)
{
    return _InitRng(rng, NULL, 0, heap, devId);
}
   c:	4770      	bx	lr

Disassembly of section .text.wc_InitRngNonce:

00000000 <wc_InitRngNonce>:
    if (rng == NULL)
   0:	4603      	mov	r3, r0
   2:	b120      	cbz	r0, e <wc_InitRngNonce+0xe>
    if (nonce == NULL && nonceSz != 0)
   4:	b901      	cbnz	r1, 8 <wc_InitRngNonce+0x8>
   6:	b912      	cbnz	r2, e <wc_InitRngNonce+0xe>
    rng->heap = heap;
   8:	2000      	movs	r0, #0
   a:	6058      	str	r0, [r3, #4]
    return ret;
   c:	4770      	bx	lr
        return BAD_FUNC_ARG;
   e:	f06f 00ac 	mvn.w	r0, #172	; 0xac


int wc_InitRngNonce(WC_RNG* rng, byte* nonce, word32 nonceSz)
{
    return _InitRng(rng, nonce, nonceSz, NULL, INVALID_DEVID);
}
  12:	4770      	bx	lr

Disassembly of section .text.wc_InitRngNonce_ex:

00000000 <wc_InitRngNonce_ex>:
    if (rng == NULL)
   0:	b120      	cbz	r0, c <wc_InitRngNonce_ex+0xc>
    if (nonce == NULL && nonceSz != 0)
   2:	b901      	cbnz	r1, 6 <wc_InitRngNonce_ex+0x6>
   4:	b912      	cbnz	r2, c <wc_InitRngNonce_ex+0xc>
    rng->heap = heap;
   6:	6043      	str	r3, [r0, #4]
    return ret;
   8:	2000      	movs	r0, #0
   a:	4770      	bx	lr
        return BAD_FUNC_ARG;
   c:	f06f 00ac 	mvn.w	r0, #172	; 0xac

int wc_InitRngNonce_ex(WC_RNG* rng, byte* nonce, word32 nonceSz,
                       void* heap, int devId)
{
    return _InitRng(rng, nonce, nonceSz, heap, devId);
}
  10:	4770      	bx	lr

Disassembly of section .text.wc_RNG_GenerateBlock:

00000000 <wc_RNG_GenerateBlock>:


/* place a generated block in output */
WOLFSSL_ABI
int wc_RNG_GenerateBlock(WC_RNG* rng, byte* output, word32 sz)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
    int ret;

    if (rng == NULL || output == NULL)
   6:	b158      	cbz	r0, 20 <wc_RNG_GenerateBlock+0x20>
   8:	b151      	cbz	r1, 20 <wc_RNG_GenerateBlock+0x20>
        return BAD_FUNC_ARG;

    if (sz == 0)
   a:	b162      	cbz	r2, 26 <wc_RNG_GenerateBlock+0x26>
    #endif
    }
#endif

#ifdef CUSTOM_RAND_GENERATE_BLOCK
    XMEMSET(output, 0, sz);
   c:	2100      	movs	r1, #0
   e:	4628      	mov	r0, r5
  10:	f7ff fffe 	bl	0 <memset>
    ret = (int)CUSTOM_RAND_GENERATE_BLOCK(output, sz);
  14:	4621      	mov	r1, r4
  16:	4628      	mov	r0, r5

#endif /* HAVE_HASHDRBG */
#endif /* CUSTOM_RAND_GENERATE_BLOCK */

    return ret;
}
  18:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = (int)CUSTOM_RAND_GENERATE_BLOCK(output, sz);
  1c:	f7ff bffe 	b.w	0 <my_rng_gen_block>
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  24:	bd38      	pop	{r3, r4, r5, pc}
        return 0;
  26:	4610      	mov	r0, r2
  28:	e7fc      	b.n	24 <wc_RNG_GenerateBlock+0x24>

Disassembly of section .text.wc_RNG_GenerateByte:

00000000 <wc_RNG_GenerateByte>:


int wc_RNG_GenerateByte(WC_RNG* rng, byte* b)
{
    return wc_RNG_GenerateBlock(rng, b, 1);
   0:	2201      	movs	r2, #1
   2:	f7ff bffe 	b.w	0 <wc_RNG_GenerateByte>

Disassembly of section .text.wc_FreeRng:

00000000 <wc_FreeRng>:
int wc_FreeRng(WC_RNG* rng)
{
    int ret = 0;

    if (rng == NULL)
        return BAD_FUNC_ARG;
   0:	2800      	cmp	r0, #0
    if (wc_VersalTrngReset() && !ret)
        ret = WC_HW_E;
#endif

    return ret;
}
   2:	bf0c      	ite	eq
   4:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   8:	2000      	movne	r0, #0
   a:	4770      	bx	lr

Disassembly of section .text.wc_GenerateSeed:

00000000 <wc_GenerateSeed>:
   /* Implement your own random generation function
    * word32 rand_gen(void);
    * #define CUSTOM_RAND_GENERATE  rand_gen  */

    int wc_GenerateSeed(OS_Seed* os, byte* output, word32 sz)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4615      	mov	r5, r2
        word32 i = 0;
   8:	2400      	movs	r4, #0

        (void)os;

        while (i < sz)
   a:	42ac      	cmp	r4, r5
   c:	d302      	bcc.n	14 <wc_GenerateSeed+0x14>
                i += sizeof(CUSTOM_RAND_TYPE);
            }
        }

        return 0;
    }
   e:	2000      	movs	r0, #0
  10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if( (i + sizeof(CUSTOM_RAND_TYPE)) > sz ||
  14:	1d27      	adds	r7, r4, #4
  16:	42af      	cmp	r7, r5
                ((wc_ptr_t)&output[i] % sizeof(CUSTOM_RAND_TYPE)) != 0
  18:	eb06 0804 	add.w	r8, r6, r4
            if( (i + sizeof(CUSTOM_RAND_TYPE)) > sz ||
  1c:	d802      	bhi.n	24 <wc_GenerateSeed+0x24>
  1e:	f018 0f03 	tst.w	r8, #3
  22:	d006      	beq.n	32 <wc_GenerateSeed+0x32>
                output[i++] = (byte)CUSTOM_RAND_GENERATE();
  24:	f7ff fffe 	bl	0 <my_rng_seed_gen>
  28:	1c67      	adds	r7, r4, #1
  2a:	f888 0000 	strb.w	r0, [r8]
    {
  2e:	463c      	mov	r4, r7
  30:	e7eb      	b.n	a <wc_GenerateSeed+0xa>
                *((CUSTOM_RAND_TYPE*)&output[i]) = CUSTOM_RAND_GENERATE();
  32:	f7ff fffe 	bl	0 <my_rng_seed_gen>
  36:	f8c8 0000 	str.w	r0, [r8]
                i += sizeof(CUSTOM_RAND_TYPE);
  3a:	e7f8      	b.n	2e <wc_GenerateSeed+0x2e>

rsa.o:     file format elf32-littlearm


sha.o:     file format elf32-littlearm


Disassembly of section .text.ByteReverseWords:

00000000 <ByteReverseWords>:
}
#endif /* __CCRX__ */
/* This routine performs a byte swap of words array of a given count. */
WC_MISC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
                                    word32 byteCount)
{
   0:	b510      	push	{r4, lr}
#ifdef WOLFSSL_USE_ALIGN
    if ((((size_t)in & 0x3) == 0) &&
        (((size_t)out & 0x3) == 0))
#endif
    {
        word32 count = byteCount/(word32)sizeof(word32);
   2:	0892      	lsrs	r2, r2, #2
        for (i = 0; i < count; i++)
   4:	2300      	movs	r3, #0
            out[i] = ByteReverseWord32(in[i]);
   6:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   a:	ba24      	rev	r4, r4
   c:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
        for (i = 0; i < count; i++)
  10:	3301      	adds	r3, #1
  12:	429a      	cmp	r2, r3
  14:	d1f7      	bne.n	6 <ByteReverseWords+0x6>
            scratch = ByteReverseWord32(scratch);
            XMEMCPY(out_bytes + i, &scratch, sizeof(scratch));
        }
    }
#endif
}
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.Transform:

00000000 <Transform>:
        rotlFixed((v),5); (w) = rotlFixed((w),30);
    #define R4(v,w,x,y,z,i) (z)+= f4((w),(x),(y)) + blk1((i)) + 0xCA62C1D6+ \
        rotlFixed((v),5); (w) = rotlFixed((w),30);

    static int Transform(wc_Sha* sha, const byte* data)
    {
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b097      	sub	sp, #92	; 0x5c
        word32 W[WC_SHA_BLOCK_SIZE / sizeof(word32)];

        /* Copy context->state[] to working vars */
        word32 a = sha->digest[0];
   6:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   8:	930d      	str	r3, [sp, #52]	; 0x34
        word32 b = sha->digest[1];
   a:	6d03      	ldr	r3, [r0, #80]	; 0x50
   c:	9301      	str	r3, [sp, #4]
        word32 c = sha->digest[2];
   e:	6d43      	ldr	r3, [r0, #84]	; 0x54
  10:	9305      	str	r3, [sp, #20]
        word32 d = sha->digest[3];
  12:	6d83      	ldr	r3, [r0, #88]	; 0x58
  14:	930e      	str	r3, [sp, #56]	; 0x38
        word32 e = sha->digest[4];
  16:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  18:	9312      	str	r3, [sp, #72]	; 0x48
            t = e; e = d; d = c; c = b; b = a; a = t;
        }
    #else
        /* nearly 1 K bigger in code size but 25% faster */
        /* 4 rounds of 20 operations each. Loop unrolled. */
        R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
  1a:	680b      	ldr	r3, [r1, #0]
  1c:	9306      	str	r3, [sp, #24]
        return (x << y) | (x >> (sizeof(x) * 8 - y));
  1e:	9a06      	ldr	r2, [sp, #24]
  20:	4bd9      	ldr	r3, [pc, #868]	; (388 <Transform+0x388>)
  22:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    {
  24:	9000      	str	r0, [sp, #0]
  26:	eb02 0e03 	add.w	lr, r2, r3
  2a:	9a12      	ldr	r2, [sp, #72]	; 0x48
        R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
  2c:	9805      	ldr	r0, [sp, #20]
  2e:	f8d1 a008 	ldr.w	sl, [r1, #8]
  32:	9d05      	ldr	r5, [sp, #20]
  34:	f8d1 900c 	ldr.w	r9, [r1, #12]
  38:	4496      	add	lr, r2
  3a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  3c:	eb0e 62f2 	add.w	r2, lr, r2, ror #27
  40:	ea80 0e04 	eor.w	lr, r0, r4
  44:	9801      	ldr	r0, [sp, #4]
  46:	ea0e 0e00 	and.w	lr, lr, r0
  4a:	ea8e 0e04 	eor.w	lr, lr, r4
  4e:	4496      	add	lr, r2
  50:	684a      	ldr	r2, [r1, #4]
  52:	9207      	str	r2, [sp, #28]
  54:	9801      	ldr	r0, [sp, #4]
  56:	9a05      	ldr	r2, [sp, #20]
  58:	ea82 00b0 	eor.w	r0, r2, r0, ror #2
  5c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  5e:	4010      	ands	r0, r2
  60:	9a05      	ldr	r2, [sp, #20]
  62:	4050      	eors	r0, r2
  64:	9a07      	ldr	r2, [sp, #28]
  66:	441a      	add	r2, r3
  68:	4422      	add	r2, r4
  6a:	4410      	add	r0, r2
  6c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  6e:	ea4f 04b2 	mov.w	r4, r2, ror #2
  72:	9a01      	ldr	r2, [sp, #4]
  74:	ea84 07b2 	eor.w	r7, r4, r2, ror #2
  78:	ea07 070e 	and.w	r7, r7, lr
  7c:	ea87 07b2 	eor.w	r7, r7, r2, ror #2
  80:	eb0a 0203 	add.w	r2, sl, r3
  84:	442a      	add	r2, r5
  86:	eb00 60fe 	add.w	r0, r0, lr, ror #27
  8a:	9d01      	ldr	r5, [sp, #4]
        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
  8c:	f8d1 b010 	ldr.w	fp, [r1, #16]
        R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
  90:	ea84 0cbe 	eor.w	ip, r4, lr, ror #2
  94:	4417      	add	r7, r2
  96:	eb07 67f0 	add.w	r7, r7, r0, ror #27
  9a:	eb09 0203 	add.w	r2, r9, r3
  9e:	ea0c 0c00 	and.w	ip, ip, r0
  a2:	ea4f 00b0 	mov.w	r0, r0, ror #2
  a6:	eb02 02b5 	add.w	r2, r2, r5, ror #2
        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
  aa:	ea80 06be 	eor.w	r6, r0, lr, ror #2
        R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
  ae:	ea8c 0c04 	eor.w	ip, ip, r4
  b2:	4494      	add	ip, r2
        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
  b4:	403e      	ands	r6, r7
  b6:	eb0b 0203 	add.w	r2, fp, r3
  ba:	4422      	add	r2, r4
  bc:	ea86 06be 	eor.w	r6, r6, lr, ror #2
  c0:	4416      	add	r6, r2
  c2:	694a      	ldr	r2, [r1, #20]
  c4:	920f      	str	r2, [sp, #60]	; 0x3c
        R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
  c6:	eb0c 6cf7 	add.w	ip, ip, r7, ror #27
        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
  ca:	ea80 04b7 	eor.w	r4, r0, r7, ror #2
  ce:	ea04 040c 	and.w	r4, r4, ip
  d2:	441a      	add	r2, r3
  d4:	eb02 02be 	add.w	r2, r2, lr, ror #2
  d8:	4044      	eors	r4, r0
  da:	eb06 66fc 	add.w	r6, r6, ip, ror #27
  de:	4414      	add	r4, r2
  e0:	ea4f 0cbc 	mov.w	ip, ip, ror #2
  e4:	698a      	ldr	r2, [r1, #24]
  e6:	9210      	str	r2, [sp, #64]	; 0x40
  e8:	ea8c 05b7 	eor.w	r5, ip, r7, ror #2
  ec:	4035      	ands	r5, r6
  ee:	441a      	add	r2, r3
  f0:	4402      	add	r2, r0
  f2:	ea85 05b7 	eor.w	r5, r5, r7, ror #2
  f6:	4415      	add	r5, r2
  f8:	69ca      	ldr	r2, [r1, #28]
  fa:	9211      	str	r2, [sp, #68]	; 0x44
  fc:	eb04 64f6 	add.w	r4, r4, r6, ror #27
 100:	ea8c 00b6 	eor.w	r0, ip, r6, ror #2
 104:	4020      	ands	r0, r4
 106:	441a      	add	r2, r3
        R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
 108:	f8d1 e020 	ldr.w	lr, [r1, #32]
        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
 10c:	eb05 65f4 	add.w	r5, r5, r4, ror #27
 110:	eb02 02b7 	add.w	r2, r2, r7, ror #2
 114:	ea4f 04b4 	mov.w	r4, r4, ror #2
 118:	ea80 000c 	eor.w	r0, r0, ip
 11c:	4410      	add	r0, r2
        R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
 11e:	ea84 02b6 	eor.w	r2, r4, r6, ror #2
 122:	eb0e 0703 	add.w	r7, lr, r3
 126:	402a      	ands	r2, r5
 128:	4467      	add	r7, ip
 12a:	ea82 02b6 	eor.w	r2, r2, r6, ror #2
 12e:	443a      	add	r2, r7
 130:	6a4f      	ldr	r7, [r1, #36]	; 0x24
 132:	9709      	str	r7, [sp, #36]	; 0x24
        R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
 134:	eb00 60f5 	add.w	r0, r0, r5, ror #27
        R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
 138:	ea84 0cb5 	eor.w	ip, r4, r5, ror #2
 13c:	441f      	add	r7, r3
 13e:	ea0c 0c00 	and.w	ip, ip, r0
 142:	eb07 06b6 	add.w	r6, r7, r6, ror #2
 146:	ea8c 0c04 	eor.w	ip, ip, r4
 14a:	eb02 62f0 	add.w	r2, r2, r0, ror #27
 14e:	44b4      	add	ip, r6
 150:	ea4f 00b0 	mov.w	r0, r0, ror #2
 154:	6a8e      	ldr	r6, [r1, #40]	; 0x28
 156:	960a      	str	r6, [sp, #40]	; 0x28
 158:	ea80 08b5 	eor.w	r8, r0, r5, ror #2
 15c:	441e      	add	r6, r3
 15e:	ea08 0802 	and.w	r8, r8, r2
 162:	4434      	add	r4, r6
 164:	ea88 08b5 	eor.w	r8, r8, r5, ror #2
 168:	44a0      	add	r8, r4
 16a:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 16c:	940b      	str	r4, [sp, #44]	; 0x2c
 16e:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 170:	eb0c 6cf2 	add.w	ip, ip, r2, ror #27
 174:	ea80 04b2 	eor.w	r4, r0, r2, ror #2
 178:	441e      	add	r6, r3
 17a:	ea04 040c 	and.w	r4, r4, ip
 17e:	eb06 05b5 	add.w	r5, r6, r5, ror #2
 182:	4044      	eors	r4, r0
 184:	eb08 68fc 	add.w	r8, r8, ip, ror #27
 188:	442c      	add	r4, r5
 18a:	ea4f 0cbc 	mov.w	ip, ip, ror #2
        R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
 18e:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 190:	950c      	str	r5, [sp, #48]	; 0x30
 192:	ea8c 07b2 	eor.w	r7, ip, r2, ror #2
 196:	441d      	add	r5, r3
 198:	ea07 0708 	and.w	r7, r7, r8
 19c:	4428      	add	r0, r5
 19e:	ea87 07b2 	eor.w	r7, r7, r2, ror #2
 1a2:	4407      	add	r7, r0
 1a4:	6b48      	ldr	r0, [r1, #52]	; 0x34
 1a6:	9002      	str	r0, [sp, #8]
 1a8:	9d02      	ldr	r5, [sp, #8]
        R0(c,d,e,a,b, 8); R0(b,c,d,e,a, 9); R0(a,b,c,d,e,10); R0(e,a,b,c,d,11);
 1aa:	eb04 64f8 	add.w	r4, r4, r8, ror #27
        R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
 1ae:	ea8c 00b8 	eor.w	r0, ip, r8, ror #2
 1b2:	441d      	add	r5, r3
 1b4:	4020      	ands	r0, r4
 1b6:	eb05 02b2 	add.w	r2, r5, r2, ror #2
 1ba:	ea80 000c 	eor.w	r0, r0, ip
 1be:	eb07 67f4 	add.w	r7, r7, r4, ror #27
 1c2:	4410      	add	r0, r2
 1c4:	ea4f 04b4 	mov.w	r4, r4, ror #2
 1c8:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 1ca:	9203      	str	r2, [sp, #12]
 1cc:	ea84 06b8 	eor.w	r6, r4, r8, ror #2
 1d0:	403e      	ands	r6, r7
 1d2:	441a      	add	r2, r3
 1d4:	4462      	add	r2, ip
 1d6:	ea86 06b8 	eor.w	r6, r6, r8, ror #2
 1da:	4416      	add	r6, r2
 1dc:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 1de:	9204      	str	r2, [sp, #16]
 1e0:	eb00 60f7 	add.w	r0, r0, r7, ror #27
 1e4:	ea84 01b7 	eor.w	r1, r4, r7, ror #2
 1e8:	4001      	ands	r1, r0
 1ea:	441a      	add	r2, r3
 1ec:	eb02 02b8 	add.w	r2, r2, r8, ror #2
 1f0:	4061      	eors	r1, r4
 1f2:	4411      	add	r1, r2

        R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
 1f4:	9a06      	ldr	r2, [sp, #24]
 1f6:	9d02      	ldr	r5, [sp, #8]
 1f8:	ea82 020a 	eor.w	r2, r2, sl
        R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
 1fc:	eb06 66f0 	add.w	r6, r6, r0, ror #27
        R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
 200:	ea82 020e 	eor.w	r2, r2, lr
 204:	ea4f 00b0 	mov.w	r0, r0, ror #2
 208:	406a      	eors	r2, r5
 20a:	ea80 05b7 	eor.w	r5, r0, r7, ror #2
 20e:	9206      	str	r2, [sp, #24]
 210:	4035      	ands	r5, r6
 212:	eb03 72f2 	add.w	r2, r3, r2, ror #31
 216:	4422      	add	r2, r4
 218:	ea85 05b7 	eor.w	r5, r5, r7, ror #2
 21c:	4415      	add	r5, r2
 21e:	9a07      	ldr	r2, [sp, #28]
 220:	ea82 0c09 	eor.w	ip, r2, r9
 224:	9a09      	ldr	r2, [sp, #36]	; 0x24
 226:	ea8c 0c02 	eor.w	ip, ip, r2
 22a:	9a03      	ldr	r2, [sp, #12]
        R0(d,e,a,b,c,12); R0(c,d,e,a,b,13); R0(b,c,d,e,a,14); R0(a,b,c,d,e,15);
 22c:	eb01 61f6 	add.w	r1, r1, r6, ror #27
        R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
 230:	ea8c 0202 	eor.w	r2, ip, r2
 234:	ea80 04b6 	eor.w	r4, r0, r6, ror #2
 238:	9207      	str	r2, [sp, #28]
 23a:	400c      	ands	r4, r1
 23c:	eb03 72f2 	add.w	r2, r3, r2, ror #31
 240:	eb02 02b7 	add.w	r2, r2, r7, ror #2
 244:	4044      	eors	r4, r0
 246:	4414      	add	r4, r2
 248:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 24a:	ea8a 0a0b 	eor.w	sl, sl, fp
 24e:	ea8a 0a02 	eor.w	sl, sl, r2
 252:	9a04      	ldr	r2, [sp, #16]
 254:	ea8a 0a02 	eor.w	sl, sl, r2
 258:	eb05 65f1 	add.w	r5, r5, r1, ror #27
 25c:	ea4f 72fa 	mov.w	r2, sl, ror #31
 260:	ea4f 01b1 	mov.w	r1, r1, ror #2
 264:	9213      	str	r2, [sp, #76]	; 0x4c
 266:	ea81 02b6 	eor.w	r2, r1, r6, ror #2
 26a:	eb03 77fa 	add.w	r7, r3, sl, ror #31
 26e:	402a      	ands	r2, r5
 270:	4438      	add	r0, r7
 272:	ea82 02b6 	eor.w	r2, r2, r6, ror #2
 276:	4402      	add	r2, r0
 278:	980f      	ldr	r0, [sp, #60]	; 0x3c
 27a:	ea89 0700 	eor.w	r7, r9, r0
 27e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 280:	4047      	eors	r7, r0
 282:	9806      	ldr	r0, [sp, #24]
 284:	ea87 77f0 	eor.w	r7, r7, r0, ror #31
 288:	ea4f 70f7 	mov.w	r0, r7, ror #31
 28c:	eb04 64f5 	add.w	r4, r4, r5, ror #27
 290:	9014      	str	r0, [sp, #80]	; 0x50
 292:	ea81 00b5 	eor.w	r0, r1, r5, ror #2
 296:	4020      	ands	r0, r4
 298:	eb03 73f7 	add.w	r3, r3, r7, ror #31
 29c:	eb03 03b6 	add.w	r3, r3, r6, ror #2
 2a0:	4048      	eors	r0, r1
 2a2:	4418      	add	r0, r3

        R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
 2a4:	9b10      	ldr	r3, [sp, #64]	; 0x40
 2a6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 2a8:	ea8b 0303 	eor.w	r3, fp, r3
 2ac:	4073      	eors	r3, r6
 2ae:	9e07      	ldr	r6, [sp, #28]
 2b0:	ea83 73f6 	eor.w	r3, r3, r6, ror #31
 2b4:	9308      	str	r3, [sp, #32]
 2b6:	9e08      	ldr	r6, [sp, #32]
 2b8:	4b34      	ldr	r3, [pc, #208]	; (38c <Transform+0x38c>)
        R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
 2ba:	eb02 62f4 	add.w	r2, r2, r4, ror #27
 2be:	ea4f 04b4 	mov.w	r4, r4, ror #2
        R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
 2c2:	ea84 0bb5 	eor.w	fp, r4, r5, ror #2
 2c6:	eb03 76f6 	add.w	r6, r3, r6, ror #31
 2ca:	4431      	add	r1, r6
 2cc:	ea8b 0b02 	eor.w	fp, fp, r2
 2d0:	9e11      	ldr	r6, [sp, #68]	; 0x44
 2d2:	448b      	add	fp, r1
 2d4:	990f      	ldr	r1, [sp, #60]	; 0x3c
 2d6:	4071      	eors	r1, r6
 2d8:	9e02      	ldr	r6, [sp, #8]
 2da:	4071      	eors	r1, r6
 2dc:	ea81 71fa 	eor.w	r1, r1, sl, ror #31
        R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);
 2e0:	eb00 60f2 	add.w	r0, r0, r2, ror #27
        R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
 2e4:	eb03 76f1 	add.w	r6, r3, r1, ror #31
 2e8:	ea84 0cb2 	eor.w	ip, r4, r2, ror #2
 2ec:	eb06 05b5 	add.w	r5, r6, r5, ror #2
 2f0:	ea8c 0c00 	eor.w	ip, ip, r0
 2f4:	44ac      	add	ip, r5
 2f6:	9d10      	ldr	r5, [sp, #64]	; 0x40
 2f8:	9e03      	ldr	r6, [sp, #12]
 2fa:	ea85 050e 	eor.w	r5, r5, lr
 2fe:	4075      	eors	r5, r6
 300:	ea85 75f7 	eor.w	r5, r5, r7, ror #31
 304:	eb0b 6bf0 	add.w	fp, fp, r0, ror #27
 308:	ea4f 76f5 	mov.w	r6, r5, ror #31
 30c:	ea4f 00b0 	mov.w	r0, r0, ror #2
 310:	9610      	str	r6, [sp, #64]	; 0x40
 312:	ea80 08b2 	eor.w	r8, r0, r2, ror #2
 316:	eb03 76f5 	add.w	r6, r3, r5, ror #31
 31a:	4434      	add	r4, r6
 31c:	ea88 080b 	eor.w	r8, r8, fp
 320:	9e09      	ldr	r6, [sp, #36]	; 0x24
 322:	44a0      	add	r8, r4
 324:	9c11      	ldr	r4, [sp, #68]	; 0x44
 326:	4066      	eors	r6, r4
 328:	9c04      	ldr	r4, [sp, #16]
 32a:	4066      	eors	r6, r4
 32c:	9c08      	ldr	r4, [sp, #32]
 32e:	ea86 76f4 	eor.w	r6, r6, r4, ror #31
 332:	ea4f 74f6 	mov.w	r4, r6, ror #31
 336:	eb0c 6cfb 	add.w	ip, ip, fp, ror #27
 33a:	9411      	str	r4, [sp, #68]	; 0x44
 33c:	ea80 09bb 	eor.w	r9, r0, fp, ror #2
 340:	eb03 74f6 	add.w	r4, r3, r6, ror #31
 344:	eb04 02b2 	add.w	r2, r4, r2, ror #2
 348:	ea89 090c 	eor.w	r9, r9, ip
 34c:	4491      	add	r9, r2
        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
 34e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 350:	9c06      	ldr	r4, [sp, #24]
 352:	ea8e 0202 	eor.w	r2, lr, r2
 356:	ea82 72f4 	eor.w	r2, r2, r4, ror #31
        R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
 35a:	eb08 68fc 	add.w	r8, r8, ip, ror #27
        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
 35e:	ea82 72f1 	eor.w	r2, r2, r1, ror #31
 362:	ea4f 0cbc 	mov.w	ip, ip, ror #2
 366:	eb03 7ef2 	add.w	lr, r3, r2, ror #31
 36a:	ea8c 04bb 	eor.w	r4, ip, fp, ror #2
 36e:	4470      	add	r0, lr
 370:	ea84 0408 	eor.w	r4, r4, r8
 374:	f8dd e02c 	ldr.w	lr, [sp, #44]	; 0x2c
 378:	4404      	add	r4, r0
 37a:	9809      	ldr	r0, [sp, #36]	; 0x24
 37c:	ea80 000e 	eor.w	r0, r0, lr
 380:	f8dd e01c 	ldr.w	lr, [sp, #28]
 384:	e004      	b.n	390 <Transform+0x390>
 386:	bf00      	nop
 388:	5a827999 	.word	0x5a827999
 38c:	6ed9eba1 	.word	0x6ed9eba1
 390:	ea80 70fe 	eor.w	r0, r0, lr, ror #31
 394:	ea80 70f5 	eor.w	r0, r0, r5, ror #31
        R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);
 398:	eb09 69f8 	add.w	r9, r9, r8, ror #27
        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
 39c:	9009      	str	r0, [sp, #36]	; 0x24
 39e:	ea8c 0eb8 	eor.w	lr, ip, r8, ror #2
 3a2:	eb03 70f0 	add.w	r0, r3, r0, ror #31
 3a6:	eb00 00bb 	add.w	r0, r0, fp, ror #2
 3aa:	ea8e 0e09 	eor.w	lr, lr, r9
 3ae:	4486      	add	lr, r0
 3b0:	ea4f 00b9 	mov.w	r0, r9, ror #2
 3b4:	eb04 64f9 	add.w	r4, r4, r9, ror #27
 3b8:	900f      	str	r0, [sp, #60]	; 0x3c
 3ba:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
 3be:	980a      	ldr	r0, [sp, #40]	; 0x28
 3c0:	ea80 0909 	eor.w	r9, r0, r9
 3c4:	ea89 7afa 	eor.w	sl, r9, sl, ror #31
 3c8:	ea8a 7af6 	eor.w	sl, sl, r6, ror #31
 3cc:	ea4f 70fa 	mov.w	r0, sl, ror #31
 3d0:	9015      	str	r0, [sp, #84]	; 0x54
 3d2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 3d4:	eb03 79fa 	add.w	r9, r3, sl, ror #31
 3d8:	ea80 0bb8 	eor.w	fp, r0, r8, ror #2
 3dc:	44cc      	add	ip, r9
 3de:	ea8b 0b04 	eor.w	fp, fp, r4
 3e2:	980b      	ldr	r0, [sp, #44]	; 0x2c
 3e4:	44e3      	add	fp, ip
 3e6:	f8dd c008 	ldr.w	ip, [sp, #8]
 3ea:	ea80 090c 	eor.w	r9, r0, ip
 3ee:	ea89 77f7 	eor.w	r7, r9, r7, ror #31
 3f2:	ea87 77f2 	eor.w	r7, r7, r2, ror #31
 3f6:	ea4f 70f7 	mov.w	r0, r7, ror #31
 3fa:	900b      	str	r0, [sp, #44]	; 0x2c
 3fc:	980f      	ldr	r0, [sp, #60]	; 0x3c
 3fe:	eb0e 6ef4 	add.w	lr, lr, r4, ror #27
 402:	eb03 79f7 	add.w	r9, r3, r7, ror #31
 406:	ea80 0cb4 	eor.w	ip, r0, r4, ror #2
 40a:	eb09 08b8 	add.w	r8, r9, r8, ror #2
 40e:	ea8c 0c0e 	eor.w	ip, ip, lr
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 412:	980c      	ldr	r0, [sp, #48]	; 0x30
        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
 414:	44c4      	add	ip, r8
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 416:	f8dd 800c 	ldr.w	r8, [sp, #12]
 41a:	ea80 0808 	eor.w	r8, r0, r8
 41e:	9808      	ldr	r0, [sp, #32]
 420:	ea88 78f0 	eor.w	r8, r8, r0, ror #31
 424:	9809      	ldr	r0, [sp, #36]	; 0x24
 426:	ea88 70f0 	eor.w	r0, r8, r0, ror #31
        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
 42a:	eb0b 6bfe 	add.w	fp, fp, lr, ror #27
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 42e:	900a      	str	r0, [sp, #40]	; 0x28
 430:	ea4f 0ebe 	mov.w	lr, lr, ror #2
 434:	eb03 79f0 	add.w	r9, r3, r0, ror #31
 438:	980f      	ldr	r0, [sp, #60]	; 0x3c
 43a:	ea8e 08b4 	eor.w	r8, lr, r4, ror #2
 43e:	4448      	add	r0, r9
 440:	ea88 080b 	eor.w	r8, r8, fp
 444:	f8dd 9010 	ldr.w	r9, [sp, #16]
 448:	4480      	add	r8, r0
 44a:	9802      	ldr	r0, [sp, #8]
 44c:	ea80 0009 	eor.w	r0, r0, r9
 450:	ea80 70f1 	eor.w	r0, r0, r1, ror #31
 454:	ea80 70fa 	eor.w	r0, r0, sl, ror #31
        R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);
 458:	eb0c 6cfb 	add.w	ip, ip, fp, ror #27
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 45c:	9002      	str	r0, [sp, #8]
 45e:	ea8e 09bb 	eor.w	r9, lr, fp, ror #2
 462:	eb03 70f0 	add.w	r0, r3, r0, ror #31
 466:	eb00 00b4 	add.w	r0, r0, r4, ror #2
 46a:	ea89 090c 	eor.w	r9, r9, ip
 46e:	9c06      	ldr	r4, [sp, #24]
 470:	4481      	add	r9, r0
 472:	9803      	ldr	r0, [sp, #12]
 474:	ea80 70f4 	eor.w	r0, r0, r4, ror #31
 478:	ea80 75f5 	eor.w	r5, r0, r5, ror #31
 47c:	ea85 75f7 	eor.w	r5, r5, r7, ror #31
 480:	eb08 68fc 	add.w	r8, r8, ip, ror #27
 484:	ea4f 70f5 	mov.w	r0, r5, ror #31
 488:	ea4f 0cbc 	mov.w	ip, ip, ror #2
 48c:	900c      	str	r0, [sp, #48]	; 0x30
 48e:	ea8c 04bb 	eor.w	r4, ip, fp, ror #2
 492:	eb03 70f5 	add.w	r0, r3, r5, ror #31
 496:	4470      	add	r0, lr
 498:	ea84 0408 	eor.w	r4, r4, r8
 49c:	f8dd e01c 	ldr.w	lr, [sp, #28]
 4a0:	4404      	add	r4, r0
 4a2:	9804      	ldr	r0, [sp, #16]
 4a4:	ea80 70fe 	eor.w	r0, r0, lr, ror #31
 4a8:	ea80 70f6 	eor.w	r0, r0, r6, ror #31
 4ac:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 4ae:	ea80 70f6 	eor.w	r0, r0, r6, ror #31
 4b2:	ea4f 76f0 	mov.w	r6, r0, ror #31
 4b6:	eb09 69f8 	add.w	r9, r9, r8, ror #27
 4ba:	960f      	str	r6, [sp, #60]	; 0x3c
 4bc:	eb03 7ef0 	add.w	lr, r3, r0, ror #31
 4c0:	ea8c 06b8 	eor.w	r6, ip, r8, ror #2
 4c4:	eb0e 0ebb 	add.w	lr, lr, fp, ror #2
 4c8:	ea86 0609 	eor.w	r6, r6, r9
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 4cc:	f8dd b018 	ldr.w	fp, [sp, #24]
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 4d0:	4476      	add	r6, lr
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 4d2:	f8dd e04c 	ldr.w	lr, [sp, #76]	; 0x4c
 4d6:	ea8e 7efb 	eor.w	lr, lr, fp, ror #31
 4da:	f8dd b008 	ldr.w	fp, [sp, #8]
 4de:	ea8e 7ef2 	eor.w	lr, lr, r2, ror #31
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 4e2:	eb04 64f9 	add.w	r4, r4, r9, ror #27
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 4e6:	ea8e 7efb 	eor.w	lr, lr, fp, ror #31
 4ea:	ea4f 09b9 	mov.w	r9, r9, ror #2
 4ee:	f8cd e00c 	str.w	lr, [sp, #12]
 4f2:	ea89 0bb8 	eor.w	fp, r9, r8, ror #2
 4f6:	eb03 7efe 	add.w	lr, r3, lr, ror #31
 4fa:	44f4      	add	ip, lr
 4fc:	ea8b 0b04 	eor.w	fp, fp, r4
 500:	f8dd e01c 	ldr.w	lr, [sp, #28]
 504:	44e3      	add	fp, ip
 506:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
 50a:	ea8c 7cfe 	eor.w	ip, ip, lr, ror #31
 50e:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
 512:	ea8c 7cfe 	eor.w	ip, ip, lr, ror #31
 516:	ea8c 7cf5 	eor.w	ip, ip, r5, ror #31
        R2(c,d,e,a,b,28); R2(b,c,d,e,a,29); R2(a,b,c,d,e,30); R2(e,a,b,c,d,31);
 51a:	eb06 66f4 	add.w	r6, r6, r4, ror #27
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 51e:	f8cd c010 	str.w	ip, [sp, #16]
 522:	ea89 0eb4 	eor.w	lr, r9, r4, ror #2
 526:	eb03 7cfc 	add.w	ip, r3, ip, ror #31
 52a:	eb0c 0cb8 	add.w	ip, ip, r8, ror #2
 52e:	ea8e 0e06 	eor.w	lr, lr, r6
 532:	eb0b 6bf6 	add.w	fp, fp, r6, ror #27
 536:	ea4f 08b6 	mov.w	r8, r6, ror #2
 53a:	44e6      	add	lr, ip
 53c:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 53e:	f8dd c020 	ldr.w	ip, [sp, #32]
 542:	ea86 76fc 	eor.w	r6, r6, ip, ror #31
 546:	ea86 7afa 	eor.w	sl, r6, sl, ror #31
 54a:	ea8a 7af0 	eor.w	sl, sl, r0, ror #31
 54e:	ea4f 76fa 	mov.w	r6, sl, ror #31
 552:	9613      	str	r6, [sp, #76]	; 0x4c
 554:	eb03 7cfa 	add.w	ip, r3, sl, ror #31
 558:	ea88 06b4 	eor.w	r6, r8, r4, ror #2
 55c:	44cc      	add	ip, r9
 55e:	ea86 060b 	eor.w	r6, r6, fp
 562:	4466      	add	r6, ip
 564:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
 568:	ea8c 79f1 	eor.w	r9, ip, r1, ror #31
 56c:	ea89 79f7 	eor.w	r9, r9, r7, ror #31
 570:	9f03      	ldr	r7, [sp, #12]
 572:	ea89 79f7 	eor.w	r9, r9, r7, ror #31
 576:	ea4f 77f9 	mov.w	r7, r9, ror #31
 57a:	eb0e 6efb 	add.w	lr, lr, fp, ror #27
 57e:	eb03 7cf9 	add.w	ip, r3, r9, ror #31
 582:	9714      	str	r7, [sp, #80]	; 0x50
 584:	ea88 07bb 	eor.w	r7, r8, fp, ror #2
 588:	eb0c 04b4 	add.w	r4, ip, r4, ror #2
 58c:	ea87 070e 	eor.w	r7, r7, lr
        R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
 590:	f8dd c020 	ldr.w	ip, [sp, #32]
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 594:	4427      	add	r7, r4
        R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
 596:	9c10      	ldr	r4, [sp, #64]	; 0x40
 598:	ea84 74fc 	eor.w	r4, r4, ip, ror #31
 59c:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 5a0:	ea84 74fc 	eor.w	r4, r4, ip, ror #31
 5a4:	f8dd c010 	ldr.w	ip, [sp, #16]
 5a8:	ea84 74fc 	eor.w	r4, r4, ip, ror #31
 5ac:	9406      	str	r4, [sp, #24]
 5ae:	f8dd c018 	ldr.w	ip, [sp, #24]
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 5b2:	eb06 66fe 	add.w	r6, r6, lr, ror #27
 5b6:	ea4f 0ebe 	mov.w	lr, lr, ror #2
        R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
 5ba:	ea8e 04bb 	eor.w	r4, lr, fp, ror #2
 5be:	eb03 7cfc 	add.w	ip, r3, ip, ror #31
 5c2:	44c4      	add	ip, r8
 5c4:	4074      	eors	r4, r6
 5c6:	4464      	add	r4, ip
 5c8:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
 5cc:	ea8c 71f1 	eor.w	r1, ip, r1, ror #31
 5d0:	f8dd c008 	ldr.w	ip, [sp, #8]
 5d4:	ea81 71fc 	eor.w	r1, r1, ip, ror #31
 5d8:	ea81 71fa 	eor.w	r1, r1, sl, ror #31
        R2(d,e,a,b,c,32); R2(c,d,e,a,b,33); R2(b,c,d,e,a,34); R2(a,b,c,d,e,35);
 5dc:	eb07 67f6 	add.w	r7, r7, r6, ror #27
        R2(e,a,b,c,d,36); R2(d,e,a,b,c,37); R2(c,d,e,a,b,38); R2(b,c,d,e,a,39);
 5e0:	9107      	str	r1, [sp, #28]
 5e2:	ea8e 0cb6 	eor.w	ip, lr, r6, ror #2
 5e6:	eb03 71f1 	add.w	r1, r3, r1, ror #31
 5ea:	eb01 01bb 	add.w	r1, r1, fp, ror #2
 5ee:	ea8c 0c07 	eor.w	ip, ip, r7
 5f2:	448c      	add	ip, r1
 5f4:	9910      	ldr	r1, [sp, #64]	; 0x40
 5f6:	ea81 78f2 	eor.w	r8, r1, r2, ror #31
 5fa:	ea88 78f5 	eor.w	r8, r8, r5, ror #31
 5fe:	ea88 78f9 	eor.w	r8, r8, r9, ror #31
 602:	eb04 64f7 	add.w	r4, r4, r7, ror #27
 606:	ea4f 71f8 	mov.w	r1, r8, ror #31
 60a:	ea4f 07b7 	mov.w	r7, r7, ror #2
 60e:	9110      	str	r1, [sp, #64]	; 0x40
 610:	ea87 0bb6 	eor.w	fp, r7, r6, ror #2
 614:	eb03 71f8 	add.w	r1, r3, r8, ror #31
 618:	4471      	add	r1, lr
 61a:	ea8b 0b04 	eor.w	fp, fp, r4
 61e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 620:	448b      	add	fp, r1
 622:	9911      	ldr	r1, [sp, #68]	; 0x44
 624:	ea81 71f5 	eor.w	r1, r1, r5, ror #31
 628:	ea81 70f0 	eor.w	r0, r1, r0, ror #31
 62c:	9906      	ldr	r1, [sp, #24]
 62e:	ea80 70f1 	eor.w	r0, r0, r1, ror #31
 632:	eb0c 6cf4 	add.w	ip, ip, r4, ror #27
 636:	ea87 0eb4 	eor.w	lr, r7, r4, ror #2
 63a:	eb03 73f0 	add.w	r3, r3, r0, ror #31
 63e:	ea8e 0e0c 	eor.w	lr, lr, ip
 642:	eb03 03b6 	add.w	r3, r3, r6, ror #2
 646:	eb0b 6bfc 	add.w	fp, fp, ip, ror #27
 64a:	4473      	add	r3, lr
 64c:	eb03 6efb 	add.w	lr, r3, fp, ror #27

        R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
 650:	9b15      	ldr	r3, [sp, #84]	; 0x54
 652:	ea83 72f2 	eor.w	r2, r3, r2, ror #31
 656:	9b03      	ldr	r3, [sp, #12]
 658:	ea82 72f3 	eor.w	r2, r2, r3, ror #31
 65c:	9b07      	ldr	r3, [sp, #28]
 65e:	ea82 73f3 	eor.w	r3, r2, r3, ror #31
 662:	ea4b 02bc 	orr.w	r2, fp, ip, ror #2
 666:	9308      	str	r3, [sp, #32]
 668:	ea4f 71f0 	mov.w	r1, r0, ror #31
 66c:	ea0b 03bc 	and.w	r3, fp, ip, ror #2
 670:	ea02 02b4 	and.w	r2, r2, r4, ror #2
 674:	9111      	str	r1, [sp, #68]	; 0x44
 676:	431a      	orrs	r2, r3
 678:	9908      	ldr	r1, [sp, #32]
 67a:	4bd9      	ldr	r3, [pc, #868]	; (9e0 <Transform+0x9e0>)
 67c:	eb03 71f1 	add.w	r1, r3, r1, ror #31
 680:	4439      	add	r1, r7
 682:	440a      	add	r2, r1
 684:	990b      	ldr	r1, [sp, #44]	; 0x2c
 686:	ea81 76f5 	eor.w	r6, r1, r5, ror #31
 68a:	9904      	ldr	r1, [sp, #16]
 68c:	ea86 76f1 	eor.w	r6, r6, r1, ror #31
 690:	ea86 71f8 	eor.w	r1, r6, r8, ror #31
 694:	9109      	str	r1, [sp, #36]	; 0x24
 696:	ea4e 01bb 	orr.w	r1, lr, fp, ror #2
 69a:	ea01 05bc 	and.w	r5, r1, ip, ror #2
 69e:	ea0e 01bb 	and.w	r1, lr, fp, ror #2
 6a2:	4329      	orrs	r1, r5
 6a4:	9d09      	ldr	r5, [sp, #36]	; 0x24
 6a6:	eb03 75f5 	add.w	r5, r3, r5, ror #31
 6aa:	eb05 04b4 	add.w	r4, r5, r4, ror #2
 6ae:	4421      	add	r1, r4
 6b0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 6b2:	9c15      	ldr	r4, [sp, #84]	; 0x54
 6b4:	ea84 74f5 	eor.w	r4, r4, r5, ror #31
 6b8:	ea84 7afa 	eor.w	sl, r4, sl, ror #31
 6bc:	eb02 62fe 	add.w	r2, r2, lr, ror #27
 6c0:	ea8a 7af0 	eor.w	sl, sl, r0, ror #31
 6c4:	ea42 07be 	orr.w	r7, r2, lr, ror #2
 6c8:	ea4f 74fa 	mov.w	r4, sl, ror #31
 6cc:	9415      	str	r4, [sp, #84]	; 0x54
 6ce:	ea07 04bb 	and.w	r4, r7, fp, ror #2
 6d2:	ea02 07be 	and.w	r7, r2, lr, ror #2
 6d6:	4327      	orrs	r7, r4
 6d8:	eb03 74fa 	add.w	r4, r3, sl, ror #31
 6dc:	9d02      	ldr	r5, [sp, #8]
 6de:	eb04 0cbc 	add.w	ip, r4, ip, ror #2
 6e2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 6e4:	ea84 74f5 	eor.w	r4, r4, r5, ror #31
 6e8:	ea84 79f9 	eor.w	r9, r4, r9, ror #31
 6ec:	9c08      	ldr	r4, [sp, #32]
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 6ee:	9d0a      	ldr	r5, [sp, #40]	; 0x28
        R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
 6f0:	eb01 61f2 	add.w	r1, r1, r2, ror #27
 6f4:	ea89 79f4 	eor.w	r9, r9, r4, ror #31
 6f8:	ea41 06b2 	orr.w	r6, r1, r2, ror #2
 6fc:	ea4f 74f9 	mov.w	r4, r9, ror #31
 700:	940b      	str	r4, [sp, #44]	; 0x2c
 702:	ea06 04be 	and.w	r4, r6, lr, ror #2
 706:	ea01 06b2 	and.w	r6, r1, r2, ror #2
 70a:	4326      	orrs	r6, r4
 70c:	eb03 74f9 	add.w	r4, r3, r9, ror #31
 710:	eb04 04bb 	add.w	r4, r4, fp, ror #2
 714:	4426      	add	r6, r4
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 716:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 718:	ea84 74f5 	eor.w	r4, r4, r5, ror #31
 71c:	9d06      	ldr	r5, [sp, #24]
        R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
 71e:	4467      	add	r7, ip
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 720:	ea84 74f5 	eor.w	r4, r4, r5, ror #31
 724:	9d09      	ldr	r5, [sp, #36]	; 0x24
 726:	f8dd c008 	ldr.w	ip, [sp, #8]
        R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
 72a:	eb07 67f1 	add.w	r7, r7, r1, ror #27
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 72e:	ea84 74f5 	eor.w	r4, r4, r5, ror #31
 732:	ea47 05b1 	orr.w	r5, r7, r1, ror #2
 736:	940a      	str	r4, [sp, #40]	; 0x28
 738:	ea05 04b2 	and.w	r4, r5, r2, ror #2
 73c:	ea07 05b1 	and.w	r5, r7, r1, ror #2
 740:	4325      	orrs	r5, r4
 742:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 744:	eb03 74f4 	add.w	r4, r3, r4, ror #31
 748:	eb04 04be 	add.w	r4, r4, lr, ror #2
 74c:	4425      	add	r5, r4
 74e:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 750:	ea84 74fc 	eor.w	r4, r4, ip, ror #31
 754:	f8dd c01c 	ldr.w	ip, [sp, #28]
        R3(a,b,c,d,e,40); R3(e,a,b,c,d,41); R3(d,e,a,b,c,42); R3(c,d,e,a,b,43);
 758:	eb06 66f7 	add.w	r6, r6, r7, ror #27
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 75c:	ea84 74fc 	eor.w	r4, r4, ip, ror #31
 760:	ea46 0eb7 	orr.w	lr, r6, r7, ror #2
 764:	ea84 74fa 	eor.w	r4, r4, sl, ror #31
 768:	9402      	str	r4, [sp, #8]
 76a:	ea0e 04b1 	and.w	r4, lr, r1, ror #2
 76e:	ea06 0eb7 	and.w	lr, r6, r7, ror #2
 772:	ea44 0e0e 	orr.w	lr, r4, lr
 776:	9c02      	ldr	r4, [sp, #8]
 778:	eb03 74f4 	add.w	r4, r3, r4, ror #31
 77c:	eb04 02b2 	add.w	r2, r4, r2, ror #2
 780:	4496      	add	lr, r2
 782:	9c03      	ldr	r4, [sp, #12]
 784:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 786:	ea82 7cf4 	eor.w	ip, r2, r4, ror #31
 78a:	ea8c 78f8 	eor.w	r8, ip, r8, ror #31
 78e:	eb05 65f6 	add.w	r5, r5, r6, ror #27
 792:	ea88 78f9 	eor.w	r8, r8, r9, ror #31
 796:	ea45 04b6 	orr.w	r4, r5, r6, ror #2
 79a:	ea4f 72f8 	mov.w	r2, r8, ror #31
 79e:	920c      	str	r2, [sp, #48]	; 0x30
 7a0:	ea04 02b7 	and.w	r2, r4, r7, ror #2
 7a4:	ea05 04b6 	and.w	r4, r5, r6, ror #2
 7a8:	4314      	orrs	r4, r2
 7aa:	eb03 72f8 	add.w	r2, r3, r8, ror #31
 7ae:	eb02 02b1 	add.w	r2, r2, r1, ror #2
 7b2:	4414      	add	r4, r2
 7b4:	9904      	ldr	r1, [sp, #16]
 7b6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 7b8:	ea82 71f1 	eor.w	r1, r2, r1, ror #31
 7bc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 7be:	ea81 71f0 	eor.w	r1, r1, r0, ror #31
 7c2:	eb0e 6ef5 	add.w	lr, lr, r5, ror #27
 7c6:	ea81 71f2 	eor.w	r1, r1, r2, ror #31
 7ca:	ea4e 0cb5 	orr.w	ip, lr, r5, ror #2
 7ce:	ea4f 72f1 	mov.w	r2, r1, ror #31
 7d2:	920f      	str	r2, [sp, #60]	; 0x3c
 7d4:	ea0c 02b6 	and.w	r2, ip, r6, ror #2
 7d8:	ea0e 0cb5 	and.w	ip, lr, r5, ror #2
 7dc:	ea42 0c0c 	orr.w	ip, r2, ip
 7e0:	eb03 72f1 	add.w	r2, r3, r1, ror #31
 7e4:	eb02 02b7 	add.w	r2, r2, r7, ror #2
        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
 7e8:	9803      	ldr	r0, [sp, #12]
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 7ea:	4494      	add	ip, r2
        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
 7ec:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 7ee:	ea82 72f0 	eor.w	r2, r2, r0, ror #31
 7f2:	9808      	ldr	r0, [sp, #32]
 7f4:	ea82 72f0 	eor.w	r2, r2, r0, ror #31
 7f8:	9802      	ldr	r0, [sp, #8]
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 7fa:	eb04 64fe 	add.w	r4, r4, lr, ror #27
        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
 7fe:	ea82 72f0 	eor.w	r2, r2, r0, ror #31
 802:	9203      	str	r2, [sp, #12]
 804:	ea44 02be 	orr.w	r2, r4, lr, ror #2
 808:	ea02 00b5 	and.w	r0, r2, r5, ror #2
 80c:	ea04 02be 	and.w	r2, r4, lr, ror #2
 810:	4302      	orrs	r2, r0
 812:	9803      	ldr	r0, [sp, #12]
 814:	eb03 70f0 	add.w	r0, r3, r0, ror #31
 818:	eb00 00b6 	add.w	r0, r0, r6, ror #2
 81c:	4402      	add	r2, r0
 81e:	9e04      	ldr	r6, [sp, #16]
 820:	9814      	ldr	r0, [sp, #80]	; 0x50
 822:	ea80 70f6 	eor.w	r0, r0, r6, ror #31
 826:	9e09      	ldr	r6, [sp, #36]	; 0x24
        R3(b,c,d,e,a,44); R3(a,b,c,d,e,45); R3(e,a,b,c,d,46); R3(d,e,a,b,c,47);
 828:	eb0c 6cf4 	add.w	ip, ip, r4, ror #27
        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
 82c:	ea80 70f6 	eor.w	r0, r0, r6, ror #31
 830:	ea4c 0bb4 	orr.w	fp, ip, r4, ror #2
 834:	ea80 70f8 	eor.w	r0, r0, r8, ror #31
 838:	9004      	str	r0, [sp, #16]
 83a:	ea0b 00be 	and.w	r0, fp, lr, ror #2
 83e:	ea0c 0bb4 	and.w	fp, ip, r4, ror #2
 842:	ea40 0b0b 	orr.w	fp, r0, fp
 846:	9804      	ldr	r0, [sp, #16]
 848:	eb03 70f0 	add.w	r0, r3, r0, ror #31
 84c:	eb00 00b5 	add.w	r0, r0, r5, ror #2
 850:	4483      	add	fp, r0
 852:	9813      	ldr	r0, [sp, #76]	; 0x4c
 854:	9d06      	ldr	r5, [sp, #24]
 856:	ea80 70f5 	eor.w	r0, r0, r5, ror #31
 85a:	ea80 7afa 	eor.w	sl, r0, sl, ror #31
 85e:	eb02 62fc 	add.w	r2, r2, ip, ror #27
 862:	ea8a 7af1 	eor.w	sl, sl, r1, ror #31
 866:	ea42 07bc 	orr.w	r7, r2, ip, ror #2
 86a:	ea4f 70fa 	mov.w	r0, sl, ror #31
 86e:	9013      	str	r0, [sp, #76]	; 0x4c
 870:	ea07 00b4 	and.w	r0, r7, r4, ror #2
 874:	ea02 07bc 	and.w	r7, r2, ip, ror #2
 878:	4307      	orrs	r7, r0
 87a:	eb03 70fa 	add.w	r0, r3, sl, ror #31
 87e:	eb00 00be 	add.w	r0, r0, lr, ror #2
 882:	9d07      	ldr	r5, [sp, #28]
 884:	4407      	add	r7, r0
 886:	9814      	ldr	r0, [sp, #80]	; 0x50
 888:	ea80 70f5 	eor.w	r0, r0, r5, ror #31
 88c:	ea80 79f9 	eor.w	r9, r0, r9, ror #31
 890:	9803      	ldr	r0, [sp, #12]
 892:	eb0b 6bf2 	add.w	fp, fp, r2, ror #27
 896:	ea89 79f0 	eor.w	r9, r9, r0, ror #31
 89a:	ea4b 06b2 	orr.w	r6, fp, r2, ror #2
 89e:	ea4f 70f9 	mov.w	r0, r9, ror #31
 8a2:	9014      	str	r0, [sp, #80]	; 0x50
 8a4:	ea06 00bc 	and.w	r0, r6, ip, ror #2
 8a8:	ea0b 06b2 	and.w	r6, fp, r2, ror #2
 8ac:	4306      	orrs	r6, r0
 8ae:	eb03 70f9 	add.w	r0, r3, r9, ror #31
 8b2:	eb00 00b4 	add.w	r0, r0, r4, ror #2
 8b6:	4406      	add	r6, r0
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 8b8:	9c06      	ldr	r4, [sp, #24]
 8ba:	9810      	ldr	r0, [sp, #64]	; 0x40
 8bc:	ea80 74f4 	eor.w	r4, r0, r4, ror #31
 8c0:	980a      	ldr	r0, [sp, #40]	; 0x28
 8c2:	ea84 74f0 	eor.w	r4, r4, r0, ror #31
 8c6:	9804      	ldr	r0, [sp, #16]
        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
 8c8:	eb07 67fb 	add.w	r7, r7, fp, ror #27
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 8cc:	ea47 05bb 	orr.w	r5, r7, fp, ror #2
 8d0:	ea84 70f0 	eor.w	r0, r4, r0, ror #31
 8d4:	9006      	str	r0, [sp, #24]
 8d6:	ea05 00b2 	and.w	r0, r5, r2, ror #2
 8da:	ea07 05bb 	and.w	r5, r7, fp, ror #2
 8de:	4305      	orrs	r5, r0
 8e0:	9806      	ldr	r0, [sp, #24]
 8e2:	9c07      	ldr	r4, [sp, #28]
 8e4:	eb03 70f0 	add.w	r0, r3, r0, ror #31
 8e8:	eb00 00bc 	add.w	r0, r0, ip, ror #2
 8ec:	4405      	add	r5, r0
 8ee:	9811      	ldr	r0, [sp, #68]	; 0x44
 8f0:	ea80 70f4 	eor.w	r0, r0, r4, ror #31
 8f4:	9c02      	ldr	r4, [sp, #8]
 8f6:	ea80 70f4 	eor.w	r0, r0, r4, ror #31
        R3(c,d,e,a,b,48); R3(b,c,d,e,a,49); R3(a,b,c,d,e,50); R3(e,a,b,c,d,51);
 8fa:	eb06 66f7 	add.w	r6, r6, r7, ror #27
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 8fe:	ea80 70fa 	eor.w	r0, r0, sl, ror #31
 902:	9007      	str	r0, [sp, #28]
 904:	ea46 00b7 	orr.w	r0, r6, r7, ror #2
 908:	ea00 04bb 	and.w	r4, r0, fp, ror #2
 90c:	ea06 00b7 	and.w	r0, r6, r7, ror #2
 910:	4320      	orrs	r0, r4
 912:	9c07      	ldr	r4, [sp, #28]
 914:	eb03 74f4 	add.w	r4, r3, r4, ror #31
 918:	eb04 02b2 	add.w	r2, r4, r2, ror #2
 91c:	4410      	add	r0, r2
 91e:	9c08      	ldr	r4, [sp, #32]
 920:	9a10      	ldr	r2, [sp, #64]	; 0x40
 922:	ea82 7cf4 	eor.w	ip, r2, r4, ror #31
 926:	ea8c 7cf8 	eor.w	ip, ip, r8, ror #31
 92a:	eb05 65f6 	add.w	r5, r5, r6, ror #27
 92e:	ea8c 7cf9 	eor.w	ip, ip, r9, ror #31
 932:	ea45 08b6 	orr.w	r8, r5, r6, ror #2
 936:	ea4f 72fc 	mov.w	r2, ip, ror #31
 93a:	9210      	str	r2, [sp, #64]	; 0x40
 93c:	ea08 02b7 	and.w	r2, r8, r7, ror #2
 940:	ea05 08b6 	and.w	r8, r5, r6, ror #2
 944:	ea42 0808 	orr.w	r8, r2, r8
 948:	eb03 72fc 	add.w	r2, r3, ip, ror #31
 94c:	eb02 02bb 	add.w	r2, r2, fp, ror #2
 950:	9c09      	ldr	r4, [sp, #36]	; 0x24
 952:	4490      	add	r8, r2
 954:	9a11      	ldr	r2, [sp, #68]	; 0x44
 956:	ea82 7bf4 	eor.w	fp, r2, r4, ror #31
 95a:	9a06      	ldr	r2, [sp, #24]
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 95c:	9c08      	ldr	r4, [sp, #32]
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 95e:	ea8b 7bf1 	eor.w	fp, fp, r1, ror #31
 962:	eb00 60f5 	add.w	r0, r0, r5, ror #27
 966:	ea8b 7bf2 	eor.w	fp, fp, r2, ror #31
 96a:	ea40 01b5 	orr.w	r1, r0, r5, ror #2
 96e:	ea4f 72fb 	mov.w	r2, fp, ror #31
 972:	9211      	str	r2, [sp, #68]	; 0x44
 974:	ea01 02b6 	and.w	r2, r1, r6, ror #2
 978:	ea00 01b5 	and.w	r1, r0, r5, ror #2
 97c:	4311      	orrs	r1, r2
 97e:	eb03 72fb 	add.w	r2, r3, fp, ror #31
 982:	eb02 07b7 	add.w	r7, r2, r7, ror #2
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 986:	9a15      	ldr	r2, [sp, #84]	; 0x54
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 988:	4439      	add	r1, r7
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 98a:	ea82 77f4 	eor.w	r7, r2, r4, ror #31
 98e:	9a03      	ldr	r2, [sp, #12]
 990:	9c09      	ldr	r4, [sp, #36]	; 0x24
 992:	ea87 77f2 	eor.w	r7, r7, r2, ror #31
 996:	9a07      	ldr	r2, [sp, #28]
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 998:	eb08 68f0 	add.w	r8, r8, r0, ror #27
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 99c:	ea48 0eb0 	orr.w	lr, r8, r0, ror #2
 9a0:	ea87 72f2 	eor.w	r2, r7, r2, ror #31
 9a4:	9208      	str	r2, [sp, #32]
 9a6:	ea0e 02b5 	and.w	r2, lr, r5, ror #2
 9aa:	ea08 0eb0 	and.w	lr, r8, r0, ror #2
 9ae:	ea42 0e0e 	orr.w	lr, r2, lr
 9b2:	9a08      	ldr	r2, [sp, #32]
 9b4:	eb03 72f2 	add.w	r2, r3, r2, ror #31
 9b8:	eb02 02b6 	add.w	r2, r2, r6, ror #2
 9bc:	4496      	add	lr, r2
 9be:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 9c0:	ea82 76f4 	eor.w	r6, r2, r4, ror #31
 9c4:	9a04      	ldr	r2, [sp, #16]
 9c6:	ea86 76f2 	eor.w	r6, r6, r2, ror #31
        R3(d,e,a,b,c,52); R3(c,d,e,a,b,53); R3(b,c,d,e,a,54); R3(a,b,c,d,e,55);
 9ca:	eb01 61f8 	add.w	r1, r1, r8, ror #27
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 9ce:	ea86 72fc 	eor.w	r2, r6, ip, ror #31
 9d2:	9209      	str	r2, [sp, #36]	; 0x24
 9d4:	ea41 02b8 	orr.w	r2, r1, r8, ror #2
 9d8:	ea02 04b0 	and.w	r4, r2, r0, ror #2
 9dc:	e002      	b.n	9e4 <Transform+0x9e4>
 9de:	bf00      	nop
 9e0:	8f1bbcdc 	.word	0x8f1bbcdc
 9e4:	ea01 02b8 	and.w	r2, r1, r8, ror #2
 9e8:	4322      	orrs	r2, r4
 9ea:	9c09      	ldr	r4, [sp, #36]	; 0x24

        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
 9ec:	9e03      	ldr	r6, [sp, #12]
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 9ee:	eb03 74f4 	add.w	r4, r3, r4, ror #31
 9f2:	eb04 05b5 	add.w	r5, r4, r5, ror #2
 9f6:	4415      	add	r5, r2
 9f8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 9fa:	9a15      	ldr	r2, [sp, #84]	; 0x54
 9fc:	ea82 72f4 	eor.w	r2, r2, r4, ror #31
 a00:	ea82 7afa 	eor.w	sl, r2, sl, ror #31
 a04:	ea8a 7afb 	eor.w	sl, sl, fp, ror #31
 a08:	eb0e 6ef1 	add.w	lr, lr, r1, ror #27
 a0c:	ea4f 72fa 	mov.w	r2, sl, ror #31
 a10:	9215      	str	r2, [sp, #84]	; 0x54
 a12:	ea4e 02b1 	orr.w	r2, lr, r1, ror #2
 a16:	ea02 04b8 	and.w	r4, r2, r8, ror #2
 a1a:	ea0e 02b1 	and.w	r2, lr, r1, ror #2
 a1e:	4322      	orrs	r2, r4
 a20:	eb03 74fa 	add.w	r4, r3, sl, ror #31
 a24:	eb04 00b0 	add.w	r0, r4, r0, ror #2
 a28:	4402      	add	r2, r0
 a2a:	9c02      	ldr	r4, [sp, #8]
 a2c:	980b      	ldr	r0, [sp, #44]	; 0x2c
 a2e:	ea80 70f4 	eor.w	r0, r0, r4, ror #31
 a32:	ea80 79f9 	eor.w	r9, r0, r9, ror #31
 a36:	9808      	ldr	r0, [sp, #32]
 a38:	eb05 65fe 	add.w	r5, r5, lr, ror #27
 a3c:	ea89 79f0 	eor.w	r9, r9, r0, ror #31
 a40:	ea4f 70f9 	mov.w	r0, r9, ror #31
 a44:	ea45 04be 	orr.w	r4, r5, lr, ror #2
 a48:	900b      	str	r0, [sp, #44]	; 0x2c
 a4a:	ea04 04b1 	and.w	r4, r4, r1, ror #2
 a4e:	ea05 00be 	and.w	r0, r5, lr, ror #2
 a52:	eb03 73f9 	add.w	r3, r3, r9, ror #31
 a56:	eb03 03b8 	add.w	r3, r3, r8, ror #2
 a5a:	4320      	orrs	r0, r4
 a5c:	4418      	add	r0, r3
        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
 a5e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 a60:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 a62:	ea83 78f4 	eor.w	r8, r3, r4, ror #31
 a66:	9b06      	ldr	r3, [sp, #24]
 a68:	ea88 78f3 	eor.w	r8, r8, r3, ror #31
 a6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 a6e:	ea88 73f3 	eor.w	r3, r8, r3, ror #31
 a72:	930a      	str	r3, [sp, #40]	; 0x28
 a74:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 a76:	4bd8      	ldr	r3, [pc, #864]	; (dd8 <Transform+0xdd8>)
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 a78:	eb02 62f5 	add.w	r2, r2, r5, ror #27
 a7c:	ea4f 05b5 	mov.w	r5, r5, ror #2
        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
 a80:	ea85 07be 	eor.w	r7, r5, lr, ror #2
 a84:	eb03 74f4 	add.w	r4, r3, r4, ror #31
 a88:	eb04 01b1 	add.w	r1, r4, r1, ror #2
 a8c:	4057      	eors	r7, r2
 a8e:	9c02      	ldr	r4, [sp, #8]
 a90:	440f      	add	r7, r1
 a92:	990f      	ldr	r1, [sp, #60]	; 0x3c
 a94:	ea81 71f4 	eor.w	r1, r1, r4, ror #31
 a98:	9c07      	ldr	r4, [sp, #28]
 a9a:	ea81 71f4 	eor.w	r1, r1, r4, ror #31
 a9e:	ea81 71fa 	eor.w	r1, r1, sl, ror #31
        R3(e,a,b,c,d,56); R3(d,e,a,b,c,57); R3(c,d,e,a,b,58); R3(b,c,d,e,a,59);
 aa2:	eb00 60f2 	add.w	r0, r0, r2, ror #27
        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
 aa6:	9102      	str	r1, [sp, #8]
 aa8:	ea85 04b2 	eor.w	r4, r5, r2, ror #2
 aac:	eb03 71f1 	add.w	r1, r3, r1, ror #31
 ab0:	eb01 01be 	add.w	r1, r1, lr, ror #2
 ab4:	4044      	eors	r4, r0
 ab6:	440c      	add	r4, r1
 ab8:	990c      	ldr	r1, [sp, #48]	; 0x30
 aba:	ea81 7ef6 	eor.w	lr, r1, r6, ror #31
 abe:	ea8e 7efc 	eor.w	lr, lr, ip, ror #31
 ac2:	ea8e 7ef9 	eor.w	lr, lr, r9, ror #31
 ac6:	eb07 67f0 	add.w	r7, r7, r0, ror #27
 aca:	ea4f 71fe 	mov.w	r1, lr, ror #31
 ace:	ea4f 00b0 	mov.w	r0, r0, ror #2
 ad2:	910c      	str	r1, [sp, #48]	; 0x30
 ad4:	ea80 0cb2 	eor.w	ip, r0, r2, ror #2
 ad8:	eb03 71fe 	add.w	r1, r3, lr, ror #31
 adc:	4429      	add	r1, r5
 ade:	ea8c 0c07 	eor.w	ip, ip, r7
 ae2:	9d04      	ldr	r5, [sp, #16]
 ae4:	448c      	add	ip, r1
 ae6:	990f      	ldr	r1, [sp, #60]	; 0x3c
 ae8:	ea81 71f5 	eor.w	r1, r1, r5, ror #31
 aec:	ea81 7bfb 	eor.w	fp, r1, fp, ror #31
 af0:	990a      	ldr	r1, [sp, #40]	; 0x28
 af2:	ea8b 7bf1 	eor.w	fp, fp, r1, ror #31
 af6:	ea4f 71fb 	mov.w	r1, fp, ror #31
 afa:	eb04 64f7 	add.w	r4, r4, r7, ror #27
 afe:	eb03 75fb 	add.w	r5, r3, fp, ror #31
 b02:	910f      	str	r1, [sp, #60]	; 0x3c
 b04:	ea80 01b7 	eor.w	r1, r0, r7, ror #2
 b08:	eb05 02b2 	add.w	r2, r5, r2, ror #2
 b0c:	4061      	eors	r1, r4
 b0e:	4411      	add	r1, r2
        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
 b10:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 b12:	9d08      	ldr	r5, [sp, #32]
 b14:	ea82 72f6 	eor.w	r2, r2, r6, ror #31
 b18:	ea82 72f5 	eor.w	r2, r2, r5, ror #31
 b1c:	9d02      	ldr	r5, [sp, #8]
        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
 b1e:	eb0c 6cf4 	add.w	ip, ip, r4, ror #27
        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
 b22:	ea82 72f5 	eor.w	r2, r2, r5, ror #31
 b26:	ea4f 04b4 	mov.w	r4, r4, ror #2
 b2a:	9203      	str	r2, [sp, #12]
 b2c:	ea84 08b7 	eor.w	r8, r4, r7, ror #2
 b30:	eb03 72f2 	add.w	r2, r3, r2, ror #31
 b34:	4402      	add	r2, r0
 b36:	ea88 080c 	eor.w	r8, r8, ip
 b3a:	4490      	add	r8, r2
 b3c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 b3e:	9804      	ldr	r0, [sp, #16]
 b40:	ea82 72f0 	eor.w	r2, r2, r0, ror #31
 b44:	9809      	ldr	r0, [sp, #36]	; 0x24
 b46:	ea82 72f0 	eor.w	r2, r2, r0, ror #31
 b4a:	ea82 72fe 	eor.w	r2, r2, lr, ror #31
 b4e:	9204      	str	r2, [sp, #16]
        R4(a,b,c,d,e,60); R4(e,a,b,c,d,61); R4(d,e,a,b,c,62); R4(c,d,e,a,b,63);
 b50:	eb01 61fc 	add.w	r1, r1, ip, ror #27
        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
 b54:	ea84 06bc 	eor.w	r6, r4, ip, ror #2
 b58:	eb03 72f2 	add.w	r2, r3, r2, ror #31
 b5c:	eb02 02b7 	add.w	r2, r2, r7, ror #2
 b60:	404e      	eors	r6, r1
 b62:	9806      	ldr	r0, [sp, #24]
 b64:	4416      	add	r6, r2
 b66:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 b68:	ea82 72f0 	eor.w	r2, r2, r0, ror #31
 b6c:	ea82 7afa 	eor.w	sl, r2, sl, ror #31
 b70:	eb08 68f1 	add.w	r8, r8, r1, ror #27
 b74:	ea8a 7afb 	eor.w	sl, sl, fp, ror #31
 b78:	ea4f 01b1 	mov.w	r1, r1, ror #2
 b7c:	ea81 07bc 	eor.w	r7, r1, ip, ror #2
 b80:	eb03 72fa 	add.w	r2, r3, sl, ror #31
 b84:	4422      	add	r2, r4
 b86:	ea87 0708 	eor.w	r7, r7, r8
 b8a:	9807      	ldr	r0, [sp, #28]
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 b8c:	9c06      	ldr	r4, [sp, #24]
        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
 b8e:	4417      	add	r7, r2
 b90:	9a14      	ldr	r2, [sp, #80]	; 0x50
 b92:	ea82 72f0 	eor.w	r2, r2, r0, ror #31
 b96:	ea82 79f9 	eor.w	r9, r2, r9, ror #31
 b9a:	9a03      	ldr	r2, [sp, #12]
 b9c:	ea89 79f2 	eor.w	r9, r9, r2, ror #31
 ba0:	eb06 66f8 	add.w	r6, r6, r8, ror #27
 ba4:	ea81 02b8 	eor.w	r2, r1, r8, ror #2
 ba8:	eb03 70f9 	add.w	r0, r3, r9, ror #31
 bac:	eb00 00bc 	add.w	r0, r0, ip, ror #2
 bb0:	4072      	eors	r2, r6
 bb2:	4402      	add	r2, r0
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 bb4:	9810      	ldr	r0, [sp, #64]	; 0x40
 bb6:	ea80 74f4 	eor.w	r4, r0, r4, ror #31
 bba:	980a      	ldr	r0, [sp, #40]	; 0x28
 bbc:	ea84 74f0 	eor.w	r4, r4, r0, ror #31
 bc0:	9804      	ldr	r0, [sp, #16]
        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
 bc2:	eb07 67f6 	add.w	r7, r7, r6, ror #27
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 bc6:	ea84 74f0 	eor.w	r4, r4, r0, ror #31
 bca:	ea4f 06b6 	mov.w	r6, r6, ror #2
 bce:	eb03 70f4 	add.w	r0, r3, r4, ror #31
 bd2:	ea86 0cb8 	eor.w	ip, r6, r8, ror #2
 bd6:	4401      	add	r1, r0
 bd8:	ea8c 0c07 	eor.w	ip, ip, r7
 bdc:	9807      	ldr	r0, [sp, #28]
 bde:	448c      	add	ip, r1
 be0:	9911      	ldr	r1, [sp, #68]	; 0x44
 be2:	ea81 71f0 	eor.w	r1, r1, r0, ror #31
 be6:	ea81 71f5 	eor.w	r1, r1, r5, ror #31
 bea:	ea81 71fa 	eor.w	r1, r1, sl, ror #31
        R4(b,c,d,e,a,64); R4(a,b,c,d,e,65); R4(e,a,b,c,d,66); R4(d,e,a,b,c,67);
 bee:	eb02 62f7 	add.w	r2, r2, r7, ror #27
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 bf2:	ea86 05b7 	eor.w	r5, r6, r7, ror #2
 bf6:	eb03 70f1 	add.w	r0, r3, r1, ror #31
 bfa:	eb00 00b8 	add.w	r0, r0, r8, ror #2
 bfe:	4055      	eors	r5, r2
 c00:	f8dd 8020 	ldr.w	r8, [sp, #32]
 c04:	4405      	add	r5, r0
 c06:	9810      	ldr	r0, [sp, #64]	; 0x40
 c08:	ea80 70f8 	eor.w	r0, r0, r8, ror #31
 c0c:	ea80 70fe 	eor.w	r0, r0, lr, ror #31
 c10:	eb0c 6cf2 	add.w	ip, ip, r2, ror #27
 c14:	ea80 70f9 	eor.w	r0, r0, r9, ror #31
 c18:	ea4f 02b2 	mov.w	r2, r2, ror #2
 c1c:	9006      	str	r0, [sp, #24]
 c1e:	ea82 08b7 	eor.w	r8, r2, r7, ror #2
 c22:	eb03 70f0 	add.w	r0, r3, r0, ror #31
 c26:	4430      	add	r0, r6
 c28:	ea88 080c 	eor.w	r8, r8, ip
 c2c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 c2e:	4480      	add	r8, r0
 c30:	9811      	ldr	r0, [sp, #68]	; 0x44
 c32:	ea80 70f6 	eor.w	r0, r0, r6, ror #31
 c36:	ea80 70fb 	eor.w	r0, r0, fp, ror #31
 c3a:	ea80 70f4 	eor.w	r0, r0, r4, ror #31
 c3e:	9007      	str	r0, [sp, #28]
 c40:	9e07      	ldr	r6, [sp, #28]
 c42:	eb05 65fc 	add.w	r5, r5, ip, ror #27
 c46:	ea82 00bc 	eor.w	r0, r2, ip, ror #2
 c4a:	eb03 76f6 	add.w	r6, r3, r6, ror #31
 c4e:	eb06 06b7 	add.w	r6, r6, r7, ror #2
 c52:	4068      	eors	r0, r5
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 c54:	9f08      	ldr	r7, [sp, #32]
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 c56:	4430      	add	r0, r6
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 c58:	9e15      	ldr	r6, [sp, #84]	; 0x54
 c5a:	ea86 77f7 	eor.w	r7, r6, r7, ror #31
 c5e:	9e03      	ldr	r6, [sp, #12]
 c60:	ea87 77f6 	eor.w	r7, r7, r6, ror #31
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 c64:	eb08 68f5 	add.w	r8, r8, r5, ror #27
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 c68:	ea87 77f1 	eor.w	r7, r7, r1, ror #31
 c6c:	ea4f 05b5 	mov.w	r5, r5, ror #2
 c70:	eb03 76f7 	add.w	r6, r3, r7, ror #31
 c74:	ea85 0ebc 	eor.w	lr, r5, ip, ror #2
 c78:	4432      	add	r2, r6
 c7a:	ea8e 0e08 	eor.w	lr, lr, r8
 c7e:	9e09      	ldr	r6, [sp, #36]	; 0x24
 c80:	4496      	add	lr, r2
 c82:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 c84:	ea82 76f6 	eor.w	r6, r2, r6, ror #31
 c88:	9a04      	ldr	r2, [sp, #16]
 c8a:	ea86 76f2 	eor.w	r6, r6, r2, ror #31
 c8e:	9a06      	ldr	r2, [sp, #24]
 c90:	ea86 76f2 	eor.w	r6, r6, r2, ror #31
        R4(c,d,e,a,b,68); R4(b,c,d,e,a,69); R4(a,b,c,d,e,70); R4(e,a,b,c,d,71);
 c94:	eb00 60f8 	add.w	r0, r0, r8, ror #27
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 c98:	eb03 7bf6 	add.w	fp, r3, r6, ror #31
 c9c:	ea85 02b8 	eor.w	r2, r5, r8, ror #2
 ca0:	eb0b 0cbc 	add.w	ip, fp, ip, ror #2
 ca4:	4042      	eors	r2, r0
 ca6:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
 caa:	4462      	add	r2, ip
 cac:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
 cb0:	ea8c 7cfb 	eor.w	ip, ip, fp, ror #31
 cb4:	ea8c 7afa 	eor.w	sl, ip, sl, ror #31
 cb8:	f8dd c01c 	ldr.w	ip, [sp, #28]
 cbc:	eb0e 6ef0 	add.w	lr, lr, r0, ror #27
 cc0:	ea8a 7afc 	eor.w	sl, sl, ip, ror #31
 cc4:	ea4f 00b0 	mov.w	r0, r0, ror #2
 cc8:	ea80 0cb8 	eor.w	ip, r0, r8, ror #2
 ccc:	eb03 7bfa 	add.w	fp, r3, sl, ror #31
 cd0:	44ab      	add	fp, r5
 cd2:	ea8c 0c0e 	eor.w	ip, ip, lr
 cd6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 cd8:	44dc      	add	ip, fp
 cda:	f8dd b008 	ldr.w	fp, [sp, #8]
 cde:	ea85 75fb 	eor.w	r5, r5, fp, ror #31
 ce2:	ea85 79f9 	eor.w	r9, r5, r9, ror #31
 ce6:	ea89 77f7 	eor.w	r7, r9, r7, ror #31
 cea:	eb02 62fe 	add.w	r2, r2, lr, ror #27
 cee:	ea80 05be 	eor.w	r5, r0, lr, ror #2
 cf2:	eb03 79f7 	add.w	r9, r3, r7, ror #31
 cf6:	eb09 09b8 	add.w	r9, r9, r8, ror #2
 cfa:	4055      	eors	r5, r2
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 cfc:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 d00:	444d      	add	r5, r9
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 d02:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
 d06:	ea88 78f9 	eor.w	r8, r8, r9, ror #31
 d0a:	ea88 74f4 	eor.w	r4, r8, r4, ror #31
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 d0e:	eb0c 6cf2 	add.w	ip, ip, r2, ror #27
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 d12:	ea84 76f6 	eor.w	r6, r4, r6, ror #31
 d16:	ea4f 02b2 	mov.w	r2, r2, ror #2
 d1a:	eb03 78f6 	add.w	r8, r3, r6, ror #31
 d1e:	ea82 04be 	eor.w	r4, r2, lr, ror #2
 d22:	ea84 040c 	eor.w	r4, r4, ip
 d26:	4440      	add	r0, r8
 d28:	4420      	add	r0, r4
 d2a:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 d2c:	ea84 74fb 	eor.w	r4, r4, fp, ror #31
 d30:	ea84 71f1 	eor.w	r1, r4, r1, ror #31
 d34:	ea81 71fa 	eor.w	r1, r1, sl, ror #31
 d38:	eb03 71f1 	add.w	r1, r3, r1, ror #31
        R4(d,e,a,b,c,72); R4(c,d,e,a,b,73); R4(b,c,d,e,a,74); R4(a,b,c,d,e,75);
 d3c:	eb05 65fc 	add.w	r5, r5, ip, ror #27
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 d40:	eb01 0ebe 	add.w	lr, r1, lr, ror #2
 d44:	ea82 01bc 	eor.w	r1, r2, ip, ror #2
 d48:	4069      	eors	r1, r5
 d4a:	9c03      	ldr	r4, [sp, #12]
 d4c:	448e      	add	lr, r1
 d4e:	990c      	ldr	r1, [sp, #48]	; 0x30
 d50:	ea81 71f4 	eor.w	r1, r1, r4, ror #31
 d54:	9c06      	ldr	r4, [sp, #24]
 d56:	ea81 71f4 	eor.w	r1, r1, r4, ror #31
 d5a:	ea81 71f7 	eor.w	r1, r1, r7, ror #31
 d5e:	eb00 60f5 	add.w	r0, r0, r5, ror #27
 d62:	eb03 71f1 	add.w	r1, r3, r1, ror #31
 d66:	ea4f 05b5 	mov.w	r5, r5, ror #2
 d6a:	440a      	add	r2, r1
 d6c:	ea85 01bc 	eor.w	r1, r5, ip, ror #2
 d70:	4041      	eors	r1, r0
 d72:	9c04      	ldr	r4, [sp, #16]
 d74:	440a      	add	r2, r1
 d76:	990f      	ldr	r1, [sp, #60]	; 0x3c
 d78:	ea81 71f4 	eor.w	r1, r1, r4, ror #31
 d7c:	9c07      	ldr	r4, [sp, #28]
 d7e:	ea81 71f4 	eor.w	r1, r1, r4, ror #31
 d82:	ea81 76f6 	eor.w	r6, r1, r6, ror #31
    #endif

        /* Add the working vars back into digest state[] */
        sha->digest[0] += a;
 d86:	990d      	ldr	r1, [sp, #52]	; 0x34
 d88:	440b      	add	r3, r1
 d8a:	eb03 73f6 	add.w	r3, r3, r6, ror #31
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 d8e:	eb0e 6ef0 	add.w	lr, lr, r0, ror #27
        sha->digest[0] += a;
 d92:	eb03 0cbc 	add.w	ip, r3, ip, ror #2
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 d96:	ea85 03b0 	eor.w	r3, r5, r0, ror #2
 d9a:	ea83 030e 	eor.w	r3, r3, lr
        sha->digest[0] += a;
 d9e:	9900      	ldr	r1, [sp, #0]
        R4(e,a,b,c,d,76); R4(d,e,a,b,c,77); R4(c,d,e,a,b,78); R4(b,c,d,e,a,79);
 da0:	eb02 62fe 	add.w	r2, r2, lr, ror #27
        sha->digest[0] += a;
 da4:	4463      	add	r3, ip
 da6:	eb03 63f2 	add.w	r3, r3, r2, ror #27
 daa:	64cb      	str	r3, [r1, #76]	; 0x4c
        sha->digest[1] += b;
 dac:	9b01      	ldr	r3, [sp, #4]
 dae:	441a      	add	r2, r3
        sha->digest[2] += c;
 db0:	9b05      	ldr	r3, [sp, #20]
        sha->digest[1] += b;
 db2:	650a      	str	r2, [r1, #80]	; 0x50
        sha->digest[2] += c;
 db4:	eb03 01be 	add.w	r1, r3, lr, ror #2
 db8:	9b00      	ldr	r3, [sp, #0]
 dba:	6559      	str	r1, [r3, #84]	; 0x54
        sha->digest[3] += d;
 dbc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 dbe:	eb03 00b0 	add.w	r0, r3, r0, ror #2
 dc2:	9b00      	ldr	r3, [sp, #0]
 dc4:	6598      	str	r0, [r3, #88]	; 0x58
        sha->digest[4] += e;
 dc6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 dc8:	441d      	add	r5, r3
 dca:	9b00      	ldr	r3, [sp, #0]

        (void)data; /* Not used */

        return 0;
    }
 dcc:	2000      	movs	r0, #0
        sha->digest[4] += e;
 dce:	65dd      	str	r5, [r3, #92]	; 0x5c
    }
 dd0:	b017      	add	sp, #92	; 0x5c
 dd2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 dd6:	bf00      	nop
 dd8:	ca62c1d6 	.word	0xca62c1d6

Disassembly of section .text.wc_InitSha_ex:

00000000 <wc_InitSha_ex>:
** we'll assume this is ALWAYS for a new, uninitialized sha256
*/
int wc_InitSha_ex(wc_Sha* sha, void* heap, int devId)
{
    int ret = 0;
    if (sha == NULL) {
   0:	b1b8      	cbz	r0, 32 <wc_InitSha_ex+0x32>
        sha->digest[0] = 0x67452301L;
   2:	4b0d      	ldr	r3, [pc, #52]	; (38 <wc_InitSha_ex+0x38>)
   4:	64c3      	str	r3, [r0, #76]	; 0x4c
        sha->digest[1] = 0xEFCDAB89L;
   6:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
   a:	6503      	str	r3, [r0, #80]	; 0x50
        sha->digest[2] = 0x98BADCFEL;
   c:	f103 4329 	add.w	r3, r3, #2835349504	; 0xa9000000
  10:	f5a3 1396 	sub.w	r3, r3, #1228800	; 0x12c000
  14:	f6a3 638b 	subw	r3, r3, #3723	; 0xe8b
  18:	6543      	str	r3, [r0, #84]	; 0x54
        sha->digest[3] = 0x10325476L;
  1a:	f1a3 3388 	sub.w	r3, r3, #2290649224	; 0x88888888
  1e:	6583      	str	r3, [r0, #88]	; 0x58
        sha->digest[4] = 0xC3D2E1F0L;
  20:	4b06      	ldr	r3, [pc, #24]	; (3c <wc_InitSha_ex+0x3c>)
  22:	65c3      	str	r3, [r0, #92]	; 0x5c
        sha->buffLen = 0;
  24:	2300      	movs	r3, #0
        sha->loLen   = 0;
  26:	e9c0 3300 	strd	r3, r3, [r0]
        return BAD_FUNC_ARG;
    }

    sha->heap = heap;
  2a:	6601      	str	r1, [r0, #96]	; 0x60
        sha->hiLen   = 0;
  2c:	6083      	str	r3, [r0, #8]
# endif /* WOLFSSL_ASYNC_CRYPT */
#ifdef WOLFSSL_IMXRT1170_CAAM
   ret = wc_CAAM_HashInit(&sha->hndl, &sha->ctx, WC_HASH_TYPE_SHA);
#endif

    return ret;
  2e:	4618      	mov	r0, r3
  30:	4770      	bx	lr
        return BAD_FUNC_ARG;
  32:	f06f 00ac 	mvn.w	r0, #172	; 0xac
} /* wc_InitSha_ex */
  36:	4770      	bx	lr
  38:	67452301 	.word	0x67452301
  3c:	c3d2e1f0 	.word	0xc3d2e1f0

Disassembly of section .text.wc_ShaUpdate:

00000000 <wc_ShaUpdate>:

/* do block size increments/updates */
int wc_ShaUpdate(wc_Sha* sha, const byte* data, word32 len)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	460f      	mov	r7, r1
   6:	4614      	mov	r4, r2
    int ret = 0;
    word32 blocksLen;
    byte* local;

    if (sha == NULL || (data == NULL && len > 0)) {
   8:	4605      	mov	r5, r0
   a:	2800      	cmp	r0, #0
   c:	d05a      	beq.n	c4 <wc_ShaUpdate+0xc4>
   e:	b939      	cbnz	r1, 20 <wc_ShaUpdate+0x20>
        return BAD_FUNC_ARG;
    }

    if (data == NULL && len == 0) {
        /* valid, but do nothing */
        return 0;
  10:	2a00      	cmp	r2, #0
  12:	bf14      	ite	ne
  14:	f06f 06ac 	mvnne.w	r6, #172	; 0xac
  18:	2600      	moveq	r6, #0
        XMEMCPY(local, data, len);
        sha->buffLen = len;
    }

    return ret;
}
  1a:	4630      	mov	r0, r6
  1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (sha->buffLen >= WC_SHA_BLOCK_SIZE) {
  20:	6800      	ldr	r0, [r0, #0]
  22:	283f      	cmp	r0, #63	; 0x3f
  24:	d851      	bhi.n	ca <wc_ShaUpdate+0xca>
        sha->hiLen++;                       /* carry low to high */
  26:	686b      	ldr	r3, [r5, #4]
  28:	18d3      	adds	r3, r2, r3
    if ((sha->loLen += len) < tmp)
  2a:	606b      	str	r3, [r5, #4]
        sha->hiLen++;                       /* carry low to high */
  2c:	bf22      	ittt	cs
  2e:	68ab      	ldrcs	r3, [r5, #8]
  30:	3301      	addcs	r3, #1
  32:	60ab      	strcs	r3, [r5, #8]
    local = (byte*)sha->buffer;
  34:	f105 080c 	add.w	r8, r5, #12
    if (sha->buffLen > 0) {
  38:	b1d8      	cbz	r0, 72 <wc_ShaUpdate+0x72>
        blocksLen = min(len, WC_SHA_BLOCK_SIZE - sha->buffLen);
  3a:	f1c0 0640 	rsb	r6, r0, #64	; 0x40
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_MISC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
        return a > b ? b : a;
  3e:	4296      	cmp	r6, r2
  40:	bf28      	it	cs
  42:	4616      	movcs	r6, r2
        XMEMCPY(&local[sha->buffLen], data, blocksLen);
  44:	4632      	mov	r2, r6
  46:	4440      	add	r0, r8
  48:	f7ff fffe 	bl	0 <memcpy>
        sha->buffLen += blocksLen;
  4c:	682a      	ldr	r2, [r5, #0]
  4e:	4432      	add	r2, r6
        if (sha->buffLen == WC_SHA_BLOCK_SIZE) {
  50:	2a40      	cmp	r2, #64	; 0x40
        sha->buffLen += blocksLen;
  52:	602a      	str	r2, [r5, #0]
        data         += blocksLen;
  54:	4437      	add	r7, r6
        len          -= blocksLen;
  56:	eba4 0406 	sub.w	r4, r4, r6
        if (sha->buffLen == WC_SHA_BLOCK_SIZE) {
  5a:	d10a      	bne.n	72 <wc_ShaUpdate+0x72>
            ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
  5c:	4641      	mov	r1, r8
  5e:	4640      	mov	r0, r8
  60:	f7ff fffe 	bl	0 <wc_ShaUpdate>
            ret = XTRANSFORM(sha, (const byte*)local);
  64:	4628      	mov	r0, r5
  66:	f7ff fffe 	bl	0 <wc_ShaUpdate>
            if (ret != 0) {
  6a:	4606      	mov	r6, r0
  6c:	2800      	cmp	r0, #0
  6e:	d1d4      	bne.n	1a <wc_ShaUpdate+0x1a>
            sha->buffLen = 0; /* Nothing left to do, so set to zero. */
  70:	6028      	str	r0, [r5, #0]
{
  72:	46a1      	mov	r9, r4
  74:	2600      	movs	r6, #0
  76:	eb07 0a04 	add.w	sl, r7, r4
    while (len >= WC_SHA_BLOCK_SIZE) {
  7a:	f1b9 0f3f 	cmp.w	r9, #63	; 0x3f
  7e:	ebaa 0109 	sub.w	r1, sl, r9
  82:	d80f      	bhi.n	a4 <wc_ShaUpdate+0xa4>
  84:	09a2      	lsrs	r2, r4, #6
  86:	f06f 033f 	mvn.w	r3, #63	; 0x3f
  8a:	f024 013f 	bic.w	r1, r4, #63	; 0x3f
  8e:	fb03 4402 	mla	r4, r3, r2, r4
    if (len > 0) {
  92:	4439      	add	r1, r7
  94:	2c00      	cmp	r4, #0
  96:	d0c0      	beq.n	1a <wc_ShaUpdate+0x1a>
        XMEMCPY(local, data, len);
  98:	4622      	mov	r2, r4
  9a:	4640      	mov	r0, r8
  9c:	f7ff fffe 	bl	0 <memcpy>
        sha->buffLen = len;
  a0:	602c      	str	r4, [r5, #0]
  a2:	e7ba      	b.n	1a <wc_ShaUpdate+0x1a>
            XMEMCPY(local32, data, WC_SHA_BLOCK_SIZE);
  a4:	2240      	movs	r2, #64	; 0x40
  a6:	4640      	mov	r0, r8
  a8:	f7ff fffe 	bl	0 <memcpy>
        ByteReverseWords(local32, local32, WC_SHA_BLOCK_SIZE);
  ac:	2240      	movs	r2, #64	; 0x40
  ae:	4641      	mov	r1, r8
  b0:	4640      	mov	r0, r8
  b2:	f7ff fffe 	bl	0 <wc_ShaUpdate>
        ret = XTRANSFORM(sha, (const byte*)local32);
  b6:	4628      	mov	r0, r5
  b8:	f7ff fffe 	bl	0 <wc_ShaUpdate>
        len  -= WC_SHA_BLOCK_SIZE;
  bc:	f1a9 0940 	sub.w	r9, r9, #64	; 0x40
        ret = XTRANSFORM(sha, (const byte*)local32);
  c0:	4606      	mov	r6, r0
  c2:	e7da      	b.n	7a <wc_ShaUpdate+0x7a>
        return BAD_FUNC_ARG;
  c4:	f06f 06ac 	mvn.w	r6, #172	; 0xac
  c8:	e7a7      	b.n	1a <wc_ShaUpdate+0x1a>
        return BUFFER_E;
  ca:	f06f 0683 	mvn.w	r6, #131	; 0x83
  ce:	e7a4      	b.n	1a <wc_ShaUpdate+0x1a>

Disassembly of section .text.wc_ShaFinalRaw:

00000000 <wc_ShaFinalRaw>:

int wc_ShaFinalRaw(wc_Sha* sha, byte* hash)
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
   4:	b086      	sub	sp, #24
#ifdef LITTLE_ENDIAN_ORDER
    word32 digest[WC_SHA_DIGEST_SIZE / sizeof(word32)];
#endif

    if (sha == NULL || hash == NULL) {
   6:	b170      	cbz	r0, 26 <wc_ShaFinalRaw+0x26>
   8:	b169      	cbz	r1, 26 <wc_ShaFinalRaw+0x26>
        return BAD_FUNC_ARG;
    }

#ifdef LITTLE_ENDIAN_ORDER
    ByteReverseWords((word32*)digest, (word32*)sha->digest, WC_SHA_DIGEST_SIZE);
   a:	f100 014c 	add.w	r1, r0, #76	; 0x4c
   e:	2214      	movs	r2, #20
  10:	a801      	add	r0, sp, #4
  12:	f7ff fffe 	bl	0 <wc_ShaFinalRaw>
    XMEMCPY(hash, (byte *)&digest[0], WC_SHA_DIGEST_SIZE);
  16:	4601      	mov	r1, r0
  18:	2214      	movs	r2, #20
  1a:	4620      	mov	r0, r4
  1c:	f7ff fffe 	bl	0 <memcpy>
#else
    XMEMCPY(hash, sha->digest, WC_SHA_DIGEST_SIZE);
#endif

    return 0;
  20:	2000      	movs	r0, #0
}
  22:	b006      	add	sp, #24
  24:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  26:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2a:	e7fa      	b.n	22 <wc_ShaFinalRaw+0x22>

Disassembly of section .text.wc_ShaFinal:

00000000 <wc_ShaFinal>:
/*
** Finalizes hashing of data. Result is placed into hash.
** Resets state of sha struct.
*/
int wc_ShaFinal(wc_Sha* sha, byte* hash)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460f      	mov	r7, r1
    int ret;
    byte* local;

    if (sha == NULL || hash == NULL) {
   4:	4604      	mov	r4, r0
   6:	2800      	cmp	r0, #0
   8:	d067      	beq.n	da <wc_ShaFinal+0xda>
   a:	2900      	cmp	r1, #0
   c:	d065      	beq.n	da <wc_ShaFinal+0xda>
        return BAD_FUNC_ARG;
    }

    local = (byte*)sha->buffer;
   e:	4606      	mov	r6, r0
    }
#endif /* WOLFSSL_ASYNC_CRYPT */

    /* we'll add a 0x80 byte at the end,
    ** so make sure we have appropriate buffer length. */
    if (sha->buffLen > WC_SHA_BLOCK_SIZE - 1) {
  10:	f856 3b0c 	ldr.w	r3, [r6], #12
  14:	2b3f      	cmp	r3, #63	; 0x3f
  16:	d863      	bhi.n	e0 <wc_ShaFinal+0xe0>
        /* exit with error code if there's a bad buffer size in buffLen */
        return BAD_STATE_E;
    } /* buffLen check */

    local[sha->buffLen++] = 0x80;  /* add 1 */
  18:	1c5a      	adds	r2, r3, #1
  1a:	6002      	str	r2, [r0, #0]
  1c:	2280      	movs	r2, #128	; 0x80
  1e:	54f2      	strb	r2, [r6, r3]

    /* pad with zeros */
    if (sha->buffLen > WC_SHA_PAD_SIZE) {
  20:	6800      	ldr	r0, [r0, #0]
  22:	2838      	cmp	r0, #56	; 0x38
  24:	d912      	bls.n	4c <wc_ShaFinal+0x4c>
        XMEMSET(&local[sha->buffLen], 0, WC_SHA_BLOCK_SIZE - sha->buffLen);
  26:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
  2a:	2100      	movs	r1, #0
  2c:	4430      	add	r0, r6
  2e:	f7ff fffe 	bl	0 <memset>
        sha->buffLen += WC_SHA_BLOCK_SIZE - sha->buffLen;
  32:	2240      	movs	r2, #64	; 0x40
  34:	6022      	str	r2, [r4, #0]

    #if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
        ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
  36:	4631      	mov	r1, r6
  38:	4630      	mov	r0, r6
  3a:	f7ff fffe 	bl	0 <wc_ShaFinal>
    #else
        /*
        ** The #if defined(WOLFSSL_USE_ESP32C3_CRYPT_HASH_HW) also falls
        ** though here to SW, as it's not yet implemented for HW.
        */
        ret = XTRANSFORM(sha, (const byte*)local);
  3e:	4620      	mov	r0, r4
  40:	f7ff fffe 	bl	0 <wc_ShaFinal>
    #endif
        if (ret != 0) {
  44:	4605      	mov	r5, r0
  46:	2800      	cmp	r0, #0
  48:	d145      	bne.n	d6 <wc_ShaFinal+0xd6>
            return ret;
        }

        sha->buffLen = 0;
  4a:	6020      	str	r0, [r4, #0]
    } /*  (sha->buffLen > WC_SHA_PAD_SIZE) */

    XMEMSET(&local[sha->buffLen], 0, WC_SHA_PAD_SIZE - sha->buffLen);
  4c:	6820      	ldr	r0, [r4, #0]
  4e:	2100      	movs	r1, #0
  50:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
  54:	4430      	add	r0, r6
  56:	f7ff fffe 	bl	0 <memset>

#if defined(LITTLE_ENDIAN_ORDER) && !defined(FREESCALE_MMCAU_SHA)
    ByteReverseWords(sha->buffer, sha->buffer, WC_SHA_BLOCK_SIZE);
  5a:	2240      	movs	r2, #64	; 0x40
  5c:	4631      	mov	r1, r6
  5e:	4630      	mov	r0, r6
  60:	f7ff fffe 	bl	0 <wc_ShaFinal>
#endif

    /* store lengths */
    /* put lengths in bits */
    sha->hiLen = (sha->loLen >> (8*sizeof(sha->loLen) - 3)) + (sha->hiLen << 3);
  64:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
  68:	0f5a      	lsrs	r2, r3, #29
  6a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    sha->loLen = sha->loLen << 3;
  6e:	00db      	lsls	r3, r3, #3
  70:	6063      	str	r3, [r4, #4]
    sha->hiLen = (sha->loLen >> (8*sizeof(sha->loLen) - 3)) + (sha->hiLen << 3);
  72:	60a2      	str	r2, [r4, #8]

    /* ! length ordering dependent on digest endian type ! */
    XMEMCPY(&local[WC_SHA_PAD_SIZE], &sha->hiLen, sizeof(word32));
  74:	f104 0108 	add.w	r1, r4, #8
  78:	2204      	movs	r2, #4
  7a:	f104 0044 	add.w	r0, r4, #68	; 0x44
  7e:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(&local[WC_SHA_PAD_SIZE + sizeof(word32)], &sha->loLen, sizeof(word32));
  82:	2204      	movs	r2, #4
  84:	18a1      	adds	r1, r4, r2
  86:	f104 0048 	add.w	r0, r4, #72	; 0x48
  8a:	f7ff fffe 	bl	0 <memcpy>
/*
** The #if defined(WOLFSSL_USE_ESP32C3_CRYPT_HASH_HW) also falls
** though here to SW, as it's not yet implemented for HW.
*/
#else
    ret = XTRANSFORM(sha, (const byte*)local);
  8e:	4631      	mov	r1, r6
  90:	4620      	mov	r0, r4
  92:	f7ff fffe 	bl	0 <wc_ShaFinal>
#endif

#ifdef LITTLE_ENDIAN_ORDER
    ByteReverseWords(sha->digest, sha->digest, WC_SHA_DIGEST_SIZE);
  96:	f104 014c 	add.w	r1, r4, #76	; 0x4c
  9a:	2214      	movs	r2, #20
    ret = XTRANSFORM(sha, (const byte*)local);
  9c:	4605      	mov	r5, r0
    ByteReverseWords(sha->digest, sha->digest, WC_SHA_DIGEST_SIZE);
  9e:	4608      	mov	r0, r1
  a0:	f7ff fffe 	bl	0 <wc_ShaFinal>
#endif

    XMEMCPY(hash, (byte *)&sha->digest[0], WC_SHA_DIGEST_SIZE);
  a4:	2214      	movs	r2, #20
  a6:	4638      	mov	r0, r7
  a8:	f7ff fffe 	bl	0 <memcpy>
        sha->digest[0] = 0x67452301L;
  ac:	4b0e      	ldr	r3, [pc, #56]	; (e8 <wc_ShaFinal+0xe8>)
  ae:	64e3      	str	r3, [r4, #76]	; 0x4c
        sha->digest[1] = 0xEFCDAB89L;
  b0:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
  b4:	6523      	str	r3, [r4, #80]	; 0x50
        sha->digest[2] = 0x98BADCFEL;
  b6:	f103 4329 	add.w	r3, r3, #2835349504	; 0xa9000000
  ba:	f5a3 1396 	sub.w	r3, r3, #1228800	; 0x12c000
  be:	f6a3 638b 	subw	r3, r3, #3723	; 0xe8b
  c2:	6563      	str	r3, [r4, #84]	; 0x54
        sha->digest[3] = 0x10325476L;
  c4:	f1a3 3388 	sub.w	r3, r3, #2290649224	; 0x88888888
  c8:	65a3      	str	r3, [r4, #88]	; 0x58
        sha->digest[4] = 0xC3D2E1F0L;
  ca:	4b08      	ldr	r3, [pc, #32]	; (ec <wc_ShaFinal+0xec>)
  cc:	65e3      	str	r3, [r4, #92]	; 0x5c
        sha->buffLen = 0;
  ce:	2300      	movs	r3, #0
        sha->loLen   = 0;
  d0:	e9c4 3300 	strd	r3, r3, [r4]
        sha->hiLen   = 0;
  d4:	60a3      	str	r3, [r4, #8]
     * which may cause fall back to SW if HW is busy. we do not return result
     * of initSha here */
    (void)InitSha(sha); /* reset state */

    return ret;
}
  d6:	4628      	mov	r0, r5
  d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
  da:	f06f 05ac 	mvn.w	r5, #172	; 0xac
  de:	e7fa      	b.n	d6 <wc_ShaFinal+0xd6>
        return BAD_STATE_E;
  e0:	f06f 05bf 	mvn.w	r5, #191	; 0xbf
  e4:	e7f7      	b.n	d6 <wc_ShaFinal+0xd6>
  e6:	bf00      	nop
  e8:	67452301 	.word	0x67452301
  ec:	c3d2e1f0 	.word	0xc3d2e1f0

Disassembly of section .text.wc_InitSha:

00000000 <wc_InitSha>:
/*
** This function initializes SHA. This is automatically called by wc_ShaHash.
*/
int wc_InitSha(wc_Sha* sha)
{
    return wc_InitSha_ex(sha, NULL, INVALID_DEVID);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_InitSha>

Disassembly of section .text.wc_ShaFree:

00000000 <wc_ShaFree>:
    }
#endif
#ifdef WOLFSSL_IMXRT_DCP
    DCPShaFree(sha);
#endif
}
   0:	4770      	bx	lr

Disassembly of section .text.wc_ShaCopy:

00000000 <wc_ShaCopy>:

    return ret;
}

int wc_ShaCopy(wc_Sha* src, wc_Sha* dst)
{
   0:	b508      	push	{r3, lr}
   2:	460b      	mov	r3, r1
    int ret = 0;

    if (src == NULL || dst == NULL)
   4:	4601      	mov	r1, r0
   6:	b130      	cbz	r0, 16 <wc_ShaCopy+0x16>
   8:	b12b      	cbz	r3, 16 <wc_ShaCopy+0x16>
        return BAD_FUNC_ARG;

    XMEMCPY(dst, src, sizeof(wc_Sha));
   a:	2264      	movs	r2, #100	; 0x64
   c:	4618      	mov	r0, r3
   e:	f7ff fffe 	bl	0 <memcpy>
#endif

#ifdef WOLFSSL_HASH_FLAGS
    dst->flags |= WC_HASH_FLAG_ISCOPY;
#endif
    return ret;
  12:	2000      	movs	r0, #0
}
  14:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1a:	e7fb      	b.n	14 <wc_ShaCopy+0x14>

Disassembly of section .text.wc_ShaGetHash:

00000000 <wc_ShaGetHash>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460e      	mov	r6, r1
    if (sha == NULL || hash == NULL) {
   4:	4604      	mov	r4, r0
   6:	b1a8      	cbz	r0, 34 <wc_ShaGetHash+0x34>
   8:	b1a1      	cbz	r1, 34 <wc_ShaGetHash+0x34>
    tmpSha = (wc_Sha*)XMALLOC(sizeof(wc_Sha), NULL,
   a:	2064      	movs	r0, #100	; 0x64
   c:	f7ff fffe 	bl	0 <malloc>
    if (tmpSha == NULL) {
  10:	4605      	mov	r5, r0
  12:	b190      	cbz	r0, 3a <wc_ShaGetHash+0x3a>
    ret = wc_ShaCopy(sha, tmpSha);
  14:	4601      	mov	r1, r0
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <wc_ShaGetHash>
    if (ret == 0) {
  1c:	4604      	mov	r4, r0
  1e:	b920      	cbnz	r0, 2a <wc_ShaGetHash+0x2a>
        ret = wc_ShaFinal(tmpSha, hash);
  20:	4631      	mov	r1, r6
  22:	4628      	mov	r0, r5
  24:	f7ff fffe 	bl	0 <wc_ShaGetHash>
  28:	4604      	mov	r4, r0
    XFREE(tmpSha, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  2a:	4628      	mov	r0, r5
  2c:	f7ff fffe 	bl	0 <free>
}
  30:	4620      	mov	r0, r4
  32:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  34:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  38:	e7fa      	b.n	30 <wc_ShaGetHash+0x30>
        return MEMORY_E;
  3a:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  3e:	e7f7      	b.n	30 <wc_ShaGetHash+0x30>

sha256.o:     file format elf32-littlearm


Disassembly of section .text.ByteReverseWords:

00000000 <ByteReverseWords>:
}
#endif /* __CCRX__ */
/* This routine performs a byte swap of words array of a given count. */
WC_MISC_STATIC WC_INLINE void ByteReverseWords(word32* out, const word32* in,
                                    word32 byteCount)
{
   0:	b510      	push	{r4, lr}
#ifdef WOLFSSL_USE_ALIGN
    if ((((size_t)in & 0x3) == 0) &&
        (((size_t)out & 0x3) == 0))
#endif
    {
        word32 count = byteCount/(word32)sizeof(word32);
   2:	0892      	lsrs	r2, r2, #2
        for (i = 0; i < count; i++)
   4:	2300      	movs	r3, #0
            out[i] = ByteReverseWord32(in[i]);
   6:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
   a:	ba24      	rev	r4, r4
   c:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
        for (i = 0; i < count; i++)
  10:	3301      	adds	r3, #1
  12:	429a      	cmp	r2, r3
  14:	d1f7      	bne.n	6 <ByteReverseWords+0x6>
            scratch = ByteReverseWord32(scratch);
            XMEMCPY(out_bytes + i, &scratch, sizeof(scratch));
        }
    }
#endif
}
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.Transform_Sha256:

00000000 <Transform_Sha256>:
         t1 = Sigma0(a(j)) + Maj(a(j), b(j), c(j)); \
         d(j) += t0; \
         h(j)  = t0 + t1

    static int Transform_Sha256(wc_Sha256* sha256, const byte* data)
    {
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4604      	mov	r4, r0
   6:	b08d      	sub	sp, #52	; 0x34
                return MEMORY_E;
            sha256->W = W;
        }
    #elif defined(WOLFSSL_SMALL_STACK)
        word32* W;
        W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
   8:	f44f 7080 	mov.w	r0, #256	; 0x100
    {
   c:	460d      	mov	r5, r1
        W = (word32*)XMALLOC(sizeof(word32) * WC_SHA256_BLOCK_SIZE, NULL,
   e:	f7ff fffe 	bl	0 <malloc>
                                                       DYNAMIC_TYPE_TMP_BUFFER);
        if (W == NULL)
  12:	4682      	mov	sl, r0
  14:	2800      	cmp	r0, #0
  16:	f000 818e 	beq.w	336 <Transform_Sha256+0x336>
  1a:	1f23      	subs	r3, r4, #4
  1c:	9300      	str	r3, [sp, #0]
  1e:	ab04      	add	r3, sp, #16
  20:	9301      	str	r3, [sp, #4]
  22:	f104 031c 	add.w	r3, r4, #28
  26:	9302      	str	r3, [sp, #8]
  28:	e9dd 3200 	ldrd	r3, r2, [sp]
        word32 W[WC_SHA256_BLOCK_SIZE];
    #endif

        /* Copy context->state[] to working vars */
        for (i = 0; i < 8; i++)
            S[i] = sha256->digest[i];
  2c:	f853 1f04 	ldr.w	r1, [r3, #4]!
  30:	f842 1b04 	str.w	r1, [r2], #4
        for (i = 0; i < 8; i++)
  34:	9902      	ldr	r1, [sp, #8]
  36:	4299      	cmp	r1, r3
  38:	d1f8      	bne.n	2c <Transform_Sha256+0x2c>

        for (i = 0; i < 16; i++)
  3a:	2300      	movs	r3, #0
            W[i] = *((const word32*)&data[i*(int)sizeof(word32)]);
  3c:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
  40:	f84a 2023 	str.w	r2, [sl, r3, lsl #2]
        for (i = 0; i < 16; i++)
  44:	3301      	adds	r3, #1
  46:	2b10      	cmp	r3, #16
  48:	d1f8      	bne.n	3c <Transform_Sha256+0x3c>
  4a:	46d0      	mov	r8, sl
  4c:	f10a 00c0 	add.w	r0, sl, #192	; 0xc0
  50:	4652      	mov	r2, sl

        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
  52:	6b91      	ldr	r1, [r2, #56]	; 0x38
        return (x >> y) | (x << (sizeof(x) * 8 - y));
  54:	4615      	mov	r5, r2
  56:	ea4f 43f1 	mov.w	r3, r1, ror #19
  5a:	ea83 4371 	eor.w	r3, r3, r1, ror #17
  5e:	ea83 2391 	eor.w	r3, r3, r1, lsr #10
  62:	6a69      	ldr	r1, [r5, #36]	; 0x24
  64:	682d      	ldr	r5, [r5, #0]
  66:	f852 4f04 	ldr.w	r4, [r2, #4]!
  6a:	4429      	add	r1, r5
  6c:	440b      	add	r3, r1
  6e:	ea4f 41b4 	mov.w	r1, r4, ror #18
  72:	ea81 11f4 	eor.w	r1, r1, r4, ror #7
  76:	ea81 01d4 	eor.w	r1, r1, r4, lsr #3
  7a:	440b      	add	r3, r1
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
  7c:	4290      	cmp	r0, r2
            W[i] = Gamma1(W[i-2]) + W[i-7] + Gamma0(W[i-15]) + W[i-16];
  7e:	63d3      	str	r3, [r2, #60]	; 0x3c
        for (i = 16; i < WC_SHA256_BLOCK_SIZE; i++)
  80:	d1e7      	bne.n	52 <Transform_Sha256+0x52>
  82:	e9dd 1009 	ldrd	r1, r0, [sp, #36]	; 0x24
  86:	e9dd ec04 	ldrd	lr, ip, [sp, #16]
  8a:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
  8e:	f50a 7680 	add.w	r6, sl, #256	; 0x100
  92:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  94:	9c08      	ldr	r4, [sp, #32]
  96:	f8df 92a4 	ldr.w	r9, [pc, #676]	; 33c <Transform_Sha256+0x33c>
  9a:	9603      	str	r6, [sp, #12]
            }
        }
    #else
        /* partially loop unrolled */
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
            RND(0); RND(1); RND(2); RND(3);
  9c:	f8d8 7000 	ldr.w	r7, [r8]
  a0:	f8d9 6000 	ldr.w	r6, [r9]
  a4:	ea4f 2bf4 	mov.w	fp, r4, ror #11
  a8:	ea8b 1bb4 	eor.w	fp, fp, r4, ror #6
  ac:	443e      	add	r6, r7
  ae:	ea8b 6b74 	eor.w	fp, fp, r4, ror #25
  b2:	44b3      	add	fp, r6
  b4:	ea80 0601 	eor.w	r6, r0, r1
  b8:	4026      	ands	r6, r4
  ba:	4046      	eors	r6, r0
  bc:	44b3      	add	fp, r6
  be:	ea4e 070c 	orr.w	r7, lr, ip
  c2:	ea4f 06be 	mov.w	r6, lr, ror #2
  c6:	445d      	add	r5, fp
  c8:	ea86 367e 	eor.w	r6, r6, lr, ror #13
  cc:	ea0e 0b0c 	and.w	fp, lr, ip
  d0:	4017      	ands	r7, r2
  d2:	ea86 56be 	eor.w	r6, r6, lr, ror #22
  d6:	ea47 070b 	orr.w	r7, r7, fp
  da:	4437      	add	r7, r6
  dc:	442b      	add	r3, r5
  de:	f8d9 6004 	ldr.w	r6, [r9, #4]
  e2:	443d      	add	r5, r7
  e4:	f8d8 7004 	ldr.w	r7, [r8, #4]
  e8:	ea84 0b01 	eor.w	fp, r4, r1
  ec:	443e      	add	r6, r7
  ee:	4430      	add	r0, r6
  f0:	ea0b 0b03 	and.w	fp, fp, r3
  f4:	ea4f 26f3 	mov.w	r6, r3, ror #11
  f8:	ea8b 0b01 	eor.w	fp, fp, r1
  fc:	ea86 16b3 	eor.w	r6, r6, r3, ror #6
 100:	4458      	add	r0, fp
 102:	ea86 6673 	eor.w	r6, r6, r3, ror #25
 106:	4406      	add	r6, r0
 108:	ea45 070e 	orr.w	r7, r5, lr
 10c:	ea4f 3075 	mov.w	r0, r5, ror #13
 110:	ea05 0b0e 	and.w	fp, r5, lr
 114:	ea80 00b5 	eor.w	r0, r0, r5, ror #2
 118:	ea07 070c 	and.w	r7, r7, ip
 11c:	ea47 070b 	orr.w	r7, r7, fp
 120:	ea80 50b5 	eor.w	r0, r0, r5, ror #22
 124:	4438      	add	r0, r7
 126:	4430      	add	r0, r6
 128:	4432      	add	r2, r6
 12a:	f8d8 7008 	ldr.w	r7, [r8, #8]
 12e:	f8d9 6008 	ldr.w	r6, [r9, #8]
 132:	ea84 0b03 	eor.w	fp, r4, r3
 136:	443e      	add	r6, r7
 138:	4431      	add	r1, r6
 13a:	ea0b 0b02 	and.w	fp, fp, r2
 13e:	ea4f 26f2 	mov.w	r6, r2, ror #11
 142:	ea8b 0b04 	eor.w	fp, fp, r4
 146:	ea86 16b2 	eor.w	r6, r6, r2, ror #6
 14a:	4459      	add	r1, fp
 14c:	ea86 6672 	eor.w	r6, r6, r2, ror #25
 150:	440e      	add	r6, r1
 152:	ea45 0700 	orr.w	r7, r5, r0
 156:	ea4f 3170 	mov.w	r1, r0, ror #13
 15a:	ea05 0b00 	and.w	fp, r5, r0
 15e:	ea81 01b0 	eor.w	r1, r1, r0, ror #2
 162:	ea07 070e 	and.w	r7, r7, lr
 166:	ea47 070b 	orr.w	r7, r7, fp
 16a:	ea81 51b0 	eor.w	r1, r1, r0, ror #22
 16e:	4439      	add	r1, r7
 170:	4431      	add	r1, r6
 172:	44b4      	add	ip, r6
 174:	f8d8 700c 	ldr.w	r7, [r8, #12]
 178:	f8d9 600c 	ldr.w	r6, [r9, #12]
 17c:	ea83 0b02 	eor.w	fp, r3, r2
 180:	443e      	add	r6, r7
 182:	4434      	add	r4, r6
 184:	ea0b 0b0c 	and.w	fp, fp, ip
 188:	ea4f 26fc 	mov.w	r6, ip, ror #11
 18c:	ea8b 0b03 	eor.w	fp, fp, r3
 190:	ea86 16bc 	eor.w	r6, r6, ip, ror #6
 194:	445c      	add	r4, fp
 196:	ea86 667c 	eor.w	r6, r6, ip, ror #25
 19a:	4426      	add	r6, r4
 19c:	ea40 0701 	orr.w	r7, r0, r1
 1a0:	ea4f 3471 	mov.w	r4, r1, ror #13
 1a4:	ea00 0b01 	and.w	fp, r0, r1
 1a8:	ea84 04b1 	eor.w	r4, r4, r1, ror #2
 1ac:	402f      	ands	r7, r5
 1ae:	ea47 070b 	orr.w	r7, r7, fp
 1b2:	ea84 54b1 	eor.w	r4, r4, r1, ror #22
 1b6:	443c      	add	r4, r7
 1b8:	4434      	add	r4, r6
 1ba:	44b6      	add	lr, r6
            RND(4); RND(5); RND(6); RND(7);
 1bc:	f8d8 7010 	ldr.w	r7, [r8, #16]
 1c0:	f8d9 6010 	ldr.w	r6, [r9, #16]
 1c4:	ea82 0b0c 	eor.w	fp, r2, ip
 1c8:	443e      	add	r6, r7
 1ca:	4433      	add	r3, r6
 1cc:	ea0b 0b0e 	and.w	fp, fp, lr
 1d0:	ea4f 26fe 	mov.w	r6, lr, ror #11
 1d4:	ea8b 0b02 	eor.w	fp, fp, r2
 1d8:	ea86 16be 	eor.w	r6, r6, lr, ror #6
 1dc:	445b      	add	r3, fp
 1de:	ea86 667e 	eor.w	r6, r6, lr, ror #25
 1e2:	441e      	add	r6, r3
 1e4:	ea41 0704 	orr.w	r7, r1, r4
 1e8:	ea4f 3374 	mov.w	r3, r4, ror #13
 1ec:	ea01 0b04 	and.w	fp, r1, r4
 1f0:	ea83 03b4 	eor.w	r3, r3, r4, ror #2
 1f4:	4007      	ands	r7, r0
 1f6:	ea47 070b 	orr.w	r7, r7, fp
 1fa:	ea83 53b4 	eor.w	r3, r3, r4, ror #22
 1fe:	443b      	add	r3, r7
 200:	4433      	add	r3, r6
 202:	4435      	add	r5, r6
 204:	f8d8 7014 	ldr.w	r7, [r8, #20]
 208:	f8d9 6014 	ldr.w	r6, [r9, #20]
 20c:	ea8c 0b0e 	eor.w	fp, ip, lr
 210:	443e      	add	r6, r7
 212:	4432      	add	r2, r6
 214:	ea0b 0b05 	and.w	fp, fp, r5
 218:	ea4f 26f5 	mov.w	r6, r5, ror #11
 21c:	ea8b 0b0c 	eor.w	fp, fp, ip
 220:	ea86 16b5 	eor.w	r6, r6, r5, ror #6
 224:	445a      	add	r2, fp
 226:	ea86 6675 	eor.w	r6, r6, r5, ror #25
 22a:	4416      	add	r6, r2
 22c:	ea44 0703 	orr.w	r7, r4, r3
 230:	ea4f 3273 	mov.w	r2, r3, ror #13
 234:	ea04 0b03 	and.w	fp, r4, r3
 238:	400f      	ands	r7, r1
 23a:	ea82 02b3 	eor.w	r2, r2, r3, ror #2
 23e:	ea47 070b 	orr.w	r7, r7, fp
 242:	ea82 52b3 	eor.w	r2, r2, r3, ror #22
 246:	443a      	add	r2, r7
 248:	4432      	add	r2, r6
 24a:	4430      	add	r0, r6
 24c:	f8d8 7018 	ldr.w	r7, [r8, #24]
 250:	f8d9 6018 	ldr.w	r6, [r9, #24]
 254:	ea8e 0b05 	eor.w	fp, lr, r5
 258:	443e      	add	r6, r7
 25a:	44b4      	add	ip, r6
 25c:	ea0b 0b00 	and.w	fp, fp, r0
 260:	ea4f 26f0 	mov.w	r6, r0, ror #11
 264:	ea8b 0b0e 	eor.w	fp, fp, lr
 268:	ea86 16b0 	eor.w	r6, r6, r0, ror #6
 26c:	44dc      	add	ip, fp
 26e:	ea86 6670 	eor.w	r6, r6, r0, ror #25
 272:	4466      	add	r6, ip
 274:	ea43 0702 	orr.w	r7, r3, r2
 278:	ea4f 3c72 	mov.w	ip, r2, ror #13
 27c:	4027      	ands	r7, r4
 27e:	ea03 0b02 	and.w	fp, r3, r2
 282:	ea8c 0cb2 	eor.w	ip, ip, r2, ror #2
 286:	ea47 070b 	orr.w	r7, r7, fp
 28a:	ea8c 5cb2 	eor.w	ip, ip, r2, ror #22
 28e:	44bc      	add	ip, r7
 290:	44b4      	add	ip, r6
 292:	4431      	add	r1, r6
 294:	f8d8 701c 	ldr.w	r7, [r8, #28]
 298:	f8d9 601c 	ldr.w	r6, [r9, #28]
 29c:	ea85 0b00 	eor.w	fp, r5, r0
 2a0:	443e      	add	r6, r7
 2a2:	44b6      	add	lr, r6
 2a4:	ea0b 0b01 	and.w	fp, fp, r1
 2a8:	ea4f 26f1 	mov.w	r6, r1, ror #11
 2ac:	ea8b 0b05 	eor.w	fp, fp, r5
 2b0:	ea86 16b1 	eor.w	r6, r6, r1, ror #6
 2b4:	44de      	add	lr, fp
 2b6:	ea86 6671 	eor.w	r6, r6, r1, ror #25
 2ba:	4476      	add	r6, lr
 2bc:	ea42 070c 	orr.w	r7, r2, ip
 2c0:	ea4f 3e7c 	mov.w	lr, ip, ror #13
 2c4:	ea8e 0ebc 	eor.w	lr, lr, ip, ror #2
 2c8:	401f      	ands	r7, r3
 2ca:	ea02 0b0c 	and.w	fp, r2, ip
 2ce:	ea8e 5ebc 	eor.w	lr, lr, ip, ror #22
 2d2:	ea47 070b 	orr.w	r7, r7, fp
 2d6:	44be      	add	lr, r7
 2d8:	4434      	add	r4, r6
 2da:	44b6      	add	lr, r6
        for (i = 0; i < WC_SHA256_BLOCK_SIZE; i += 8) {
 2dc:	9e03      	ldr	r6, [sp, #12]
 2de:	f108 0820 	add.w	r8, r8, #32
 2e2:	4546      	cmp	r6, r8
 2e4:	f109 0920 	add.w	r9, r9, #32
 2e8:	f47f aed8 	bne.w	9c <Transform_Sha256+0x9c>
 2ec:	e9cd 1009 	strd	r1, r0, [sp, #36]	; 0x24
 2f0:	e9cd ec04 	strd	lr, ip, [sp, #16]
 2f4:	e9cd 2306 	strd	r2, r3, [sp, #24]
 2f8:	950b      	str	r5, [sp, #44]	; 0x2c
 2fa:	9408      	str	r4, [sp, #32]
        }
    #endif /* USE_SLOW_SHA256 */

        /* Add the working vars back into digest state[] */
        for (i = 0; i < 8; i++) {
            sha256->digest[i] += S[i];
 2fc:	9b01      	ldr	r3, [sp, #4]
 2fe:	9900      	ldr	r1, [sp, #0]
 300:	f853 2b04 	ldr.w	r2, [r3], #4
 304:	9301      	str	r3, [sp, #4]
 306:	f851 3f04 	ldr.w	r3, [r1, #4]!
 30a:	9100      	str	r1, [sp, #0]
 30c:	4413      	add	r3, r2
 30e:	600b      	str	r3, [r1, #0]
        for (i = 0; i < 8; i++) {
 310:	9b02      	ldr	r3, [sp, #8]
 312:	428b      	cmp	r3, r1
 314:	d1f2      	bne.n	2fc <Transform_Sha256+0x2fc>
 316:	f50a 7280 	add.w	r2, sl, #256	; 0x100
 31a:	4653      	mov	r3, sl
 31c:	2100      	movs	r1, #0
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
 31e:	4293      	cmp	r3, r2
 320:	d106      	bne.n	330 <Transform_Sha256+0x330>
        }

    #if defined(WOLFSSL_SMALL_STACK) && !defined(WOLFSSL_SMALL_STACK_CACHE)
        ForceZero(W, sizeof(word32) * WC_SHA256_BLOCK_SIZE);
        XFREE(W, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 322:	4650      	mov	r0, sl
 324:	f7ff fffe 	bl	0 <free>
    #endif
        return 0;
 328:	2000      	movs	r0, #0
    }
 32a:	b00d      	add	sp, #52	; 0x34
 32c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 330:	f803 1b01 	strb.w	r1, [r3], #1
 334:	e7f3      	b.n	31e <Transform_Sha256+0x31e>
            return MEMORY_E;
 336:	f06f 007c 	mvn.w	r0, #124	; 0x7c
 33a:	e7f6      	b.n	32a <Transform_Sha256+0x32a>
 33c:	00000000 	.word	0x00000000

Disassembly of section .text.wc_InitSha256_ex:

00000000 <wc_InitSha256_ex>:
    {
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
        if (sha256 == NULL)
   4:	4604      	mov	r4, r0
   6:	b1f0      	cbz	r0, 46 <wc_InitSha256_ex+0x46>
    XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
   8:	2220      	movs	r2, #32
   a:	2100      	movs	r1, #0
   c:	f7ff fffe 	bl	0 <memset>
    sha256->digest[1] = 0xBB67AE85L;
  10:	4b0e      	ldr	r3, [pc, #56]	; (4c <wc_InitSha256_ex+0x4c>)
  12:	4a0f      	ldr	r2, [pc, #60]	; (50 <wc_InitSha256_ex+0x50>)
    sha256->digest[3] = 0xA54FF53AL;
  14:	490f      	ldr	r1, [pc, #60]	; (54 <wc_InitSha256_ex+0x54>)
    sha256->digest[5] = 0x9B05688CL;
  16:	4810      	ldr	r0, [pc, #64]	; (58 <wc_InitSha256_ex+0x58>)
    sha256->digest[1] = 0xBB67AE85L;
  18:	e9c4 2300 	strd	r2, r3, [r4]
    sha256->digest[3] = 0xA54FF53AL;
  1c:	4b0f      	ldr	r3, [pc, #60]	; (5c <wc_InitSha256_ex+0x5c>)
  1e:	e9c4 1302 	strd	r1, r3, [r4, #8]
    sha256->digest[5] = 0x9B05688CL;
  22:	4b0f      	ldr	r3, [pc, #60]	; (60 <wc_InitSha256_ex+0x60>)
  24:	e9c4 0304 	strd	r0, r3, [r4, #16]
    sha256->digest[6] = 0x1F83D9ABL;
  28:	4b0e      	ldr	r3, [pc, #56]	; (64 <wc_InitSha256_ex+0x64>)
  2a:	61a3      	str	r3, [r4, #24]
    sha256->buffLen = 0;
  2c:	2000      	movs	r0, #0
    sha256->digest[7] = 0x5BE0CD19L;
  2e:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
  32:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
    sha256->loLen   = 0;
  36:	e9c4 0018 	strd	r0, r0, [r4, #96]	; 0x60
        sha256->heap = heap;
  3a:	e9c4 051a 	strd	r0, r5, [r4, #104]	; 0x68
    sha256->digest[7] = 0x5BE0CD19L;
  3e:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
  42:	61e3      	str	r3, [r4, #28]
    }
  44:	bd38      	pop	{r3, r4, r5, pc}
            return BAD_FUNC_ARG;
  46:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  4a:	e7fb      	b.n	44 <wc_InitSha256_ex+0x44>
  4c:	bb67ae85 	.word	0xbb67ae85
  50:	6a09e667 	.word	0x6a09e667
  54:	3c6ef372 	.word	0x3c6ef372
  58:	510e527f 	.word	0x510e527f
  5c:	a54ff53a 	.word	0xa54ff53a
  60:	9b05688c 	.word	0x9b05688c
  64:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text.wc_Sha256Update:

00000000 <wc_Sha256Update>:
#if defined(WOLFSSL_KCAPI_HASH)
    /* implemented in wolfcrypt/src/port/kcapi/kcapi_hash.c */

#else
    int wc_Sha256Update(wc_Sha256* sha256, const byte* data, word32 len)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4614      	mov	r4, r2
        if (sha256 == NULL || (data == NULL && len > 0)) {
   8:	4605      	mov	r5, r0
   a:	2800      	cmp	r0, #0
   c:	d049      	beq.n	a2 <wc_Sha256Update+0xa2>
   e:	b919      	cbnz	r1, 18 <wc_Sha256Update+0x18>
  10:	2a00      	cmp	r2, #0
  12:	d146      	bne.n	a2 <wc_Sha256Update+0xa2>
            sha256->buffLen = len;
  14:	2000      	movs	r0, #0
  16:	e042      	b.n	9e <wc_Sha256Update+0x9e>
        if (sha256->buffLen >= WC_SHA256_BLOCK_SIZE) {
  18:	6e00      	ldr	r0, [r0, #96]	; 0x60
  1a:	283f      	cmp	r0, #63	; 0x3f
  1c:	d844      	bhi.n	a8 <wc_Sha256Update+0xa8>
            sha256->hiLen++;                       /* carry low to high */
  1e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
  20:	18d3      	adds	r3, r2, r3
        if ((sha256->loLen += len) < tmp) {
  22:	666b      	str	r3, [r5, #100]	; 0x64
            sha256->hiLen++;                       /* carry low to high */
  24:	bf22      	ittt	cs
  26:	6eab      	ldrcs	r3, [r5, #104]	; 0x68
  28:	3301      	addcs	r3, #1
  2a:	66ab      	strcs	r3, [r5, #104]	; 0x68
        local = (byte*)sha256->buffer;
  2c:	f105 0720 	add.w	r7, r5, #32
        if (sha256->buffLen > 0) {
  30:	b1c8      	cbz	r0, 66 <wc_Sha256Update+0x66>
            blocksLen = min(len, WC_SHA256_BLOCK_SIZE - sha256->buffLen);
  32:	f1c0 0840 	rsb	r8, r0, #64	; 0x40
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_MISC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
        return a > b ? b : a;
  36:	4590      	cmp	r8, r2
  38:	bf28      	it	cs
  3a:	4690      	movcs	r8, r2
            XMEMCPY(&local[sha256->buffLen], data, blocksLen);
  3c:	4642      	mov	r2, r8
  3e:	4438      	add	r0, r7
  40:	f7ff fffe 	bl	0 <memcpy>
            sha256->buffLen += blocksLen;
  44:	6e2a      	ldr	r2, [r5, #96]	; 0x60
  46:	4442      	add	r2, r8
            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
  48:	2a40      	cmp	r2, #64	; 0x40
            sha256->buffLen += blocksLen;
  4a:	662a      	str	r2, [r5, #96]	; 0x60
            data            += blocksLen;
  4c:	4446      	add	r6, r8
            len             -= blocksLen;
  4e:	eba4 0408 	sub.w	r4, r4, r8
            if (sha256->buffLen == WC_SHA256_BLOCK_SIZE) {
  52:	d108      	bne.n	66 <wc_Sha256Update+0x66>
                    ByteReverseWords(sha256->buffer, sha256->buffer,
  54:	4638      	mov	r0, r7
  56:	4639      	mov	r1, r7
  58:	f7ff fffe 	bl	0 <wc_Sha256Update>
                ret = XTRANSFORM(sha256, (const byte*)local);
  5c:	4628      	mov	r0, r5
  5e:	f7ff fffe 	bl	0 <wc_Sha256Update>
                if (ret == 0)
  62:	b9e0      	cbnz	r0, 9e <wc_Sha256Update+0x9e>
                    sha256->buffLen = 0;
  64:	6628      	str	r0, [r5, #96]	; 0x60
  66:	4426      	add	r6, r4
            while (len >= WC_SHA256_BLOCK_SIZE) {
  68:	2c3f      	cmp	r4, #63	; 0x3f
  6a:	eba6 0104 	sub.w	r1, r6, r4
  6e:	d807      	bhi.n	80 <wc_Sha256Update+0x80>
        if (ret == 0 && len > 0) {
  70:	2c00      	cmp	r4, #0
  72:	d0cf      	beq.n	14 <wc_Sha256Update+0x14>
            XMEMCPY(local, data, len);
  74:	4622      	mov	r2, r4
  76:	4638      	mov	r0, r7
  78:	f7ff fffe 	bl	0 <memcpy>
            sha256->buffLen = len;
  7c:	662c      	str	r4, [r5, #96]	; 0x60
  7e:	e7c9      	b.n	14 <wc_Sha256Update+0x14>
                    XMEMCPY(local32, data, WC_SHA256_BLOCK_SIZE);
  80:	2240      	movs	r2, #64	; 0x40
  82:	4638      	mov	r0, r7
  84:	f7ff fffe 	bl	0 <memcpy>
                    ByteReverseWords(local32, local32, WC_SHA256_BLOCK_SIZE);
  88:	4638      	mov	r0, r7
  8a:	2240      	movs	r2, #64	; 0x40
  8c:	4639      	mov	r1, r7
  8e:	f7ff fffe 	bl	0 <wc_Sha256Update>
                ret = XTRANSFORM(sha256, (const byte*)local32);
  92:	4628      	mov	r0, r5
                len  -= WC_SHA256_BLOCK_SIZE;
  94:	3c40      	subs	r4, #64	; 0x40
                ret = XTRANSFORM(sha256, (const byte*)local32);
  96:	f7ff fffe 	bl	0 <wc_Sha256Update>
                if (ret != 0)
  9a:	2800      	cmp	r0, #0
  9c:	d0e4      	beq.n	68 <wc_Sha256Update+0x68>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        return Sha256Update(sha256, data, len);
    }
  9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return BAD_FUNC_ARG;
  a2:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  a6:	e7fa      	b.n	9e <wc_Sha256Update+0x9e>
            return BUFFER_E;
  a8:	f06f 0083 	mvn.w	r0, #131	; 0x83
  ac:	e7f7      	b.n	9e <wc_Sha256Update+0x9e>

Disassembly of section .text.wc_Sha256FinalRaw:

00000000 <wc_Sha256FinalRaw>:
    }

#if !defined(WOLFSSL_KCAPI_HASH)

    int wc_Sha256FinalRaw(wc_Sha256* sha256, byte* hash)
    {
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
   4:	b088      	sub	sp, #32
    #ifdef LITTLE_ENDIAN_ORDER
        word32 digest[WC_SHA256_DIGEST_SIZE / sizeof(word32)];
    #endif

        if (sha256 == NULL || hash == NULL) {
   6:	4601      	mov	r1, r0
   8:	b160      	cbz	r0, 24 <wc_Sha256FinalRaw+0x24>
   a:	b15c      	cbz	r4, 24 <wc_Sha256FinalRaw+0x24>
            return BAD_FUNC_ARG;
        }

    #ifdef LITTLE_ENDIAN_ORDER
        ByteReverseWords((word32*)digest, (word32*)sha256->digest,
   c:	4668      	mov	r0, sp
   e:	2220      	movs	r2, #32
  10:	f7ff fffe 	bl	0 <wc_Sha256FinalRaw>
                                                         WC_SHA256_DIGEST_SIZE);
        XMEMCPY(hash, digest, WC_SHA256_DIGEST_SIZE);
  14:	4601      	mov	r1, r0
  16:	2220      	movs	r2, #32
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <memcpy>
    #else
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
    #endif

        return 0;
  1e:	2000      	movs	r0, #0
    }
  20:	b008      	add	sp, #32
  22:	bd10      	pop	{r4, pc}
            return BAD_FUNC_ARG;
  24:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  28:	e7fa      	b.n	20 <wc_Sha256FinalRaw+0x20>

Disassembly of section .text.wc_Sha256Final:

00000000 <wc_Sha256Final>:

    int wc_Sha256Final(wc_Sha256* sha256, byte* hash)
    {
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460f      	mov	r7, r1
        int ret;

        if (sha256 == NULL || hash == NULL) {
   4:	4604      	mov	r4, r0
   6:	2800      	cmp	r0, #0
   8:	d070      	beq.n	ec <wc_Sha256Final+0xec>
   a:	2900      	cmp	r1, #0
   c:	d06e      	beq.n	ec <wc_Sha256Final+0xec>
        if (sha256->buffLen > WC_SHA256_BLOCK_SIZE - 1) {
   e:	6e03      	ldr	r3, [r0, #96]	; 0x60
  10:	2b3f      	cmp	r3, #63	; 0x3f
  12:	d86e      	bhi.n	f2 <wc_Sha256Final+0xf2>
        local = (byte*)sha256->buffer;
  14:	f100 0620 	add.w	r6, r0, #32
        local[sha256->buffLen++] = 0x80; /* add 1 */
  18:	1c5a      	adds	r2, r3, #1
  1a:	6602      	str	r2, [r0, #96]	; 0x60
  1c:	2280      	movs	r2, #128	; 0x80
  1e:	54f2      	strb	r2, [r6, r3]
        if (sha256->buffLen > WC_SHA256_PAD_SIZE) {
  20:	6e00      	ldr	r0, [r0, #96]	; 0x60
  22:	2838      	cmp	r0, #56	; 0x38
  24:	d912      	bls.n	4c <wc_Sha256Final+0x4c>
            XMEMSET(&local[sha256->buffLen], 0,
  26:	f1c0 0240 	rsb	r2, r0, #64	; 0x40
  2a:	2100      	movs	r1, #0
  2c:	4430      	add	r0, r6
  2e:	f7ff fffe 	bl	0 <memset>
            sha256->buffLen += WC_SHA256_BLOCK_SIZE - sha256->buffLen;
  32:	2240      	movs	r2, #64	; 0x40
  34:	6622      	str	r2, [r4, #96]	; 0x60
                ByteReverseWords(sha256->buffer, sha256->buffer,
  36:	4631      	mov	r1, r6
  38:	4630      	mov	r0, r6
  3a:	f7ff fffe 	bl	0 <wc_Sha256Final>
            ret = XTRANSFORM(sha256, (const byte*)local);
  3e:	4620      	mov	r0, r4
  40:	f7ff fffe 	bl	0 <wc_Sha256Final>
            if (ret != 0)
  44:	4605      	mov	r5, r0
  46:	2800      	cmp	r0, #0
  48:	d14e      	bne.n	e8 <wc_Sha256Final+0xe8>
            sha256->buffLen = 0;
  4a:	6620      	str	r0, [r4, #96]	; 0x60
        XMEMSET(&local[sha256->buffLen], 0,
  4c:	6e20      	ldr	r0, [r4, #96]	; 0x60
  4e:	2100      	movs	r1, #0
  50:	f1c0 0238 	rsb	r2, r0, #56	; 0x38
  54:	4430      	add	r0, r6
  56:	f7ff fffe 	bl	0 <memset>
                                                         (sha256->hiLen << 3);
  5a:	e9d4 3119 	ldrd	r3, r1, [r4, #100]	; 0x64
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
  5e:	0f5a      	lsrs	r2, r3, #29
  60:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
        sha256->loLen = sha256->loLen << 3;
  64:	00db      	lsls	r3, r3, #3
  66:	6663      	str	r3, [r4, #100]	; 0x64
        sha256->hiLen = (sha256->loLen >> (8 * sizeof(sha256->loLen) - 3)) +
  68:	66a2      	str	r2, [r4, #104]	; 0x68
            ByteReverseWords(sha256->buffer, sha256->buffer,
  6a:	4631      	mov	r1, r6
  6c:	2240      	movs	r2, #64	; 0x40
  6e:	4630      	mov	r0, r6
  70:	f7ff fffe 	bl	0 <wc_Sha256Final>
        XMEMCPY(&local[WC_SHA256_PAD_SIZE], &sha256->hiLen, sizeof(word32));
  74:	2204      	movs	r2, #4
  76:	f104 0168 	add.w	r1, r4, #104	; 0x68
  7a:	f104 0058 	add.w	r0, r4, #88	; 0x58
  7e:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(&local[WC_SHA256_PAD_SIZE + sizeof(word32)], &sha256->loLen,
  82:	2204      	movs	r2, #4
  84:	f104 0164 	add.w	r1, r4, #100	; 0x64
  88:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  8c:	f7ff fffe 	bl	0 <memcpy>
        ret = XTRANSFORM(sha256, (const byte*)local);
  90:	4631      	mov	r1, r6
  92:	4620      	mov	r0, r4
  94:	f7ff fffe 	bl	0 <wc_Sha256Final>
        #endif
        }
    #endif /* WOLFSSL_ASYNC_CRYPT */

        ret = Sha256Final(sha256);
        if (ret != 0) {
  98:	4605      	mov	r5, r0
  9a:	bb28      	cbnz	r0, e8 <wc_Sha256Final+0xe8>
            return ret;
        }

    #if defined(LITTLE_ENDIAN_ORDER)
        ByteReverseWords(sha256->digest, sha256->digest, WC_SHA256_DIGEST_SIZE);
  9c:	4621      	mov	r1, r4
  9e:	2220      	movs	r2, #32
  a0:	4620      	mov	r0, r4
  a2:	f7ff fffe 	bl	0 <wc_Sha256Final>
    #endif
        XMEMCPY(hash, sha256->digest, WC_SHA256_DIGEST_SIZE);
  a6:	2220      	movs	r2, #32
  a8:	4638      	mov	r0, r7
  aa:	f7ff fffe 	bl	0 <memcpy>
    XMEMSET(sha256->digest, 0, sizeof(sha256->digest));
  ae:	2220      	movs	r2, #32
  b0:	4629      	mov	r1, r5
  b2:	4620      	mov	r0, r4
  b4:	f7ff fffe 	bl	0 <memset>
    sha256->digest[1] = 0xBB67AE85L;
  b8:	4b0f      	ldr	r3, [pc, #60]	; (f8 <wc_Sha256Final+0xf8>)
  ba:	4a10      	ldr	r2, [pc, #64]	; (fc <wc_Sha256Final+0xfc>)
    sha256->digest[3] = 0xA54FF53AL;
  bc:	4910      	ldr	r1, [pc, #64]	; (100 <wc_Sha256Final+0x100>)
    sha256->digest[5] = 0x9B05688CL;
  be:	4811      	ldr	r0, [pc, #68]	; (104 <wc_Sha256Final+0x104>)
    sha256->hiLen   = 0;
  c0:	66a5      	str	r5, [r4, #104]	; 0x68
    sha256->digest[1] = 0xBB67AE85L;
  c2:	e9c4 2300 	strd	r2, r3, [r4]
    sha256->digest[3] = 0xA54FF53AL;
  c6:	4b10      	ldr	r3, [pc, #64]	; (108 <wc_Sha256Final+0x108>)
  c8:	e9c4 1302 	strd	r1, r3, [r4, #8]
    sha256->digest[5] = 0x9B05688CL;
  cc:	4b0f      	ldr	r3, [pc, #60]	; (10c <wc_Sha256Final+0x10c>)
  ce:	e9c4 0304 	strd	r0, r3, [r4, #16]
    sha256->digest[6] = 0x1F83D9ABL;
  d2:	4b0f      	ldr	r3, [pc, #60]	; (110 <wc_Sha256Final+0x110>)
  d4:	61a3      	str	r3, [r4, #24]
    sha256->digest[7] = 0x5BE0CD19L;
  d6:	f103 5374 	add.w	r3, r3, #1023410176	; 0x3d000000
  da:	f5a3 0323 	sub.w	r3, r3, #10682368	; 0xa30000
    sha256->loLen   = 0;
  de:	e9c4 5518 	strd	r5, r5, [r4, #96]	; 0x60
    sha256->digest[7] = 0x5BE0CD19L;
  e2:	f6a3 4392 	subw	r3, r3, #3218	; 0xc92
  e6:	61e3      	str	r3, [r4, #28]

        return InitSha256(sha256);  /* reset state */
    }
  e8:	4628      	mov	r0, r5
  ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return BAD_FUNC_ARG;
  ec:	f06f 05ac 	mvn.w	r5, #172	; 0xac
  f0:	e7fa      	b.n	e8 <wc_Sha256Final+0xe8>
            return BAD_STATE_E;
  f2:	f06f 05bf 	mvn.w	r5, #191	; 0xbf
  f6:	e7f7      	b.n	e8 <wc_Sha256Final+0xe8>
  f8:	bb67ae85 	.word	0xbb67ae85
  fc:	6a09e667 	.word	0x6a09e667
 100:	3c6ef372 	.word	0x3c6ef372
 104:	510e527f 	.word	0x510e527f
 108:	a54ff53a 	.word	0xa54ff53a
 10c:	9b05688c 	.word	0x9b05688c
 110:	1f83d9ab 	.word	0x1f83d9ab

Disassembly of section .text.wc_InitSha256:

00000000 <wc_InitSha256>:
    int devId = INVALID_DEVID;

#ifdef WOLF_CRYPTO_CB
    devId = wc_CryptoCb_DefaultDevID();
#endif
    return wc_InitSha256_ex(sha256, NULL, devId);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_InitSha256>

Disassembly of section .text.wc_Sha256Free:

00000000 <wc_Sha256Free>:
#if !defined(WOLFSSL_HAVE_PSA) || defined(WOLFSSL_PSA_NO_HASH)
    /* implemented in wolfcrypt/src/port/psa/psa_hash.c */

void wc_Sha256Free(wc_Sha256* sha256)
{
    if (sha256 == NULL)
   0:	b120      	cbz	r0, c <wc_Sha256Free+0xc>
   2:	f100 0370 	add.w	r3, r0, #112	; 0x70
    while (len--) *z++ = 0;
   6:	2200      	movs	r2, #0
   8:	4298      	cmp	r0, r3
   a:	d100      	bne.n	e <wc_Sha256Free+0xe>
    else {
        ESP_LOGV(TAG, "Hardware unlock not needed in wc_Sha256Free.");
    }
#endif
    ForceZero(sha256, sizeof(*sha256));
}
   c:	4770      	bx	lr
   e:	f800 2b01 	strb.w	r2, [r0], #1
  12:	e7f9      	b.n	8 <wc_Sha256Free+0x8>

Disassembly of section .text.wc_Sha256Copy:

00000000 <wc_Sha256Copy>:
#endif

    return ret;
}
int wc_Sha256Copy(wc_Sha256* src, wc_Sha256* dst)
{
   0:	b508      	push	{r3, lr}
   2:	460b      	mov	r3, r1
    int ret = 0;

    if (src == NULL || dst == NULL) {
   4:	4601      	mov	r1, r0
   6:	b130      	cbz	r0, 16 <wc_Sha256Copy+0x16>
   8:	b12b      	cbz	r3, 16 <wc_Sha256Copy+0x16>
        return BAD_FUNC_ARG;
    }

    XMEMCPY(dst, src, sizeof(wc_Sha256));
   a:	2270      	movs	r2, #112	; 0x70
   c:	4618      	mov	r0, r3
   e:	f7ff fffe 	bl	0 <memcpy>
            return MEMORY_E;
        XMEMCPY(dst->msg, src->msg, src->len);
    }
#endif

    return ret;
  12:	2000      	movs	r0, #0
}
  14:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1a:	e7fb      	b.n	14 <wc_Sha256Copy+0x14>

Disassembly of section .text.wc_Sha256GetHash:

00000000 <wc_Sha256GetHash>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460e      	mov	r6, r1
    if (sha256 == NULL || hash == NULL) {
   4:	4604      	mov	r4, r0
   6:	b1c0      	cbz	r0, 3a <wc_Sha256GetHash+0x3a>
   8:	b1b9      	cbz	r1, 3a <wc_Sha256GetHash+0x3a>
    tmpSha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
   a:	2070      	movs	r0, #112	; 0x70
   c:	f7ff fffe 	bl	0 <malloc>
    if (tmpSha256 == NULL) {
  10:	4605      	mov	r5, r0
  12:	b1a8      	cbz	r0, 40 <wc_Sha256GetHash+0x40>
    ret = wc_Sha256Copy(sha256, tmpSha256);
  14:	4601      	mov	r1, r0
  16:	4620      	mov	r0, r4
  18:	f7ff fffe 	bl	0 <wc_Sha256GetHash>
    if (ret == 0) {
  1c:	4604      	mov	r4, r0
  1e:	b938      	cbnz	r0, 30 <wc_Sha256GetHash+0x30>
        ret = wc_Sha256Final(tmpSha256, hash);
  20:	4631      	mov	r1, r6
  22:	4628      	mov	r0, r5
  24:	f7ff fffe 	bl	0 <wc_Sha256GetHash>
  28:	4604      	mov	r4, r0
        wc_Sha256Free(tmpSha256); /* TODO move outside brackets? */
  2a:	4628      	mov	r0, r5
  2c:	f7ff fffe 	bl	0 <wc_Sha256GetHash>
    XFREE(tmpSha256, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  30:	4628      	mov	r0, r5
  32:	f7ff fffe 	bl	0 <free>
}
  36:	4620      	mov	r0, r4
  38:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  3a:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  3e:	e7fa      	b.n	36 <wc_Sha256GetHash+0x36>
        return MEMORY_E;
  40:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  44:	e7f7      	b.n	36 <wc_Sha256GetHash+0x36>

sha512.o:     file format elf32-littlearm


Disassembly of section .text.InitSha512:

00000000 <InitSha512>:
#else

#ifdef WOLFSSL_SHA512

static int InitSha512(wc_Sha512* sha512)
{
   0:	b530      	push	{r4, r5, lr}
    if (sha512 == NULL)
   2:	2800      	cmp	r0, #0
   4:	d032      	beq.n	6c <InitSha512+0x6c>
        return BAD_FUNC_ARG;

    sha512->digest[0] = W64LIT(0x6a09e667f3bcc908);
   6:	a31c      	add	r3, pc, #112	; (adr r3, 78 <InitSha512+0x78>)
   8:	e9d3 2300 	ldrd	r2, r3, [r3]
   c:	e9c0 2300 	strd	r2, r3, [r0]
    sha512->digest[1] = W64LIT(0xbb67ae8584caa73b);
  10:	a31b      	add	r3, pc, #108	; (adr r3, 80 <InitSha512+0x80>)
  12:	e9d3 2300 	ldrd	r2, r3, [r3]
  16:	e9c0 2302 	strd	r2, r3, [r0, #8]
    sha512->digest[2] = W64LIT(0x3c6ef372fe94f82b);
  1a:	a31b      	add	r3, pc, #108	; (adr r3, 88 <InitSha512+0x88>)
  1c:	e9d3 2300 	ldrd	r2, r3, [r3]
  20:	e9c0 2304 	strd	r2, r3, [r0, #16]
    sha512->digest[3] = W64LIT(0xa54ff53a5f1d36f1);
  24:	a31a      	add	r3, pc, #104	; (adr r3, 90 <InitSha512+0x90>)
  26:	e9d3 2300 	ldrd	r2, r3, [r3]
  2a:	e9c0 2306 	strd	r2, r3, [r0, #24]
    sha512->digest[4] = W64LIT(0x510e527fade682d1);
  2e:	a31a      	add	r3, pc, #104	; (adr r3, 98 <InitSha512+0x98>)
  30:	e9d3 2300 	ldrd	r2, r3, [r3]
  34:	e9c0 2308 	strd	r2, r3, [r0, #32]
    sha512->digest[5] = W64LIT(0x9b05688c2b3e6c1f);
  38:	a319      	add	r3, pc, #100	; (adr r3, a0 <InitSha512+0xa0>)
  3a:	e9d3 2300 	ldrd	r2, r3, [r3]
  3e:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    sha512->digest[6] = W64LIT(0x1f83d9abfb41bd6b);
  42:	a319      	add	r3, pc, #100	; (adr r3, a8 <InitSha512+0xa8>)
  44:	e9d3 2300 	ldrd	r2, r3, [r3]
  48:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
    sha512->digest[7] = W64LIT(0x5be0cd19137e2179);
  4c:	a318      	add	r3, pc, #96	; (adr r3, b0 <InitSha512+0xb0>)
  4e:	e9d3 2300 	ldrd	r2, r3, [r3]

    sha512->buffLen = 0;
    sha512->loLen   = 0;
  52:	2400      	movs	r4, #0
    sha512->digest[7] = W64LIT(0x5be0cd19137e2179);
  54:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
    sha512->loLen   = 0;
  58:	2500      	movs	r5, #0
    sha512->buffLen = 0;
  5a:	2300      	movs	r3, #0
    sha512->loLen   = 0;
  5c:	e9c0 4532 	strd	r4, r5, [r0, #200]	; 0xc8
    sha512->hiLen   = 0;
  60:	e9c0 4534 	strd	r4, r5, [r0, #208]	; 0xd0
    sha512->buffLen = 0;
  64:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
#endif

#ifdef WOLFSSL_HASH_FLAGS
    sha512->flags = 0;
#endif
    return 0;
  68:	4618      	mov	r0, r3
}
  6a:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  6c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  70:	e7fb      	b.n	6a <InitSha512+0x6a>
  72:	bf00      	nop
  74:	f3af 8000 	nop.w
  78:	f3bcc908 	.word	0xf3bcc908
  7c:	6a09e667 	.word	0x6a09e667
  80:	84caa73b 	.word	0x84caa73b
  84:	bb67ae85 	.word	0xbb67ae85
  88:	fe94f82b 	.word	0xfe94f82b
  8c:	3c6ef372 	.word	0x3c6ef372
  90:	5f1d36f1 	.word	0x5f1d36f1
  94:	a54ff53a 	.word	0xa54ff53a
  98:	ade682d1 	.word	0xade682d1
  9c:	510e527f 	.word	0x510e527f
  a0:	2b3e6c1f 	.word	0x2b3e6c1f
  a4:	9b05688c 	.word	0x9b05688c
  a8:	fb41bd6b 	.word	0xfb41bd6b
  ac:	1f83d9ab 	.word	0x1f83d9ab
  b0:	137e2179 	.word	0x137e2179
  b4:	5be0cd19 	.word	0x5be0cd19

Disassembly of section .text.InitSha512_224:

00000000 <InitSha512_224>:
 * Note that sha512/224 has different initial hash value from sha512.
 * The initial hash value consists of eight 64bit words. They are given
 * in FIPS180-4.
 */
static int InitSha512_224(wc_Sha512* sha512)
{
   0:	b530      	push	{r4, r5, lr}
    if (sha512 == NULL)
   2:	2800      	cmp	r0, #0
   4:	d032      	beq.n	6c <InitSha512_224+0x6c>
        return BAD_FUNC_ARG;

    sha512->digest[0] = W64LIT(0x8c3d37c819544da2);
   6:	a31c      	add	r3, pc, #112	; (adr r3, 78 <InitSha512_224+0x78>)
   8:	e9d3 2300 	ldrd	r2, r3, [r3]
   c:	e9c0 2300 	strd	r2, r3, [r0]
    sha512->digest[1] = W64LIT(0x73e1996689dcd4d6);
  10:	a31b      	add	r3, pc, #108	; (adr r3, 80 <InitSha512_224+0x80>)
  12:	e9d3 2300 	ldrd	r2, r3, [r3]
  16:	e9c0 2302 	strd	r2, r3, [r0, #8]
    sha512->digest[2] = W64LIT(0x1dfab7ae32ff9c82);
  1a:	a31b      	add	r3, pc, #108	; (adr r3, 88 <InitSha512_224+0x88>)
  1c:	e9d3 2300 	ldrd	r2, r3, [r3]
  20:	e9c0 2304 	strd	r2, r3, [r0, #16]
    sha512->digest[3] = W64LIT(0x679dd514582f9fcf);
  24:	a31a      	add	r3, pc, #104	; (adr r3, 90 <InitSha512_224+0x90>)
  26:	e9d3 2300 	ldrd	r2, r3, [r3]
  2a:	e9c0 2306 	strd	r2, r3, [r0, #24]
    sha512->digest[4] = W64LIT(0x0f6d2b697bd44da8);
  2e:	a31a      	add	r3, pc, #104	; (adr r3, 98 <InitSha512_224+0x98>)
  30:	e9d3 2300 	ldrd	r2, r3, [r3]
  34:	e9c0 2308 	strd	r2, r3, [r0, #32]
    sha512->digest[5] = W64LIT(0x77e36f7304c48942);
  38:	a319      	add	r3, pc, #100	; (adr r3, a0 <InitSha512_224+0xa0>)
  3a:	e9d3 2300 	ldrd	r2, r3, [r3]
  3e:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    sha512->digest[6] = W64LIT(0x3f9d85a86a1d36c8);
  42:	a319      	add	r3, pc, #100	; (adr r3, a8 <InitSha512_224+0xa8>)
  44:	e9d3 2300 	ldrd	r2, r3, [r3]
  48:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
    sha512->digest[7] = W64LIT(0x1112e6ad91d692a1);
  4c:	a318      	add	r3, pc, #96	; (adr r3, b0 <InitSha512_224+0xb0>)
  4e:	e9d3 2300 	ldrd	r2, r3, [r3]

    sha512->buffLen = 0;
    sha512->loLen   = 0;
  52:	2400      	movs	r4, #0
    sha512->digest[7] = W64LIT(0x1112e6ad91d692a1);
  54:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
    sha512->loLen   = 0;
  58:	2500      	movs	r5, #0
    sha512->buffLen = 0;
  5a:	2300      	movs	r3, #0
    sha512->loLen   = 0;
  5c:	e9c0 4532 	strd	r4, r5, [r0, #200]	; 0xc8
    sha512->hiLen   = 0;
  60:	e9c0 4534 	strd	r4, r5, [r0, #208]	; 0xd0
    sha512->buffLen = 0;
  64:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
#endif

#ifdef WOLFSSL_HASH_FLAGS
    sha512->flags = 0;
#endif
    return 0;
  68:	4618      	mov	r0, r3
}
  6a:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  6c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  70:	e7fb      	b.n	6a <InitSha512_224+0x6a>
  72:	bf00      	nop
  74:	f3af 8000 	nop.w
  78:	19544da2 	.word	0x19544da2
  7c:	8c3d37c8 	.word	0x8c3d37c8
  80:	89dcd4d6 	.word	0x89dcd4d6
  84:	73e19966 	.word	0x73e19966
  88:	32ff9c82 	.word	0x32ff9c82
  8c:	1dfab7ae 	.word	0x1dfab7ae
  90:	582f9fcf 	.word	0x582f9fcf
  94:	679dd514 	.word	0x679dd514
  98:	7bd44da8 	.word	0x7bd44da8
  9c:	0f6d2b69 	.word	0x0f6d2b69
  a0:	04c48942 	.word	0x04c48942
  a4:	77e36f73 	.word	0x77e36f73
  a8:	6a1d36c8 	.word	0x6a1d36c8
  ac:	3f9d85a8 	.word	0x3f9d85a8
  b0:	91d692a1 	.word	0x91d692a1
  b4:	1112e6ad 	.word	0x1112e6ad

Disassembly of section .text.InitSha512_256:

00000000 <InitSha512_256>:
 * Note that sha512/256 has different initial hash value from sha512.
 * The initial hash value consists of eight 64bit words. They are given
 * in FIPS180-4.
 */
static int InitSha512_256(wc_Sha512* sha512)
{
   0:	b530      	push	{r4, r5, lr}
    if (sha512 == NULL)
   2:	2800      	cmp	r0, #0
   4:	d032      	beq.n	6c <InitSha512_256+0x6c>
        return BAD_FUNC_ARG;

    sha512->digest[0] = W64LIT(0x22312194fc2bf72c);
   6:	a31c      	add	r3, pc, #112	; (adr r3, 78 <InitSha512_256+0x78>)
   8:	e9d3 2300 	ldrd	r2, r3, [r3]
   c:	e9c0 2300 	strd	r2, r3, [r0]
    sha512->digest[1] = W64LIT(0x9f555fa3c84c64c2);
  10:	a31b      	add	r3, pc, #108	; (adr r3, 80 <InitSha512_256+0x80>)
  12:	e9d3 2300 	ldrd	r2, r3, [r3]
  16:	e9c0 2302 	strd	r2, r3, [r0, #8]
    sha512->digest[2] = W64LIT(0x2393b86b6f53b151);
  1a:	a31b      	add	r3, pc, #108	; (adr r3, 88 <InitSha512_256+0x88>)
  1c:	e9d3 2300 	ldrd	r2, r3, [r3]
  20:	e9c0 2304 	strd	r2, r3, [r0, #16]
    sha512->digest[3] = W64LIT(0x963877195940eabd);
  24:	a31a      	add	r3, pc, #104	; (adr r3, 90 <InitSha512_256+0x90>)
  26:	e9d3 2300 	ldrd	r2, r3, [r3]
  2a:	e9c0 2306 	strd	r2, r3, [r0, #24]
    sha512->digest[4] = W64LIT(0x96283ee2a88effe3);
  2e:	a31a      	add	r3, pc, #104	; (adr r3, 98 <InitSha512_256+0x98>)
  30:	e9d3 2300 	ldrd	r2, r3, [r3]
  34:	e9c0 2308 	strd	r2, r3, [r0, #32]
    sha512->digest[5] = W64LIT(0xbe5e1e2553863992);
  38:	a319      	add	r3, pc, #100	; (adr r3, a0 <InitSha512_256+0xa0>)
  3a:	e9d3 2300 	ldrd	r2, r3, [r3]
  3e:	e9c0 230a 	strd	r2, r3, [r0, #40]	; 0x28
    sha512->digest[6] = W64LIT(0x2b0199fc2c85b8aa);
  42:	a319      	add	r3, pc, #100	; (adr r3, a8 <InitSha512_256+0xa8>)
  44:	e9d3 2300 	ldrd	r2, r3, [r3]
  48:	e9c0 230c 	strd	r2, r3, [r0, #48]	; 0x30
    sha512->digest[7] = W64LIT(0x0eb72ddc81c52ca2);
  4c:	a318      	add	r3, pc, #96	; (adr r3, b0 <InitSha512_256+0xb0>)
  4e:	e9d3 2300 	ldrd	r2, r3, [r3]

    sha512->buffLen = 0;
    sha512->loLen   = 0;
  52:	2400      	movs	r4, #0
    sha512->digest[7] = W64LIT(0x0eb72ddc81c52ca2);
  54:	e9c0 230e 	strd	r2, r3, [r0, #56]	; 0x38
    sha512->loLen   = 0;
  58:	2500      	movs	r5, #0
    sha512->buffLen = 0;
  5a:	2300      	movs	r3, #0
    sha512->loLen   = 0;
  5c:	e9c0 4532 	strd	r4, r5, [r0, #200]	; 0xc8
    sha512->hiLen   = 0;
  60:	e9c0 4534 	strd	r4, r5, [r0, #208]	; 0xd0
    sha512->buffLen = 0;
  64:	f8c0 30c0 	str.w	r3, [r0, #192]	; 0xc0
#endif

#ifdef WOLFSSL_HASH_FLAGS
    sha512->flags = 0;
#endif
    return 0;
  68:	4618      	mov	r0, r3
}
  6a:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  6c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  70:	e7fb      	b.n	6a <InitSha512_256+0x6a>
  72:	bf00      	nop
  74:	f3af 8000 	nop.w
  78:	fc2bf72c 	.word	0xfc2bf72c
  7c:	22312194 	.word	0x22312194
  80:	c84c64c2 	.word	0xc84c64c2
  84:	9f555fa3 	.word	0x9f555fa3
  88:	6f53b151 	.word	0x6f53b151
  8c:	2393b86b 	.word	0x2393b86b
  90:	5940eabd 	.word	0x5940eabd
  94:	96387719 	.word	0x96387719
  98:	a88effe3 	.word	0xa88effe3
  9c:	96283ee2 	.word	0x96283ee2
  a0:	53863992 	.word	0x53863992
  a4:	be5e1e25 	.word	0xbe5e1e25
  a8:	2c85b8aa 	.word	0x2c85b8aa
  ac:	2b0199fc 	.word	0x2b0199fc
  b0:	81c52ca2 	.word	0x81c52ca2
  b4:	0eb72ddc 	.word	0x0eb72ddc

Disassembly of section .text.ByteReverseWords64:

00000000 <ByteReverseWords64>:
}


WC_MISC_STATIC WC_INLINE void ByteReverseWords64(word64* out, const word64* in,
                                      word32 byteCount)
{
   0:	b510      	push	{r4, lr}
   2:	f022 0207 	bic.w	r2, r2, #7
   6:	3808      	subs	r0, #8
   8:	440a      	add	r2, r1
    word32 count = byteCount/(word32)sizeof(word64), i;

    for (i = 0; i < count; i++)
        out[i] = ByteReverseWord64(in[i]);
   a:	e9d1 3400 	ldrd	r3, r4, [r1]
   e:	ba24      	rev	r4, r4
  10:	f840 4f08 	str.w	r4, [r0, #8]!
  14:	3108      	adds	r1, #8
  16:	ba1b      	rev	r3, r3
    for (i = 0; i < count; i++)
  18:	428a      	cmp	r2, r1
        out[i] = ByteReverseWord64(in[i]);
  1a:	6043      	str	r3, [r0, #4]
    for (i = 0; i < count; i++)
  1c:	d1f5      	bne.n	a <ByteReverseWords64+0xa>

}
  1e:	bd10      	pop	{r4, pc}

Disassembly of section .text.Sha512FinalRaw:

00000000 <Sha512FinalRaw>:
    /* functions defined in wolfcrypt/src/port/Renesas/renesas_fspsm_sha.c */

#else

static int Sha512FinalRaw(wc_Sha512* sha512, byte* hash, size_t digestSz)
{
   0:	b530      	push	{r4, r5, lr}
   2:	460c      	mov	r4, r1
   4:	b091      	sub	sp, #68	; 0x44
   6:	4615      	mov	r5, r2
#ifdef LITTLE_ENDIAN_ORDER
    word64 digest[WC_SHA512_DIGEST_SIZE / sizeof(word64)];
#endif

    if (sha512 == NULL || hash == NULL) {
   8:	4601      	mov	r1, r0
   a:	b160      	cbz	r0, 26 <Sha512FinalRaw+0x26>
   c:	b15c      	cbz	r4, 26 <Sha512FinalRaw+0x26>
        return BAD_FUNC_ARG;
    }

#ifdef LITTLE_ENDIAN_ORDER
    ByteReverseWords64((word64*)digest, (word64*)sha512->digest,
   e:	2240      	movs	r2, #64	; 0x40
  10:	4668      	mov	r0, sp
  12:	f7ff fffe 	bl	0 <Sha512FinalRaw>
                                                         WC_SHA512_DIGEST_SIZE);
    XMEMCPY(hash, digest, digestSz);
  16:	462a      	mov	r2, r5
  18:	4669      	mov	r1, sp
  1a:	4620      	mov	r0, r4
  1c:	f7ff fffe 	bl	0 <memcpy>
#else
    XMEMCPY(hash, sha512->digest, digestSz);
#endif

    return 0;
  20:	2000      	movs	r0, #0
}
  22:	b011      	add	sp, #68	; 0x44
  24:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  26:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2a:	e7fa      	b.n	22 <Sha512FinalRaw+0x22>

Disassembly of section .text._Transform_Sha512:

00000000 <_Transform_Sha512>:
{
       0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
       4:	4605      	mov	r5, r0
       6:	b0c3      	sub	sp, #268	; 0x10c
    W = (word64*) XMALLOC(sizeof(word64) * 16, sha512->heap, DYNAMIC_TYPE_TMP_BUFFER);
       8:	2080      	movs	r0, #128	; 0x80
       a:	f7ff fffe 	bl	0 <malloc>
    if (W == NULL)
       e:	4604      	mov	r4, r0
      10:	2800      	cmp	r0, #0
      12:	f001 87e2 	beq.w	1fda <_Transform_Sha512+0x1fda>
    XMEMCPY(T, sha512->digest, sizeof(T));
      16:	2240      	movs	r2, #64	; 0x40
      18:	4629      	mov	r1, r5
      1a:	a832      	add	r0, sp, #200	; 0xc8
      1c:	f7ff fffe 	bl	0 <memcpy>
    for (j = 0; j < 80; j += 16) {
      20:	9b3a      	ldr	r3, [sp, #232]	; 0xe8
      22:	932f      	str	r3, [sp, #188]	; 0xbc
      24:	9b3e      	ldr	r3, [sp, #248]	; 0xf8
      26:	932b      	str	r3, [sp, #172]	; 0xac
      28:	9b3f      	ldr	r3, [sp, #252]	; 0xfc
      2a:	932c      	str	r3, [sp, #176]	; 0xb0
      2c:	9b3c      	ldr	r3, [sp, #240]	; 0xf0
      2e:	932d      	str	r3, [sp, #180]	; 0xb4
      30:	9b3d      	ldr	r3, [sp, #244]	; 0xf4
      32:	932e      	str	r3, [sp, #184]	; 0xb8
      34:	68a3      	ldr	r3, [r4, #8]
      36:	9319      	str	r3, [sp, #100]	; 0x64
      38:	68e3      	ldr	r3, [r4, #12]
      3a:	9309      	str	r3, [sp, #36]	; 0x24
      3c:	6823      	ldr	r3, [r4, #0]
      3e:	9318      	str	r3, [sp, #96]	; 0x60
      40:	6863      	ldr	r3, [r4, #4]
      42:	9308      	str	r3, [sp, #32]
      44:	9b40      	ldr	r3, [sp, #256]	; 0x100
      46:	9329      	str	r3, [sp, #164]	; 0xa4
      48:	9b41      	ldr	r3, [sp, #260]	; 0x104
      4a:	932a      	str	r3, [sp, #168]	; 0xa8
      4c:	9b38      	ldr	r3, [sp, #224]	; 0xe0
      4e:	9322      	str	r3, [sp, #136]	; 0x88
      50:	9b32      	ldr	r3, [sp, #200]	; 0xc8
      52:	9327      	str	r3, [sp, #156]	; 0x9c
      54:	9b33      	ldr	r3, [sp, #204]	; 0xcc
      56:	9328      	str	r3, [sp, #160]	; 0xa0
      58:	9b34      	ldr	r3, [sp, #208]	; 0xd0
      5a:	f8dd a0ec 	ldr.w	sl, [sp, #236]	; 0xec
      5e:	f8dd b0e4 	ldr.w	fp, [sp, #228]	; 0xe4
      62:	9325      	str	r3, [sp, #148]	; 0x94
      64:	9b35      	ldr	r3, [sp, #212]	; 0xd4
      66:	9326      	str	r3, [sp, #152]	; 0x98
      68:	9b36      	ldr	r3, [sp, #216]	; 0xd8
      6a:	9323      	str	r3, [sp, #140]	; 0x8c
      6c:	9b37      	ldr	r3, [sp, #220]	; 0xdc
      6e:	9324      	str	r3, [sp, #144]	; 0x90
      70:	6923      	ldr	r3, [r4, #16]
      72:	9317      	str	r3, [sp, #92]	; 0x5c
      74:	6963      	ldr	r3, [r4, #20]
      76:	9307      	str	r3, [sp, #28]
      78:	69a3      	ldr	r3, [r4, #24]
      7a:	9312      	str	r3, [sp, #72]	; 0x48
      7c:	69e3      	ldr	r3, [r4, #28]
      7e:	9302      	str	r3, [sp, #8]
      80:	6a23      	ldr	r3, [r4, #32]
      82:	931a      	str	r3, [sp, #104]	; 0x68
      84:	6a63      	ldr	r3, [r4, #36]	; 0x24
      86:	930a      	str	r3, [sp, #40]	; 0x28
      88:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      8a:	9314      	str	r3, [sp, #80]	; 0x50
      8c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
      8e:	9304      	str	r3, [sp, #16]
      90:	6f23      	ldr	r3, [r4, #112]	; 0x70
      92:	9320      	str	r3, [sp, #128]	; 0x80
      94:	6f63      	ldr	r3, [r4, #116]	; 0x74
      96:	9310      	str	r3, [sp, #64]	; 0x40
      98:	6b23      	ldr	r3, [r4, #48]	; 0x30
      9a:	9315      	str	r3, [sp, #84]	; 0x54
      9c:	6b63      	ldr	r3, [r4, #52]	; 0x34
      9e:	9305      	str	r3, [sp, #20]
      a0:	6fa3      	ldr	r3, [r4, #120]	; 0x78
      a2:	9321      	str	r3, [sp, #132]	; 0x84
      a4:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
      a6:	9311      	str	r3, [sp, #68]	; 0x44
      a8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      aa:	9316      	str	r3, [sp, #88]	; 0x58
      ac:	6be3      	ldr	r3, [r4, #60]	; 0x3c
      ae:	9306      	str	r3, [sp, #24]
      b0:	6c23      	ldr	r3, [r4, #64]	; 0x40
      b2:	931b      	str	r3, [sp, #108]	; 0x6c
      b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
      b6:	930b      	str	r3, [sp, #44]	; 0x2c
      b8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
      ba:	931c      	str	r3, [sp, #112]	; 0x70
      bc:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
      be:	930c      	str	r3, [sp, #48]	; 0x30
      c0:	6d23      	ldr	r3, [r4, #80]	; 0x50
      c2:	931d      	str	r3, [sp, #116]	; 0x74
      c4:	6d63      	ldr	r3, [r4, #84]	; 0x54
      c6:	930d      	str	r3, [sp, #52]	; 0x34
      c8:	6da3      	ldr	r3, [r4, #88]	; 0x58
      ca:	931e      	str	r3, [sp, #120]	; 0x78
      cc:	6de3      	ldr	r3, [r4, #92]	; 0x5c
      ce:	930e      	str	r3, [sp, #56]	; 0x38
      d0:	6e23      	ldr	r3, [r4, #96]	; 0x60
      d2:	9313      	str	r3, [sp, #76]	; 0x4c
      d4:	6e63      	ldr	r3, [r4, #100]	; 0x64
      d6:	9303      	str	r3, [sp, #12]
      d8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
      da:	931f      	str	r3, [sp, #124]	; 0x7c
      dc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
      de:	930f      	str	r3, [sp, #60]	; 0x3c
      e0:	2200      	movs	r2, #0
      e2:	4bbf      	ldr	r3, [pc, #764]	; (3e0 <_Transform_Sha512+0x3e0>)
      e4:	9201      	str	r2, [sp, #4]
    return (x >> y) | (x << (sizeof(y) * 8 - y));
      e6:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
      e8:	992f      	ldr	r1, [sp, #188]	; 0xbc
      ea:	ea4f 469a 	mov.w	r6, sl, lsr #18
      ee:	ea4f 379a 	mov.w	r7, sl, lsr #14
      f2:	ea47 4782 	orr.w	r7, r7, r2, lsl #18
      f6:	ea46 3082 	orr.w	r0, r6, r2, lsl #14
      fa:	ea4f 4c92 	mov.w	ip, r2, lsr #18
      fe:	0b89      	lsrs	r1, r1, #14
        R( 0); R( 1); R( 2); R( 3);
     100:	ea87 0600 	eor.w	r6, r7, r0
     104:	ea4c 3c8a 	orr.w	ip, ip, sl, lsl #14
     108:	05d0      	lsls	r0, r2, #23
     10a:	ea41 418a 	orr.w	r1, r1, sl, lsl #18
     10e:	ea81 010c 	eor.w	r1, r1, ip
     112:	ea40 205a 	orr.w	r0, r0, sl, lsr #9
     116:	ea4f 57ca 	mov.w	r7, sl, lsl #23
     11a:	ea47 2752 	orr.w	r7, r7, r2, lsr #9
     11e:	4041      	eors	r1, r0
     120:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     122:	982b      	ldr	r0, [sp, #172]	; 0xac
     124:	ea82 0c00 	eor.w	ip, r2, r0
     128:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     12a:	982c      	ldr	r0, [sp, #176]	; 0xb0
     12c:	4077      	eors	r7, r6
     12e:	ea82 0600 	eor.w	r6, r2, r0
     132:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     134:	ea0c 0c02 	and.w	ip, ip, r2
     138:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     13a:	ea06 060a 	and.w	r6, r6, sl
     13e:	ea8c 0c02 	eor.w	ip, ip, r2
     142:	4070      	eors	r0, r6
     144:	eb11 010c 	adds.w	r1, r1, ip
     148:	681a      	ldr	r2, [r3, #0]
     14a:	9230      	str	r2, [sp, #192]	; 0xc0
     14c:	eb47 0600 	adc.w	r6, r7, r0
     150:	9801      	ldr	r0, [sp, #4]
     152:	685a      	ldr	r2, [r3, #4]
     154:	9231      	str	r2, [sp, #196]	; 0xc4
     156:	2800      	cmp	r0, #0
     158:	f001 86d8 	beq.w	1f0c <_Transform_Sha512+0x1f0c>
     15c:	9a20      	ldr	r2, [sp, #128]	; 0x80
     15e:	ea4f 4ed2 	mov.w	lr, r2, lsr #19
     162:	9a10      	ldr	r2, [sp, #64]	; 0x40
     164:	ea4e 3e42 	orr.w	lr, lr, r2, lsl #13
     168:	4610      	mov	r0, r2
     16a:	0cd7      	lsrs	r7, r2, #19
     16c:	9a20      	ldr	r2, [sp, #128]	; 0x80
     16e:	ea47 3742 	orr.w	r7, r7, r2, lsl #13
     172:	9a20      	ldr	r2, [sp, #128]	; 0x80
     174:	ea4f 0cc0 	mov.w	ip, r0, lsl #3
     178:	ea4c 7c52 	orr.w	ip, ip, r2, lsr #29
     17c:	ea87 0c0c 	eor.w	ip, r7, ip
     180:	9f20      	ldr	r7, [sp, #128]	; 0x80
     182:	00d0      	lsls	r0, r2, #3
     184:	9a10      	ldr	r2, [sp, #64]	; 0x40
     186:	09bf      	lsrs	r7, r7, #6
     188:	ea47 6782 	orr.w	r7, r7, r2, lsl #26
     18c:	ea40 7052 	orr.w	r0, r0, r2, lsr #29
     190:	ea8c 1c92 	eor.w	ip, ip, r2, lsr #6
     194:	9a19      	ldr	r2, [sp, #100]	; 0x64
     196:	ea4f 0952 	mov.w	r9, r2, lsr #1
     19a:	9a09      	ldr	r2, [sp, #36]	; 0x24
     19c:	ea8e 0000 	eor.w	r0, lr, r0
     1a0:	4078      	eors	r0, r7
     1a2:	ea49 79c2 	orr.w	r9, r9, r2, lsl #31
     1a6:	0857      	lsrs	r7, r2, #1
     1a8:	9a19      	ldr	r2, [sp, #100]	; 0x64
     1aa:	ea47 77c2 	orr.w	r7, r7, r2, lsl #31
     1ae:	ea4f 2e12 	mov.w	lr, r2, lsr #8
     1b2:	9a09      	ldr	r2, [sp, #36]	; 0x24
     1b4:	ea4e 6e02 	orr.w	lr, lr, r2, lsl #24
     1b8:	ea4f 2812 	mov.w	r8, r2, lsr #8
     1bc:	9a19      	ldr	r2, [sp, #100]	; 0x64
     1be:	ea89 0e0e 	eor.w	lr, r9, lr
     1c2:	ea48 6802 	orr.w	r8, r8, r2, lsl #24
     1c6:	ea4f 19d2 	mov.w	r9, r2, lsr #7
     1ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
     1cc:	ea87 0708 	eor.w	r7, r7, r8
     1d0:	ea49 6942 	orr.w	r9, r9, r2, lsl #25
     1d4:	ea87 17d2 	eor.w	r7, r7, r2, lsr #7
     1d8:	ea8e 0e09 	eor.w	lr, lr, r9
     1dc:	9a1c      	ldr	r2, [sp, #112]	; 0x70
     1de:	eb10 0e0e 	adds.w	lr, r0, lr
     1e2:	980c      	ldr	r0, [sp, #48]	; 0x30
     1e4:	eb4c 0707 	adc.w	r7, ip, r7
     1e8:	eb1e 0e02 	adds.w	lr, lr, r2
     1ec:	9a18      	ldr	r2, [sp, #96]	; 0x60
     1ee:	eb40 0707 	adc.w	r7, r0, r7
     1f2:	9808      	ldr	r0, [sp, #32]
     1f4:	eb1e 0e02 	adds.w	lr, lr, r2
     1f8:	eb40 0007 	adc.w	r0, r0, r7
     1fc:	f8cd e060 	str.w	lr, [sp, #96]	; 0x60
     200:	9008      	str	r0, [sp, #32]
     202:	9830      	ldr	r0, [sp, #192]	; 0xc0
     204:	f8dd 9098 	ldr.w	r9, [sp, #152]	; 0x98
     208:	1809      	adds	r1, r1, r0
     20a:	9831      	ldr	r0, [sp, #196]	; 0xc4
     20c:	eb46 0600 	adc.w	r6, r6, r0
     210:	9818      	ldr	r0, [sp, #96]	; 0x60
     212:	1809      	adds	r1, r1, r0
     214:	9808      	ldr	r0, [sp, #32]
     216:	eb40 0606 	adc.w	r6, r0, r6
     21a:	9829      	ldr	r0, [sp, #164]	; 0xa4
     21c:	1809      	adds	r1, r1, r0
     21e:	982a      	ldr	r0, [sp, #168]	; 0xa8
     220:	eb40 0606 	adc.w	r6, r0, r6
     224:	9822      	ldr	r0, [sp, #136]	; 0x88
     226:	1808      	adds	r0, r1, r0
     228:	eb46 020b 	adc.w	r2, r6, fp
     22c:	9230      	str	r2, [sp, #192]	; 0xc0
     22e:	9a27      	ldr	r2, [sp, #156]	; 0x9c
     230:	902a      	str	r0, [sp, #168]	; 0xa8
     232:	ea4f 7e12 	mov.w	lr, r2, lsr #28
     236:	9a28      	ldr	r2, [sp, #160]	; 0xa0
     238:	9828      	ldr	r0, [sp, #160]	; 0xa0
     23a:	ea4e 1e02 	orr.w	lr, lr, r2, lsl #4
     23e:	ea4f 7c12 	mov.w	ip, r2, lsr #28
     242:	9a27      	ldr	r2, [sp, #156]	; 0x9c
     244:	0780      	lsls	r0, r0, #30
     246:	ea40 0092 	orr.w	r0, r0, r2, lsr #2
     24a:	ea4c 1c02 	orr.w	ip, ip, r2, lsl #4
     24e:	0797      	lsls	r7, r2, #30
     250:	9a28      	ldr	r2, [sp, #160]	; 0xa0
     252:	ea8c 0c00 	eor.w	ip, ip, r0
     256:	ea47 0792 	orr.w	r7, r7, r2, lsr #2
     25a:	0650      	lsls	r0, r2, #25
     25c:	9a27      	ldr	r2, [sp, #156]	; 0x9c
     25e:	ea8e 0e07 	eor.w	lr, lr, r7
     262:	ea40 10d2 	orr.w	r0, r0, r2, lsr #7
     266:	0657      	lsls	r7, r2, #25
     268:	9a28      	ldr	r2, [sp, #160]	; 0xa0
     26a:	ea8c 0c00 	eor.w	ip, ip, r0
     26e:	ea47 17d2 	orr.w	r7, r7, r2, lsr #7
     272:	9827      	ldr	r0, [sp, #156]	; 0x9c
     274:	9a25      	ldr	r2, [sp, #148]	; 0x94
     276:	ea40 0802 	orr.w	r8, r0, r2
     27a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
     27c:	9826      	ldr	r0, [sp, #152]	; 0x98
     27e:	ea8e 0e07 	eor.w	lr, lr, r7
     282:	4310      	orrs	r0, r2
     284:	9f24      	ldr	r7, [sp, #144]	; 0x90
     286:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     288:	4038      	ands	r0, r7
     28a:	ea08 0802 	and.w	r8, r8, r2
     28e:	9f27      	ldr	r7, [sp, #156]	; 0x9c
     290:	9a25      	ldr	r2, [sp, #148]	; 0x94
     292:	4017      	ands	r7, r2
     294:	9a28      	ldr	r2, [sp, #160]	; 0xa0
     296:	ea48 0707 	orr.w	r7, r8, r7
     29a:	ea02 0909 	and.w	r9, r2, r9
     29e:	eb1e 0707 	adds.w	r7, lr, r7
     2a2:	ea40 0909 	orr.w	r9, r0, r9
     2a6:	eb4c 0909 	adc.w	r9, ip, r9
     2aa:	1879      	adds	r1, r7, r1
     2ac:	eb46 0209 	adc.w	r2, r6, r9
     2b0:	9229      	str	r2, [sp, #164]	; 0xa4
     2b2:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
     2b4:	9122      	str	r1, [sp, #136]	; 0x88
     2b6:	ea4f 3c92 	mov.w	ip, r2, lsr #14
     2ba:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     2bc:	ea4c 4c82 	orr.w	ip, ip, r2, lsl #18
     2c0:	0b96      	lsrs	r6, r2, #14
     2c2:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
     2c4:	ea46 4682 	orr.w	r6, r6, r2, lsl #18
     2c8:	0c90      	lsrs	r0, r2, #18
     2ca:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     2cc:	ea40 3082 	orr.w	r0, r0, r2, lsl #14
     2d0:	0c91      	lsrs	r1, r2, #18
     2d2:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
     2d4:	f8d3 e00c 	ldr.w	lr, [r3, #12]
     2d8:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     2dc:	404e      	eors	r6, r1
     2de:	9930      	ldr	r1, [sp, #192]	; 0xc0
     2e0:	05c9      	lsls	r1, r1, #23
     2e2:	ea41 2152 	orr.w	r1, r1, r2, lsr #9
     2e6:	ea8c 0c00 	eor.w	ip, ip, r0
     2ea:	05d0      	lsls	r0, r2, #23
     2ec:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     2ee:	404e      	eors	r6, r1
     2f0:	ea40 2052 	orr.w	r0, r0, r2, lsr #9
     2f4:	992f      	ldr	r1, [sp, #188]	; 0xbc
     2f6:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     2f8:	ea8c 0c00 	eor.w	ip, ip, r0
     2fc:	982a      	ldr	r0, [sp, #168]	; 0xa8
     2fe:	4051      	eors	r1, r2
     300:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     302:	4001      	ands	r1, r0
     304:	9830      	ldr	r0, [sp, #192]	; 0xc0
     306:	ea82 070a 	eor.w	r7, r2, sl
     30a:	4007      	ands	r7, r0
     30c:	982d      	ldr	r0, [sp, #180]	; 0xb4
     30e:	4057      	eors	r7, r2
     310:	4041      	eors	r1, r0
     312:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     314:	6898      	ldr	r0, [r3, #8]
     316:	1810      	adds	r0, r2, r0
     318:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     31a:	eb42 080e 	adc.w	r8, r2, lr
     31e:	180a      	adds	r2, r1, r0
     320:	922b      	str	r2, [sp, #172]	; 0xac
     322:	9a01      	ldr	r2, [sp, #4]
     324:	eb47 0708 	adc.w	r7, r7, r8
     328:	2a00      	cmp	r2, #0
     32a:	f001 85f5 	beq.w	1f18 <_Transform_Sha512+0x1f18>
     32e:	9a21      	ldr	r2, [sp, #132]	; 0x84
     330:	9917      	ldr	r1, [sp, #92]	; 0x5c
     332:	ea4f 49d2 	mov.w	r9, r2, lsr #19
     336:	9a11      	ldr	r2, [sp, #68]	; 0x44
     338:	ea49 3942 	orr.w	r9, r9, r2, lsl #13
     33c:	ea4f 48d2 	mov.w	r8, r2, lsr #19
     340:	9a21      	ldr	r2, [sp, #132]	; 0x84
     342:	ea48 3842 	orr.w	r8, r8, r2, lsl #13
     346:	9a11      	ldr	r2, [sp, #68]	; 0x44
     348:	ea4f 0ec2 	mov.w	lr, r2, lsl #3
     34c:	9a21      	ldr	r2, [sp, #132]	; 0x84
     34e:	ea4e 7e52 	orr.w	lr, lr, r2, lsr #29
     352:	00d0      	lsls	r0, r2, #3
     354:	9a11      	ldr	r2, [sp, #68]	; 0x44
     356:	ea40 7052 	orr.w	r0, r0, r2, lsr #29
     35a:	9a21      	ldr	r2, [sp, #132]	; 0x84
     35c:	ea88 0e0e 	eor.w	lr, r8, lr
     360:	ea4f 1892 	mov.w	r8, r2, lsr #6
     364:	9a11      	ldr	r2, [sp, #68]	; 0x44
     366:	ea89 0000 	eor.w	r0, r9, r0
     36a:	ea48 6882 	orr.w	r8, r8, r2, lsl #26
     36e:	ea80 0008 	eor.w	r0, r0, r8
     372:	ea8e 1e92 	eor.w	lr, lr, r2, lsr #6
     376:	f8dd 8074 	ldr.w	r8, [sp, #116]	; 0x74
     37a:	9a19      	ldr	r2, [sp, #100]	; 0x64
     37c:	eb12 0b08 	adds.w	fp, r2, r8
     380:	9a09      	ldr	r2, [sp, #36]	; 0x24
     382:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
     386:	eb42 0808 	adc.w	r8, r2, r8
     38a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
     38c:	eb10 000b 	adds.w	r0, r0, fp
     390:	ea4f 0b52 	mov.w	fp, r2, lsr #1
     394:	9a07      	ldr	r2, [sp, #28]
     396:	eb4e 0e08 	adc.w	lr, lr, r8
     39a:	ea4b 7bc2 	orr.w	fp, fp, r2, lsl #31
     39e:	ea4f 0852 	mov.w	r8, r2, lsr #1
     3a2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
     3a4:	ea48 78c2 	orr.w	r8, r8, r2, lsl #31
     3a8:	ea4f 2912 	mov.w	r9, r2, lsr #8
     3ac:	9a07      	ldr	r2, [sp, #28]
     3ae:	ea49 6902 	orr.w	r9, r9, r2, lsl #24
     3b2:	0a12      	lsrs	r2, r2, #8
     3b4:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
     3b8:	ea88 0802 	eor.w	r8, r8, r2
     3bc:	9a07      	ldr	r2, [sp, #28]
     3be:	ea8b 0909 	eor.w	r9, fp, r9
     3c2:	ea4f 1bd1 	mov.w	fp, r1, lsr #7
     3c6:	ea4b 6b42 	orr.w	fp, fp, r2, lsl #25
     3ca:	ea89 090b 	eor.w	r9, r9, fp
     3ce:	ea88 18d2 	eor.w	r8, r8, r2, lsr #7
     3d2:	eb10 0209 	adds.w	r2, r0, r9
     3d6:	9219      	str	r2, [sp, #100]	; 0x64
     3d8:	eb4e 0208 	adc.w	r2, lr, r8
     3dc:	e002      	b.n	3e4 <_Transform_Sha512+0x3e4>
     3de:	bf00      	nop
     3e0:	00000000 	.word	0x00000000
     3e4:	9209      	str	r2, [sp, #36]	; 0x24
     3e6:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     3e8:	eb1c 0102 	adds.w	r1, ip, r2
     3ec:	9a19      	ldr	r2, [sp, #100]	; 0x64
     3ee:	eb46 0607 	adc.w	r6, r6, r7
     3f2:	1889      	adds	r1, r1, r2
     3f4:	9a09      	ldr	r2, [sp, #36]	; 0x24
     3f6:	eb42 0606 	adc.w	r6, r2, r6
     3fa:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     3fc:	188a      	adds	r2, r1, r2
     3fe:	922b      	str	r2, [sp, #172]	; 0xac
     400:	9a24      	ldr	r2, [sp, #144]	; 0x90
     402:	eb46 0202 	adc.w	r2, r6, r2
     406:	922c      	str	r2, [sp, #176]	; 0xb0
     408:	9a22      	ldr	r2, [sp, #136]	; 0x88
     40a:	ea4f 7c12 	mov.w	ip, r2, lsr #28
     40e:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     410:	ea4c 1c02 	orr.w	ip, ip, r2, lsl #4
     414:	ea4f 7e12 	mov.w	lr, r2, lsr #28
     418:	9a22      	ldr	r2, [sp, #136]	; 0x88
     41a:	ea4e 1e02 	orr.w	lr, lr, r2, lsl #4
     41e:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     420:	0790      	lsls	r0, r2, #30
     422:	9a22      	ldr	r2, [sp, #136]	; 0x88
     424:	ea40 0092 	orr.w	r0, r0, r2, lsr #2
     428:	0797      	lsls	r7, r2, #30
     42a:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     42c:	ea8e 0e00 	eor.w	lr, lr, r0
     430:	ea47 0792 	orr.w	r7, r7, r2, lsr #2
     434:	0650      	lsls	r0, r2, #25
     436:	9a22      	ldr	r2, [sp, #136]	; 0x88
     438:	ea8c 0c07 	eor.w	ip, ip, r7
     43c:	ea40 10d2 	orr.w	r0, r0, r2, lsr #7
     440:	0657      	lsls	r7, r2, #25
     442:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     444:	ea8e 0e00 	eor.w	lr, lr, r0
     448:	ea47 17d2 	orr.w	r7, r7, r2, lsr #7
     44c:	9827      	ldr	r0, [sp, #156]	; 0x9c
     44e:	9a22      	ldr	r2, [sp, #136]	; 0x88
     450:	ea8c 0c07 	eor.w	ip, ip, r7
     454:	ea42 0700 	orr.w	r7, r2, r0
     458:	e9dd 0228 	ldrd	r0, r2, [sp, #160]	; 0xa0
     45c:	ea42 0800 	orr.w	r8, r2, r0
     460:	9a25      	ldr	r2, [sp, #148]	; 0x94
     462:	9827      	ldr	r0, [sp, #156]	; 0x9c
     464:	4017      	ands	r7, r2
     466:	9a26      	ldr	r2, [sp, #152]	; 0x98
     468:	ea08 0802 	and.w	r8, r8, r2
     46c:	9a22      	ldr	r2, [sp, #136]	; 0x88
     46e:	4010      	ands	r0, r2
     470:	e9dd 9228 	ldrd	r9, r2, [sp, #160]	; 0xa0
     474:	4307      	orrs	r7, r0
     476:	ea02 0909 	and.w	r9, r2, r9
     47a:	eb1c 0707 	adds.w	r7, ip, r7
     47e:	ea48 0909 	orr.w	r9, r8, r9
     482:	eb4e 0909 	adc.w	r9, lr, r9
     486:	187a      	adds	r2, r7, r1
     488:	9223      	str	r2, [sp, #140]	; 0x8c
     48a:	eb46 0209 	adc.w	r2, r6, r9
     48e:	9224      	str	r2, [sp, #144]	; 0x90
     490:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     492:	ea4f 3c92 	mov.w	ip, r2, lsr #14
     496:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     498:	ea4c 4c82 	orr.w	ip, ip, r2, lsl #18
     49c:	0b96      	lsrs	r6, r2, #14
     49e:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     4a0:	ea46 4682 	orr.w	r6, r6, r2, lsl #18
     4a4:	0c90      	lsrs	r0, r2, #18
     4a6:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     4a8:	ea40 3082 	orr.w	r0, r0, r2, lsl #14
     4ac:	0c91      	lsrs	r1, r2, #18
     4ae:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     4b0:	f8d3 e014 	ldr.w	lr, [r3, #20]
     4b4:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     4b8:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     4ba:	404e      	eors	r6, r1
     4bc:	05d1      	lsls	r1, r2, #23
     4be:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     4c0:	ea8c 0c00 	eor.w	ip, ip, r0
     4c4:	ea41 2152 	orr.w	r1, r1, r2, lsr #9
     4c8:	05d0      	lsls	r0, r2, #23
     4ca:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     4cc:	404e      	eors	r6, r1
     4ce:	ea40 2052 	orr.w	r0, r0, r2, lsr #9
     4d2:	992f      	ldr	r1, [sp, #188]	; 0xbc
     4d4:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
     4d6:	4051      	eors	r1, r2
     4d8:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     4da:	ea82 070a 	eor.w	r7, r2, sl
     4de:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     4e0:	4011      	ands	r1, r2
     4e2:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     4e4:	4017      	ands	r7, r2
     4e6:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     4e8:	ea8c 0c00 	eor.w	ip, ip, r0
     4ec:	4051      	eors	r1, r2
     4ee:	6918      	ldr	r0, [r3, #16]
     4f0:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     4f2:	1810      	adds	r0, r2, r0
     4f4:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     4f6:	eb42 0e0e 	adc.w	lr, r2, lr
     4fa:	9a01      	ldr	r2, [sp, #4]
     4fc:	ea87 070a 	eor.w	r7, r7, sl
     500:	1809      	adds	r1, r1, r0
     502:	eb47 070e 	adc.w	r7, r7, lr
     506:	2a00      	cmp	r2, #0
     508:	f001 850b 	beq.w	1f22 <_Transform_Sha512+0x1f22>
     50c:	9a12      	ldr	r2, [sp, #72]	; 0x48
     50e:	ea4f 0952 	mov.w	r9, r2, lsr #1
     512:	9a02      	ldr	r2, [sp, #8]
     514:	ea49 79c2 	orr.w	r9, r9, r2, lsl #31
     518:	ea4f 0852 	mov.w	r8, r2, lsr #1
     51c:	9a12      	ldr	r2, [sp, #72]	; 0x48
     51e:	ea48 78c2 	orr.w	r8, r8, r2, lsl #31
     522:	0a10      	lsrs	r0, r2, #8
     524:	9a02      	ldr	r2, [sp, #8]
     526:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
     52a:	ea4f 2e12 	mov.w	lr, r2, lsr #8
     52e:	9a12      	ldr	r2, [sp, #72]	; 0x48
     530:	ea4e 6e02 	orr.w	lr, lr, r2, lsl #24
     534:	ea88 0e0e 	eor.w	lr, r8, lr
     538:	ea4f 18d2 	mov.w	r8, r2, lsr #7
     53c:	9a02      	ldr	r2, [sp, #8]
     53e:	ea89 0000 	eor.w	r0, r9, r0
     542:	ea48 6842 	orr.w	r8, r8, r2, lsl #25
     546:	ea80 0008 	eor.w	r0, r0, r8
     54a:	ea8e 1ed2 	eor.w	lr, lr, r2, lsr #7
     54e:	f8dd 8078 	ldr.w	r8, [sp, #120]	; 0x78
     552:	9a17      	ldr	r2, [sp, #92]	; 0x5c
     554:	eb12 0b08 	adds.w	fp, r2, r8
     558:	9a07      	ldr	r2, [sp, #28]
     55a:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
     55e:	eb42 0808 	adc.w	r8, r2, r8
     562:	9a18      	ldr	r2, [sp, #96]	; 0x60
     564:	eb10 000b 	adds.w	r0, r0, fp
     568:	ea4f 4bd2 	mov.w	fp, r2, lsr #19
     56c:	9a08      	ldr	r2, [sp, #32]
     56e:	eb4e 0e08 	adc.w	lr, lr, r8
     572:	ea4b 3b42 	orr.w	fp, fp, r2, lsl #13
     576:	ea4f 48d2 	mov.w	r8, r2, lsr #19
     57a:	9a18      	ldr	r2, [sp, #96]	; 0x60
     57c:	ea48 3842 	orr.w	r8, r8, r2, lsl #13
     580:	9a08      	ldr	r2, [sp, #32]
     582:	ea4f 09c2 	mov.w	r9, r2, lsl #3
     586:	9a18      	ldr	r2, [sp, #96]	; 0x60
     588:	ea49 7252 	orr.w	r2, r9, r2, lsr #29
     58c:	9207      	str	r2, [sp, #28]
     58e:	9a18      	ldr	r2, [sp, #96]	; 0x60
     590:	ea4f 09c2 	mov.w	r9, r2, lsl #3
     594:	9a08      	ldr	r2, [sp, #32]
     596:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
     59a:	9a07      	ldr	r2, [sp, #28]
     59c:	ea88 0802 	eor.w	r8, r8, r2
     5a0:	9a18      	ldr	r2, [sp, #96]	; 0x60
     5a2:	ea8b 0909 	eor.w	r9, fp, r9
     5a6:	ea4f 1b92 	mov.w	fp, r2, lsr #6
     5aa:	9a08      	ldr	r2, [sp, #32]
     5ac:	ea4b 6b82 	orr.w	fp, fp, r2, lsl #26
     5b0:	ea89 090b 	eor.w	r9, r9, fp
     5b4:	ea88 1892 	eor.w	r8, r8, r2, lsr #6
     5b8:	eb10 0209 	adds.w	r2, r0, r9
     5bc:	9217      	str	r2, [sp, #92]	; 0x5c
     5be:	eb4e 0208 	adc.w	r2, lr, r8
     5c2:	9207      	str	r2, [sp, #28]
     5c4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
     5c6:	f8dd 9090 	ldr.w	r9, [sp, #144]	; 0x90
     5ca:	eb1c 0101 	adds.w	r1, ip, r1
     5ce:	eb46 0607 	adc.w	r6, r6, r7
     5d2:	1889      	adds	r1, r1, r2
     5d4:	9a07      	ldr	r2, [sp, #28]
     5d6:	eb42 0606 	adc.w	r6, r2, r6
     5da:	9a25      	ldr	r2, [sp, #148]	; 0x94
     5dc:	188a      	adds	r2, r1, r2
     5de:	922d      	str	r2, [sp, #180]	; 0xb4
     5e0:	9a26      	ldr	r2, [sp, #152]	; 0x98
     5e2:	eb46 0202 	adc.w	r2, r6, r2
     5e6:	922e      	str	r2, [sp, #184]	; 0xb8
     5e8:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     5ea:	ea4f 7c12 	mov.w	ip, r2, lsr #28
     5ee:	9a24      	ldr	r2, [sp, #144]	; 0x90
     5f0:	ea4c 1c02 	orr.w	ip, ip, r2, lsl #4
     5f4:	ea4f 7e12 	mov.w	lr, r2, lsr #28
     5f8:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     5fa:	ea4e 1e02 	orr.w	lr, lr, r2, lsl #4
     5fe:	9a24      	ldr	r2, [sp, #144]	; 0x90
     600:	0790      	lsls	r0, r2, #30
     602:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     604:	ea40 0092 	orr.w	r0, r0, r2, lsr #2
     608:	0797      	lsls	r7, r2, #30
     60a:	9a24      	ldr	r2, [sp, #144]	; 0x90
     60c:	ea8e 0e00 	eor.w	lr, lr, r0
     610:	ea47 0792 	orr.w	r7, r7, r2, lsr #2
     614:	0650      	lsls	r0, r2, #25
     616:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     618:	ea8c 0c07 	eor.w	ip, ip, r7
     61c:	ea40 10d2 	orr.w	r0, r0, r2, lsr #7
     620:	0657      	lsls	r7, r2, #25
     622:	9a24      	ldr	r2, [sp, #144]	; 0x90
     624:	ea8e 0e00 	eor.w	lr, lr, r0
     628:	ea47 17d2 	orr.w	r7, r7, r2, lsr #7
     62c:	e9dd 2022 	ldrd	r2, r0, [sp, #136]	; 0x88
     630:	ea8c 0c07 	eor.w	ip, ip, r7
     634:	ea42 0700 	orr.w	r7, r2, r0
     638:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     63a:	9824      	ldr	r0, [sp, #144]	; 0x90
     63c:	ea42 0800 	orr.w	r8, r2, r0
     640:	9a27      	ldr	r2, [sp, #156]	; 0x9c
     642:	4017      	ands	r7, r2
     644:	9a28      	ldr	r2, [sp, #160]	; 0xa0
     646:	ea08 0802 	and.w	r8, r8, r2
     64a:	e9dd 2022 	ldrd	r2, r0, [sp, #136]	; 0x88
     64e:	4010      	ands	r0, r2
     650:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     652:	4338      	orrs	r0, r7
     654:	ea02 0909 	and.w	r9, r2, r9
     658:	eb1c 0000 	adds.w	r0, ip, r0
     65c:	ea48 0909 	orr.w	r9, r8, r9
     660:	eb4e 0909 	adc.w	r9, lr, r9
     664:	1842      	adds	r2, r0, r1
     666:	9225      	str	r2, [sp, #148]	; 0x94
     668:	eb46 0209 	adc.w	r2, r6, r9
     66c:	9226      	str	r2, [sp, #152]	; 0x98
     66e:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     670:	ea4f 3c92 	mov.w	ip, r2, lsr #14
     674:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     676:	ea4c 4c82 	orr.w	ip, ip, r2, lsl #18
     67a:	0b96      	lsrs	r6, r2, #14
     67c:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     67e:	ea46 4682 	orr.w	r6, r6, r2, lsl #18
     682:	0c90      	lsrs	r0, r2, #18
     684:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     686:	ea40 3082 	orr.w	r0, r0, r2, lsl #14
     68a:	0c91      	lsrs	r1, r2, #18
     68c:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     68e:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     692:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     694:	404e      	eors	r6, r1
     696:	05d1      	lsls	r1, r2, #23
     698:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     69a:	ea8c 0c00 	eor.w	ip, ip, r0
     69e:	ea41 2152 	orr.w	r1, r1, r2, lsr #9
     6a2:	05d0      	lsls	r0, r2, #23
     6a4:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     6a6:	404e      	eors	r6, r1
     6a8:	ea40 2052 	orr.w	r0, r0, r2, lsr #9
     6ac:	e9dd 212a 	ldrd	r2, r1, [sp, #168]	; 0xa8
     6b0:	ea8c 0c00 	eor.w	ip, ip, r0
     6b4:	4051      	eors	r1, r2
     6b6:	982c      	ldr	r0, [sp, #176]	; 0xb0
     6b8:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     6ba:	ea82 0700 	eor.w	r7, r2, r0
     6be:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     6c0:	6998      	ldr	r0, [r3, #24]
     6c2:	4011      	ands	r1, r2
     6c4:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     6c6:	4017      	ands	r7, r2
     6c8:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
     6ca:	4051      	eors	r1, r2
     6cc:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     6ce:	4057      	eors	r7, r2
     6d0:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     6d2:	1810      	adds	r0, r2, r0
     6d4:	69da      	ldr	r2, [r3, #28]
     6d6:	eb4a 0e02 	adc.w	lr, sl, r2
     6da:	9a01      	ldr	r2, [sp, #4]
     6dc:	1809      	adds	r1, r1, r0
     6de:	eb47 070e 	adc.w	r7, r7, lr
     6e2:	2a00      	cmp	r2, #0
     6e4:	f001 8422 	beq.w	1f2c <_Transform_Sha512+0x1f2c>
     6e8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
     6ea:	ea4f 0952 	mov.w	r9, r2, lsr #1
     6ee:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     6f0:	ea49 79c2 	orr.w	r9, r9, r2, lsl #31
     6f4:	ea4f 0852 	mov.w	r8, r2, lsr #1
     6f8:	9a1a      	ldr	r2, [sp, #104]	; 0x68
     6fa:	ea48 78c2 	orr.w	r8, r8, r2, lsl #31
     6fe:	0a10      	lsrs	r0, r2, #8
     700:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     702:	ea40 6002 	orr.w	r0, r0, r2, lsl #24
     706:	ea4f 2e12 	mov.w	lr, r2, lsr #8
     70a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
     70c:	ea4e 6e02 	orr.w	lr, lr, r2, lsl #24
     710:	ea88 0e0e 	eor.w	lr, r8, lr
     714:	ea4f 18d2 	mov.w	r8, r2, lsr #7
     718:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     71a:	ea89 0000 	eor.w	r0, r9, r0
     71e:	ea48 6842 	orr.w	r8, r8, r2, lsl #25
     722:	ea80 0008 	eor.w	r0, r0, r8
     726:	ea8e 1ed2 	eor.w	lr, lr, r2, lsr #7
     72a:	e9dd 2812 	ldrd	r2, r8, [sp, #72]	; 0x48
     72e:	eb12 0b08 	adds.w	fp, r2, r8
     732:	e9dd 2802 	ldrd	r2, r8, [sp, #8]
     736:	eb42 0808 	adc.w	r8, r2, r8
     73a:	9a19      	ldr	r2, [sp, #100]	; 0x64
     73c:	eb10 000b 	adds.w	r0, r0, fp
     740:	ea4f 4bd2 	mov.w	fp, r2, lsr #19
     744:	9a09      	ldr	r2, [sp, #36]	; 0x24
     746:	eb4e 0e08 	adc.w	lr, lr, r8
     74a:	ea4b 3b42 	orr.w	fp, fp, r2, lsl #13
     74e:	ea4f 48d2 	mov.w	r8, r2, lsr #19
     752:	9a19      	ldr	r2, [sp, #100]	; 0x64
     754:	ea48 3842 	orr.w	r8, r8, r2, lsl #13
     758:	9a09      	ldr	r2, [sp, #36]	; 0x24
     75a:	ea4f 0ac2 	mov.w	sl, r2, lsl #3
     75e:	9a19      	ldr	r2, [sp, #100]	; 0x64
     760:	ea4a 7a52 	orr.w	sl, sl, r2, lsr #29
     764:	ea4f 09c2 	mov.w	r9, r2, lsl #3
     768:	9a09      	ldr	r2, [sp, #36]	; 0x24
     76a:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
     76e:	9a19      	ldr	r2, [sp, #100]	; 0x64
     770:	ea8b 0909 	eor.w	r9, fp, r9
     774:	ea4f 1b92 	mov.w	fp, r2, lsr #6
     778:	9a09      	ldr	r2, [sp, #36]	; 0x24
     77a:	ea4b 6b82 	orr.w	fp, fp, r2, lsl #26
     77e:	ea88 080a 	eor.w	r8, r8, sl
     782:	ea89 090b 	eor.w	r9, r9, fp
     786:	ea88 1892 	eor.w	r8, r8, r2, lsr #6
     78a:	eb10 0209 	adds.w	r2, r0, r9
     78e:	9212      	str	r2, [sp, #72]	; 0x48
     790:	eb4e 0208 	adc.w	r2, lr, r8
     794:	9202      	str	r2, [sp, #8]
     796:	9a12      	ldr	r2, [sp, #72]	; 0x48
     798:	f8dd e098 	ldr.w	lr, [sp, #152]	; 0x98
     79c:	f8dd 8094 	ldr.w	r8, [sp, #148]	; 0x94
     7a0:	f8dd 9098 	ldr.w	r9, [sp, #152]	; 0x98
     7a4:	eb1c 0101 	adds.w	r1, ip, r1
     7a8:	eb46 0607 	adc.w	r6, r6, r7
     7ac:	1889      	adds	r1, r1, r2
     7ae:	9a02      	ldr	r2, [sp, #8]
     7b0:	9f25      	ldr	r7, [sp, #148]	; 0x94
     7b2:	eb42 0606 	adc.w	r6, r2, r6
     7b6:	9a27      	ldr	r2, [sp, #156]	; 0x9c
     7b8:	188a      	adds	r2, r1, r2
     7ba:	922f      	str	r2, [sp, #188]	; 0xbc
     7bc:	9a28      	ldr	r2, [sp, #160]	; 0xa0
     7be:	eb46 0202 	adc.w	r2, r6, r2
     7c2:	9231      	str	r2, [sp, #196]	; 0xc4
     7c4:	9a25      	ldr	r2, [sp, #148]	; 0x94
     7c6:	ea4f 7c12 	mov.w	ip, r2, lsr #28
     7ca:	9a26      	ldr	r2, [sp, #152]	; 0x98
     7cc:	ea4c 1c02 	orr.w	ip, ip, r2, lsl #4
     7d0:	0f10      	lsrs	r0, r2, #28
     7d2:	9a25      	ldr	r2, [sp, #148]	; 0x94
     7d4:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
     7d8:	9a26      	ldr	r2, [sp, #152]	; 0x98
     7da:	0792      	lsls	r2, r2, #30
     7dc:	ea42 0297 	orr.w	r2, r2, r7, lsr #2
     7e0:	07bf      	lsls	r7, r7, #30
     7e2:	ea47 079e 	orr.w	r7, r7, lr, lsr #2
     7e6:	ea8c 0c07 	eor.w	ip, ip, r7
     7ea:	4050      	eors	r0, r2
     7ec:	9f25      	ldr	r7, [sp, #148]	; 0x94
     7ee:	4672      	mov	r2, lr
     7f0:	0652      	lsls	r2, r2, #25
     7f2:	ea42 12d7 	orr.w	r2, r2, r7, lsr #7
     7f6:	067f      	lsls	r7, r7, #25
     7f8:	ea47 17de 	orr.w	r7, r7, lr, lsr #7
     7fc:	ea8c 0c07 	eor.w	ip, ip, r7
     800:	4050      	eors	r0, r2
     802:	9f25      	ldr	r7, [sp, #148]	; 0x94
     804:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     806:	4317      	orrs	r7, r2
     808:	9a24      	ldr	r2, [sp, #144]	; 0x90
     80a:	ea42 0e0e 	orr.w	lr, r2, lr
     80e:	9a22      	ldr	r2, [sp, #136]	; 0x88
     810:	4017      	ands	r7, r2
     812:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     814:	ea0e 0e02 	and.w	lr, lr, r2
     818:	9a23      	ldr	r2, [sp, #140]	; 0x8c
     81a:	ea02 0208 	and.w	r2, r2, r8
     81e:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
     822:	433a      	orrs	r2, r7
     824:	ea08 0809 	and.w	r8, r8, r9
     828:	eb1c 0202 	adds.w	r2, ip, r2
     82c:	ea4e 0808 	orr.w	r8, lr, r8
     830:	eb40 0808 	adc.w	r8, r0, r8
     834:	eb12 0b01 	adds.w	fp, r2, r1
     838:	eb46 0208 	adc.w	r2, r6, r8
     83c:	9227      	str	r2, [sp, #156]	; 0x9c
     83e:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     840:	9e2f      	ldr	r6, [sp, #188]	; 0xbc
     842:	0b97      	lsrs	r7, r2, #14
     844:	9a31      	ldr	r2, [sp, #196]	; 0xc4
     846:	ea47 4782 	orr.w	r7, r7, r2, lsl #18
     84a:	0b90      	lsrs	r0, r2, #14
     84c:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     84e:	ea40 4082 	orr.w	r0, r0, r2, lsl #18
     852:	0c91      	lsrs	r1, r2, #18
     854:	9a31      	ldr	r2, [sp, #196]	; 0xc4
     856:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     85a:	0c92      	lsrs	r2, r2, #18
     85c:	ea42 3286 	orr.w	r2, r2, r6, lsl #14
        R( 4); R( 5); R( 6); R( 7);
     860:	4050      	eors	r0, r2
     862:	9a31      	ldr	r2, [sp, #196]	; 0xc4
     864:	05d2      	lsls	r2, r2, #23
     866:	404f      	eors	r7, r1
     868:	ea42 2256 	orr.w	r2, r2, r6, lsr #9
     86c:	05f1      	lsls	r1, r6, #23
     86e:	9e31      	ldr	r6, [sp, #196]	; 0xc4
     870:	4042      	eors	r2, r0
     872:	ea41 2156 	orr.w	r1, r1, r6, lsr #9
     876:	404f      	eors	r7, r1
     878:	9228      	str	r2, [sp, #160]	; 0xa0
     87a:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     87c:	992d      	ldr	r1, [sp, #180]	; 0xb4
     87e:	982e      	ldr	r0, [sp, #184]	; 0xb8
     880:	f8d3 c024 	ldr.w	ip, [r3, #36]	; 0x24
     884:	404a      	eors	r2, r1
     886:	992c      	ldr	r1, [sp, #176]	; 0xb0
     888:	ea81 0600 	eor.w	r6, r1, r0
     88c:	992f      	ldr	r1, [sp, #188]	; 0xbc
     88e:	982a      	ldr	r0, [sp, #168]	; 0xa8
     890:	400a      	ands	r2, r1
     892:	9931      	ldr	r1, [sp, #196]	; 0xc4
     894:	400e      	ands	r6, r1
     896:	992b      	ldr	r1, [sp, #172]	; 0xac
     898:	404a      	eors	r2, r1
     89a:	992c      	ldr	r1, [sp, #176]	; 0xb0
     89c:	404e      	eors	r6, r1
     89e:	6a19      	ldr	r1, [r3, #32]
     8a0:	1841      	adds	r1, r0, r1
     8a2:	9830      	ldr	r0, [sp, #192]	; 0xc0
     8a4:	eb40 0c0c 	adc.w	ip, r0, ip
     8a8:	1852      	adds	r2, r2, r1
     8aa:	9901      	ldr	r1, [sp, #4]
     8ac:	eb46 060c 	adc.w	r6, r6, ip
     8b0:	2900      	cmp	r1, #0
     8b2:	f001 8340 	beq.w	1f36 <_Transform_Sha512+0x1f36>
     8b6:	9914      	ldr	r1, [sp, #80]	; 0x50
     8b8:	9804      	ldr	r0, [sp, #16]
     8ba:	ea4f 0851 	mov.w	r8, r1, lsr #1
     8be:	9904      	ldr	r1, [sp, #16]
     8c0:	ea48 78c1 	orr.w	r8, r8, r1, lsl #31
     8c4:	ea4f 0e51 	mov.w	lr, r1, lsr #1
     8c8:	9914      	ldr	r1, [sp, #80]	; 0x50
     8ca:	ea4e 7ec1 	orr.w	lr, lr, r1, lsl #31
     8ce:	0a09      	lsrs	r1, r1, #8
     8d0:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
     8d4:	ea4f 2c10 	mov.w	ip, r0, lsr #8
     8d8:	9814      	ldr	r0, [sp, #80]	; 0x50
     8da:	ea4c 6c00 	orr.w	ip, ip, r0, lsl #24
     8de:	ea8e 0c0c 	eor.w	ip, lr, ip
     8e2:	ea4f 1ed0 	mov.w	lr, r0, lsr #7
     8e6:	9804      	ldr	r0, [sp, #16]
     8e8:	ea88 0101 	eor.w	r1, r8, r1
     8ec:	ea4e 6e40 	orr.w	lr, lr, r0, lsl #25
     8f0:	ea81 010e 	eor.w	r1, r1, lr
     8f4:	ea8c 1cd0 	eor.w	ip, ip, r0, lsr #7
     8f8:	f8dd e07c 	ldr.w	lr, [sp, #124]	; 0x7c
     8fc:	981a      	ldr	r0, [sp, #104]	; 0x68
     8fe:	eb10 0a0e 	adds.w	sl, r0, lr
     902:	980a      	ldr	r0, [sp, #40]	; 0x28
     904:	f8dd e03c 	ldr.w	lr, [sp, #60]	; 0x3c
     908:	eb40 0e0e 	adc.w	lr, r0, lr
     90c:	9817      	ldr	r0, [sp, #92]	; 0x5c
     90e:	eb11 010a 	adds.w	r1, r1, sl
     912:	ea4f 4ad0 	mov.w	sl, r0, lsr #19
     916:	9807      	ldr	r0, [sp, #28]
     918:	eb4c 0c0e 	adc.w	ip, ip, lr
     91c:	ea4a 3a40 	orr.w	sl, sl, r0, lsl #13
     920:	ea4f 4ed0 	mov.w	lr, r0, lsr #19
     924:	9817      	ldr	r0, [sp, #92]	; 0x5c
     926:	ea4e 3e40 	orr.w	lr, lr, r0, lsl #13
     92a:	9807      	ldr	r0, [sp, #28]
     92c:	ea4f 09c0 	mov.w	r9, r0, lsl #3
     930:	9817      	ldr	r0, [sp, #92]	; 0x5c
     932:	ea49 7950 	orr.w	r9, r9, r0, lsr #29
     936:	ea4f 08c0 	mov.w	r8, r0, lsl #3
     93a:	9807      	ldr	r0, [sp, #28]
     93c:	ea48 7850 	orr.w	r8, r8, r0, lsr #29
     940:	9817      	ldr	r0, [sp, #92]	; 0x5c
     942:	ea8a 0808 	eor.w	r8, sl, r8
     946:	ea4f 1a90 	mov.w	sl, r0, lsr #6
     94a:	9807      	ldr	r0, [sp, #28]
     94c:	ea4a 6a80 	orr.w	sl, sl, r0, lsl #26
     950:	ea8e 0e09 	eor.w	lr, lr, r9
     954:	ea88 080a 	eor.w	r8, r8, sl
     958:	eb11 0108 	adds.w	r1, r1, r8
     95c:	ea8e 1e90 	eor.w	lr, lr, r0, lsr #6
     960:	911a      	str	r1, [sp, #104]	; 0x68
     962:	eb4c 010e 	adc.w	r1, ip, lr
     966:	910a      	str	r1, [sp, #40]	; 0x28
     968:	9928      	ldr	r1, [sp, #160]	; 0xa0
     96a:	18ba      	adds	r2, r7, r2
     96c:	eb41 0006 	adc.w	r0, r1, r6
     970:	991a      	ldr	r1, [sp, #104]	; 0x68
     972:	9f27      	ldr	r7, [sp, #156]	; 0x9c
     974:	1852      	adds	r2, r2, r1
     976:	990a      	ldr	r1, [sp, #40]	; 0x28
     978:	eb41 0000 	adc.w	r0, r1, r0
     97c:	9922      	ldr	r1, [sp, #136]	; 0x88
     97e:	1889      	adds	r1, r1, r2
     980:	912a      	str	r1, [sp, #168]	; 0xa8
     982:	9929      	ldr	r1, [sp, #164]	; 0xa4
     984:	eb41 0100 	adc.w	r1, r1, r0
     988:	9129      	str	r1, [sp, #164]	; 0xa4
     98a:	9927      	ldr	r1, [sp, #156]	; 0x9c
     98c:	ea4f 7e1b 	mov.w	lr, fp, lsr #28
     990:	ea4e 1e01 	orr.w	lr, lr, r1, lsl #4
     994:	ea4f 7c11 	mov.w	ip, r1, lsr #28
     998:	0789      	lsls	r1, r1, #30
     99a:	ea41 019b 	orr.w	r1, r1, fp, lsr #2
     99e:	ea4c 1c0b 	orr.w	ip, ip, fp, lsl #4
     9a2:	ea8c 0c01 	eor.w	ip, ip, r1
     9a6:	ea4f 768b 	mov.w	r6, fp, lsl #30
     9aa:	0679      	lsls	r1, r7, #25
     9ac:	ea46 0697 	orr.w	r6, r6, r7, lsr #2
     9b0:	ea41 11db 	orr.w	r1, r1, fp, lsr #7
     9b4:	ea8c 0c01 	eor.w	ip, ip, r1
     9b8:	ea8e 0e06 	eor.w	lr, lr, r6
     9bc:	9925      	ldr	r1, [sp, #148]	; 0x94
     9be:	ea4f 664b 	mov.w	r6, fp, lsl #25
     9c2:	ea46 16d7 	orr.w	r6, r6, r7, lsr #7
     9c6:	ea8e 0e06 	eor.w	lr, lr, r6
     9ca:	ea41 060b 	orr.w	r6, r1, fp
     9ce:	9926      	ldr	r1, [sp, #152]	; 0x98
     9d0:	430f      	orrs	r7, r1
     9d2:	9923      	ldr	r1, [sp, #140]	; 0x8c
     9d4:	400e      	ands	r6, r1
     9d6:	9924      	ldr	r1, [sp, #144]	; 0x90
     9d8:	e9dd 8926 	ldrd	r8, r9, [sp, #152]	; 0x98
     9dc:	400f      	ands	r7, r1
     9de:	9925      	ldr	r1, [sp, #148]	; 0x94
     9e0:	ea01 010b 	and.w	r1, r1, fp
     9e4:	4331      	orrs	r1, r6
     9e6:	ea08 0809 	and.w	r8, r8, r9
     9ea:	eb1e 0101 	adds.w	r1, lr, r1
     9ee:	ea47 0808 	orr.w	r8, r7, r8
     9f2:	eb4c 0808 	adc.w	r8, ip, r8
     9f6:	188a      	adds	r2, r1, r2
     9f8:	9222      	str	r2, [sp, #136]	; 0x88
     9fa:	eb40 0208 	adc.w	r2, r0, r8
     9fe:	9228      	str	r2, [sp, #160]	; 0xa0
     a00:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
     a02:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
     a04:	0b97      	lsrs	r7, r2, #14
     a06:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     a08:	ea47 4782 	orr.w	r7, r7, r2, lsl #18
     a0c:	0b90      	lsrs	r0, r2, #14
     a0e:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
     a10:	ea40 4082 	orr.w	r0, r0, r2, lsl #18
     a14:	0c91      	lsrs	r1, r2, #18
     a16:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     a18:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     a1c:	0c92      	lsrs	r2, r2, #18
     a1e:	ea42 3286 	orr.w	r2, r2, r6, lsl #14
     a22:	4050      	eors	r0, r2
     a24:	9a29      	ldr	r2, [sp, #164]	; 0xa4
     a26:	05d2      	lsls	r2, r2, #23
     a28:	404f      	eors	r7, r1
     a2a:	ea42 2256 	orr.w	r2, r2, r6, lsr #9
     a2e:	05f1      	lsls	r1, r6, #23
     a30:	9e29      	ldr	r6, [sp, #164]	; 0xa4
     a32:	4042      	eors	r2, r0
     a34:	ea41 2156 	orr.w	r1, r1, r6, lsr #9
     a38:	9230      	str	r2, [sp, #192]	; 0xc0
     a3a:	404f      	eors	r7, r1
     a3c:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     a3e:	992f      	ldr	r1, [sp, #188]	; 0xbc
     a40:	9831      	ldr	r0, [sp, #196]	; 0xc4
     a42:	404a      	eors	r2, r1
     a44:	992e      	ldr	r1, [sp, #184]	; 0xb8
     a46:	ea81 0600 	eor.w	r6, r1, r0
     a4a:	992a      	ldr	r1, [sp, #168]	; 0xa8
     a4c:	400a      	ands	r2, r1
     a4e:	9929      	ldr	r1, [sp, #164]	; 0xa4
     a50:	982b      	ldr	r0, [sp, #172]	; 0xac
     a52:	f8d3 c02c 	ldr.w	ip, [r3, #44]	; 0x2c
     a56:	400e      	ands	r6, r1
     a58:	992d      	ldr	r1, [sp, #180]	; 0xb4
     a5a:	404a      	eors	r2, r1
     a5c:	992e      	ldr	r1, [sp, #184]	; 0xb8
     a5e:	404e      	eors	r6, r1
     a60:	6a99      	ldr	r1, [r3, #40]	; 0x28
     a62:	1841      	adds	r1, r0, r1
     a64:	982c      	ldr	r0, [sp, #176]	; 0xb0
     a66:	eb40 0c0c 	adc.w	ip, r0, ip
     a6a:	1852      	adds	r2, r2, r1
     a6c:	9901      	ldr	r1, [sp, #4]
     a6e:	eb46 060c 	adc.w	r6, r6, ip
     a72:	2900      	cmp	r1, #0
     a74:	f001 8264 	beq.w	1f40 <_Transform_Sha512+0x1f40>
     a78:	9915      	ldr	r1, [sp, #84]	; 0x54
     a7a:	9805      	ldr	r0, [sp, #20]
     a7c:	ea4f 0851 	mov.w	r8, r1, lsr #1
     a80:	9905      	ldr	r1, [sp, #20]
     a82:	ea48 78c1 	orr.w	r8, r8, r1, lsl #31
     a86:	ea4f 0e51 	mov.w	lr, r1, lsr #1
     a8a:	9915      	ldr	r1, [sp, #84]	; 0x54
     a8c:	ea4e 7ec1 	orr.w	lr, lr, r1, lsl #31
     a90:	0a09      	lsrs	r1, r1, #8
     a92:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
     a96:	ea4f 2c10 	mov.w	ip, r0, lsr #8
     a9a:	9815      	ldr	r0, [sp, #84]	; 0x54
     a9c:	ea4c 6c00 	orr.w	ip, ip, r0, lsl #24
     aa0:	ea8e 0c0c 	eor.w	ip, lr, ip
     aa4:	ea4f 1ed0 	mov.w	lr, r0, lsr #7
     aa8:	9805      	ldr	r0, [sp, #20]
     aaa:	ea88 0101 	eor.w	r1, r8, r1
     aae:	ea4e 6e40 	orr.w	lr, lr, r0, lsl #25
     ab2:	ea81 010e 	eor.w	r1, r1, lr
     ab6:	ea8c 1cd0 	eor.w	ip, ip, r0, lsr #7
     aba:	f8dd e080 	ldr.w	lr, [sp, #128]	; 0x80
     abe:	9814      	ldr	r0, [sp, #80]	; 0x50
     ac0:	eb10 0a0e 	adds.w	sl, r0, lr
     ac4:	9804      	ldr	r0, [sp, #16]
     ac6:	f8dd e040 	ldr.w	lr, [sp, #64]	; 0x40
     aca:	eb40 0e0e 	adc.w	lr, r0, lr
     ace:	9812      	ldr	r0, [sp, #72]	; 0x48
     ad0:	eb11 010a 	adds.w	r1, r1, sl
     ad4:	ea4f 4ad0 	mov.w	sl, r0, lsr #19
     ad8:	9802      	ldr	r0, [sp, #8]
     ada:	eb4c 0c0e 	adc.w	ip, ip, lr
     ade:	ea4a 3a40 	orr.w	sl, sl, r0, lsl #13
     ae2:	ea4f 4ed0 	mov.w	lr, r0, lsr #19
     ae6:	9812      	ldr	r0, [sp, #72]	; 0x48
     ae8:	ea4e 3e40 	orr.w	lr, lr, r0, lsl #13
     aec:	9802      	ldr	r0, [sp, #8]
     aee:	ea4f 09c0 	mov.w	r9, r0, lsl #3
     af2:	9812      	ldr	r0, [sp, #72]	; 0x48
     af4:	ea49 7950 	orr.w	r9, r9, r0, lsr #29
     af8:	ea4f 08c0 	mov.w	r8, r0, lsl #3
     afc:	9802      	ldr	r0, [sp, #8]
     afe:	ea48 7850 	orr.w	r8, r8, r0, lsr #29
     b02:	9812      	ldr	r0, [sp, #72]	; 0x48
     b04:	ea8a 0808 	eor.w	r8, sl, r8
     b08:	ea4f 1a90 	mov.w	sl, r0, lsr #6
     b0c:	9802      	ldr	r0, [sp, #8]
     b0e:	ea4a 6a80 	orr.w	sl, sl, r0, lsl #26
     b12:	ea8e 0e09 	eor.w	lr, lr, r9
     b16:	ea88 080a 	eor.w	r8, r8, sl
     b1a:	eb11 0108 	adds.w	r1, r1, r8
     b1e:	ea8e 1e90 	eor.w	lr, lr, r0, lsr #6
     b22:	9114      	str	r1, [sp, #80]	; 0x50
     b24:	eb4c 010e 	adc.w	r1, ip, lr
     b28:	9104      	str	r1, [sp, #16]
     b2a:	9930      	ldr	r1, [sp, #192]	; 0xc0
     b2c:	18ba      	adds	r2, r7, r2
     b2e:	eb41 0006 	adc.w	r0, r1, r6
     b32:	9914      	ldr	r1, [sp, #80]	; 0x50
     b34:	9e22      	ldr	r6, [sp, #136]	; 0x88
     b36:	9f28      	ldr	r7, [sp, #160]	; 0xa0
     b38:	1852      	adds	r2, r2, r1
     b3a:	9904      	ldr	r1, [sp, #16]
     b3c:	eb41 0000 	adc.w	r0, r1, r0
     b40:	9923      	ldr	r1, [sp, #140]	; 0x8c
     b42:	1889      	adds	r1, r1, r2
     b44:	912b      	str	r1, [sp, #172]	; 0xac
     b46:	9924      	ldr	r1, [sp, #144]	; 0x90
     b48:	eb41 0100 	adc.w	r1, r1, r0
     b4c:	912c      	str	r1, [sp, #176]	; 0xb0
     b4e:	9922      	ldr	r1, [sp, #136]	; 0x88
     b50:	ea4f 7e11 	mov.w	lr, r1, lsr #28
     b54:	9928      	ldr	r1, [sp, #160]	; 0xa0
     b56:	ea4e 1e01 	orr.w	lr, lr, r1, lsl #4
     b5a:	ea4f 7c11 	mov.w	ip, r1, lsr #28
     b5e:	9922      	ldr	r1, [sp, #136]	; 0x88
     b60:	ea4c 1c01 	orr.w	ip, ip, r1, lsl #4
     b64:	9928      	ldr	r1, [sp, #160]	; 0xa0
     b66:	0789      	lsls	r1, r1, #30
     b68:	ea41 0196 	orr.w	r1, r1, r6, lsr #2
     b6c:	07b6      	lsls	r6, r6, #30
     b6e:	ea46 0697 	orr.w	r6, r6, r7, lsr #2
     b72:	ea8e 0e06 	eor.w	lr, lr, r6
     b76:	9e22      	ldr	r6, [sp, #136]	; 0x88
     b78:	ea8c 0c01 	eor.w	ip, ip, r1
     b7c:	0679      	lsls	r1, r7, #25
     b7e:	ea41 11d6 	orr.w	r1, r1, r6, lsr #7
     b82:	ea8c 0c01 	eor.w	ip, ip, r1
     b86:	0676      	lsls	r6, r6, #25
     b88:	9922      	ldr	r1, [sp, #136]	; 0x88
     b8a:	ea46 16d7 	orr.w	r6, r6, r7, lsr #7
     b8e:	ea8e 0e06 	eor.w	lr, lr, r6
     b92:	ea4b 0601 	orr.w	r6, fp, r1
     b96:	9927      	ldr	r1, [sp, #156]	; 0x9c
     b98:	430f      	orrs	r7, r1
     b9a:	9925      	ldr	r1, [sp, #148]	; 0x94
     b9c:	400e      	ands	r6, r1
     b9e:	9926      	ldr	r1, [sp, #152]	; 0x98
     ba0:	e9dd 8927 	ldrd	r8, r9, [sp, #156]	; 0x9c
     ba4:	400f      	ands	r7, r1
     ba6:	9922      	ldr	r1, [sp, #136]	; 0x88
     ba8:	ea0b 0101 	and.w	r1, fp, r1
     bac:	4331      	orrs	r1, r6
     bae:	ea08 0809 	and.w	r8, r8, r9
     bb2:	eb1e 0101 	adds.w	r1, lr, r1
     bb6:	ea47 0808 	orr.w	r8, r7, r8
     bba:	eb4c 0808 	adc.w	r8, ip, r8
     bbe:	188a      	adds	r2, r1, r2
     bc0:	9223      	str	r2, [sp, #140]	; 0x8c
     bc2:	eb40 0208 	adc.w	r2, r0, r8
     bc6:	9224      	str	r2, [sp, #144]	; 0x90
     bc8:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     bca:	9e2b      	ldr	r6, [sp, #172]	; 0xac
     bcc:	0b97      	lsrs	r7, r2, #14
     bce:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     bd0:	ea47 4782 	orr.w	r7, r7, r2, lsl #18
     bd4:	0b90      	lsrs	r0, r2, #14
     bd6:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     bd8:	ea40 4082 	orr.w	r0, r0, r2, lsl #18
     bdc:	0c91      	lsrs	r1, r2, #18
     bde:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     be0:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     be4:	0c92      	lsrs	r2, r2, #18
     be6:	ea42 3286 	orr.w	r2, r2, r6, lsl #14
     bea:	4050      	eors	r0, r2
     bec:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
     bee:	05d2      	lsls	r2, r2, #23
     bf0:	404f      	eors	r7, r1
     bf2:	ea42 2256 	orr.w	r2, r2, r6, lsr #9
     bf6:	05f1      	lsls	r1, r6, #23
     bf8:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
     bfa:	4042      	eors	r2, r0
     bfc:	ea41 2156 	orr.w	r1, r1, r6, lsr #9
     c00:	404f      	eors	r7, r1
     c02:	9230      	str	r2, [sp, #192]	; 0xc0
     c04:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     c06:	992a      	ldr	r1, [sp, #168]	; 0xa8
     c08:	9829      	ldr	r0, [sp, #164]	; 0xa4
     c0a:	f8d3 c034 	ldr.w	ip, [r3, #52]	; 0x34
     c0e:	404a      	eors	r2, r1
     c10:	9931      	ldr	r1, [sp, #196]	; 0xc4
     c12:	ea81 0600 	eor.w	r6, r1, r0
     c16:	992b      	ldr	r1, [sp, #172]	; 0xac
     c18:	982d      	ldr	r0, [sp, #180]	; 0xb4
     c1a:	400a      	ands	r2, r1
     c1c:	992c      	ldr	r1, [sp, #176]	; 0xb0
     c1e:	400e      	ands	r6, r1
     c20:	992f      	ldr	r1, [sp, #188]	; 0xbc
     c22:	404a      	eors	r2, r1
     c24:	9931      	ldr	r1, [sp, #196]	; 0xc4
     c26:	404e      	eors	r6, r1
     c28:	6b19      	ldr	r1, [r3, #48]	; 0x30
     c2a:	1841      	adds	r1, r0, r1
     c2c:	982e      	ldr	r0, [sp, #184]	; 0xb8
     c2e:	eb40 0c0c 	adc.w	ip, r0, ip
     c32:	1852      	adds	r2, r2, r1
     c34:	9901      	ldr	r1, [sp, #4]
     c36:	eb46 060c 	adc.w	r6, r6, ip
     c3a:	2900      	cmp	r1, #0
     c3c:	f001 8185 	beq.w	1f4a <_Transform_Sha512+0x1f4a>
     c40:	9916      	ldr	r1, [sp, #88]	; 0x58
     c42:	9806      	ldr	r0, [sp, #24]
     c44:	ea4f 0851 	mov.w	r8, r1, lsr #1
     c48:	9906      	ldr	r1, [sp, #24]
     c4a:	ea48 78c1 	orr.w	r8, r8, r1, lsl #31
     c4e:	ea4f 0e51 	mov.w	lr, r1, lsr #1
     c52:	9916      	ldr	r1, [sp, #88]	; 0x58
     c54:	ea4e 7ec1 	orr.w	lr, lr, r1, lsl #31
     c58:	0a09      	lsrs	r1, r1, #8
     c5a:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
     c5e:	ea4f 2c10 	mov.w	ip, r0, lsr #8
     c62:	9816      	ldr	r0, [sp, #88]	; 0x58
     c64:	ea4c 6c00 	orr.w	ip, ip, r0, lsl #24
     c68:	ea8e 0c0c 	eor.w	ip, lr, ip
     c6c:	ea4f 1ed0 	mov.w	lr, r0, lsr #7
     c70:	9806      	ldr	r0, [sp, #24]
     c72:	ea88 0101 	eor.w	r1, r8, r1
     c76:	ea4e 6e40 	orr.w	lr, lr, r0, lsl #25
     c7a:	ea81 010e 	eor.w	r1, r1, lr
     c7e:	ea8c 1cd0 	eor.w	ip, ip, r0, lsr #7
     c82:	f8dd e084 	ldr.w	lr, [sp, #132]	; 0x84
     c86:	9815      	ldr	r0, [sp, #84]	; 0x54
     c88:	eb10 0a0e 	adds.w	sl, r0, lr
     c8c:	9805      	ldr	r0, [sp, #20]
     c8e:	f8dd e044 	ldr.w	lr, [sp, #68]	; 0x44
     c92:	eb40 0e0e 	adc.w	lr, r0, lr
     c96:	981a      	ldr	r0, [sp, #104]	; 0x68
     c98:	eb11 010a 	adds.w	r1, r1, sl
     c9c:	ea4f 4ad0 	mov.w	sl, r0, lsr #19
     ca0:	980a      	ldr	r0, [sp, #40]	; 0x28
     ca2:	eb4c 0c0e 	adc.w	ip, ip, lr
     ca6:	ea4a 3a40 	orr.w	sl, sl, r0, lsl #13
     caa:	ea4f 4ed0 	mov.w	lr, r0, lsr #19
     cae:	981a      	ldr	r0, [sp, #104]	; 0x68
     cb0:	ea4e 3e40 	orr.w	lr, lr, r0, lsl #13
     cb4:	980a      	ldr	r0, [sp, #40]	; 0x28
     cb6:	ea4f 09c0 	mov.w	r9, r0, lsl #3
     cba:	981a      	ldr	r0, [sp, #104]	; 0x68
     cbc:	ea49 7950 	orr.w	r9, r9, r0, lsr #29
     cc0:	ea4f 08c0 	mov.w	r8, r0, lsl #3
     cc4:	980a      	ldr	r0, [sp, #40]	; 0x28
     cc6:	ea48 7850 	orr.w	r8, r8, r0, lsr #29
     cca:	981a      	ldr	r0, [sp, #104]	; 0x68
     ccc:	ea8a 0808 	eor.w	r8, sl, r8
     cd0:	ea4f 1a90 	mov.w	sl, r0, lsr #6
     cd4:	980a      	ldr	r0, [sp, #40]	; 0x28
     cd6:	ea4a 6a80 	orr.w	sl, sl, r0, lsl #26
     cda:	ea8e 0e09 	eor.w	lr, lr, r9
     cde:	ea88 080a 	eor.w	r8, r8, sl
     ce2:	eb11 0108 	adds.w	r1, r1, r8
     ce6:	ea8e 1e90 	eor.w	lr, lr, r0, lsr #6
     cea:	9115      	str	r1, [sp, #84]	; 0x54
     cec:	eb4c 010e 	adc.w	r1, ip, lr
     cf0:	9105      	str	r1, [sp, #20]
     cf2:	9930      	ldr	r1, [sp, #192]	; 0xc0
     cf4:	f8dd 9090 	ldr.w	r9, [sp, #144]	; 0x90
     cf8:	18ba      	adds	r2, r7, r2
     cfa:	eb41 0006 	adc.w	r0, r1, r6
     cfe:	9915      	ldr	r1, [sp, #84]	; 0x54
     d00:	9e23      	ldr	r6, [sp, #140]	; 0x8c
     d02:	9f24      	ldr	r7, [sp, #144]	; 0x90
     d04:	1852      	adds	r2, r2, r1
     d06:	9905      	ldr	r1, [sp, #20]
     d08:	eb41 0000 	adc.w	r0, r1, r0
     d0c:	9925      	ldr	r1, [sp, #148]	; 0x94
     d0e:	1889      	adds	r1, r1, r2
     d10:	912d      	str	r1, [sp, #180]	; 0xb4
     d12:	9926      	ldr	r1, [sp, #152]	; 0x98
     d14:	eb41 0100 	adc.w	r1, r1, r0
     d18:	912e      	str	r1, [sp, #184]	; 0xb8
     d1a:	9923      	ldr	r1, [sp, #140]	; 0x8c
     d1c:	ea4f 7e11 	mov.w	lr, r1, lsr #28
     d20:	9924      	ldr	r1, [sp, #144]	; 0x90
     d22:	ea4e 1e01 	orr.w	lr, lr, r1, lsl #4
     d26:	ea4f 7c11 	mov.w	ip, r1, lsr #28
     d2a:	9923      	ldr	r1, [sp, #140]	; 0x8c
     d2c:	ea4c 1c01 	orr.w	ip, ip, r1, lsl #4
     d30:	9924      	ldr	r1, [sp, #144]	; 0x90
     d32:	0789      	lsls	r1, r1, #30
     d34:	ea41 0196 	orr.w	r1, r1, r6, lsr #2
     d38:	07b6      	lsls	r6, r6, #30
     d3a:	ea46 0697 	orr.w	r6, r6, r7, lsr #2
     d3e:	ea8e 0e06 	eor.w	lr, lr, r6
     d42:	9e23      	ldr	r6, [sp, #140]	; 0x8c
     d44:	ea8c 0c01 	eor.w	ip, ip, r1
     d48:	0679      	lsls	r1, r7, #25
     d4a:	ea41 11d6 	orr.w	r1, r1, r6, lsr #7
     d4e:	0676      	lsls	r6, r6, #25
     d50:	ea46 16d7 	orr.w	r6, r6, r7, lsr #7
     d54:	ea8c 0c01 	eor.w	ip, ip, r1
     d58:	ea8e 0e06 	eor.w	lr, lr, r6
     d5c:	e9dd 1622 	ldrd	r1, r6, [sp, #136]	; 0x88
     d60:	430e      	orrs	r6, r1
     d62:	9928      	ldr	r1, [sp, #160]	; 0xa0
     d64:	430f      	orrs	r7, r1
     d66:	9927      	ldr	r1, [sp, #156]	; 0x9c
     d68:	400f      	ands	r7, r1
     d6a:	e9dd 1822 	ldrd	r1, r8, [sp, #136]	; 0x88
     d6e:	ea01 0108 	and.w	r1, r1, r8
     d72:	f8dd 80a0 	ldr.w	r8, [sp, #160]	; 0xa0
     d76:	ea06 060b 	and.w	r6, r6, fp
     d7a:	4331      	orrs	r1, r6
     d7c:	ea08 0809 	and.w	r8, r8, r9
     d80:	eb1e 0101 	adds.w	r1, lr, r1
     d84:	ea47 0808 	orr.w	r8, r7, r8
     d88:	eb4c 0808 	adc.w	r8, ip, r8
     d8c:	188a      	adds	r2, r1, r2
     d8e:	9225      	str	r2, [sp, #148]	; 0x94
     d90:	eb40 0208 	adc.w	r2, r0, r8
     d94:	9226      	str	r2, [sp, #152]	; 0x98
     d96:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     d98:	9e2d      	ldr	r6, [sp, #180]	; 0xb4
     d9a:	ea4f 3c92 	mov.w	ip, r2, lsr #14
     d9e:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     da0:	ea4c 4c82 	orr.w	ip, ip, r2, lsl #18
     da4:	0b90      	lsrs	r0, r2, #14
     da6:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
     da8:	ea40 4082 	orr.w	r0, r0, r2, lsl #18
     dac:	0c91      	lsrs	r1, r2, #18
     dae:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     db0:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     db4:	0c92      	lsrs	r2, r2, #18
     db6:	ea42 3286 	orr.w	r2, r2, r6, lsl #14
     dba:	4050      	eors	r0, r2
     dbc:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
     dbe:	05d2      	lsls	r2, r2, #23
     dc0:	ea8c 0c01 	eor.w	ip, ip, r1
     dc4:	ea42 2256 	orr.w	r2, r2, r6, lsr #9
     dc8:	05f1      	lsls	r1, r6, #23
     dca:	9e2e      	ldr	r6, [sp, #184]	; 0xb8
     dcc:	4042      	eors	r2, r0
     dce:	ea41 2156 	orr.w	r1, r1, r6, lsr #9
     dd2:	9230      	str	r2, [sp, #192]	; 0xc0
     dd4:	ea8c 0c01 	eor.w	ip, ip, r1
     dd8:	e9dd 212a 	ldrd	r2, r1, [sp, #168]	; 0xa8
     ddc:	982c      	ldr	r0, [sp, #176]	; 0xb0
     dde:	404a      	eors	r2, r1
     de0:	9929      	ldr	r1, [sp, #164]	; 0xa4
     de2:	ea81 0700 	eor.w	r7, r1, r0
     de6:	992d      	ldr	r1, [sp, #180]	; 0xb4
     de8:	982f      	ldr	r0, [sp, #188]	; 0xbc
     dea:	400a      	ands	r2, r1
     dec:	992a      	ldr	r1, [sp, #168]	; 0xa8
     dee:	404a      	eors	r2, r1
     df0:	9929      	ldr	r1, [sp, #164]	; 0xa4
     df2:	4037      	ands	r7, r6
     df4:	404f      	eors	r7, r1
     df6:	e9d3 160e 	ldrd	r1, r6, [r3, #56]	; 0x38
     dfa:	1841      	adds	r1, r0, r1
     dfc:	9831      	ldr	r0, [sp, #196]	; 0xc4
     dfe:	eb40 0606 	adc.w	r6, r0, r6
     e02:	1852      	adds	r2, r2, r1
     e04:	9901      	ldr	r1, [sp, #4]
     e06:	eb47 0706 	adc.w	r7, r7, r6
     e0a:	2900      	cmp	r1, #0
     e0c:	f001 80a2 	beq.w	1f54 <_Transform_Sha512+0x1f54>
     e10:	991b      	ldr	r1, [sp, #108]	; 0x6c
     e12:	980b      	ldr	r0, [sp, #44]	; 0x2c
     e14:	ea4f 0851 	mov.w	r8, r1, lsr #1
     e18:	990b      	ldr	r1, [sp, #44]	; 0x2c
     e1a:	ea48 78c1 	orr.w	r8, r8, r1, lsl #31
     e1e:	ea4f 0e51 	mov.w	lr, r1, lsr #1
     e22:	991b      	ldr	r1, [sp, #108]	; 0x6c
     e24:	ea4e 7ec1 	orr.w	lr, lr, r1, lsl #31
     e28:	0a09      	lsrs	r1, r1, #8
     e2a:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
     e2e:	0a06      	lsrs	r6, r0, #8
     e30:	981b      	ldr	r0, [sp, #108]	; 0x6c
     e32:	ea88 0101 	eor.w	r1, r8, r1
     e36:	ea46 6600 	orr.w	r6, r6, r0, lsl #24
     e3a:	ea4f 18d0 	mov.w	r8, r0, lsr #7
     e3e:	980b      	ldr	r0, [sp, #44]	; 0x2c
     e40:	ea8e 0606 	eor.w	r6, lr, r6
     e44:	ea48 6840 	orr.w	r8, r8, r0, lsl #25
     e48:	ea86 16d0 	eor.w	r6, r6, r0, lsr #7
     e4c:	9816      	ldr	r0, [sp, #88]	; 0x58
     e4e:	ea81 0108 	eor.w	r1, r1, r8
     e52:	1809      	adds	r1, r1, r0
     e54:	9806      	ldr	r0, [sp, #24]
     e56:	eb40 0606 	adc.w	r6, r0, r6
     e5a:	9818      	ldr	r0, [sp, #96]	; 0x60
     e5c:	1809      	adds	r1, r1, r0
     e5e:	9808      	ldr	r0, [sp, #32]
     e60:	eb40 0606 	adc.w	r6, r0, r6
     e64:	9814      	ldr	r0, [sp, #80]	; 0x50
     e66:	ea4f 4ad0 	mov.w	sl, r0, lsr #19
     e6a:	9804      	ldr	r0, [sp, #16]
     e6c:	ea4a 3a40 	orr.w	sl, sl, r0, lsl #13
     e70:	ea4f 4ed0 	mov.w	lr, r0, lsr #19
     e74:	9814      	ldr	r0, [sp, #80]	; 0x50
     e76:	ea4e 3e40 	orr.w	lr, lr, r0, lsl #13
     e7a:	9804      	ldr	r0, [sp, #16]
     e7c:	ea4f 09c0 	mov.w	r9, r0, lsl #3
     e80:	9814      	ldr	r0, [sp, #80]	; 0x50
     e82:	ea49 7950 	orr.w	r9, r9, r0, lsr #29
     e86:	ea4f 08c0 	mov.w	r8, r0, lsl #3
     e8a:	9804      	ldr	r0, [sp, #16]
     e8c:	ea48 7850 	orr.w	r8, r8, r0, lsr #29
     e90:	9814      	ldr	r0, [sp, #80]	; 0x50
     e92:	ea8a 0808 	eor.w	r8, sl, r8
     e96:	ea4f 1a90 	mov.w	sl, r0, lsr #6
     e9a:	9804      	ldr	r0, [sp, #16]
     e9c:	ea4a 6a80 	orr.w	sl, sl, r0, lsl #26
     ea0:	ea8e 0e09 	eor.w	lr, lr, r9
     ea4:	ea88 080a 	eor.w	r8, r8, sl
     ea8:	eb11 0108 	adds.w	r1, r1, r8
     eac:	ea8e 1e90 	eor.w	lr, lr, r0, lsr #6
     eb0:	9116      	str	r1, [sp, #88]	; 0x58
     eb2:	eb46 010e 	adc.w	r1, r6, lr
     eb6:	9106      	str	r1, [sp, #24]
     eb8:	9930      	ldr	r1, [sp, #192]	; 0xc0
     eba:	f8dd 8094 	ldr.w	r8, [sp, #148]	; 0x94
     ebe:	f8dd 9098 	ldr.w	r9, [sp, #152]	; 0x98
     ec2:	eb1c 0202 	adds.w	r2, ip, r2
     ec6:	eb41 0007 	adc.w	r0, r1, r7
     eca:	9916      	ldr	r1, [sp, #88]	; 0x58
     ecc:	f8dd c094 	ldr.w	ip, [sp, #148]	; 0x94
     ed0:	1852      	adds	r2, r2, r1
     ed2:	9906      	ldr	r1, [sp, #24]
     ed4:	eb41 0000 	adc.w	r0, r1, r0
     ed8:	eb1b 0102 	adds.w	r1, fp, r2
     edc:	912f      	str	r1, [sp, #188]	; 0xbc
     ede:	9927      	ldr	r1, [sp, #156]	; 0x9c
     ee0:	eb41 0100 	adc.w	r1, r1, r0
     ee4:	9130      	str	r1, [sp, #192]	; 0xc0
     ee6:	9926      	ldr	r1, [sp, #152]	; 0x98
     ee8:	078e      	lsls	r6, r1, #30
     eea:	9925      	ldr	r1, [sp, #148]	; 0x94
     eec:	ea46 0691 	orr.w	r6, r6, r1, lsr #2
     ef0:	ea4f 7e81 	mov.w	lr, r1, lsl #30
     ef4:	9926      	ldr	r1, [sp, #152]	; 0x98
     ef6:	ea4e 0e91 	orr.w	lr, lr, r1, lsr #2
     efa:	9925      	ldr	r1, [sp, #148]	; 0x94
     efc:	0f0f      	lsrs	r7, r1, #28
     efe:	9926      	ldr	r1, [sp, #152]	; 0x98
     f00:	ea47 1701 	orr.w	r7, r7, r1, lsl #4
     f04:	0f09      	lsrs	r1, r1, #28
     f06:	ea41 110c 	orr.w	r1, r1, ip, lsl #4
     f0a:	404e      	eors	r6, r1
     f0c:	9926      	ldr	r1, [sp, #152]	; 0x98
     f0e:	0649      	lsls	r1, r1, #25
     f10:	ea41 11dc 	orr.w	r1, r1, ip, lsr #7
     f14:	ea8e 0e07 	eor.w	lr, lr, r7
     f18:	4667      	mov	r7, ip
     f1a:	f8dd c098 	ldr.w	ip, [sp, #152]	; 0x98
     f1e:	067f      	lsls	r7, r7, #25
     f20:	ea47 17dc 	orr.w	r7, r7, ip, lsr #7
     f24:	404e      	eors	r6, r1
     f26:	ea8e 0e07 	eor.w	lr, lr, r7
     f2a:	9923      	ldr	r1, [sp, #140]	; 0x8c
     f2c:	9f25      	ldr	r7, [sp, #148]	; 0x94
     f2e:	430f      	orrs	r7, r1
     f30:	9924      	ldr	r1, [sp, #144]	; 0x90
     f32:	ea41 0c0c 	orr.w	ip, r1, ip
     f36:	9922      	ldr	r1, [sp, #136]	; 0x88
     f38:	400f      	ands	r7, r1
     f3a:	9928      	ldr	r1, [sp, #160]	; 0xa0
     f3c:	ea0c 0c01 	and.w	ip, ip, r1
     f40:	9923      	ldr	r1, [sp, #140]	; 0x8c
     f42:	ea01 0108 	and.w	r1, r1, r8
     f46:	f8dd 8090 	ldr.w	r8, [sp, #144]	; 0x90
     f4a:	4339      	orrs	r1, r7
     f4c:	ea08 0809 	and.w	r8, r8, r9
     f50:	eb1e 0101 	adds.w	r1, lr, r1
     f54:	ea4c 0808 	orr.w	r8, ip, r8
     f58:	eb46 0808 	adc.w	r8, r6, r8
     f5c:	eb11 0b02 	adds.w	fp, r1, r2
     f60:	eb40 0208 	adc.w	r2, r0, r8
     f64:	9227      	str	r2, [sp, #156]	; 0x9c
     f66:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     f68:	9e2f      	ldr	r6, [sp, #188]	; 0xbc
     f6a:	ea4f 3c92 	mov.w	ip, r2, lsr #14
     f6e:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     f70:	ea4c 4c82 	orr.w	ip, ip, r2, lsl #18
     f74:	0b90      	lsrs	r0, r2, #14
     f76:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     f78:	ea40 4082 	orr.w	r0, r0, r2, lsl #18
     f7c:	0c91      	lsrs	r1, r2, #18
     f7e:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     f80:	ea41 3182 	orr.w	r1, r1, r2, lsl #14
     f84:	0c92      	lsrs	r2, r2, #18
     f86:	ea42 3286 	orr.w	r2, r2, r6, lsl #14
        R( 8); R( 9); R(10); R(11);
     f8a:	4050      	eors	r0, r2
     f8c:	9a30      	ldr	r2, [sp, #192]	; 0xc0
     f8e:	05d2      	lsls	r2, r2, #23
     f90:	ea8c 0c01 	eor.w	ip, ip, r1
     f94:	ea42 2256 	orr.w	r2, r2, r6, lsr #9
     f98:	05f1      	lsls	r1, r6, #23
     f9a:	9e30      	ldr	r6, [sp, #192]	; 0xc0
     f9c:	4042      	eors	r2, r0
     f9e:	ea41 2156 	orr.w	r1, r1, r6, lsr #9
     fa2:	9231      	str	r2, [sp, #196]	; 0xc4
     fa4:	ea8c 0c01 	eor.w	ip, ip, r1
     fa8:	9a2b      	ldr	r2, [sp, #172]	; 0xac
     faa:	992d      	ldr	r1, [sp, #180]	; 0xb4
     fac:	982e      	ldr	r0, [sp, #184]	; 0xb8
     fae:	404a      	eors	r2, r1
     fb0:	992c      	ldr	r1, [sp, #176]	; 0xb0
     fb2:	ea81 0700 	eor.w	r7, r1, r0
     fb6:	992f      	ldr	r1, [sp, #188]	; 0xbc
     fb8:	982a      	ldr	r0, [sp, #168]	; 0xa8
     fba:	400a      	ands	r2, r1
     fbc:	992b      	ldr	r1, [sp, #172]	; 0xac
     fbe:	404a      	eors	r2, r1
     fc0:	992c      	ldr	r1, [sp, #176]	; 0xb0
     fc2:	4037      	ands	r7, r6
     fc4:	404f      	eors	r7, r1
     fc6:	e9d3 1610 	ldrd	r1, r6, [r3, #64]	; 0x40
     fca:	1841      	adds	r1, r0, r1
     fcc:	9829      	ldr	r0, [sp, #164]	; 0xa4
     fce:	eb40 0606 	adc.w	r6, r0, r6
     fd2:	1852      	adds	r2, r2, r1
     fd4:	9901      	ldr	r1, [sp, #4]
     fd6:	eb47 0706 	adc.w	r7, r7, r6
     fda:	2900      	cmp	r1, #0
     fdc:	f000 87bf 	beq.w	1f5e <_Transform_Sha512+0x1f5e>
     fe0:	991c      	ldr	r1, [sp, #112]	; 0x70
     fe2:	980c      	ldr	r0, [sp, #48]	; 0x30
     fe4:	ea4f 2811 	mov.w	r8, r1, lsr #8
     fe8:	990c      	ldr	r1, [sp, #48]	; 0x30
     fea:	ea48 6801 	orr.w	r8, r8, r1, lsl #24
     fee:	ea4f 2e11 	mov.w	lr, r1, lsr #8
     ff2:	991c      	ldr	r1, [sp, #112]	; 0x70
     ff4:	ea4e 6e01 	orr.w	lr, lr, r1, lsl #24
     ff8:	0849      	lsrs	r1, r1, #1
     ffa:	ea41 71c0 	orr.w	r1, r1, r0, lsl #31
     ffe:	0846      	lsrs	r6, r0, #1
    1000:	981c      	ldr	r0, [sp, #112]	; 0x70
    1002:	ea88 0101 	eor.w	r1, r8, r1
    1006:	ea46 76c0 	orr.w	r6, r6, r0, lsl #31
    100a:	ea4f 18d0 	mov.w	r8, r0, lsr #7
    100e:	980c      	ldr	r0, [sp, #48]	; 0x30
    1010:	ea8e 0606 	eor.w	r6, lr, r6
    1014:	ea48 6840 	orr.w	r8, r8, r0, lsl #25
    1018:	ea86 16d0 	eor.w	r6, r6, r0, lsr #7
    101c:	981b      	ldr	r0, [sp, #108]	; 0x6c
    101e:	ea81 0108 	eor.w	r1, r1, r8
    1022:	1809      	adds	r1, r1, r0
    1024:	980b      	ldr	r0, [sp, #44]	; 0x2c
    1026:	eb40 0606 	adc.w	r6, r0, r6
    102a:	9819      	ldr	r0, [sp, #100]	; 0x64
    102c:	1809      	adds	r1, r1, r0
    102e:	9809      	ldr	r0, [sp, #36]	; 0x24
    1030:	eb40 0606 	adc.w	r6, r0, r6
    1034:	9805      	ldr	r0, [sp, #20]
    1036:	ea4f 0ec0 	mov.w	lr, r0, lsl #3
    103a:	9815      	ldr	r0, [sp, #84]	; 0x54
    103c:	ea4e 7e50 	orr.w	lr, lr, r0, lsr #29
    1040:	ea4f 0ac0 	mov.w	sl, r0, lsl #3
    1044:	9805      	ldr	r0, [sp, #20]
    1046:	ea4a 7a50 	orr.w	sl, sl, r0, lsr #29
    104a:	9815      	ldr	r0, [sp, #84]	; 0x54
    104c:	ea4f 48d0 	mov.w	r8, r0, lsr #19
    1050:	9805      	ldr	r0, [sp, #20]
    1052:	ea48 3840 	orr.w	r8, r8, r0, lsl #13
    1056:	ea4f 49d0 	mov.w	r9, r0, lsr #19
    105a:	9815      	ldr	r0, [sp, #84]	; 0x54
    105c:	ea8a 0808 	eor.w	r8, sl, r8
    1060:	ea49 3940 	orr.w	r9, r9, r0, lsl #13
    1064:	ea4f 1a90 	mov.w	sl, r0, lsr #6
    1068:	9805      	ldr	r0, [sp, #20]
    106a:	ea4a 6a80 	orr.w	sl, sl, r0, lsl #26
    106e:	ea8e 0e09 	eor.w	lr, lr, r9
    1072:	ea88 080a 	eor.w	r8, r8, sl
    1076:	eb11 0108 	adds.w	r1, r1, r8
    107a:	ea8e 1e90 	eor.w	lr, lr, r0, lsr #6
    107e:	911b      	str	r1, [sp, #108]	; 0x6c
    1080:	eb46 010e 	adc.w	r1, r6, lr
    1084:	910b      	str	r1, [sp, #44]	; 0x2c
    1086:	9931      	ldr	r1, [sp, #196]	; 0xc4
    1088:	eb1c 0202 	adds.w	r2, ip, r2
    108c:	eb41 0007 	adc.w	r0, r1, r7
    1090:	991b      	ldr	r1, [sp, #108]	; 0x6c
    1092:	f8dd c09c 	ldr.w	ip, [sp, #156]	; 0x9c
    1096:	1852      	adds	r2, r2, r1
    1098:	990b      	ldr	r1, [sp, #44]	; 0x2c
    109a:	eb41 0000 	adc.w	r0, r1, r0
    109e:	9922      	ldr	r1, [sp, #136]	; 0x88
    10a0:	1889      	adds	r1, r1, r2
    10a2:	9129      	str	r1, [sp, #164]	; 0xa4
    10a4:	9928      	ldr	r1, [sp, #160]	; 0xa0
    10a6:	eb41 0100 	adc.w	r1, r1, r0
    10aa:	912a      	str	r1, [sp, #168]	; 0xa8
    10ac:	9927      	ldr	r1, [sp, #156]	; 0x9c
    10ae:	ea4f 7e8b 	mov.w	lr, fp, lsl #30
    10b2:	ea4f 771b 	mov.w	r7, fp, lsr #28
    10b6:	ea47 1701 	orr.w	r7, r7, r1, lsl #4
    10ba:	078e      	lsls	r6, r1, #30
    10bc:	ea4e 0e91 	orr.w	lr, lr, r1, lsr #2
    10c0:	0f09      	lsrs	r1, r1, #28
    10c2:	ea41 110b 	orr.w	r1, r1, fp, lsl #4
    10c6:	ea46 069b 	orr.w	r6, r6, fp, lsr #2
    10ca:	404e      	eors	r6, r1
    10cc:	9927      	ldr	r1, [sp, #156]	; 0x9c
    10ce:	0649      	lsls	r1, r1, #25
    10d0:	ea41 11db 	orr.w	r1, r1, fp, lsr #7
    10d4:	404e      	eors	r6, r1
    10d6:	ea8e 0e07 	eor.w	lr, lr, r7
    10da:	9925      	ldr	r1, [sp, #148]	; 0x94
    10dc:	ea4f 674b 	mov.w	r7, fp, lsl #25
    10e0:	ea47 17dc 	orr.w	r7, r7, ip, lsr #7
    10e4:	ea8e 0e07 	eor.w	lr, lr, r7
    10e8:	ea41 070b 	orr.w	r7, r1, fp
    10ec:	9926      	ldr	r1, [sp, #152]	; 0x98
    10ee:	ea41 0c0c 	orr.w	ip, r1, ip
    10f2:	9923      	ldr	r1, [sp, #140]	; 0x8c
    10f4:	400f      	ands	r7, r1
    10f6:	9924      	ldr	r1, [sp, #144]	; 0x90
    10f8:	e9dd 8926 	ldrd	r8, r9, [sp, #152]	; 0x98
    10fc:	ea0c 0c01 	and.w	ip, ip, r1
    1100:	9925      	ldr	r1, [sp, #148]	; 0x94
    1102:	ea01 010b 	and.w	r1, r1, fp
    1106:	4339      	orrs	r1, r7
    1108:	ea08 0809 	and.w	r8, r8, r9
    110c:	eb1e 0101 	adds.w	r1, lr, r1
    1110:	ea4c 0808 	orr.w	r8, ip, r8
    1114:	eb46 0808 	adc.w	r8, r6, r8
    1118:	188a      	adds	r2, r1, r2
    111a:	9222      	str	r2, [sp, #136]	; 0x88
    111c:	eb40 0208 	adc.w	r2, r0, r8
    1120:	9228      	str	r2, [sp, #160]	; 0xa0
    1122:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    1124:	9829      	ldr	r0, [sp, #164]	; 0xa4
    1126:	0c97      	lsrs	r7, r2, #18
    1128:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
    112a:	ea47 3782 	orr.w	r7, r7, r2, lsl #14
    112e:	ea4f 4c92 	mov.w	ip, r2, lsr #18
    1132:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    1134:	ea4c 3c82 	orr.w	ip, ip, r2, lsl #14
    1138:	0b91      	lsrs	r1, r2, #14
    113a:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
    113c:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
    1140:	0b92      	lsrs	r2, r2, #14
    1142:	ea42 4280 	orr.w	r2, r2, r0, lsl #18
    1146:	ea8c 0c02 	eor.w	ip, ip, r2
    114a:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
    114c:	05d2      	lsls	r2, r2, #23
    114e:	404f      	eors	r7, r1
    1150:	ea42 2250 	orr.w	r2, r2, r0, lsr #9
    1154:	05c1      	lsls	r1, r0, #23
    1156:	982a      	ldr	r0, [sp, #168]	; 0xa8
    1158:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
    115c:	4079      	eors	r1, r7
    115e:	9131      	str	r1, [sp, #196]	; 0xc4
    1160:	e9d3 1612 	ldrd	r1, r6, [r3, #72]	; 0x48
    1164:	ea8c 0c02 	eor.w	ip, ip, r2
    1168:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    116a:	1851      	adds	r1, r2, r1
    116c:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    116e:	eb42 0606 	adc.w	r6, r2, r6
    1172:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    1174:	982f      	ldr	r0, [sp, #188]	; 0xbc
    1176:	9f30      	ldr	r7, [sp, #192]	; 0xc0
    1178:	4050      	eors	r0, r2
    117a:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    117c:	407a      	eors	r2, r7
    117e:	9f29      	ldr	r7, [sp, #164]	; 0xa4
    1180:	4038      	ands	r0, r7
    1182:	9f2a      	ldr	r7, [sp, #168]	; 0xa8
    1184:	403a      	ands	r2, r7
    1186:	9f2d      	ldr	r7, [sp, #180]	; 0xb4
    1188:	4078      	eors	r0, r7
    118a:	9f2e      	ldr	r7, [sp, #184]	; 0xb8
    118c:	1809      	adds	r1, r1, r0
    118e:	ea82 0207 	eor.w	r2, r2, r7
    1192:	eb46 0602 	adc.w	r6, r6, r2
    1196:	9a01      	ldr	r2, [sp, #4]
    1198:	2a00      	cmp	r2, #0
    119a:	f000 86e7 	beq.w	1f6c <_Transform_Sha512+0x1f6c>
    119e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    11a0:	980d      	ldr	r0, [sp, #52]	; 0x34
    11a2:	9f1d      	ldr	r7, [sp, #116]	; 0x74
    11a4:	ea4f 2812 	mov.w	r8, r2, lsr #8
    11a8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    11aa:	ea48 6802 	orr.w	r8, r8, r2, lsl #24
    11ae:	ea4f 2e12 	mov.w	lr, r2, lsr #8
    11b2:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    11b4:	ea4e 6e02 	orr.w	lr, lr, r2, lsl #24
    11b8:	0852      	lsrs	r2, r2, #1
    11ba:	ea42 72c0 	orr.w	r2, r2, r0, lsl #31
    11be:	0840      	lsrs	r0, r0, #1
    11c0:	ea40 70c7 	orr.w	r0, r0, r7, lsl #31
    11c4:	ea88 0202 	eor.w	r2, r8, r2
    11c8:	ea4f 18d7 	mov.w	r8, r7, lsr #7
    11cc:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    11ce:	ea8e 0000 	eor.w	r0, lr, r0
    11d2:	ea48 6847 	orr.w	r8, r8, r7, lsl #25
    11d6:	ea80 10d7 	eor.w	r0, r0, r7, lsr #7
    11da:	9f1c      	ldr	r7, [sp, #112]	; 0x70
    11dc:	ea82 0208 	eor.w	r2, r2, r8
    11e0:	19d2      	adds	r2, r2, r7
    11e2:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    11e4:	eb47 0000 	adc.w	r0, r7, r0
    11e8:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    11ea:	19d2      	adds	r2, r2, r7
    11ec:	9f07      	ldr	r7, [sp, #28]
    11ee:	eb47 0000 	adc.w	r0, r7, r0
    11f2:	9f06      	ldr	r7, [sp, #24]
    11f4:	ea4f 0ec7 	mov.w	lr, r7, lsl #3
    11f8:	9f16      	ldr	r7, [sp, #88]	; 0x58
    11fa:	ea4e 7e57 	orr.w	lr, lr, r7, lsr #29
    11fe:	ea4f 0ac7 	mov.w	sl, r7, lsl #3
    1202:	9f06      	ldr	r7, [sp, #24]
    1204:	ea4a 7a57 	orr.w	sl, sl, r7, lsr #29
    1208:	9f16      	ldr	r7, [sp, #88]	; 0x58
    120a:	ea4f 48d7 	mov.w	r8, r7, lsr #19
    120e:	9f06      	ldr	r7, [sp, #24]
    1210:	ea48 3847 	orr.w	r8, r8, r7, lsl #13
    1214:	ea4f 49d7 	mov.w	r9, r7, lsr #19
    1218:	9f16      	ldr	r7, [sp, #88]	; 0x58
    121a:	ea8a 0808 	eor.w	r8, sl, r8
    121e:	ea49 3947 	orr.w	r9, r9, r7, lsl #13
    1222:	ea4f 1a97 	mov.w	sl, r7, lsr #6
    1226:	9f06      	ldr	r7, [sp, #24]
    1228:	ea4a 6a87 	orr.w	sl, sl, r7, lsl #26
    122c:	ea8e 0e09 	eor.w	lr, lr, r9
    1230:	ea88 080a 	eor.w	r8, r8, sl
    1234:	eb12 0208 	adds.w	r2, r2, r8
    1238:	ea8e 1e97 	eor.w	lr, lr, r7, lsr #6
    123c:	921c      	str	r2, [sp, #112]	; 0x70
    123e:	eb40 020e 	adc.w	r2, r0, lr
    1242:	920c      	str	r2, [sp, #48]	; 0x30
    1244:	9a31      	ldr	r2, [sp, #196]	; 0xc4
    1246:	1889      	adds	r1, r1, r2
    1248:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    124a:	eb46 060c 	adc.w	r6, r6, ip
    124e:	1889      	adds	r1, r1, r2
    1250:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    1252:	f8dd c088 	ldr.w	ip, [sp, #136]	; 0x88
    1256:	eb42 0606 	adc.w	r6, r2, r6
    125a:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    125c:	1852      	adds	r2, r2, r1
    125e:	922b      	str	r2, [sp, #172]	; 0xac
    1260:	9a24      	ldr	r2, [sp, #144]	; 0x90
    1262:	eb42 0206 	adc.w	r2, r2, r6
    1266:	922c      	str	r2, [sp, #176]	; 0xb0
    1268:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    126a:	0790      	lsls	r0, r2, #30
    126c:	9a22      	ldr	r2, [sp, #136]	; 0x88
    126e:	ea40 0092 	orr.w	r0, r0, r2, lsr #2
    1272:	ea4f 7e82 	mov.w	lr, r2, lsl #30
    1276:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    1278:	ea4e 0e92 	orr.w	lr, lr, r2, lsr #2
    127c:	9a22      	ldr	r2, [sp, #136]	; 0x88
    127e:	0f17      	lsrs	r7, r2, #28
    1280:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    1282:	ea47 1702 	orr.w	r7, r7, r2, lsl #4
    1286:	0f12      	lsrs	r2, r2, #28
    1288:	ea42 120c 	orr.w	r2, r2, ip, lsl #4
    128c:	4050      	eors	r0, r2
    128e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    1290:	0652      	lsls	r2, r2, #25
    1292:	ea42 12dc 	orr.w	r2, r2, ip, lsr #7
    1296:	ea8e 0e07 	eor.w	lr, lr, r7
    129a:	4667      	mov	r7, ip
    129c:	f8dd c0a0 	ldr.w	ip, [sp, #160]	; 0xa0
    12a0:	4050      	eors	r0, r2
    12a2:	067f      	lsls	r7, r7, #25
    12a4:	9a22      	ldr	r2, [sp, #136]	; 0x88
    12a6:	ea47 17dc 	orr.w	r7, r7, ip, lsr #7
    12aa:	ea8e 0e07 	eor.w	lr, lr, r7
    12ae:	ea4b 0c02 	orr.w	ip, fp, r2
    12b2:	e9dd 2727 	ldrd	r2, r7, [sp, #156]	; 0x9c
    12b6:	4317      	orrs	r7, r2
    12b8:	9a25      	ldr	r2, [sp, #148]	; 0x94
    12ba:	ea0c 0c02 	and.w	ip, ip, r2
    12be:	9a26      	ldr	r2, [sp, #152]	; 0x98
    12c0:	e9dd 8927 	ldrd	r8, r9, [sp, #156]	; 0x9c
    12c4:	4017      	ands	r7, r2
    12c6:	9a22      	ldr	r2, [sp, #136]	; 0x88
    12c8:	ea0b 0202 	and.w	r2, fp, r2
    12cc:	ea08 0809 	and.w	r8, r8, r9
    12d0:	ea4c 0202 	orr.w	r2, ip, r2
    12d4:	ea47 0808 	orr.w	r8, r7, r8
    12d8:	eb1e 0202 	adds.w	r2, lr, r2
    12dc:	eb40 0808 	adc.w	r8, r0, r8
    12e0:	1852      	adds	r2, r2, r1
    12e2:	9223      	str	r2, [sp, #140]	; 0x8c
    12e4:	eb46 0208 	adc.w	r2, r6, r8
    12e8:	9224      	str	r2, [sp, #144]	; 0x90
    12ea:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    12ec:	982b      	ldr	r0, [sp, #172]	; 0xac
    12ee:	0c97      	lsrs	r7, r2, #18
    12f0:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    12f2:	ea47 3782 	orr.w	r7, r7, r2, lsl #14
    12f6:	ea4f 4c92 	mov.w	ip, r2, lsr #18
    12fa:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    12fc:	ea4c 3c82 	orr.w	ip, ip, r2, lsl #14
    1300:	0b91      	lsrs	r1, r2, #14
    1302:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    1304:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
    1308:	0b92      	lsrs	r2, r2, #14
    130a:	ea42 4280 	orr.w	r2, r2, r0, lsl #18
    130e:	ea8c 0c02 	eor.w	ip, ip, r2
    1312:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    1314:	05d2      	lsls	r2, r2, #23
    1316:	ea42 2250 	orr.w	r2, r2, r0, lsr #9
    131a:	404f      	eors	r7, r1
    131c:	05c1      	lsls	r1, r0, #23
    131e:	982c      	ldr	r0, [sp, #176]	; 0xb0
    1320:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
    1324:	404f      	eors	r7, r1
    1326:	e9d3 1614 	ldrd	r1, r6, [r3, #80]	; 0x50
    132a:	ea8c 0c02 	eor.w	ip, ip, r2
    132e:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    1330:	9829      	ldr	r0, [sp, #164]	; 0xa4
    1332:	1851      	adds	r1, r2, r1
    1334:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    1336:	eb42 0906 	adc.w	r9, r2, r6
    133a:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
    133c:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
    133e:	4050      	eors	r0, r2
    1340:	9a30      	ldr	r2, [sp, #192]	; 0xc0
    1342:	4056      	eors	r6, r2
    1344:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    1346:	4010      	ands	r0, r2
    1348:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    134a:	4016      	ands	r6, r2
    134c:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
    134e:	4050      	eors	r0, r2
    1350:	9a30      	ldr	r2, [sp, #192]	; 0xc0
    1352:	1809      	adds	r1, r1, r0
    1354:	ea86 0202 	eor.w	r2, r6, r2
    1358:	eb49 0602 	adc.w	r6, r9, r2
    135c:	9a01      	ldr	r2, [sp, #4]
    135e:	912d      	str	r1, [sp, #180]	; 0xb4
    1360:	2a00      	cmp	r2, #0
    1362:	f000 860a 	beq.w	1f7a <_Transform_Sha512+0x1f7a>
    1366:	9a1e      	ldr	r2, [sp, #120]	; 0x78
    1368:	990e      	ldr	r1, [sp, #56]	; 0x38
    136a:	ea4f 2812 	mov.w	r8, r2, lsr #8
    136e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    1370:	ea48 6802 	orr.w	r8, r8, r2, lsl #24
    1374:	ea4f 2e12 	mov.w	lr, r2, lsr #8
    1378:	9a1e      	ldr	r2, [sp, #120]	; 0x78
    137a:	ea4e 6e02 	orr.w	lr, lr, r2, lsl #24
    137e:	0852      	lsrs	r2, r2, #1
    1380:	ea42 72c1 	orr.w	r2, r2, r1, lsl #31
    1384:	0848      	lsrs	r0, r1, #1
    1386:	991e      	ldr	r1, [sp, #120]	; 0x78
    1388:	ea88 0202 	eor.w	r2, r8, r2
    138c:	ea40 70c1 	orr.w	r0, r0, r1, lsl #31
    1390:	ea4f 18d1 	mov.w	r8, r1, lsr #7
    1394:	990e      	ldr	r1, [sp, #56]	; 0x38
    1396:	ea8e 0000 	eor.w	r0, lr, r0
    139a:	ea48 6841 	orr.w	r8, r8, r1, lsl #25
    139e:	ea80 10d1 	eor.w	r0, r0, r1, lsr #7
    13a2:	991d      	ldr	r1, [sp, #116]	; 0x74
    13a4:	ea82 0208 	eor.w	r2, r2, r8
    13a8:	1852      	adds	r2, r2, r1
    13aa:	990d      	ldr	r1, [sp, #52]	; 0x34
    13ac:	eb41 0000 	adc.w	r0, r1, r0
    13b0:	9912      	ldr	r1, [sp, #72]	; 0x48
    13b2:	1852      	adds	r2, r2, r1
    13b4:	9902      	ldr	r1, [sp, #8]
    13b6:	eb41 0000 	adc.w	r0, r1, r0
    13ba:	990b      	ldr	r1, [sp, #44]	; 0x2c
    13bc:	ea4f 0ec1 	mov.w	lr, r1, lsl #3
    13c0:	991b      	ldr	r1, [sp, #108]	; 0x6c
    13c2:	ea4e 7e51 	orr.w	lr, lr, r1, lsr #29
    13c6:	ea4f 0ac1 	mov.w	sl, r1, lsl #3
    13ca:	990b      	ldr	r1, [sp, #44]	; 0x2c
    13cc:	ea4a 7a51 	orr.w	sl, sl, r1, lsr #29
    13d0:	991b      	ldr	r1, [sp, #108]	; 0x6c
    13d2:	ea4f 48d1 	mov.w	r8, r1, lsr #19
    13d6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    13d8:	ea48 3841 	orr.w	r8, r8, r1, lsl #13
    13dc:	ea4f 49d1 	mov.w	r9, r1, lsr #19
    13e0:	991b      	ldr	r1, [sp, #108]	; 0x6c
    13e2:	ea8a 0808 	eor.w	r8, sl, r8
    13e6:	ea49 3941 	orr.w	r9, r9, r1, lsl #13
    13ea:	ea4f 1a91 	mov.w	sl, r1, lsr #6
    13ee:	990b      	ldr	r1, [sp, #44]	; 0x2c
    13f0:	ea4a 6a81 	orr.w	sl, sl, r1, lsl #26
    13f4:	ea8e 0e09 	eor.w	lr, lr, r9
    13f8:	ea88 080a 	eor.w	r8, r8, sl
    13fc:	eb12 0208 	adds.w	r2, r2, r8
    1400:	ea8e 1e91 	eor.w	lr, lr, r1, lsr #6
    1404:	921d      	str	r2, [sp, #116]	; 0x74
    1406:	eb40 020e 	adc.w	r2, r0, lr
    140a:	920d      	str	r2, [sp, #52]	; 0x34
    140c:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    140e:	19d1      	adds	r1, r2, r7
    1410:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    1412:	9f23      	ldr	r7, [sp, #140]	; 0x8c
    1414:	eb46 060c 	adc.w	r6, r6, ip
    1418:	1889      	adds	r1, r1, r2
    141a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    141c:	f8dd c090 	ldr.w	ip, [sp, #144]	; 0x90
    1420:	eb42 0606 	adc.w	r6, r2, r6
    1424:	9a25      	ldr	r2, [sp, #148]	; 0x94
    1426:	1852      	adds	r2, r2, r1
    1428:	922d      	str	r2, [sp, #180]	; 0xb4
    142a:	9a26      	ldr	r2, [sp, #152]	; 0x98
    142c:	eb42 0206 	adc.w	r2, r2, r6
    1430:	922e      	str	r2, [sp, #184]	; 0xb8
    1432:	9a24      	ldr	r2, [sp, #144]	; 0x90
    1434:	ea4f 7e82 	mov.w	lr, r2, lsl #30
    1438:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    143a:	ea4e 0e92 	orr.w	lr, lr, r2, lsr #2
    143e:	ea4f 7882 	mov.w	r8, r2, lsl #30
    1442:	9a24      	ldr	r2, [sp, #144]	; 0x90
    1444:	ea48 0892 	orr.w	r8, r8, r2, lsr #2
    1448:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    144a:	0f10      	lsrs	r0, r2, #28
    144c:	9a24      	ldr	r2, [sp, #144]	; 0x90
    144e:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
    1452:	0f12      	lsrs	r2, r2, #28
    1454:	ea42 1207 	orr.w	r2, r2, r7, lsl #4
    1458:	ea8e 0e02 	eor.w	lr, lr, r2
    145c:	9a24      	ldr	r2, [sp, #144]	; 0x90
    145e:	0652      	lsls	r2, r2, #25
    1460:	ea42 12d7 	orr.w	r2, r2, r7, lsr #7
    1464:	ea88 0800 	eor.w	r8, r8, r0
    1468:	0678      	lsls	r0, r7, #25
    146a:	9f24      	ldr	r7, [sp, #144]	; 0x90
    146c:	ea40 10d7 	orr.w	r0, r0, r7, lsr #7
    1470:	ea8e 0e02 	eor.w	lr, lr, r2
    1474:	ea88 0800 	eor.w	r8, r8, r0
    1478:	e9dd 2022 	ldrd	r2, r0, [sp, #136]	; 0x88
    147c:	4310      	orrs	r0, r2
    147e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    1480:	ea42 0907 	orr.w	r9, r2, r7
    1484:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    1486:	ea09 0902 	and.w	r9, r9, r2
    148a:	e9dd 2722 	ldrd	r2, r7, [sp, #136]	; 0x88
    148e:	403a      	ands	r2, r7
    1490:	9f28      	ldr	r7, [sp, #160]	; 0xa0
    1492:	ea00 000b 	and.w	r0, r0, fp
    1496:	4310      	orrs	r0, r2
    1498:	ea07 070c 	and.w	r7, r7, ip
    149c:	eb18 0000 	adds.w	r0, r8, r0
    14a0:	ea49 0707 	orr.w	r7, r9, r7
    14a4:	eb4e 0707 	adc.w	r7, lr, r7
    14a8:	1842      	adds	r2, r0, r1
    14aa:	9225      	str	r2, [sp, #148]	; 0x94
    14ac:	eb46 0207 	adc.w	r2, r6, r7
    14b0:	9226      	str	r2, [sp, #152]	; 0x98
    14b2:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    14b4:	982d      	ldr	r0, [sp, #180]	; 0xb4
    14b6:	ea4f 4992 	mov.w	r9, r2, lsr #18
    14ba:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    14bc:	ea49 3982 	orr.w	r9, r9, r2, lsl #14
    14c0:	ea4f 4e92 	mov.w	lr, r2, lsr #18
    14c4:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    14c6:	ea4e 3e82 	orr.w	lr, lr, r2, lsl #14
    14ca:	0b91      	lsrs	r1, r2, #14
    14cc:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    14ce:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
    14d2:	0b92      	lsrs	r2, r2, #14
    14d4:	ea42 4280 	orr.w	r2, r2, r0, lsl #18
    14d8:	ea8e 0e02 	eor.w	lr, lr, r2
    14dc:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    14de:	05d2      	lsls	r2, r2, #23
    14e0:	ea42 2250 	orr.w	r2, r2, r0, lsr #9
    14e4:	ea89 0901 	eor.w	r9, r9, r1
    14e8:	05c1      	lsls	r1, r0, #23
    14ea:	982e      	ldr	r0, [sp, #184]	; 0xb8
    14ec:	9f2f      	ldr	r7, [sp, #188]	; 0xbc
    14ee:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
    14f2:	ea89 0901 	eor.w	r9, r9, r1
    14f6:	ea8e 0e02 	eor.w	lr, lr, r2
    14fa:	992b      	ldr	r1, [sp, #172]	; 0xac
    14fc:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    14fe:	982c      	ldr	r0, [sp, #176]	; 0xb0
    1500:	404a      	eors	r2, r1
    1502:	992a      	ldr	r1, [sp, #168]	; 0xa8
    1504:	ea81 0600 	eor.w	r6, r1, r0
    1508:	992d      	ldr	r1, [sp, #180]	; 0xb4
    150a:	400a      	ands	r2, r1
    150c:	992e      	ldr	r1, [sp, #184]	; 0xb8
    150e:	400e      	ands	r6, r1
    1510:	9929      	ldr	r1, [sp, #164]	; 0xa4
    1512:	404a      	eors	r2, r1
    1514:	992a      	ldr	r1, [sp, #168]	; 0xa8
    1516:	404e      	eors	r6, r1
    1518:	e9d3 1016 	ldrd	r1, r0, [r3, #88]	; 0x58
    151c:	1879      	adds	r1, r7, r1
    151e:	9f30      	ldr	r7, [sp, #192]	; 0xc0
    1520:	eb47 0000 	adc.w	r0, r7, r0
    1524:	1852      	adds	r2, r2, r1
    1526:	9901      	ldr	r1, [sp, #4]
    1528:	922f      	str	r2, [sp, #188]	; 0xbc
    152a:	eb46 0600 	adc.w	r6, r6, r0
    152e:	2900      	cmp	r1, #0
    1530:	f000 852a 	beq.w	1f88 <_Transform_Sha512+0x1f88>
    1534:	9913      	ldr	r1, [sp, #76]	; 0x4c
    1536:	9803      	ldr	r0, [sp, #12]
    1538:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
    153c:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    153e:	ea4f 2c11 	mov.w	ip, r1, lsr #8
    1542:	9903      	ldr	r1, [sp, #12]
    1544:	ea4c 6c01 	orr.w	ip, ip, r1, lsl #24
    1548:	0a0f      	lsrs	r7, r1, #8
    154a:	9913      	ldr	r1, [sp, #76]	; 0x4c
    154c:	ea47 6701 	orr.w	r7, r7, r1, lsl #24
    1550:	0849      	lsrs	r1, r1, #1
    1552:	ea41 71c0 	orr.w	r1, r1, r0, lsl #31
    1556:	0840      	lsrs	r0, r0, #1
    1558:	ea40 70c8 	orr.w	r0, r0, r8, lsl #31
    155c:	4078      	eors	r0, r7
    155e:	9f03      	ldr	r7, [sp, #12]
    1560:	ea8c 0101 	eor.w	r1, ip, r1
    1564:	ea4f 1cd8 	mov.w	ip, r8, lsr #7
    1568:	ea4c 6c47 	orr.w	ip, ip, r7, lsl #25
    156c:	ea80 10d7 	eor.w	r0, r0, r7, lsr #7
    1570:	9f1e      	ldr	r7, [sp, #120]	; 0x78
    1572:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    1576:	ea81 010c 	eor.w	r1, r1, ip
    157a:	19c9      	adds	r1, r1, r7
    157c:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    157e:	f8dd c070 	ldr.w	ip, [sp, #112]	; 0x70
    1582:	eb47 0000 	adc.w	r0, r7, r0
    1586:	9f1a      	ldr	r7, [sp, #104]	; 0x68
    1588:	19c9      	adds	r1, r1, r7
    158a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    158c:	eb47 0000 	adc.w	r0, r7, r0
    1590:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    1592:	00ff      	lsls	r7, r7, #3
    1594:	ea47 775c 	orr.w	r7, r7, ip, lsr #29
    1598:	ea4f 0acc 	mov.w	sl, ip, lsl #3
    159c:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
    15a0:	ea4a 7a5c 	orr.w	sl, sl, ip, lsr #29
    15a4:	f8dd c070 	ldr.w	ip, [sp, #112]	; 0x70
    15a8:	ea4f 4cdc 	mov.w	ip, ip, lsr #19
    15ac:	ea4c 3c48 	orr.w	ip, ip, r8, lsl #13
    15b0:	ea4f 48d8 	mov.w	r8, r8, lsr #19
    15b4:	ea48 3842 	orr.w	r8, r8, r2, lsl #13
    15b8:	ea8a 0c0c 	eor.w	ip, sl, ip
    15bc:	ea4f 1a92 	mov.w	sl, r2, lsr #6
    15c0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    15c2:	ea4a 6a82 	orr.w	sl, sl, r2, lsl #26
    15c6:	ea87 0708 	eor.w	r7, r7, r8
    15ca:	ea8c 0c0a 	eor.w	ip, ip, sl
    15ce:	ea87 1792 	eor.w	r7, r7, r2, lsr #6
    15d2:	eb11 020c 	adds.w	r2, r1, ip
    15d6:	eb40 0107 	adc.w	r1, r0, r7
    15da:	921e      	str	r2, [sp, #120]	; 0x78
    15dc:	910e      	str	r1, [sp, #56]	; 0x38
    15de:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
    15e0:	991e      	ldr	r1, [sp, #120]	; 0x78
    15e2:	eb19 0202 	adds.w	r2, r9, r2
    15e6:	eb4e 0e06 	adc.w	lr, lr, r6
    15ea:	1852      	adds	r2, r2, r1
    15ec:	990e      	ldr	r1, [sp, #56]	; 0x38
    15ee:	9e25      	ldr	r6, [sp, #148]	; 0x94
    15f0:	f8dd 9098 	ldr.w	r9, [sp, #152]	; 0x98
    15f4:	eb41 0e0e 	adc.w	lr, r1, lr
    15f8:	eb1b 0102 	adds.w	r1, fp, r2
    15fc:	912f      	str	r1, [sp, #188]	; 0xbc
    15fe:	9927      	ldr	r1, [sp, #156]	; 0x9c
    1600:	eb41 010e 	adc.w	r1, r1, lr
    1604:	9131      	str	r1, [sp, #196]	; 0xc4
    1606:	9926      	ldr	r1, [sp, #152]	; 0x98
    1608:	078f      	lsls	r7, r1, #30
    160a:	9925      	ldr	r1, [sp, #148]	; 0x94
    160c:	ea47 0791 	orr.w	r7, r7, r1, lsr #2
    1610:	ea4f 7c81 	mov.w	ip, r1, lsl #30
    1614:	9926      	ldr	r1, [sp, #152]	; 0x98
    1616:	ea4c 0c91 	orr.w	ip, ip, r1, lsr #2
    161a:	9925      	ldr	r1, [sp, #148]	; 0x94
    161c:	0f08      	lsrs	r0, r1, #28
    161e:	9926      	ldr	r1, [sp, #152]	; 0x98
    1620:	ea40 1001 	orr.w	r0, r0, r1, lsl #4
    1624:	0f09      	lsrs	r1, r1, #28
    1626:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
    162a:	404f      	eors	r7, r1
    162c:	9926      	ldr	r1, [sp, #152]	; 0x98
    162e:	0649      	lsls	r1, r1, #25
    1630:	ea41 11d6 	orr.w	r1, r1, r6, lsr #7
    1634:	ea8c 0c00 	eor.w	ip, ip, r0
    1638:	0670      	lsls	r0, r6, #25
    163a:	9e26      	ldr	r6, [sp, #152]	; 0x98
    163c:	ea40 10d6 	orr.w	r0, r0, r6, lsr #7
    1640:	ea8c 0c00 	eor.w	ip, ip, r0
    1644:	404f      	eors	r7, r1
    1646:	9825      	ldr	r0, [sp, #148]	; 0x94
    1648:	9923      	ldr	r1, [sp, #140]	; 0x8c
    164a:	4308      	orrs	r0, r1
    164c:	9924      	ldr	r1, [sp, #144]	; 0x90
    164e:	ea41 0806 	orr.w	r8, r1, r6
    1652:	9922      	ldr	r1, [sp, #136]	; 0x88
    1654:	9e25      	ldr	r6, [sp, #148]	; 0x94
    1656:	4008      	ands	r0, r1
    1658:	9928      	ldr	r1, [sp, #160]	; 0xa0
    165a:	ea08 0801 	and.w	r8, r8, r1
    165e:	9923      	ldr	r1, [sp, #140]	; 0x8c
    1660:	4031      	ands	r1, r6
    1662:	9e24      	ldr	r6, [sp, #144]	; 0x90
    1664:	4308      	orrs	r0, r1
    1666:	ea06 0609 	and.w	r6, r6, r9
    166a:	eb1c 0000 	adds.w	r0, ip, r0
    166e:	ea48 0606 	orr.w	r6, r8, r6
    1672:	eb47 0606 	adc.w	r6, r7, r6
    1676:	1882      	adds	r2, r0, r2
    1678:	9227      	str	r2, [sp, #156]	; 0x9c
    167a:	eb4e 0206 	adc.w	r2, lr, r6
    167e:	9230      	str	r2, [sp, #192]	; 0xc0
    1680:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
    1682:	982f      	ldr	r0, [sp, #188]	; 0xbc
    1684:	ea4f 4a92 	mov.w	sl, r2, lsr #18
    1688:	9a31      	ldr	r2, [sp, #196]	; 0xc4
    168a:	ea4a 3a82 	orr.w	sl, sl, r2, lsl #14
    168e:	ea4f 4992 	mov.w	r9, r2, lsr #18
    1692:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
    1694:	ea49 3982 	orr.w	r9, r9, r2, lsl #14
    1698:	0b91      	lsrs	r1, r2, #14
    169a:	9a31      	ldr	r2, [sp, #196]	; 0xc4
    169c:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
    16a0:	0b92      	lsrs	r2, r2, #14
    16a2:	ea42 4280 	orr.w	r2, r2, r0, lsl #18
        R(12); R(13); R(14); R(15);
    16a6:	ea89 0902 	eor.w	r9, r9, r2
    16aa:	9a31      	ldr	r2, [sp, #196]	; 0xc4
    16ac:	05d2      	lsls	r2, r2, #23
    16ae:	ea42 2250 	orr.w	r2, r2, r0, lsr #9
    16b2:	ea8a 0a01 	eor.w	sl, sl, r1
    16b6:	05c1      	lsls	r1, r0, #23
    16b8:	9831      	ldr	r0, [sp, #196]	; 0xc4
    16ba:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
    16be:	ea8a 0a01 	eor.w	sl, sl, r1
    16c2:	ea89 0902 	eor.w	r9, r9, r2
    16c6:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    16c8:	992d      	ldr	r1, [sp, #180]	; 0xb4
    16ca:	982e      	ldr	r0, [sp, #184]	; 0xb8
    16cc:	9e29      	ldr	r6, [sp, #164]	; 0xa4
    16ce:	404a      	eors	r2, r1
    16d0:	992c      	ldr	r1, [sp, #176]	; 0xb0
    16d2:	ea81 0800 	eor.w	r8, r1, r0
    16d6:	992f      	ldr	r1, [sp, #188]	; 0xbc
    16d8:	400a      	ands	r2, r1
    16da:	9931      	ldr	r1, [sp, #196]	; 0xc4
    16dc:	ea08 0801 	and.w	r8, r8, r1
    16e0:	992b      	ldr	r1, [sp, #172]	; 0xac
    16e2:	404a      	eors	r2, r1
    16e4:	992c      	ldr	r1, [sp, #176]	; 0xb0
    16e6:	ea88 0801 	eor.w	r8, r8, r1
    16ea:	e9d3 1018 	ldrd	r1, r0, [r3, #96]	; 0x60
    16ee:	1871      	adds	r1, r6, r1
    16f0:	9e2a      	ldr	r6, [sp, #168]	; 0xa8
    16f2:	eb46 0000 	adc.w	r0, r6, r0
    16f6:	1852      	adds	r2, r2, r1
    16f8:	9901      	ldr	r1, [sp, #4]
    16fa:	eb48 0800 	adc.w	r8, r8, r0
    16fe:	2900      	cmp	r1, #0
    1700:	f000 844a 	beq.w	1f98 <_Transform_Sha512+0x1f98>
    1704:	991f      	ldr	r1, [sp, #124]	; 0x7c
    1706:	980f      	ldr	r0, [sp, #60]	; 0x3c
    1708:	f8dd c07c 	ldr.w	ip, [sp, #124]	; 0x7c
    170c:	f8dd b074 	ldr.w	fp, [sp, #116]	; 0x74
    1710:	0a0f      	lsrs	r7, r1, #8
    1712:	990f      	ldr	r1, [sp, #60]	; 0x3c
    1714:	ea47 6701 	orr.w	r7, r7, r1, lsl #24
    1718:	0a0e      	lsrs	r6, r1, #8
    171a:	991f      	ldr	r1, [sp, #124]	; 0x7c
    171c:	ea46 6601 	orr.w	r6, r6, r1, lsl #24
    1720:	0849      	lsrs	r1, r1, #1
    1722:	ea41 71c0 	orr.w	r1, r1, r0, lsl #31
    1726:	0840      	lsrs	r0, r0, #1
    1728:	ea40 70cc 	orr.w	r0, r0, ip, lsl #31
    172c:	4070      	eors	r0, r6
    172e:	4666      	mov	r6, ip
    1730:	4079      	eors	r1, r7
    1732:	09f7      	lsrs	r7, r6, #7
    1734:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    1736:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
    173a:	ea47 6746 	orr.w	r7, r7, r6, lsl #25
    173e:	ea80 10d6 	eor.w	r0, r0, r6, lsr #7
    1742:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    1744:	4079      	eors	r1, r7
    1746:	1989      	adds	r1, r1, r6
    1748:	9e03      	ldr	r6, [sp, #12]
    174a:	9f1d      	ldr	r7, [sp, #116]	; 0x74
    174c:	eb46 0000 	adc.w	r0, r6, r0
    1750:	9e14      	ldr	r6, [sp, #80]	; 0x50
    1752:	1989      	adds	r1, r1, r6
    1754:	9e04      	ldr	r6, [sp, #16]
    1756:	eb46 0000 	adc.w	r0, r6, r0
    175a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    175c:	00f6      	lsls	r6, r6, #3
    175e:	ea46 7657 	orr.w	r6, r6, r7, lsr #29
    1762:	ea4f 0ec7 	mov.w	lr, r7, lsl #3
    1766:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    1768:	ea4e 7e57 	orr.w	lr, lr, r7, lsr #29
    176c:	9f1d      	ldr	r7, [sp, #116]	; 0x74
    176e:	0cff      	lsrs	r7, r7, #19
    1770:	ea47 374c 	orr.w	r7, r7, ip, lsl #13
    1774:	ea4f 4cdc 	mov.w	ip, ip, lsr #19
    1778:	ea4c 3c4b 	orr.w	ip, ip, fp, lsl #13
    177c:	ea86 060c 	eor.w	r6, r6, ip
    1780:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
    1784:	ea8e 0707 	eor.w	r7, lr, r7
    1788:	ea4f 1e9b 	mov.w	lr, fp, lsr #6
    178c:	ea4e 6e8c 	orr.w	lr, lr, ip, lsl #26
    1790:	ea87 070e 	eor.w	r7, r7, lr
    1794:	19c9      	adds	r1, r1, r7
    1796:	ea86 169c 	eor.w	r6, r6, ip, lsr #6
    179a:	9113      	str	r1, [sp, #76]	; 0x4c
    179c:	eb40 0106 	adc.w	r1, r0, r6
    17a0:	9103      	str	r1, [sp, #12]
    17a2:	9913      	ldr	r1, [sp, #76]	; 0x4c
    17a4:	f8dd c09c 	ldr.w	ip, [sp, #156]	; 0x9c
    17a8:	eb1a 0202 	adds.w	r2, sl, r2
    17ac:	eb49 0908 	adc.w	r9, r9, r8
    17b0:	1852      	adds	r2, r2, r1
    17b2:	9903      	ldr	r1, [sp, #12]
    17b4:	f8dd 80c0 	ldr.w	r8, [sp, #192]	; 0xc0
    17b8:	eb41 0909 	adc.w	r9, r1, r9
    17bc:	9922      	ldr	r1, [sp, #136]	; 0x88
    17be:	1889      	adds	r1, r1, r2
    17c0:	9129      	str	r1, [sp, #164]	; 0xa4
    17c2:	9928      	ldr	r1, [sp, #160]	; 0xa0
    17c4:	eb41 0109 	adc.w	r1, r1, r9
    17c8:	912a      	str	r1, [sp, #168]	; 0xa8
    17ca:	9930      	ldr	r1, [sp, #192]	; 0xc0
    17cc:	078e      	lsls	r6, r1, #30
    17ce:	9927      	ldr	r1, [sp, #156]	; 0x9c
    17d0:	ea46 0691 	orr.w	r6, r6, r1, lsr #2
    17d4:	078f      	lsls	r7, r1, #30
    17d6:	9930      	ldr	r1, [sp, #192]	; 0xc0
    17d8:	ea47 0791 	orr.w	r7, r7, r1, lsr #2
    17dc:	9927      	ldr	r1, [sp, #156]	; 0x9c
    17de:	0f08      	lsrs	r0, r1, #28
    17e0:	9930      	ldr	r1, [sp, #192]	; 0xc0
    17e2:	ea40 1001 	orr.w	r0, r0, r1, lsl #4
    17e6:	0f09      	lsrs	r1, r1, #28
    17e8:	ea41 110c 	orr.w	r1, r1, ip, lsl #4
    17ec:	404e      	eors	r6, r1
    17ee:	9930      	ldr	r1, [sp, #192]	; 0xc0
    17f0:	ea4f 6c41 	mov.w	ip, r1, lsl #25
    17f4:	9927      	ldr	r1, [sp, #156]	; 0x9c
    17f6:	4047      	eors	r7, r0
    17f8:	9830      	ldr	r0, [sp, #192]	; 0xc0
    17fa:	ea4c 1cd1 	orr.w	ip, ip, r1, lsr #7
    17fe:	0649      	lsls	r1, r1, #25
    1800:	ea41 11d0 	orr.w	r1, r1, r0, lsr #7
    1804:	404f      	eors	r7, r1
    1806:	9827      	ldr	r0, [sp, #156]	; 0x9c
    1808:	9925      	ldr	r1, [sp, #148]	; 0x94
    180a:	ea86 060c 	eor.w	r6, r6, ip
    180e:	4301      	orrs	r1, r0
    1810:	f8dd c0c0 	ldr.w	ip, [sp, #192]	; 0xc0
    1814:	9826      	ldr	r0, [sp, #152]	; 0x98
    1816:	ea40 0e0c 	orr.w	lr, r0, ip
    181a:	9823      	ldr	r0, [sp, #140]	; 0x8c
    181c:	f8dd c09c 	ldr.w	ip, [sp, #156]	; 0x9c
    1820:	4001      	ands	r1, r0
    1822:	9824      	ldr	r0, [sp, #144]	; 0x90
    1824:	ea0e 0e00 	and.w	lr, lr, r0
    1828:	9825      	ldr	r0, [sp, #148]	; 0x94
    182a:	ea00 000c 	and.w	r0, r0, ip
    182e:	f8dd c098 	ldr.w	ip, [sp, #152]	; 0x98
    1832:	4301      	orrs	r1, r0
    1834:	ea0c 0c08 	and.w	ip, ip, r8
    1838:	1879      	adds	r1, r7, r1
    183a:	ea4e 0c0c 	orr.w	ip, lr, ip
    183e:	eb46 0c0c 	adc.w	ip, r6, ip
    1842:	188a      	adds	r2, r1, r2
    1844:	9222      	str	r2, [sp, #136]	; 0x88
    1846:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    1848:	9829      	ldr	r0, [sp, #164]	; 0xa4
    184a:	ea4f 4a92 	mov.w	sl, r2, lsr #18
    184e:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
    1850:	eb49 0b0c 	adc.w	fp, r9, ip
    1854:	ea4a 3a82 	orr.w	sl, sl, r2, lsl #14
    1858:	ea4f 4992 	mov.w	r9, r2, lsr #18
    185c:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    185e:	ea49 3982 	orr.w	r9, r9, r2, lsl #14
    1862:	0b91      	lsrs	r1, r2, #14
    1864:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
    1866:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
    186a:	0b92      	lsrs	r2, r2, #14
    186c:	ea42 4280 	orr.w	r2, r2, r0, lsl #18
    1870:	ea89 0902 	eor.w	r9, r9, r2
    1874:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
    1876:	9e2b      	ldr	r6, [sp, #172]	; 0xac
    1878:	05d2      	lsls	r2, r2, #23
    187a:	ea42 2250 	orr.w	r2, r2, r0, lsr #9
    187e:	ea8a 0a01 	eor.w	sl, sl, r1
    1882:	05c1      	lsls	r1, r0, #23
    1884:	982a      	ldr	r0, [sp, #168]	; 0xa8
    1886:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
    188a:	ea8a 0a01 	eor.w	sl, sl, r1
    188e:	ea89 0902 	eor.w	r9, r9, r2
    1892:	992f      	ldr	r1, [sp, #188]	; 0xbc
    1894:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    1896:	9831      	ldr	r0, [sp, #196]	; 0xc4
    1898:	404a      	eors	r2, r1
    189a:	992e      	ldr	r1, [sp, #184]	; 0xb8
    189c:	ea81 0800 	eor.w	r8, r1, r0
    18a0:	9929      	ldr	r1, [sp, #164]	; 0xa4
    18a2:	400a      	ands	r2, r1
    18a4:	992a      	ldr	r1, [sp, #168]	; 0xa8
    18a6:	ea08 0801 	and.w	r8, r8, r1
    18aa:	992d      	ldr	r1, [sp, #180]	; 0xb4
    18ac:	404a      	eors	r2, r1
    18ae:	992e      	ldr	r1, [sp, #184]	; 0xb8
    18b0:	ea88 0801 	eor.w	r8, r8, r1
    18b4:	e9d3 101a 	ldrd	r1, r0, [r3, #104]	; 0x68
    18b8:	1871      	adds	r1, r6, r1
    18ba:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
    18bc:	eb46 0000 	adc.w	r0, r6, r0
    18c0:	1852      	adds	r2, r2, r1
    18c2:	9901      	ldr	r1, [sp, #4]
    18c4:	9228      	str	r2, [sp, #160]	; 0xa0
    18c6:	eb48 0800 	adc.w	r8, r8, r0
    18ca:	2900      	cmp	r1, #0
    18cc:	f000 836b 	beq.w	1fa6 <_Transform_Sha512+0x1fa6>
    18d0:	9920      	ldr	r1, [sp, #128]	; 0x80
    18d2:	9810      	ldr	r0, [sp, #64]	; 0x40
    18d4:	f8dd c080 	ldr.w	ip, [sp, #128]	; 0x80
    18d8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
    18da:	0a0f      	lsrs	r7, r1, #8
    18dc:	9910      	ldr	r1, [sp, #64]	; 0x40
    18de:	ea47 6701 	orr.w	r7, r7, r1, lsl #24
    18e2:	0a0e      	lsrs	r6, r1, #8
    18e4:	9920      	ldr	r1, [sp, #128]	; 0x80
    18e6:	ea46 6601 	orr.w	r6, r6, r1, lsl #24
    18ea:	0849      	lsrs	r1, r1, #1
    18ec:	ea41 71c0 	orr.w	r1, r1, r0, lsl #31
    18f0:	0840      	lsrs	r0, r0, #1
    18f2:	ea40 70cc 	orr.w	r0, r0, ip, lsl #31
    18f6:	4070      	eors	r0, r6
    18f8:	4666      	mov	r6, ip
    18fa:	4079      	eors	r1, r7
    18fc:	09f7      	lsrs	r7, r6, #7
    18fe:	9e10      	ldr	r6, [sp, #64]	; 0x40
    1900:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
    1904:	ea47 6746 	orr.w	r7, r7, r6, lsl #25
    1908:	ea80 10d6 	eor.w	r0, r0, r6, lsr #7
    190c:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
    190e:	4079      	eors	r1, r7
    1910:	1989      	adds	r1, r1, r6
    1912:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    1914:	9f1e      	ldr	r7, [sp, #120]	; 0x78
    1916:	eb46 0000 	adc.w	r0, r6, r0
    191a:	9e15      	ldr	r6, [sp, #84]	; 0x54
    191c:	1989      	adds	r1, r1, r6
    191e:	9e05      	ldr	r6, [sp, #20]
    1920:	eb46 0000 	adc.w	r0, r6, r0
    1924:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    1926:	00f6      	lsls	r6, r6, #3
    1928:	ea46 7657 	orr.w	r6, r6, r7, lsr #29
    192c:	ea4f 0ec7 	mov.w	lr, r7, lsl #3
    1930:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    1932:	ea4e 7e57 	orr.w	lr, lr, r7, lsr #29
    1936:	9f1e      	ldr	r7, [sp, #120]	; 0x78
    1938:	0cff      	lsrs	r7, r7, #19
    193a:	ea47 374c 	orr.w	r7, r7, ip, lsl #13
    193e:	ea4f 4cdc 	mov.w	ip, ip, lsr #19
    1942:	ea4c 3c42 	orr.w	ip, ip, r2, lsl #13
    1946:	ea8e 0707 	eor.w	r7, lr, r7
    194a:	ea4f 1e92 	mov.w	lr, r2, lsr #6
    194e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    1950:	ea4e 6e82 	orr.w	lr, lr, r2, lsl #26
    1954:	ea86 060c 	eor.w	r6, r6, ip
    1958:	ea87 070e 	eor.w	r7, r7, lr
    195c:	19c9      	adds	r1, r1, r7
    195e:	ea86 1692 	eor.w	r6, r6, r2, lsr #6
    1962:	911f      	str	r1, [sp, #124]	; 0x7c
    1964:	eb40 0106 	adc.w	r1, r0, r6
    1968:	910f      	str	r1, [sp, #60]	; 0x3c
    196a:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    196c:	991f      	ldr	r1, [sp, #124]	; 0x7c
    196e:	f8dd c088 	ldr.w	ip, [sp, #136]	; 0x88
    1972:	eb1a 0202 	adds.w	r2, sl, r2
    1976:	eb49 0908 	adc.w	r9, r9, r8
    197a:	1852      	adds	r2, r2, r1
    197c:	990f      	ldr	r1, [sp, #60]	; 0x3c
    197e:	eb41 0909 	adc.w	r9, r1, r9
    1982:	9923      	ldr	r1, [sp, #140]	; 0x8c
    1984:	1889      	adds	r1, r1, r2
    1986:	912b      	str	r1, [sp, #172]	; 0xac
    1988:	9924      	ldr	r1, [sp, #144]	; 0x90
    198a:	eb41 0109 	adc.w	r1, r1, r9
    198e:	912c      	str	r1, [sp, #176]	; 0xb0
    1990:	9922      	ldr	r1, [sp, #136]	; 0x88
    1992:	ea4f 768b 	mov.w	r6, fp, lsl #30
    1996:	ea46 0691 	orr.w	r6, r6, r1, lsr #2
    199a:	078f      	lsls	r7, r1, #30
    199c:	0f08      	lsrs	r0, r1, #28
    199e:	ea4f 711b 	mov.w	r1, fp, lsr #28
    19a2:	ea41 110c 	orr.w	r1, r1, ip, lsl #4
    19a6:	404e      	eors	r6, r1
    19a8:	9922      	ldr	r1, [sp, #136]	; 0x88
    19aa:	ea4f 6c4b 	mov.w	ip, fp, lsl #25
    19ae:	ea4c 1cd1 	orr.w	ip, ip, r1, lsr #7
    19b2:	ea40 100b 	orr.w	r0, r0, fp, lsl #4
    19b6:	ea47 079b 	orr.w	r7, r7, fp, lsr #2
    19ba:	0649      	lsls	r1, r1, #25
    19bc:	4047      	eors	r7, r0
    19be:	ea41 11db 	orr.w	r1, r1, fp, lsr #7
    19c2:	9822      	ldr	r0, [sp, #136]	; 0x88
    19c4:	404f      	eors	r7, r1
    19c6:	9927      	ldr	r1, [sp, #156]	; 0x9c
    19c8:	4301      	orrs	r1, r0
    19ca:	9830      	ldr	r0, [sp, #192]	; 0xc0
    19cc:	ea40 0e0b 	orr.w	lr, r0, fp
    19d0:	9825      	ldr	r0, [sp, #148]	; 0x94
    19d2:	4001      	ands	r1, r0
    19d4:	9826      	ldr	r0, [sp, #152]	; 0x98
    19d6:	ea86 060c 	eor.w	r6, r6, ip
    19da:	ea0e 0e00 	and.w	lr, lr, r0
    19de:	f8dd c088 	ldr.w	ip, [sp, #136]	; 0x88
    19e2:	9827      	ldr	r0, [sp, #156]	; 0x9c
    19e4:	ea00 000c 	and.w	r0, r0, ip
    19e8:	f8dd c0c0 	ldr.w	ip, [sp, #192]	; 0xc0
    19ec:	4301      	orrs	r1, r0
    19ee:	ea0c 0c0b 	and.w	ip, ip, fp
    19f2:	1879      	adds	r1, r7, r1
    19f4:	ea4e 0c0c 	orr.w	ip, lr, ip
    19f8:	eb46 0c0c 	adc.w	ip, r6, ip
    19fc:	188a      	adds	r2, r1, r2
    19fe:	9223      	str	r2, [sp, #140]	; 0x8c
    1a00:	eb49 020c 	adc.w	r2, r9, ip
    1a04:	9224      	str	r2, [sp, #144]	; 0x90
    1a06:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    1a08:	982b      	ldr	r0, [sp, #172]	; 0xac
    1a0a:	ea4f 4a92 	mov.w	sl, r2, lsr #18
    1a0e:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    1a10:	ea4a 3a82 	orr.w	sl, sl, r2, lsl #14
    1a14:	ea4f 4992 	mov.w	r9, r2, lsr #18
    1a18:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    1a1a:	ea49 3982 	orr.w	r9, r9, r2, lsl #14
    1a1e:	0b91      	lsrs	r1, r2, #14
    1a20:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    1a22:	ea41 4182 	orr.w	r1, r1, r2, lsl #18
    1a26:	0b92      	lsrs	r2, r2, #14
    1a28:	ea42 4280 	orr.w	r2, r2, r0, lsl #18
    1a2c:	ea89 0902 	eor.w	r9, r9, r2
    1a30:	9a2c      	ldr	r2, [sp, #176]	; 0xb0
    1a32:	05d2      	lsls	r2, r2, #23
    1a34:	ea42 2250 	orr.w	r2, r2, r0, lsr #9
    1a38:	ea8a 0a01 	eor.w	sl, sl, r1
    1a3c:	05c1      	lsls	r1, r0, #23
    1a3e:	982c      	ldr	r0, [sp, #176]	; 0xb0
    1a40:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
    1a44:	ea8a 0a01 	eor.w	sl, sl, r1
    1a48:	ea89 0902 	eor.w	r9, r9, r2
    1a4c:	9929      	ldr	r1, [sp, #164]	; 0xa4
    1a4e:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
    1a50:	982a      	ldr	r0, [sp, #168]	; 0xa8
    1a52:	404a      	eors	r2, r1
    1a54:	9931      	ldr	r1, [sp, #196]	; 0xc4
    1a56:	ea81 0800 	eor.w	r8, r1, r0
    1a5a:	992b      	ldr	r1, [sp, #172]	; 0xac
    1a5c:	400a      	ands	r2, r1
    1a5e:	992c      	ldr	r1, [sp, #176]	; 0xb0
    1a60:	9e2d      	ldr	r6, [sp, #180]	; 0xb4
    1a62:	ea08 0801 	and.w	r8, r8, r1
    1a66:	992f      	ldr	r1, [sp, #188]	; 0xbc
    1a68:	404a      	eors	r2, r1
    1a6a:	9931      	ldr	r1, [sp, #196]	; 0xc4
    1a6c:	ea88 0801 	eor.w	r8, r8, r1
    1a70:	e9d3 101c 	ldrd	r1, r0, [r3, #112]	; 0x70
    1a74:	1871      	adds	r1, r6, r1
    1a76:	9e2e      	ldr	r6, [sp, #184]	; 0xb8
    1a78:	eb46 0000 	adc.w	r0, r6, r0
    1a7c:	1852      	adds	r2, r2, r1
    1a7e:	9901      	ldr	r1, [sp, #4]
    1a80:	9228      	str	r2, [sp, #160]	; 0xa0
    1a82:	eb48 0800 	adc.w	r8, r8, r0
    1a86:	2900      	cmp	r1, #0
    1a88:	f000 8294 	beq.w	1fb4 <_Transform_Sha512+0x1fb4>
    1a8c:	9921      	ldr	r1, [sp, #132]	; 0x84
    1a8e:	9811      	ldr	r0, [sp, #68]	; 0x44
    1a90:	f8dd c084 	ldr.w	ip, [sp, #132]	; 0x84
    1a94:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    1a96:	0a0f      	lsrs	r7, r1, #8
    1a98:	9911      	ldr	r1, [sp, #68]	; 0x44
    1a9a:	ea47 6701 	orr.w	r7, r7, r1, lsl #24
    1a9e:	0a0e      	lsrs	r6, r1, #8
    1aa0:	9921      	ldr	r1, [sp, #132]	; 0x84
    1aa2:	ea46 6601 	orr.w	r6, r6, r1, lsl #24
    1aa6:	0849      	lsrs	r1, r1, #1
    1aa8:	ea41 71c0 	orr.w	r1, r1, r0, lsl #31
    1aac:	0840      	lsrs	r0, r0, #1
    1aae:	ea40 70cc 	orr.w	r0, r0, ip, lsl #31
    1ab2:	4070      	eors	r0, r6
    1ab4:	4666      	mov	r6, ip
    1ab6:	4079      	eors	r1, r7
    1ab8:	09f7      	lsrs	r7, r6, #7
    1aba:	9e11      	ldr	r6, [sp, #68]	; 0x44
    1abc:	f8dd c00c 	ldr.w	ip, [sp, #12]
    1ac0:	ea47 6746 	orr.w	r7, r7, r6, lsl #25
    1ac4:	ea80 10d6 	eor.w	r0, r0, r6, lsr #7
    1ac8:	9e20      	ldr	r6, [sp, #128]	; 0x80
    1aca:	4079      	eors	r1, r7
    1acc:	1989      	adds	r1, r1, r6
    1ace:	9e10      	ldr	r6, [sp, #64]	; 0x40
    1ad0:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    1ad2:	eb46 0000 	adc.w	r0, r6, r0
    1ad6:	9e16      	ldr	r6, [sp, #88]	; 0x58
    1ad8:	1989      	adds	r1, r1, r6
    1ada:	9e06      	ldr	r6, [sp, #24]
    1adc:	eb46 0000 	adc.w	r0, r6, r0
    1ae0:	9e03      	ldr	r6, [sp, #12]
    1ae2:	00f6      	lsls	r6, r6, #3
    1ae4:	ea46 7657 	orr.w	r6, r6, r7, lsr #29
    1ae8:	ea4f 0ec7 	mov.w	lr, r7, lsl #3
    1aec:	9f03      	ldr	r7, [sp, #12]
    1aee:	ea4e 7e57 	orr.w	lr, lr, r7, lsr #29
    1af2:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    1af4:	0cff      	lsrs	r7, r7, #19
    1af6:	ea47 374c 	orr.w	r7, r7, ip, lsl #13
    1afa:	ea4f 4cdc 	mov.w	ip, ip, lsr #19
    1afe:	ea4c 3c42 	orr.w	ip, ip, r2, lsl #13
    1b02:	ea8e 0707 	eor.w	r7, lr, r7
    1b06:	ea4f 1e92 	mov.w	lr, r2, lsr #6
    1b0a:	9a03      	ldr	r2, [sp, #12]
    1b0c:	ea4e 6e82 	orr.w	lr, lr, r2, lsl #26
    1b10:	ea86 060c 	eor.w	r6, r6, ip
    1b14:	ea87 070e 	eor.w	r7, r7, lr
    1b18:	19c9      	adds	r1, r1, r7
    1b1a:	ea86 1692 	eor.w	r6, r6, r2, lsr #6
    1b1e:	9120      	str	r1, [sp, #128]	; 0x80
    1b20:	eb40 0106 	adc.w	r1, r0, r6
    1b24:	9110      	str	r1, [sp, #64]	; 0x40
    1b26:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    1b28:	9920      	ldr	r1, [sp, #128]	; 0x80
    1b2a:	9e23      	ldr	r6, [sp, #140]	; 0x8c
    1b2c:	eb1a 0202 	adds.w	r2, sl, r2
    1b30:	eb49 0908 	adc.w	r9, r9, r8
    1b34:	1852      	adds	r2, r2, r1
    1b36:	9910      	ldr	r1, [sp, #64]	; 0x40
    1b38:	eb41 0909 	adc.w	r9, r1, r9
    1b3c:	9925      	ldr	r1, [sp, #148]	; 0x94
    1b3e:	1889      	adds	r1, r1, r2
    1b40:	912d      	str	r1, [sp, #180]	; 0xb4
    1b42:	9926      	ldr	r1, [sp, #152]	; 0x98
    1b44:	eb41 0109 	adc.w	r1, r1, r9
    1b48:	912e      	str	r1, [sp, #184]	; 0xb8
    1b4a:	9924      	ldr	r1, [sp, #144]	; 0x90
    1b4c:	078f      	lsls	r7, r1, #30
    1b4e:	9923      	ldr	r1, [sp, #140]	; 0x8c
    1b50:	ea47 0791 	orr.w	r7, r7, r1, lsr #2
    1b54:	ea4f 7e81 	mov.w	lr, r1, lsl #30
    1b58:	9924      	ldr	r1, [sp, #144]	; 0x90
    1b5a:	ea4e 0e91 	orr.w	lr, lr, r1, lsr #2
    1b5e:	9923      	ldr	r1, [sp, #140]	; 0x8c
    1b60:	0f08      	lsrs	r0, r1, #28
    1b62:	9924      	ldr	r1, [sp, #144]	; 0x90
    1b64:	ea40 1001 	orr.w	r0, r0, r1, lsl #4
    1b68:	0f09      	lsrs	r1, r1, #28
    1b6a:	ea41 1106 	orr.w	r1, r1, r6, lsl #4
    1b6e:	404f      	eors	r7, r1
    1b70:	9924      	ldr	r1, [sp, #144]	; 0x90
    1b72:	ea8e 0e00 	eor.w	lr, lr, r0
    1b76:	9824      	ldr	r0, [sp, #144]	; 0x90
    1b78:	ea4f 6c41 	mov.w	ip, r1, lsl #25
    1b7c:	0671      	lsls	r1, r6, #25
    1b7e:	ea41 11d0 	orr.w	r1, r1, r0, lsr #7
    1b82:	ea8e 0e01 	eor.w	lr, lr, r1
    1b86:	9824      	ldr	r0, [sp, #144]	; 0x90
    1b88:	9922      	ldr	r1, [sp, #136]	; 0x88
    1b8a:	ea4c 1cd6 	orr.w	ip, ip, r6, lsr #7
    1b8e:	4331      	orrs	r1, r6
    1b90:	ea4b 0600 	orr.w	r6, fp, r0
    1b94:	9827      	ldr	r0, [sp, #156]	; 0x9c
    1b96:	4001      	ands	r1, r0
    1b98:	9830      	ldr	r0, [sp, #192]	; 0xc0
    1b9a:	ea87 070c 	eor.w	r7, r7, ip
    1b9e:	4006      	ands	r6, r0
    1ba0:	e9dd 0c22 	ldrd	r0, ip, [sp, #136]	; 0x88
    1ba4:	ea00 000c 	and.w	r0, r0, ip
    1ba8:	f8dd c090 	ldr.w	ip, [sp, #144]	; 0x90
    1bac:	4301      	orrs	r1, r0
    1bae:	ea0b 0c0c 	and.w	ip, fp, ip
    1bb2:	eb1e 0101 	adds.w	r1, lr, r1
    1bb6:	ea46 0c0c 	orr.w	ip, r6, ip
    1bba:	eb47 0c0c 	adc.w	ip, r7, ip
    1bbe:	188a      	adds	r2, r1, r2
    1bc0:	9225      	str	r2, [sp, #148]	; 0x94
    1bc2:	eb49 020c 	adc.w	r2, r9, ip
    1bc6:	9226      	str	r2, [sp, #152]	; 0x98
    1bc8:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    1bca:	992e      	ldr	r1, [sp, #184]	; 0xb8
    1bcc:	982d      	ldr	r0, [sp, #180]	; 0xb4
    1bce:	ea4f 4a92 	mov.w	sl, r2, lsr #18
    1bd2:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    1bd4:	ea4a 3a82 	orr.w	sl, sl, r2, lsl #14
    1bd8:	ea4f 4992 	mov.w	r9, r2, lsr #18
    1bdc:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    1bde:	ea49 3982 	orr.w	r9, r9, r2, lsl #14
    1be2:	0b92      	lsrs	r2, r2, #14
    1be4:	ea42 4281 	orr.w	r2, r2, r1, lsl #18
    1be8:	ea8a 0a02 	eor.w	sl, sl, r2
    1bec:	0b89      	lsrs	r1, r1, #14
    1bee:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
    1bf0:	ea41 4180 	orr.w	r1, r1, r0, lsl #18
    1bf4:	ea89 0901 	eor.w	r9, r9, r1
    1bf8:	05d1      	lsls	r1, r2, #23
    1bfa:	ea41 2150 	orr.w	r1, r1, r0, lsr #9
    1bfe:	05c2      	lsls	r2, r0, #23
    1c00:	982e      	ldr	r0, [sp, #184]	; 0xb8
    1c02:	ea42 2250 	orr.w	r2, r2, r0, lsr #9
    1c06:	ea8a 0a02 	eor.w	sl, sl, r2
    1c0a:	ea89 0901 	eor.w	r9, r9, r1
    1c0e:	9a29      	ldr	r2, [sp, #164]	; 0xa4
    1c10:	992b      	ldr	r1, [sp, #172]	; 0xac
    1c12:	982c      	ldr	r0, [sp, #176]	; 0xb0
    1c14:	9e2f      	ldr	r6, [sp, #188]	; 0xbc
    1c16:	404a      	eors	r2, r1
    1c18:	992a      	ldr	r1, [sp, #168]	; 0xa8
    1c1a:	ea81 0800 	eor.w	r8, r1, r0
    1c1e:	992d      	ldr	r1, [sp, #180]	; 0xb4
    1c20:	400a      	ands	r2, r1
    1c22:	992e      	ldr	r1, [sp, #184]	; 0xb8
    1c24:	ea08 0801 	and.w	r8, r8, r1
    1c28:	9929      	ldr	r1, [sp, #164]	; 0xa4
    1c2a:	404a      	eors	r2, r1
    1c2c:	992a      	ldr	r1, [sp, #168]	; 0xa8
    1c2e:	ea88 0801 	eor.w	r8, r8, r1
    1c32:	e9d3 101e 	ldrd	r1, r0, [r3, #120]	; 0x78
    1c36:	1871      	adds	r1, r6, r1
    1c38:	9e31      	ldr	r6, [sp, #196]	; 0xc4
    1c3a:	eb46 0000 	adc.w	r0, r6, r0
    1c3e:	1852      	adds	r2, r2, r1
    1c40:	9901      	ldr	r1, [sp, #4]
    1c42:	9228      	str	r2, [sp, #160]	; 0xa0
    1c44:	eb48 0800 	adc.w	r8, r8, r0
    1c48:	2900      	cmp	r1, #0
    1c4a:	f000 81ba 	beq.w	1fc2 <_Transform_Sha512+0x1fc2>
    1c4e:	9918      	ldr	r1, [sp, #96]	; 0x60
    1c50:	9808      	ldr	r0, [sp, #32]
    1c52:	f8dd c060 	ldr.w	ip, [sp, #96]	; 0x60
    1c56:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    1c58:	0a0f      	lsrs	r7, r1, #8
    1c5a:	9908      	ldr	r1, [sp, #32]
    1c5c:	ea47 6701 	orr.w	r7, r7, r1, lsl #24
    1c60:	0a0e      	lsrs	r6, r1, #8
    1c62:	9918      	ldr	r1, [sp, #96]	; 0x60
    1c64:	ea46 6601 	orr.w	r6, r6, r1, lsl #24
    1c68:	0849      	lsrs	r1, r1, #1
    1c6a:	ea41 71c0 	orr.w	r1, r1, r0, lsl #31
    1c6e:	0840      	lsrs	r0, r0, #1
    1c70:	ea40 70cc 	orr.w	r0, r0, ip, lsl #31
    1c74:	4070      	eors	r0, r6
    1c76:	4666      	mov	r6, ip
    1c78:	4079      	eors	r1, r7
    1c7a:	09f7      	lsrs	r7, r6, #7
    1c7c:	9e08      	ldr	r6, [sp, #32]
    1c7e:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
    1c82:	ea47 6746 	orr.w	r7, r7, r6, lsl #25
    1c86:	ea80 10d6 	eor.w	r0, r0, r6, lsr #7
    1c8a:	9e21      	ldr	r6, [sp, #132]	; 0x84
    1c8c:	4079      	eors	r1, r7
    1c8e:	1989      	adds	r1, r1, r6
    1c90:	9e11      	ldr	r6, [sp, #68]	; 0x44
    1c92:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
    1c94:	eb46 0000 	adc.w	r0, r6, r0
    1c98:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
    1c9a:	1989      	adds	r1, r1, r6
    1c9c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    1c9e:	eb46 0000 	adc.w	r0, r6, r0
    1ca2:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    1ca4:	00f6      	lsls	r6, r6, #3
    1ca6:	ea46 7657 	orr.w	r6, r6, r7, lsr #29
    1caa:	ea4f 0ec7 	mov.w	lr, r7, lsl #3
    1cae:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    1cb0:	ea4e 7e57 	orr.w	lr, lr, r7, lsr #29
    1cb4:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
    1cb6:	0cff      	lsrs	r7, r7, #19
    1cb8:	ea47 374c 	orr.w	r7, r7, ip, lsl #13
    1cbc:	ea4f 4cdc 	mov.w	ip, ip, lsr #19
    1cc0:	ea4c 3c42 	orr.w	ip, ip, r2, lsl #13
    1cc4:	ea8e 0707 	eor.w	r7, lr, r7
    1cc8:	ea4f 1e92 	mov.w	lr, r2, lsr #6
    1ccc:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    1cce:	ea4e 6e82 	orr.w	lr, lr, r2, lsl #26
    1cd2:	ea86 060c 	eor.w	r6, r6, ip
    1cd6:	ea87 070e 	eor.w	r7, r7, lr
    1cda:	19c9      	adds	r1, r1, r7
    1cdc:	ea86 1692 	eor.w	r6, r6, r2, lsr #6
    1ce0:	9121      	str	r1, [sp, #132]	; 0x84
    1ce2:	eb40 0106 	adc.w	r1, r0, r6
    1ce6:	9111      	str	r1, [sp, #68]	; 0x44
    1ce8:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    1cea:	9921      	ldr	r1, [sp, #132]	; 0x84
    1cec:	9f25      	ldr	r7, [sp, #148]	; 0x94
    1cee:	f8dd e098 	ldr.w	lr, [sp, #152]	; 0x98
    1cf2:	eb1a 0202 	adds.w	r2, sl, r2
    1cf6:	eb49 0908 	adc.w	r9, r9, r8
    1cfa:	eb12 0801 	adds.w	r8, r2, r1
    1cfe:	9a11      	ldr	r2, [sp, #68]	; 0x44
    1d00:	9926      	ldr	r1, [sp, #152]	; 0x98
    1d02:	eb42 0909 	adc.w	r9, r2, r9
    1d06:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    1d08:	eb12 0208 	adds.w	r2, r2, r8
    1d0c:	922f      	str	r2, [sp, #188]	; 0xbc
    1d0e:	9a30      	ldr	r2, [sp, #192]	; 0xc0
    1d10:	eb42 0a09 	adc.w	sl, r2, r9
    1d14:	9a26      	ldr	r2, [sp, #152]	; 0x98
    1d16:	0790      	lsls	r0, r2, #30
    1d18:	9a25      	ldr	r2, [sp, #148]	; 0x94
    1d1a:	ea40 0092 	orr.w	r0, r0, r2, lsr #2
    1d1e:	0796      	lsls	r6, r2, #30
    1d20:	9a26      	ldr	r2, [sp, #152]	; 0x98
    1d22:	ea46 0692 	orr.w	r6, r6, r2, lsr #2
    1d26:	9a25      	ldr	r2, [sp, #148]	; 0x94
    1d28:	0f12      	lsrs	r2, r2, #28
    1d2a:	ea42 1201 	orr.w	r2, r2, r1, lsl #4
    1d2e:	4056      	eors	r6, r2
    1d30:	0f09      	lsrs	r1, r1, #28
    1d32:	9a26      	ldr	r2, [sp, #152]	; 0x98
    1d34:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
    1d38:	4048      	eors	r0, r1
    1d3a:	0651      	lsls	r1, r2, #25
    1d3c:	ea41 11d7 	orr.w	r1, r1, r7, lsr #7
    1d40:	067a      	lsls	r2, r7, #25
    1d42:	9f26      	ldr	r7, [sp, #152]	; 0x98
    1d44:	ea42 12d7 	orr.w	r2, r2, r7, lsr #7
    1d48:	4056      	eors	r6, r2
    1d4a:	4048      	eors	r0, r1
    1d4c:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    1d4e:	9925      	ldr	r1, [sp, #148]	; 0x94
    1d50:	ea42 0c01 	orr.w	ip, r2, r1
    1d54:	9a24      	ldr	r2, [sp, #144]	; 0x90
    1d56:	9925      	ldr	r1, [sp, #148]	; 0x94
    1d58:	4317      	orrs	r7, r2
    1d5a:	9a22      	ldr	r2, [sp, #136]	; 0x88
    1d5c:	ea0c 0c02 	and.w	ip, ip, r2
    1d60:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    1d62:	4011      	ands	r1, r2
    1d64:	9a24      	ldr	r2, [sp, #144]	; 0x90
    1d66:	ea07 070b 	and.w	r7, r7, fp
    1d6a:	ea02 0e0e 	and.w	lr, r2, lr
    1d6e:	ea4c 0101 	orr.w	r1, ip, r1
    1d72:	1871      	adds	r1, r6, r1
    1d74:	ea47 0e0e 	orr.w	lr, r7, lr
    1d78:	eb40 0e0e 	adc.w	lr, r0, lr
    1d7c:	eb11 0208 	adds.w	r2, r1, r8
    for (j = 0; j < 80; j += 16) {
    1d80:	9901      	ldr	r1, [sp, #4]
        R(12); R(13); R(14); R(15);
    1d82:	9227      	str	r2, [sp, #156]	; 0x9c
    for (j = 0; j < 80; j += 16) {
    1d84:	f101 0110 	add.w	r1, r1, #16
        R(12); R(13); R(14); R(15);
    1d88:	eb49 020e 	adc.w	r2, r9, lr
    for (j = 0; j < 80; j += 16) {
    1d8c:	2950      	cmp	r1, #80	; 0x50
        R(12); R(13); R(14); R(15);
    1d8e:	9228      	str	r2, [sp, #160]	; 0xa0
    for (j = 0; j < 80; j += 16) {
    1d90:	9101      	str	r1, [sp, #4]
    1d92:	f103 0380 	add.w	r3, r3, #128	; 0x80
    1d96:	f47e a9a6 	bne.w	e6 <_Transform_Sha512+0xe6>
    1d9a:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    1d9c:	e9cd 3a3a 	strd	r3, sl, [sp, #232]	; 0xe8
    1da0:	9b2b      	ldr	r3, [sp, #172]	; 0xac
    1da2:	933e      	str	r3, [sp, #248]	; 0xf8
    1da4:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    1da6:	933f      	str	r3, [sp, #252]	; 0xfc
    1da8:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
    1daa:	933c      	str	r3, [sp, #240]	; 0xf0
    1dac:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
    1dae:	933d      	str	r3, [sp, #244]	; 0xf4
    1db0:	9b20      	ldr	r3, [sp, #128]	; 0x80
    1db2:	6723      	str	r3, [r4, #112]	; 0x70
    1db4:	9b10      	ldr	r3, [sp, #64]	; 0x40
    1db6:	6763      	str	r3, [r4, #116]	; 0x74
    1db8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    1dba:	64a3      	str	r3, [r4, #72]	; 0x48
    1dbc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1dbe:	64e3      	str	r3, [r4, #76]	; 0x4c
    1dc0:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1dc2:	60a3      	str	r3, [r4, #8]
    1dc4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1dc6:	60e3      	str	r3, [r4, #12]
    1dc8:	9b18      	ldr	r3, [sp, #96]	; 0x60
    1dca:	6023      	str	r3, [r4, #0]
    1dcc:	9b08      	ldr	r3, [sp, #32]
    1dce:	6063      	str	r3, [r4, #4]
    1dd0:	9b29      	ldr	r3, [sp, #164]	; 0xa4
    1dd2:	9340      	str	r3, [sp, #256]	; 0x100
    1dd4:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
    1dd6:	9341      	str	r3, [sp, #260]	; 0x104
    1dd8:	9b22      	ldr	r3, [sp, #136]	; 0x88
    1dda:	e9cd 3b38 	strd	r3, fp, [sp, #224]	; 0xe0
    1dde:	9b27      	ldr	r3, [sp, #156]	; 0x9c
    1de0:	9332      	str	r3, [sp, #200]	; 0xc8
    1de2:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    1de4:	9333      	str	r3, [sp, #204]	; 0xcc
    1de6:	9b25      	ldr	r3, [sp, #148]	; 0x94
    1de8:	9334      	str	r3, [sp, #208]	; 0xd0
    1dea:	9b26      	ldr	r3, [sp, #152]	; 0x98
    1dec:	9335      	str	r3, [sp, #212]	; 0xd4
    1dee:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    1df0:	9336      	str	r3, [sp, #216]	; 0xd8
    1df2:	9b24      	ldr	r3, [sp, #144]	; 0x90
    1df4:	9337      	str	r3, [sp, #220]	; 0xdc
    1df6:	9b21      	ldr	r3, [sp, #132]	; 0x84
    1df8:	67a3      	str	r3, [r4, #120]	; 0x78
    1dfa:	9b11      	ldr	r3, [sp, #68]	; 0x44
    1dfc:	67e3      	str	r3, [r4, #124]	; 0x7c
    1dfe:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    1e00:	6523      	str	r3, [r4, #80]	; 0x50
    1e02:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1e04:	6563      	str	r3, [r4, #84]	; 0x54
    1e06:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    1e08:	6123      	str	r3, [r4, #16]
    1e0a:	9b07      	ldr	r3, [sp, #28]
    1e0c:	6163      	str	r3, [r4, #20]
    1e0e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1e10:	65a3      	str	r3, [r4, #88]	; 0x58
    1e12:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    1e14:	65e3      	str	r3, [r4, #92]	; 0x5c
    1e16:	9b12      	ldr	r3, [sp, #72]	; 0x48
    1e18:	61a3      	str	r3, [r4, #24]
    1e1a:	9b02      	ldr	r3, [sp, #8]
    1e1c:	61e3      	str	r3, [r4, #28]
    1e1e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    1e20:	6623      	str	r3, [r4, #96]	; 0x60
    1e22:	9b03      	ldr	r3, [sp, #12]
    1e24:	6663      	str	r3, [r4, #100]	; 0x64
    1e26:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    1e28:	6223      	str	r3, [r4, #32]
    1e2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1e2c:	6263      	str	r3, [r4, #36]	; 0x24
    1e2e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1e30:	66a3      	str	r3, [r4, #104]	; 0x68
    1e32:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    1e34:	66e3      	str	r3, [r4, #108]	; 0x6c
    1e36:	9b14      	ldr	r3, [sp, #80]	; 0x50
    1e38:	62a3      	str	r3, [r4, #40]	; 0x28
    1e3a:	9b04      	ldr	r3, [sp, #16]
    1e3c:	62e3      	str	r3, [r4, #44]	; 0x2c
    1e3e:	9b15      	ldr	r3, [sp, #84]	; 0x54
    1e40:	6323      	str	r3, [r4, #48]	; 0x30
    1e42:	9b05      	ldr	r3, [sp, #20]
    1e44:	6363      	str	r3, [r4, #52]	; 0x34
    1e46:	9b16      	ldr	r3, [sp, #88]	; 0x58
    1e48:	63a3      	str	r3, [r4, #56]	; 0x38
    1e4a:	9b06      	ldr	r3, [sp, #24]
    1e4c:	63e3      	str	r3, [r4, #60]	; 0x3c
    1e4e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    1e50:	6423      	str	r3, [r4, #64]	; 0x40
    1e52:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1e54:	6463      	str	r3, [r4, #68]	; 0x44
    sha512->digest[0] += a(0);
    1e56:	e9d5 3100 	ldrd	r3, r1, [r5]
    1e5a:	9a27      	ldr	r2, [sp, #156]	; 0x9c
    1e5c:	189b      	adds	r3, r3, r2
    1e5e:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    1e60:	eb42 0101 	adc.w	r1, r2, r1
    1e64:	e9c5 3100 	strd	r3, r1, [r5]
    sha512->digest[1] += b(0);
    1e68:	e9d5 1602 	ldrd	r1, r6, [r5, #8]
    1e6c:	9b25      	ldr	r3, [sp, #148]	; 0x94
    1e6e:	18c9      	adds	r1, r1, r3
    1e70:	9b26      	ldr	r3, [sp, #152]	; 0x98
    1e72:	eb43 0606 	adc.w	r6, r3, r6
    1e76:	e9c5 1602 	strd	r1, r6, [r5, #8]
    sha512->digest[2] += c(0);
    1e7a:	e9d5 2604 	ldrd	r2, r6, [r5, #16]
    1e7e:	9b23      	ldr	r3, [sp, #140]	; 0x8c
    1e80:	18d2      	adds	r2, r2, r3
    1e82:	9b24      	ldr	r3, [sp, #144]	; 0x90
    1e84:	eb43 0606 	adc.w	r6, r3, r6
    1e88:	e9c5 2604 	strd	r2, r6, [r5, #16]
    sha512->digest[3] += d(0);
    1e8c:	e9d5 2606 	ldrd	r2, r6, [r5, #24]
    1e90:	9b22      	ldr	r3, [sp, #136]	; 0x88
    sha512->digest[4] += e(0);
    1e92:	e9d5 0708 	ldrd	r0, r7, [r5, #32]
    sha512->digest[3] += d(0);
    1e96:	18d2      	adds	r2, r2, r3
    sha512->digest[4] += e(0);
    1e98:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
    sha512->digest[3] += d(0);
    1e9a:	eb4b 0606 	adc.w	r6, fp, r6
    sha512->digest[4] += e(0);
    1e9e:	18c0      	adds	r0, r0, r3
    1ea0:	eb4a 0707 	adc.w	r7, sl, r7
    1ea4:	e9c5 0708 	strd	r0, r7, [r5, #32]
    sha512->digest[5] += f(0);
    1ea8:	e9d5 070a 	ldrd	r0, r7, [r5, #40]	; 0x28
    1eac:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
    1eae:	18c0      	adds	r0, r0, r3
    1eb0:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
    1eb2:	eb43 0707 	adc.w	r7, r3, r7
    sha512->digest[3] += d(0);
    1eb6:	e9c5 2606 	strd	r2, r6, [r5, #24]
    sha512->digest[5] += f(0);
    1eba:	e9c5 070a 	strd	r0, r7, [r5, #40]	; 0x28
    sha512->digest[6] += g(0);
    1ebe:	e9d5 060c 	ldrd	r0, r6, [r5, #48]	; 0x30
    1ec2:	9b2b      	ldr	r3, [sp, #172]	; 0xac
    1ec4:	18c0      	adds	r0, r0, r3
    1ec6:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
    1ec8:	eb43 0606 	adc.w	r6, r3, r6
    1ecc:	e9c5 060c 	strd	r0, r6, [r5, #48]	; 0x30
    sha512->digest[7] += h(0);
    1ed0:	e9d5 160e 	ldrd	r1, r6, [r5, #56]	; 0x38
    1ed4:	9b29      	ldr	r3, [sp, #164]	; 0xa4
    1ed6:	18c9      	adds	r1, r1, r3
    1ed8:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
    1eda:	eb43 0606 	adc.w	r6, r3, r6
    1ede:	e9c5 160e 	strd	r1, r6, [r5, #56]	; 0x38
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
    1ee2:	f104 0280 	add.w	r2, r4, #128	; 0x80
    1ee6:	4623      	mov	r3, r4
    1ee8:	2100      	movs	r1, #0
    1eea:	4293      	cmp	r3, r2
    1eec:	d170      	bne.n	1fd0 <_Transform_Sha512+0x1fd0>
    1eee:	2300      	movs	r3, #0
    1ef0:	4619      	mov	r1, r3
    1ef2:	f103 02c8 	add.w	r2, r3, #200	; 0xc8
    1ef6:	3301      	adds	r3, #1
    1ef8:	2b41      	cmp	r3, #65	; 0x41
    1efa:	446a      	add	r2, sp
    1efc:	d16b      	bne.n	1fd6 <_Transform_Sha512+0x1fd6>
    XFREE(W, sha512->heap, DYNAMIC_TYPE_TMP_BUFFER);
    1efe:	4620      	mov	r0, r4
    1f00:	f7ff fffe 	bl	0 <free>
    return 0;
    1f04:	2000      	movs	r0, #0
}
    1f06:	b043      	add	sp, #268	; 0x10c
    1f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        R( 0); R( 1); R( 2); R( 3);
    1f0c:	6c2a      	ldr	r2, [r5, #64]	; 0x40
    1f0e:	9218      	str	r2, [sp, #96]	; 0x60
    1f10:	6c6a      	ldr	r2, [r5, #68]	; 0x44
    1f12:	9208      	str	r2, [sp, #32]
    1f14:	f7fe b975 	b.w	202 <_Transform_Sha512+0x202>
    1f18:	6caa      	ldr	r2, [r5, #72]	; 0x48
    1f1a:	9219      	str	r2, [sp, #100]	; 0x64
    1f1c:	6cea      	ldr	r2, [r5, #76]	; 0x4c
    1f1e:	f7fe ba61 	b.w	3e4 <_Transform_Sha512+0x3e4>
    1f22:	6d2a      	ldr	r2, [r5, #80]	; 0x50
    1f24:	9217      	str	r2, [sp, #92]	; 0x5c
    1f26:	6d6a      	ldr	r2, [r5, #84]	; 0x54
    1f28:	f7fe bb4b 	b.w	5c2 <_Transform_Sha512+0x5c2>
    1f2c:	6daa      	ldr	r2, [r5, #88]	; 0x58
    1f2e:	9212      	str	r2, [sp, #72]	; 0x48
    1f30:	6dea      	ldr	r2, [r5, #92]	; 0x5c
    1f32:	f7fe bc2f 	b.w	794 <_Transform_Sha512+0x794>
        R( 4); R( 5); R( 6); R( 7);
    1f36:	6e29      	ldr	r1, [r5, #96]	; 0x60
    1f38:	911a      	str	r1, [sp, #104]	; 0x68
    1f3a:	6e69      	ldr	r1, [r5, #100]	; 0x64
    1f3c:	f7fe bd13 	b.w	966 <_Transform_Sha512+0x966>
    1f40:	6ea9      	ldr	r1, [r5, #104]	; 0x68
    1f42:	9114      	str	r1, [sp, #80]	; 0x50
    1f44:	6ee9      	ldr	r1, [r5, #108]	; 0x6c
    1f46:	f7fe bdef 	b.w	b28 <_Transform_Sha512+0xb28>
    1f4a:	6f29      	ldr	r1, [r5, #112]	; 0x70
    1f4c:	9115      	str	r1, [sp, #84]	; 0x54
    1f4e:	6f69      	ldr	r1, [r5, #116]	; 0x74
    1f50:	f7fe bece 	b.w	cf0 <_Transform_Sha512+0xcf0>
    1f54:	6fa9      	ldr	r1, [r5, #120]	; 0x78
    1f56:	9116      	str	r1, [sp, #88]	; 0x58
    1f58:	6fe9      	ldr	r1, [r5, #124]	; 0x7c
    1f5a:	f7fe bfac 	b.w	eb6 <_Transform_Sha512+0xeb6>
        R( 8); R( 9); R(10); R(11);
    1f5e:	f8d5 1080 	ldr.w	r1, [r5, #128]	; 0x80
    1f62:	911b      	str	r1, [sp, #108]	; 0x6c
    1f64:	f8d5 1084 	ldr.w	r1, [r5, #132]	; 0x84
    1f68:	f7ff b88c 	b.w	1084 <_Transform_Sha512+0x1084>
    1f6c:	f8d5 2088 	ldr.w	r2, [r5, #136]	; 0x88
    1f70:	921c      	str	r2, [sp, #112]	; 0x70
    1f72:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
    1f76:	f7ff b964 	b.w	1242 <_Transform_Sha512+0x1242>
    1f7a:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
    1f7e:	921d      	str	r2, [sp, #116]	; 0x74
    1f80:	f8d5 2094 	ldr.w	r2, [r5, #148]	; 0x94
    1f84:	f7ff ba41 	b.w	140a <_Transform_Sha512+0x140a>
    1f88:	f8d5 2098 	ldr.w	r2, [r5, #152]	; 0x98
    1f8c:	921e      	str	r2, [sp, #120]	; 0x78
    1f8e:	f8d5 209c 	ldr.w	r2, [r5, #156]	; 0x9c
    1f92:	920e      	str	r2, [sp, #56]	; 0x38
    1f94:	f7ff bb23 	b.w	15de <_Transform_Sha512+0x15de>
        R(12); R(13); R(14); R(15);
    1f98:	f8d5 10a0 	ldr.w	r1, [r5, #160]	; 0xa0
    1f9c:	9113      	str	r1, [sp, #76]	; 0x4c
    1f9e:	f8d5 10a4 	ldr.w	r1, [r5, #164]	; 0xa4
    1fa2:	f7ff bbfd 	b.w	17a0 <_Transform_Sha512+0x17a0>
    1fa6:	f8d5 20a8 	ldr.w	r2, [r5, #168]	; 0xa8
    1faa:	921f      	str	r2, [sp, #124]	; 0x7c
    1fac:	f8d5 20ac 	ldr.w	r2, [r5, #172]	; 0xac
    1fb0:	920f      	str	r2, [sp, #60]	; 0x3c
    1fb2:	e4da      	b.n	196a <_Transform_Sha512+0x196a>
    1fb4:	f8d5 20b0 	ldr.w	r2, [r5, #176]	; 0xb0
    1fb8:	9220      	str	r2, [sp, #128]	; 0x80
    1fba:	f8d5 20b4 	ldr.w	r2, [r5, #180]	; 0xb4
    1fbe:	9210      	str	r2, [sp, #64]	; 0x40
    1fc0:	e5b1      	b.n	1b26 <_Transform_Sha512+0x1b26>
    1fc2:	f8d5 20b8 	ldr.w	r2, [r5, #184]	; 0xb8
    1fc6:	9221      	str	r2, [sp, #132]	; 0x84
    1fc8:	f8d5 20bc 	ldr.w	r2, [r5, #188]	; 0xbc
    1fcc:	9211      	str	r2, [sp, #68]	; 0x44
    1fce:	e68b      	b.n	1ce8 <_Transform_Sha512+0x1ce8>
    1fd0:	f803 1b01 	strb.w	r1, [r3], #1
    1fd4:	e789      	b.n	1eea <_Transform_Sha512+0x1eea>
    1fd6:	7011      	strb	r1, [r2, #0]
    1fd8:	e78b      	b.n	1ef2 <_Transform_Sha512+0x1ef2>
        return MEMORY_E;
    1fda:	f06f 007c 	mvn.w	r0, #124	; 0x7c
    1fde:	e792      	b.n	1f06 <_Transform_Sha512+0x1f06>

Disassembly of section .text.Sha512_Family_Final:

00000000 <Sha512_Family_Final>:
    return Sha512FinalRaw(sha512, hash, WC_SHA512_DIGEST_SIZE);
}

static int Sha512_Family_Final(wc_Sha512* sha512, byte* hash, size_t digestSz,
                               int (*initfp)(wc_Sha512*))
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	460e      	mov	r6, r1
   6:	4690      	mov	r8, r2
   8:	461f      	mov	r7, r3
    int ret;

    if (sha512 == NULL || hash == NULL) {
   a:	4604      	mov	r4, r0
   c:	2800      	cmp	r0, #0
   e:	d061      	beq.n	d4 <Sha512_Family_Final+0xd4>
  10:	2900      	cmp	r1, #0
  12:	d05f      	beq.n	d4 <Sha512_Family_Final+0xd4>
    if (sha512->buffLen > WC_SHA512_BLOCK_SIZE - 1) {
  14:	f8d0 30c0 	ldr.w	r3, [r0, #192]	; 0xc0
  18:	2b7f      	cmp	r3, #127	; 0x7f
    local = (byte*)sha512->buffer;
  1a:	f100 0940 	add.w	r9, r0, #64	; 0x40
    if (sha512->buffLen > WC_SHA512_BLOCK_SIZE - 1) {
  1e:	d85d      	bhi.n	dc <Sha512_Family_Final+0xdc>
    local[sha512->buffLen++] = 0x80;  /* add 1 */
  20:	1c5a      	adds	r2, r3, #1
  22:	2580      	movs	r5, #128	; 0x80
  24:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
  28:	f809 5003 	strb.w	r5, [r9, r3]
    if (sha512->buffLen > WC_SHA512_PAD_SIZE) {
  2c:	f8d0 00c0 	ldr.w	r0, [r0, #192]	; 0xc0
  30:	2870      	cmp	r0, #112	; 0x70
  32:	d912      	bls.n	5a <Sha512_Family_Final+0x5a>
        XMEMSET(&local[sha512->buffLen], 0, WC_SHA512_BLOCK_SIZE - sha512->buffLen);
  34:	1a2a      	subs	r2, r5, r0
  36:	2100      	movs	r1, #0
  38:	4448      	add	r0, r9
  3a:	f7ff fffe 	bl	0 <memset>
            ByteReverseWords64(sha512->buffer,sha512->buffer,
  3e:	4648      	mov	r0, r9
        sha512->buffLen += WC_SHA512_BLOCK_SIZE - sha512->buffLen;
  40:	f8c4 50c0 	str.w	r5, [r4, #192]	; 0xc0
            ByteReverseWords64(sha512->buffer,sha512->buffer,
  44:	462a      	mov	r2, r5
  46:	4649      	mov	r1, r9
  48:	f7ff fffe 	bl	0 <Sha512_Family_Final>
        ret = Transform_Sha512(sha512);
  4c:	4620      	mov	r0, r4
  4e:	f7ff fffe 	bl	0 <Sha512_Family_Final>
        if (ret != 0)
  52:	2800      	cmp	r0, #0
  54:	d140      	bne.n	d8 <Sha512_Family_Final+0xd8>
        sha512->buffLen = 0;
  56:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
    XMEMSET(&local[sha512->buffLen], 0, WC_SHA512_PAD_SIZE - sha512->buffLen);
  5a:	f8d4 00c0 	ldr.w	r0, [r4, #192]	; 0xc0
  5e:	2100      	movs	r1, #0
  60:	f1c0 0270 	rsb	r2, r0, #112	; 0x70
  64:	4448      	add	r0, r9
  66:	f7ff fffe 	bl	0 <memset>
                                                         (sha512->hiLen << 3);
  6a:	e9d4 5334 	ldrd	r5, r3, [r4, #208]	; 0xd0
    sha512->hiLen = (sha512->loLen >> (8 * sizeof(sha512->loLen) - 3)) +
  6e:	e9d4 1232 	ldrd	r1, r2, [r4, #200]	; 0xc8
                                                         (sha512->hiLen << 3);
  72:	00db      	lsls	r3, r3, #3
    sha512->hiLen = (sha512->loLen >> (8 * sizeof(sha512->loLen) - 3)) +
  74:	0f50      	lsrs	r0, r2, #29
                                                         (sha512->hiLen << 3);
  76:	ea43 7355 	orr.w	r3, r3, r5, lsr #29
  7a:	00ed      	lsls	r5, r5, #3
    sha512->hiLen = (sha512->loLen >> (8 * sizeof(sha512->loLen) - 3)) +
  7c:	182d      	adds	r5, r5, r0
    sha512->loLen = sha512->loLen << 3;
  7e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
    sha512->hiLen = (sha512->loLen >> (8 * sizeof(sha512->loLen) - 3)) +
  82:	f143 0300 	adc.w	r3, r3, #0
    sha512->loLen = sha512->loLen << 3;
  86:	ea42 7251 	orr.w	r2, r2, r1, lsr #29
  8a:	00c9      	lsls	r1, r1, #3
  8c:	e9c4 1232 	strd	r1, r2, [r4, #200]	; 0xc8
    sha512->hiLen = (sha512->loLen >> (8 * sizeof(sha512->loLen) - 3)) +
  90:	e9c4 5334 	strd	r5, r3, [r4, #208]	; 0xd0
            ByteReverseWords64(sha512->buffer, sha512->buffer, WC_SHA512_PAD_SIZE);
  94:	2270      	movs	r2, #112	; 0x70
  96:	4648      	mov	r0, r9
  98:	4649      	mov	r1, r9
  9a:	f7ff fffe 	bl	0 <Sha512_Family_Final>
    sha512->buffer[WC_SHA512_BLOCK_SIZE / sizeof(word64) - 2] = sha512->hiLen;
  9e:	e9d4 2334 	ldrd	r2, r3, [r4, #208]	; 0xd0
  a2:	e9c4 232c 	strd	r2, r3, [r4, #176]	; 0xb0
    sha512->buffer[WC_SHA512_BLOCK_SIZE / sizeof(word64) - 1] = sha512->loLen;
  a6:	e9d4 2332 	ldrd	r2, r3, [r4, #200]	; 0xc8
    ret = Transform_Sha512(sha512);
  aa:	4620      	mov	r0, r4
    sha512->buffer[WC_SHA512_BLOCK_SIZE / sizeof(word64) - 1] = sha512->loLen;
  ac:	e9c4 232e 	strd	r2, r3, [r4, #184]	; 0xb8
    ret = Transform_Sha512(sha512);
  b0:	f7ff fffe 	bl	0 <Sha512_Family_Final>
    if (ret != 0)
  b4:	b980      	cbnz	r0, d8 <Sha512_Family_Final+0xd8>
        ByteReverseWords64(sha512->digest, sha512->digest, WC_SHA512_DIGEST_SIZE);
  b6:	4621      	mov	r1, r4
  b8:	4620      	mov	r0, r4
  ba:	2240      	movs	r2, #64	; 0x40
  bc:	f7ff fffe 	bl	0 <Sha512_Family_Final>

    ret = Sha512Final(sha512);
    if (ret != 0)
        return ret;

    XMEMCPY(hash, sha512->digest, digestSz);
  c0:	4642      	mov	r2, r8
  c2:	4621      	mov	r1, r4
  c4:	4630      	mov	r0, r6
  c6:	f7ff fffe 	bl	0 <memcpy>

    /* initialize Sha512 structure for the next use */
    return initfp(sha512);
  ca:	4620      	mov	r0, r4
  cc:	463b      	mov	r3, r7
}
  ce:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    return initfp(sha512);
  d2:	4718      	bx	r3
        return BAD_FUNC_ARG;
  d4:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return BAD_STATE_E;
  dc:	f06f 00bf 	mvn.w	r0, #191	; 0xbf
  e0:	e7fa      	b.n	d8 <Sha512_Family_Final+0xd8>

Disassembly of section .text.wc_Sha512Final:

00000000 <wc_Sha512Final>:

int wc_Sha512Final(wc_Sha512* sha512, byte* hash)
{
    return Sha512_Family_Final(sha512, hash, WC_SHA512_DIGEST_SIZE, InitSha512);
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <wc_Sha512Final+0x8>)
   2:	2240      	movs	r2, #64	; 0x40
   4:	f7ff bffe 	b.w	0 <wc_Sha512Final>
   8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_Sha512_224Final:

00000000 <wc_Sha512_224Final>:
    return Sha512FinalRaw(sha, hash, WC_SHA512_224_DIGEST_SIZE);
}

int wc_Sha512_224Final(wc_Sha512* sha512, byte* hash)
{
    return Sha512_Family_Final(sha512, hash, WC_SHA512_224_DIGEST_SIZE,
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <wc_Sha512_224Final+0x8>)
   2:	221c      	movs	r2, #28
   4:	f7ff bffe 	b.w	0 <wc_Sha512_224Final>
   8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_Sha512_256Final:

00000000 <wc_Sha512_256Final>:
    return Sha512FinalRaw(sha, hash, WC_SHA512_256_DIGEST_SIZE);
}

int wc_Sha512_256Final(wc_Sha512* sha512, byte* hash)
{
    return Sha512_Family_Final(sha512, hash, WC_SHA512_256_DIGEST_SIZE,
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <wc_Sha512_256Final+0x8>)
   2:	2220      	movs	r2, #32
   4:	f7ff bffe 	b.w	0 <wc_Sha512_256Final>
   8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_InitSha512_ex:

00000000 <wc_InitSha512_ex>:
    if (sha512 == NULL) {
   0:	b118      	cbz	r0, a <wc_InitSha512_ex+0xa>
    sha512->heap = heap;
   2:	f8c0 10d8 	str.w	r1, [r0, #216]	; 0xd8
    ret = initfp(sha512);
   6:	f7ff bffe 	b.w	0 <wc_InitSha512_ex>
}
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   e:	4770      	bx	lr

Disassembly of section .text.wc_InitSha512_224_ex:

00000000 <wc_InitSha512_224_ex>:
    if (sha512 == NULL) {
   0:	b118      	cbz	r0, a <wc_InitSha512_224_ex+0xa>
    sha512->heap = heap;
   2:	f8c0 10d8 	str.w	r1, [r0, #216]	; 0xd8
    ret = initfp(sha512);
   6:	f7ff bffe 	b.w	0 <wc_InitSha512_224_ex>
}
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   e:	4770      	bx	lr

Disassembly of section .text.wc_InitSha512_256_ex:

00000000 <wc_InitSha512_256_ex>:
    if (sha512 == NULL) {
   0:	b118      	cbz	r0, a <wc_InitSha512_256_ex+0xa>
    sha512->heap = heap;
   2:	f8c0 10d8 	str.w	r1, [r0, #216]	; 0xd8
    ret = initfp(sha512);
   6:	f7ff bffe 	b.w	0 <wc_InitSha512_256_ex>
}
   a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
   e:	4770      	bx	lr

Disassembly of section .text.wc_Sha512Update:

00000000 <wc_Sha512Update>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	4614      	mov	r4, r2
    if (sha512 == NULL || (data == NULL && len > 0)) {
   8:	4605      	mov	r5, r0
   a:	2800      	cmp	r0, #0
   c:	d05c      	beq.n	c8 <wc_Sha512Update+0xc8>
   e:	b909      	cbnz	r1, 14 <wc_Sha512Update+0x14>
  10:	2a00      	cmp	r2, #0
  12:	d159      	bne.n	c8 <wc_Sha512Update+0xc8>
    if (sha512->buffLen >= WC_SHA512_BLOCK_SIZE)
  14:	f8d5 00c0 	ldr.w	r0, [r5, #192]	; 0xc0
  18:	287f      	cmp	r0, #127	; 0x7f
  1a:	d858      	bhi.n	ce <wc_Sha512Update+0xce>
    if (len == 0)
  1c:	b90c      	cbnz	r4, 22 <wc_Sha512Update+0x22>
        sha512->buffLen = len;
  1e:	2000      	movs	r0, #0
  20:	e050      	b.n	c4 <wc_Sha512Update+0xc4>
    if ( (sha512->loLen += len) < tmp)
  22:	e9d5 3232 	ldrd	r3, r2, [r5, #200]	; 0xc8
  26:	191b      	adds	r3, r3, r4
  28:	f152 0200 	adcs.w	r2, r2, #0
  2c:	f04f 0100 	mov.w	r1, #0
  30:	bf28      	it	cs
  32:	2101      	movcs	r1, #1
  34:	e9c5 3232 	strd	r3, r2, [r5, #200]	; 0xc8
  38:	b131      	cbz	r1, 48 <wc_Sha512Update+0x48>
        sha512->hiLen++;                       /* carry low to high */
  3a:	e9d5 3234 	ldrd	r3, r2, [r5, #208]	; 0xd0
  3e:	3301      	adds	r3, #1
  40:	f142 0200 	adc.w	r2, r2, #0
  44:	e9c5 3234 	strd	r3, r2, [r5, #208]	; 0xd0
    byte* local = (byte*)sha512->buffer;
  48:	f105 0740 	add.w	r7, r5, #64	; 0x40
    if (sha512->buffLen > 0) {
  4c:	b1e8      	cbz	r0, 8a <wc_Sha512Update+0x8a>
        word32 add = min(len, WC_SHA512_BLOCK_SIZE - sha512->buffLen);
  4e:	f1c0 0880 	rsb	r8, r0, #128	; 0x80
        #define min min
    #endif
    /* returns the smaller of a and b */
    WC_MISC_STATIC WC_INLINE word32 min(word32 a, word32 b)
    {
        return a > b ? b : a;
  52:	45a0      	cmp	r8, r4
  54:	bf28      	it	cs
  56:	46a0      	movcs	r8, r4
            XMEMCPY(&local[sha512->buffLen], data, add);
  58:	4642      	mov	r2, r8
  5a:	4631      	mov	r1, r6
  5c:	4438      	add	r0, r7
  5e:	f7ff fffe 	bl	0 <memcpy>
            sha512->buffLen += add;
  62:	f8d5 20c0 	ldr.w	r2, [r5, #192]	; 0xc0
  66:	4442      	add	r2, r8
        if (sha512->buffLen == WC_SHA512_BLOCK_SIZE) {
  68:	2a80      	cmp	r2, #128	; 0x80
            sha512->buffLen += add;
  6a:	f8c5 20c0 	str.w	r2, [r5, #192]	; 0xc0
            data            += add;
  6e:	4446      	add	r6, r8
            len             -= add;
  70:	eba4 0408 	sub.w	r4, r4, r8
        if (sha512->buffLen == WC_SHA512_BLOCK_SIZE) {
  74:	d109      	bne.n	8a <wc_Sha512Update+0x8a>
                ByteReverseWords64(sha512->buffer, sha512->buffer,
  76:	4638      	mov	r0, r7
  78:	4639      	mov	r1, r7
  7a:	f7ff fffe 	bl	0 <wc_Sha512Update>
            ret = Transform_Sha512(sha512);
  7e:	4628      	mov	r0, r5
  80:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret == 0)
  84:	b9f0      	cbnz	r0, c4 <wc_Sha512Update+0xc4>
                sha512->buffLen = 0;
  86:	f8c5 00c0 	str.w	r0, [r5, #192]	; 0xc0
  8a:	4426      	add	r6, r4
        while (len >= WC_SHA512_BLOCK_SIZE) {
  8c:	2c7f      	cmp	r4, #127	; 0x7f
  8e:	eba6 0104 	sub.w	r1, r6, r4
  92:	d808      	bhi.n	a6 <wc_Sha512Update+0xa6>
    if (ret == 0 && len > 0) {
  94:	2c00      	cmp	r4, #0
  96:	d0c2      	beq.n	1e <wc_Sha512Update+0x1e>
        XMEMCPY(local, data, len);
  98:	4622      	mov	r2, r4
  9a:	4638      	mov	r0, r7
  9c:	f7ff fffe 	bl	0 <memcpy>
        sha512->buffLen = len;
  a0:	f8c5 40c0 	str.w	r4, [r5, #192]	; 0xc0
  a4:	e7bb      	b.n	1e <wc_Sha512Update+0x1e>
            XMEMCPY(local, data, WC_SHA512_BLOCK_SIZE);
  a6:	2280      	movs	r2, #128	; 0x80
  a8:	4638      	mov	r0, r7
  aa:	f7ff fffe 	bl	0 <memcpy>
            ByteReverseWords64(sha512->buffer, sha512->buffer,
  ae:	4638      	mov	r0, r7
  b0:	2280      	movs	r2, #128	; 0x80
  b2:	4639      	mov	r1, r7
  b4:	f7ff fffe 	bl	0 <wc_Sha512Update>
            ret = Transform_Sha512(sha512);
  b8:	4628      	mov	r0, r5
            len  -= WC_SHA512_BLOCK_SIZE;
  ba:	3c80      	subs	r4, #128	; 0x80
            ret = Transform_Sha512(sha512);
  bc:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret != 0)
  c0:	2800      	cmp	r0, #0
  c2:	d0e3      	beq.n	8c <wc_Sha512Update+0x8c>
}
  c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return BAD_FUNC_ARG;
  c8:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  cc:	e7fa      	b.n	c4 <wc_Sha512Update+0xc4>
        return BUFFER_E;
  ce:	f06f 0083 	mvn.w	r0, #131	; 0x83
  d2:	e7f7      	b.n	c4 <wc_Sha512Update+0xc4>

Disassembly of section .text.wc_Sha512FinalRaw:

00000000 <wc_Sha512FinalRaw>:
    return Sha512FinalRaw(sha512, hash, WC_SHA512_DIGEST_SIZE);
   0:	2240      	movs	r2, #64	; 0x40
   2:	f7ff bffe 	b.w	0 <wc_Sha512FinalRaw>

Disassembly of section .text.wc_InitSha512:

00000000 <wc_InitSha512>:
    return wc_InitSha512_ex(sha512, NULL, devId);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_InitSha512>

Disassembly of section .text.wc_Sha512Free:

00000000 <wc_Sha512Free>:
    if (sha512 == NULL)
   0:	b120      	cbz	r0, c <wc_Sha512Free+0xc>
   2:	f100 03e0 	add.w	r3, r0, #224	; 0xe0
    while (len--) *z++ = 0;
   6:	2200      	movs	r2, #0
   8:	4298      	cmp	r0, r3
   a:	d100      	bne.n	e <wc_Sha512Free+0xe>
}
   c:	4770      	bx	lr
   e:	f800 2b01 	strb.w	r2, [r0], #1
  12:	e7f9      	b.n	8 <wc_Sha512Free+0x8>

Disassembly of section .text.wc_Sha512Copy:

00000000 <wc_Sha512Copy>:
{
   0:	b508      	push	{r3, lr}
   2:	460b      	mov	r3, r1
    if (src == NULL || dst == NULL) {
   4:	4601      	mov	r1, r0
   6:	b130      	cbz	r0, 16 <wc_Sha512Copy+0x16>
   8:	b12b      	cbz	r3, 16 <wc_Sha512Copy+0x16>
    XMEMCPY(dst, src, sizeof(wc_Sha512));
   a:	22e0      	movs	r2, #224	; 0xe0
   c:	4618      	mov	r0, r3
   e:	f7ff fffe 	bl	0 <memcpy>
    return ret;
  12:	2000      	movs	r0, #0
}
  14:	bd08      	pop	{r3, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1a:	e7fb      	b.n	14 <wc_Sha512Copy+0x14>

Disassembly of section .text.Sha512_Family_GetHash:

00000000 <Sha512_Family_GetHash>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460e      	mov	r6, r1
   4:	4617      	mov	r7, r2
    if (sha512 == NULL || hash == NULL) {
   6:	4604      	mov	r4, r0
   8:	b1b8      	cbz	r0, 3a <Sha512_Family_GetHash+0x3a>
   a:	b1b1      	cbz	r1, 3a <Sha512_Family_GetHash+0x3a>
    tmpSha512 = (wc_Sha512*)XMALLOC(sizeof(wc_Sha512), NULL,
   c:	20e0      	movs	r0, #224	; 0xe0
   e:	f7ff fffe 	bl	0 <malloc>
    if (tmpSha512 == NULL) {
  12:	4605      	mov	r5, r0
  14:	b1a0      	cbz	r0, 40 <Sha512_Family_GetHash+0x40>
    ret = wc_Sha512Copy(sha512, tmpSha512);
  16:	4601      	mov	r1, r0
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <Sha512_Family_GetHash>
    if (ret == 0) {
  1e:	4604      	mov	r4, r0
  20:	b930      	cbnz	r0, 30 <Sha512_Family_GetHash+0x30>
        ret = finalfp(tmpSha512, hash);
  22:	4631      	mov	r1, r6
  24:	4628      	mov	r0, r5
  26:	47b8      	blx	r7
  28:	4604      	mov	r4, r0
        wc_Sha512Free(tmpSha512);
  2a:	4628      	mov	r0, r5
  2c:	f7ff fffe 	bl	0 <Sha512_Family_GetHash>
    XFREE(tmpSha512, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  30:	4628      	mov	r0, r5
  32:	f7ff fffe 	bl	0 <free>
}
  36:	4620      	mov	r0, r4
  38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
  3a:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  3e:	e7fa      	b.n	36 <Sha512_Family_GetHash+0x36>
        return MEMORY_E;
  40:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  44:	e7f7      	b.n	36 <Sha512_Family_GetHash+0x36>

Disassembly of section .text.wc_Sha512GetHash:

00000000 <wc_Sha512GetHash>:
    return Sha512_Family_GetHash(sha512, hash, wc_Sha512Final);
   0:	4a01      	ldr	r2, [pc, #4]	; (8 <wc_Sha512GetHash+0x8>)
   2:	f7ff bffe 	b.w	0 <wc_Sha512GetHash>
   6:	bf00      	nop
   8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_InitSha512_224:

00000000 <wc_InitSha512_224>:
    return wc_InitSha512_224_ex(sha, NULL, INVALID_DEVID);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_InitSha512_224>

Disassembly of section .text.wc_Sha512_224Update:

00000000 <wc_Sha512_224Update>:
    return wc_Sha512Update(sha, data, len);
   0:	f7ff bffe 	b.w	0 <wc_Sha512_224Update>

Disassembly of section .text.wc_Sha512_224FinalRaw:

00000000 <wc_Sha512_224FinalRaw>:
    return Sha512FinalRaw(sha, hash, WC_SHA512_224_DIGEST_SIZE);
   0:	221c      	movs	r2, #28
   2:	f7ff bffe 	b.w	0 <wc_Sha512_224FinalRaw>

Disassembly of section .text.wc_Sha512_224Free:

00000000 <wc_Sha512_224Free>:
    wc_Sha512Free(sha);
   0:	f7ff bffe 	b.w	0 <wc_Sha512_224Free>

Disassembly of section .text.wc_Sha512_224GetHash:

00000000 <wc_Sha512_224GetHash>:
    return Sha512_Family_GetHash(sha512, hash, wc_Sha512_224Final);
   0:	4a01      	ldr	r2, [pc, #4]	; (8 <wc_Sha512_224GetHash+0x8>)
   2:	f7ff bffe 	b.w	0 <wc_Sha512_224GetHash>
   6:	bf00      	nop
   8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_Sha512_224Copy:

00000000 <wc_Sha512_224Copy>:
    return wc_Sha512Copy(src, dst);
   0:	f7ff bffe 	b.w	0 <wc_Sha512_224Copy>

Disassembly of section .text.wc_InitSha512_256:

00000000 <wc_InitSha512_256>:
    return wc_InitSha512_256_ex(sha, NULL, INVALID_DEVID);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_InitSha512_256>

Disassembly of section .text.wc_Sha512_256Update:

00000000 <wc_Sha512_256Update>:
   0:	f7ff bffe 	b.w	0 <wc_Sha512_256Update>

Disassembly of section .text.wc_Sha512_256FinalRaw:

00000000 <wc_Sha512_256FinalRaw>:
    return Sha512FinalRaw(sha, hash, WC_SHA512_256_DIGEST_SIZE);
   0:	2220      	movs	r2, #32
   2:	f7ff bffe 	b.w	0 <wc_Sha512_256FinalRaw>

Disassembly of section .text.wc_Sha512_256Free:

00000000 <wc_Sha512_256Free>:
   0:	f7ff bffe 	b.w	0 <wc_Sha512_256Free>

Disassembly of section .text.wc_Sha512_256GetHash:

00000000 <wc_Sha512_256GetHash>:
    /* functions defined in wolfcrypt/src/port/Renesas/renesas_fspsm_sha.c */

#else
int wc_Sha512_256GetHash(wc_Sha512* sha512, byte* hash)
{
    return Sha512_Family_GetHash(sha512, hash, wc_Sha512_256Final);
   0:	4a01      	ldr	r2, [pc, #4]	; (8 <wc_Sha512_256GetHash+0x8>)
   2:	f7ff bffe 	b.w	0 <wc_Sha512_256GetHash>
   6:	bf00      	nop
   8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_Sha512_256Copy:

00000000 <wc_Sha512_256Copy>:
   0:	f7ff bffe 	b.w	0 <wc_Sha512_256Copy>

sha3.o:     file format elf32-littlearm


asm.o:     file format elf32-littlearm


asn.o:     file format elf32-littlearm


Disassembly of section .text.GetBoolean:

00000000 <GetBoolean>:
 *         ASN_PARSE_E when the BOOLEAN tag is not found or length is not 1.
 *         Otherwise, 0 to indicate the value was false and 1 to indicate true.
 */
static int GetBoolean(const byte* input, word32* inOutIdx, word32 maxIdx)
{
    word32 idx = *inOutIdx;
   0:	680b      	ldr	r3, [r1, #0]
{
   2:	b530      	push	{r4, r5, lr}
    byte   b;

    if ((idx + 3) > maxIdx)
   4:	1cdc      	adds	r4, r3, #3
   6:	4294      	cmp	r4, r2
   8:	d80f      	bhi.n	2a <GetBoolean+0x2a>
        return BUFFER_E;

    b = input[idx++];
    if (b != ASN_BOOLEAN)
   a:	5cc5      	ldrb	r5, [r0, r3]
   c:	2d01      	cmp	r5, #1
    b = input[idx++];
   e:	f103 0201 	add.w	r2, r3, #1
    if (b != ASN_BOOLEAN)
  12:	d10d      	bne.n	30 <GetBoolean+0x30>
        return ASN_PARSE_E;

    if (input[idx++] != 1)
  14:	5c82      	ldrb	r2, [r0, r2]
  16:	2a01      	cmp	r2, #1
  18:	f103 0302 	add.w	r3, r3, #2
  1c:	d108      	bne.n	30 <GetBoolean+0x30>
        return ASN_PARSE_E;

    b = input[idx++] != 0;
  1e:	5cc0      	ldrb	r0, [r0, r3]

    *inOutIdx = idx;
  20:	600c      	str	r4, [r1, #0]
    return b;
  22:	3800      	subs	r0, #0
  24:	bf18      	it	ne
  26:	2001      	movne	r0, #1
}
  28:	bd30      	pop	{r4, r5, pc}
        return BUFFER_E;
  2a:	f06f 0083 	mvn.w	r0, #131	; 0x83
  2e:	e7fb      	b.n	28 <GetBoolean+0x28>
        return ASN_PARSE_E;
  30:	f06f 008b 	mvn.w	r0, #139	; 0x8b
  34:	e7f8      	b.n	28 <GetBoolean+0x28>

Disassembly of section .text.GetTime:

00000000 <GetTime>:

#ifndef NO_ASN_TIME

/* two byte date/time, add to value */
static WC_INLINE int GetTime(int* value, const byte* date, int* idx)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    int i = *idx;
   2:	6813      	ldr	r3, [r2, #0]

    if (date[i] < 0x30 || date[i] > 0x39 || date[i+1] < 0x30 ||
   4:	5ccc      	ldrb	r4, [r1, r3]
   6:	f1a4 0530 	sub.w	r5, r4, #48	; 0x30
   a:	b2ec      	uxtb	r4, r5
   c:	2c09      	cmp	r4, #9
   e:	d811      	bhi.n	34 <GetTime+0x34>
  10:	1c5e      	adds	r6, r3, #1
  12:	5d8c      	ldrb	r4, [r1, r6]
  14:	3c30      	subs	r4, #48	; 0x30
  16:	2c09      	cmp	r4, #9
  18:	d80c      	bhi.n	34 <GetTime+0x34>
                                                             date[i+1] > 0x39) {
        return ASN_PARSE_E;
    }

    *value += (int)btoi(date[i++]) * 10;
  1a:	6804      	ldr	r4, [r0, #0]
  1c:	270a      	movs	r7, #10
  1e:	fb07 4405 	mla	r4, r7, r5, r4
  22:	6004      	str	r4, [r0, #0]
}


WC_MISC_STATIC WC_INLINE word32 btoi(byte b)
{
    return (word32)(b - 0x30);
  24:	5d89      	ldrb	r1, [r1, r6]
  26:	3930      	subs	r1, #48	; 0x30
    *value += (int)btoi(date[i++]);
  28:	4421      	add	r1, r4
  2a:	3302      	adds	r3, #2
  2c:	6001      	str	r1, [r0, #0]

    *idx = i;
  2e:	6013      	str	r3, [r2, #0]

    return 0;
  30:	2000      	movs	r0, #0
}
  32:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ASN_PARSE_E;
  34:	f06f 008b 	mvn.w	r0, #139	; 0x8b
  38:	e7fb      	b.n	32 <GetTime+0x32>

Disassembly of section .text.trim_leading_zeros:

00000000 <trim_leading_zeros>:
    if (sz > 0)
        c = input[0];
    return (c & 0x80) != 0;
}
static word32 trim_leading_zeros(const byte** input, word32 sz)
{
   0:	b530      	push	{r4, r5, lr}
    int i;
    word32 leadingZeroCount = 0;
    const byte* tmp = *input;
   2:	6802      	ldr	r2, [r0, #0]
    for (i=0; i<(int)sz; i++) {
   4:	2300      	movs	r3, #0
   6:	4299      	cmp	r1, r3
   8:	461c      	mov	r4, r3
   a:	dd01      	ble.n	10 <trim_leading_zeros+0x10>
        if (tmp[i] != 0)
   c:	5cd5      	ldrb	r5, [r2, r3]
   e:	b125      	cbz	r5, 1a <trim_leading_zeros+0x1a>
            break;
        leadingZeroCount++;
    }
    /* catch all zero case */
    if (sz > 0 && leadingZeroCount == sz) {
  10:	b929      	cbnz	r1, 1e <trim_leading_zeros+0x1e>
        leadingZeroCount--;
    }
    *input += leadingZeroCount;
  12:	4422      	add	r2, r4
  14:	6002      	str	r2, [r0, #0]
    sz -= leadingZeroCount;
    return sz;
}
  16:	1b08      	subs	r0, r1, r4
  18:	bd30      	pop	{r4, r5, pc}
    for (i=0; i<(int)sz; i++) {
  1a:	3301      	adds	r3, #1
  1c:	e7f3      	b.n	6 <trim_leading_zeros+0x6>
    if (sz > 0 && leadingZeroCount == sz) {
  1e:	4299      	cmp	r1, r3
        leadingZeroCount--;
  20:	bf08      	it	eq
  22:	f101 34ff 	addeq.w	r4, r1, #4294967295	; 0xffffffff
  26:	e7f4      	b.n	12 <trim_leading_zeros+0x12>

Disassembly of section .text.CheckCurve:

00000000 <CheckCurve>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    ret = wc_ecc_get_oid(oid, NULL, &oidSz);
   2:	2100      	movs	r1, #0
   4:	aa01      	add	r2, sp, #4
   6:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
    if ((ret < 0) || (oidSz == 0)) {
   a:	2800      	cmp	r0, #0
   c:	db07      	blt.n	1e <CheckCurve+0x1e>
   e:	9b01      	ldr	r3, [sp, #4]
        ret = ECC_CURVE_OID_E;
  10:	2b00      	cmp	r3, #0
  12:	bf08      	it	eq
  14:	f06f 00ab 	mvneq.w	r0, #171	; 0xab
}
  18:	b003      	add	sp, #12
  1a:	f85d fb04 	ldr.w	pc, [sp], #4
        ret = ECC_CURVE_OID_E;
  1e:	f06f 00ab 	mvn.w	r0, #171	; 0xab
  22:	e7f9      	b.n	18 <CheckCurve+0x18>

Disassembly of section .text.MatchBaseName:

00000000 <MatchBaseName>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
   4:	4614      	mov	r4, r2
   6:	4608      	mov	r0, r1
   8:	9a06      	ldr	r2, [sp, #24]
    if (base == NULL || baseSz <= 0 || name == NULL || nameSz <= 0 ||
   a:	4619      	mov	r1, r3
   c:	2b00      	cmp	r3, #0
   e:	d052      	beq.n	b6 <MatchBaseName+0xb6>
  10:	2a00      	cmp	r2, #0
  12:	dd50      	ble.n	b6 <MatchBaseName+0xb6>
  14:	b180      	cbz	r0, 38 <MatchBaseName+0x38>
  16:	2c00      	cmp	r4, #0
  18:	dd4d      	ble.n	b6 <MatchBaseName+0xb6>
  1a:	7803      	ldrb	r3, [r0, #0]
  1c:	2b2e      	cmp	r3, #46	; 0x2e
  1e:	d04a      	beq.n	b6 <MatchBaseName+0xb6>
            name[0] == '.' || nameSz < baseSz ||
  20:	42a2      	cmp	r2, r4
  22:	dc48      	bgt.n	b6 <MatchBaseName+0xb6>
            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE &&
  24:	1e6b      	subs	r3, r5, #1
            name[0] == '.' || nameSz < baseSz ||
  26:	2b01      	cmp	r3, #1
  28:	d907      	bls.n	3a <MatchBaseName+0x3a>
            (type != ASN_RFC822_TYPE && type != ASN_DNS_TYPE &&
  2a:	2d04      	cmp	r5, #4
  2c:	d143      	bne.n	b6 <MatchBaseName+0xb6>
        return XMEMCMP(name, base, (size_t)baseSz) == 0;
  2e:	f7ff fffe 	bl	0 <memcmp>
  32:	fab0 f080 	clz	r0, r0
  36:	0940      	lsrs	r0, r0, #5
}
  38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (type == ASN_RFC822_TYPE) {
  3a:	2d01      	cmp	r5, #1
  3c:	d10f      	bne.n	5e <MatchBaseName+0x5e>
        if (base[0] != '.') {
  3e:	780e      	ldrb	r6, [r1, #0]
  40:	2e2e      	cmp	r6, #46	; 0x2e
  42:	d117      	bne.n	74 <MatchBaseName+0x74>
  44:	4605      	mov	r5, r0
            count = 0;
  46:	2300      	movs	r3, #0
  48:	462f      	mov	r7, r5
            while (*p != '@' && count < baseSz) {
  4a:	3501      	adds	r5, #1
  4c:	f897 c000 	ldrb.w	ip, [r7]
  50:	f1bc 0f40 	cmp.w	ip, #64	; 0x40
  54:	d031      	beq.n	ba <MatchBaseName+0xba>
  56:	4293      	cmp	r3, r2
  58:	d117      	bne.n	8a <MatchBaseName+0x8a>
    if (type == ASN_DNS_TYPE || (type == ASN_RFC822_TYPE && base[0] == '.')) {
  5a:	2e2e      	cmp	r6, #46	; 0x2e
  5c:	d10e      	bne.n	7c <MatchBaseName+0x7c>
        int szAdjust = nameSz - baseSz;
  5e:	1aa4      	subs	r4, r4, r2
        name += szAdjust;
  60:	4420      	add	r0, r4
  62:	4614      	mov	r4, r2
  64:	e00a      	b.n	7c <MatchBaseName+0x7c>
                count++;
  66:	3301      	adds	r3, #1
            while (*p != '@' && count < baseSz) {
  68:	5ccd      	ldrb	r5, [r1, r3]
  6a:	2d40      	cmp	r5, #64	; 0x40
  6c:	d004      	beq.n	78 <MatchBaseName+0x78>
  6e:	4293      	cmp	r3, r2
  70:	d1f9      	bne.n	66 <MatchBaseName+0x66>
  72:	e7e7      	b.n	44 <MatchBaseName+0x44>
            count = 0;
  74:	2300      	movs	r3, #0
  76:	e7f7      	b.n	68 <MatchBaseName+0x68>
            if (count >= baseSz)
  78:	4293      	cmp	r3, r2
  7a:	dae3      	bge.n	44 <MatchBaseName+0x44>
        if (XTOLOWER((unsigned char)*name) !=
  7c:	4b12      	ldr	r3, [pc, #72]	; (c8 <MatchBaseName+0xc8>)
  7e:	3901      	subs	r1, #1
  80:	3801      	subs	r0, #1
    while (nameSz > 0) {
  82:	2c00      	cmp	r4, #0
  84:	dc03      	bgt.n	8e <MatchBaseName+0x8e>
    return 1;
  86:	2001      	movs	r0, #1
  88:	e7d6      	b.n	38 <MatchBaseName+0x38>
                count++;
  8a:	3301      	adds	r3, #1
                p++;
  8c:	e7dc      	b.n	48 <MatchBaseName+0x48>
        if (XTOLOWER((unsigned char)*name) !=
  8e:	f810 5f01 	ldrb.w	r5, [r0, #1]!
  92:	5cea      	ldrb	r2, [r5, r3]
  94:	f002 0203 	and.w	r2, r2, #3
  98:	2a01      	cmp	r2, #1
                                               XTOLOWER((unsigned char)*base))
  9a:	f811 2f01 	ldrb.w	r2, [r1, #1]!
  9e:	5c9e      	ldrb	r6, [r3, r2]
  a0:	f006 0603 	and.w	r6, r6, #3
        if (XTOLOWER((unsigned char)*name) !=
  a4:	bf08      	it	eq
  a6:	3520      	addeq	r5, #32
                                               XTOLOWER((unsigned char)*base))
  a8:	2e01      	cmp	r6, #1
  aa:	bf08      	it	eq
  ac:	3220      	addeq	r2, #32
        if (XTOLOWER((unsigned char)*name) !=
  ae:	4295      	cmp	r5, r2
  b0:	d101      	bne.n	b6 <MatchBaseName+0xb6>
        nameSz--;
  b2:	3c01      	subs	r4, #1
  b4:	e7e5      	b.n	82 <MatchBaseName+0x82>
        return 0;
  b6:	2000      	movs	r0, #0
  b8:	e7be      	b.n	38 <MatchBaseName+0x38>
            if (count < baseSz && *p == '@') {
  ba:	4293      	cmp	r3, r2
  bc:	dacd      	bge.n	5a <MatchBaseName+0x5a>
                nameSz -= count + 1;
  be:	3301      	adds	r3, #1
                name = p + 1;
  c0:	1c78      	adds	r0, r7, #1
                nameSz -= count + 1;
  c2:	1ae4      	subs	r4, r4, r3
  c4:	e7c9      	b.n	5a <MatchBaseName+0x5a>
  c6:	bf00      	nop
  c8:	00000001 	.word	0x00000001

Disassembly of section .text.IsInExcludedList:

00000000 <IsInExcludedList>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	460c      	mov	r4, r1
   6:	4616      	mov	r6, r2
    while (current != NULL) {
   8:	b914      	cbnz	r4, 10 <IsInExcludedList+0x10>
    int ret = 0; /* default of not found in the list */
   a:	4620      	mov	r0, r4
}
   c:	b002      	add	sp, #8
   e:	bd70      	pop	{r4, r5, r6, pc}
        if (current->type == nameType) {
  10:	7b23      	ldrb	r3, [r4, #12]
  12:	42b3      	cmp	r3, r6
  14:	d001      	beq.n	1a <IsInExcludedList+0x1a>
        current = current->next;
  16:	6824      	ldr	r4, [r4, #0]
  18:	e7f6      	b.n	8 <IsInExcludedList+0x8>
            if (name->len >= current->nameSz &&
  1a:	68aa      	ldr	r2, [r5, #8]
  1c:	68a3      	ldr	r3, [r4, #8]
  1e:	429a      	cmp	r2, r3
  20:	dbf9      	blt.n	16 <IsInExcludedList+0x16>
                MatchBaseName(nameType, name->name, name->len,
  22:	9300      	str	r3, [sp, #0]
  24:	6863      	ldr	r3, [r4, #4]
  26:	68e9      	ldr	r1, [r5, #12]
  28:	4630      	mov	r0, r6
  2a:	f7ff fffe 	bl	0 <IsInExcludedList>
            if (name->len >= current->nameSz &&
  2e:	2800      	cmp	r0, #0
  30:	d0f1      	beq.n	16 <IsInExcludedList+0x16>
                ret = 1;
  32:	2001      	movs	r0, #1
    return ret;
  34:	e7ea      	b.n	c <IsInExcludedList+0xc>

Disassembly of section .text.PermittedListOk:

00000000 <PermittedListOk>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    int need  = 0;
   2:	2300      	movs	r3, #0
{
   4:	4605      	mov	r5, r0
   6:	460c      	mov	r4, r1
   8:	4616      	mov	r6, r2
    while (current != NULL) {
   a:	b91c      	cbnz	r4, 14 <PermittedListOk+0x14>
    if (need && !match)
   c:	f1c3 0001 	rsb	r0, r3, #1
}
  10:	b002      	add	sp, #8
  12:	bd70      	pop	{r4, r5, r6, pc}
        if (current->type == nameType) {
  14:	7b22      	ldrb	r2, [r4, #12]
  16:	42b2      	cmp	r2, r6
  18:	d104      	bne.n	24 <PermittedListOk+0x24>
            if (name->len >= current->nameSz &&
  1a:	68aa      	ldr	r2, [r5, #8]
  1c:	68a3      	ldr	r3, [r4, #8]
  1e:	429a      	cmp	r2, r3
  20:	da02      	bge.n	28 <PermittedListOk+0x28>
            need = 1; /* restriction on permitted names is set for this type */
  22:	2301      	movs	r3, #1
        current = current->next;
  24:	6824      	ldr	r4, [r4, #0]
  26:	e7f0      	b.n	a <PermittedListOk+0xa>
                MatchBaseName(nameType, name->name, name->len,
  28:	9300      	str	r3, [sp, #0]
  2a:	6863      	ldr	r3, [r4, #4]
  2c:	68e9      	ldr	r1, [r5, #12]
  2e:	4630      	mov	r0, r6
  30:	f7ff fffe 	bl	0 <PermittedListOk>
            if (name->len >= current->nameSz &&
  34:	2800      	cmp	r0, #0
  36:	d0f4      	beq.n	22 <PermittedListOk+0x22>
                match = 1; /* found the current name in the permitted list*/
  38:	2001      	movs	r0, #1
    return ret;
  3a:	e7e9      	b.n	10 <PermittedListOk+0x10>

Disassembly of section .text.SetASNLength:

00000000 <SetASNLength>:
    if (length < ASN_LONG_LENGTH)
   0:	287f      	cmp	r0, #127	; 0x7f
{
   2:	b510      	push	{r4, lr}
    if (length < ASN_LONG_LENGTH)
   4:	d913      	bls.n	2e <SetASNLength+0x2e>
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
   6:	0c03      	lsrs	r3, r0, #16
   8:	d114      	bne.n	34 <SetASNLength+0x34>
   a:	0a03      	lsrs	r3, r0, #8
   c:	bf0c      	ite	eq
   e:	2301      	moveq	r3, #1
  10:	2302      	movne	r3, #2
        output[i++] = (byte)(BytePrecision(length) | ASN_LONG_LENGTH);
  12:	f063 027f 	orn	r2, r3, #127	; 0x7f
  16:	700a      	strb	r2, [r1, #0]
        for (j = BytePrecision(length); j; --j) {
  18:	461a      	mov	r2, r3
            output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
  1a:	3a01      	subs	r2, #1
  1c:	00d4      	lsls	r4, r2, #3
  1e:	fa20 f404 	lsr.w	r4, r0, r4
  22:	f801 4f01 	strb.w	r4, [r1, #1]!
        for (j = BytePrecision(length); j; --j) {
  26:	2a00      	cmp	r2, #0
  28:	d1f7      	bne.n	1a <SetASNLength+0x1a>
            i++;
  2a:	1c58      	adds	r0, r3, #1
    return i;
  2c:	e001      	b.n	32 <SetASNLength+0x32>
        output[i++] = (byte)length;
  2e:	7008      	strb	r0, [r1, #0]
  30:	2001      	movs	r0, #1
}
  32:	bd10      	pop	{r4, pc}
    for (i = (word32)sizeof(value) - 1; i; --i)
  34:	2303      	movs	r3, #3
  36:	e7ec      	b.n	12 <SetASNLength+0x12>

Disassembly of section .text.GetLength_ex:

00000000 <GetLength_ex>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    word32  idx = (word32)*inOutIdx;
   2:	680f      	ldr	r7, [r1, #0]
    if ((idx + 1) > maxIdx) {
   4:	1c7e      	adds	r6, r7, #1
    *len = 0;
   6:	2400      	movs	r4, #0
    if ((idx + 1) > maxIdx) {
   8:	429e      	cmp	r6, r3
{
   a:	4605      	mov	r5, r0
    *len = 0;
   c:	6014      	str	r4, [r2, #0]
    if ((idx + 1) > maxIdx) {
   e:	d82f      	bhi.n	70 <GetLength_ex+0x70>
    if (b >= ASN_LONG_LENGTH) {
  10:	57ed      	ldrsb	r5, [r5, r7]
  12:	42a5      	cmp	r5, r4
    b = input[idx++];
  14:	eb00 0c07 	add.w	ip, r0, r7
  18:	5dc0      	ldrb	r0, [r0, r7]
    if (b >= ASN_LONG_LENGTH) {
  1a:	da15      	bge.n	48 <GetLength_ex+0x48>
        if (b == ASN_INDEF_LENGTH) {
  1c:	2880      	cmp	r0, #128	; 0x80
  1e:	f000 057f 	and.w	r5, r0, #127	; 0x7f
  22:	d007      	beq.n	34 <GetLength_ex+0x34>
        else if (bytes == 1) {
  24:	2d01      	cmp	r5, #1
  26:	d019      	beq.n	5c <GetLength_ex+0x5c>
        else if (bytes > sizeof(length)) {
  28:	2d04      	cmp	r5, #4
  2a:	d81e      	bhi.n	6a <GetLength_ex+0x6a>
            minLen = 1 << ((bytes - 1) * 8);
  2c:	1e6c      	subs	r4, r5, #1
  2e:	00e0      	lsls	r0, r4, #3
  30:	2401      	movs	r4, #1
  32:	4084      	lsls	r4, r0
        if ((idx + bytes) > maxIdx) {
  34:	442e      	add	r6, r5
  36:	429e      	cmp	r6, r3
  38:	d81a      	bhi.n	70 <GetLength_ex+0x70>
    int     length = 0;
  3a:	2000      	movs	r0, #0
        while (bytes--) {
  3c:	3d01      	subs	r5, #1
  3e:	d20f      	bcs.n	60 <GetLength_ex+0x60>
        if (length < 0) {
  40:	2800      	cmp	r0, #0
  42:	db12      	blt.n	6a <GetLength_ex+0x6a>
        if (length < minLen) {
  44:	42a0      	cmp	r0, r4
  46:	db10      	blt.n	6a <GetLength_ex+0x6a>
    if (check && ((idx + (word32)length) > maxIdx)) {
  48:	9c05      	ldr	r4, [sp, #20]
  4a:	b114      	cbz	r4, 52 <GetLength_ex+0x52>
  4c:	1984      	adds	r4, r0, r6
  4e:	429c      	cmp	r4, r3
  50:	d80e      	bhi.n	70 <GetLength_ex+0x70>
    if (length > 0) {
  52:	2800      	cmp	r0, #0
    *inOutIdx = idx;
  54:	600e      	str	r6, [r1, #0]
    if (length > 0) {
  56:	dd00      	ble.n	5a <GetLength_ex+0x5a>
        *len = length;
  58:	6010      	str	r0, [r2, #0]
}
  5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
            minLen = 0x80;
  5c:	2480      	movs	r4, #128	; 0x80
  5e:	e7e9      	b.n	34 <GetLength_ex+0x34>
            length = (length << 8) | b;
  60:	f81c ef01 	ldrb.w	lr, [ip, #1]!
  64:	ea4e 2000 	orr.w	r0, lr, r0, lsl #8
  68:	e7e8      	b.n	3c <GetLength_ex+0x3c>
            return ASN_PARSE_E;
  6a:	f06f 008b 	mvn.w	r0, #139	; 0x8b
  6e:	e7f4      	b.n	5a <GetLength_ex+0x5a>
        return BUFFER_E;
  70:	f06f 0083 	mvn.w	r0, #131	; 0x83
  74:	e7f1      	b.n	5a <GetLength_ex+0x5a>

Disassembly of section .text.GetLength:

00000000 <GetLength>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetLength_ex(input, inOutIdx, len, maxIdx, 1);
   2:	2401      	movs	r4, #1
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <GetLength>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetDateInfo:

00000000 <GetDateInfo>:
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	461f      	mov	r7, r3
   6:	460c      	mov	r4, r1
   8:	e9dd 830a 	ldrd	r8, r3, [sp, #40]	; 0x28
   c:	4616      	mov	r6, r2
    if (source == NULL || idx == NULL)
   e:	4605      	mov	r5, r0
  10:	b348      	cbz	r0, 66 <GetDateInfo+0x66>
    if (*idx+1 > maxIdx)
  12:	f8d1 c000 	ldr.w	ip, [r1]
  16:	f10c 0201 	add.w	r2, ip, #1
  1a:	429a      	cmp	r2, r3
  1c:	d826      	bhi.n	6c <GetDateInfo+0x6c>
    format = source[*idx];
  1e:	f810 900c 	ldrb.w	r9, [r0, ip]
    *idx += 1;
  22:	600a      	str	r2, [r1, #0]
    if (format != ASN_UTC_TIME && format != ASN_GENERALIZED_TIME) {
  24:	f1a9 0217 	sub.w	r2, r9, #23
  28:	2a01      	cmp	r2, #1
  2a:	d822      	bhi.n	72 <GetDateInfo+0x72>
    if (GetLength(source, idx, &length, maxIdx) < 0)
  2c:	aa01      	add	r2, sp, #4
  2e:	f7ff fffe 	bl	0 <GetDateInfo>
  32:	2800      	cmp	r0, #0
  34:	db20      	blt.n	78 <GetDateInfo+0x78>
    if (length > MAX_DATE_SIZE || length < MIN_DATE_SIZE)
  36:	9a01      	ldr	r2, [sp, #4]
  38:	f1a2 030c 	sub.w	r3, r2, #12
  3c:	2b14      	cmp	r3, #20
  3e:	d81e      	bhi.n	7e <GetDateInfo+0x7e>
    if (pFormat)
  40:	b10f      	cbz	r7, 46 <GetDateInfo+0x46>
        *pFormat = format;
  42:	f887 9000 	strb.w	r9, [r7]
    if (pDate)
  46:	b116      	cbz	r6, 4e <GetDateInfo+0x4e>
        *pDate = &source[*idx];
  48:	6820      	ldr	r0, [r4, #0]
  4a:	4405      	add	r5, r0
  4c:	6035      	str	r5, [r6, #0]
    if (pLength)
  4e:	f1b8 0f00 	cmp.w	r8, #0
  52:	d001      	beq.n	58 <GetDateInfo+0x58>
        *pLength = length;
  54:	f8c8 2000 	str.w	r2, [r8]
    *idx += (word32)length;
  58:	6823      	ldr	r3, [r4, #0]
  5a:	4413      	add	r3, r2
  5c:	6023      	str	r3, [r4, #0]
    return 0;
  5e:	2000      	movs	r0, #0
}
  60:	b003      	add	sp, #12
  62:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return BAD_FUNC_ARG;
  66:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  6a:	e7f9      	b.n	60 <GetDateInfo+0x60>
        return BUFFER_E;
  6c:	f06f 0083 	mvn.w	r0, #131	; 0x83
  70:	e7f6      	b.n	60 <GetDateInfo+0x60>
        return ASN_TIME_E;
  72:	f06f 0098 	mvn.w	r0, #152	; 0x98
  76:	e7f3      	b.n	60 <GetDateInfo+0x60>
        return ASN_PARSE_E;
  78:	f06f 008b 	mvn.w	r0, #139	; 0x8b
  7c:	e7f0      	b.n	60 <GetDateInfo+0x60>
        return ASN_DATE_SZ_E;
  7e:	f06f 0094 	mvn.w	r0, #148	; 0x94
  82:	e7ed      	b.n	60 <GetDateInfo+0x60>

Disassembly of section .text.GetASNTag:

00000000 <GetASNTag>:
{
   0:	b530      	push	{r4, r5, lr}
    if ((tag == NULL) || (inOutIdx == NULL) || (input == NULL)) {
   2:	b152      	cbz	r2, 1a <GetASNTag+0x1a>
   4:	b149      	cbz	r1, 1a <GetASNTag+0x1a>
   6:	b140      	cbz	r0, 1a <GetASNTag+0x1a>
        idx = *inOutIdx;
   8:	680d      	ldr	r5, [r1, #0]
        if (idx + ASN_TAG_SZ > maxIdx) {
   a:	1c6c      	adds	r4, r5, #1
   c:	429c      	cmp	r4, r3
   e:	d807      	bhi.n	20 <GetASNTag+0x20>
        *tag = input[idx];
  10:	5d43      	ldrb	r3, [r0, r5]
  12:	7013      	strb	r3, [r2, #0]
        *inOutIdx = idx + ASN_TAG_SZ;
  14:	2000      	movs	r0, #0
  16:	600c      	str	r4, [r1, #0]
}
  18:	bd30      	pop	{r4, r5, pc}
        ret = BAD_FUNC_ARG;
  1a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1e:	e7fb      	b.n	18 <GetASNTag+0x18>
            ret = BUFFER_E;
  20:	f06f 0083 	mvn.w	r0, #131	; 0x83
    return ret;
  24:	e7f8      	b.n	18 <GetASNTag+0x18>

Disassembly of section .text.GetASNHeader_ex:

00000000 <GetASNHeader_ex>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b086      	sub	sp, #24
   6:	461d      	mov	r5, r3
   8:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    word32 idx = *inOutIdx;
   c:	6813      	ldr	r3, [r2, #0]
   e:	9304      	str	r3, [sp, #16]
    int    length = 0;
  10:	2300      	movs	r3, #0
{
  12:	460f      	mov	r7, r1
  14:	4614      	mov	r4, r2
    int    length = 0;
  16:	9305      	str	r3, [sp, #20]
    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0) {
  18:	f10d 020f 	add.w	r2, sp, #15
  1c:	4643      	mov	r3, r8
  1e:	a904      	add	r1, sp, #16
{
  20:	4606      	mov	r6, r0
    if (GetASNTag(input, &idx, &tagFound, maxIdx) != 0) {
  22:	f7ff fffe 	bl	0 <GetASNHeader_ex>
  26:	b120      	cbz	r0, 32 <GetASNHeader_ex+0x32>
{
  28:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
  2c:	b006      	add	sp, #24
  2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((ret == 0) && (tagFound != tag)) {
  32:	f89d 300f 	ldrb.w	r3, [sp, #15]
  36:	42bb      	cmp	r3, r7
  38:	d1f6      	bne.n	28 <GetASNHeader_ex+0x28>
    if ((ret == 0) && (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)) {
  3a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  3c:	9300      	str	r3, [sp, #0]
  3e:	aa05      	add	r2, sp, #20
  40:	4643      	mov	r3, r8
  42:	4630      	mov	r0, r6
  44:	f7ff fffe 	bl	0 <GetASNHeader_ex>
  48:	2800      	cmp	r0, #0
  4a:	dbed      	blt.n	28 <GetASNHeader_ex+0x28>
        *len      = length;
  4c:	9805      	ldr	r0, [sp, #20]
        *inOutIdx = idx;
  4e:	9b04      	ldr	r3, [sp, #16]
        *len      = length;
  50:	6028      	str	r0, [r5, #0]
        *inOutIdx = idx;
  52:	6023      	str	r3, [r4, #0]
    return ret;
  54:	e7ea      	b.n	2c <GetASNHeader_ex+0x2c>

Disassembly of section .text.GetSequence:

00000000 <GetSequence>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
   2:	2401      	movs	r4, #1
   4:	e9cd 3400 	strd	r3, r4, [sp]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	2130      	movs	r1, #48	; 0x30
   e:	f7ff fffe 	bl	0 <GetSequence>
}
  12:	b002      	add	sp, #8
  14:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetSequence_ex:

00000000 <GetSequence_ex>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetASNHeader_ex(input, ASN_SEQUENCE | ASN_CONSTRUCTED, inOutIdx, len,
   2:	9c04      	ldr	r4, [sp, #16]
   4:	e9cd 3400 	strd	r3, r4, [sp]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	2130      	movs	r1, #48	; 0x30
   e:	f7ff fffe 	bl	0 <GetSequence_ex>
}
  12:	b002      	add	sp, #8
  14:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetSet:

00000000 <GetSet>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
   2:	2401      	movs	r4, #1
   4:	e9cd 3400 	strd	r3, r4, [sp]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	2131      	movs	r1, #49	; 0x31
   e:	f7ff fffe 	bl	0 <GetSet>
}
  12:	b002      	add	sp, #8
  14:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetSet_ex:

00000000 <GetSet_ex>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetASNHeader_ex(input, ASN_SET | ASN_CONSTRUCTED, inOutIdx, len,
   2:	9c04      	ldr	r4, [sp, #16]
   4:	e9cd 3400 	strd	r3, r4, [sp]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	2131      	movs	r1, #49	; 0x31
   e:	f7ff fffe 	bl	0 <GetSet_ex>
}
  12:	b002      	add	sp, #8
  14:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetOctetString:

00000000 <GetOctetString>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
   2:	2401      	movs	r4, #1
   4:	e9cd 3400 	strd	r3, r4, [sp]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	2104      	movs	r1, #4
   e:	f7ff fffe 	bl	0 <GetOctetString>
}
  12:	b002      	add	sp, #8
  14:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetASNInt:

00000000 <GetASNInt>:
{
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2:	4616      	mov	r6, r2
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
   4:	2201      	movs	r2, #1
   6:	e9cd 3200 	strd	r3, r2, [sp]
{
   a:	460d      	mov	r5, r1
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
   c:	460a      	mov	r2, r1
   e:	4633      	mov	r3, r6
  10:	2102      	movs	r1, #2
{
  12:	4607      	mov	r7, r0
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
  14:	f7ff fffe 	bl	0 <GetASNInt>
    if (ret < 0)
  18:	2800      	cmp	r0, #0
  1a:	db0f      	blt.n	3c <GetASNInt+0x3c>
    if (*len > 0) {
  1c:	6832      	ldr	r2, [r6, #0]
  1e:	2a00      	cmp	r2, #0
  20:	dd1a      	ble.n	58 <GetASNInt+0x58>
            if ((input[*inOutIdx] == 0xff) && (input[*inOutIdx + 1] & 0x80))
  22:	682c      	ldr	r4, [r5, #0]
        if (*len > 1) {
  24:	2a01      	cmp	r2, #1
            if ((input[*inOutIdx] == 0xff) && (input[*inOutIdx + 1] & 0x80))
  26:	5d3b      	ldrb	r3, [r7, r4]
        if (*len > 1) {
  28:	d016      	beq.n	58 <GetASNInt+0x58>
            if ((input[*inOutIdx] == 0xff) && (input[*inOutIdx + 1] & 0x80))
  2a:	2bff      	cmp	r3, #255	; 0xff
  2c:	d108      	bne.n	40 <GetASNInt+0x40>
  2e:	443c      	add	r4, r7
  30:	f994 3001 	ldrsb.w	r3, [r4, #1]
  34:	2b00      	cmp	r3, #0
  36:	da0f      	bge.n	58 <GetASNInt+0x58>
                return ASN_PARSE_E;
  38:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
  3c:	b003      	add	sp, #12
  3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if ((input[*inOutIdx] == 0x00) && (*len > 1)) {
  40:	b953      	cbnz	r3, 58 <GetASNInt+0x58>
            (*inOutIdx)++;
  42:	3401      	adds	r4, #1
  44:	602c      	str	r4, [r5, #0]
            (*len)--;
  46:	6833      	ldr	r3, [r6, #0]
  48:	3b01      	subs	r3, #1
            if (*len > 0 && (input[*inOutIdx] & 0x80) == 0)
  4a:	2b00      	cmp	r3, #0
            (*len)--;
  4c:	6033      	str	r3, [r6, #0]
            if (*len > 0 && (input[*inOutIdx] & 0x80) == 0)
  4e:	dd03      	ble.n	58 <GetASNInt+0x58>
  50:	682b      	ldr	r3, [r5, #0]
  52:	56fb      	ldrsb	r3, [r7, r3]
  54:	2b00      	cmp	r3, #0
  56:	daef      	bge.n	38 <GetASNInt+0x38>
    return 0;
  58:	2000      	movs	r0, #0
  5a:	e7ef      	b.n	3c <GetASNInt+0x3c>

Disassembly of section .text.GetIntPositive:

00000000 <GetIntPositive>:
{
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   4:	460c      	mov	r4, r1
   6:	4617      	mov	r7, r2
    word32 idx = *inOutIdx;
   8:	6812      	ldr	r2, [r2, #0]
   a:	9200      	str	r2, [sp, #0]
{
   c:	4606      	mov	r6, r0
    ret = GetASNInt(input, &idx, &length, maxIdx);
   e:	aa01      	add	r2, sp, #4
  10:	4669      	mov	r1, sp
  12:	4620      	mov	r0, r4
{
  14:	9d08      	ldr	r5, [sp, #32]
  16:	4698      	mov	r8, r3
    ret = GetASNInt(input, &idx, &length, maxIdx);
  18:	f7ff fffe 	bl	0 <GetIntPositive>
    if (ret != 0)
  1c:	b930      	cbnz	r0, 2c <GetIntPositive+0x2c>
    if (idx + length > maxIdx) {
  1e:	e9dd 1300 	ldrd	r1, r3, [sp]
  22:	440b      	add	r3, r1
  24:	4543      	cmp	r3, r8
  26:	d904      	bls.n	32 <GetIntPositive+0x32>
        return MP_INIT_E;
  28:	f06f 006d 	mvn.w	r0, #109	; 0x6d
}
  2c:	b002      	add	sp, #8
  2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((input[idx] & 0x80) == 0x80) {
  32:	5663      	ldrsb	r3, [r4, r1]
  34:	2b00      	cmp	r3, #0
  36:	da06      	bge.n	46 <GetIntPositive+0x46>
        if (idx < 1) {
  38:	2900      	cmp	r1, #0
  3a:	d0f5      	beq.n	28 <GetIntPositive+0x28>
        if (input[idx - 1] != 0x00) {
  3c:	4421      	add	r1, r4
  3e:	f811 3c01 	ldrb.w	r3, [r1, #-1]
  42:	2b00      	cmp	r3, #0
  44:	d1f0      	bne.n	28 <GetIntPositive+0x28>
    if (initNum) {
  46:	b965      	cbnz	r5, 62 <GetIntPositive+0x62>
    if (mp_read_unsigned_bin(mpi, input + idx, (word32)length) != 0) {
  48:	e9dd 1200 	ldrd	r1, r2, [sp]
  4c:	4630      	mov	r0, r6
  4e:	4421      	add	r1, r4
  50:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
  54:	b158      	cbz	r0, 6e <GetIntPositive+0x6e>
        mp_clear(mpi);
  56:	4630      	mov	r0, r6
  58:	f7ff fffe 	bl	0 <mp_clear>
        return ASN_GETINT_E;
  5c:	f06f 008d 	mvn.w	r0, #141	; 0x8d
  60:	e7e4      	b.n	2c <GetIntPositive+0x2c>
        if (mp_init(mpi) != MP_OKAY)
  62:	4630      	mov	r0, r6
  64:	f7ff fffe 	bl	0 <mp_init>
  68:	2800      	cmp	r0, #0
  6a:	d0ed      	beq.n	48 <GetIntPositive+0x48>
  6c:	e7dc      	b.n	28 <GetIntPositive+0x28>
    *inOutIdx = idx + (word32)length;
  6e:	e9dd 3200 	ldrd	r3, r2, [sp]
  72:	4413      	add	r3, r2
  74:	603b      	str	r3, [r7, #0]
    return 0;
  76:	e7d9      	b.n	2c <GetIntPositive+0x2c>

Disassembly of section .text.GetSigName:

00000000 <GetSigName>:
    switch (oid) {
   0:	f5a0 7002 	sub.w	r0, r0, #520	; 0x208
   4:	2806      	cmp	r0, #6
   6:	bf9a      	itte	ls
   8:	4b02      	ldrls	r3, [pc, #8]	; (14 <GetSigName+0x14>)
   a:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
   e:	4802      	ldrhi	r0, [pc, #8]	; (18 <GetSigName+0x18>)
}
  10:	4770      	bx	lr
  12:	bf00      	nop
	...

Disassembly of section .text.GetMyVersion:

00000000 <GetMyVersion>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2:	4614      	mov	r4, r2
    word32 idx = *inOutIdx;
   4:	680a      	ldr	r2, [r1, #0]
   6:	9201      	str	r2, [sp, #4]
    if ((idx + MIN_VERSION_SZ) > maxIdx)
   8:	3203      	adds	r2, #3
   a:	429a      	cmp	r2, r3
{
   c:	4606      	mov	r6, r0
   e:	460d      	mov	r5, r1
    if ((idx + MIN_VERSION_SZ) > maxIdx)
  10:	d903      	bls.n	1a <GetMyVersion+0x1a>
        return ASN_PARSE_E;
  12:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
  16:	b002      	add	sp, #8
  18:	bd70      	pop	{r4, r5, r6, pc}
    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)
  1a:	f10d 0203 	add.w	r2, sp, #3
  1e:	a901      	add	r1, sp, #4
  20:	f7ff fffe 	bl	0 <GetMyVersion>
  24:	2800      	cmp	r0, #0
  26:	d1f4      	bne.n	12 <GetMyVersion+0x12>
    if (tag != ASN_INTEGER)
  28:	f89d 3003 	ldrb.w	r3, [sp, #3]
  2c:	2b02      	cmp	r3, #2
  2e:	d1f0      	bne.n	12 <GetMyVersion+0x12>
    if (input[idx++] != 0x01)
  30:	9b01      	ldr	r3, [sp, #4]
  32:	5cf1      	ldrb	r1, [r6, r3]
  34:	1c5a      	adds	r2, r3, #1
  36:	2901      	cmp	r1, #1
    *version  = input[idx++];
  38:	bf01      	itttt	eq
  3a:	5cb2      	ldrbeq	r2, [r6, r2]
  3c:	6022      	streq	r2, [r4, #0]
  3e:	3302      	addeq	r3, #2
    *inOutIdx = idx;
  40:	602b      	streq	r3, [r5, #0]
    return *version;
  42:	bf0c      	ite	eq
  44:	6820      	ldreq	r0, [r4, #0]
        return ASN_VERSION_E;
  46:	f06f 008c 	mvnne.w	r0, #140	; 0x8c
  4a:	e7e4      	b.n	16 <GetMyVersion+0x16>

Disassembly of section .text.GetInt:

00000000 <GetInt>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2:	460e      	mov	r6, r1
   4:	4615      	mov	r5, r2
    word32 idx = *inOutIdx;
   6:	6812      	ldr	r2, [r2, #0]
   8:	9200      	str	r2, [sp, #0]
{
   a:	4604      	mov	r4, r0
    ret = GetASNInt(input, &idx, &length, maxIdx);
   c:	aa01      	add	r2, sp, #4
   e:	4669      	mov	r1, sp
  10:	4630      	mov	r0, r6
  12:	f7ff fffe 	bl	0 <GetInt>
    if (ret != 0)
  16:	b978      	cbnz	r0, 38 <GetInt+0x38>
    if (mp_init(mpi) != MP_OKAY)
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <mp_init>
  1e:	b990      	cbnz	r0, 46 <GetInt+0x46>
    if (mp_read_unsigned_bin(mpi, input + idx, (word32)length) != 0) {
  20:	e9dd 1200 	ldrd	r1, r2, [sp]
  24:	4620      	mov	r0, r4
  26:	4431      	add	r1, r6
  28:	f7ff fffe 	bl	0 <mp_read_unsigned_bin>
  2c:	b130      	cbz	r0, 3c <GetInt+0x3c>
        mp_clear(mpi);
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <mp_clear>
        return ASN_GETINT_E;
  34:	f06f 008d 	mvn.w	r0, #141	; 0x8d
}
  38:	b002      	add	sp, #8
  3a:	bd70      	pop	{r4, r5, r6, pc}
    *inOutIdx = idx + (word32)length;
  3c:	e9dd 3200 	ldrd	r3, r2, [sp]
  40:	4413      	add	r3, r2
  42:	602b      	str	r3, [r5, #0]
    return 0;
  44:	e7f8      	b.n	38 <GetInt+0x38>
        return MP_INIT_E;
  46:	f06f 006d 	mvn.w	r0, #109	; 0x6d
  4a:	e7f5      	b.n	38 <GetInt+0x38>

Disassembly of section .text.CheckBitString:

00000000 <CheckBitString>:
{
   0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4616      	mov	r6, r2
    word32 idx = *inOutIdx;
   6:	680a      	ldr	r2, [r1, #0]
   8:	9202      	str	r2, [sp, #8]
{
   a:	4688      	mov	r8, r1
    if (GetASNTag(input, &idx, &b, maxIdx) != 0) {
   c:	f10d 0207 	add.w	r2, sp, #7
  10:	a902      	add	r1, sp, #8
{
  12:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
  16:	4605      	mov	r5, r0
  18:	469a      	mov	sl, r3
    if (GetASNTag(input, &idx, &b, maxIdx) != 0) {
  1a:	f7ff fffe 	bl	0 <CheckBitString>
  1e:	4604      	mov	r4, r0
  20:	2800      	cmp	r0, #0
  22:	d138      	bne.n	96 <CheckBitString+0x96>
    if (b != ASN_BIT_STRING) {
  24:	f89d 3007 	ldrb.w	r3, [sp, #7]
  28:	2b03      	cmp	r3, #3
  2a:	d134      	bne.n	96 <CheckBitString+0x96>
    if (GetLength(input, &idx, &length, maxIdx) < 0)
  2c:	4653      	mov	r3, sl
  2e:	aa03      	add	r2, sp, #12
  30:	4628      	mov	r0, r5
  32:	f7ff fffe 	bl	0 <CheckBitString>
  36:	2800      	cmp	r0, #0
  38:	da05      	bge.n	46 <CheckBitString+0x46>
        return ASN_PARSE_E;
  3a:	f06f 048b 	mvn.w	r4, #139	; 0x8b
}
  3e:	4620      	mov	r0, r4
  40:	b004      	add	sp, #16
  42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (length <= 0) {
  46:	9a03      	ldr	r2, [sp, #12]
  48:	2a00      	cmp	r2, #0
  4a:	dd27      	ble.n	9c <CheckBitString+0x9c>
    if (idx + 1 > maxIdx) {
  4c:	9902      	ldr	r1, [sp, #8]
  4e:	1c48      	adds	r0, r1, #1
  50:	4550      	cmp	r0, sl
  52:	d823      	bhi.n	9c <CheckBitString+0x9c>
    if (zeroBits && b != 0x00)
  54:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    b = input[idx];
  56:	5c6b      	ldrb	r3, [r5, r1]
  58:	f88d 3007 	strb.w	r3, [sp, #7]
    if (zeroBits && b != 0x00)
  5c:	b11f      	cbz	r7, 66 <CheckBitString+0x66>
  5e:	b17b      	cbz	r3, 80 <CheckBitString+0x80>
        return ASN_EXPECT_0_E;
  60:	f06f 0491 	mvn.w	r4, #145	; 0x91
  64:	e7eb      	b.n	3e <CheckBitString+0x3e>
    if (b >= 0x08)
  66:	2b07      	cmp	r3, #7
  68:	d8e7      	bhi.n	3a <CheckBitString+0x3a>
    if (b != 0) {
  6a:	b14b      	cbz	r3, 80 <CheckBitString+0x80>
        if ((byte)(input[idx + (word32)length - 1] << (8 - b)) != 0)
  6c:	4415      	add	r5, r2
  6e:	440d      	add	r5, r1
  70:	f815 1c01 	ldrb.w	r1, [r5, #-1]
  74:	f1c3 0508 	rsb	r5, r3, #8
  78:	40a9      	lsls	r1, r5
  7a:	b2c9      	uxtb	r1, r1
  7c:	2900      	cmp	r1, #0
  7e:	d1dc      	bne.n	3a <CheckBitString+0x3a>
    *inOutIdx = idx;
  80:	f8c8 0000 	str.w	r0, [r8]
    if (len != NULL)
  84:	b10e      	cbz	r6, 8a <CheckBitString+0x8a>
    length--; /* length has been checked for greater than 0 */
  86:	3a01      	subs	r2, #1
        *len = length;
  88:	6032      	str	r2, [r6, #0]
    if (unusedBits != NULL)
  8a:	f1b9 0f00 	cmp.w	r9, #0
  8e:	d0d6      	beq.n	3e <CheckBitString+0x3e>
        *unusedBits = b;
  90:	f889 3000 	strb.w	r3, [r9]
  94:	e7d3      	b.n	3e <CheckBitString+0x3e>
        return ASN_BITSTR_E;
  96:	f06f 0492 	mvn.w	r4, #146	; 0x92
  9a:	e7d0      	b.n	3e <CheckBitString+0x3e>
        return BUFFER_E;
  9c:	f06f 0483 	mvn.w	r4, #131	; 0x83
  a0:	e7cd      	b.n	3e <CheckBitString+0x3e>

Disassembly of section .text.OidFromId:

00000000 <OidFromId>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    const byte* oid = NULL;
   2:	2300      	movs	r3, #0
   4:	9301      	str	r3, [sp, #4]
    *oidSz = 0;
   6:	6013      	str	r3, [r2, #0]
    switch (type) {
   8:	290f      	cmp	r1, #15
   a:	d836      	bhi.n	7a <OidFromId+0x7a>
   c:	e8df f011 	tbh	[pc, r1, lsl #1]
  10:	002b0010 	.word	0x002b0010
  14:	005b004c 	.word	0x005b004c
  18:	0035005f 	.word	0x0035005f
  1c:	00dd0088 	.word	0x00dd0088
  20:	00ed00e6 	.word	0x00ed00e6
  24:	012100f2 	.word	0x012100f2
  28:	01ba0144 	.word	0x01ba0144
  2c:	01ca0127 	.word	0x01ca0127
            switch (id) {
  30:	2858      	cmp	r0, #88	; 0x58
  32:	d00a      	beq.n	4a <OidFromId+0x4a>
  34:	f5a0 70cf 	sub.w	r0, r0, #414	; 0x19e
  38:	2805      	cmp	r0, #5
  3a:	d81e      	bhi.n	7a <OidFromId+0x7a>
  3c:	2805      	cmp	r0, #5
  3e:	d81c      	bhi.n	7a <OidFromId+0x7a>
  40:	e8df f000 	tbb	[pc, r0]
  44:	1b0f1b07 	.word	0x1b0f1b07
  48:	0d0b      	.short	0x0d0b
                    oid = hashSha1hOid;
  4a:	4b9d      	ldr	r3, [pc, #628]	; (2c0 <OidFromId+0x2c0>)
                    oid = blkDesCbcOid;
  4c:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(blkDesCbcOid);
  4e:	2305      	movs	r3, #5
  50:	e020      	b.n	94 <OidFromId+0x94>
                    oid = hashSha256hOid;
  52:	4b9c      	ldr	r3, [pc, #624]	; (2c4 <OidFromId+0x2c4>)
                    oid = blkAes128CbcOid;
  54:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(blkAes128CbcOid);
  56:	2309      	movs	r3, #9
  58:	e01c      	b.n	94 <OidFromId+0x94>
                    oid = hashSha512_224hOid;
  5a:	4b9b      	ldr	r3, [pc, #620]	; (2c8 <OidFromId+0x2c8>)
  5c:	e7fa      	b.n	54 <OidFromId+0x54>
                    oid = hashSha512_256hOid;
  5e:	4b9b      	ldr	r3, [pc, #620]	; (2cc <OidFromId+0x2cc>)
  60:	e7f8      	b.n	54 <OidFromId+0x54>
                    oid = hashSha512hOid;
  62:	4b9b      	ldr	r3, [pc, #620]	; (2d0 <OidFromId+0x2d0>)
  64:	e7f6      	b.n	54 <OidFromId+0x54>
            switch (id) {
  66:	f5b0 7f03 	cmp.w	r0, #524	; 0x20c
  6a:	d015      	beq.n	98 <OidFromId+0x98>
  6c:	d809      	bhi.n	82 <OidFromId+0x82>
  6e:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  72:	d015      	beq.n	a0 <OidFromId+0xa0>
  74:	f5b0 7f02 	cmp.w	r0, #520	; 0x208
  78:	d009      	beq.n	8e <OidFromId+0x8e>
}
  7a:	9801      	ldr	r0, [sp, #4]
  7c:	b003      	add	sp, #12
  7e:	f85d fb04 	ldr.w	pc, [sp], #4
  82:	f240 230e 	movw	r3, #526	; 0x20e
  86:	4298      	cmp	r0, r3
  88:	d1f7      	bne.n	7a <OidFromId+0x7a>
                    oid = sigSha512wEcdsaOid;
  8a:	4b92      	ldr	r3, [pc, #584]	; (2d4 <OidFromId+0x2d4>)
  8c:	e005      	b.n	9a <OidFromId+0x9a>
                    oid = sigSha1wEcdsaOid;
  8e:	4b92      	ldr	r3, [pc, #584]	; (2d8 <OidFromId+0x2d8>)
                    oid = keyEcdsaOid;
  90:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(keyEcdsaOid);
  92:	2307      	movs	r3, #7
                    *oidSz = sizeof(hmacSha512Oid);
  94:	6013      	str	r3, [r2, #0]
                    break;
  96:	e7f0      	b.n	7a <OidFromId+0x7a>
                    oid = sigSha256wEcdsaOid;
  98:	4b90      	ldr	r3, [pc, #576]	; (2dc <OidFromId+0x2dc>)
                    oid = hmacSha512Oid;
  9a:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(hmacSha512Oid);
  9c:	2308      	movs	r3, #8
  9e:	e7f9      	b.n	94 <OidFromId+0x94>
                    oid = sigEd25519Oid;
  a0:	4b8f      	ldr	r3, [pc, #572]	; (2e0 <OidFromId+0x2e0>)
                    oid = keyCurve25519Oid;
  a2:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(keyCurve25519Oid);
  a4:	2303      	movs	r3, #3
  a6:	e7f5      	b.n	94 <OidFromId+0x94>
            switch (id) {
  a8:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  ac:	d009      	beq.n	c2 <OidFromId+0xc2>
  ae:	f240 2306 	movw	r3, #518	; 0x206
  b2:	4298      	cmp	r0, r3
  b4:	d003      	beq.n	be <OidFromId+0xbe>
  b6:	28fe      	cmp	r0, #254	; 0xfe
  b8:	d1df      	bne.n	7a <OidFromId+0x7a>
                    oid = keyCurve25519Oid;
  ba:	4b8a      	ldr	r3, [pc, #552]	; (2e4 <OidFromId+0x2e4>)
  bc:	e7f1      	b.n	a2 <OidFromId+0xa2>
                    oid = keyEcdsaOid;
  be:	4b8a      	ldr	r3, [pc, #552]	; (2e8 <OidFromId+0x2e8>)
  c0:	e7e6      	b.n	90 <OidFromId+0x90>
                    oid = keyEd25519Oid;
  c2:	4b8a      	ldr	r3, [pc, #552]	; (2ec <OidFromId+0x2ec>)
  c4:	e7ed      	b.n	a2 <OidFromId+0xa2>
            if (wc_ecc_get_oid(id, &oid, oidSz) < 0) {
  c6:	a901      	add	r1, sp, #4
  c8:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
            break;
  cc:	e7d5      	b.n	7a <OidFromId+0x7a>
            switch (id) {
  ce:	f5b0 7fdb 	cmp.w	r0, #438	; 0x1b6
  d2:	d01d      	beq.n	110 <OidFromId+0x110>
  d4:	d80f      	bhi.n	f6 <OidFromId+0xf6>
  d6:	f5b0 7fd1 	cmp.w	r0, #418	; 0x1a2
  da:	d017      	beq.n	10c <OidFromId+0x10c>
  dc:	d806      	bhi.n	ec <OidFromId+0xec>
  de:	2845      	cmp	r0, #69	; 0x45
  e0:	d01a      	beq.n	118 <OidFromId+0x118>
  e2:	f5b0 7fcf 	cmp.w	r0, #414	; 0x19e
  e6:	d1c8      	bne.n	7a <OidFromId+0x7a>
                    oid = blkAes128CbcOid;
  e8:	4b81      	ldr	r3, [pc, #516]	; (2f0 <OidFromId+0x2f0>)
  ea:	e7b3      	b.n	54 <OidFromId+0x54>
  ec:	f5b0 7fd9 	cmp.w	r0, #434	; 0x1b2
  f0:	d1c3      	bne.n	7a <OidFromId+0x7a>
                    oid = blkAes192CbcOid;
  f2:	4b80      	ldr	r3, [pc, #512]	; (2f4 <OidFromId+0x2f4>)
  f4:	e7ae      	b.n	54 <OidFromId+0x54>
  f6:	f5b0 7fe5 	cmp.w	r0, #458	; 0x1ca
  fa:	d00b      	beq.n	114 <OidFromId+0x114>
  fc:	f5b0 7f23 	cmp.w	r0, #652	; 0x28c
 100:	d00c      	beq.n	11c <OidFromId+0x11c>
 102:	f5b0 7fe3 	cmp.w	r0, #454	; 0x1c6
 106:	d1b8      	bne.n	7a <OidFromId+0x7a>
                    oid = blkAes256CbcOid;
 108:	4b7b      	ldr	r3, [pc, #492]	; (2f8 <OidFromId+0x2f8>)
 10a:	e7a3      	b.n	54 <OidFromId+0x54>
                    oid = blkAes128GcmOid;
 10c:	4b7b      	ldr	r3, [pc, #492]	; (2fc <OidFromId+0x2fc>)
 10e:	e7a1      	b.n	54 <OidFromId+0x54>
                    oid = blkAes192GcmOid;
 110:	4b7b      	ldr	r3, [pc, #492]	; (300 <OidFromId+0x300>)
 112:	e79f      	b.n	54 <OidFromId+0x54>
                    oid = blkAes256GcmOid;
 114:	4b7b      	ldr	r3, [pc, #492]	; (304 <OidFromId+0x304>)
 116:	e79d      	b.n	54 <OidFromId+0x54>
                    oid = blkDesCbcOid;
 118:	4b7b      	ldr	r3, [pc, #492]	; (308 <OidFromId+0x308>)
 11a:	e797      	b.n	4c <OidFromId+0x4c>
                    oid = blkDes3CbcOid;
 11c:	4b7b      	ldr	r3, [pc, #492]	; (30c <OidFromId+0x30c>)
 11e:	e7bc      	b.n	9a <OidFromId+0x9a>
            switch (id) {
 120:	2897      	cmp	r0, #151	; 0x97
 122:	d83b      	bhi.n	19c <OidFromId+0x19c>
 124:	287f      	cmp	r0, #127	; 0x7f
 126:	d803      	bhi.n	130 <OidFromId+0x130>
 128:	2845      	cmp	r0, #69	; 0x45
 12a:	d1a6      	bne.n	7a <OidFromId+0x7a>
                    oid = extAuthInfoOid;
 12c:	4b78      	ldr	r3, [pc, #480]	; (310 <OidFromId+0x310>)
 12e:	e7b4      	b.n	9a <OidFromId+0x9a>
 130:	3880      	subs	r0, #128	; 0x80
 132:	2817      	cmp	r0, #23
 134:	d8a1      	bhi.n	7a <OidFromId+0x7a>
 136:	a301      	add	r3, pc, #4	; (adr r3, 13c <OidFromId+0x13c>)
 138:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 13c:	000001b7 	.word	0x000001b7
 140:	000001bf 	.word	0x000001bf
 144:	0000007b 	.word	0x0000007b
 148:	000001ab 	.word	0x000001ab
 14c:	0000007b 	.word	0x0000007b
 150:	000001a7 	.word	0x000001a7
 154:	0000007b 	.word	0x0000007b
 158:	0000007b 	.word	0x0000007b
 15c:	0000007b 	.word	0x0000007b
 160:	0000007b 	.word	0x0000007b
 164:	0000007b 	.word	0x0000007b
 168:	0000007b 	.word	0x0000007b
 16c:	0000007b 	.word	0x0000007b
 170:	0000007b 	.word	0x0000007b
 174:	0000007b 	.word	0x0000007b
 178:	0000007b 	.word	0x0000007b
 17c:	000001c7 	.word	0x000001c7
 180:	000001af 	.word	0x000001af
 184:	000001bb 	.word	0x000001bb
 188:	0000007b 	.word	0x0000007b
 18c:	0000007b 	.word	0x0000007b
 190:	000001b3 	.word	0x000001b3
 194:	0000007b 	.word	0x0000007b
 198:	000001c3 	.word	0x000001c3
 19c:	28a8      	cmp	r0, #168	; 0xa8
 19e:	f47f af6c 	bne.w	7a <OidFromId+0x7a>
                    oid = extInhibitAnyOid;
 1a2:	4b5c      	ldr	r3, [pc, #368]	; (314 <OidFromId+0x314>)
 1a4:	e77d      	b.n	a2 <OidFromId+0xa2>
                    oid = extBasicCaOid;
 1a6:	4b5c      	ldr	r3, [pc, #368]	; (318 <OidFromId+0x318>)
 1a8:	e77b      	b.n	a2 <OidFromId+0xa2>
                    oid = extAltNamesOid;
 1aa:	4b5c      	ldr	r3, [pc, #368]	; (31c <OidFromId+0x31c>)
 1ac:	e779      	b.n	a2 <OidFromId+0xa2>
                    oid = extCrlDistOid;
 1ae:	4b5c      	ldr	r3, [pc, #368]	; (320 <OidFromId+0x320>)
 1b0:	e777      	b.n	a2 <OidFromId+0xa2>
                    oid = extAuthKeyOid;
 1b2:	4b5c      	ldr	r3, [pc, #368]	; (324 <OidFromId+0x324>)
 1b4:	e775      	b.n	a2 <OidFromId+0xa2>
                    oid = extSubjKeyOid;
 1b6:	4b5c      	ldr	r3, [pc, #368]	; (328 <OidFromId+0x328>)
 1b8:	e773      	b.n	a2 <OidFromId+0xa2>
                    oid = extCertPolicyOid;
 1ba:	4b5c      	ldr	r3, [pc, #368]	; (32c <OidFromId+0x32c>)
 1bc:	e771      	b.n	a2 <OidFromId+0xa2>
                    oid = extKeyUsageOid;
 1be:	4b5c      	ldr	r3, [pc, #368]	; (330 <OidFromId+0x330>)
 1c0:	e76f      	b.n	a2 <OidFromId+0xa2>
                    oid = extExtKeyUsageOid;
 1c2:	4b5c      	ldr	r3, [pc, #368]	; (334 <OidFromId+0x334>)
 1c4:	e76d      	b.n	a2 <OidFromId+0xa2>
                    oid = extNameConsOid;
 1c6:	4b5c      	ldr	r3, [pc, #368]	; (338 <OidFromId+0x338>)
 1c8:	e76b      	b.n	a2 <OidFromId+0xa2>
            switch (id) {
 1ca:	2874      	cmp	r0, #116	; 0x74
 1cc:	d004      	beq.n	1d8 <OidFromId+0x1d8>
 1ce:	2875      	cmp	r0, #117	; 0x75
 1d0:	f47f af53 	bne.w	7a <OidFromId+0x7a>
                    oid = extAuthInfoCaIssuerOid;
 1d4:	4b59      	ldr	r3, [pc, #356]	; (33c <OidFromId+0x33c>)
 1d6:	e760      	b.n	9a <OidFromId+0x9a>
                    oid = extAuthInfoOcspOid;
 1d8:	4b59      	ldr	r3, [pc, #356]	; (340 <OidFromId+0x340>)
 1da:	e75e      	b.n	9a <OidFromId+0x9a>
            switch (id) {
 1dc:	2892      	cmp	r0, #146	; 0x92
 1de:	f47f af4c 	bne.w	7a <OidFromId+0x7a>
                    oid = extCertPolicyAnyOid;
 1e2:	4b58      	ldr	r3, [pc, #352]	; (344 <OidFromId+0x344>)
                    oid = extExtKeyUsageAnyOid;
 1e4:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(extExtKeyUsageAnyOid);
 1e6:	2304      	movs	r3, #4
 1e8:	e754      	b.n	94 <OidFromId+0x94>
            switch (id) {
 1ea:	284f      	cmp	r0, #79	; 0x4f
 1ec:	f47f af45 	bne.w	7a <OidFromId+0x7a>
                    oid = extAltNamesHwNameOid;
 1f0:	4b55      	ldr	r3, [pc, #340]	; (348 <OidFromId+0x348>)
 1f2:	e752      	b.n	9a <OidFromId+0x9a>
            switch (id) {
 1f4:	284f      	cmp	r0, #79	; 0x4f
 1f6:	d81b      	bhi.n	230 <OidFromId+0x230>
 1f8:	2846      	cmp	r0, #70	; 0x46
 1fa:	f67f af3e 	bls.w	7a <OidFromId+0x7a>
 1fe:	3847      	subs	r0, #71	; 0x47
 200:	2808      	cmp	r0, #8
 202:	f63f af3a 	bhi.w	7a <OidFromId+0x7a>
 206:	a301      	add	r3, pc, #4	; (adr r3, 20c <OidFromId+0x20c>)
 208:	f853 f020 	ldr.w	pc, [r3, r0, lsl #2]
 20c:	0000023b 	.word	0x0000023b
 210:	0000023f 	.word	0x0000023f
 214:	00000243 	.word	0x00000243
 218:	00000247 	.word	0x00000247
 21c:	0000007b 	.word	0x0000007b
 220:	0000007b 	.word	0x0000007b
 224:	0000007b 	.word	0x0000007b
 228:	0000024b 	.word	0x0000024b
 22c:	0000024f 	.word	0x0000024f
 230:	2897      	cmp	r0, #151	; 0x97
 232:	f47f af22 	bne.w	7a <OidFromId+0x7a>
                    oid = extExtKeyUsageAnyOid;
 236:	4b45      	ldr	r3, [pc, #276]	; (34c <OidFromId+0x34c>)
 238:	e7d4      	b.n	1e4 <OidFromId+0x1e4>
                    oid = extExtKeyUsageServerAuthOid;
 23a:	4b45      	ldr	r3, [pc, #276]	; (350 <OidFromId+0x350>)
 23c:	e72d      	b.n	9a <OidFromId+0x9a>
                    oid = extExtKeyUsageClientAuthOid;
 23e:	4b45      	ldr	r3, [pc, #276]	; (354 <OidFromId+0x354>)
 240:	e72b      	b.n	9a <OidFromId+0x9a>
                    oid = extExtKeyUsageCodeSigningOid;
 242:	4b45      	ldr	r3, [pc, #276]	; (358 <OidFromId+0x358>)
 244:	e729      	b.n	9a <OidFromId+0x9a>
                    oid = extExtKeyUsageEmailProtectOid;
 246:	4b45      	ldr	r3, [pc, #276]	; (35c <OidFromId+0x35c>)
 248:	e727      	b.n	9a <OidFromId+0x9a>
                    oid = extExtKeyUsageTimestampOid;
 24a:	4b45      	ldr	r3, [pc, #276]	; (360 <OidFromId+0x360>)
 24c:	e725      	b.n	9a <OidFromId+0x9a>
                    oid = extExtKeyUsageOcspSignOid;
 24e:	4b45      	ldr	r3, [pc, #276]	; (364 <OidFromId+0x364>)
 250:	e723      	b.n	9a <OidFromId+0x9a>
            switch (id) {
 252:	f5b0 7f25 	cmp.w	r0, #660	; 0x294
 256:	f47f af10 	bne.w	7a <OidFromId+0x7a>
                    oid = pbkdf2Oid;
 25a:	4b43      	ldr	r3, [pc, #268]	; (368 <OidFromId+0x368>)
 25c:	e6fa      	b.n	54 <OidFromId+0x54>
            switch (id) {
 25e:	f240 2392 	movw	r3, #658	; 0x292
 262:	4298      	cmp	r0, r3
 264:	d007      	beq.n	276 <OidFromId+0x276>
 266:	d808      	bhi.n	27a <OidFromId+0x27a>
 268:	2803      	cmp	r0, #3
 26a:	d011      	beq.n	290 <OidFromId+0x290>
 26c:	280d      	cmp	r0, #13
 26e:	d00d      	beq.n	28c <OidFromId+0x28c>
 270:	2802      	cmp	r0, #2
 272:	f47f af02 	bne.w	7a <OidFromId+0x7a>
                    oid = pbeSha1Des;
 276:	4b3d      	ldr	r3, [pc, #244]	; (36c <OidFromId+0x36c>)
 278:	e6ec      	b.n	54 <OidFromId+0x54>
 27a:	f240 2393 	movw	r3, #659	; 0x293
 27e:	4298      	cmp	r0, r3
 280:	d006      	beq.n	290 <OidFromId+0x290>
 282:	f240 2395 	movw	r3, #661	; 0x295
 286:	4298      	cmp	r0, r3
 288:	f47f aef7 	bne.w	7a <OidFromId+0x7a>
                    oid = pbes2;
 28c:	4b38      	ldr	r3, [pc, #224]	; (370 <OidFromId+0x370>)
 28e:	e6e1      	b.n	54 <OidFromId+0x54>
                    oid = pbeSha1Des3;
 290:	4b38      	ldr	r3, [pc, #224]	; (374 <OidFromId+0x374>)
 292:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(pbeSha1Des3);
 294:	230a      	movs	r3, #10
 296:	e6fd      	b.n	94 <OidFromId+0x94>
            switch (id) {
 298:	f240 13b5 	movw	r3, #437	; 0x1b5
 29c:	4298      	cmp	r0, r3
 29e:	d00a      	beq.n	2b6 <OidFromId+0x2b6>
 2a0:	f240 13c9 	movw	r3, #457	; 0x1c9
 2a4:	4298      	cmp	r0, r3
 2a6:	d008      	beq.n	2ba <OidFromId+0x2ba>
 2a8:	f240 13a1 	movw	r3, #417	; 0x1a1
 2ac:	4298      	cmp	r0, r3
 2ae:	f47f aee4 	bne.w	7a <OidFromId+0x7a>
                    oid = wrapAes128Oid;
 2b2:	4b31      	ldr	r3, [pc, #196]	; (378 <OidFromId+0x378>)
 2b4:	e6ce      	b.n	54 <OidFromId+0x54>
                    oid = wrapAes192Oid;
 2b6:	4b31      	ldr	r3, [pc, #196]	; (37c <OidFromId+0x37c>)
 2b8:	e6cc      	b.n	54 <OidFromId+0x54>
                    oid = wrapAes256Oid;
 2ba:	4b31      	ldr	r3, [pc, #196]	; (380 <OidFromId+0x380>)
 2bc:	e6ca      	b.n	54 <OidFromId+0x54>
 2be:	bf00      	nop
	...
            switch (id) {
 384:	28bf      	cmp	r0, #191	; 0xbf
 386:	d00b      	beq.n	3a0 <OidFromId+0x3a0>
 388:	f5b0 7fe8 	cmp.w	r0, #464	; 0x1d0
 38c:	d006      	beq.n	39c <OidFromId+0x39c>
 38e:	28bd      	cmp	r0, #189	; 0xbd
 390:	f47f ae73 	bne.w	7a <OidFromId+0x7a>
                    oid = dhSinglePass_stdDH_sha256kdf_Oid;
 394:	4b0a      	ldr	r3, [pc, #40]	; (3c0 <OidFromId+0x3c0>)
                    oid = dhSinglePass_stdDH_sha512kdf_Oid;
 396:	9301      	str	r3, [sp, #4]
                    *oidSz = sizeof(dhSinglePass_stdDH_sha512kdf_Oid);
 398:	2306      	movs	r3, #6
 39a:	e67b      	b.n	94 <OidFromId+0x94>
                    oid = dhSinglePass_stdDH_sha1kdf_Oid;
 39c:	4b09      	ldr	r3, [pc, #36]	; (3c4 <OidFromId+0x3c4>)
 39e:	e659      	b.n	54 <OidFromId+0x54>
                    oid = dhSinglePass_stdDH_sha512kdf_Oid;
 3a0:	4b09      	ldr	r3, [pc, #36]	; (3c8 <OidFromId+0x3c8>)
 3a2:	e7f8      	b.n	396 <OidFromId+0x396>
            switch (id) {
 3a4:	f240 238d 	movw	r3, #653	; 0x28d
 3a8:	4298      	cmp	r0, r3
 3aa:	d006      	beq.n	3ba <OidFromId+0x3ba>
 3ac:	f240 238f 	movw	r3, #655	; 0x28f
 3b0:	4298      	cmp	r0, r3
 3b2:	f47f ae62 	bne.w	7a <OidFromId+0x7a>
                    oid = hmacSha512Oid;
 3b6:	4b05      	ldr	r3, [pc, #20]	; (3cc <OidFromId+0x3cc>)
 3b8:	e66f      	b.n	9a <OidFromId+0x9a>
                    oid = hmacSha256Oid;
 3ba:	4b05      	ldr	r3, [pc, #20]	; (3d0 <OidFromId+0x3d0>)
 3bc:	e66d      	b.n	9a <OidFromId+0x9a>
 3be:	bf00      	nop
	...

Disassembly of section .text.GetASNObjectId:

00000000 <GetASNObjectId>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
   2:	2401      	movs	r4, #1
   4:	e9cd 3400 	strd	r3, r4, [sp]
   8:	4613      	mov	r3, r2
   a:	460a      	mov	r2, r1
   c:	2106      	movs	r1, #6
   e:	f7ff fffe 	bl	0 <GetASNObjectId>
}
  12:	ea00 70e0 	and.w	r0, r0, r0, asr #31
  16:	b002      	add	sp, #8
  18:	bd10      	pop	{r4, pc}

Disassembly of section .text.SkipObjectId:

00000000 <SkipObjectId>:
{
   0:	b513      	push	{r0, r1, r4, lr}
   2:	4613      	mov	r3, r2
    word32 idx = *inOutIdx;
   4:	680a      	ldr	r2, [r1, #0]
   6:	9200      	str	r2, [sp, #0]
{
   8:	460c      	mov	r4, r1
    ret = GetASNObjectId(input, &idx, &length, maxIdx);
   a:	aa01      	add	r2, sp, #4
   c:	4669      	mov	r1, sp
   e:	f7ff fffe 	bl	0 <SkipObjectId>
    if (ret != 0)
  12:	b918      	cbnz	r0, 1c <SkipObjectId+0x1c>
    idx += (word32)length;
  14:	e9dd 3200 	ldrd	r3, r2, [sp]
  18:	4413      	add	r3, r2
    *inOutIdx = idx;
  1a:	6023      	str	r3, [r4, #0]
}
  1c:	b002      	add	sp, #8
  1e:	bd10      	pop	{r4, pc}

Disassembly of section .text.GetObjectId:

00000000 <GetObjectId>:
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4615      	mov	r5, r2
   6:	461f      	mov	r7, r3
    ret = GetASNObjectId(input, inOutIdx, &length, maxIdx);
   8:	466a      	mov	r2, sp
   a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
{
   c:	4606      	mov	r6, r0
   e:	4688      	mov	r8, r1
    ret = GetASNObjectId(input, inOutIdx, &length, maxIdx);
  10:	f7ff fffe 	bl	0 <GetObjectId>
    if (ret != 0)
  14:	4604      	mov	r4, r0
  16:	bb00      	cbnz	r0, 5a <GetObjectId+0x5a>
    word32 idx = *inOutIdx;
  18:	f8d8 2000 	ldr.w	r2, [r8]
    return GetOID(input, inOutIdx, oid, oidType, length);
  1c:	f8dd 9000 	ldr.w	r9, [sp]
    *oid = 0;
  20:	6028      	str	r0, [r5, #0]
    while (length--) {
  22:	eb06 0a02 	add.w	sl, r6, r2
  26:	444a      	add	r2, r9
  28:	4651      	mov	r1, sl
  2a:	4416      	add	r6, r2
  2c:	42b1      	cmp	r1, r6
  2e:	d118      	bne.n	62 <GetObjectId+0x62>
    if (oidType != oidIgnoreType) {
  30:	2f15      	cmp	r7, #21
    *inOutIdx = idx;
  32:	f8c8 2000 	str.w	r2, [r8]
    if (oidType != oidIgnoreType) {
  36:	d010      	beq.n	5a <GetObjectId+0x5a>
        checkOid = OidFromId(*oid, oidType, &checkOidSz);
  38:	4639      	mov	r1, r7
  3a:	6828      	ldr	r0, [r5, #0]
  3c:	aa01      	add	r2, sp, #4
  3e:	f7ff fffe 	bl	0 <GetObjectId>
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
  42:	4601      	mov	r1, r0
  44:	b148      	cbz	r0, 5a <GetObjectId+0x5a>
  46:	9b01      	ldr	r3, [sp, #4]
  48:	454b      	cmp	r3, r9
  4a:	d104      	bne.n	56 <GetObjectId+0x56>
                (XMEMCMP(actualOid, checkOid, checkOidSz) != 0))) {
  4c:	464a      	mov	r2, r9
  4e:	4650      	mov	r0, sl
  50:	f7ff fffe 	bl	0 <memcmp>
        if ((ret == 0) && (checkOid != NULL) && ((checkOidSz != actualOidSz) ||
  54:	b108      	cbz	r0, 5a <GetObjectId+0x5a>
            ret = ASN_UNKNOWN_OID_E;
  56:	f06f 0493 	mvn.w	r4, #147	; 0x93
}
  5a:	4620      	mov	r0, r4
  5c:	b002      	add	sp, #8
  5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        *oid += (word32)input[idx];
  62:	f811 0b01 	ldrb.w	r0, [r1], #1
  66:	682b      	ldr	r3, [r5, #0]
  68:	4403      	add	r3, r0
  6a:	602b      	str	r3, [r5, #0]
        idx++;
  6c:	e7de      	b.n	2c <GetObjectId+0x2c>

Disassembly of section .text.GetSigAlg:

00000000 <GetSigAlg>:
{
   0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)
   4:	f500 771e 	add.w	r7, r0, #632	; 0x278
   8:	4613      	mov	r3, r2
{
   a:	4604      	mov	r4, r0
   c:	4688      	mov	r8, r1
    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)
   e:	f8d0 0274 	ldr.w	r0, [r0, #628]	; 0x274
{
  12:	4616      	mov	r6, r2
    if (GetSequence(cert->source, &cert->srcIdx, &length, maxIdx) < 0)
  14:	4639      	mov	r1, r7
  16:	aa03      	add	r2, sp, #12
  18:	f7ff fffe 	bl	0 <GetSigAlg>
  1c:	2800      	cmp	r0, #0
  1e:	da04      	bge.n	2a <GetSigAlg+0x2a>
                return ASN_PARSE_E;
  20:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
  24:	b004      	add	sp, #16
  26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    endSeqIdx = cert->srcIdx + (word32)length;
  2a:	9b03      	ldr	r3, [sp, #12]
  2c:	f8d4 5278 	ldr.w	r5, [r4, #632]	; 0x278
    if (GetObjectId(cert->source, &cert->srcIdx, sigOid, oidSigType,
  30:	f8d4 0274 	ldr.w	r0, [r4, #628]	; 0x274
  34:	9600      	str	r6, [sp, #0]
    endSeqIdx = cert->srcIdx + (word32)length;
  36:	441d      	add	r5, r3
    if (GetObjectId(cert->source, &cert->srcIdx, sigOid, oidSigType,
  38:	4642      	mov	r2, r8
  3a:	2301      	movs	r3, #1
  3c:	4639      	mov	r1, r7
  3e:	f7ff fffe 	bl	0 <GetSigAlg>
  42:	2800      	cmp	r0, #0
  44:	db18      	blt.n	78 <GetSigAlg+0x78>
    if (cert->srcIdx != endSeqIdx) {
  46:	f8d4 3278 	ldr.w	r3, [r4, #632]	; 0x278
  4a:	42ab      	cmp	r3, r5
  4c:	d010      	beq.n	70 <GetSigAlg+0x70>
        if  (endSeqIdx - cert->srcIdx != 2)
  4e:	1aeb      	subs	r3, r5, r3
  50:	2b02      	cmp	r3, #2
  52:	d1e5      	bne.n	20 <GetSigAlg+0x20>
            if (GetASNTag(cert->source, &cert->srcIdx, &tag, endSeqIdx) != 0)
  54:	f8d4 0274 	ldr.w	r0, [r4, #628]	; 0x274
  58:	462b      	mov	r3, r5
  5a:	f10d 020b 	add.w	r2, sp, #11
  5e:	4639      	mov	r1, r7
  60:	f7ff fffe 	bl	0 <GetSigAlg>
  64:	2800      	cmp	r0, #0
  66:	d1db      	bne.n	20 <GetSigAlg+0x20>
            if (tag != ASN_TAG_NULL)
  68:	f89d 300b 	ldrb.w	r3, [sp, #11]
  6c:	2b05      	cmp	r3, #5
  6e:	d1d7      	bne.n	20 <GetSigAlg+0x20>
    cert->srcIdx = endSeqIdx;
  70:	f8c4 5278 	str.w	r5, [r4, #632]	; 0x278
    return 0;
  74:	2000      	movs	r0, #0
  76:	e7d5      	b.n	24 <GetSigAlg+0x24>
        return ASN_OBJECT_ID_E;
  78:	f06f 008f 	mvn.w	r0, #143	; 0x8f
  7c:	e7d2      	b.n	24 <GetSigAlg+0x24>

Disassembly of section .text.GetAlgoId:

00000000 <GetAlgoId>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b086      	sub	sp, #24
   6:	4698      	mov	r8, r3
   8:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    word32 idx = *inOutIdx;
   a:	680b      	ldr	r3, [r1, #0]
   c:	9304      	str	r3, [sp, #16]
    *oid = 0;
   e:	2300      	movs	r3, #0
  10:	6013      	str	r3, [r2, #0]
{
  12:	460e      	mov	r6, r1
  14:	4617      	mov	r7, r2
    if (GetSequence(input, &idx, &length, maxIdx) < 0)
  16:	462b      	mov	r3, r5
  18:	aa03      	add	r2, sp, #12
  1a:	a904      	add	r1, sp, #16
{
  1c:	4604      	mov	r4, r0
    if (GetSequence(input, &idx, &length, maxIdx) < 0)
  1e:	f7ff fffe 	bl	0 <GetAlgoId>
  22:	2800      	cmp	r0, #0
  24:	db32      	blt.n	8c <GetAlgoId+0x8c>
    if (GetObjectId(input, &idx, oid, oidType, maxIdx) < 0)
  26:	9500      	str	r5, [sp, #0]
  28:	4643      	mov	r3, r8
  2a:	463a      	mov	r2, r7
  2c:	a904      	add	r1, sp, #16
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <GetAlgoId>
  34:	2800      	cmp	r0, #0
  36:	db2c      	blt.n	92 <GetAlgoId+0x92>
    if (idx < maxIdx) {
  38:	9b04      	ldr	r3, [sp, #16]
  3a:	42ab      	cmp	r3, r5
  3c:	d217      	bcs.n	6e <GetAlgoId+0x6e>
        word32 localIdx = idx; /*use localIdx to not advance when checking tag*/
  3e:	9305      	str	r3, [sp, #20]
        if (GetASNTag(input, &localIdx, &tag, maxIdx) == 0) {
  40:	f10d 020b 	add.w	r2, sp, #11
  44:	462b      	mov	r3, r5
  46:	a905      	add	r1, sp, #20
  48:	4620      	mov	r0, r4
  4a:	f7ff fffe 	bl	0 <GetAlgoId>
  4e:	b970      	cbnz	r0, 6e <GetAlgoId+0x6e>
            if (tag == ASN_TAG_NULL) {
  50:	f89d 300b 	ldrb.w	r3, [sp, #11]
  54:	2b05      	cmp	r3, #5
  56:	d10a      	bne.n	6e <GetAlgoId+0x6e>
    word32 idx = *inOutIdx;
  58:	9804      	ldr	r0, [sp, #16]
    if ((idx + 2) > maxIdx) {
  5a:	1c83      	adds	r3, r0, #2
  5c:	429d      	cmp	r5, r3
  5e:	d30a      	bcc.n	76 <GetAlgoId+0x76>
    if ((ret == 0) && (input[idx++] != ASN_TAG_NULL)) {
  60:	5c22      	ldrb	r2, [r4, r0]
  62:	2a05      	cmp	r2, #5
  64:	d10c      	bne.n	80 <GetAlgoId+0x80>
    if ((ret == 0) && (input[idx++] != 0)) {
  66:	4404      	add	r4, r0
  68:	7862      	ldrb	r2, [r4, #1]
  6a:	b962      	cbnz	r2, 86 <GetAlgoId+0x86>
        *inOutIdx = idx;
  6c:	9304      	str	r3, [sp, #16]
    *inOutIdx = idx;
  6e:	9b04      	ldr	r3, [sp, #16]
  70:	6033      	str	r3, [r6, #0]
    return 0;
  72:	2000      	movs	r0, #0
  74:	e001      	b.n	7a <GetAlgoId+0x7a>
  76:	f06f 0083 	mvn.w	r0, #131	; 0x83
}
  7a:	b006      	add	sp, #24
  7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret = ASN_TAG_NULL_E;
  80:	f06f 0090 	mvn.w	r0, #144	; 0x90
  84:	e7f9      	b.n	7a <GetAlgoId+0x7a>
        ret = ASN_EXPECT_0_E;
  86:	f06f 0091 	mvn.w	r0, #145	; 0x91
                    return ret;
  8a:	e7f6      	b.n	7a <GetAlgoId+0x7a>
        return ASN_PARSE_E;
  8c:	f06f 008b 	mvn.w	r0, #139	; 0x8b
  90:	e7f3      	b.n	7a <GetAlgoId+0x7a>
        return ASN_OBJECT_ID_E;
  92:	f06f 008f 	mvn.w	r0, #143	; 0x8f
  96:	e7f0      	b.n	7a <GetAlgoId+0x7a>

Disassembly of section .text.ToTraditionalInline_ex:

00000000 <ToTraditionalInline_ex>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	460e      	mov	r6, r1
   4:	b087      	sub	sp, #28
   6:	4615      	mov	r5, r2
   8:	461f      	mov	r7, r3
    if (input == NULL || inOutIdx == NULL)
   a:	4604      	mov	r4, r0
   c:	2800      	cmp	r0, #0
   e:	d042      	beq.n	96 <ToTraditionalInline_ex+0x96>
  10:	2900      	cmp	r1, #0
  12:	d040      	beq.n	96 <ToTraditionalInline_ex+0x96>
    idx = *inOutIdx;
  14:	680b      	ldr	r3, [r1, #0]
  16:	9303      	str	r3, [sp, #12]
    if (GetSequence(input, &idx, &length, sz) < 0)
  18:	a903      	add	r1, sp, #12
  1a:	4613      	mov	r3, r2
  1c:	aa05      	add	r2, sp, #20
  1e:	f7ff fffe 	bl	0 <ToTraditionalInline_ex>
  22:	2800      	cmp	r0, #0
  24:	da03      	bge.n	2e <ToTraditionalInline_ex+0x2e>
        return ASN_PARSE_E;
  26:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
  2a:	b007      	add	sp, #28
  2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (GetMyVersion(input, &idx, &version, sz) < 0)
  2e:	462b      	mov	r3, r5
  30:	aa04      	add	r2, sp, #16
  32:	a903      	add	r1, sp, #12
  34:	4620      	mov	r0, r4
  36:	f7ff fffe 	bl	0 <ToTraditionalInline_ex>
  3a:	2800      	cmp	r0, #0
  3c:	dbf3      	blt.n	26 <ToTraditionalInline_ex+0x26>
    if (GetAlgoId(input, &idx, algId, oidKeyType, sz) < 0)
  3e:	9500      	str	r5, [sp, #0]
  40:	2302      	movs	r3, #2
  42:	463a      	mov	r2, r7
  44:	a903      	add	r1, sp, #12
  46:	4620      	mov	r0, r4
  48:	f7ff fffe 	bl	0 <ToTraditionalInline_ex>
  4c:	2800      	cmp	r0, #0
  4e:	dbea      	blt.n	26 <ToTraditionalInline_ex+0x26>
    if (GetASNTag(input, &idx, &tag, sz) < 0)
  50:	462b      	mov	r3, r5
  52:	f10d 020b 	add.w	r2, sp, #11
  56:	a903      	add	r1, sp, #12
  58:	4620      	mov	r0, r4
  5a:	f7ff fffe 	bl	0 <ToTraditionalInline_ex>
  5e:	2800      	cmp	r0, #0
  60:	dbe1      	blt.n	26 <ToTraditionalInline_ex+0x26>
    idx = idx - 1; /* reset idx after finding tag */
  62:	9b03      	ldr	r3, [sp, #12]
  64:	3b01      	subs	r3, #1
  66:	9303      	str	r3, [sp, #12]
    if (tag == ASN_OBJECT_ID) {
  68:	f89d 300b 	ldrb.w	r3, [sp, #11]
  6c:	2b06      	cmp	r3, #6
  6e:	d00b      	beq.n	88 <ToTraditionalInline_ex+0x88>
    ret = GetOctetString(input, &idx, &length, sz);
  70:	462b      	mov	r3, r5
  72:	aa05      	add	r2, sp, #20
  74:	a903      	add	r1, sp, #12
  76:	4620      	mov	r0, r4
  78:	f7ff fffe 	bl	0 <ToTraditionalInline_ex>
        if (ret == BUFFER_E)
  7c:	3084      	adds	r0, #132	; 0x84
  7e:	d0d2      	beq.n	26 <ToTraditionalInline_ex+0x26>
    *inOutIdx = idx;
  80:	9b03      	ldr	r3, [sp, #12]
    return length;
  82:	9805      	ldr	r0, [sp, #20]
    *inOutIdx = idx;
  84:	6033      	str	r3, [r6, #0]
    return length;
  86:	e7d0      	b.n	2a <ToTraditionalInline_ex+0x2a>
        if (SkipObjectId(input, &idx, sz) < 0)
  88:	462a      	mov	r2, r5
  8a:	4620      	mov	r0, r4
  8c:	f7ff fffe 	bl	0 <ToTraditionalInline_ex>
  90:	2800      	cmp	r0, #0
  92:	daed      	bge.n	70 <ToTraditionalInline_ex+0x70>
  94:	e7c7      	b.n	26 <ToTraditionalInline_ex+0x26>
        return BAD_FUNC_ARG;
  96:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  9a:	e7c6      	b.n	2a <ToTraditionalInline_ex+0x2a>

Disassembly of section .text.ToTraditionalInline:

00000000 <ToTraditionalInline>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    return ToTraditionalInline_ex(input, inOutIdx, sz, &oid);
   2:	ab01      	add	r3, sp, #4
   4:	f7ff fffe 	bl	0 <ToTraditionalInline>
}
   8:	b003      	add	sp, #12
   a:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.ToTraditional_ex:

00000000 <ToTraditional_ex>:
{
   0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   2:	4613      	mov	r3, r2
    word32 inOutIdx = 0;
   4:	2200      	movs	r2, #0
{
   6:	460e      	mov	r6, r1
    word32 inOutIdx = 0;
   8:	9201      	str	r2, [sp, #4]
    if (input == NULL)
   a:	4605      	mov	r5, r0
   c:	b188      	cbz	r0, 32 <ToTraditional_ex+0x32>
    length = ToTraditionalInline_ex(input, &inOutIdx, sz, algId);
   e:	460a      	mov	r2, r1
  10:	a901      	add	r1, sp, #4
  12:	f7ff fffe 	bl	0 <ToTraditional_ex>
    if (length < 0)
  16:	1e04      	subs	r4, r0, #0
  18:	db08      	blt.n	2c <ToTraditional_ex+0x2c>
    if ((word32)length + inOutIdx > sz)
  1a:	9901      	ldr	r1, [sp, #4]
  1c:	1863      	adds	r3, r4, r1
  1e:	42b3      	cmp	r3, r6
  20:	d80a      	bhi.n	38 <ToTraditional_ex+0x38>
    XMEMMOVE(input, input + inOutIdx, (size_t)length);
  22:	4622      	mov	r2, r4
  24:	4429      	add	r1, r5
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <memmove>
}
  2c:	4620      	mov	r0, r4
  2e:	b002      	add	sp, #8
  30:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  32:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  36:	e7f9      	b.n	2c <ToTraditional_ex+0x2c>
        return BUFFER_E;
  38:	f06f 0483 	mvn.w	r4, #131	; 0x83
  3c:	e7f6      	b.n	2c <ToTraditional_ex+0x2c>

Disassembly of section .text.ToTraditional:

00000000 <ToTraditional>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    return ToTraditional_ex(input, sz, &oid);
   2:	aa01      	add	r2, sp, #4
   4:	f7ff fffe 	bl	0 <ToTraditional>
}
   8:	b003      	add	sp, #12
   a:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.wc_GetPkcs8TraditionalOffset:

00000000 <wc_GetPkcs8TraditionalOffset>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    if (input == NULL || inOutIdx == NULL || (*inOutIdx > sz))
   2:	b140      	cbz	r0, 16 <wc_GetPkcs8TraditionalOffset+0x16>
   4:	b139      	cbz	r1, 16 <wc_GetPkcs8TraditionalOffset+0x16>
   6:	680b      	ldr	r3, [r1, #0]
   8:	4293      	cmp	r3, r2
   a:	d804      	bhi.n	16 <wc_GetPkcs8TraditionalOffset+0x16>
    length = ToTraditionalInline_ex(input, inOutIdx, sz, &algId);
   c:	ab01      	add	r3, sp, #4
   e:	f7ff fffe 	bl	0 <wc_GetPkcs8TraditionalOffset>
}
  12:	b002      	add	sp, #8
  14:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1a:	e7fa      	b.n	12 <wc_GetPkcs8TraditionalOffset+0x12>

Disassembly of section .text.FreeAltNames:

00000000 <FreeAltNames>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
    while (altNames) {
   4:	b904      	cbnz	r4, 8 <FreeAltNames+0x8>
}
   6:	bd38      	pop	{r3, r4, r5, pc}
        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);
   8:	68e0      	ldr	r0, [r4, #12]
        DNS_entry* tmp = altNames->next;
   a:	6825      	ldr	r5, [r4, #0]
        XFREE(altNames->name, heap, DYNAMIC_TYPE_ALTNAME);
   c:	b108      	cbz	r0, 12 <FreeAltNames+0x12>
   e:	f7ff fffe 	bl	0 <free>
        XFREE(altNames,       heap, DYNAMIC_TYPE_ALTNAME);
  12:	4620      	mov	r0, r4
  14:	f7ff fffe 	bl	0 <free>
        altNames = tmp;
  18:	462c      	mov	r4, r5
  1a:	e7f3      	b.n	4 <FreeAltNames+0x4>

Disassembly of section .text.AltNameNew:

00000000 <AltNameNew>:
{
   0:	b510      	push	{r4, lr}
    ret = (DNS_entry*)XMALLOC(sizeof(DNS_entry), heap, DYNAMIC_TYPE_ALTNAME);
   2:	2010      	movs	r0, #16
   4:	f7ff fffe 	bl	0 <malloc>
    if (ret != NULL) {
   8:	4604      	mov	r4, r0
   a:	b118      	cbz	r0, 14 <AltNameNew+0x14>
        XMEMSET(ret, 0, sizeof(DNS_entry));
   c:	2210      	movs	r2, #16
   e:	2100      	movs	r1, #0
  10:	f7ff fffe 	bl	0 <memset>
}
  14:	4620      	mov	r0, r4
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.FreeNameSubtrees:

00000000 <FreeNameSubtrees>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
    while (names) {
   4:	b904      	cbnz	r4, 8 <FreeNameSubtrees+0x8>
}
   6:	bd38      	pop	{r3, r4, r5, pc}
        XFREE(names->name, heap, DYNAMIC_TYPE_ALTNAME);
   8:	e9d4 5000 	ldrd	r5, r0, [r4]
   c:	b108      	cbz	r0, 12 <FreeNameSubtrees+0x12>
   e:	f7ff fffe 	bl	0 <free>
        XFREE(names,       heap, DYNAMIC_TYPE_ALTNAME);
  12:	4620      	mov	r0, r4
  14:	f7ff fffe 	bl	0 <free>
        names = tmp;
  18:	462c      	mov	r4, r5
  1a:	e7f3      	b.n	4 <FreeNameSubtrees+0x4>

Disassembly of section .text.HashIdAlg:

00000000 <HashIdAlg>:
}
   0:	2004      	movs	r0, #4
   2:	4770      	bx	lr

Disassembly of section .text.CalcHashId:

00000000 <CalcHashId>:
        ret = wc_ShaHash(data, len, hash);
   0:	f7ff bffe 	b.w	0 <wc_ShaHash>

Disassembly of section .text.CalcHashId_ex:

00000000 <CalcHashId_ex>:
    if (hashAlg == WC_SHA) {
   0:	2b04      	cmp	r3, #4
   2:	d101      	bne.n	8 <CalcHashId_ex+0x8>
        ret = wc_ShaHash(data, len, hash);
   4:	f7ff bffe 	b.w	0 <wc_ShaHash>
}
   8:	f06f 00ad 	mvn.w	r0, #173	; 0xad
   c:	4770      	bx	lr

Disassembly of section .text.GetName:

00000000 <GetName>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b093      	sub	sp, #76	; 0x4c
   6:	4605      	mov	r5, r0
   8:	4616      	mov	r6, r2
    if (nameType == ISSUER) {
   a:	9105      	str	r1, [sp, #20]
   c:	b9d1      	cbnz	r1, 44 <GetName+0x44>
        full = cert->issuer;
   e:	f100 036d 	add.w	r3, r0, #109	; 0x6d
  12:	9304      	str	r3, [sp, #16]
        hash = cert->issuerHash;
  14:	f100 044c 	add.w	r4, r0, #76	; 0x4c
    if (cert->srcIdx >= (word32)maxIdx) {
  18:	f8d5 3278 	ldr.w	r3, [r5, #632]	; 0x278
  1c:	42b3      	cmp	r3, r6
  1e:	f080 8182 	bcs.w	326 <GetName+0x326>
    localIdx = cert->srcIdx;
  22:	930a      	str	r3, [sp, #40]	; 0x28
    if (GetASNTag(cert->source, &localIdx, &tag, (word32)maxIdx) < 0) {
  24:	f8d5 0274 	ldr.w	r0, [r5, #628]	; 0x274
  28:	4633      	mov	r3, r6
  2a:	f10d 021f 	add.w	r2, sp, #31
  2e:	a90a      	add	r1, sp, #40	; 0x28
  30:	f7ff fffe 	bl	0 <GetName>
  34:	2800      	cmp	r0, #0
  36:	da0b      	bge.n	50 <GetName+0x50>
        return ASN_PARSE_E;
  38:	f06f 098b 	mvn.w	r9, #139	; 0x8b
}
  3c:	4648      	mov	r0, r9
  3e:	b013      	add	sp, #76	; 0x4c
  40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        full = cert->subject;
  44:	f200 136d 	addw	r3, r0, #365	; 0x16d
  48:	9304      	str	r3, [sp, #16]
        hash = cert->subjectHash;
  4a:	f100 0438 	add.w	r4, r0, #56	; 0x38
  4e:	e7e3      	b.n	18 <GetName+0x18>
    if (tag == ASN_OBJECT_ID) {
  50:	f89d 301f 	ldrb.w	r3, [sp, #31]
  54:	2b06      	cmp	r3, #6
  56:	d04b      	beq.n	f0 <GetName+0xf0>
    localIdx = cert->srcIdx;
  58:	f8d5 3278 	ldr.w	r3, [r5, #632]	; 0x278
  5c:	930a      	str	r3, [sp, #40]	; 0x28
    if (GetASNTag(cert->source, &localIdx, &tag, (word32)maxIdx) < 0) {
  5e:	f8d5 0274 	ldr.w	r0, [r5, #628]	; 0x274
  62:	4633      	mov	r3, r6
  64:	f10d 021f 	add.w	r2, sp, #31
  68:	a90a      	add	r1, sp, #40	; 0x28
  6a:	f7ff fffe 	bl	0 <GetName>
  6e:	2800      	cmp	r0, #0
  70:	dbe2      	blt.n	38 <GetName+0x38>
    localIdx = cert->srcIdx + 1;
  72:	f8d5 3278 	ldr.w	r3, [r5, #632]	; 0x278
    if (GetLength(cert->source, &localIdx, &length, (word32)maxIdx) < 0) {
  76:	f8d5 0274 	ldr.w	r0, [r5, #628]	; 0x274
    localIdx = cert->srcIdx + 1;
  7a:	3301      	adds	r3, #1
  7c:	930a      	str	r3, [sp, #40]	; 0x28
    if (GetLength(cert->source, &localIdx, &length, (word32)maxIdx) < 0) {
  7e:	aa09      	add	r2, sp, #36	; 0x24
  80:	4633      	mov	r3, r6
  82:	f7ff fffe 	bl	0 <GetName>
  86:	2800      	cmp	r0, #0
  88:	dbd6      	blt.n	38 <GetName+0x38>
    length += (int)(localIdx - cert->srcIdx);
  8a:	f8d5 0278 	ldr.w	r0, [r5, #632]	; 0x278
  8e:	990a      	ldr	r1, [sp, #40]	; 0x28
  90:	9b09      	ldr	r3, [sp, #36]	; 0x24
    return GetCertName(cert, full, hash, nameType, cert->source, &cert->srcIdx,
  92:	f8d5 7274 	ldr.w	r7, [r5, #628]	; 0x274
    word32 srcIdx = *inOutIdx;
  96:	900d      	str	r0, [sp, #52]	; 0x34
    length += (int)(localIdx - cert->srcIdx);
  98:	1a09      	subs	r1, r1, r0
  9a:	4419      	add	r1, r3
    return GetCertName(cert, full, hash, nameType, cert->source, &cert->srcIdx,
  9c:	eb00 0a01 	add.w	sl, r0, r1
        ret = wc_ShaHash(data, len, hash);
  a0:	4622      	mov	r2, r4
  a2:	4438      	add	r0, r7
    length += (int)(localIdx - cert->srcIdx);
  a4:	9109      	str	r1, [sp, #36]	; 0x24
        ret = wc_ShaHash(data, len, hash);
  a6:	f7ff fffe 	bl	0 <wc_ShaHash>
    if (CalcHashId_ex(input + *inOutIdx, maxIdx - *inOutIdx, hash,
  aa:	4681      	mov	r9, r0
  ac:	2800      	cmp	r0, #0
  ae:	d1c3      	bne.n	38 <GetName+0x38>
    if (GetSequence(input, &srcIdx, &length, maxIdx) < 0) {
  b0:	4653      	mov	r3, sl
  b2:	aa0b      	add	r2, sp, #44	; 0x2c
  b4:	a90d      	add	r1, sp, #52	; 0x34
  b6:	4638      	mov	r0, r7
  b8:	f7ff fffe 	bl	0 <GetName>
  bc:	2800      	cmp	r0, #0
  be:	dbbb      	blt.n	38 <GetName+0x38>
    if (nameType == SUBJECT) {
  c0:	9905      	ldr	r1, [sp, #20]
        cert->subjectRaw = &input[srcIdx];
  c2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
        cert->subjectRawLen = length;
  c4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    if (nameType == SUBJECT) {
  c6:	2901      	cmp	r1, #1
        cert->subjectRaw = &input[srcIdx];
  c8:	bf04      	itt	eq
  ca:	18f9      	addeq	r1, r7, r3
        cert->subjectRawLen = length;
  cc:	e9c5 12c4 	strdeq	r1, r2, [r5, #784]	; 0x310
    length += (int)srcIdx;
  d0:	4413      	add	r3, r2
  d2:	930b      	str	r3, [sp, #44]	; 0x2c
    idx = 0;
  d4:	f04f 0b00 	mov.w	fp, #0
    while (srcIdx < (word32)length) {
  d8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  da:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  dc:	4293      	cmp	r3, r2
  de:	f04f 0200 	mov.w	r2, #0
  e2:	d30f      	bcc.n	104 <GetName+0x104>
    full[idx++] = 0;
  e4:	9904      	ldr	r1, [sp, #16]
  e6:	f801 200b 	strb.w	r2, [r1, fp]
    *inOutIdx = srcIdx;
  ea:	f8c5 3278 	str.w	r3, [r5, #632]	; 0x278
    return GetCertName(cert, full, hash, nameType, cert->source, &cert->srcIdx,
  ee:	e7a5      	b.n	3c <GetName+0x3c>
        if (SkipObjectId(cert->source, &cert->srcIdx, (word32)maxIdx) < 0)
  f0:	f8d5 0274 	ldr.w	r0, [r5, #628]	; 0x274
  f4:	4632      	mov	r2, r6
  f6:	f505 711e 	add.w	r1, r5, #632	; 0x278
  fa:	f7ff fffe 	bl	0 <GetName>
  fe:	2800      	cmp	r0, #0
 100:	daaa      	bge.n	58 <GetName+0x58>
 102:	e799      	b.n	38 <GetName+0x38>
        int         strLen  = 0;
 104:	920f      	str	r2, [sp, #60]	; 0x3c
        if (GetSet(input, &srcIdx, &dummy, maxIdx) < 0) {
 106:	4653      	mov	r3, sl
 108:	aa0c      	add	r2, sp, #48	; 0x30
 10a:	a90d      	add	r1, sp, #52	; 0x34
 10c:	4638      	mov	r0, r7
 10e:	f7ff fffe 	bl	0 <GetName>
        if (GetSequence(input, &srcIdx, &dummy, maxIdx) <= 0) {
 112:	4653      	mov	r3, sl
 114:	aa0c      	add	r2, sp, #48	; 0x30
 116:	a90d      	add	r1, sp, #52	; 0x34
 118:	4638      	mov	r0, r7
 11a:	f7ff fffe 	bl	0 <GetName>
 11e:	2800      	cmp	r0, #0
 120:	dd21      	ble.n	166 <GetName+0x166>
        ret = GetASNObjectId(input, &srcIdx, &oidSz, maxIdx);
 122:	4653      	mov	r3, sl
 124:	aa0e      	add	r2, sp, #56	; 0x38
 126:	a90d      	add	r1, sp, #52	; 0x34
 128:	4638      	mov	r0, r7
 12a:	f7ff fffe 	bl	0 <GetName>
        if (ret != 0) {
 12e:	4604      	mov	r4, r0
 130:	b9d8      	cbnz	r0, 16a <GetName+0x16a>
        if ((srcIdx + sizeof(joint)) > (word32)maxIdx) {
 132:	990d      	ldr	r1, [sp, #52]	; 0x34
 134:	1ccb      	adds	r3, r1, #3
 136:	459a      	cmp	sl, r3
 138:	d315      	bcc.n	166 <GetName+0x166>
        XMEMCPY(joint, &input[srcIdx], sizeof(joint));
 13a:	2203      	movs	r2, #3
 13c:	4439      	add	r1, r7
 13e:	a808      	add	r0, sp, #32
 140:	f7ff fffe 	bl	0 <memcpy>
        if (joint[0] == 0x55 && joint[1] == 0x04) {
 144:	f89d 2020 	ldrb.w	r2, [sp, #32]
 148:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 14a:	2a55      	cmp	r2, #85	; 0x55
 14c:	d14b      	bne.n	1e6 <GetName+0x1e6>
 14e:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
 152:	2a04      	cmp	r2, #4
 154:	f040 808c 	bne.w	270 <GetName+0x270>
            srcIdx += 3;
 158:	1cda      	adds	r2, r3, #3
    if ((idx + 1) > maxIdx)
 15a:	3304      	adds	r3, #4
 15c:	459a      	cmp	sl, r3
            id = joint[2];
 15e:	f89d 6022 	ldrb.w	r6, [sp, #34]	; 0x22
            srcIdx += 3;
 162:	920d      	str	r2, [sp, #52]	; 0x34
    if ((idx + 1) > maxIdx)
 164:	d203      	bcs.n	16e <GetName+0x16e>
                switch (id) {
 166:	f06f 048b 	mvn.w	r4, #139	; 0x8b
            return ASN_PARSE_E;
 16a:	46a1      	mov	r9, r4
 16c:	e766      	b.n	3c <GetName+0x3c>
    *tag = input[idx++];
 16e:	9310      	str	r3, [sp, #64]	; 0x40
    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)
 170:	2301      	movs	r3, #1
    *tag = input[idx++];
 172:	f817 8002 	ldrb.w	r8, [r7, r2]
    if (GetLength_ex(input, &idx, &length, maxIdx, check) < 0)
 176:	9300      	str	r3, [sp, #0]
 178:	aa11      	add	r2, sp, #68	; 0x44
 17a:	4653      	mov	r3, sl
 17c:	a910      	add	r1, sp, #64	; 0x40
 17e:	4638      	mov	r0, r7
 180:	f7ff fffe 	bl	0 <GetName>
 184:	2800      	cmp	r0, #0
 186:	dbee      	blt.n	166 <GetName+0x166>
    *len      = length;
 188:	9a11      	ldr	r2, [sp, #68]	; 0x44
    *inOutIdx = idx;
 18a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    *len      = length;
 18c:	920f      	str	r2, [sp, #60]	; 0x3c
            if (GetHeader(input, &b, &srcIdx, &strLen, maxIdx, 1) < 0) {
 18e:	2a00      	cmp	r2, #0
    *inOutIdx = idx;
 190:	930d      	str	r3, [sp, #52]	; 0x34
            if (GetHeader(input, &b, &srcIdx, &strLen, maxIdx, 1) < 0) {
 192:	dbe8      	blt.n	166 <GetName+0x166>
            if (id == ASN_COMMON_NAME) {
 194:	2e03      	cmp	r6, #3
 196:	d10a      	bne.n	1ae <GetName+0x1ae>
                if (nameType == SUBJECT) {
 198:	9905      	ldr	r1, [sp, #20]
 19a:	2901      	cmp	r1, #1
 19c:	d104      	bne.n	1a8 <GetName+0x1a8>
                    cert->subjectCN = (char *)&input[srcIdx];
 19e:	443b      	add	r3, r7
                    cert->subjectCNLen = strLen;
 1a0:	e9c5 3219 	strd	r3, r2, [r5, #100]	; 0x64
                    cert->subjectCNEnc = (char)b;
 1a4:	f885 806c 	strb.w	r8, [r5, #108]	; 0x6c
                copy = WOLFSSL_COMMON_NAME;
 1a8:	4960      	ldr	r1, [pc, #384]	; (32c <GetName+0x32c>)
                copyLen = sizeof(WOLFSSL_COMMON_NAME) - 1;
 1aa:	2404      	movs	r4, #4
 1ac:	e019      	b.n	1e2 <GetName+0x1e2>
            else if (id == ASN_SUR_NAME) {
 1ae:	2e04      	cmp	r6, #4
 1b0:	f000 809c 	beq.w	2ec <GetName+0x2ec>
            else if (id == ASN_COUNTRY_NAME) {
 1b4:	2e06      	cmp	r6, #6
 1b6:	f000 809c 	beq.w	2f2 <GetName+0x2f2>
            else if (id == ASN_LOCALITY_NAME) {
 1ba:	2e07      	cmp	r6, #7
 1bc:	f000 809c 	beq.w	2f8 <GetName+0x2f8>
            else if (id == ASN_STATE_NAME) {
 1c0:	2e08      	cmp	r6, #8
 1c2:	f000 809c 	beq.w	2fe <GetName+0x2fe>
            else if (id == ASN_ORG_NAME) {
 1c6:	2e0a      	cmp	r6, #10
 1c8:	f000 809c 	beq.w	304 <GetName+0x304>
            else if (id == ASN_ORGUNIT_NAME) {
 1cc:	2e0b      	cmp	r6, #11
 1ce:	f000 809c 	beq.w	30a <GetName+0x30a>
            else if (id == ASN_SERIAL_NUMBER) {
 1d2:	2e05      	cmp	r6, #5
 1d4:	f000 809c 	beq.w	310 <GetName+0x310>
            else if (id == ASN_USER_ID) {
 1d8:	2e12      	cmp	r6, #18
 1da:	f040 809c 	bne.w	316 <GetName+0x316>
                copy = WOLFSSL_USER_ID;
 1de:	4954      	ldr	r1, [pc, #336]	; (330 <GetName+0x330>)
                copyLen = sizeof(WOLFSSL_USER_ID) - 1;
 1e0:	2405      	movs	r4, #5
        byte        tooBig  = FALSE;
 1e2:	2600      	movs	r6, #0
 1e4:	e064      	b.n	2b0 <GetName+0x2b0>
            if (joint[0] == 0x2a && joint[1] == 0x86) {  /* email id hdr 42.134.* */
 1e6:	2a2a      	cmp	r2, #42	; 0x2a
 1e8:	d12e      	bne.n	248 <GetName+0x248>
 1ea:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
                email = TRUE;
 1ee:	9403      	str	r4, [sp, #12]
            if (joint[0] == 0x2a && joint[1] == 0x86) {  /* email id hdr 42.134.* */
 1f0:	2a86      	cmp	r2, #134	; 0x86
                email = TRUE;
 1f2:	bf15      	itete	ne
 1f4:	4626      	movne	r6, r4
 1f6:	2601      	moveq	r6, #1
 1f8:	46a0      	movne	r8, r4
 1fa:	f04f 0898 	moveq.w	r8, #152	; 0x98
            srcIdx += (word32)oidSz + 1;
 1fe:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 200:	3301      	adds	r3, #1
 202:	4413      	add	r3, r2
 204:	930d      	str	r3, [sp, #52]	; 0x34
            if (GetLength(input, &srcIdx, &strLen, maxIdx) < 0) {
 206:	aa0f      	add	r2, sp, #60	; 0x3c
 208:	4653      	mov	r3, sl
 20a:	a90d      	add	r1, sp, #52	; 0x34
 20c:	4638      	mov	r0, r7
 20e:	f7ff fffe 	bl	0 <GetName>
 212:	2800      	cmp	r0, #0
 214:	dba7      	blt.n	166 <GetName+0x166>
            if (strLen > (int)(WC_ASN_NAME_MAX - idx)) {
 216:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 218:	f5cb 7180 	rsb	r1, fp, #256	; 0x100
                tooBig = TRUE;
 21c:	4299      	cmp	r1, r3
 21e:	bfac      	ite	ge
 220:	2200      	movge	r2, #0
 222:	2201      	movlt	r2, #1
            if (email) {
 224:	b366      	cbz	r6, 280 <GetName+0x280>
                if ((copyLen + strLen) > (int)(WC_ASN_NAME_MAX - idx)) {
 226:	f103 000e 	add.w	r0, r3, #14
 22a:	4281      	cmp	r1, r0
 22c:	bfa8      	it	ge
 22e:	4616      	movge	r6, r2
                    if (nameType == SUBJECT) {
 230:	9a05      	ldr	r2, [sp, #20]
                if ((copyLen + strLen) > (int)(WC_ASN_NAME_MAX - idx)) {
 232:	4940      	ldr	r1, [pc, #256]	; (334 <GetName+0x334>)
 234:	bfb8      	it	lt
 236:	2100      	movlt	r1, #0
                    if (nameType == SUBJECT) {
 238:	2a01      	cmp	r2, #1
 23a:	d103      	bne.n	244 <GetName+0x244>
                        cert->subjectEmail = (char*)&input[srcIdx];
 23c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 23e:	443a      	add	r2, r7
                        cert->subjectEmailLen = strLen;
 240:	e9c5 23c6 	strd	r2, r3, [r5, #792]	; 0x318
                copyLen = sizeof(WOLFSSL_EMAIL_ADDR) - 1;
 244:	240e      	movs	r4, #14
 246:	e01d      	b.n	284 <GetName+0x284>
            if (joint[0] == 0x9  && joint[1] == 0x92) { /* uid id hdr 9.146.* */
 248:	2a09      	cmp	r2, #9
 24a:	d111      	bne.n	270 <GetName+0x270>
 24c:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
 250:	2a92      	cmp	r2, #146	; 0x92
 252:	d10d      	bne.n	270 <GetName+0x270>
                id    = input[srcIdx + (word32)oidSz - 1];
 254:	990e      	ldr	r1, [sp, #56]	; 0x38
 256:	18fa      	adds	r2, r7, r3
 258:	440a      	add	r2, r1
 25a:	f812 8c01 	ldrb.w	r8, [r2, #-1]
                if (id == 0x01)
 25e:	f1b8 0f01 	cmp.w	r8, #1
 262:	d109      	bne.n	278 <GetName+0x278>
                pilot = TRUE;
 264:	f8cd 800c 	str.w	r8, [sp, #12]
            byte email = FALSE;
 268:	4626      	mov	r6, r4
                    id = ASN_USER_ID;
 26a:	f04f 0812 	mov.w	r8, #18
 26e:	e7c6      	b.n	1fe <GetName+0x1fe>
            byte email = FALSE;
 270:	4626      	mov	r6, r4
            byte pilot = FALSE;
 272:	9403      	str	r4, [sp, #12]
        byte        id      = 0;
 274:	46a0      	mov	r8, r4
 276:	e7c2      	b.n	1fe <GetName+0x1fe>
                pilot = TRUE;
 278:	2201      	movs	r2, #1
            byte email = FALSE;
 27a:	4626      	mov	r6, r4
                pilot = TRUE;
 27c:	9203      	str	r2, [sp, #12]
 27e:	e7be      	b.n	1fe <GetName+0x1fe>
 280:	4616      	mov	r6, r2
        const char* copy    = NULL;
 282:	2100      	movs	r1, #0
            if (pilot) {
 284:	9b03      	ldr	r3, [sp, #12]
 286:	b19b      	cbz	r3, 2b0 <GetName+0x2b0>
                switch (id) {
 288:	f1b8 0f19 	cmp.w	r8, #25
 28c:	d045      	beq.n	31a <GetName+0x31a>
 28e:	d809      	bhi.n	2a4 <GetName+0x2a4>
 290:	f1b8 0f12 	cmp.w	r8, #18
 294:	d044      	beq.n	320 <GetName+0x320>
 296:	f1b8 0f13 	cmp.w	r8, #19
 29a:	f47f af64 	bne.w	166 <GetName+0x166>
                        copy = WOLFSSL_FAVOURITE_DRINK;
 29e:	4926      	ldr	r1, [pc, #152]	; (338 <GetName+0x338>)
                        copyLen = sizeof(WOLFSSL_FAVOURITE_DRINK) - 1;
 2a0:	2410      	movs	r4, #16
 2a2:	e005      	b.n	2b0 <GetName+0x2b0>
                switch (id) {
 2a4:	f1b8 0f97 	cmp.w	r8, #151	; 0x97
 2a8:	f47f af5d 	bne.w	166 <GetName+0x166>
                        copy = WOLFSSL_CONTENT_TYPE;
 2ac:	4923      	ldr	r1, [pc, #140]	; (33c <GetName+0x33c>)
                        copyLen = sizeof(WOLFSSL_CONTENT_TYPE) - 1;
 2ae:	240d      	movs	r4, #13
        if ((copyLen + strLen) > (int)(WC_ASN_NAME_MAX - idx))
 2b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 2b2:	f5cb 7280 	rsb	r2, fp, #256	; 0x100
 2b6:	4423      	add	r3, r4
 2b8:	4293      	cmp	r3, r2
 2ba:	dc12      	bgt.n	2e2 <GetName+0x2e2>
        if ((copy != NULL) && !tooBig) {
 2bc:	b189      	cbz	r1, 2e2 <GetName+0x2e2>
 2be:	b986      	cbnz	r6, 2e2 <GetName+0x2e2>
            XMEMCPY(&full[idx], copy, (size_t)copyLen);
 2c0:	9b04      	ldr	r3, [sp, #16]
 2c2:	4622      	mov	r2, r4
 2c4:	eb03 000b 	add.w	r0, r3, fp
 2c8:	f7ff fffe 	bl	0 <memcpy>
            XMEMCPY(&full[idx], &input[srcIdx], (size_t)strLen);
 2cc:	9b04      	ldr	r3, [sp, #16]
 2ce:	990d      	ldr	r1, [sp, #52]	; 0x34
 2d0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
            idx += (word32)copyLen;
 2d2:	44a3      	add	fp, r4
            XMEMCPY(&full[idx], &input[srcIdx], (size_t)strLen);
 2d4:	eb03 000b 	add.w	r0, r3, fp
 2d8:	4439      	add	r1, r7
 2da:	f7ff fffe 	bl	0 <memcpy>
            idx += (word32)strLen;
 2de:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 2e0:	449b      	add	fp, r3
        srcIdx += (word32)strLen;
 2e2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 2e4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 2e6:	4413      	add	r3, r2
 2e8:	930d      	str	r3, [sp, #52]	; 0x34
 2ea:	e6f5      	b.n	d8 <GetName+0xd8>
                copy = WOLFSSL_SUR_NAME;
 2ec:	4914      	ldr	r1, [pc, #80]	; (340 <GetName+0x340>)
                copyLen = sizeof(WOLFSSL_SUR_NAME) - 1;
 2ee:	4634      	mov	r4, r6
 2f0:	e777      	b.n	1e2 <GetName+0x1e2>
                copy = WOLFSSL_COUNTRY_NAME;
 2f2:	4914      	ldr	r1, [pc, #80]	; (344 <GetName+0x344>)
                copyLen = sizeof(WOLFSSL_COUNTRY_NAME) - 1;
 2f4:	2403      	movs	r4, #3
 2f6:	e774      	b.n	1e2 <GetName+0x1e2>
                copy = WOLFSSL_LOCALITY_NAME;
 2f8:	4913      	ldr	r1, [pc, #76]	; (348 <GetName+0x348>)
                copyLen = sizeof(WOLFSSL_LOCALITY_NAME) - 1;
 2fa:	2403      	movs	r4, #3
 2fc:	e771      	b.n	1e2 <GetName+0x1e2>
                copy = WOLFSSL_STATE_NAME;
 2fe:	4913      	ldr	r1, [pc, #76]	; (34c <GetName+0x34c>)
                copyLen = sizeof(WOLFSSL_STATE_NAME) - 1;
 300:	2404      	movs	r4, #4
 302:	e76e      	b.n	1e2 <GetName+0x1e2>
                copy = WOLFSSL_ORG_NAME;
 304:	4912      	ldr	r1, [pc, #72]	; (350 <GetName+0x350>)
                copyLen = sizeof(WOLFSSL_ORG_NAME) - 1;
 306:	2403      	movs	r4, #3
 308:	e76b      	b.n	1e2 <GetName+0x1e2>
                copy = WOLFSSL_ORGUNIT_NAME;
 30a:	4912      	ldr	r1, [pc, #72]	; (354 <GetName+0x354>)
                copyLen = sizeof(WOLFSSL_ORGUNIT_NAME) - 1;
 30c:	2404      	movs	r4, #4
 30e:	e768      	b.n	1e2 <GetName+0x1e2>
                copy = WOLFSSL_SERIAL_NUMBER;
 310:	4911      	ldr	r1, [pc, #68]	; (358 <GetName+0x358>)
                copyLen = sizeof(WOLFSSL_SERIAL_NUMBER) - 1;
 312:	240e      	movs	r4, #14
 314:	e765      	b.n	1e2 <GetName+0x1e2>
        const char* copy    = NULL;
 316:	2100      	movs	r1, #0
 318:	e763      	b.n	1e2 <GetName+0x1e2>
                switch (id) {
 31a:	4910      	ldr	r1, [pc, #64]	; (35c <GetName+0x35c>)
 31c:	2404      	movs	r4, #4
 31e:	e7c7      	b.n	2b0 <GetName+0x2b0>
                        copy = WOLFSSL_USER_ID;
 320:	4903      	ldr	r1, [pc, #12]	; (330 <GetName+0x330>)
                        copyLen = sizeof(WOLFSSL_USER_ID) - 1;
 322:	2405      	movs	r4, #5
 324:	e7c4      	b.n	2b0 <GetName+0x2b0>
        return BUFFER_E;
 326:	f06f 0983 	mvn.w	r9, #131	; 0x83
 32a:	e687      	b.n	3c <GetName+0x3c>
 32c:	00000020 	.word	0x00000020
 330:	00000025 	.word	0x00000025
 334:	00000000 	.word	0x00000000
 338:	0000000f 	.word	0x0000000f
 33c:	0000005a 	.word	0x0000005a
 340:	00000030 	.word	0x00000030
 344:	00000035 	.word	0x00000035
 348:	00000039 	.word	0x00000039
 34c:	0000003d 	.word	0x0000003d
 350:	00000042 	.word	0x00000042
 354:	00000046 	.word	0x00000046
 358:	0000004b 	.word	0x0000004b
 35c:	0000002b 	.word	0x0000002b

Disassembly of section .text.ExtractDate:

00000000 <ExtractDate>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4614      	mov	r4, r2
   6:	460f      	mov	r7, r1
   8:	4605      	mov	r5, r0
    XMEMSET(certTime, 0, sizeof(struct tm));
   a:	2224      	movs	r2, #36	; 0x24
   c:	2100      	movs	r1, #0
   e:	4620      	mov	r0, r4
{
  10:	461e      	mov	r6, r3
    XMEMSET(certTime, 0, sizeof(struct tm));
  12:	f7ff fffe 	bl	0 <memset>
    if (format == ASN_UTC_TIME) {
  16:	2f17      	cmp	r7, #23
        if (GetTime(&certTime->tm_year, date, idx) != 0) return 0;
  18:	f104 0814 	add.w	r8, r4, #20
    if (format == ASN_UTC_TIME) {
  1c:	d135      	bne.n	8a <ExtractDate+0x8a>
        if (btoi(date[*idx]) >= 5)
  1e:	6833      	ldr	r3, [r6, #0]
  20:	5ceb      	ldrb	r3, [r5, r3]
  22:	3b30      	subs	r3, #48	; 0x30
  24:	2b04      	cmp	r3, #4
            certTime->tm_year = 1900;
  26:	bf8c      	ite	hi
  28:	f240 736c 	movwhi	r3, #1900	; 0x76c
            certTime->tm_year = 2000;
  2c:	f44f 63fa 	movls.w	r3, #2000	; 0x7d0
        certTime->tm_year *= 100;
  30:	6163      	str	r3, [r4, #20]
    if (GetTime(&certTime->tm_year, date, idx) != 0) return 0;
  32:	4632      	mov	r2, r6
  34:	4629      	mov	r1, r5
  36:	4640      	mov	r0, r8
  38:	f7ff fffe 	bl	0 <ExtractDate>
  3c:	bb58      	cbnz	r0, 96 <ExtractDate+0x96>
    certTime->tm_year -= 1900;
  3e:	6963      	ldr	r3, [r4, #20]
  40:	f2a3 736c 	subw	r3, r3, #1900	; 0x76c
  44:	6163      	str	r3, [r4, #20]
    if (GetTime(&certTime->tm_mon , date, idx) != 0) return 0;
  46:	4629      	mov	r1, r5
  48:	f104 0010 	add.w	r0, r4, #16
  4c:	f7ff fffe 	bl	0 <ExtractDate>
  50:	bb08      	cbnz	r0, 96 <ExtractDate+0x96>
    certTime->tm_mon  -= 1;
  52:	6923      	ldr	r3, [r4, #16]
  54:	3b01      	subs	r3, #1
  56:	6123      	str	r3, [r4, #16]
    if (GetTime(&certTime->tm_mday, date, idx) != 0) return 0;
  58:	4629      	mov	r1, r5
  5a:	f104 000c 	add.w	r0, r4, #12
  5e:	f7ff fffe 	bl	0 <ExtractDate>
  62:	b9c0      	cbnz	r0, 96 <ExtractDate+0x96>
    if (GetTime(&certTime->tm_hour, date, idx) != 0) return 0;
  64:	4629      	mov	r1, r5
  66:	f104 0008 	add.w	r0, r4, #8
  6a:	f7ff fffe 	bl	0 <ExtractDate>
  6e:	b990      	cbnz	r0, 96 <ExtractDate+0x96>
    if (GetTime(&certTime->tm_min , date, idx) != 0) return 0;
  70:	4629      	mov	r1, r5
  72:	1d20      	adds	r0, r4, #4
  74:	f7ff fffe 	bl	0 <ExtractDate>
  78:	b968      	cbnz	r0, 96 <ExtractDate+0x96>
    if (GetTime(&certTime->tm_sec , date, idx) != 0) return 0;
  7a:	4629      	mov	r1, r5
  7c:	4620      	mov	r0, r4
  7e:	f7ff fffe 	bl	0 <ExtractDate>
  82:	fab0 f080 	clz	r0, r0
  86:	0940      	lsrs	r0, r0, #5
  88:	e006      	b.n	98 <ExtractDate+0x98>
        if (GetTime(&certTime->tm_year, date, idx) != 0) return 0;
  8a:	4632      	mov	r2, r6
  8c:	4629      	mov	r1, r5
  8e:	4640      	mov	r0, r8
  90:	f7ff fffe 	bl	0 <ExtractDate>
  94:	b110      	cbz	r0, 9c <ExtractDate+0x9c>
  96:	2000      	movs	r0, #0
}
  98:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        certTime->tm_year *= 100;
  9c:	6963      	ldr	r3, [r4, #20]
  9e:	2264      	movs	r2, #100	; 0x64
  a0:	4353      	muls	r3, r2
  a2:	e7c5      	b.n	30 <ExtractDate+0x30>

Disassembly of section .text.DateGreaterThan:

00000000 <DateGreaterThan>:
    if (a->tm_year > b->tm_year)
   0:	6942      	ldr	r2, [r0, #20]
   2:	694b      	ldr	r3, [r1, #20]
   4:	429a      	cmp	r2, r3
{
   6:	b530      	push	{r4, r5, lr}
    if (a->tm_year > b->tm_year)
   8:	dc29      	bgt.n	5e <DateGreaterThan+0x5e>
    if (a->tm_year == b->tm_year && a->tm_mon > b->tm_mon)
   a:	d12a      	bne.n	62 <DateGreaterThan+0x62>
   c:	6902      	ldr	r2, [r0, #16]
   e:	690b      	ldr	r3, [r1, #16]
  10:	429a      	cmp	r2, r3
  12:	dc24      	bgt.n	5e <DateGreaterThan+0x5e>
    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&
  14:	d125      	bne.n	62 <DateGreaterThan+0x62>
  16:	68c2      	ldr	r2, [r0, #12]
  18:	68cb      	ldr	r3, [r1, #12]
  1a:	429a      	cmp	r2, r3
  1c:	dc1f      	bgt.n	5e <DateGreaterThan+0x5e>
    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&
  1e:	d103      	bne.n	28 <DateGreaterThan+0x28>
        a->tm_mday == b->tm_mday && a->tm_hour > b->tm_hour)
  20:	6885      	ldr	r5, [r0, #8]
  22:	688c      	ldr	r4, [r1, #8]
  24:	42a5      	cmp	r5, r4
  26:	dc1a      	bgt.n	5e <DateGreaterThan+0x5e>
    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&
  28:	429a      	cmp	r2, r3
  2a:	d11a      	bne.n	62 <DateGreaterThan+0x62>
        a->tm_mday == b->tm_mday && a->tm_hour == b->tm_hour &&
  2c:	6885      	ldr	r5, [r0, #8]
  2e:	688c      	ldr	r4, [r1, #8]
  30:	42a5      	cmp	r5, r4
  32:	d103      	bne.n	3c <DateGreaterThan+0x3c>
  34:	6845      	ldr	r5, [r0, #4]
  36:	684c      	ldr	r4, [r1, #4]
  38:	42a5      	cmp	r5, r4
  3a:	dc10      	bgt.n	5e <DateGreaterThan+0x5e>
    if (a->tm_year == b->tm_year && a->tm_mon == b->tm_mon &&
  3c:	429a      	cmp	r2, r3
  3e:	d110      	bne.n	62 <DateGreaterThan+0x62>
        a->tm_mday == b->tm_mday && a->tm_hour == b->tm_hour &&
  40:	6882      	ldr	r2, [r0, #8]
  42:	688b      	ldr	r3, [r1, #8]
  44:	429a      	cmp	r2, r3
  46:	d10c      	bne.n	62 <DateGreaterThan+0x62>
  48:	6842      	ldr	r2, [r0, #4]
  4a:	684b      	ldr	r3, [r1, #4]
  4c:	429a      	cmp	r2, r3
  4e:	d108      	bne.n	62 <DateGreaterThan+0x62>
        a->tm_min  == b->tm_min  && a->tm_sec > b->tm_sec)
  50:	6800      	ldr	r0, [r0, #0]
  52:	680b      	ldr	r3, [r1, #0]
  54:	4298      	cmp	r0, r3
  56:	bfd4      	ite	le
  58:	2000      	movle	r0, #0
  5a:	2001      	movgt	r0, #1
}
  5c:	bd30      	pop	{r4, r5, pc}
        return 1;
  5e:	2001      	movs	r0, #1
  60:	e7fc      	b.n	5c <DateGreaterThan+0x5c>
    return 0; /* false */
  62:	2000      	movs	r0, #0
  64:	e7fa      	b.n	5c <DateGreaterThan+0x5c>

Disassembly of section .text.wc_SetTimeCb:

00000000 <wc_SetTimeCb>:
    timeFunc = f;
   0:	4b01      	ldr	r3, [pc, #4]	; (8 <wc_SetTimeCb+0x8>)
   2:	6018      	str	r0, [r3, #0]
}
   4:	2000      	movs	r0, #0
   6:	4770      	bx	lr
   8:	00000000 	.word	0x00000000

Disassembly of section .text.wc_Time:

00000000 <wc_Time>:
    if (timeFunc != NULL) {
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <wc_Time+0x18>)
{
   2:	b510      	push	{r4, lr}
    if (timeFunc != NULL) {
   4:	681c      	ldr	r4, [r3, #0]
   6:	b11c      	cbz	r4, 10 <wc_Time+0x10>
        return timeFunc(t);
   8:	4623      	mov	r3, r4
}
   a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return timeFunc(t);
   e:	4718      	bx	r3
    return XTIME(t);
  10:	f7ff fffe 	bl	0 <my_time>
}
  14:	4621      	mov	r1, r4
  16:	bd10      	pop	{r4, pc}
  18:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ValidateDate:

00000000 <wc_ValidateDate>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    int    i = 0;
   2:	2400      	movs	r4, #0
{
   4:	b091      	sub	sp, #68	; 0x44
   6:	4605      	mov	r5, r0
    ltime = wc_Time(0);
   8:	4620      	mov	r0, r4
{
   a:	460f      	mov	r7, r1
   c:	4616      	mov	r6, r2
    int    diffHH = 0, diffMM = 0;
   e:	e9cd 4401 	strd	r4, r4, [sp, #4]
  12:	9403      	str	r4, [sp, #12]
    ltime = wc_Time(0);
  14:	f7ff fffe 	bl	0 <wc_ValidateDate>
    if (!ExtractDate(date, format, &certTime, &i)) {
  18:	ab01      	add	r3, sp, #4
    ltime = wc_Time(0);
  1a:	e9cd 0104 	strd	r0, r1, [sp, #16]
    if (!ExtractDate(date, format, &certTime, &i)) {
  1e:	aa07      	add	r2, sp, #28
  20:	4639      	mov	r1, r7
  22:	4628      	mov	r0, r5
  24:	f7ff fffe 	bl	0 <wc_ValidateDate>
  28:	b910      	cbnz	r0, 30 <wc_ValidateDate+0x30>
        return 0;
  2a:	2000      	movs	r0, #0
}
  2c:	b011      	add	sp, #68	; 0x44
  2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if ((date[i] == '+') || (date[i] == '-')) {
  30:	9a01      	ldr	r2, [sp, #4]
  32:	5cab      	ldrb	r3, [r5, r2]
  34:	2b2b      	cmp	r3, #43	; 0x2b
  36:	d001      	beq.n	3c <wc_ValidateDate+0x3c>
  38:	2b2d      	cmp	r3, #45	; 0x2d
  3a:	d12f      	bne.n	9c <wc_ValidateDate+0x9c>
        diffSign = date[i++] == '+' ? 1 : -1 ;
  3c:	3201      	adds	r2, #1
  3e:	2b2b      	cmp	r3, #43	; 0x2b
  40:	9201      	str	r2, [sp, #4]
        if (GetTime(&diffHH, date, &i) != 0)
  42:	4629      	mov	r1, r5
  44:	aa01      	add	r2, sp, #4
  46:	a802      	add	r0, sp, #8
        diffSign = date[i++] == '+' ? 1 : -1 ;
  48:	bf0c      	ite	eq
  4a:	2701      	moveq	r7, #1
  4c:	f04f 37ff 	movne.w	r7, #4294967295	; 0xffffffff
        if (GetTime(&diffHH, date, &i) != 0)
  50:	f7ff fffe 	bl	0 <wc_ValidateDate>
  54:	2800      	cmp	r0, #0
  56:	d1e8      	bne.n	2a <wc_ValidateDate+0x2a>
        if (GetTime(&diffMM, date, &i) != 0)
  58:	4629      	mov	r1, r5
  5a:	a803      	add	r0, sp, #12
  5c:	f7ff fffe 	bl	0 <wc_ValidateDate>
  60:	2800      	cmp	r0, #0
  62:	d1e2      	bne.n	2a <wc_ValidateDate+0x2a>
        timeDiff = diffSign * (diffHH*60 + diffMM) * 60 ;
  64:	e9dd 4302 	ldrd	r4, r3, [sp, #8]
  68:	223c      	movs	r2, #60	; 0x3c
  6a:	fb02 3404 	mla	r4, r2, r4, r3
  6e:	437c      	muls	r4, r7
  70:	4354      	muls	r4, r2
    ltime -= (time_t)timeDiff;
  72:	9b04      	ldr	r3, [sp, #16]
  74:	9a05      	ldr	r2, [sp, #20]
  76:	1b1b      	subs	r3, r3, r4
  78:	eb62 74e4 	sbc.w	r4, r2, r4, asr #31
    localTime = XGMTIME(&ltime, tmpTime);
  7c:	a804      	add	r0, sp, #16
    ltime -= (time_t)timeDiff;
  7e:	e9cd 3404 	strd	r3, r4, [sp, #16]
    localTime = XGMTIME(&ltime, tmpTime);
  82:	f7ff fffe 	bl	0 <gmtime>
  86:	4601      	mov	r1, r0
    if (localTime == NULL) {
  88:	2800      	cmp	r0, #0
  8a:	d0ce      	beq.n	2a <wc_ValidateDate+0x2a>
    if (dateType == BEFORE) {
  8c:	b94e      	cbnz	r6, a2 <wc_ValidateDate+0xa2>
    return DateGreaterThan(b,a);
  8e:	a807      	add	r0, sp, #28
        if (DateGreaterThan(localTime, &certTime)) {
  90:	f7ff fffe 	bl	0 <wc_ValidateDate>
  94:	fab0 f080 	clz	r0, r0
  98:	0940      	lsrs	r0, r0, #5
  9a:	e7c7      	b.n	2c <wc_ValidateDate+0x2c>
    } else if (date[i] != 'Z') {
  9c:	2b5a      	cmp	r3, #90	; 0x5a
  9e:	d1c4      	bne.n	2a <wc_ValidateDate+0x2a>
  a0:	e7e7      	b.n	72 <wc_ValidateDate+0x72>
        if (DateGreaterThan(localTime, &certTime)) {
  a2:	a907      	add	r1, sp, #28
  a4:	e7f4      	b.n	90 <wc_ValidateDate+0x90>

Disassembly of section .text.GetDate:

00000000 <GetDate>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	4604      	mov	r4, r0
        cert->beforeDate = &cert->source[cert->srcIdx];
   4:	e9d0 079d 	ldrd	r0, r7, [r0, #628]	; 0x274
{
   8:	b08f      	sub	sp, #60	; 0x3c
   a:	4616      	mov	r6, r2
    const byte *datePtr = NULL;
   c:	2200      	movs	r2, #0
   e:	9205      	str	r2, [sp, #20]
    if (dateType == BEFORE)
  10:	460d      	mov	r5, r1
        cert->beforeDate = &cert->source[cert->srcIdx];
  12:	19c2      	adds	r2, r0, r7
    if (dateType == BEFORE)
  14:	bb09      	cbnz	r1, 5a <GetDate+0x5a>
        cert->beforeDate = &cert->source[cert->srcIdx];
  16:	f8c4 2300 	str.w	r2, [r4, #768]	; 0x300
    ret = GetDateInfo(cert->source, &cert->srcIdx, &datePtr, &format,
  1a:	9301      	str	r3, [sp, #4]
  1c:	ab04      	add	r3, sp, #16
  1e:	9300      	str	r3, [sp, #0]
  20:	aa05      	add	r2, sp, #20
  22:	f10d 030f 	add.w	r3, sp, #15
  26:	f504 711e 	add.w	r1, r4, #632	; 0x278
  2a:	f7ff fffe 	bl	0 <GetDate>
    if (ret < 0)
  2e:	2800      	cmp	r0, #0
  30:	db11      	blt.n	56 <GetDate+0x56>
    XMEMSET(date, 0, MAX_DATE_SIZE);
  32:	2220      	movs	r2, #32
  34:	2100      	movs	r1, #0
  36:	a806      	add	r0, sp, #24
  38:	f7ff fffe 	bl	0 <memset>
    XMEMCPY(date, datePtr, (size_t)length);
  3c:	e9dd 2104 	ldrd	r2, r1, [sp, #16]
  40:	a806      	add	r0, sp, #24
  42:	f7ff fffe 	bl	0 <memcpy>
    if (dateType == BEFORE)
  46:	f8d4 3278 	ldr.w	r3, [r4, #632]	; 0x278
        cert->beforeDateLen = (int)(cert->srcIdx - startIdx);
  4a:	1bdb      	subs	r3, r3, r7
    if (dateType == BEFORE)
  4c:	b945      	cbnz	r5, 60 <GetDate+0x60>
        cert->beforeDateLen = (int)(cert->srcIdx - startIdx);
  4e:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    if (verify != NO_VERIFY && verify != VERIFY_SKIP_DATE &&
  52:	b946      	cbnz	r6, 66 <GetDate+0x66>
    return 0;
  54:	2000      	movs	r0, #0
}
  56:	b00f      	add	sp, #60	; 0x3c
  58:	bdf0      	pop	{r4, r5, r6, r7, pc}
        cert->afterDate = &cert->source[cert->srcIdx];
  5a:	f8c4 2308 	str.w	r2, [r4, #776]	; 0x308
  5e:	e7dc      	b.n	1a <GetDate+0x1a>
        cert->afterDateLen  = (int)(cert->srcIdx - startIdx);
  60:	f8c4 330c 	str.w	r3, [r4, #780]	; 0x30c
  64:	e7f5      	b.n	52 <GetDate+0x52>
    if (verify != NO_VERIFY && verify != VERIFY_SKIP_DATE &&
  66:	2e05      	cmp	r6, #5
  68:	d0f4      	beq.n	54 <GetDate+0x54>
            !XVALIDATE_DATE(date, format, dateType)) {
  6a:	f89d 100f 	ldrb.w	r1, [sp, #15]
  6e:	462a      	mov	r2, r5
  70:	a806      	add	r0, sp, #24
  72:	f7ff fffe 	bl	0 <GetDate>
    if (verify != NO_VERIFY && verify != VERIFY_SKIP_DATE &&
  76:	2800      	cmp	r0, #0
  78:	d1ec      	bne.n	54 <GetDate+0x54>
        if (dateType == BEFORE) {
  7a:	f06f 0095 	mvn.w	r0, #149	; 0x95
  7e:	1b40      	subs	r0, r0, r5
  80:	e7e9      	b.n	56 <GetDate+0x56>

Disassembly of section .text.wc_GetTime:

00000000 <wc_GetTime>:
{
   0:	b510      	push	{r4, lr}
    if (timePtr == NULL) {
   2:	4604      	mov	r4, r0
   4:	b140      	cbz	r0, 18 <wc_GetTime+0x18>
    if ((word32)sizeof(time_t) > timeSize) {
   6:	2907      	cmp	r1, #7
   8:	d909      	bls.n	1e <wc_GetTime+0x1e>
    *ltime = wc_Time(0);
   a:	2000      	movs	r0, #0
   c:	f7ff fffe 	bl	0 <wc_GetTime>
  10:	e9c4 0100 	strd	r0, r1, [r4]
    return 0;
  14:	2000      	movs	r0, #0
}
  16:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  18:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1c:	e7fb      	b.n	16 <wc_GetTime+0x16>
        return BUFFER_E;
  1e:	f06f 0083 	mvn.w	r0, #131	; 0x83
  22:	e7f8      	b.n	16 <wc_GetTime+0x16>

Disassembly of section .text.wc_GetDateInfo:

00000000 <wc_GetDateInfo>:
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    ret = GetDateInfo(certDate, &idx, date, format, length, (word32)certDateSz);
   2:	9101      	str	r1, [sp, #4]
   4:	9906      	ldr	r1, [sp, #24]
   6:	9100      	str	r1, [sp, #0]
    word32 idx = 0;
   8:	2400      	movs	r4, #0
    ret = GetDateInfo(certDate, &idx, date, format, length, (word32)certDateSz);
   a:	a903      	add	r1, sp, #12
    word32 idx = 0;
   c:	9403      	str	r4, [sp, #12]
    ret = GetDateInfo(certDate, &idx, date, format, length, (word32)certDateSz);
   e:	f7ff fffe 	bl	0 <wc_GetDateInfo>
}
  12:	b004      	add	sp, #16
  14:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_GetDateAsCalendarTime:

00000000 <wc_GetDateAsCalendarTime>:
{
   0:	b507      	push	{r0, r1, r2, lr}
   2:	4611      	mov	r1, r2
   4:	461a      	mov	r2, r3
    int idx = 0;
   6:	2300      	movs	r3, #0
   8:	9301      	str	r3, [sp, #4]
    if (!ExtractDate(date, format, timearg, &idx))
   a:	ab01      	add	r3, sp, #4
   c:	f7ff fffe 	bl	0 <wc_GetDateAsCalendarTime>
        return ASN_TIME_E;
  10:	2800      	cmp	r0, #0
}
  12:	bf0c      	ite	eq
  14:	f06f 0098 	mvneq.w	r0, #152	; 0x98
  18:	2000      	movne	r0, #0
  1a:	b003      	add	sp, #12
  1c:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.SetLength:

00000000 <SetLength>:
    if (length < ASN_LONG_LENGTH) {
   0:	287f      	cmp	r0, #127	; 0x7f
{
   2:	b570      	push	{r4, r5, r6, lr}
    if (length < ASN_LONG_LENGTH) {
   4:	d91c      	bls.n	40 <SetLength+0x40>
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
   6:	0c03      	lsrs	r3, r0, #16
   8:	d11e      	bne.n	48 <SetLength+0x48>
   a:	0a03      	lsrs	r3, r0, #8
   c:	bf0c      	ite	eq
   e:	2301      	moveq	r3, #1
  10:	2302      	movne	r3, #2
        byte j = (byte)BytePrecision(length);
  12:	b2da      	uxtb	r2, r3
        if (output) {
  14:	b111      	cbz	r1, 1c <SetLength+0x1c>
            output[i] = (byte)(j | ASN_LONG_LENGTH);
  16:	f062 047f 	orn	r4, r2, #127	; 0x7f
  1a:	700c      	strb	r4, [r1, #0]
  1c:	3b01      	subs	r3, #1
  1e:	00db      	lsls	r3, r3, #3
  20:	1c4d      	adds	r5, r1, #1
        if (value >> ((i - 1) * WOLFSSL_BIT_SIZE))
  22:	4614      	mov	r4, r2
            if (output) {
  24:	b111      	cbz	r1, 2c <SetLength+0x2c>
                output[i] = (byte)(length >> ((j - 1) * WOLFSSL_BIT_SIZE));
  26:	fa20 f603 	lsr.w	r6, r0, r3
  2a:	702e      	strb	r6, [r5, #0]
        for (; j > 0; --j) {
  2c:	3c01      	subs	r4, #1
  2e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
  32:	f1a3 0308 	sub.w	r3, r3, #8
  36:	f105 0501 	add.w	r5, r5, #1
  3a:	d1f3      	bne.n	24 <SetLength+0x24>
            i++;
  3c:	1c50      	adds	r0, r2, #1
}
  3e:	bd70      	pop	{r4, r5, r6, pc}
        if (output) {
  40:	b101      	cbz	r1, 44 <SetLength+0x44>
            output[i] = (byte)length;
  42:	7008      	strb	r0, [r1, #0]
        i++;
  44:	2001      	movs	r0, #1
    return i;
  46:	e7fa      	b.n	3e <SetLength+0x3e>
    for (i = (word32)sizeof(value) - 1; i; --i)
  48:	2303      	movs	r3, #3
  4a:	e7e2      	b.n	12 <SetLength+0x12>

Disassembly of section .text.SetASNInt:

00000000 <SetASNInt>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (output) {
   2:	4614      	mov	r4, r2
   4:	b10a      	cbz	r2, a <SetASNInt+0xa>
        output[idx] = ASN_INTEGER;
   6:	2302      	movs	r3, #2
   8:	7013      	strb	r3, [r2, #0]
    if (firstByte & 0x80) {
   a:	b24d      	sxtb	r5, r1
   c:	2d00      	cmp	r5, #0
        len++;
   e:	bfb8      	it	lt
  10:	3001      	addlt	r0, #1
    idx += (int)SetLength((word32)len, output ? output + idx : NULL);
  12:	b164      	cbz	r4, 2e <SetASNInt+0x2e>
  14:	1c61      	adds	r1, r4, #1
  16:	f7ff fffe 	bl	0 <SetASNInt>
    if (firstByte & 0x80) {
  1a:	2d00      	cmp	r5, #0
    idx += (int)SetLength((word32)len, output ? output + idx : NULL);
  1c:	4603      	mov	r3, r0
  1e:	f100 0001 	add.w	r0, r0, #1
    if (firstByte & 0x80) {
  22:	da03      	bge.n	2c <SetASNInt+0x2c>
        if (output) {
  24:	b10c      	cbz	r4, 2a <SetASNInt+0x2a>
            output[idx] = 0x00;
  26:	2200      	movs	r2, #0
  28:	5422      	strb	r2, [r4, r0]
        idx++;
  2a:	1c98      	adds	r0, r3, #2
}
  2c:	bd38      	pop	{r3, r4, r5, pc}
    idx += (int)SetLength((word32)len, output ? output + idx : NULL);
  2e:	4621      	mov	r1, r4
  30:	e7f1      	b.n	16 <SetASNInt+0x16>

Disassembly of section .text.SetASNIntMP:

00000000 <SetASNIntMP>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460d      	mov	r5, r1
   6:	4680      	mov	r8, r0
   8:	4617      	mov	r7, r2
    leadingBit = mp_leading_bit(n);
   a:	f7ff fffe 	bl	0 <mp_leading_bit>
   e:	4606      	mov	r6, r0
    length = mp_unsigned_bin_size(n);
  10:	4640      	mov	r0, r8
  12:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
    if (maxSz >= 0 && (1 + length + (leadingBit ? 1 : 0)) > maxSz)
  16:	2d00      	cmp	r5, #0
    length = mp_unsigned_bin_size(n);
  18:	4604      	mov	r4, r0
    if (maxSz >= 0 && (1 + length + (leadingBit ? 1 : 0)) > maxSz)
  1a:	db09      	blt.n	30 <SetASNIntMP+0x30>
  1c:	1c43      	adds	r3, r0, #1
  1e:	2e00      	cmp	r6, #0
  20:	bf18      	it	ne
  22:	3301      	addne	r3, #1
  24:	42ab      	cmp	r3, r5
  26:	dd03      	ble.n	30 <SetASNIntMP+0x30>
        return BUFFER_E;
  28:	f06f 0083 	mvn.w	r0, #131	; 0x83
}
  2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    idx = SetASNInt(length, (byte)(leadingBit ? 0x80U : 0x00U), output);
  30:	2e00      	cmp	r6, #0
  32:	bf14      	ite	ne
  34:	2180      	movne	r1, #128	; 0x80
  36:	2100      	moveq	r1, #0
  38:	463a      	mov	r2, r7
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <SetASNIntMP>
    if (maxSz >= 0 && (idx + length) > maxSz)
  40:	2d00      	cmp	r5, #0
    idx = SetASNInt(length, (byte)(leadingBit ? 0x80U : 0x00U), output);
  42:	4606      	mov	r6, r0
    if (maxSz >= 0 && (idx + length) > maxSz)
  44:	db02      	blt.n	4c <SetASNIntMP+0x4c>
  46:	1823      	adds	r3, r4, r0
  48:	42ab      	cmp	r3, r5
  4a:	dced      	bgt.n	28 <SetASNIntMP+0x28>
    if (output) {
  4c:	b90f      	cbnz	r7, 52 <SetASNIntMP+0x52>
    idx += length;
  4e:	19a0      	adds	r0, r4, r6
    return idx;
  50:	e7ec      	b.n	2c <SetASNIntMP+0x2c>
        int err = mp_to_unsigned_bin(n, output + idx);
  52:	19b9      	adds	r1, r7, r6
  54:	4640      	mov	r0, r8
  56:	f7ff fffe 	bl	0 <mp_to_unsigned_bin>
        if (err != MP_OKAY)
  5a:	2800      	cmp	r0, #0
  5c:	d0f7      	beq.n	4e <SetASNIntMP+0x4e>
            return MP_TO_E;
  5e:	f06f 0070 	mvn.w	r0, #112	; 0x70
  62:	e7e3      	b.n	2c <SetASNIntMP+0x2c>

Disassembly of section .text.SetBitString:

00000000 <SetBitString>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    if (output) {
   4:	4614      	mov	r4, r2
   6:	b10a      	cbz	r2, c <SetBitString+0xc>
        output[idx] = ASN_BIT_STRING;
   8:	2303      	movs	r3, #3
   a:	7013      	strb	r3, [r2, #0]
    idx += SetLength(len + 1, output ? output + idx : NULL);
   c:	3001      	adds	r0, #1
   e:	b13c      	cbz	r4, 20 <SetBitString+0x20>
  10:	1c61      	adds	r1, r4, #1
  12:	f7ff fffe 	bl	0 <SetBitString>
    if (output) {
  16:	b10c      	cbz	r4, 1c <SetBitString+0x1c>
        output[idx] = unusedBits;
  18:	4404      	add	r4, r0
  1a:	7065      	strb	r5, [r4, #1]
}
  1c:	3002      	adds	r0, #2
  1e:	bd38      	pop	{r3, r4, r5, pc}
    idx += SetLength(len + 1, output ? output + idx : NULL);
  20:	4621      	mov	r1, r4
  22:	e7f6      	b.n	12 <SetBitString+0x12>

Disassembly of section .text.SetObjectId:

00000000 <SetObjectId>:
{
   0:	b508      	push	{r3, lr}
    if (output) {
   2:	b111      	cbz	r1, a <SetObjectId+0xa>
        output[idx] = ASN_OBJECT_ID;
   4:	2306      	movs	r3, #6
   6:	f801 3b01 	strb.w	r3, [r1], #1
    idx += (int)SetLength((word32)len, output ? output + idx : NULL);
   a:	f7ff fffe 	bl	0 <SetObjectId>
}
   e:	3001      	adds	r0, #1
  10:	bd08      	pop	{r3, pc}

Disassembly of section .text.SetCurve:

00000000 <SetCurve>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460f      	mov	r7, r1
   6:	4690      	mov	r8, r2
    if (key == NULL || key->dp == NULL) {
   8:	4606      	mov	r6, r0
   a:	b198      	cbz	r0, 34 <SetCurve+0x34>
   c:	6903      	ldr	r3, [r0, #16]
   e:	b18b      	cbz	r3, 34 <SetCurve+0x34>
    oidSz = key->dp->oidSz;
  10:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    idx = SetObjectId((int)oidSz, output);
  12:	4620      	mov	r0, r4
  14:	f7ff fffe 	bl	0 <SetCurve>
  18:	4605      	mov	r5, r0
    if (output == NULL) {
  1a:	b917      	cbnz	r7, 22 <SetCurve+0x22>
    idx += (int)oidSz;
  1c:	1960      	adds	r0, r4, r5
}
  1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (oidSz > outSz)
  22:	4544      	cmp	r4, r8
  24:	d809      	bhi.n	3a <SetCurve+0x3a>
    XMEMCPY(output+idx, key->dp->oid, oidSz);
  26:	6933      	ldr	r3, [r6, #16]
  28:	4622      	mov	r2, r4
  2a:	6a59      	ldr	r1, [r3, #36]	; 0x24
  2c:	1838      	adds	r0, r7, r0
  2e:	f7ff fffe 	bl	0 <memcpy>
  32:	e7f3      	b.n	1c <SetCurve+0x1c>
        return BAD_FUNC_ARG;
  34:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  38:	e7f1      	b.n	1e <SetCurve+0x1e>
        return BUFFER_E;
  3a:	f06f 0083 	mvn.w	r0, #131	; 0x83
  3e:	e7ee      	b.n	1e <SetCurve+0x1e>

Disassembly of section .text.SetHeader:

00000000 <SetHeader>:
{
   0:	b508      	push	{r3, lr}
   2:	4603      	mov	r3, r0
   4:	4608      	mov	r0, r1
    if (output) {
   6:	4611      	mov	r1, r2
   8:	b10a      	cbz	r2, e <SetHeader+0xe>
        output[0] = tag;
   a:	f801 3b01 	strb.w	r3, [r1], #1
    return SetLength(len, output ? output + ASN_TAG_SZ : NULL) + ASN_TAG_SZ;
   e:	f7ff fffe 	bl	0 <SetHeader>
}
  12:	3001      	adds	r0, #1
  14:	bd08      	pop	{r3, pc}

Disassembly of section .text.SetSequence:

00000000 <SetSequence>:
{
   0:	460a      	mov	r2, r1
    return SetHeader(ASN_SEQUENCE | ASN_CONSTRUCTED, len, output);
   2:	4601      	mov	r1, r0
   4:	2030      	movs	r0, #48	; 0x30
   6:	f7ff bffe 	b.w	0 <SetSequence>

Disassembly of section .text.SetOctetString:

00000000 <SetOctetString>:
{
   0:	460a      	mov	r2, r1
    return SetHeader(ASN_OCTET_STRING, len, output);
   2:	4601      	mov	r1, r0
   4:	2004      	movs	r0, #4
   6:	f7ff bffe 	b.w	0 <SetOctetString>

Disassembly of section .text.SetSet:

00000000 <SetSet>:
{
   0:	460a      	mov	r2, r1
    return SetHeader(ASN_SET | ASN_CONSTRUCTED, len, output);
   2:	4601      	mov	r1, r0
   4:	2031      	movs	r0, #49	; 0x31
   6:	f7ff bffe 	b.w	0 <SetSet>

Disassembly of section .text.SetImplicit:

00000000 <SetImplicit>:
                 | ASN_CONTEXT_SPECIFIC | number);
   0:	3810      	subs	r0, #16
   2:	2801      	cmp	r0, #1
   4:	bf94      	ite	ls
   6:	f06f 005f 	mvnls.w	r0, #95	; 0x5f
   a:	f06f 007f 	mvnhi.w	r0, #127	; 0x7f
{
   e:	b410      	push	{r4}
                 | ASN_CONTEXT_SPECIFIC | number);
  10:	4308      	orrs	r0, r1
{
  12:	4614      	mov	r4, r2
    return SetHeader(tag, len, output);
  14:	4621      	mov	r1, r4
  16:	461a      	mov	r2, r3
}
  18:	bc10      	pop	{r4}
    return SetHeader(tag, len, output);
  1a:	b2c0      	uxtb	r0, r0
  1c:	f7ff bffe 	b.w	0 <SetImplicit>

Disassembly of section .text.SetExplicit:

00000000 <SetExplicit>:
    return SetHeader((byte)(ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | number),
   0:	f040 00a0 	orr.w	r0, r0, #160	; 0xa0
   4:	f7ff bffe 	b.w	0 <SetExplicit>

Disassembly of section .text.SetAlgoID:

00000000 <SetAlgoID>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b087      	sub	sp, #28
    word32 tagSz, idSz, seqSz, algoSz = 0;
   6:	2400      	movs	r4, #0
{
   8:	460e      	mov	r6, r1
   a:	4680      	mov	r8, r0
   c:	4699      	mov	r9, r3
    word32 tagSz, idSz, seqSz, algoSz = 0;
   e:	9401      	str	r4, [sp, #4]
             (type == oidKeyType && algoOID == RSAk)) ? 2U : 0U;
  10:	4611      	mov	r1, r2
  12:	2a00      	cmp	r2, #0
  14:	d048      	beq.n	a8 <SetAlgoID+0xa8>
    tagSz = (type == oidHashType ||
  16:	2a01      	cmp	r2, #1
  18:	d13d      	bne.n	96 <SetAlgoID+0x96>
    if (algoOID == CTC_SHAwECDSA || algoOID == CTC_SHA256wECDSA ||
  1a:	f5b0 7f02 	cmp.w	r0, #520	; 0x208
  1e:	d009      	beq.n	34 <SetAlgoID+0x34>
  20:	f5a0 7303 	sub.w	r3, r0, #524	; 0x20c
  24:	2b02      	cmp	r3, #2
  26:	d905      	bls.n	34 <SetAlgoID+0x34>
              || (algoOID == ED25519k)
  28:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  2c:	d002      	beq.n	34 <SetAlgoID+0x34>
             (type == oidKeyType && algoOID == RSAk)) ? 2U : 0U;
  2e:	28fe      	cmp	r0, #254	; 0xfe
  30:	bf18      	it	ne
  32:	2402      	movne	r4, #2
    algoName = OidFromId((word32)algoOID, (word32)type, &algoSz);
  34:	aa01      	add	r2, sp, #4
  36:	4640      	mov	r0, r8
  38:	f7ff fffe 	bl	0 <SetAlgoID>
    if (algoName == NULL) {
  3c:	4605      	mov	r5, r0
  3e:	b338      	cbz	r0, 90 <SetAlgoID+0x90>
    idSz  = (word32)SetObjectId((int)algoSz, ID_Length);
  40:	a902      	add	r1, sp, #8
  42:	9801      	ldr	r0, [sp, #4]
  44:	f7ff fffe 	bl	0 <SetAlgoID>
  48:	4607      	mov	r7, r0
    seqSz = SetSequence(idSz + algoSz + tagSz + (word32)curveSz, seqArray);
  4a:	9801      	ldr	r0, [sp, #4]
  4c:	4448      	add	r0, r9
  4e:	4420      	add	r0, r4
  50:	a904      	add	r1, sp, #16
  52:	4438      	add	r0, r7
  54:	f7ff fffe 	bl	0 <SetAlgoID>
    if (algoOID == DSAk && output) {
  58:	f240 2303 	movw	r3, #515	; 0x203
  5c:	4598      	cmp	r8, r3
    seqSz = SetSequence(idSz + algoSz + tagSz + (word32)curveSz, seqArray);
  5e:	4681      	mov	r9, r0
    if (algoOID == DSAk && output) {
  60:	d124      	bne.n	ac <SetAlgoID+0xac>
  62:	b196      	cbz	r6, 8a <SetAlgoID+0x8a>
        XMEMCPY(output, ID_Length, idSz);
  64:	463a      	mov	r2, r7
  66:	a902      	add	r1, sp, #8
  68:	4630      	mov	r0, r6
  6a:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(output + idSz, algoName, algoSz);
  6e:	9a01      	ldr	r2, [sp, #4]
  70:	4629      	mov	r1, r5
  72:	19f0      	adds	r0, r6, r7
  74:	f7ff fffe 	bl	0 <memcpy>
        if (tagSz == 2)
  78:	b13c      	cbz	r4, 8a <SetAlgoID+0x8a>
            SetASNNull(&output[seqSz + idSz + algoSz]);
  7a:	9901      	ldr	r1, [sp, #4]
  7c:	4449      	add	r1, r9
  7e:	4439      	add	r1, r7
    output[0] = ASN_TAG_NULL;
  80:	2205      	movs	r2, #5
            SetASNNull(&output[seqSz + idSz + algoSz]);
  82:	1873      	adds	r3, r6, r1
    output[0] = ASN_TAG_NULL;
  84:	5472      	strb	r2, [r6, r1]
    output[1] = 0;
  86:	2200      	movs	r2, #0
  88:	705a      	strb	r2, [r3, #1]
        length = idSz + algoSz + tagSz;
  8a:	9901      	ldr	r1, [sp, #4]
  8c:	4421      	add	r1, r4
        length = seqSz + idSz + algoSz + tagSz;
  8e:	19c8      	adds	r0, r1, r7
}
  90:	b007      	add	sp, #28
  92:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
             (type == oidSigType && !IsSigAlgoECC((word32)algoOID)) ||
  96:	2a02      	cmp	r2, #2
  98:	d1cc      	bne.n	34 <SetAlgoID+0x34>
             (type == oidKeyType && algoOID == RSAk)) ? 2U : 0U;
  9a:	f240 2485 	movw	r4, #645	; 0x285
  9e:	42a0      	cmp	r0, r4
  a0:	bf0c      	ite	eq
  a2:	2402      	moveq	r4, #2
  a4:	2400      	movne	r4, #0
  a6:	e7c5      	b.n	34 <SetAlgoID+0x34>
  a8:	2402      	movs	r4, #2
  aa:	e7c3      	b.n	34 <SetAlgoID+0x34>
    else if (output) {
  ac:	b1e6      	cbz	r6, e8 <SetAlgoID+0xe8>
        XMEMCPY(output, seqArray, seqSz);
  ae:	464a      	mov	r2, r9
  b0:	a904      	add	r1, sp, #16
  b2:	4630      	mov	r0, r6
  b4:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(output + seqSz + idSz, algoName, algoSz);
  b8:	eb07 0809 	add.w	r8, r7, r9
        XMEMCPY(output + seqSz, ID_Length, idSz);
  bc:	463a      	mov	r2, r7
  be:	a902      	add	r1, sp, #8
  c0:	eb06 0009 	add.w	r0, r6, r9
  c4:	f7ff fffe 	bl	0 <memcpy>
        XMEMCPY(output + seqSz + idSz, algoName, algoSz);
  c8:	9a01      	ldr	r2, [sp, #4]
  ca:	4629      	mov	r1, r5
  cc:	eb06 0008 	add.w	r0, r6, r8
  d0:	f7ff fffe 	bl	0 <memcpy>
        if (tagSz == 2)
  d4:	b144      	cbz	r4, e8 <SetAlgoID+0xe8>
            SetASNNull(&output[seqSz + idSz + algoSz]);
  d6:	9b01      	ldr	r3, [sp, #4]
  d8:	4498      	add	r8, r3
    output[0] = ASN_TAG_NULL;
  da:	2205      	movs	r2, #5
            SetASNNull(&output[seqSz + idSz + algoSz]);
  dc:	eb06 0308 	add.w	r3, r6, r8
    output[0] = ASN_TAG_NULL;
  e0:	f806 2008 	strb.w	r2, [r6, r8]
    output[1] = 0;
  e4:	2200      	movs	r2, #0
  e6:	705a      	strb	r2, [r3, #1]
        length = seqSz + idSz + algoSz + tagSz;
  e8:	9901      	ldr	r1, [sp, #4]
  ea:	440c      	add	r4, r1
  ec:	eb04 0109 	add.w	r1, r4, r9
  f0:	e7cd      	b.n	8e <SetAlgoID+0x8e>

Disassembly of section .text.SetEccPublicKey:

00000000 <SetEccPublicKey>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	461c      	mov	r4, r3
   6:	b088      	sub	sp, #32
    pubSz = key->dp ? (word32)key->dp->size : MAX_ECC_BYTES;
   8:	690b      	ldr	r3, [r1, #16]
{
   a:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
   e:	4606      	mov	r6, r0
  10:	460f      	mov	r7, r1
  12:	4690      	mov	r8, r2
    pubSz = key->dp ? (word32)key->dp->size : MAX_ECC_BYTES;
  14:	b17b      	cbz	r3, 36 <SetEccPublicKey+0x36>
  16:	681b      	ldr	r3, [r3, #0]
    if (comp)
  18:	f1b9 0f00 	cmp.w	r9, #0
  1c:	d00d      	beq.n	3a <SetEccPublicKey+0x3a>
        pubSz = 1 + 2 * pubSz;
  1e:	3301      	adds	r3, #1
  20:	9300      	str	r3, [sp, #0]
    if (output != NULL && pubSz > (word32)outLen) {
  22:	2e00      	cmp	r6, #0
  24:	d05c      	beq.n	e0 <SetEccPublicKey+0xe0>
  26:	4598      	cmp	r8, r3
  28:	d209      	bcs.n	3e <SetEccPublicKey+0x3e>
        return BUFFER_E;
  2a:	f06f 0583 	mvn.w	r5, #131	; 0x83
}
  2e:	4628      	mov	r0, r5
  30:	b008      	add	sp, #32
  32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pubSz = key->dp ? (word32)key->dp->size : MAX_ECC_BYTES;
  36:	2320      	movs	r3, #32
  38:	e7ee      	b.n	18 <SetEccPublicKey+0x18>
        pubSz = 1 + 2 * pubSz;
  3a:	005b      	lsls	r3, r3, #1
  3c:	e7ef      	b.n	1e <SetEccPublicKey+0x1e>
    if (with_header) {
  3e:	2c00      	cmp	r4, #0
  40:	d042      	beq.n	c8 <SetEccPublicKey+0xc8>
        ret = SetCurve(key, NULL, 0);
  42:	2200      	movs	r2, #0
  44:	4611      	mov	r1, r2
  46:	4638      	mov	r0, r7
  48:	f7ff fffe 	bl	0 <SetEccPublicKey>
        if (ret <= 0) {
  4c:	1e05      	subs	r5, r0, #0
  4e:	ddee      	ble.n	2e <SetEccPublicKey+0x2e>
        algoSz  = SetAlgoID(ECDSAk, algo, oidKeyType, (int)curveSz);
  50:	462b      	mov	r3, r5
  52:	2202      	movs	r2, #2
  54:	a903      	add	r1, sp, #12
  56:	f240 2006 	movw	r0, #518	; 0x206
  5a:	f7ff fffe 	bl	0 <SetEccPublicKey>
        bitStringSz = SetBitString(pubSz, 0, bitString);
  5e:	aa01      	add	r2, sp, #4
        algoSz  = SetAlgoID(ECDSAk, algo, oidKeyType, (int)curveSz);
  60:	4682      	mov	sl, r0
        bitStringSz = SetBitString(pubSz, 0, bitString);
  62:	2100      	movs	r1, #0
  64:	9800      	ldr	r0, [sp, #0]
  66:	f7ff fffe 	bl	0 <SetEccPublicKey>
  6a:	4604      	mov	r4, r0
        idx = SetSequence(pubSz + curveSz + bitStringSz + algoSz, NULL);
  6c:	9800      	ldr	r0, [sp, #0]
  6e:	4428      	add	r0, r5
  70:	4450      	add	r0, sl
  72:	2100      	movs	r1, #0
  74:	4420      	add	r0, r4
  76:	f7ff fffe 	bl	0 <SetEccPublicKey>
        if (output != NULL &&
  7a:	9a00      	ldr	r2, [sp, #0]
  7c:	b12e      	cbz	r6, 8a <SetEccPublicKey+0x8a>
                curveSz + algoSz + bitStringSz + idx + pubSz > (word32)outLen) {
  7e:	18ab      	adds	r3, r5, r2
  80:	4453      	add	r3, sl
  82:	4423      	add	r3, r4
  84:	4418      	add	r0, r3
        if (output != NULL &&
  86:	4540      	cmp	r0, r8
  88:	d8cf      	bhi.n	2a <SetEccPublicKey+0x2a>
        idx = SetSequence(pubSz + curveSz + bitStringSz + algoSz,
  8a:	18a8      	adds	r0, r5, r2
  8c:	4450      	add	r0, sl
  8e:	4631      	mov	r1, r6
  90:	4420      	add	r0, r4
  92:	f7ff fffe 	bl	0 <SetEccPublicKey>
  96:	4680      	mov	r8, r0
        if (output)
  98:	b126      	cbz	r6, a4 <SetEccPublicKey+0xa4>
            XMEMCPY(output + idx, algo, algoSz);
  9a:	4652      	mov	r2, sl
  9c:	a903      	add	r1, sp, #12
  9e:	1830      	adds	r0, r6, r0
  a0:	f7ff fffe 	bl	0 <memcpy>
        idx += algoSz;
  a4:	44c2      	add	sl, r8
        if (output)
  a6:	b12e      	cbz	r6, b4 <SetEccPublicKey+0xb4>
            (void)SetCurve(key, output + idx, curveSz);
  a8:	462a      	mov	r2, r5
  aa:	eb06 010a 	add.w	r1, r6, sl
  ae:	4638      	mov	r0, r7
  b0:	f7ff fffe 	bl	0 <SetEccPublicKey>
        idx += curveSz;
  b4:	44aa      	add	sl, r5
        if (output)
  b6:	b12e      	cbz	r6, c4 <SetEccPublicKey+0xc4>
            XMEMCPY(output + idx, bitString, bitStringSz);
  b8:	4622      	mov	r2, r4
  ba:	a901      	add	r1, sp, #4
  bc:	eb06 000a 	add.w	r0, r6, sl
  c0:	f7ff fffe 	bl	0 <memcpy>
        idx += bitStringSz;
  c4:	4454      	add	r4, sl
    if (output) {
  c6:	b146      	cbz	r6, da <SetEccPublicKey+0xda>
        ret = wc_ecc_export_x963_ex(key, output + idx, &pubSz, comp);
  c8:	464b      	mov	r3, r9
  ca:	466a      	mov	r2, sp
  cc:	1931      	adds	r1, r6, r4
  ce:	4638      	mov	r0, r7
  d0:	f7ff fffe 	bl	0 <wc_ecc_export_x963_ex>
        if (ret != 0) {
  d4:	4605      	mov	r5, r0
  d6:	2800      	cmp	r0, #0
  d8:	d1a9      	bne.n	2e <SetEccPublicKey+0x2e>
    idx += pubSz;
  da:	9d00      	ldr	r5, [sp, #0]
  dc:	4425      	add	r5, r4
    return (int)idx;
  de:	e7a6      	b.n	2e <SetEccPublicKey+0x2e>
    if (with_header) {
  e0:	2c00      	cmp	r4, #0
  e2:	d0fa      	beq.n	da <SetEccPublicKey+0xda>
  e4:	e7ad      	b.n	42 <SetEccPublicKey+0x42>

Disassembly of section .text.wc_EccPublicKeyToDer:

00000000 <wc_EccPublicKeyToDer>:
{
   0:	b513      	push	{r0, r1, r4, lr}
   2:	4604      	mov	r4, r0
   4:	4608      	mov	r0, r1
    return SetEccPublicKey(output, key, (int)inLen, with_AlgCurve, 0);
   6:	2100      	movs	r1, #0
   8:	9100      	str	r1, [sp, #0]
   a:	4621      	mov	r1, r4
   c:	f7ff fffe 	bl	0 <wc_EccPublicKeyToDer>
}
  10:	b002      	add	sp, #8
  12:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_EccPublicKeyToDer_ex:

00000000 <wc_EccPublicKeyToDer_ex>:
{
   0:	b410      	push	{r4}
   2:	4604      	mov	r4, r0
   4:	4608      	mov	r0, r1
    return SetEccPublicKey(output, key, (int)inLen, with_AlgCurve, comp);
   6:	4621      	mov	r1, r4
}
   8:	bc10      	pop	{r4}
    return SetEccPublicKey(output, key, (int)inLen, with_AlgCurve, comp);
   a:	f7ff bffe 	b.w	0 <wc_EccPublicKeyToDer_ex>

Disassembly of section .text.wc_EccPublicKeyDerSize:

00000000 <wc_EccPublicKeyDerSize>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    return SetEccPublicKey(NULL, key, 0, with_AlgCurve, 0);
   2:	2200      	movs	r2, #0
{
   4:	460b      	mov	r3, r1
    return SetEccPublicKey(NULL, key, 0, with_AlgCurve, 0);
   6:	9200      	str	r2, [sp, #0]
   8:	4601      	mov	r1, r0
   a:	4610      	mov	r0, r2
   c:	f7ff fffe 	bl	0 <wc_EccPublicKeyDerSize>
}
  10:	b003      	add	sp, #12
  12:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.SetAsymKeyDerPublic:

00000000 <SetAsymKeyDerPublic>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	460d      	mov	r5, r1
   6:	e9dd 8408 	ldrd	r8, r4, [sp, #32]
   a:	4616      	mov	r6, r2
   c:	4699      	mov	r9, r3
    if (pubKey == NULL) {
   e:	4607      	mov	r7, r0
  10:	b398      	cbz	r0, 7a <SetAsymKeyDerPublic+0x7a>
    if (withHeader) {
  12:	b37c      	cbz	r4, 74 <SetAsymKeyDerPublic+0x74>
        word32 algoSz      = SetAlgoID(keyType, NULL, oidKeyType, 0);
  14:	2300      	movs	r3, #0
  16:	4619      	mov	r1, r3
  18:	2202      	movs	r2, #2
  1a:	4640      	mov	r0, r8
  1c:	f7ff fffe 	bl	0 <SetAsymKeyDerPublic>
        word32 bitStringSz = SetBitString(pubKeyLen, 0, NULL);
  20:	2200      	movs	r2, #0
  22:	4611      	mov	r1, r2
        word32 algoSz      = SetAlgoID(keyType, NULL, oidKeyType, 0);
  24:	4682      	mov	sl, r0
        word32 bitStringSz = SetBitString(pubKeyLen, 0, NULL);
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <SetAsymKeyDerPublic>
        seqDataSz = algoSz + bitStringSz + pubKeyLen;
  2c:	4482      	add	sl, r0
  2e:	44aa      	add	sl, r5
        sz = SetSequence(seqDataSz, NULL) + seqDataSz;
  30:	2100      	movs	r1, #0
  32:	4650      	mov	r0, sl
  34:	f7ff fffe 	bl	0 <SetAsymKeyDerPublic>
  38:	4450      	add	r0, sl
    if (output != NULL && sz > outLen) {
  3a:	b306      	cbz	r6, 7e <SetAsymKeyDerPublic+0x7e>
  3c:	4548      	cmp	r0, r9
  3e:	d820      	bhi.n	82 <SetAsymKeyDerPublic+0x82>
    if (ret == 0 && output != NULL && withHeader) {
  40:	b18c      	cbz	r4, 66 <SetAsymKeyDerPublic+0x66>
        idx = SetSequence(seqDataSz, output);
  42:	4631      	mov	r1, r6
  44:	4650      	mov	r0, sl
  46:	f7ff fffe 	bl	0 <SetAsymKeyDerPublic>
        idx += SetAlgoID(keyType, output + idx, oidKeyType, 0);
  4a:	2300      	movs	r3, #0
  4c:	1831      	adds	r1, r6, r0
        idx = SetSequence(seqDataSz, output);
  4e:	4604      	mov	r4, r0
        idx += SetAlgoID(keyType, output + idx, oidKeyType, 0);
  50:	2202      	movs	r2, #2
  52:	4640      	mov	r0, r8
  54:	f7ff fffe 	bl	0 <SetAsymKeyDerPublic>
  58:	4404      	add	r4, r0
        idx += SetBitString(pubKeyLen, 0, output + idx);
  5a:	1932      	adds	r2, r6, r4
  5c:	2100      	movs	r1, #0
  5e:	4628      	mov	r0, r5
  60:	f7ff fffe 	bl	0 <SetAsymKeyDerPublic>
  64:	4404      	add	r4, r0
        XMEMCPY(output + idx, pubKey, pubKeyLen);
  66:	462a      	mov	r2, r5
  68:	4639      	mov	r1, r7
  6a:	1930      	adds	r0, r6, r4
  6c:	f7ff fffe 	bl	0 <memcpy>
        idx += pubKeyLen;
  70:	1928      	adds	r0, r5, r4
        sz = idx;
  72:	e004      	b.n	7e <SetAsymKeyDerPublic+0x7e>
        sz = pubKeyLen;
  74:	4608      	mov	r0, r1
    word32 seqDataSz = 0;
  76:	46a2      	mov	sl, r4
  78:	e7df      	b.n	3a <SetAsymKeyDerPublic+0x3a>
        return BAD_FUNC_ARG;
  7a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ret = BUFFER_E;
  82:	f06f 0083 	mvn.w	r0, #131	; 0x83
  86:	e7fa      	b.n	7e <SetAsymKeyDerPublic+0x7e>

Disassembly of section .text.wc_Ed25519PublicKeyToDer:

00000000 <wc_Ed25519PublicKeyToDer>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b08c      	sub	sp, #48	; 0x30
   4:	461e      	mov	r6, r3
    word32 pubKeyLen = (word32)sizeof(pubKey);
   6:	2320      	movs	r3, #32
{
   8:	460c      	mov	r4, r1
   a:	4615      	mov	r5, r2
    word32 pubKeyLen = (word32)sizeof(pubKey);
   c:	9303      	str	r3, [sp, #12]
    if (key == NULL) {
   e:	b180      	cbz	r0, 32 <wc_Ed25519PublicKeyToDer+0x32>
    ret = wc_ed25519_export_public(key, pubKey, &pubKeyLen);
  10:	aa03      	add	r2, sp, #12
  12:	a904      	add	r1, sp, #16
  14:	f7ff fffe 	bl	0 <wc_ed25519_export_public>
    if (ret == 0) {
  18:	b948      	cbnz	r0, 2e <wc_Ed25519PublicKeyToDer+0x2e>
        ret = SetAsymKeyDerPublic(pubKey, pubKeyLen, output, inLen,
  1a:	f44f 7380 	mov.w	r3, #256	; 0x100
  1e:	9300      	str	r3, [sp, #0]
  20:	9903      	ldr	r1, [sp, #12]
  22:	9601      	str	r6, [sp, #4]
  24:	462b      	mov	r3, r5
  26:	4622      	mov	r2, r4
  28:	a804      	add	r0, sp, #16
  2a:	f7ff fffe 	bl	0 <wc_Ed25519PublicKeyToDer>
}
  2e:	b00c      	add	sp, #48	; 0x30
  30:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  32:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  36:	e7fa      	b.n	2e <wc_Ed25519PublicKeyToDer+0x2e>

Disassembly of section .text.wc_EncodeSignature:

00000000 <wc_EncodeSignature>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b09a      	sub	sp, #104	; 0x68
   6:	4607      	mov	r7, r0
   8:	461c      	mov	r4, r3
    XMEMCPY(&output[idx], digest, digSz);
   a:	f10d 001e 	add.w	r0, sp, #30
    output[0] = ASN_OCTET_STRING;
   e:	2304      	movs	r3, #4
{
  10:	4615      	mov	r5, r2
    output[0] = ASN_OCTET_STRING;
  12:	f88d 301c 	strb.w	r3, [sp, #28]
    output[1] = (byte)len;
  16:	f88d 201d 	strb.w	r2, [sp, #29]
    XMEMCPY(&output[idx], digest, digSz);
  1a:	f7ff fffe 	bl	0 <memcpy>
    algoSz   = SetAlgoID(hashOID, algoArray, oidHashType, 0);
  1e:	2300      	movs	r3, #0
  20:	461a      	mov	r2, r3
  22:	a902      	add	r1, sp, #8
  24:	4620      	mov	r0, r4
  26:	f7ff fffe 	bl	0 <wc_EncodeSignature>
    return idx + digSz;
  2a:	3502      	adds	r5, #2
    seqSz    = SetSequence(encDigSz + algoSz, seqArray);
  2c:	eb00 0805 	add.w	r8, r0, r5
    algoSz   = SetAlgoID(hashOID, algoArray, oidHashType, 0);
  30:	4604      	mov	r4, r0
    seqSz    = SetSequence(encDigSz + algoSz, seqArray);
  32:	4669      	mov	r1, sp
  34:	4640      	mov	r0, r8
  36:	f7ff fffe 	bl	0 <wc_EncodeSignature>
    XMEMCPY(out, seqArray, seqSz);
  3a:	4669      	mov	r1, sp
    seqSz    = SetSequence(encDigSz + algoSz, seqArray);
  3c:	4606      	mov	r6, r0
    XMEMCPY(out, seqArray, seqSz);
  3e:	4602      	mov	r2, r0
  40:	4638      	mov	r0, r7
  42:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(out + seqSz, algoArray, algoSz);
  46:	4622      	mov	r2, r4
  48:	a902      	add	r1, sp, #8
  4a:	19b8      	adds	r0, r7, r6
    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);
  4c:	4434      	add	r4, r6
    XMEMCPY(out + seqSz, algoArray, algoSz);
  4e:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(out + seqSz + algoSz, digArray, encDigSz);
  52:	462a      	mov	r2, r5
  54:	a907      	add	r1, sp, #28
  56:	1938      	adds	r0, r7, r4
  58:	f7ff fffe 	bl	0 <memcpy>
}
  5c:	eb08 0006 	add.w	r0, r8, r6
  60:	b01a      	add	sp, #104	; 0x68
  62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.wc_GetCTC_HashOID:

00000000 <wc_GetCTC_HashOID>:
{
   0:	b508      	push	{r3, lr}
    hType = wc_HashTypeConvert(type);
   2:	f7ff fffe 	bl	0 <wc_HashTypeConvert>
    ret = wc_HashGetOID(hType);
   6:	f7ff fffe 	bl	0 <wc_HashGetOID>
}
   a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
   e:	bd08      	pop	{r3, pc}

Disassembly of section .text.InitSignatureCtx:

00000000 <InitSignatureCtx>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4616      	mov	r6, r2
    if (sigCtx) {
   6:	4604      	mov	r4, r0
   8:	b128      	cbz	r0, 16 <InitSignatureCtx+0x16>
        XMEMSET(sigCtx, 0, sizeof(SignatureCtx));
   a:	2224      	movs	r2, #36	; 0x24
   c:	2100      	movs	r1, #0
   e:	f7ff fffe 	bl	0 <memset>
        sigCtx->devId = devId;
  12:	6126      	str	r6, [r4, #16]
        sigCtx->heap = heap;
  14:	6025      	str	r5, [r4, #0]
}
  16:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.InitDecodedCert_ex:

00000000 <InitDecodedCert_ex>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	f8dd 8018 	ldr.w	r8, [sp, #24]
   8:	460f      	mov	r7, r1
   a:	4616      	mov	r6, r2
   c:	461d      	mov	r5, r3
    if (cert != NULL) {
   e:	4604      	mov	r4, r0
  10:	b1c8      	cbz	r0, 46 <InitDecodedCert_ex+0x46>
        XMEMSET(cert, 0, sizeof(DecodedCert));
  12:	f44f 7256 	mov.w	r2, #856	; 0x358
  16:	2100      	movs	r1, #0
  18:	f7ff fffe 	bl	0 <memset>
        cert->subjectCNEnc    = CTC_UTF8;
  1c:	230c      	movs	r3, #12
  1e:	f8a4 306c 	strh.w	r3, [r4, #108]	; 0x6c
        cert->subject[0]      = '\0';
  22:	2300      	movs	r3, #0
  24:	f884 316d 	strb.w	r3, [r4, #365]	; 0x16d
        cert->maxPathLen      = WOLFSSL_MAX_PATH_LEN;
  28:	237f      	movs	r3, #127	; 0x7f
  2a:	f884 32f5 	strb.w	r3, [r4, #757]	; 0x2f5
        cert->heap            = heap;
  2e:	e9c4 659f 	strd	r6, r5, [r4, #636]	; 0x27c
        cert->source          = source;  /* don't own */
  32:	f8c4 7274 	str.w	r7, [r4, #628]	; 0x274
        InitSignatureCtx(&cert->sigCtx, heap, devId);
  36:	4642      	mov	r2, r8
  38:	4629      	mov	r1, r5
  3a:	f504 704a 	add.w	r0, r4, #808	; 0x328
}
  3e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        InitSignatureCtx(&cert->sigCtx, heap, devId);
  42:	f7ff bffe 	b.w	0 <InitDecodedCert_ex>
}
  46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.InitDecodedCert:

00000000 <InitDecodedCert>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    InitDecodedCert_ex(cert, source, inSz, heap, INVALID_DEVID);
   2:	f06f 0401 	mvn.w	r4, #1
   6:	9400      	str	r4, [sp, #0]
   8:	f7ff fffe 	bl	0 <InitDecodedCert>
}
   c:	b002      	add	sp, #8
   e:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_InitDecodedCert:

00000000 <wc_InitDecodedCert>:
    InitDecodedCert(cert, source, inSz, heap);
   0:	f7ff bffe 	b.w	0 <wc_InitDecodedCert>

Disassembly of section .text.FreeSignatureCtx:

00000000 <FreeSignatureCtx>:
{
   0:	b510      	push	{r4, lr}
    if (sigCtx == NULL)
   2:	4604      	mov	r4, r0
   4:	b1c8      	cbz	r0, 3a <FreeSignatureCtx+0x3a>
    if (sigCtx->digest) {
   6:	6840      	ldr	r0, [r0, #4]
   8:	b118      	cbz	r0, 12 <FreeSignatureCtx+0x12>
        XFREE(sigCtx->digest, sigCtx->heap, DYNAMIC_TYPE_DIGEST);
   a:	f7ff fffe 	bl	0 <free>
        sigCtx->digest = NULL;
   e:	2300      	movs	r3, #0
  10:	6063      	str	r3, [r4, #4]
    if (sigCtx->key.ptr) {
  12:	68e0      	ldr	r0, [r4, #12]
  14:	b178      	cbz	r0, 36 <FreeSignatureCtx+0x36>
        switch (sigCtx->keyOID) {
  16:	6a23      	ldr	r3, [r4, #32]
  18:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  1c:	d00e      	beq.n	3c <FreeSignatureCtx+0x3c>
  1e:	f240 2206 	movw	r2, #518	; 0x206
  22:	4293      	cmp	r3, r2
  24:	d105      	bne.n	32 <FreeSignatureCtx+0x32>
                wc_ecc_free(sigCtx->key.ecc);
  26:	f7ff fffe 	bl	0 <wc_ecc_free>
                XFREE(sigCtx->key.ed25519, sigCtx->heap, DYNAMIC_TYPE_ED25519);
  2a:	68e0      	ldr	r0, [r4, #12]
  2c:	b108      	cbz	r0, 32 <FreeSignatureCtx+0x32>
  2e:	f7ff fffe 	bl	0 <free>
        sigCtx->key.ptr = NULL;
  32:	2300      	movs	r3, #0
  34:	60e3      	str	r3, [r4, #12]
    sigCtx->state = SIG_STATE_BEGIN;
  36:	2300      	movs	r3, #0
  38:	6163      	str	r3, [r4, #20]
}
  3a:	bd10      	pop	{r4, pc}
                wc_ed25519_free(sigCtx->key.ed25519);
  3c:	f7ff fffe 	bl	0 <wc_ed25519_free>
  40:	e7f3      	b.n	2a <FreeSignatureCtx+0x2a>

Disassembly of section .text.FreeDecodedCert:

00000000 <FreeDecodedCert>:
{
   0:	b510      	push	{r4, lr}
    if (cert == NULL)
   2:	4604      	mov	r4, r0
   4:	2800      	cmp	r0, #0
   6:	d036      	beq.n	76 <FreeDecodedCert+0x76>
    if (cert->subjectCNStored == 1) {
   8:	f890 3354 	ldrb.w	r3, [r0, #852]	; 0x354
   c:	07da      	lsls	r2, r3, #31
   e:	d503      	bpl.n	18 <FreeDecodedCert+0x18>
        XFREE(cert->subjectCN, cert->heap, DYNAMIC_TYPE_SUBJECT_CN);
  10:	6e40      	ldr	r0, [r0, #100]	; 0x64
  12:	b108      	cbz	r0, 18 <FreeDecodedCert+0x18>
  14:	f7ff fffe 	bl	0 <free>
    if (cert->pubKeyStored == 1) {
  18:	68a3      	ldr	r3, [r4, #8]
  1a:	2b01      	cmp	r3, #1
  1c:	d103      	bne.n	26 <FreeDecodedCert+0x26>
        XFREE((void*)cert->publicKey, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);
  1e:	6820      	ldr	r0, [r4, #0]
  20:	b108      	cbz	r0, 26 <FreeDecodedCert+0x26>
  22:	f7ff fffe 	bl	0 <free>
    if (cert->weOwnAltNames && cert->altNames)
  26:	f894 3354 	ldrb.w	r3, [r4, #852]	; 0x354
  2a:	065b      	lsls	r3, r3, #25
  2c:	d505      	bpl.n	3a <FreeDecodedCert+0x3a>
  2e:	6a60      	ldr	r0, [r4, #36]	; 0x24
  30:	b118      	cbz	r0, 3a <FreeDecodedCert+0x3a>
        FreeAltNames(cert->altNames, cert->heap);
  32:	f8d4 1280 	ldr.w	r1, [r4, #640]	; 0x280
  36:	f7ff fffe 	bl	0 <FreeDecodedCert>
    if (cert->altEmailNames)
  3a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  3c:	b118      	cbz	r0, 46 <FreeDecodedCert+0x46>
        FreeAltNames(cert->altEmailNames, cert->heap);
  3e:	f8d4 1280 	ldr.w	r1, [r4, #640]	; 0x280
  42:	f7ff fffe 	bl	0 <FreeDecodedCert>
    if (cert->altDirNames)
  46:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  48:	b118      	cbz	r0, 52 <FreeDecodedCert+0x52>
        FreeAltNames(cert->altDirNames, cert->heap);
  4a:	f8d4 1280 	ldr.w	r1, [r4, #640]	; 0x280
  4e:	f7ff fffe 	bl	0 <FreeDecodedCert>
    if (cert->permittedNames)
  52:	6b20      	ldr	r0, [r4, #48]	; 0x30
  54:	b118      	cbz	r0, 5e <FreeDecodedCert+0x5e>
        FreeNameSubtrees(cert->permittedNames, cert->heap);
  56:	f8d4 1280 	ldr.w	r1, [r4, #640]	; 0x280
  5a:	f7ff fffe 	bl	0 <FreeDecodedCert>
    if (cert->excludedNames)
  5e:	6b60      	ldr	r0, [r4, #52]	; 0x34
  60:	b118      	cbz	r0, 6a <FreeDecodedCert+0x6a>
        FreeNameSubtrees(cert->excludedNames, cert->heap);
  62:	f8d4 1280 	ldr.w	r1, [r4, #640]	; 0x280
  66:	f7ff fffe 	bl	0 <FreeDecodedCert>
    FreeSignatureCtx(&cert->sigCtx);
  6a:	f504 704a 	add.w	r0, r4, #808	; 0x328
}
  6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    FreeSignatureCtx(&cert->sigCtx);
  72:	f7ff bffe 	b.w	0 <FreeDecodedCert>
}
  76:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_FreeDecodedCert:

00000000 <wc_FreeDecodedCert>:
    FreeDecodedCert(cert);
   0:	f7ff bffe 	b.w	0 <wc_FreeDecodedCert>

Disassembly of section .text.wc_CertGetPubKey:

00000000 <wc_CertGetPubKey>:
{
   0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	461f      	mov	r7, r3
    word32 o = 0;
   6:	2300      	movs	r3, #0
{
   8:	4689      	mov	r9, r1
   a:	4690      	mov	r8, r2
    word32 o = 0;
   c:	9303      	str	r3, [sp, #12]
    if ((cert == NULL) || (pubKey == NULL) || (pubKeySz == NULL)) {
   e:	4604      	mov	r4, r0
  10:	b1b8      	cbz	r0, 42 <wc_CertGetPubKey+0x42>
  12:	b1b2      	cbz	r2, 42 <wc_CertGetPubKey+0x42>
        ret = BAD_FUNC_ARG;
  14:	429f      	cmp	r7, r3
  16:	bf14      	ite	ne
  18:	461d      	movne	r5, r3
  1a:	f06f 05ac 	mvneq.w	r5, #172	; 0xac
        DecodeInstr op = ops[i];
  1e:	f8df a070 	ldr.w	sl, [pc, #112]	; 90 <wc_CertGetPubKey+0x90>
                ret = ASN_PARSE_E;
  22:	2600      	movs	r6, #0
    for (i = 0; (ret == 0) && (i < (int)(sizeof(ops) / sizeof(*ops))); i++) {
  24:	b94d      	cbnz	r5, 3a <wc_CertGetPubKey+0x3a>
  26:	2e0b      	cmp	r6, #11
        if (cert[o] != op.tag) {
  28:	9803      	ldr	r0, [sp, #12]
    for (i = 0; (ret == 0) && (i < (int)(sizeof(ops) / sizeof(*ops))); i++) {
  2a:	d10d      	bne.n	48 <wc_CertGetPubKey+0x48>
        *pubKeySz = (word32)(l - 1);
  2c:	9b02      	ldr	r3, [sp, #8]
        *pubKey = cert + o + 1;
  2e:	3001      	adds	r0, #1
  30:	4420      	add	r0, r4
        *pubKeySz = (word32)(l - 1);
  32:	3b01      	subs	r3, #1
        *pubKey = cert + o + 1;
  34:	f8c8 0000 	str.w	r0, [r8]
        *pubKeySz = (word32)(l - 1);
  38:	603b      	str	r3, [r7, #0]
}
  3a:	4628      	mov	r0, r5
  3c:	b004      	add	sp, #16
  3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        ret = BAD_FUNC_ARG;
  42:	f06f 05ac 	mvn.w	r5, #172	; 0xac
  46:	e7ea      	b.n	1e <wc_CertGetPubKey+0x1e>
        DecodeInstr op = ops[i];
  48:	f83a 3016 	ldrh.w	r3, [sl, r6, lsl #1]
        if (cert[o] != op.tag) {
  4c:	5c22      	ldrb	r2, [r4, r0]
        DecodeInstr op = ops[i];
  4e:	f8ad 3004 	strh.w	r3, [sp, #4]
        if (cert[o] != op.tag) {
  52:	f81a 3016 	ldrb.w	r3, [sl, r6, lsl #1]
  56:	429a      	cmp	r2, r3
  58:	d007      	beq.n	6a <wc_CertGetPubKey+0x6a>
            if (!op.optional) {
  5a:	f89d 3005 	ldrb.w	r3, [sp, #5]
  5e:	079a      	lsls	r2, r3, #30
  60:	d401      	bmi.n	66 <wc_CertGetPubKey+0x66>
                ret = ASN_PARSE_E;
  62:	f06f 058b 	mvn.w	r5, #139	; 0x8b
    for (i = 0; (ret == 0) && (i < (int)(sizeof(ops) / sizeof(*ops))); i++) {
  66:	3601      	adds	r6, #1
  68:	e7dc      	b.n	24 <wc_CertGetPubKey+0x24>
            o++;
  6a:	3001      	adds	r0, #1
  6c:	9003      	str	r0, [sp, #12]
            if (GetLength(cert, &o, &l, certSz) < 0) {
  6e:	464b      	mov	r3, r9
  70:	aa02      	add	r2, sp, #8
  72:	a903      	add	r1, sp, #12
  74:	4620      	mov	r0, r4
  76:	f7ff fffe 	bl	0 <wc_CertGetPubKey>
  7a:	2800      	cmp	r0, #0
  7c:	dbf1      	blt.n	62 <wc_CertGetPubKey+0x62>
            else if (op.op == DECODE_INSTR_OVER) {
  7e:	f89d 3005 	ldrb.w	r3, [sp, #5]
  82:	07db      	lsls	r3, r3, #31
                o += (word32)l;
  84:	bf42      	ittt	mi
  86:	e9dd 2302 	ldrdmi	r2, r3, [sp, #8]
  8a:	189b      	addmi	r3, r3, r2
  8c:	9303      	strmi	r3, [sp, #12]
  8e:	e7ea      	b.n	66 <wc_CertGetPubKey+0x66>
  90:	00000000 	.word	0x00000000

Disassembly of section .text.MakeSigner:

00000000 <MakeSigner>:
{
   0:	b510      	push	{r4, lr}
    Signer* signer = (Signer*) XMALLOC(sizeof(Signer), heap,
   2:	204c      	movs	r0, #76	; 0x4c
   4:	f7ff fffe 	bl	0 <malloc>
    if (signer) {
   8:	4604      	mov	r4, r0
   a:	b118      	cbz	r0, 14 <MakeSigner+0x14>
        XMEMSET(signer, 0, sizeof(Signer));
   c:	224c      	movs	r2, #76	; 0x4c
   e:	2100      	movs	r1, #0
  10:	f7ff fffe 	bl	0 <memset>
}
  14:	4620      	mov	r0, r4
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.FreeSigner:

00000000 <FreeSigner>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4604      	mov	r4, r0
    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);
   4:	6940      	ldr	r0, [r0, #20]
{
   6:	460d      	mov	r5, r1
    XFREE(signer->name, heap, DYNAMIC_TYPE_SUBJECT_CN);
   8:	b108      	cbz	r0, e <FreeSigner+0xe>
   a:	f7ff fffe 	bl	0 <free>
    XFREE((void*)signer->publicKey, heap, DYNAMIC_TYPE_PUBLIC_KEY);
   e:	68e0      	ldr	r0, [r4, #12]
  10:	b108      	cbz	r0, 16 <FreeSigner+0x16>
  12:	f7ff fffe 	bl	0 <free>
    if (signer->permittedNames)
  16:	69a0      	ldr	r0, [r4, #24]
  18:	b110      	cbz	r0, 20 <FreeSigner+0x20>
        FreeNameSubtrees(signer->permittedNames, heap);
  1a:	4629      	mov	r1, r5
  1c:	f7ff fffe 	bl	0 <FreeSigner>
    if (signer->excludedNames)
  20:	69e0      	ldr	r0, [r4, #28]
  22:	b110      	cbz	r0, 2a <FreeSigner+0x2a>
        FreeNameSubtrees(signer->excludedNames, heap);
  24:	4629      	mov	r1, r5
  26:	f7ff fffe 	bl	0 <FreeSigner>
    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);
  2a:	4620      	mov	r0, r4
}
  2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    XFREE(signer, heap, DYNAMIC_TYPE_SIGNER);
  30:	f7ff bffe 	b.w	0 <free>

Disassembly of section .text.FreeSignerTable:

00000000 <FreeSignerTable>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460d      	mov	r5, r1
   6:	4617      	mov	r7, r2
   8:	1f04      	subs	r4, r0, #4
    for (i = 0; i < rows; i++) {
   a:	2600      	movs	r6, #0
   c:	42ae      	cmp	r6, r5
   e:	db01      	blt.n	14 <FreeSignerTable+0x14>
}
  10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        Signer* signer = table[i];
  14:	6860      	ldr	r0, [r4, #4]
        while (signer) {
  16:	b918      	cbnz	r0, 20 <FreeSignerTable+0x20>
        table[i] = NULL;
  18:	f844 0f04 	str.w	r0, [r4, #4]!
    for (i = 0; i < rows; i++) {
  1c:	3601      	adds	r6, #1
  1e:	e7f5      	b.n	c <FreeSignerTable+0xc>
            Signer* next = signer->next;
  20:	f8d0 8048 	ldr.w	r8, [r0, #72]	; 0x48
            FreeSigner(signer, heap);
  24:	4639      	mov	r1, r7
  26:	f7ff fffe 	bl	0 <FreeSignerTable>
            signer = next;
  2a:	4640      	mov	r0, r8
  2c:	e7f3      	b.n	16 <FreeSignerTable+0x16>

Disassembly of section .text.SetSerialNumber:

00000000 <SetSerialNumber>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4616      	mov	r6, r2
   6:	461d      	mov	r5, r3
   8:	9a06      	ldr	r2, [sp, #24]
    int snSzInt = (int)snSz;
   a:	460f      	mov	r7, r1
    if (sn == NULL || output == NULL || snSzInt < 0)
   c:	4603      	mov	r3, r0
   e:	b340      	cbz	r0, 62 <SetSerialNumber+0x62>
  10:	b33e      	cbz	r6, 62 <SetSerialNumber+0x62>
  12:	2900      	cmp	r1, #0
  14:	db25      	blt.n	62 <SetSerialNumber+0x62>
  16:	4698      	mov	r8, r3
    while (snSzInt > 0 && sn[0] == 0) {
  18:	b31f      	cbz	r7, 62 <SetSerialNumber+0x62>
  1a:	7819      	ldrb	r1, [r3, #0]
  1c:	3301      	adds	r3, #1
  1e:	b1f1      	cbz	r1, 5e <SetSerialNumber+0x5e>
    if (sn[0] & 0x80)
  20:	060b      	lsls	r3, r1, #24
  22:	d500      	bpl.n	26 <SetSerialNumber+0x26>
        maxSnSz--;
  24:	3a01      	subs	r2, #1
    if (snSzInt > maxSnSz)
  26:	4297      	cmp	r7, r2
  28:	bfa8      	it	ge
  2a:	4617      	movge	r7, r2
    i = SetASNInt(snSzInt, sn[0], NULL);
  2c:	4638      	mov	r0, r7
  2e:	2200      	movs	r2, #0
  30:	f7ff fffe 	bl	0 <SetSerialNumber>
  34:	4604      	mov	r4, r0
    if (snSzInt > (int)outputSz - i)
  36:	1a28      	subs	r0, r5, r0
  38:	4287      	cmp	r7, r0
  3a:	bfa8      	it	ge
  3c:	4607      	movge	r7, r0
    if (snSzInt <= 0) {
  3e:	2f00      	cmp	r7, #0
  40:	dd12      	ble.n	68 <SetSerialNumber+0x68>
    (void)SetASNInt(snSzInt, sn[0], output);
  42:	f898 1000 	ldrb.w	r1, [r8]
  46:	4632      	mov	r2, r6
  48:	4638      	mov	r0, r7
  4a:	f7ff fffe 	bl	0 <SetSerialNumber>
    XMEMCPY(output + i, sn, (size_t)snSzInt);
  4e:	463a      	mov	r2, r7
  50:	4641      	mov	r1, r8
  52:	1930      	adds	r0, r6, r4
  54:	f7ff fffe 	bl	0 <memcpy>
    i += snSzInt;
  58:	19e0      	adds	r0, r4, r7
}
  5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        snSzInt--;
  5e:	3f01      	subs	r7, #1
        sn++;
  60:	e7d9      	b.n	16 <SetSerialNumber+0x16>
        return BAD_FUNC_ARG;
  62:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  66:	e7f8      	b.n	5a <SetSerialNumber+0x5a>
        return BUFFER_E;
  68:	f06f 0083 	mvn.w	r0, #131	; 0x83
  6c:	e7f5      	b.n	5a <SetSerialNumber+0x5a>

Disassembly of section .text.SetMyVersion:

00000000 <SetMyVersion>:
{
   0:	4603      	mov	r3, r0
    if (output == NULL)
   2:	b169      	cbz	r1, 20 <SetMyVersion+0x20>
    if (header) {
   4:	b122      	cbz	r2, 10 <SetMyVersion+0x10>
        output[i++] = ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED;
   6:	22a0      	movs	r2, #160	; 0xa0
   8:	700a      	strb	r2, [r1, #0]
        output[i++] = 3;
   a:	2203      	movs	r2, #3
   c:	704a      	strb	r2, [r1, #1]
   e:	2202      	movs	r2, #2
    output[i++] = ASN_INTEGER;
  10:	2002      	movs	r0, #2
  12:	5488      	strb	r0, [r1, r2]
    output[i++] = 0x01;
  14:	4411      	add	r1, r2
  16:	2001      	movs	r0, #1
  18:	7048      	strb	r0, [r1, #1]
    output[i++] = (byte)version;
  1a:	708b      	strb	r3, [r1, #2]
  1c:	1cd0      	adds	r0, r2, #3
    return i;
  1e:	4770      	bx	lr
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  24:	4770      	bx	lr

Disassembly of section .text.wc_CreatePKCS8Key:

00000000 <wc_CreatePKCS8Key>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	461f      	mov	r7, r3
   6:	b087      	sub	sp, #28
    word32 keyIdx = 0;
   8:	2300      	movs	r3, #0
{
   a:	e9dd 4611 	ldrd	r4, r6, [sp, #68]	; 0x44
    word32 tmpAlgId = 0;
   e:	e9cd 3303 	strd	r3, r3, [sp, #12]
{
  12:	4689      	mov	r9, r1
  14:	4693      	mov	fp, r2
    if (out == NULL && outSz != NULL) {
  16:	4680      	mov	r8, r0
  18:	2800      	cmp	r0, #0
  1a:	f040 8086 	bne.w	12a <wc_CreatePKCS8Key+0x12a>
  1e:	2900      	cmp	r1, #0
  20:	f000 8085 	beq.w	12e <wc_CreatePKCS8Key+0x12e>
                 + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 2;
  24:	3728      	adds	r7, #40	; 0x28
        if (curveOID != NULL)
  26:	b92c      	cbnz	r4, 34 <wc_CreatePKCS8Key+0x34>
        *outSz = keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ
  28:	600f      	str	r7, [r1, #0]
        return LENGTH_ONLY_E;
  2a:	f06f 00c9 	mvn.w	r0, #201	; 0xc9
}
  2e:	b007      	add	sp, #28
  30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *outSz += oidSz + MAX_LENGTH_SZ + 1;
  34:	3605      	adds	r6, #5
  36:	443e      	add	r6, r7
  38:	600e      	str	r6, [r1, #0]
  3a:	e7f6      	b.n	2a <wc_CreatePKCS8Key+0x2a>
    if (key == NULL || out == NULL || outSz == NULL) {
  3c:	f1b9 0f00 	cmp.w	r9, #0
  40:	d075      	beq.n	12e <wc_CreatePKCS8Key+0x12e>
        if (*outSz < (keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ
  42:	f8d9 2000 	ldr.w	r2, [r9]
    if (curveOID != NULL) {
  46:	b13c      	cbz	r4, 58 <wc_CreatePKCS8Key+0x58>
               + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 3 + oidSz + MAX_LENGTH_SZ))
  48:	f106 032d 	add.w	r3, r6, #45	; 0x2d
  4c:	443b      	add	r3, r7
        if (*outSz < (keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ
  4e:	4293      	cmp	r3, r2
  50:	d907      	bls.n	62 <wc_CreatePKCS8Key+0x62>
            return BUFFER_E;
  52:	f06f 0083 	mvn.w	r0, #131	; 0x83
  56:	e7ea      	b.n	2e <wc_CreatePKCS8Key+0x2e>
                  + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 2))
  58:	f107 0328 	add.w	r3, r7, #40	; 0x28
        if (*outSz < (keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ
  5c:	4293      	cmp	r3, r2
  5e:	d8f8      	bhi.n	52 <wc_CreatePKCS8Key+0x52>
        oidSz = 0; /* with no curveOID oid size must be 0 */
  60:	4626      	mov	r6, r4
    if (ToTraditionalInline_ex(key, &keyIdx, keySz, &tmpAlgId) >= 0) {
  62:	ab04      	add	r3, sp, #16
  64:	463a      	mov	r2, r7
  66:	a903      	add	r1, sp, #12
  68:	4658      	mov	r0, fp
  6a:	f7ff fffe 	bl	0 <wc_CreatePKCS8Key>
  6e:	2800      	cmp	r0, #0
  70:	da58      	bge.n	124 <wc_CreatePKCS8Key+0x124>
    keyIdx = MAX_SEQ_SZ; /* save room for sequence */
  72:	2305      	movs	r3, #5
    sz = (word32)SetMyVersion(PKCS8v0, out + keyIdx, 0);
  74:	eb08 0a03 	add.w	sl, r8, r3
  78:	2200      	movs	r2, #0
  7a:	4651      	mov	r1, sl
  7c:	4610      	mov	r0, r2
    keyIdx = MAX_SEQ_SZ; /* save room for sequence */
  7e:	9303      	str	r3, [sp, #12]
    sz = (word32)SetMyVersion(PKCS8v0, out + keyIdx, 0);
  80:	f7ff fffe 	bl	0 <wc_CreatePKCS8Key>
    tmpSz += sz; keyIdx += sz;
  84:	9b03      	ldr	r3, [sp, #12]
  86:	4403      	add	r3, r0
    sz = (word32)SetMyVersion(PKCS8v0, out + keyIdx, 0);
  88:	4605      	mov	r5, r0
    tmpSz += sz; keyIdx += sz;
  8a:	9303      	str	r3, [sp, #12]
    if (curveOID != NULL && oidSz > 0) {
  8c:	2c00      	cmp	r4, #0
  8e:	d045      	beq.n	11c <wc_CreatePKCS8Key+0x11c>
  90:	2e00      	cmp	r6, #0
  92:	d045      	beq.n	120 <wc_CreatePKCS8Key+0x120>
        sz = SetLength(oidSz, buf);
  94:	a905      	add	r1, sp, #20
  96:	4630      	mov	r0, r6
  98:	f7ff fffe 	bl	0 <wc_CreatePKCS8Key>
        sz += 1; /* plus one for ASN object id */
  9c:	1c43      	adds	r3, r0, #1
    sz = (word32)SetAlgoID(algoID, out + keyIdx, oidKeyType, (int)(oidSz + sz));
  9e:	9903      	ldr	r1, [sp, #12]
  a0:	9810      	ldr	r0, [sp, #64]	; 0x40
  a2:	4441      	add	r1, r8
  a4:	4433      	add	r3, r6
  a6:	2202      	movs	r2, #2
  a8:	f7ff fffe 	bl	0 <wc_CreatePKCS8Key>
    tmpSz += sz; keyIdx += sz;
  ac:	9903      	ldr	r1, [sp, #12]
  ae:	4401      	add	r1, r0
  b0:	4405      	add	r5, r0
  b2:	9103      	str	r1, [sp, #12]
    if (curveOID != NULL && oidSz > 0) {
  b4:	b1a4      	cbz	r4, e0 <wc_CreatePKCS8Key+0xe0>
  b6:	b19e      	cbz	r6, e0 <wc_CreatePKCS8Key+0xe0>
        sz = (word32)SetObjectId((int)oidSz, out + keyIdx);
  b8:	4441      	add	r1, r8
  ba:	4630      	mov	r0, r6
  bc:	f7ff fffe 	bl	0 <wc_CreatePKCS8Key>
  c0:	4603      	mov	r3, r0
        keyIdx += sz; tmpSz += sz;
  c2:	9803      	ldr	r0, [sp, #12]
  c4:	9301      	str	r3, [sp, #4]
  c6:	4418      	add	r0, r3
  c8:	9003      	str	r0, [sp, #12]
        XMEMCPY(out + keyIdx, curveOID, oidSz);
  ca:	4632      	mov	r2, r6
  cc:	4621      	mov	r1, r4
  ce:	4440      	add	r0, r8
  d0:	f7ff fffe 	bl	0 <memcpy>
        keyIdx += oidSz; tmpSz += oidSz;
  d4:	9a03      	ldr	r2, [sp, #12]
  d6:	9b01      	ldr	r3, [sp, #4]
  d8:	4435      	add	r5, r6
  da:	4432      	add	r2, r6
  dc:	9203      	str	r2, [sp, #12]
  de:	441d      	add	r5, r3
    sz = (word32)SetOctetString(keySz, out + keyIdx);
  e0:	9903      	ldr	r1, [sp, #12]
  e2:	4638      	mov	r0, r7
  e4:	4441      	add	r1, r8
  e6:	f7ff fffe 	bl	0 <wc_CreatePKCS8Key>
    keyIdx += sz; tmpSz += sz;
  ea:	9b03      	ldr	r3, [sp, #12]
  ec:	182c      	adds	r4, r5, r0
  ee:	4403      	add	r3, r0
    XMEMCPY(out + keyIdx, key, keySz);
  f0:	463a      	mov	r2, r7
  f2:	eb08 0003 	add.w	r0, r8, r3
    tmpSz += keySz;
  f6:	443c      	add	r4, r7
    XMEMCPY(out + keyIdx, key, keySz);
  f8:	4659      	mov	r1, fp
    keyIdx += sz; tmpSz += sz;
  fa:	9303      	str	r3, [sp, #12]
    XMEMCPY(out + keyIdx, key, keySz);
  fc:	f7ff fffe 	bl	0 <memcpy>
    sz = SetSequence(tmpSz, out);
 100:	4641      	mov	r1, r8
 102:	4620      	mov	r0, r4
 104:	f7ff fffe 	bl	0 <wc_CreatePKCS8Key>
    XMEMMOVE(out + sz, out + MAX_SEQ_SZ, tmpSz);
 108:	4622      	mov	r2, r4
    sz = SetSequence(tmpSz, out);
 10a:	4605      	mov	r5, r0
    XMEMMOVE(out + sz, out + MAX_SEQ_SZ, tmpSz);
 10c:	4651      	mov	r1, sl
 10e:	4440      	add	r0, r8
 110:	f7ff fffe 	bl	0 <memmove>
    *outSz = tmpSz + sz;
 114:	1960      	adds	r0, r4, r5
 116:	f8c9 0000 	str.w	r0, [r9]
    return (int)(tmpSz + sz);
 11a:	e788      	b.n	2e <wc_CreatePKCS8Key+0x2e>
    sz = 0; /* set sz to 0 and get privateKey oid buffer size needed */
 11c:	4623      	mov	r3, r4
 11e:	e7be      	b.n	9e <wc_CreatePKCS8Key+0x9e>
 120:	4633      	mov	r3, r6
 122:	e7bc      	b.n	9e <wc_CreatePKCS8Key+0x9e>
        return ASN_PARSE_E;
 124:	f06f 008b 	mvn.w	r0, #139	; 0x8b
 128:	e781      	b.n	2e <wc_CreatePKCS8Key+0x2e>
    if (key == NULL || out == NULL || outSz == NULL) {
 12a:	2a00      	cmp	r2, #0
 12c:	d186      	bne.n	3c <wc_CreatePKCS8Key+0x3c>
        return BAD_FUNC_ARG;
 12e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 132:	e77c      	b.n	2e <wc_CreatePKCS8Key+0x2e>

Disassembly of section .text.wc_GetSerialNumber:

00000000 <wc_GetSerialNumber>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	461e      	mov	r6, r3
   6:	4680      	mov	r8, r0
   8:	9b06      	ldr	r3, [sp, #24]
   a:	460d      	mov	r5, r1
    if (serial == NULL || input == NULL || serialSz == NULL) {
   c:	4617      	mov	r7, r2
   e:	b1d2      	cbz	r2, 46 <wc_GetSerialNumber+0x46>
  10:	b1c8      	cbz	r0, 46 <wc_GetSerialNumber+0x46>
  12:	b1c6      	cbz	r6, 46 <wc_GetSerialNumber+0x46>
    if ((*inOutIdx+1) > maxIdx) {
  14:	680a      	ldr	r2, [r1, #0]
  16:	3201      	adds	r2, #1
  18:	429a      	cmp	r2, r3
  1a:	d817      	bhi.n	4c <wc_GetSerialNumber+0x4c>
    ret = GetASNInt(input, inOutIdx, serialSz, maxIdx);
  1c:	4632      	mov	r2, r6
  1e:	f7ff fffe 	bl	0 <wc_GetSerialNumber>
    if (ret != 0)
  22:	4604      	mov	r4, r0
  24:	b960      	cbnz	r0, 40 <wc_GetSerialNumber+0x40>
    if (*serialSz > EXTERNAL_SERIAL_SIZE || *serialSz <= 0) {
  26:	6832      	ldr	r2, [r6, #0]
  28:	1e53      	subs	r3, r2, #1
  2a:	2b1f      	cmp	r3, #31
  2c:	d811      	bhi.n	52 <wc_GetSerialNumber+0x52>
    XMEMCPY(serial, &input[*inOutIdx], (size_t)*serialSz);
  2e:	6829      	ldr	r1, [r5, #0]
  30:	4638      	mov	r0, r7
  32:	4441      	add	r1, r8
  34:	f7ff fffe 	bl	0 <memcpy>
    *inOutIdx += (word32)*serialSz;
  38:	682b      	ldr	r3, [r5, #0]
  3a:	6832      	ldr	r2, [r6, #0]
  3c:	4413      	add	r3, r2
  3e:	602b      	str	r3, [r5, #0]
}
  40:	4620      	mov	r0, r4
  42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return BAD_FUNC_ARG;
  46:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  4a:	e7f9      	b.n	40 <wc_GetSerialNumber+0x40>
        return BUFFER_E;
  4c:	f06f 0483 	mvn.w	r4, #131	; 0x83
  50:	e7f6      	b.n	40 <wc_GetSerialNumber+0x40>
        return ASN_PARSE_E;
  52:	f06f 048b 	mvn.w	r4, #139	; 0x8b
  56:	e7f3      	b.n	40 <wc_GetSerialNumber+0x40>

Disassembly of section .text.wc_GetPubX509:

00000000 <wc_GetPubX509>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4688      	mov	r8, r1
   6:	b086      	sub	sp, #24
   8:	4616      	mov	r6, r2
    if (cert == NULL || badDate == NULL)
   a:	4604      	mov	r4, r0
   c:	2800      	cmp	r0, #0
   e:	f000 80a0 	beq.w	152 <wc_GetPubX509+0x152>
  12:	2a00      	cmp	r2, #0
  14:	f000 809d 	beq.w	152 <wc_GetPubX509+0x152>
    *badDate = 0;
  18:	2300      	movs	r3, #0
  1a:	6013      	str	r3, [r2, #0]
    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)
  1c:	f500 771e 	add.w	r7, r0, #632	; 0x278
  20:	f8d0 327c 	ldr.w	r3, [r0, #636]	; 0x27c
  24:	f8d0 0274 	ldr.w	r0, [r0, #628]	; 0x274
  28:	aa04      	add	r2, sp, #16
  2a:	4639      	mov	r1, r7
  2c:	f7ff fffe 	bl	0 <wc_GetPubX509>
  30:	2800      	cmp	r0, #0
  32:	db25      	blt.n	80 <wc_GetPubX509+0x80>
    cert->maxIdx = (word32)len + cert->srcIdx;
  34:	f8d4 2278 	ldr.w	r2, [r4, #632]	; 0x278
  38:	9b04      	ldr	r3, [sp, #16]
    cert->certBegin = cert->srcIdx;
  3a:	60e2      	str	r2, [r4, #12]
    cert->maxIdx = (word32)len + cert->srcIdx;
  3c:	4413      	add	r3, r2
    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)
  3e:	f8d4 0274 	ldr.w	r0, [r4, #628]	; 0x274
    cert->maxIdx = (word32)len + cert->srcIdx;
  42:	f8c4 327c 	str.w	r3, [r4, #636]	; 0x27c
    if (GetSequence(cert->source, &cert->srcIdx, &len, cert->maxIdx) < 0)
  46:	aa04      	add	r2, sp, #16
  48:	4639      	mov	r1, r7
  4a:	f7ff fffe 	bl	0 <wc_GetPubX509>
  4e:	2800      	cmp	r0, #0
  50:	db16      	blt.n	80 <wc_GetPubX509+0x80>
    cert->sigIndex = (word32)len + cert->srcIdx;
  52:	9a04      	ldr	r2, [sp, #16]
  54:	f8d4 3278 	ldr.w	r3, [r4, #632]	; 0x278
  58:	eb03 0902 	add.w	r9, r3, r2
    if (cert->sigIndex > cert->maxIdx)
  5c:	f8d4 227c 	ldr.w	r2, [r4, #636]	; 0x27c
    cert->sigIndex = (word32)len + cert->srcIdx;
  60:	f8c4 9010 	str.w	r9, [r4, #16]
    if (cert->sigIndex > cert->maxIdx)
  64:	4591      	cmp	r9, r2
  66:	d80b      	bhi.n	80 <wc_GetPubX509+0x80>
    if (GetExplicitVersion(cert->source, &cert->srcIdx, &cert->version,
  68:	f8d4 a274 	ldr.w	sl, [r4, #628]	; 0x274
    word32 idx = *inOutIdx;
  6c:	9305      	str	r3, [sp, #20]
    if (GetASNTag(input, &idx, &tag, maxIdx) != 0)
  6e:	f10d 020f 	add.w	r2, sp, #15
  72:	464b      	mov	r3, r9
  74:	a905      	add	r1, sp, #20
  76:	4650      	mov	r0, sl
  78:	f7ff fffe 	bl	0 <wc_GetPubX509>
  7c:	4605      	mov	r5, r0
  7e:	b120      	cbz	r0, 8a <wc_GetPubX509+0x8a>
        return ASN_PARSE_E;
  80:	f06f 008b 	mvn.w	r0, #139	; 0x8b
}
  84:	b006      	add	sp, #24
  86:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (tag == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED)) {
  8a:	f89d 300f 	ldrb.w	r3, [sp, #15]
  8e:	2ba0      	cmp	r3, #160	; 0xa0
  90:	d139      	bne.n	106 <wc_GetPubX509+0x106>
        *inOutIdx = ++idx;  /* skip header */
  92:	9b05      	ldr	r3, [sp, #20]
  94:	3301      	adds	r3, #1
  96:	9305      	str	r3, [sp, #20]
  98:	f8c4 3278 	str.w	r3, [r4, #632]	; 0x278
        ret = GetMyVersion(input, inOutIdx, version, maxIdx);
  9c:	f104 0220 	add.w	r2, r4, #32
  a0:	464b      	mov	r3, r9
  a2:	4639      	mov	r1, r7
  a4:	4650      	mov	r0, sl
  a6:	f7ff fffe 	bl	0 <wc_GetPubX509>
        if (ret >= 0) {
  aa:	2800      	cmp	r0, #0
  ac:	dbe8      	blt.n	80 <wc_GetPubX509+0x80>
            if (*version > MAX_X509_VERSION || *version < MIN_X509_VERSION) {
  ae:	6a23      	ldr	r3, [r4, #32]
  b0:	2b03      	cmp	r3, #3
  b2:	d8e5      	bhi.n	80 <wc_GetPubX509+0x80>
    if (wc_GetSerialNumber(cert->source, &cert->srcIdx, cert->serial,
  b4:	6923      	ldr	r3, [r4, #16]
  b6:	9300      	str	r3, [sp, #0]
  b8:	f8d4 0274 	ldr.w	r0, [r4, #628]	; 0x274
  bc:	f504 7329 	add.w	r3, r4, #676	; 0x2a4
  c0:	f504 7221 	add.w	r2, r4, #644	; 0x284
  c4:	4639      	mov	r1, r7
  c6:	f7ff fffe 	bl	0 <wc_GetPubX509>
  ca:	2800      	cmp	r0, #0
  cc:	dbd8      	blt.n	80 <wc_GetPubX509+0x80>
        if ((ret = GetSigAlg(cert, &cert->signatureOID, cert->sigIndex)) < 0)
  ce:	6922      	ldr	r2, [r4, #16]
  d0:	f104 0118 	add.w	r1, r4, #24
  d4:	4620      	mov	r0, r4
  d6:	f7ff fffe 	bl	0 <wc_GetPubX509>
  da:	2800      	cmp	r0, #0
  dc:	dbd2      	blt.n	84 <wc_GetPubX509+0x84>
        if ( (ret = GetName(cert, ISSUER, (int)cert->sigIndex)) < 0)
  de:	6922      	ldr	r2, [r4, #16]
  e0:	2100      	movs	r1, #0
  e2:	4620      	mov	r0, r4
  e4:	f7ff fffe 	bl	0 <wc_GetPubX509>
  e8:	2800      	cmp	r0, #0
  ea:	dbcb      	blt.n	84 <wc_GetPubX509+0x84>
    if (GetSequence(cert->source, &cert->srcIdx, &length, (word32)maxIdx) < 0)
  ec:	6923      	ldr	r3, [r4, #16]
  ee:	f8d4 0274 	ldr.w	r0, [r4, #628]	; 0x274
  f2:	aa05      	add	r2, sp, #20
  f4:	4639      	mov	r1, r7
  f6:	f7ff fffe 	bl	0 <wc_GetPubX509>
  fa:	2800      	cmp	r0, #0
  fc:	da05      	bge.n	10a <wc_GetPubX509+0x10a>
        return ASN_PARSE_E;
  fe:	f06f 058b 	mvn.w	r5, #139	; 0x8b
            *badDate = ret;
 102:	6035      	str	r5, [r6, #0]
 104:	e01d      	b.n	142 <wc_GetPubX509+0x142>
    *version = 0;
 106:	6220      	str	r0, [r4, #32]
    return 0;
 108:	e7d4      	b.n	b4 <wc_GetPubX509+0xb4>
    maxIdx = (int)cert->srcIdx + length;
 10a:	9b05      	ldr	r3, [sp, #20]
 10c:	f8d4 7278 	ldr.w	r7, [r4, #632]	; 0x278
 110:	441f      	add	r7, r3
    if (GetDate(cert, BEFORE, verify, maxIdx) < 0)
 112:	463b      	mov	r3, r7
 114:	4642      	mov	r2, r8
 116:	2100      	movs	r1, #0
 118:	4620      	mov	r0, r4
 11a:	f7ff fffe 	bl	0 <wc_GetPubX509>
    if (GetDate(cert, AFTER, verify, maxIdx) < 0)
 11e:	463b      	mov	r3, r7
        badDate = ASN_BEFORE_DATE_E; /* continue parsing */
 120:	2800      	cmp	r0, #0
    if (GetDate(cert, AFTER, verify, maxIdx) < 0)
 122:	4642      	mov	r2, r8
 124:	f04f 0101 	mov.w	r1, #1
 128:	4620      	mov	r0, r4
        badDate = ASN_BEFORE_DATE_E; /* continue parsing */
 12a:	bfb8      	it	lt
 12c:	f06f 0595 	mvnlt.w	r5, #149	; 0x95
    if (GetDate(cert, AFTER, verify, maxIdx) < 0)
 130:	f7ff fffe 	bl	0 <wc_GetPubX509>
 134:	2800      	cmp	r0, #0
 136:	da02      	bge.n	13e <wc_GetPubX509+0x13e>
        return ASN_AFTER_DATE_E;
 138:	f06f 0596 	mvn.w	r5, #150	; 0x96
 13c:	e7e1      	b.n	102 <wc_GetPubX509+0x102>
    if (badDate != 0)
 13e:	2d00      	cmp	r5, #0
 140:	d1df      	bne.n	102 <wc_GetPubX509+0x102>
    if ( (ret = GetName(cert, SUBJECT, (int)cert->sigIndex)) < 0)
 142:	6922      	ldr	r2, [r4, #16]
 144:	2101      	movs	r1, #1
 146:	4620      	mov	r0, r4
}
 148:	b006      	add	sp, #24
 14a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if ( (ret = GetName(cert, SUBJECT, (int)cert->sigIndex)) < 0)
 14e:	f7ff bffe 	b.w	0 <wc_GetPubX509>
        return BAD_FUNC_ARG;
 152:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 156:	e795      	b.n	84 <wc_GetPubX509+0x84>

Disassembly of section .text.DecodeToKey:

00000000 <DecodeToKey>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36	; 0x24
    int badDate = 0;
   6:	2700      	movs	r7, #0
    if ( (ret = wc_GetPubX509(cert, verify, &badDate)) < 0)
   8:	aa03      	add	r2, sp, #12
{
   a:	4605      	mov	r5, r0
    int badDate = 0;
   c:	9703      	str	r7, [sp, #12]
    if ( (ret = wc_GetPubX509(cert, verify, &badDate)) < 0)
   e:	f7ff fffe 	bl	0 <DecodeToKey>
  12:	1e04      	subs	r4, r0, #0
  14:	db18      	blt.n	48 <DecodeToKey+0x48>
        cert->selfSigned = XMEMCMP(cert->issuerHash, cert->subjectHash,
  16:	2214      	movs	r2, #20
  18:	f105 0138 	add.w	r1, r5, #56	; 0x38
  1c:	f105 004c 	add.w	r0, r5, #76	; 0x4c
  20:	f7ff fffe 	bl	0 <memcmp>
  24:	f895 3356 	ldrb.w	r3, [r5, #854]	; 0x356
    ret = GetCertKey(cert, cert->source, &cert->srcIdx, cert->maxIdx);
  28:	f8d5 6274 	ldr.w	r6, [r5, #628]	; 0x274
            KEYID_SIZE) == 0 ? 1 : 0;
  2c:	fab0 f080 	clz	r0, r0
  30:	0940      	lsrs	r0, r0, #5
        cert->selfSigned = XMEMCMP(cert->issuerHash, cert->subjectHash,
  32:	f360 0341 	bfi	r3, r0, #1, #1
  36:	f885 3356 	strb.w	r3, [r5, #854]	; 0x356
    word32 srcIdx = *inOutIdx;
  3a:	e9d5 b39e 	ldrd	fp, r3, [r5, #632]	; 0x278
  3e:	f8cd b010 	str.w	fp, [sp, #16]
    if (source == NULL) {
  42:	b92e      	cbnz	r6, 50 <DecodeToKey+0x50>
        return ASN_PARSE_E;
  44:	f06f 048b 	mvn.w	r4, #139	; 0x8b
}
  48:	4620      	mov	r0, r4
  4a:	b009      	add	sp, #36	; 0x24
  4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (GetSequence(source, &srcIdx, &length, maxIdx) < 0)
  50:	aa05      	add	r2, sp, #20
  52:	a904      	add	r1, sp, #16
  54:	4630      	mov	r0, r6
  56:	f7ff fffe 	bl	0 <DecodeToKey>
  5a:	2800      	cmp	r0, #0
  5c:	dbf2      	blt.n	44 <DecodeToKey+0x44>
    pubLen = (int)srcIdx - pubIdx + length;
  5e:	e9dd 4a04 	ldrd	r4, sl, [sp, #16]
    maxIdx = srcIdx + (word32)length;
  62:	eb0a 0904 	add.w	r9, sl, r4
    if (GetAlgoId(source, &srcIdx, &cert->keyOID, oidKeyType, maxIdx) < 0) {
  66:	f8cd 9000 	str.w	r9, [sp]
  6a:	2302      	movs	r3, #2
  6c:	f105 021c 	add.w	r2, r5, #28
  70:	a904      	add	r1, sp, #16
  72:	4630      	mov	r0, r6
  74:	f7ff fffe 	bl	0 <DecodeToKey>
  78:	2800      	cmp	r0, #0
  7a:	dbe3      	blt.n	44 <DecodeToKey+0x44>
    switch (cert->keyOID) {
  7c:	69eb      	ldr	r3, [r5, #28]
  7e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  82:	d055      	beq.n	130 <DecodeToKey+0x130>
  84:	f240 2206 	movw	r2, #518	; 0x206
  88:	4293      	cmp	r3, r2
  8a:	d177      	bne.n	17c <DecodeToKey+0x17c>
    localIdx = *srcIdx;
  8c:	9b04      	ldr	r3, [sp, #16]
  8e:	9306      	str	r3, [sp, #24]
    if (GetASNTag(source, &localIdx, &tag, maxIdx) < 0)
  90:	f10d 020b 	add.w	r2, sp, #11
  94:	464b      	mov	r3, r9
  96:	a906      	add	r1, sp, #24
  98:	4630      	mov	r0, r6
  9a:	f7ff fffe 	bl	0 <DecodeToKey>
    pubLen = (int)srcIdx - pubIdx + length;
  9e:	eba4 040b 	sub.w	r4, r4, fp
    if (GetASNTag(source, &localIdx, &tag, maxIdx) < 0)
  a2:	2800      	cmp	r0, #0
            ret = StoreEccKey(cert, source, &srcIdx, maxIdx, source + pubIdx,
  a4:	eb06 080b 	add.w	r8, r6, fp
    pubLen = (int)srcIdx - pubIdx + length;
  a8:	eb04 070a 	add.w	r7, r4, sl
    if (GetASNTag(source, &localIdx, &tag, maxIdx) < 0)
  ac:	da08      	bge.n	c0 <DecodeToKey+0xc0>
        return ASN_PARSE_E;
  ae:	f06f 048b 	mvn.w	r4, #139	; 0x8b
    *inOutIdx = srcIdx;
  b2:	9b04      	ldr	r3, [sp, #16]
  b4:	f8c5 3278 	str.w	r3, [r5, #632]	; 0x278
    if (ret != 0)
  b8:	2c00      	cmp	r4, #0
  ba:	d1c5      	bne.n	48 <DecodeToKey+0x48>
    if (badDate != 0)
  bc:	9c03      	ldr	r4, [sp, #12]
  be:	e7c3      	b.n	48 <DecodeToKey+0x48>
    if (tag != (ASN_SEQUENCE | ASN_CONSTRUCTED)) {
  c0:	f89d 300b 	ldrb.w	r3, [sp, #11]
  c4:	2b30      	cmp	r3, #48	; 0x30
  c6:	d021      	beq.n	10c <DecodeToKey+0x10c>
        if (GetObjectId(source, srcIdx, &cert->pkCurveOID, oidCurveType,
  c8:	f8cd 9000 	str.w	r9, [sp]
  cc:	2303      	movs	r3, #3
  ce:	f505 723f 	add.w	r2, r5, #764	; 0x2fc
  d2:	a904      	add	r1, sp, #16
  d4:	4630      	mov	r0, r6
  d6:	f7ff fffe 	bl	0 <DecodeToKey>
  da:	2800      	cmp	r0, #0
  dc:	dbe7      	blt.n	ae <DecodeToKey+0xae>
        if ((ret = CheckCurve(cert->pkCurveOID)) < 0)
  de:	f8d5 02fc 	ldr.w	r0, [r5, #764]	; 0x2fc
  e2:	f7ff fffe 	bl	0 <DecodeToKey>
  e6:	2800      	cmp	r0, #0
  e8:	db1f      	blt.n	12a <DecodeToKey+0x12a>
        ret = CheckBitString(source, srcIdx, &length, maxIdx, 1, NULL);
  ea:	2301      	movs	r3, #1
  ec:	2200      	movs	r2, #0
  ee:	e9cd 3200 	strd	r3, r2, [sp]
  f2:	a904      	add	r1, sp, #16
  f4:	464b      	mov	r3, r9
  f6:	aa07      	add	r2, sp, #28
  f8:	4630      	mov	r0, r6
  fa:	f7ff fffe 	bl	0 <DecodeToKey>
        if (ret != 0)
  fe:	4604      	mov	r4, r0
 100:	2800      	cmp	r0, #0
 102:	d1d6      	bne.n	b2 <DecodeToKey+0xb2>
        *srcIdx += (word32)length;
 104:	9b04      	ldr	r3, [sp, #16]
 106:	9a07      	ldr	r2, [sp, #28]
 108:	4413      	add	r3, r2
 10a:	9304      	str	r3, [sp, #16]
    publicKey = (byte*)XMALLOC(pubKeyLen, cert->heap, DYNAMIC_TYPE_PUBLIC_KEY);
 10c:	4638      	mov	r0, r7
 10e:	f7ff fffe 	bl	0 <malloc>
    if (publicKey == NULL)
 112:	4604      	mov	r4, r0
 114:	b378      	cbz	r0, 176 <DecodeToKey+0x176>
    XMEMCPY(publicKey, pubKey, pubKeyLen);
 116:	463a      	mov	r2, r7
 118:	4641      	mov	r1, r8
 11a:	f7ff fffe 	bl	0 <memcpy>
    cert->pubKeyStored = 1;
 11e:	2301      	movs	r3, #1
    cert->publicKey = publicKey;
 120:	602c      	str	r4, [r5, #0]
    cert->pubKeySize   = pubKeyLen;
 122:	e9c5 7301 	strd	r7, r3, [r5, #4]
    return 0;
 126:	2400      	movs	r4, #0
 128:	e7c3      	b.n	b2 <DecodeToKey+0xb2>
            return ECC_CURVE_OID_E;
 12a:	f06f 04ab 	mvn.w	r4, #171	; 0xab
 12e:	e7c0      	b.n	b2 <DecodeToKey+0xb2>
    ret = CheckBitString(source, srcIdx, &length, maxIdx, 1, NULL);
 130:	f04f 0801 	mov.w	r8, #1
            cert->pkCurveOID = ED25519k;
 134:	f8c5 32fc 	str.w	r3, [r5, #764]	; 0x2fc
    ret = CheckBitString(source, srcIdx, &length, maxIdx, 1, NULL);
 138:	9701      	str	r7, [sp, #4]
 13a:	f8cd 8000 	str.w	r8, [sp]
 13e:	464b      	mov	r3, r9
 140:	aa07      	add	r2, sp, #28
 142:	a904      	add	r1, sp, #16
 144:	4630      	mov	r0, r6
 146:	f7ff fffe 	bl	0 <DecodeToKey>
    if (ret == 0) {
 14a:	4604      	mov	r4, r0
 14c:	2800      	cmp	r0, #0
 14e:	d1b0      	bne.n	b2 <DecodeToKey+0xb2>
        publicKey = (byte*)XMALLOC((size_t)length, cert->heap,
 150:	9807      	ldr	r0, [sp, #28]
 152:	f7ff fffe 	bl	0 <malloc>
        if (publicKey == NULL) {
 156:	4607      	mov	r7, r0
 158:	b168      	cbz	r0, 176 <DecodeToKey+0x176>
            XMEMCPY(publicKey, &source[*srcIdx], (size_t)length);
 15a:	9904      	ldr	r1, [sp, #16]
 15c:	9a07      	ldr	r2, [sp, #28]
 15e:	4431      	add	r1, r6
 160:	f7ff fffe 	bl	0 <memcpy>
            cert->pubKeySize   = (word32)length;
 164:	9a07      	ldr	r2, [sp, #28]
            *srcIdx += (word32)length;
 166:	9b04      	ldr	r3, [sp, #16]
            cert->publicKey = publicKey;
 168:	602f      	str	r7, [r5, #0]
            *srcIdx += (word32)length;
 16a:	4413      	add	r3, r2
            cert->pubKeyStored = 1;
 16c:	f8c5 8008 	str.w	r8, [r5, #8]
            cert->pubKeySize   = (word32)length;
 170:	606a      	str	r2, [r5, #4]
            *srcIdx += (word32)length;
 172:	9304      	str	r3, [sp, #16]
 174:	e79d      	b.n	b2 <DecodeToKey+0xb2>
            ret = MEMORY_E;
 176:	f06f 047c 	mvn.w	r4, #124	; 0x7c
            break;
 17a:	e79a      	b.n	b2 <DecodeToKey+0xb2>
    switch (cert->keyOID) {
 17c:	f06f 0493 	mvn.w	r4, #147	; 0x93
 180:	e797      	b.n	b2 <DecodeToKey+0xb2>

Disassembly of section .text.AllocDer:

00000000 <AllocDer>:
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	460e      	mov	r6, r1
   6:	4614      	mov	r4, r2
   8:	461f      	mov	r7, r3
    if (pDer) {
   a:	4605      	mov	r5, r0
   c:	b1e8      	cbz	r0, 4a <AllocDer+0x4a>
        switch (type) {
   e:	2a25      	cmp	r2, #37	; 0x25
  10:	bf98      	it	ls
  12:	4b11      	ldrls	r3, [pc, #68]	; (58 <AllocDer+0x58>)
        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);
  14:	f101 0914 	add.w	r9, r1, #20
  18:	4648      	mov	r0, r9
  1a:	bf94      	ite	ls
  1c:	f913 8002 	ldrsbls.w	r8, [r3, r2]
    if (pDer) {
  20:	f04f 0803 	movhi.w	r8, #3
        *pDer = (DerBuffer*)XMALLOC(sizeof(DerBuffer) + length, heap, dynType);
  24:	f7ff fffe 	bl	0 <malloc>
  28:	6028      	str	r0, [r5, #0]
        if (*pDer == NULL) {
  2a:	b188      	cbz	r0, 50 <AllocDer+0x50>
        XMEMSET(*pDer, 0, sizeof(DerBuffer) + length);
  2c:	464a      	mov	r2, r9
  2e:	2100      	movs	r1, #0
  30:	f7ff fffe 	bl	0 <memset>
        der = *pDer;
  34:	6828      	ldr	r0, [r5, #0]
        der->buffer = (byte*)der + sizeof(DerBuffer);
  36:	f100 0314 	add.w	r3, r0, #20
        der->dynType = dynType; /* Cache this for FreeDer */
  3a:	e9c0 4803 	strd	r4, r8, [r0, #12]
        der->heap = heap;
  3e:	6047      	str	r7, [r0, #4]
        der->buffer = (byte*)der + sizeof(DerBuffer);
  40:	6003      	str	r3, [r0, #0]
        der->length = length;
  42:	6086      	str	r6, [r0, #8]
        ret = 0; /* Success */
  44:	2000      	movs	r0, #0
}
  46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    int ret = BAD_FUNC_ARG;
  4a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  4e:	e7fa      	b.n	46 <AllocDer+0x46>
            return MEMORY_E;
  50:	f06f 007c 	mvn.w	r0, #124	; 0x7c
  54:	e7f7      	b.n	46 <AllocDer+0x46>
  56:	bf00      	nop
  58:	00000000 	.word	0x00000000

Disassembly of section .text.FreeDer:

00000000 <FreeDer>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    if (pDer && *pDer)
   2:	4604      	mov	r4, r0
   4:	b150      	cbz	r0, 1c <FreeDer+0x1c>
   6:	6800      	ldr	r0, [r0, #0]
   8:	b140      	cbz	r0, 1c <FreeDer+0x1c>
        if (der->type == PRIVATEKEY_TYPE && der->buffer != NULL) {
   a:	68c3      	ldr	r3, [r0, #12]
   c:	2b01      	cmp	r3, #1
   e:	d006      	beq.n	1e <FreeDer+0x1e>
        der->buffer = NULL;
  10:	2500      	movs	r5, #0
  12:	6005      	str	r5, [r0, #0]
        der->length = 0;
  14:	6085      	str	r5, [r0, #8]
        XFREE(der, der->heap, der->dynType);
  16:	f7ff fffe 	bl	0 <free>
        *pDer = NULL;
  1a:	6025      	str	r5, [r4, #0]
}
  1c:	bd38      	pop	{r3, r4, r5, pc}
        if (der->type == PRIVATEKEY_TYPE && der->buffer != NULL) {
  1e:	6803      	ldr	r3, [r0, #0]
  20:	2b00      	cmp	r3, #0
  22:	d0f5      	beq.n	10 <FreeDer+0x10>
    while (len--) *z++ = 0;
  24:	6882      	ldr	r2, [r0, #8]
  26:	2100      	movs	r1, #0
  28:	441a      	add	r2, r3
  2a:	429a      	cmp	r2, r3
  2c:	d0f0      	beq.n	10 <FreeDer+0x10>
  2e:	f803 1b01 	strb.w	r1, [r3], #1
  32:	e7fa      	b.n	2a <FreeDer+0x2a>

Disassembly of section .text.wc_AllocDer:

00000000 <wc_AllocDer>:
    return AllocDer(pDer, length, type, heap);
   0:	f7ff bffe 	b.w	0 <wc_AllocDer>

Disassembly of section .text.wc_FreeDer:

00000000 <wc_FreeDer>:
    FreeDer(pDer);
   0:	f7ff bffe 	b.w	0 <wc_FreeDer>

Disassembly of section .text.wc_PemGetHeaderFooter:

00000000 <wc_PemGetHeaderFooter>:
    switch (type) {
   0:	2825      	cmp	r0, #37	; 0x25
   2:	d855      	bhi.n	b0 <wc_PemGetHeaderFooter+0xb0>
   4:	e8df f000 	tbb	[pc, r0]
   8:	54542a13 	.word	0x54542a13
   c:	5423131c 	.word	0x5423131c
  10:	2a235454 	.word	0x2a235454
  14:	13383f38 	.word	0x13383f38
  18:	54543131 	.word	0x54543131
  1c:	54544d46 	.word	0x54544d46
  20:	54545454 	.word	0x54545454
  24:	54545454 	.word	0x54545454
  28:	54545454 	.word	0x54545454
  2c:	1354      	.short	0x1354
            if (header) *header = BEGIN_CERT;
  2e:	b109      	cbz	r1, 34 <wc_PemGetHeaderFooter+0x34>
  30:	4b21      	ldr	r3, [pc, #132]	; (b8 <wc_PemGetHeaderFooter+0xb8>)
  32:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_CERT;
  34:	b90a      	cbnz	r2, 3a <wc_PemGetHeaderFooter+0x3a>
            ret = 0;
  36:	2000      	movs	r0, #0
  38:	4770      	bx	lr
            if (footer) *footer = END_CERT;
  3a:	4b20      	ldr	r3, [pc, #128]	; (bc <wc_PemGetHeaderFooter+0xbc>)
  3c:	6013      	str	r3, [r2, #0]
  3e:	e7fa      	b.n	36 <wc_PemGetHeaderFooter+0x36>
            if (header) *header = BEGIN_X509_CRL;
  40:	b109      	cbz	r1, 46 <wc_PemGetHeaderFooter+0x46>
  42:	4b1f      	ldr	r3, [pc, #124]	; (c0 <wc_PemGetHeaderFooter+0xc0>)
  44:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_X509_CRL;
  46:	2a00      	cmp	r2, #0
  48:	d0f5      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  4a:	4b1e      	ldr	r3, [pc, #120]	; (c4 <wc_PemGetHeaderFooter+0xc4>)
  4c:	e7f6      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
            if (header) *header = BEGIN_EC_PRIV;
  4e:	b109      	cbz	r1, 54 <wc_PemGetHeaderFooter+0x54>
  50:	4b1d      	ldr	r3, [pc, #116]	; (c8 <wc_PemGetHeaderFooter+0xc8>)
  52:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_EC_PRIV;
  54:	2a00      	cmp	r2, #0
  56:	d0ee      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  58:	4b1c      	ldr	r3, [pc, #112]	; (cc <wc_PemGetHeaderFooter+0xcc>)
  5a:	e7ef      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
            if (header) *header = BEGIN_RSA_PRIV;
  5c:	b109      	cbz	r1, 62 <wc_PemGetHeaderFooter+0x62>
  5e:	4b1c      	ldr	r3, [pc, #112]	; (d0 <wc_PemGetHeaderFooter+0xd0>)
  60:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_RSA_PRIV;
  62:	2a00      	cmp	r2, #0
  64:	d0e7      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  66:	4b1b      	ldr	r3, [pc, #108]	; (d4 <wc_PemGetHeaderFooter+0xd4>)
  68:	e7e8      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
            if (header) *header = BEGIN_EDDSA_PRIV;
  6a:	b109      	cbz	r1, 70 <wc_PemGetHeaderFooter+0x70>
  6c:	4b1a      	ldr	r3, [pc, #104]	; (d8 <wc_PemGetHeaderFooter+0xd8>)
  6e:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_EDDSA_PRIV;
  70:	2a00      	cmp	r2, #0
  72:	d0e0      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  74:	4b19      	ldr	r3, [pc, #100]	; (dc <wc_PemGetHeaderFooter+0xdc>)
  76:	e7e1      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
            if (header) *header = BEGIN_PUB_KEY;
  78:	b109      	cbz	r1, 7e <wc_PemGetHeaderFooter+0x7e>
  7a:	4b19      	ldr	r3, [pc, #100]	; (e0 <wc_PemGetHeaderFooter+0xe0>)
  7c:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_PUB_KEY;
  7e:	2a00      	cmp	r2, #0
  80:	d0d9      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  82:	4b18      	ldr	r3, [pc, #96]	; (e4 <wc_PemGetHeaderFooter+0xe4>)
  84:	e7da      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
            if (header) *header = BEGIN_RSA_PUB;
  86:	b109      	cbz	r1, 8c <wc_PemGetHeaderFooter+0x8c>
  88:	4b17      	ldr	r3, [pc, #92]	; (e8 <wc_PemGetHeaderFooter+0xe8>)
  8a:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_RSA_PUB;
  8c:	2a00      	cmp	r2, #0
  8e:	d0d2      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  90:	4b16      	ldr	r3, [pc, #88]	; (ec <wc_PemGetHeaderFooter+0xec>)
  92:	e7d3      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
            if (header) *header = BEGIN_PRIV_KEY;
  94:	b109      	cbz	r1, 9a <wc_PemGetHeaderFooter+0x9a>
  96:	4b16      	ldr	r3, [pc, #88]	; (f0 <wc_PemGetHeaderFooter+0xf0>)
  98:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_PRIV_KEY;
  9a:	2a00      	cmp	r2, #0
  9c:	d0cb      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  9e:	4b15      	ldr	r3, [pc, #84]	; (f4 <wc_PemGetHeaderFooter+0xf4>)
  a0:	e7cc      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
            if (header) *header = BEGIN_ENC_PRIV_KEY;
  a2:	b109      	cbz	r1, a8 <wc_PemGetHeaderFooter+0xa8>
  a4:	4b14      	ldr	r3, [pc, #80]	; (f8 <wc_PemGetHeaderFooter+0xf8>)
  a6:	600b      	str	r3, [r1, #0]
            if (footer) *footer = END_ENC_PRIV_KEY;
  a8:	2a00      	cmp	r2, #0
  aa:	d0c4      	beq.n	36 <wc_PemGetHeaderFooter+0x36>
  ac:	4b13      	ldr	r3, [pc, #76]	; (fc <wc_PemGetHeaderFooter+0xfc>)
  ae:	e7c5      	b.n	3c <wc_PemGetHeaderFooter+0x3c>
    switch (type) {
  b0:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  b4:	4770      	bx	lr
  b6:	bf00      	nop
  b8:	00000000 	.word	0x00000000
  bc:	0000001c 	.word	0x0000001c
  c0:	00000036 	.word	0x00000036
  c4:	0000004f 	.word	0x0000004f
  c8:	00000066 	.word	0x00000066
  cc:	00000085 	.word	0x00000085
  d0:	000000a2 	.word	0x000000a2
  d4:	000000c2 	.word	0x000000c2
  d8:	000000e0 	.word	0x000000e0
  dc:	00000102 	.word	0x00000102
  e0:	00000122 	.word	0x00000122
  e4:	0000013d 	.word	0x0000013d
  e8:	00000156 	.word	0x00000156
  ec:	00000175 	.word	0x00000175
  f0:	00000192 	.word	0x00000192
  f4:	000001ae 	.word	0x000001ae
  f8:	000001c8 	.word	0x000001c8
  fc:	000001ee 	.word	0x000001ee

Disassembly of section .text.PemToDer:

00000000 <PemToDer>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4615      	mov	r5, r2
   6:	b087      	sub	sp, #28
   8:	4607      	mov	r7, r0
   a:	460e      	mov	r6, r1
   c:	4698      	mov	r8, r3
    ret = wc_PemGetHeaderFooter(type, &header, &footer);
   e:	aa03      	add	r2, sp, #12
    const char* header      = NULL;
  10:	2300      	movs	r3, #0
    ret = wc_PemGetHeaderFooter(type, &header, &footer);
  12:	a902      	add	r1, sp, #8
  14:	4628      	mov	r0, r5
    const char* footer      = NULL;
  16:	e9cd 3302 	strd	r3, r3, [sp, #8]
{
  1a:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
    word32      algId = 0;
  1e:	9304      	str	r3, [sp, #16]
    ret = wc_PemGetHeaderFooter(type, &header, &footer);
  20:	f7ff fffe 	bl	0 <PemToDer>
    if (ret != 0)
  24:	4604      	mov	r4, r0
  26:	2800      	cmp	r0, #0
  28:	f040 80bd 	bne.w	1a6 <PemToDer+0x1a6>
            if (header == BEGIN_PUB_KEY) {
  2c:	f8df 9180 	ldr.w	r9, [pc, #384]	; 1b0 <PemToDer+0x1b0>
        headerEnd = XSTRNSTR((char*)buff, header, sz);
  30:	9902      	ldr	r1, [sp, #8]
  32:	4632      	mov	r2, r6
  34:	4638      	mov	r0, r7
  36:	f7ff fffe 	bl	0 <mystrnstr>
        if (headerEnd) {
  3a:	4683      	mov	fp, r0
  3c:	2800      	cmp	r0, #0
  3e:	f040 8088 	bne.w	152 <PemToDer+0x152>
        if (type == PRIVATEKEY_TYPE) {
  42:	2d01      	cmp	r5, #1
  44:	4b5b      	ldr	r3, [pc, #364]	; (1b4 <PemToDer+0x1b4>)
  46:	d120      	bne.n	8a <PemToDer+0x8a>
            if (header == BEGIN_RSA_PRIV) {
  48:	495b      	ldr	r1, [pc, #364]	; (1b8 <PemToDer+0x1b8>)
  4a:	9a02      	ldr	r2, [sp, #8]
  4c:	428a      	cmp	r2, r1
  4e:	495b      	ldr	r1, [pc, #364]	; (1bc <PemToDer+0x1bc>)
  50:	d103      	bne.n	5a <PemToDer+0x5a>
                footer = END_PRIV_KEY;
  52:	4a5b      	ldr	r2, [pc, #364]	; (1c0 <PemToDer+0x1c0>)
                header = BEGIN_PRIV_KEY;
  54:	9102      	str	r1, [sp, #8]
                footer = END_EDDSA_PRIV;
  56:	9203      	str	r2, [sp, #12]
  58:	e7ea      	b.n	30 <PemToDer+0x30>
            else if (header == BEGIN_PRIV_KEY) {
  5a:	428a      	cmp	r2, r1
  5c:	4959      	ldr	r1, [pc, #356]	; (1c4 <PemToDer+0x1c4>)
  5e:	d102      	bne.n	66 <PemToDer+0x66>
                footer = END_ENC_PRIV_KEY;
  60:	4a59      	ldr	r2, [pc, #356]	; (1c8 <PemToDer+0x1c8>)
                header = BEGIN_ENC_PRIV_KEY;
  62:	9102      	str	r1, [sp, #8]
                footer = END_ENC_PRIV_KEY;
  64:	e7f7      	b.n	56 <PemToDer+0x56>
            else if (header == BEGIN_ENC_PRIV_KEY) {
  66:	428a      	cmp	r2, r1
  68:	4958      	ldr	r1, [pc, #352]	; (1cc <PemToDer+0x1cc>)
  6a:	d102      	bne.n	72 <PemToDer+0x72>
                footer = END_EC_PRIV;
  6c:	4a58      	ldr	r2, [pc, #352]	; (1d0 <PemToDer+0x1d0>)
                header = BEGIN_EC_PRIV;
  6e:	9102      	str	r1, [sp, #8]
                footer = END_EC_PRIV;
  70:	e7f1      	b.n	56 <PemToDer+0x56>
            else if (header == BEGIN_EC_PRIV) {
  72:	428a      	cmp	r2, r1
  74:	4957      	ldr	r1, [pc, #348]	; (1d4 <PemToDer+0x1d4>)
  76:	d102      	bne.n	7e <PemToDer+0x7e>
                footer = END_DSA_PRIV;
  78:	4a57      	ldr	r2, [pc, #348]	; (1d8 <PemToDer+0x1d8>)
                header = BEGIN_DSA_PRIV;
  7a:	9102      	str	r1, [sp, #8]
                footer = END_DSA_PRIV;
  7c:	e7eb      	b.n	56 <PemToDer+0x56>
            else if (header == BEGIN_DSA_PRIV) {
  7e:	428a      	cmp	r2, r1
  80:	d162      	bne.n	148 <PemToDer+0x148>
                header = BEGIN_EDDSA_PRIV;
  82:	4a56      	ldr	r2, [pc, #344]	; (1dc <PemToDer+0x1dc>)
  84:	9202      	str	r2, [sp, #8]
                footer = END_EDDSA_PRIV;
  86:	4a56      	ldr	r2, [pc, #344]	; (1e0 <PemToDer+0x1e0>)
  88:	e7e5      	b.n	56 <PemToDer+0x56>
        else if (type == PUBLICKEY_TYPE) {
  8a:	2d0c      	cmp	r5, #12
  8c:	d15c      	bne.n	148 <PemToDer+0x148>
            if (header == BEGIN_PUB_KEY) {
  8e:	9a02      	ldr	r2, [sp, #8]
  90:	454a      	cmp	r2, r9
  92:	d159      	bne.n	148 <PemToDer+0x148>
                header = BEGIN_RSA_PUB;
  94:	4a53      	ldr	r2, [pc, #332]	; (1e4 <PemToDer+0x1e4>)
                footer = END_RSA_PUB;
  96:	e9cd 2302 	strd	r2, r3, [sp, #8]
  9a:	e7c9      	b.n	30 <PemToDer+0x30>
            info->consumed = longSz; /* No more certs if no footer */
  9c:	9b11      	ldr	r3, [sp, #68]	; 0x44
  9e:	601e      	str	r6, [r3, #0]
  a0:	e07f      	b.n	1a2 <PemToDer+0x1a2>
  a2:	9001      	str	r0, [sp, #4]
    consumedEnd = footerEnd + XSTRLEN(footer);
  a4:	9803      	ldr	r0, [sp, #12]
  a6:	f7ff fffe 	bl	0 <strlen>
  aa:	9901      	ldr	r1, [sp, #4]
  ac:	180a      	adds	r2, r1, r0
    if (consumedEnd < bufferEnd) { /* handle no end of line on last line */
  ae:	4591      	cmp	r9, r2
  b0:	d915      	bls.n	de <PemToDer+0xde>
  b2:	4610      	mov	r0, r2
              (line[0] == '\r' || line[0] == '\n')) {
  b4:	f890 c000 	ldrb.w	ip, [r0]
    while (line < endOfLine &&
  b8:	f1bc 0f0d 	cmp.w	ip, #13
  bc:	4602      	mov	r2, r0
  be:	f100 0001 	add.w	r0, r0, #1
  c2:	d009      	beq.n	d8 <PemToDer+0xd8>
              (line[0] == '\r' || line[0] == '\n')) {
  c4:	f1bc 0f0a 	cmp.w	ip, #10
  c8:	d006      	beq.n	d8 <PemToDer+0xd8>
        if (consumedEnd < bufferEnd && consumedEnd[0] == '\0')
  ca:	4591      	cmp	r9, r2
  cc:	d907      	bls.n	de <PemToDer+0xde>
            consumedEnd++;
  ce:	f1bc 0f00 	cmp.w	ip, #0
  d2:	bf08      	it	eq
  d4:	4602      	moveq	r2, r0
  d6:	e002      	b.n	de <PemToDer+0xde>
    while (line < endOfLine &&
  d8:	4548      	cmp	r0, r9
        line++;
  da:	4602      	mov	r2, r0
    while (line < endOfLine &&
  dc:	d1ea      	bne.n	b4 <PemToDer+0xb4>
    if (info)
  de:	9b11      	ldr	r3, [sp, #68]	; 0x44
  e0:	b10b      	cbz	r3, e6 <PemToDer+0xe6>
        info->consumed = (long)(consumedEnd - (const char*)buff);
  e2:	1bd2      	subs	r2, r2, r7
  e4:	601a      	str	r2, [r3, #0]
    neededSz = (long)(footerEnd - headerEnd);
  e6:	eba1 070b 	sub.w	r7, r1, fp
    if (neededSz > (long)sz || neededSz <= 0)
  ea:	42be      	cmp	r6, r7
  ec:	db59      	blt.n	1a2 <PemToDer+0x1a2>
  ee:	2f00      	cmp	r7, #0
  f0:	dd57      	ble.n	1a2 <PemToDer+0x1a2>
    ret = AllocDer(pDer, (word32)neededSz, type, heap);
  f2:	462a      	mov	r2, r5
  f4:	9b10      	ldr	r3, [sp, #64]	; 0x40
  f6:	4639      	mov	r1, r7
  f8:	4640      	mov	r0, r8
  fa:	f7ff fffe 	bl	0 <PemToDer>
    if (ret < 0) {
  fe:	1e05      	subs	r5, r0, #0
 100:	db25      	blt.n	14e <PemToDer+0x14e>
    der = *pDer;
 102:	f8d8 6000 	ldr.w	r6, [r8]
    if (Base64_Decode((byte*)headerEnd, (word32)neededSz,
 106:	4639      	mov	r1, r7
 108:	6832      	ldr	r2, [r6, #0]
 10a:	f106 0308 	add.w	r3, r6, #8
 10e:	4658      	mov	r0, fp
 110:	f7ff fffe 	bl	0 <Base64_Decode>
 114:	2800      	cmp	r0, #0
 116:	db44      	blt.n	1a2 <PemToDer+0x1a2>
    if ((header == BEGIN_PRIV_KEY
 118:	9b02      	ldr	r3, [sp, #8]
 11a:	4a28      	ldr	r2, [pc, #160]	; (1bc <PemToDer+0x1bc>)
 11c:	4293      	cmp	r3, r2
 11e:	d002      	beq.n	126 <PemToDer+0x126>
         || header == BEGIN_EC_PRIV
 120:	4a2a      	ldr	r2, [pc, #168]	; (1cc <PemToDer+0x1cc>)
 122:	4293      	cmp	r3, r2
 124:	d113      	bne.n	14e <PemToDer+0x14e>
        idx = 0;
 126:	2300      	movs	r3, #0
 128:	9305      	str	r3, [sp, #20]
        ret = ToTraditionalInline_ex(der->buffer, &idx, der->length, &algId);
 12a:	68b2      	ldr	r2, [r6, #8]
 12c:	6830      	ldr	r0, [r6, #0]
 12e:	ab04      	add	r3, sp, #16
 130:	a905      	add	r1, sp, #20
 132:	f7ff fffe 	bl	0 <PemToDer>
        if (ret > 0) {
 136:	2800      	cmp	r0, #0
 138:	dd35      	ble.n	1a6 <PemToDer+0x1a6>
            if (keyFormat)
 13a:	f1ba 0f00 	cmp.w	sl, #0
 13e:	d032      	beq.n	1a6 <PemToDer+0x1a6>
                *keyFormat = (int)algId;
 140:	9b04      	ldr	r3, [sp, #16]
 142:	f8ca 3000 	str.w	r3, [sl]
 146:	e02e      	b.n	1a6 <PemToDer+0x1a6>
        return ASN_NO_PEM_HEADER;
 148:	f06f 04a1 	mvn.w	r4, #161	; 0xa1
 14c:	e02b      	b.n	1a6 <PemToDer+0x1a6>
 14e:	462c      	mov	r4, r5
 150:	e029      	b.n	1a6 <PemToDer+0x1a6>
        headerEnd += XSTRLEN(header);
 152:	9802      	ldr	r0, [sp, #8]
 154:	f7ff fffe 	bl	0 <strlen>
    const char* bufferEnd   = (const char*)(buff + longSz);
 158:	eb07 0906 	add.w	r9, r7, r6
        headerEnd += XSTRLEN(header);
 15c:	4458      	add	r0, fp
    while (line < endOfLine &&
 15e:	4581      	cmp	r9, r0
 160:	4683      	mov	fp, r0
 162:	d905      	bls.n	170 <PemToDer+0x170>
              (line[0] == '\r' || line[0] == '\n')) {
 164:	f810 2b01 	ldrb.w	r2, [r0], #1
    while (line < endOfLine &&
 168:	2a0d      	cmp	r2, #13
 16a:	d0f8      	beq.n	15e <PemToDer+0x15e>
              (line[0] == '\r' || line[0] == '\n')) {
 16c:	2a0a      	cmp	r2, #10
 16e:	d0f6      	beq.n	15e <PemToDer+0x15e>
    if (keyFormat) {
 170:	f1ba 0f00 	cmp.w	sl, #0
 174:	d009      	beq.n	18a <PemToDer+0x18a>
        if (type == PRIVATEKEY_TYPE) {
 176:	2d01      	cmp	r5, #1
 178:	d107      	bne.n	18a <PemToDer+0x18a>
            if (header == BEGIN_EC_PRIV)
 17a:	4a14      	ldr	r2, [pc, #80]	; (1cc <PemToDer+0x1cc>)
 17c:	9902      	ldr	r1, [sp, #8]
 17e:	4291      	cmp	r1, r2
                *keyFormat = ECDSAk;
 180:	bf04      	itt	eq
 182:	f240 2206 	movweq	r2, #518	; 0x206
 186:	f8ca 2000 	streq.w	r2, [sl]
    footerEnd = XSTRNSTR(headerEnd, footer, (unsigned int)((char*)buff +
 18a:	9903      	ldr	r1, [sp, #12]
 18c:	eba9 020b 	sub.w	r2, r9, fp
 190:	4658      	mov	r0, fp
 192:	f7ff fffe 	bl	0 <mystrnstr>
    if (!footerEnd) {
 196:	2800      	cmp	r0, #0
 198:	d183      	bne.n	a2 <PemToDer+0xa2>
        if (info)
 19a:	9b11      	ldr	r3, [sp, #68]	; 0x44
 19c:	2b00      	cmp	r3, #0
 19e:	f47f af7d 	bne.w	9c <PemToDer+0x9c>
        return BUFFER_E;
 1a2:	f06f 0483 	mvn.w	r4, #131	; 0x83
}
 1a6:	4620      	mov	r0, r4
 1a8:	b007      	add	sp, #28
 1aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1ae:	bf00      	nop
 1b0:	00000122 	.word	0x00000122
 1b4:	00000175 	.word	0x00000175
 1b8:	000000a2 	.word	0x000000a2
 1bc:	00000192 	.word	0x00000192
 1c0:	000001ae 	.word	0x000001ae
 1c4:	000001c8 	.word	0x000001c8
 1c8:	000001ee 	.word	0x000001ee
 1cc:	00000066 	.word	0x00000066
 1d0:	00000085 	.word	0x00000085
 1d4:	00000000 	.word	0x00000000
 1d8:	00000020 	.word	0x00000020
 1dc:	000000e0 	.word	0x000000e0
 1e0:	00000102 	.word	0x00000102
 1e4:	00000156 	.word	0x00000156

Disassembly of section .text.wc_PemToDer:

00000000 <wc_PemToDer>:
{
   0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    int ret = PemToDer(buff, longSz, type, pDer, heap, info, keyFormat);
   2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   4:	9402      	str	r4, [sp, #8]
   6:	9c09      	ldr	r4, [sp, #36]	; 0x24
   8:	9401      	str	r4, [sp, #4]
   a:	9c08      	ldr	r4, [sp, #32]
   c:	9400      	str	r4, [sp, #0]
{
   e:	4616      	mov	r6, r2
  10:	461d      	mov	r5, r3
    int ret = PemToDer(buff, longSz, type, pDer, heap, info, keyFormat);
  12:	f7ff fffe 	bl	0 <wc_PemToDer>
    if (ret == 0 && type == PRIVATEKEY_TYPE) {
  16:	4604      	mov	r4, r0
  18:	b948      	cbnz	r0, 2e <wc_PemToDer+0x2e>
  1a:	2e01      	cmp	r6, #1
  1c:	d107      	bne.n	2e <wc_PemToDer+0x2e>
        DerBuffer* der = *pDer;
  1e:	682d      	ldr	r5, [r5, #0]
        ret = ToTraditional(der->buffer, der->length);
  20:	68a9      	ldr	r1, [r5, #8]
  22:	6828      	ldr	r0, [r5, #0]
  24:	f7ff fffe 	bl	0 <wc_PemToDer>
        if (ret > 0) {
  28:	2800      	cmp	r0, #0
            der->length = (word32)ret;
  2a:	bfc8      	it	gt
  2c:	60a8      	strgt	r0, [r5, #8]
}
  2e:	4620      	mov	r0, r4
  30:	b004      	add	sp, #16
  32:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.wc_KeyPemToDer:

00000000 <wc_KeyPemToDer>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	b086      	sub	sp, #24
   6:	461f      	mov	r7, r3
    DerBuffer* der = NULL;
   8:	2300      	movs	r3, #0
{
   a:	4688      	mov	r8, r1
   c:	4615      	mov	r5, r2
    DerBuffer* der = NULL;
   e:	9305      	str	r3, [sp, #20]
    if (pem == NULL || (buff != NULL && buffSz <= 0)) {
  10:	4604      	mov	r4, r0
  12:	b398      	cbz	r0, 7c <wc_KeyPemToDer+0x7c>
  14:	b10a      	cbz	r2, 1a <wc_KeyPemToDer+0x1a>
  16:	429f      	cmp	r7, r3
  18:	dd30      	ble.n	7c <wc_KeyPemToDer+0x7c>
    info = (EncryptedInfo*)XMALLOC(sizeof(EncryptedInfo), NULL,
  1a:	2004      	movs	r0, #4
  1c:	f7ff fffe 	bl	0 <malloc>
  20:	4606      	mov	r6, r0
    if (info == NULL)
  22:	b370      	cbz	r0, 82 <wc_KeyPemToDer+0x82>
    XMEMSET(info, 0, sizeof(EncryptedInfo));
  24:	2204      	movs	r2, #4
  26:	2100      	movs	r1, #0
  28:	f7ff fffe 	bl	0 <memset>
    ret = PemToDer(pem, pemSz, PRIVATEKEY_TYPE, &der, NULL, info, NULL);
  2c:	2300      	movs	r3, #0
  2e:	e9cd 6301 	strd	r6, r3, [sp, #4]
  32:	9300      	str	r3, [sp, #0]
  34:	2201      	movs	r2, #1
  36:	ab05      	add	r3, sp, #20
  38:	4641      	mov	r1, r8
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <wc_KeyPemToDer>
  40:	4604      	mov	r4, r0
    XFREE(info, NULL, DYNAMIC_TYPE_ENCRYPTEDINFO);
  42:	4630      	mov	r0, r6
  44:	f7ff fffe 	bl	0 <free>
    if (ret < 0 || der == NULL) {
  48:	2c00      	cmp	r4, #0
  4a:	db04      	blt.n	56 <wc_KeyPemToDer+0x56>
  4c:	9b05      	ldr	r3, [sp, #20]
  4e:	b113      	cbz	r3, 56 <wc_KeyPemToDer+0x56>
        ret = (int)der->length;
  50:	689a      	ldr	r2, [r3, #8]
    else if (buff == NULL) {
  52:	b93d      	cbnz	r5, 64 <wc_KeyPemToDer+0x64>
        ret = (int)der->length;
  54:	4614      	mov	r4, r2
    FreeDer(&der);
  56:	a805      	add	r0, sp, #20
  58:	f7ff fffe 	bl	0 <wc_KeyPemToDer>
}
  5c:	4620      	mov	r0, r4
  5e:	b006      	add	sp, #24
  60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if (der->length <= (word32)buffSz) {
  64:	4297      	cmp	r7, r2
  66:	d306      	bcc.n	76 <wc_KeyPemToDer+0x76>
        XMEMCPY(buff, der->buffer, der->length);
  68:	6819      	ldr	r1, [r3, #0]
  6a:	4628      	mov	r0, r5
  6c:	f7ff fffe 	bl	0 <memcpy>
        ret = (int)der->length;
  70:	9b05      	ldr	r3, [sp, #20]
  72:	689c      	ldr	r4, [r3, #8]
  74:	e7ef      	b.n	56 <wc_KeyPemToDer+0x56>
        ret = BAD_FUNC_ARG;
  76:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  7a:	e7ec      	b.n	56 <wc_KeyPemToDer+0x56>
        return BAD_FUNC_ARG;
  7c:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  80:	e7ec      	b.n	5c <wc_KeyPemToDer+0x5c>
        return MEMORY_E;
  82:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  86:	e7e9      	b.n	5c <wc_KeyPemToDer+0x5c>

Disassembly of section .text.wc_CertPemToDer:

00000000 <wc_CertPemToDer>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b086      	sub	sp, #24
   4:	461e      	mov	r6, r3
    DerBuffer* der = NULL;
   6:	2300      	movs	r3, #0
{
   8:	4615      	mov	r5, r2
    DerBuffer* der = NULL;
   a:	9305      	str	r3, [sp, #20]
{
   c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    if (pem == NULL || buff == NULL || buffSz <= 0) {
   e:	b330      	cbz	r0, 5e <wc_CertPemToDer+0x5e>
  10:	b32d      	cbz	r5, 5e <wc_CertPemToDer+0x5e>
  12:	429e      	cmp	r6, r3
  14:	dd23      	ble.n	5e <wc_CertPemToDer+0x5e>
    if (type != CERT_TYPE && type != CHAIN_CERT_TYPE && type != CA_TYPE &&
  16:	f032 0308 	bics.w	r3, r2, #8
  1a:	d003      	beq.n	24 <wc_CertPemToDer+0x24>
  1c:	f022 0320 	bic.w	r3, r2, #32
  20:	2b05      	cmp	r3, #5
  22:	d11c      	bne.n	5e <wc_CertPemToDer+0x5e>
    ret = PemToDer(pem, pemSz, type, &der, NULL, NULL, NULL);
  24:	2300      	movs	r3, #0
  26:	e9cd 3301 	strd	r3, r3, [sp, #4]
  2a:	9300      	str	r3, [sp, #0]
  2c:	ab05      	add	r3, sp, #20
  2e:	f7ff fffe 	bl	0 <wc_CertPemToDer>
    if (ret < 0 || der == NULL) {
  32:	1e04      	subs	r4, r0, #0
  34:	db0a      	blt.n	4c <wc_CertPemToDer+0x4c>
  36:	9b05      	ldr	r3, [sp, #20]
  38:	b143      	cbz	r3, 4c <wc_CertPemToDer+0x4c>
        if (der->length <= (word32)buffSz) {
  3a:	689a      	ldr	r2, [r3, #8]
  3c:	42b2      	cmp	r2, r6
  3e:	d80b      	bhi.n	58 <wc_CertPemToDer+0x58>
            XMEMCPY(buff, der->buffer, der->length);
  40:	6819      	ldr	r1, [r3, #0]
  42:	4628      	mov	r0, r5
  44:	f7ff fffe 	bl	0 <memcpy>
            ret = (int)der->length;
  48:	9b05      	ldr	r3, [sp, #20]
  4a:	689c      	ldr	r4, [r3, #8]
    FreeDer(&der);
  4c:	a805      	add	r0, sp, #20
  4e:	f7ff fffe 	bl	0 <wc_CertPemToDer>
}
  52:	4620      	mov	r0, r4
  54:	b006      	add	sp, #24
  56:	bd70      	pop	{r4, r5, r6, pc}
            ret = BAD_FUNC_ARG;
  58:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  5c:	e7f6      	b.n	4c <wc_CertPemToDer+0x4c>
        return BAD_FUNC_ARG;
  5e:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  62:	e7f6      	b.n	52 <wc_CertPemToDer+0x52>

Disassembly of section .text.wc_GetPubKeyDerFromCert:

00000000 <wc_GetPubKeyDerFromCert>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4605      	mov	r5, r0
   4:	4614      	mov	r4, r2
   6:	4608      	mov	r0, r1
    if (cert == NULL || derKeySz == NULL ||
   8:	b155      	cbz	r5, 20 <wc_GetPubKeyDerFromCert+0x20>
   a:	b14a      	cbz	r2, 20 <wc_GetPubKeyDerFromCert+0x20>
   c:	b109      	cbz	r1, 12 <wc_GetPubKeyDerFromCert+0x12>
        (derKey != NULL && *derKeySz == 0)) {
   e:	6813      	ldr	r3, [r2, #0]
  10:	b133      	cbz	r3, 20 <wc_GetPubKeyDerFromCert+0x20>
    if (cert->publicKey == NULL) {
  12:	6829      	ldr	r1, [r5, #0]
  14:	b121      	cbz	r1, 20 <wc_GetPubKeyDerFromCert+0x20>
        if (cert->pubKeySize > *derKeySz) {
  16:	686a      	ldr	r2, [r5, #4]
    if (derKey == NULL) {
  18:	b128      	cbz	r0, 26 <wc_GetPubKeyDerFromCert+0x26>
        if (cert->pubKeySize > *derKeySz) {
  1a:	6823      	ldr	r3, [r4, #0]
  1c:	4293      	cmp	r3, r2
  1e:	d206      	bcs.n	2e <wc_GetPubKeyDerFromCert+0x2e>
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  24:	e002      	b.n	2c <wc_GetPubKeyDerFromCert+0x2c>
        *derKeySz = cert->pubKeySize;
  26:	6022      	str	r2, [r4, #0]
        ret = LENGTH_ONLY_E;
  28:	f06f 00c9 	mvn.w	r0, #201	; 0xc9
}
  2c:	bd38      	pop	{r3, r4, r5, pc}
            XMEMCPY(derKey, cert->publicKey, cert->pubKeySize);
  2e:	f7ff fffe 	bl	0 <memcpy>
            *derKeySz = cert->pubKeySize;
  32:	686b      	ldr	r3, [r5, #4]
  34:	6023      	str	r3, [r4, #0]
    int ret = 0;
  36:	2000      	movs	r0, #0
  38:	e7f8      	b.n	2c <wc_GetPubKeyDerFromCert+0x2c>

Disassembly of section .text.StoreECC_DSA_Sig:

00000000 <StoreECC_DSA_Sig>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4680      	mov	r8, r0
    int rLeadingZero = mp_leading_bit(r);
   6:	4610      	mov	r0, r2
{
   8:	461f      	mov	r7, r3
   a:	460e      	mov	r6, r1
   c:	4691      	mov	r9, r2
    int rLeadingZero = mp_leading_bit(r);
   e:	f7ff fffe 	bl	0 <mp_leading_bit>
  12:	4605      	mov	r5, r0
    int sLeadingZero = mp_leading_bit(s);
  14:	4638      	mov	r0, r7
  16:	f7ff fffe 	bl	0 <mp_leading_bit>
  1a:	4604      	mov	r4, r0
    int rLen = mp_unsigned_bin_size(r);   /* big int size */
  1c:	4648      	mov	r0, r9
  1e:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  22:	4682      	mov	sl, r0
    int sLen = mp_unsigned_bin_size(s);
  24:	4638      	mov	r0, r7
  26:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
    if (*outLen < (word32)((rLen + rLeadingZero + sLen + sLeadingZero +
  2a:	4455      	add	r5, sl
  2c:	4405      	add	r5, r0
  2e:	442c      	add	r4, r5
  30:	6833      	ldr	r3, [r6, #0]
  32:	1d20      	adds	r0, r4, #4
            headerSz + 2)))  /* SEQ_TAG + LEN(ENUM) */
  34:	3406      	adds	r4, #6
    if (*outLen < (word32)((rLen + rLeadingZero + sLen + sLeadingZero +
  36:	42a3      	cmp	r3, r4
  38:	d31b      	bcc.n	72 <StoreECC_DSA_Sig+0x72>
    idx = SetSequence((word32)(rLen + rLeadingZero + sLen + sLeadingZero +
  3a:	4641      	mov	r1, r8
  3c:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig>
    rSz = SetASNIntMP(r, (int)(*outLen - idx), &out[idx]);
  40:	6831      	ldr	r1, [r6, #0]
  42:	eb08 0200 	add.w	r2, r8, r0
  46:	1a09      	subs	r1, r1, r0
    idx = SetSequence((word32)(rLen + rLeadingZero + sLen + sLeadingZero +
  48:	4604      	mov	r4, r0
    rSz = SetASNIntMP(r, (int)(*outLen - idx), &out[idx]);
  4a:	4648      	mov	r0, r9
  4c:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig>
    if (rSz < 0)
  50:	2800      	cmp	r0, #0
  52:	db0c      	blt.n	6e <StoreECC_DSA_Sig+0x6e>
    sSz = SetASNIntMP(s, (int)(*outLen - idx), &out[idx]);
  54:	6831      	ldr	r1, [r6, #0]
    idx += (word32)rSz;
  56:	4404      	add	r4, r0
    sSz = SetASNIntMP(s, (int)(*outLen - idx), &out[idx]);
  58:	eb08 0204 	add.w	r2, r8, r4
  5c:	1b09      	subs	r1, r1, r4
  5e:	4638      	mov	r0, r7
  60:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig>
    if (sSz < 0)
  64:	2800      	cmp	r0, #0
  66:	db02      	blt.n	6e <StoreECC_DSA_Sig+0x6e>
    idx += (word32)sSz;
  68:	4420      	add	r0, r4
    *outLen = idx;
  6a:	6030      	str	r0, [r6, #0]
    return 0;
  6c:	2000      	movs	r0, #0
}
  6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return BUFFER_E;
  72:	f06f 0083 	mvn.w	r0, #131	; 0x83
  76:	e7fa      	b.n	6e <StoreECC_DSA_Sig+0x6e>

Disassembly of section .text.StoreECC_DSA_Sig_Bin:

00000000 <StoreECC_DSA_Sig_Bin>:

/* Der Encode r & s ints into out, outLen is (in/out) size */
/* All input/outputs are assumed to be big-endian */
int StoreECC_DSA_Sig_Bin(byte* out, word32* outLen, const byte* r, word32 rLen,
    const byte* s, word32 sLen)
{
   0:	e92d 4fb3 	stmdb	sp!, {r0, r1, r4, r5, r7, r8, r9, sl, fp, lr}
   4:	4688      	mov	r8, r1
   6:	9201      	str	r2, [sp, #4]
   8:	4619      	mov	r1, r3
    int ret;
    word32 idx;
    word32 headerSz = 4;   /* 2*ASN_TAG + 2*LEN(ENUM) */
    word32 rAddLeadZero, sAddLeadZero;

    if ((out == NULL) || (outLen == NULL) || (r == NULL) || (s == NULL))
   a:	4607      	mov	r7, r0
   c:	2800      	cmp	r0, #0
   e:	d05c      	beq.n	ca <StoreECC_DSA_Sig_Bin+0xca>
  10:	f1b8 0f00 	cmp.w	r8, #0
  14:	d059      	beq.n	ca <StoreECC_DSA_Sig_Bin+0xca>
  16:	2a00      	cmp	r2, #0
  18:	d057      	beq.n	ca <StoreECC_DSA_Sig_Bin+0xca>
  1a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  1c:	2b00      	cmp	r3, #0
  1e:	d054      	beq.n	ca <StoreECC_DSA_Sig_Bin+0xca>
        return BAD_FUNC_ARG;

    /* Trim leading zeros */
    rLen = trim_leading_zeros(&r, rLen);
  20:	a801      	add	r0, sp, #4
  22:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig_Bin>
    sLen = trim_leading_zeros(&s, sLen);
  26:	990b      	ldr	r1, [sp, #44]	; 0x2c
    rLen = trim_leading_zeros(&r, rLen);
  28:	4604      	mov	r4, r0
    sLen = trim_leading_zeros(&s, sLen);
  2a:	a80a      	add	r0, sp, #40	; 0x28
  2c:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig_Bin>
  30:	4681      	mov	r9, r0
    if (sz > 0)
  32:	2c00      	cmp	r4, #0
  34:	d045      	beq.n	c2 <StoreECC_DSA_Sig_Bin+0xc2>
        c = input[0];
  36:	9b01      	ldr	r3, [sp, #4]
  38:	781b      	ldrb	r3, [r3, #0]
    return (c & 0x80) != 0;
  3a:	fa4f fb83 	sxtb.w	fp, r3
  3e:	09da      	lsrs	r2, r3, #7
    if (sz > 0)
  40:	f1b9 0f00 	cmp.w	r9, #0
  44:	d03f      	beq.n	c6 <StoreECC_DSA_Sig_Bin+0xc6>
        c = input[0];
  46:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  48:	7819      	ldrb	r1, [r3, #0]
    /* If the leading bit on the INTEGER is a 1, add a leading zero */
    /* Add leading zero if MSB is set */
    rAddLeadZero = is_leading_bit_set(r, rLen);
    sAddLeadZero = is_leading_bit_set(s, sLen);

    if (*outLen < (rLen + rAddLeadZero + sLen + sAddLeadZero +
  4a:	eb04 0309 	add.w	r3, r4, r9
  4e:	4413      	add	r3, r2
  50:	eb03 13d1 	add.w	r3, r3, r1, lsr #7
  54:	f8d8 2000 	ldr.w	r2, [r8]
  58:	1d18      	adds	r0, r3, #4
                   headerSz + 2))  /* SEQ_TAG + LEN(ENUM) */
  5a:	3306      	adds	r3, #6
    if (*outLen < (rLen + rAddLeadZero + sLen + sAddLeadZero +
  5c:	429a      	cmp	r2, r3
    return (c & 0x80) != 0;
  5e:	fa4f fa81 	sxtb.w	sl, r1
    if (*outLen < (rLen + rAddLeadZero + sLen + sAddLeadZero +
  62:	d335      	bcc.n	d0 <StoreECC_DSA_Sig_Bin+0xd0>
        return BUFFER_E;

    idx = SetSequence(rLen+rAddLeadZero + sLen+sAddLeadZero + headerSz, out);
  64:	4639      	mov	r1, r7
  66:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig_Bin>

    /* store r */
    ret = SetASNInt((int)rLen, (byte)(rAddLeadZero ? 0x80U : 0x00U), &out[idx]);
  6a:	f1bb 0f00 	cmp.w	fp, #0
  6e:	eb07 0200 	add.w	r2, r7, r0
  72:	bfb4      	ite	lt
  74:	2180      	movlt	r1, #128	; 0x80
  76:	2100      	movge	r1, #0
    idx = SetSequence(rLen+rAddLeadZero + sLen+sAddLeadZero + headerSz, out);
  78:	4605      	mov	r5, r0
    ret = SetASNInt((int)rLen, (byte)(rAddLeadZero ? 0x80U : 0x00U), &out[idx]);
  7a:	4620      	mov	r0, r4
  7c:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig_Bin>
    if (ret < 0)
  80:	2800      	cmp	r0, #0
  82:	db1b      	blt.n	bc <StoreECC_DSA_Sig_Bin+0xbc>
        return ret;
    idx += (word32)ret;
  84:	4405      	add	r5, r0
    XMEMCPY(&out[idx], r, rLen);
  86:	9901      	ldr	r1, [sp, #4]
  88:	4622      	mov	r2, r4
  8a:	1978      	adds	r0, r7, r5
  8c:	f7ff fffe 	bl	0 <memcpy>
    idx += rLen;
  90:	442c      	add	r4, r5

    /* store s */
    ret = SetASNInt((int)sLen, (byte)(sAddLeadZero ? 0x80U : 0x00U), &out[idx]);
  92:	f1ba 0f00 	cmp.w	sl, #0
  96:	bfb4      	ite	lt
  98:	2180      	movlt	r1, #128	; 0x80
  9a:	2100      	movge	r1, #0
  9c:	193a      	adds	r2, r7, r4
  9e:	4648      	mov	r0, r9
  a0:	f7ff fffe 	bl	0 <StoreECC_DSA_Sig_Bin>
    if (ret < 0)
  a4:	2800      	cmp	r0, #0
  a6:	db09      	blt.n	bc <StoreECC_DSA_Sig_Bin+0xbc>
        return ret;
    idx += (word32)ret;
  a8:	4404      	add	r4, r0
    XMEMCPY(&out[idx], s, sLen);
  aa:	1938      	adds	r0, r7, r4
  ac:	990a      	ldr	r1, [sp, #40]	; 0x28
  ae:	464a      	mov	r2, r9
    idx += sLen;
  b0:	444c      	add	r4, r9
    XMEMCPY(&out[idx], s, sLen);
  b2:	f7ff fffe 	bl	0 <memcpy>

    *outLen = idx;
  b6:	f8c8 4000 	str.w	r4, [r8]

    return 0;
  ba:	2000      	movs	r0, #0
        *outLen = (word32)sz;
    }

    return ret;
#endif /* WOLFSSL_ASN_TEMPLATE */
}
  bc:	b002      	add	sp, #8
  be:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
    byte c = 0;
  c2:	4623      	mov	r3, r4
  c4:	e7b9      	b.n	3a <StoreECC_DSA_Sig_Bin+0x3a>
  c6:	4649      	mov	r1, r9
  c8:	e7bf      	b.n	4a <StoreECC_DSA_Sig_Bin+0x4a>
        return BAD_FUNC_ARG;
  ca:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  ce:	e7f5      	b.n	bc <StoreECC_DSA_Sig_Bin+0xbc>
        return BUFFER_E;
  d0:	f06f 0083 	mvn.w	r0, #131	; 0x83
  d4:	e7f2      	b.n	bc <StoreECC_DSA_Sig_Bin+0xbc>

Disassembly of section .text.DecodeECC_DSA_Sig_Bin:

00000000 <DecodeECC_DSA_Sig_Bin>:

/* Der Decode ECC-DSA Signature with R/S as unsigned bin */
/* All input/outputs are assumed to be big-endian */
int DecodeECC_DSA_Sig_Bin(const byte* sig, word32 sigLen, byte* r, word32* rLen,
    byte* s, word32* sLen)
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4698      	mov	r8, r3
#ifndef WOLFSSL_ASN_TEMPLATE
    int    ret;
    word32 idx = 0;
   6:	2300      	movs	r3, #0
    int    len = 0;
   8:	e9cd 3300 	strd	r3, r3, [sp]
{
   c:	460d      	mov	r5, r1

    if (GetSequence(sig, &idx, &len, sigLen) < 0) {
   e:	460b      	mov	r3, r1
{
  10:	4617      	mov	r7, r2
    if (GetSequence(sig, &idx, &len, sigLen) < 0) {
  12:	4669      	mov	r1, sp
  14:	aa01      	add	r2, sp, #4
{
  16:	e9dd 9a0a 	ldrd	r9, sl, [sp, #40]	; 0x28
  1a:	4606      	mov	r6, r0
    if (GetSequence(sig, &idx, &len, sigLen) < 0) {
  1c:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig_Bin>
  20:	2800      	cmp	r0, #0
  22:	da05      	bge.n	30 <DecodeECC_DSA_Sig_Bin+0x30>
        return ASN_ECC_KEY_E;
  24:	f06f 04aa 	mvn.w	r4, #170	; 0xaa

    /* Decode the DSA signature. */
    return GetASN_Items(dsaSigASN, dataASN, dsaSigASN_Length, 1, sig, &idx,
                        sigLen);
#endif /* WOLFSSL_ASN_TEMPLATE */
}
  28:	4620      	mov	r0, r4
  2a:	b002      	add	sp, #8
  2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (sigLen != idx + (word32)len) {
  30:	e9dd 3200 	ldrd	r3, r2, [sp]
  34:	4413      	add	r3, r2
  36:	42ab      	cmp	r3, r5
  38:	d1f4      	bne.n	24 <DecodeECC_DSA_Sig_Bin+0x24>
    ret = GetASNInt(sig, &idx, &len, sigLen);
  3a:	462b      	mov	r3, r5
  3c:	aa01      	add	r2, sp, #4
  3e:	4669      	mov	r1, sp
  40:	4630      	mov	r0, r6
  42:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig_Bin>
    if (ret != 0)
  46:	4604      	mov	r4, r0
  48:	2800      	cmp	r0, #0
  4a:	d1ed      	bne.n	28 <DecodeECC_DSA_Sig_Bin+0x28>
        *rLen = (word32)len;
  4c:	9a01      	ldr	r2, [sp, #4]
    if (rLen)
  4e:	f1b8 0f00 	cmp.w	r8, #0
  52:	d001      	beq.n	58 <DecodeECC_DSA_Sig_Bin+0x58>
        *rLen = (word32)len;
  54:	f8c8 2000 	str.w	r2, [r8]
    if (r)
  58:	b127      	cbz	r7, 64 <DecodeECC_DSA_Sig_Bin+0x64>
        XMEMCPY(r, (byte*)sig + idx, (size_t)len);
  5a:	9900      	ldr	r1, [sp, #0]
  5c:	4638      	mov	r0, r7
  5e:	4431      	add	r1, r6
  60:	f7ff fffe 	bl	0 <memcpy>
    idx += (word32)len;
  64:	e9dd 3200 	ldrd	r3, r2, [sp]
  68:	4413      	add	r3, r2
  6a:	9300      	str	r3, [sp, #0]
    ret = GetASNInt(sig, &idx, &len, sigLen);
  6c:	aa01      	add	r2, sp, #4
  6e:	462b      	mov	r3, r5
  70:	4669      	mov	r1, sp
  72:	4630      	mov	r0, r6
  74:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig_Bin>
    if (ret != 0)
  78:	4604      	mov	r4, r0
  7a:	2800      	cmp	r0, #0
  7c:	d1d4      	bne.n	28 <DecodeECC_DSA_Sig_Bin+0x28>
        *sLen = (word32)len;
  7e:	9a01      	ldr	r2, [sp, #4]
    if (sLen)
  80:	f1ba 0f00 	cmp.w	sl, #0
  84:	d001      	beq.n	8a <DecodeECC_DSA_Sig_Bin+0x8a>
        *sLen = (word32)len;
  86:	f8ca 2000 	str.w	r2, [sl]
    if (s)
  8a:	f1b9 0f00 	cmp.w	r9, #0
  8e:	d004      	beq.n	9a <DecodeECC_DSA_Sig_Bin+0x9a>
        XMEMCPY(s, (byte*)sig + idx, (size_t)len);
  90:	9900      	ldr	r1, [sp, #0]
  92:	4648      	mov	r0, r9
  94:	4431      	add	r1, r6
  96:	f7ff fffe 	bl	0 <memcpy>
    if (idx + (word32)len != sigLen) {
  9a:	e9dd 3200 	ldrd	r3, r2, [sp]
  9e:	4413      	add	r3, r2
  a0:	42ab      	cmp	r3, r5
  a2:	d0c1      	beq.n	28 <DecodeECC_DSA_Sig_Bin+0x28>
  a4:	e7be      	b.n	24 <DecodeECC_DSA_Sig_Bin+0x24>

Disassembly of section .text.DecodeECC_DSA_Sig_Ex:

00000000 <DecodeECC_DSA_Sig_Ex>:
    return DecodeECC_DSA_Sig_Ex(sig, sigLen, r, s, 1);
}

int DecodeECC_DSA_Sig_Ex(const byte* sig, word32 sigLen, mp_int* r, mp_int* s,
    int init)
{
   0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
#ifndef WOLFSSL_ASN_TEMPLATE
    word32 idx = 0;
   4:	2400      	movs	r4, #0
{
   6:	4689      	mov	r9, r1
   8:	4616      	mov	r6, r2
   a:	461f      	mov	r7, r3
    int    len = 0;

    if (GetSequence(sig, &idx, &len, sigLen) < 0) {
   c:	aa03      	add	r2, sp, #12
   e:	460b      	mov	r3, r1
  10:	a902      	add	r1, sp, #8
    int    len = 0;
  12:	e9cd 4402 	strd	r4, r4, [sp, #8]
{
  16:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
  1a:	4680      	mov	r8, r0
    if (GetSequence(sig, &idx, &len, sigLen) < 0) {
  1c:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig_Ex>
  20:	42a0      	cmp	r0, r4
  22:	da04      	bge.n	2e <DecodeECC_DSA_Sig_Ex+0x2e>
    /* sanity check that the index has been advanced all the way to the end of
     * the buffer */
    if (idx != sigLen) {
        mp_clear(r);
        mp_clear(s);
        return ASN_ECC_KEY_E;
  24:	f06f 00aa 	mvn.w	r0, #170	; 0xaa
        mp_clear(s);
    }

    return ret;
#endif /* WOLFSSL_ASN_TEMPLATE */
}
  28:	b004      	add	sp, #16
  2a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (sigLen != idx + (word32)len) {
  2e:	e9dd 5302 	ldrd	r5, r3, [sp, #8]
  32:	441d      	add	r5, r3
  34:	454d      	cmp	r5, r9
  36:	d1f5      	bne.n	24 <DecodeECC_DSA_Sig_Ex+0x24>
    if (GetIntPositive(r, sig, &idx, sigLen, init) < 0) {
  38:	f8cd a000 	str.w	sl, [sp]
  3c:	462b      	mov	r3, r5
  3e:	aa02      	add	r2, sp, #8
  40:	4641      	mov	r1, r8
  42:	4630      	mov	r0, r6
  44:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig_Ex>
  48:	2800      	cmp	r0, #0
  4a:	dbeb      	blt.n	24 <DecodeECC_DSA_Sig_Ex+0x24>
    if (GetIntPositive(s, sig, &idx, sigLen, init) < 0) {
  4c:	f8cd a000 	str.w	sl, [sp]
  50:	462b      	mov	r3, r5
  52:	aa02      	add	r2, sp, #8
  54:	4641      	mov	r1, r8
  56:	4638      	mov	r0, r7
  58:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig_Ex>
  5c:	2800      	cmp	r0, #0
  5e:	da03      	bge.n	68 <DecodeECC_DSA_Sig_Ex+0x68>
        mp_clear(r);
  60:	4630      	mov	r0, r6
        mp_clear(s);
  62:	f7ff fffe 	bl	0 <mp_clear>
  66:	e7dd      	b.n	24 <DecodeECC_DSA_Sig_Ex+0x24>
    if (idx != sigLen) {
  68:	9b02      	ldr	r3, [sp, #8]
  6a:	42ab      	cmp	r3, r5
  6c:	d004      	beq.n	78 <DecodeECC_DSA_Sig_Ex+0x78>
        mp_clear(r);
  6e:	4630      	mov	r0, r6
  70:	f7ff fffe 	bl	0 <mp_clear>
        mp_clear(s);
  74:	4638      	mov	r0, r7
  76:	e7f4      	b.n	62 <DecodeECC_DSA_Sig_Ex+0x62>
    return 0;
  78:	4620      	mov	r0, r4
  7a:	e7d5      	b.n	28 <DecodeECC_DSA_Sig_Ex+0x28>

Disassembly of section .text.DecodeECC_DSA_Sig:

00000000 <DecodeECC_DSA_Sig>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return DecodeECC_DSA_Sig_Ex(sig, sigLen, r, s, 1);
   2:	2401      	movs	r4, #1
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <DecodeECC_DSA_Sig>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_EccPrivateKeyDecode:

00000000 <wc_EccPrivateKeyDecode>:
#endif

WOLFSSL_ABI
int wc_EccPrivateKeyDecode(const byte* input, word32* inOutIdx, ecc_key* key,
                        word32 inSz)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36	; 0x24
    byte* pub = NULL;
#else
    byte priv[ECC_MAXSIZE+1];
    byte pub[2*(ECC_MAXSIZE+1)]; /* public key has two parts plus header */
#endif
    word32 algId = 0;
   6:	2400      	movs	r4, #0
{
   8:	460d      	mov	r5, r1
   a:	9203      	str	r2, [sp, #12]
   c:	461e      	mov	r6, r3
    word32 algId = 0;
   e:	9407      	str	r4, [sp, #28]
    byte* pubData = NULL;

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)
  10:	4607      	mov	r7, r0
  12:	2800      	cmp	r0, #0
  14:	f000 80c9 	beq.w	1aa <wc_EccPrivateKeyDecode+0x1aa>
  18:	2900      	cmp	r1, #0
  1a:	f000 80c6 	beq.w	1aa <wc_EccPrivateKeyDecode+0x1aa>
  1e:	2a00      	cmp	r2, #0
  20:	f000 80c3 	beq.w	1aa <wc_EccPrivateKeyDecode+0x1aa>
  24:	2e00      	cmp	r6, #0
  26:	f000 80c0 	beq.w	1aa <wc_EccPrivateKeyDecode+0x1aa>
        return BAD_FUNC_ARG;

    /* if has pkcs8 header skip it */
    if (ToTraditionalInline_ex(input, inOutIdx, inSz, &algId) < 0) {
  2a:	ab07      	add	r3, sp, #28
  2c:	4632      	mov	r2, r6
  2e:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
  32:	42a0      	cmp	r0, r4
  34:	db13      	blt.n	5e <wc_EccPrivateKeyDecode+0x5e>
        /* ignore error, did not have pkcs8 header */
    }
    else {
        curve_id = wc_ecc_get_oid(algId, NULL, NULL);
  36:	9807      	ldr	r0, [sp, #28]
  38:	4622      	mov	r2, r4
  3a:	4621      	mov	r1, r4
  3c:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
  40:	4680      	mov	r8, r0
    }

    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
  42:	4633      	mov	r3, r6
  44:	aa06      	add	r2, sp, #24
  46:	4629      	mov	r1, r5
  48:	4638      	mov	r0, r7
  4a:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
  4e:	2800      	cmp	r0, #0
  50:	da07      	bge.n	62 <wc_EccPrivateKeyDecode+0x62>
        return ASN_PARSE_E;
  52:	f06f 048b 	mvn.w	r4, #139	; 0x8b
    }

    FREE_ASNGETDATA(dataASN, key->heap);
    return ret;
#endif
}
  56:	4620      	mov	r0, r4
  58:	b009      	add	sp, #36	; 0x24
  5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    int    curve_id = ECC_CURVE_DEF;
  5e:	46a0      	mov	r8, r4
  60:	e7ef      	b.n	42 <wc_EccPrivateKeyDecode+0x42>
    if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)
  62:	4633      	mov	r3, r6
  64:	aa05      	add	r2, sp, #20
  66:	4629      	mov	r1, r5
  68:	4638      	mov	r0, r7
  6a:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
  6e:	2800      	cmp	r0, #0
  70:	dbef      	blt.n	52 <wc_EccPrivateKeyDecode+0x52>
    if (*inOutIdx >= inSz)
  72:	682b      	ldr	r3, [r5, #0]
  74:	42b3      	cmp	r3, r6
  76:	d2ec      	bcs.n	52 <wc_EccPrivateKeyDecode+0x52>
    b = input[*inOutIdx];
  78:	5cfa      	ldrb	r2, [r7, r3]
    *inOutIdx += 1;
  7a:	3301      	adds	r3, #1
    if (b != 4 && b != 6 && b != 7)
  7c:	2a04      	cmp	r2, #4
    *inOutIdx += 1;
  7e:	602b      	str	r3, [r5, #0]
    if (b != 4 && b != 6 && b != 7)
  80:	d002      	beq.n	88 <wc_EccPrivateKeyDecode+0x88>
  82:	3a06      	subs	r2, #6
  84:	2a01      	cmp	r2, #1
  86:	d8e4      	bhi.n	52 <wc_EccPrivateKeyDecode+0x52>
    if (GetLength(input, inOutIdx, &length, inSz) < 0)
  88:	4633      	mov	r3, r6
  8a:	aa06      	add	r2, sp, #24
  8c:	4629      	mov	r1, r5
  8e:	4638      	mov	r0, r7
  90:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
  94:	2800      	cmp	r0, #0
  96:	dbdc      	blt.n	52 <wc_EccPrivateKeyDecode+0x52>
    privSz = length;
  98:	f8dd a018 	ldr.w	sl, [sp, #24]
    if (privSz > ECC_MAXSIZE)
  9c:	f1ba 0f42 	cmp.w	sl, #66	; 0x42
  a0:	f300 8086 	bgt.w	1b0 <wc_EccPrivateKeyDecode+0x1b0>
    priv = (byte*)XMALLOC(privSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  a4:	4650      	mov	r0, sl
  a6:	f7ff fffe 	bl	0 <malloc>
    if (priv == NULL)
  aa:	4681      	mov	r9, r0
  ac:	2800      	cmp	r0, #0
  ae:	f000 8082 	beq.w	1b6 <wc_EccPrivateKeyDecode+0x1b6>
    XMEMCPY(priv, &input[*inOutIdx], (size_t)privSz);
  b2:	6829      	ldr	r1, [r5, #0]
  b4:	4652      	mov	r2, sl
  b6:	4439      	add	r1, r7
  b8:	f7ff fffe 	bl	0 <memcpy>
    *inOutIdx += (word32)length;
  bc:	682b      	ldr	r3, [r5, #0]
  be:	9a06      	ldr	r2, [sp, #24]
  c0:	4413      	add	r3, r2
    if ((*inOutIdx + 1) < inSz) {
  c2:	1c5a      	adds	r2, r3, #1
  c4:	42b2      	cmp	r2, r6
    *inOutIdx += (word32)length;
  c6:	602b      	str	r3, [r5, #0]
    if ((*inOutIdx + 1) < inSz) {
  c8:	d21a      	bcs.n	100 <wc_EccPrivateKeyDecode+0x100>
        if (b == ECC_PREFIX_0) {
  ca:	5cfb      	ldrb	r3, [r7, r3]
  cc:	2ba0      	cmp	r3, #160	; 0xa0
  ce:	d117      	bne.n	100 <wc_EccPrivateKeyDecode+0x100>
            *inOutIdx += 1;
  d0:	602a      	str	r2, [r5, #0]
            if (GetLength(input, inOutIdx, &length, inSz) <= 0)
  d2:	4633      	mov	r3, r6
  d4:	aa06      	add	r2, sp, #24
  d6:	4629      	mov	r1, r5
  d8:	4638      	mov	r0, r7
  da:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
  de:	2800      	cmp	r0, #0
  e0:	dd45      	ble.n	16e <wc_EccPrivateKeyDecode+0x16e>
                ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType,
  e2:	9600      	str	r6, [sp, #0]
  e4:	2315      	movs	r3, #21
  e6:	aa04      	add	r2, sp, #16
  e8:	4638      	mov	r0, r7
  ea:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
                if (ret == 0) {
  ee:	4604      	mov	r4, r0
  f0:	2800      	cmp	r0, #0
  f2:	d149      	bne.n	188 <wc_EccPrivateKeyDecode+0x188>
                    if ((ret = CheckCurve(oidSum)) < 0)
  f4:	9804      	ldr	r0, [sp, #16]
  f6:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
  fa:	f1b0 0800 	subs.w	r8, r0, #0
  fe:	db45      	blt.n	18c <wc_EccPrivateKeyDecode+0x18c>
    if (ret == 0 && (*inOutIdx + 1) < inSz) {
 100:	682a      	ldr	r2, [r5, #0]
 102:	1c53      	adds	r3, r2, #1
 104:	42b3      	cmp	r3, r6
 106:	d259      	bcs.n	1bc <wc_EccPrivateKeyDecode+0x1bc>
        b = input[*inOutIdx];
 108:	5cba      	ldrb	r2, [r7, r2]
        *inOutIdx += 1;
 10a:	602b      	str	r3, [r5, #0]
        if (b != ECC_PREFIX_1) {
 10c:	2aa1      	cmp	r2, #161	; 0xa1
 10e:	d141      	bne.n	194 <wc_EccPrivateKeyDecode+0x194>
        else if (GetLength(input, inOutIdx, &length, inSz) <= 0) {
 110:	4633      	mov	r3, r6
 112:	aa06      	add	r2, sp, #24
 114:	4629      	mov	r1, r5
 116:	4638      	mov	r0, r7
 118:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
 11c:	2800      	cmp	r0, #0
 11e:	dd26      	ble.n	16e <wc_EccPrivateKeyDecode+0x16e>
            ret = CheckBitString(input, inOutIdx, &length, inSz, 0, NULL);
 120:	2600      	movs	r6, #0
 122:	e9cd 6600 	strd	r6, r6, [sp]
 126:	4638      	mov	r0, r7
 128:	f7ff fffe 	bl	0 <wc_EccPrivateKeyDecode>
            if (ret == 0) {
 12c:	4604      	mov	r4, r0
 12e:	bb08      	cbnz	r0, 174 <wc_EccPrivateKeyDecode+0x174>
                pubSz = length;
 130:	f8dd b018 	ldr.w	fp, [sp, #24]
                if (pubSz > 2*(ECC_MAXSIZE+1))
 134:	f1bb 0f86 	cmp.w	fp, #134	; 0x86
 138:	dc30      	bgt.n	19c <wc_EccPrivateKeyDecode+0x19c>
                    pub = (byte*)XMALLOC(pubSz, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 13a:	4658      	mov	r0, fp
 13c:	f7ff fffe 	bl	0 <malloc>
                    if (pub == NULL)
 140:	4606      	mov	r6, r0
 142:	b378      	cbz	r0, 1a4 <wc_EccPrivateKeyDecode+0x1a4>
                        XMEMCPY(pub, &input[*inOutIdx], (size_t)pubSz);
 144:	6829      	ldr	r1, [r5, #0]
 146:	465a      	mov	r2, fp
 148:	4439      	add	r1, r7
 14a:	f7ff fffe 	bl	0 <memcpy>
                        *inOutIdx += (word32)length;
 14e:	682a      	ldr	r2, [r5, #0]
 150:	9906      	ldr	r1, [sp, #24]
 152:	440a      	add	r2, r1
 154:	602a      	str	r2, [r5, #0]
        ret = wc_ecc_import_private_key_ex(priv, (word32)privSz, pubData,
 156:	9b03      	ldr	r3, [sp, #12]
 158:	9300      	str	r3, [sp, #0]
 15a:	f8cd 8004 	str.w	r8, [sp, #4]
 15e:	465b      	mov	r3, fp
 160:	4632      	mov	r2, r6
 162:	4651      	mov	r1, sl
 164:	4648      	mov	r0, r9
 166:	f7ff fffe 	bl	0 <wc_ecc_import_private_key_ex>
 16a:	4604      	mov	r4, r0
 16c:	e002      	b.n	174 <wc_EccPrivateKeyDecode+0x174>
                        ret = ECC_CURVE_OID_E;
 16e:	2600      	movs	r6, #0
                ret = ASN_PARSE_E;
 170:	f06f 048b 	mvn.w	r4, #139	; 0x8b
    XFREE(priv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 174:	4648      	mov	r0, r9
 176:	f7ff fffe 	bl	0 <free>
    XFREE(pub,  key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 17a:	2e00      	cmp	r6, #0
 17c:	f43f af6b 	beq.w	56 <wc_EccPrivateKeyDecode+0x56>
 180:	4630      	mov	r0, r6
 182:	f7ff fffe 	bl	0 <free>
 186:	e766      	b.n	56 <wc_EccPrivateKeyDecode+0x56>
 188:	2600      	movs	r6, #0
 18a:	e7f3      	b.n	174 <wc_EccPrivateKeyDecode+0x174>
 18c:	4626      	mov	r6, r4
                        ret = ECC_CURVE_OID_E;
 18e:	f06f 04ab 	mvn.w	r4, #171	; 0xab
 192:	e7ef      	b.n	174 <wc_EccPrivateKeyDecode+0x174>
 194:	2600      	movs	r6, #0
            ret = ASN_ECC_KEY_E;
 196:	f06f 04aa 	mvn.w	r4, #170	; 0xaa
 19a:	e7eb      	b.n	174 <wc_EccPrivateKeyDecode+0x174>
 19c:	4606      	mov	r6, r0
                    ret = BUFFER_E;
 19e:	f06f 0483 	mvn.w	r4, #131	; 0x83
 1a2:	e7e7      	b.n	174 <wc_EccPrivateKeyDecode+0x174>
                        ret = MEMORY_E;
 1a4:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 1a8:	e7e4      	b.n	174 <wc_EccPrivateKeyDecode+0x174>
        return BAD_FUNC_ARG;
 1aa:	f06f 04ac 	mvn.w	r4, #172	; 0xac
 1ae:	e752      	b.n	56 <wc_EccPrivateKeyDecode+0x56>
        return BUFFER_E;
 1b0:	f06f 0483 	mvn.w	r4, #131	; 0x83
 1b4:	e74f      	b.n	56 <wc_EccPrivateKeyDecode+0x56>
        return MEMORY_E;
 1b6:	f06f 047c 	mvn.w	r4, #124	; 0x7c
 1ba:	e74c      	b.n	56 <wc_EccPrivateKeyDecode+0x56>
    byte* pub = NULL;
 1bc:	2600      	movs	r6, #0
    int    privSz, pubSz = 0;
 1be:	46b3      	mov	fp, r6
 1c0:	e7c9      	b.n	156 <wc_EccPrivateKeyDecode+0x156>

Disassembly of section .text.wc_EccPublicKeyDecode:

00000000 <wc_EccPublicKeyDecode>:
#endif /* WOLFSSL_CUSTOM_CURVES */

WOLFSSL_ABI
int wc_EccPublicKeyDecode(const byte* input, word32* inOutIdx,
                          ecc_key* key, word32 inSz)
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	460c      	mov	r4, r1
   6:	b089      	sub	sp, #36	; 0x24
   8:	4617      	mov	r7, r2
   a:	461e      	mov	r6, r3
    int    version, length;
    int    curve_id = ECC_CURVE_DEF;
    word32 oidSum, localIdx;
    byte   tag, isPrivFormat = 0;

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0)
   c:	4605      	mov	r5, r0
   e:	2800      	cmp	r0, #0
  10:	f000 80b2 	beq.w	178 <wc_EccPublicKeyDecode+0x178>
  14:	2900      	cmp	r1, #0
  16:	f000 80af 	beq.w	178 <wc_EccPublicKeyDecode+0x178>
  1a:	2a00      	cmp	r2, #0
  1c:	f000 80ac 	beq.w	178 <wc_EccPublicKeyDecode+0x178>
  20:	2b00      	cmp	r3, #0
  22:	f000 80a9 	beq.w	178 <wc_EccPublicKeyDecode+0x178>
        return BAD_FUNC_ARG;

    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
  26:	aa05      	add	r2, sp, #20
  28:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
  2c:	2800      	cmp	r0, #0
  2e:	da04      	bge.n	3a <wc_EccPublicKeyDecode+0x3a>
        return ASN_PARSE_E;
  30:	f06f 008b 	mvn.w	r0, #139	; 0x8b
    }

    FREE_ASNGETDATA(dataASN, key->heap);
    return ret;
#endif /* WOLFSSL_ASN_TEMPLATE */
}
  34:	b009      	add	sp, #36	; 0x24
  36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (GetMyVersion(input, inOutIdx, &version, inSz) >= 0) {
  3a:	4633      	mov	r3, r6
  3c:	aa04      	add	r2, sp, #16
  3e:	4621      	mov	r1, r4
  40:	4628      	mov	r0, r5
  42:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
  46:	2800      	cmp	r0, #0
  48:	db6f      	blt.n	12a <wc_EccPublicKeyDecode+0x12a>
        if (*inOutIdx >= inSz)
  4a:	6822      	ldr	r2, [r4, #0]
  4c:	42b2      	cmp	r2, r6
  4e:	d2ef      	bcs.n	30 <wc_EccPublicKeyDecode+0x30>
        tag = input[*inOutIdx];
  50:	5cab      	ldrb	r3, [r5, r2]
  52:	f88d 300f 	strb.w	r3, [sp, #15]
        *inOutIdx += 1;
  56:	3201      	adds	r2, #1
        if (tag != 4 && tag != 6 && tag != 7)
  58:	2b04      	cmp	r3, #4
        *inOutIdx += 1;
  5a:	6022      	str	r2, [r4, #0]
        if (tag != 4 && tag != 6 && tag != 7)
  5c:	d002      	beq.n	64 <wc_EccPublicKeyDecode+0x64>
  5e:	3b06      	subs	r3, #6
  60:	2b01      	cmp	r3, #1
  62:	d8e5      	bhi.n	30 <wc_EccPublicKeyDecode+0x30>
        if (GetLength(input, inOutIdx, &length, inSz) < 0)
  64:	4633      	mov	r3, r6
  66:	aa05      	add	r2, sp, #20
  68:	4621      	mov	r1, r4
  6a:	4628      	mov	r0, r5
  6c:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
  70:	2800      	cmp	r0, #0
  72:	dbdd      	blt.n	30 <wc_EccPublicKeyDecode+0x30>
        if (length > ECC_MAXSIZE)
  74:	9805      	ldr	r0, [sp, #20]
  76:	2842      	cmp	r0, #66	; 0x42
  78:	dd02      	ble.n	80 <wc_EccPublicKeyDecode+0x80>
            return BUFFER_E;
  7a:	f06f 0083 	mvn.w	r0, #131	; 0x83
  7e:	e7d9      	b.n	34 <wc_EccPublicKeyDecode+0x34>
        *inOutIdx += (word32)length;
  80:	f8d4 c000 	ldr.w	ip, [r4]
  84:	4460      	add	r0, ip
        if (*inOutIdx >= inSz)
  86:	42b0      	cmp	r0, r6
        *inOutIdx += (word32)length;
  88:	6020      	str	r0, [r4, #0]
        if (*inOutIdx >= inSz)
  8a:	d2d1      	bcs.n	30 <wc_EccPublicKeyDecode+0x30>
        tag = input[*inOutIdx];
  8c:	f815 c000 	ldrb.w	ip, [r5, r0]
  90:	f88d c00f 	strb.w	ip, [sp, #15]
        *inOutIdx += 1;
  94:	3001      	adds	r0, #1
        if (tag != ECC_PREFIX_0)
  96:	f1bc 0fa0 	cmp.w	ip, #160	; 0xa0
        *inOutIdx += 1;
  9a:	6020      	str	r0, [r4, #0]
        if (tag != ECC_PREFIX_0)
  9c:	d002      	beq.n	a4 <wc_EccPublicKeyDecode+0xa4>
            return ASN_ECC_KEY_E;
  9e:	f06f 00aa 	mvn.w	r0, #170	; 0xaa
  a2:	e7c7      	b.n	34 <wc_EccPublicKeyDecode+0x34>
        if (GetLength(input, inOutIdx, &length, inSz) <= 0)
  a4:	4628      	mov	r0, r5
  a6:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
  aa:	2800      	cmp	r0, #0
  ac:	ddc0      	ble.n	30 <wc_EccPublicKeyDecode+0x30>
        isPrivFormat = 1;
  ae:	f04f 0901 	mov.w	r9, #1
    if (*inOutIdx >= inSz) {
  b2:	6823      	ldr	r3, [r4, #0]
  b4:	42b3      	cmp	r3, r6
  b6:	d2e0      	bcs.n	7a <wc_EccPublicKeyDecode+0x7a>
    localIdx = *inOutIdx;
  b8:	9307      	str	r3, [sp, #28]
    if (GetASNTag(input, &localIdx, &tag, inSz) == 0 &&
  ba:	f10d 020f 	add.w	r2, sp, #15
  be:	4633      	mov	r3, r6
  c0:	a907      	add	r1, sp, #28
  c2:	4628      	mov	r0, r5
  c4:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
  c8:	b918      	cbnz	r0, d2 <wc_EccPublicKeyDecode+0xd2>
  ca:	f89d 300f 	ldrb.w	r3, [sp, #15]
  ce:	2b30      	cmp	r3, #48	; 0x30
  d0:	d0ae      	beq.n	30 <wc_EccPublicKeyDecode+0x30>
        ret = GetObjectId(input, inOutIdx, &oidSum, oidIgnoreType, inSz);
  d2:	9600      	str	r6, [sp, #0]
  d4:	2315      	movs	r3, #21
  d6:	aa06      	add	r2, sp, #24
  d8:	4621      	mov	r1, r4
  da:	4628      	mov	r0, r5
  dc:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
        if (ret != 0)
  e0:	2800      	cmp	r0, #0
  e2:	d1a7      	bne.n	34 <wc_EccPublicKeyDecode+0x34>
        if ((ret = CheckCurve(oidSum)) < 0)
  e4:	9806      	ldr	r0, [sp, #24]
  e6:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
  ea:	f1b0 0800 	subs.w	r8, r0, #0
  ee:	db46      	blt.n	17e <wc_EccPublicKeyDecode+0x17e>
    if (isPrivFormat) {
  f0:	f1b9 0f00 	cmp.w	r9, #0
  f4:	d12c      	bne.n	150 <wc_EccPublicKeyDecode+0x150>
    ret = CheckBitString(input, inOutIdx, &length, inSz, 1, NULL);
  f6:	2301      	movs	r3, #1
  f8:	2200      	movs	r2, #0
  fa:	e9cd 3200 	strd	r3, r2, [sp]
  fe:	4621      	mov	r1, r4
 100:	4633      	mov	r3, r6
 102:	aa05      	add	r2, sp, #20
 104:	4628      	mov	r0, r5
 106:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
    if (ret != 0)
 10a:	2800      	cmp	r0, #0
 10c:	d192      	bne.n	34 <wc_EccPublicKeyDecode+0x34>
    if (wc_ecc_import_x963_ex(input + *inOutIdx, (word32)length, key,
 10e:	6820      	ldr	r0, [r4, #0]
 110:	9905      	ldr	r1, [sp, #20]
 112:	4643      	mov	r3, r8
 114:	463a      	mov	r2, r7
 116:	4428      	add	r0, r5
 118:	f7ff fffe 	bl	0 <wc_ecc_import_x963_ex>
 11c:	2800      	cmp	r0, #0
 11e:	d1be      	bne.n	9e <wc_EccPublicKeyDecode+0x9e>
    *inOutIdx += (word32)length;
 120:	6823      	ldr	r3, [r4, #0]
 122:	9a05      	ldr	r2, [sp, #20]
 124:	4413      	add	r3, r2
 126:	6023      	str	r3, [r4, #0]
    return 0;
 128:	e784      	b.n	34 <wc_EccPublicKeyDecode+0x34>
        if (GetSequence(input, inOutIdx, &length, inSz) < 0)
 12a:	4633      	mov	r3, r6
 12c:	aa05      	add	r2, sp, #20
 12e:	4621      	mov	r1, r4
 130:	4628      	mov	r0, r5
 132:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
 136:	2800      	cmp	r0, #0
 138:	f6ff af7a 	blt.w	30 <wc_EccPublicKeyDecode+0x30>
        ret = SkipObjectId(input, inOutIdx, inSz);
 13c:	4632      	mov	r2, r6
 13e:	4621      	mov	r1, r4
 140:	4628      	mov	r0, r5
 142:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
        if (ret != 0)
 146:	2800      	cmp	r0, #0
 148:	f47f af74 	bne.w	34 <wc_EccPublicKeyDecode+0x34>
    byte   tag, isPrivFormat = 0;
 14c:	4681      	mov	r9, r0
 14e:	e7b0      	b.n	b2 <wc_EccPublicKeyDecode+0xb2>
        if (*inOutIdx >= inSz)
 150:	6822      	ldr	r2, [r4, #0]
 152:	42b2      	cmp	r2, r6
 154:	f4bf af6c 	bcs.w	30 <wc_EccPublicKeyDecode+0x30>
        tag = input[*inOutIdx];
 158:	5cab      	ldrb	r3, [r5, r2]
 15a:	f88d 300f 	strb.w	r3, [sp, #15]
        *inOutIdx += 1;
 15e:	3201      	adds	r2, #1
        if (tag != ECC_PREFIX_1)
 160:	2ba1      	cmp	r3, #161	; 0xa1
        *inOutIdx += 1;
 162:	6022      	str	r2, [r4, #0]
        if (tag != ECC_PREFIX_1)
 164:	d19b      	bne.n	9e <wc_EccPublicKeyDecode+0x9e>
        if (GetLength(input, inOutIdx, &length, inSz) <= 0)
 166:	4633      	mov	r3, r6
 168:	aa05      	add	r2, sp, #20
 16a:	4621      	mov	r1, r4
 16c:	4628      	mov	r0, r5
 16e:	f7ff fffe 	bl	0 <wc_EccPublicKeyDecode>
 172:	2800      	cmp	r0, #0
 174:	dcbf      	bgt.n	f6 <wc_EccPublicKeyDecode+0xf6>
 176:	e75b      	b.n	30 <wc_EccPublicKeyDecode+0x30>
        return BAD_FUNC_ARG;
 178:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 17c:	e75a      	b.n	34 <wc_EccPublicKeyDecode+0x34>
            return ECC_CURVE_OID_E;
 17e:	f06f 00ab 	mvn.w	r0, #171	; 0xab
 182:	e757      	b.n	34 <wc_EccPublicKeyDecode+0x34>

Disassembly of section .text.ParseCertRelative:

00000000 <ParseCertRelative>:
{
       0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
       4:	b09b      	sub	sp, #108	; 0x6c
    word32 confirmOID = 0;
       6:	2400      	movs	r4, #0
{
       8:	e9cd 2102 	strd	r2, r1, [sp, #8]
       c:	9306      	str	r3, [sp, #24]
    word32 confirmOID = 0;
       e:	940c      	str	r4, [sp, #48]	; 0x30
    if (cert == NULL) {
      10:	4681      	mov	r9, r0
      12:	b918      	cbnz	r0, 1c <ParseCertRelative+0x1c>
        return BAD_FUNC_ARG;
      14:	f06f 04ac 	mvn.w	r4, #172	; 0xac
      18:	f000 bed3 	b.w	dc2 <ParseCertRelative+0xdc2>
    if (cert->sigCtx.state == SIG_STATE_BEGIN) {
      1c:	f8d0 333c 	ldr.w	r3, [r0, #828]	; 0x33c
      20:	2b00      	cmp	r3, #0
      22:	f040 8721 	bne.w	e68 <ParseCertRelative+0xe68>
        cert->criticalExt = 0;
      26:	e9c0 33d3 	strd	r3, r3, [r0, #844]	; 0x34c
        if ((ret = DecodeToKey(cert, verify)) < 0) {
      2a:	9902      	ldr	r1, [sp, #8]
      2c:	f7ff fffe 	bl	0 <ParseCertRelative>
      30:	1e04      	subs	r4, r0, #0
      32:	da06      	bge.n	42 <ParseCertRelative+0x42>
            if (ret == ASN_BEFORE_DATE_E || ret == ASN_AFTER_DATE_E) {
      34:	f104 0397 	add.w	r3, r4, #151	; 0x97
      38:	2b01      	cmp	r3, #1
      3a:	f200 86c2 	bhi.w	dc2 <ParseCertRelative+0xdc2>
                cert->badDate = ret;
      3e:	f8c9 434c 	str.w	r4, [r9, #844]	; 0x34c
        if (cert->srcIdx < cert->sigIndex) {
      42:	f8d9 3278 	ldr.w	r3, [r9, #632]	; 0x278
      46:	f8d9 2010 	ldr.w	r2, [r9, #16]
      4a:	4293      	cmp	r3, r2
      4c:	d241      	bcs.n	d2 <ParseCertRelative+0xd2>
            if (cert->version < 2) {
      4e:	f8d9 1020 	ldr.w	r1, [r9, #32]
      52:	2901      	cmp	r1, #1
      54:	f341 80dc 	ble.w	1210 <ParseCertRelative+0x1210>
            cert->extensions    = &cert->source[cert->srcIdx];
      58:	f8d9 1274 	ldr.w	r1, [r9, #628]	; 0x274
    word32 idx = 0;
      5c:	2400      	movs	r4, #0
            cert->extensions    = &cert->source[cert->srcIdx];
      5e:	eb01 0b03 	add.w	fp, r1, r3
            cert->extensionsSz  = (int)(cert->sigIndex - cert->srcIdx);
      62:	eba2 0a03 	sub.w	sl, r2, r3
            cert->extensionsIdx = cert->srcIdx;   /* for potential later use */
      66:	e9c9 a3ab 	strd	sl, r3, [r9, #684]	; 0x2ac
            cert->extensions    = &cert->source[cert->srcIdx];
      6a:	f8c9 b2a8 	str.w	fp, [r9, #680]	; 0x2a8
    word32 idx = 0;
      6e:	940d      	str	r4, [sp, #52]	; 0x34
    byte tag = 0;
      70:	f88d 402f 	strb.w	r4, [sp, #47]	; 0x2f
    if (input == NULL || sz == 0)
      74:	f1bb 0f00 	cmp.w	fp, #0
      78:	d0cc      	beq.n	14 <ParseCertRelative+0x14>
        if (GetASNTag(input, &idx, &tag, sz) < 0) {
      7a:	4653      	mov	r3, sl
      7c:	f10d 022f 	add.w	r2, sp, #47	; 0x2f
      80:	a90d      	add	r1, sp, #52	; 0x34
      82:	4658      	mov	r0, fp
      84:	f7ff fffe 	bl	0 <ParseCertRelative>
      88:	42a0      	cmp	r0, r4
      8a:	f2c0 8293 	blt.w	5b4 <ParseCertRelative+0x5b4>
        if (tag != ASN_EXTENSIONS) {
      8e:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
      92:	2ba3      	cmp	r3, #163	; 0xa3
      94:	f040 828e 	bne.w	5b4 <ParseCertRelative+0x5b4>
        if (GetLength(input, &idx, &length, sz) < 0) {
      98:	4653      	mov	r3, sl
      9a:	aa0e      	add	r2, sp, #56	; 0x38
      9c:	4658      	mov	r0, fp
      9e:	f7ff fffe 	bl	0 <ParseCertRelative>
      a2:	42a0      	cmp	r0, r4
      a4:	f2c0 8286 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (GetSequence(input, &idx, &length, sz) < 0) {
      a8:	4658      	mov	r0, fp
      aa:	f7ff fffe 	bl	0 <ParseCertRelative>
      ae:	42a0      	cmp	r0, r4
      b0:	f2c0 8280 	blt.w	5b4 <ParseCertRelative+0x5b4>
    byte criticalFail = 0;
      b4:	9407      	str	r4, [sp, #28]
    while (idx < (word32)sz) {
      b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
      b8:	459a      	cmp	sl, r3
      ba:	f200 809a 	bhi.w	1f2 <ParseCertRelative+0x1f2>
    ret = criticalFail ? ASN_CRIT_EXT_E : 0;
      be:	9b07      	ldr	r3, [sp, #28]
      c0:	b11b      	cbz	r3, ca <ParseCertRelative+0xca>
                    cert->criticalExt = ret;
      c2:	f06f 039f 	mvn.w	r3, #159	; 0x9f
      c6:	f8c9 3350 	str.w	r3, [r9, #848]	; 0x350
            cert->srcIdx = cert->sigIndex;
      ca:	f8d9 3010 	ldr.w	r3, [r9, #16]
      ce:	f8c9 3278 	str.w	r3, [r9, #632]	; 0x278
        if ((ret = GetSigAlg(cert,
      d2:	f8d9 227c 	ldr.w	r2, [r9, #636]	; 0x27c
      d6:	a90c      	add	r1, sp, #48	; 0x30
      d8:	4648      	mov	r0, r9
      da:	f7ff fffe 	bl	0 <ParseCertRelative>
      de:	1e04      	subs	r4, r0, #0
      e0:	f2c0 866f 	blt.w	dc2 <ParseCertRelative+0xdc2>
    ret = CheckBitString(cert->source, &cert->srcIdx, &length, cert->maxIdx, 1,
      e4:	2301      	movs	r3, #1
      e6:	2000      	movs	r0, #0
      e8:	e9cd 3000 	strd	r3, r0, [sp]
      ec:	aa16      	add	r2, sp, #88	; 0x58
      ee:	f8d9 327c 	ldr.w	r3, [r9, #636]	; 0x27c
      f2:	f8d9 0274 	ldr.w	r0, [r9, #628]	; 0x274
      f6:	f509 711e 	add.w	r1, r9, #632	; 0x278
      fa:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (ret != 0)
      fe:	1e04      	subs	r4, r0, #0
     100:	f040 8663 	bne.w	dca <ParseCertRelative+0xdca>
    cert->signature = &cert->source[cert->srcIdx];
     104:	e9d9 219d 	ldrd	r2, r1, [r9, #628]	; 0x274
    cert->sigLength = (word32)length;
     108:	9b16      	ldr	r3, [sp, #88]	; 0x58
     10a:	f8c9 3014 	str.w	r3, [r9, #20]
    cert->signature = &cert->source[cert->srcIdx];
     10e:	440a      	add	r2, r1
     110:	f8c9 2060 	str.w	r2, [r9, #96]	; 0x60
    if (cert->srcIdx != cert->maxIdx)
     114:	f8d9 227c 	ldr.w	r2, [r9, #636]	; 0x27c
    cert->srcIdx += cert->sigLength;
     118:	440b      	add	r3, r1
    if (cert->srcIdx != cert->maxIdx)
     11a:	4293      	cmp	r3, r2
    cert->srcIdx += cert->sigLength;
     11c:	f8c9 3278 	str.w	r3, [r9, #632]	; 0x278
    if (cert->srcIdx != cert->maxIdx)
     120:	f040 8248 	bne.w	5b4 <ParseCertRelative+0x5b4>
        if (confirmOID != cert->signatureOID
     124:	f8d9 3018 	ldr.w	r3, [r9, #24]
     128:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     12a:	4293      	cmp	r3, r2
     12c:	f041 8073 	bne.w	1216 <ParseCertRelative+0x1216>
        if (!cert->isCA && cert->extKeyUsageSet &&
     130:	f899 2354 	ldrb.w	r2, [r9, #852]	; 0x354
     134:	f002 0190 	and.w	r1, r2, #144	; 0x90
     138:	2980      	cmp	r1, #128	; 0x80
     13a:	d104      	bne.n	146 <ParseCertRelative+0x146>
     13c:	f8b9 12f8 	ldrh.w	r1, [r9, #760]	; 0x2f8
     140:	0749      	lsls	r1, r1, #29
     142:	f101 806b 	bmi.w	121c <ParseCertRelative+0x121c>
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
     146:	0792      	lsls	r2, r2, #30
     148:	d415      	bmi.n	176 <ParseCertRelative+0x176>
     14a:	f8d9 0000 	ldr.w	r0, [r9]
     14e:	b190      	cbz	r0, 176 <ParseCertRelative+0x176>
                                                         cert->pubKeySize > 0) {
     150:	f8d9 1004 	ldr.w	r1, [r9, #4]
        if (cert->extSubjKeyIdSet == 0 && cert->publicKey != NULL &&
     154:	b179      	cbz	r1, 176 <ParseCertRelative+0x176>
            if (cert->signatureOID == CTC_SM3wSM2) {
     156:	f5b3 7f39 	cmp.w	r3, #740	; 0x2e4
                ret = CalcHashId_ex(cert->publicKey + cert->pubKeySize - 65, 65,
     15a:	bf08      	it	eq
     15c:	f1a1 0341 	subeq.w	r3, r1, #65	; 0x41
        ret = GetHashId(input + idx, length, cert->extSubjKeyId,
     160:	f509 7233 	add.w	r2, r9, #716	; 0x2cc
        ret = wc_ShaHash(data, len, hash);
     164:	bf04      	itt	eq
     166:	2141      	moveq	r1, #65	; 0x41
     168:	18c0      	addeq	r0, r0, r3
     16a:	f7ff fffe 	bl	0 <wc_ShaHash>
     16e:	4604      	mov	r4, r0
            if (ret != 0) {
     170:	2800      	cmp	r0, #0
     172:	f040 8626 	bne.w	dc2 <ParseCertRelative+0xdc2>
        if (!cert->selfSigned || (verify != NO_VERIFY && type != CA_TYPE &&
     176:	f899 3356 	ldrb.w	r3, [r9, #854]	; 0x356
     17a:	079b      	lsls	r3, r3, #30
     17c:	d50a      	bpl.n	194 <ParseCertRelative+0x194>
     17e:	9b02      	ldr	r3, [sp, #8]
     180:	2b00      	cmp	r3, #0
     182:	f000 8643 	beq.w	e0c <ParseCertRelative+0xe0c>
     186:	9b03      	ldr	r3, [sp, #12]
     188:	2b05      	cmp	r3, #5
     18a:	f000 863f 	beq.w	e0c <ParseCertRelative+0xe0c>
     18e:	2b0f      	cmp	r3, #15
     190:	f000 863c 	beq.w	e0c <ParseCertRelative+0xe0c>
            cert->ca = NULL;
     194:	2300      	movs	r3, #0
     196:	f8c9 3324 	str.w	r3, [r9, #804]	; 0x324
            if (cert->extAuthKeyIdSet) {
     19a:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     19e:	075f      	lsls	r7, r3, #29
     1a0:	f100 8616 	bmi.w	dd0 <ParseCertRelative+0xdd0>
            if (cert->ca == NULL && cert->extSubjKeyIdSet
     1a4:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     1a8:	079e      	lsls	r6, r3, #30
     1aa:	f100 861d 	bmi.w	de8 <ParseCertRelative+0xde8>
            if (cert->ca != NULL && XMEMCMP(cert->issuerHash,
     1ae:	f8d9 1324 	ldr.w	r1, [r9, #804]	; 0x324
     1b2:	f109 054c 	add.w	r5, r9, #76	; 0x4c
     1b6:	b151      	cbz	r1, 1ce <ParseCertRelative+0x1ce>
     1b8:	2214      	movs	r2, #20
     1ba:	3120      	adds	r1, #32
     1bc:	4628      	mov	r0, r5
     1be:	f7ff fffe 	bl	0 <memcmp>
     1c2:	2800      	cmp	r0, #0
     1c4:	f000 861d 	beq.w	e02 <ParseCertRelative+0xe02>
                cert->ca = NULL;
     1c8:	2300      	movs	r3, #0
     1ca:	f8c9 3324 	str.w	r3, [r9, #804]	; 0x324
                cert->ca = GetCAByName(cm, cert->issuerHash);
     1ce:	9806      	ldr	r0, [sp, #24]
     1d0:	4629      	mov	r1, r5
     1d2:	f7ff fffe 	bl	0 <GetCAByName>
     1d6:	f8c9 0324 	str.w	r0, [r9, #804]	; 0x324
                if (cert->ca && cert->extAuthKeyIdSet) {
     1da:	2800      	cmp	r0, #0
     1dc:	f000 8616 	beq.w	e0c <ParseCertRelative+0xe0c>
     1e0:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     1e4:	075d      	lsls	r5, r3, #29
                    cert->ca = NULL;
     1e6:	bf44      	itt	mi
     1e8:	2300      	movmi	r3, #0
     1ea:	f8c9 3324 	strmi.w	r3, [r9, #804]	; 0x324
     1ee:	f000 be0d 	b.w	e0c <ParseCertRelative+0xe0c>
        if (GetSequence(input, &idx, &length, sz) < 0) {
     1f2:	4653      	mov	r3, sl
     1f4:	aa0e      	add	r2, sp, #56	; 0x38
     1f6:	a90d      	add	r1, sp, #52	; 0x34
     1f8:	4658      	mov	r0, fp
     1fa:	f7ff fffe 	bl	0 <ParseCertRelative>
     1fe:	2800      	cmp	r0, #0
     200:	f2c0 81d8 	blt.w	5b4 <ParseCertRelative+0x5b4>
        oid = 0;
     204:	2500      	movs	r5, #0
        if ((ret = GetObjectId(input, &idx, &oid, oidCertExtType, sz)) < 0) {
     206:	f8cd a000 	str.w	sl, [sp]
     20a:	2306      	movs	r3, #6
     20c:	aa0f      	add	r2, sp, #60	; 0x3c
     20e:	a90d      	add	r1, sp, #52	; 0x34
     210:	4658      	mov	r0, fp
        oid = 0;
     212:	950f      	str	r5, [sp, #60]	; 0x3c
        if ((ret = GetObjectId(input, &idx, &oid, oidCertExtType, sz)) < 0) {
     214:	f7ff fffe 	bl	0 <ParseCertRelative>
     218:	1e04      	subs	r4, r0, #0
     21a:	f2c0 84f1 	blt.w	c00 <ParseCertRelative+0xc00>
        if ((idx + 1) > (word32)sz) {
     21e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     220:	1c5a      	adds	r2, r3, #1
     222:	4592      	cmp	sl, r2
     224:	f0c1 8017 	bcc.w	1256 <ParseCertRelative+0x1256>
        localIdx = idx;
     228:	9310      	str	r3, [sp, #64]	; 0x40
        if (GetASNTag(input, &localIdx, &tag, sz) == 0) {
     22a:	f10d 022f 	add.w	r2, sp, #47	; 0x2f
     22e:	4653      	mov	r3, sl
     230:	a910      	add	r1, sp, #64	; 0x40
     232:	4658      	mov	r0, fp
     234:	f7ff fffe 	bl	0 <ParseCertRelative>
     238:	4607      	mov	r7, r0
     23a:	bb30      	cbnz	r0, 28a <ParseCertRelative+0x28a>
            if (tag == ASN_BOOLEAN) {
     23c:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
     240:	2b01      	cmp	r3, #1
     242:	d108      	bne.n	256 <ParseCertRelative+0x256>
                ret = GetBoolean(input, &idx, sz);
     244:	4652      	mov	r2, sl
     246:	a90d      	add	r1, sp, #52	; 0x34
     248:	4658      	mov	r0, fp
     24a:	f7ff fffe 	bl	0 <ParseCertRelative>
                if (ret < 0) {
     24e:	1e04      	subs	r4, r0, #0
     250:	f2c0 84d6 	blt.w	c00 <ParseCertRelative+0xc00>
                critical = (byte)ret;
     254:	b2e7      	uxtb	r7, r4
        ret = GetOctetString(input, &idx, &length, sz);
     256:	4653      	mov	r3, sl
     258:	aa0e      	add	r2, sp, #56	; 0x38
     25a:	a90d      	add	r1, sp, #52	; 0x34
     25c:	4658      	mov	r0, fp
     25e:	f7ff fffe 	bl	0 <ParseCertRelative>
        if (ret < 0) {
     262:	1e04      	subs	r4, r0, #0
     264:	f2c0 84cc 	blt.w	c00 <ParseCertRelative+0xc00>
        ret = DecodeExtensionType(input + idx, (word32)length, oid, critical,
     268:	e9dd 630e 	ldrd	r6, r3, [sp, #56]	; 0x38
     26c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    switch (oid) {
     26e:	2b97      	cmp	r3, #151	; 0x97
        ret = DecodeExtensionType(input + idx, (word32)length, oid, critical,
     270:	445d      	add	r5, fp
    switch (oid) {
     272:	d843      	bhi.n	2fc <ParseCertRelative+0x2fc>
     274:	2b7f      	cmp	r3, #127	; 0x7f
     276:	d80a      	bhi.n	28e <ParseCertRelative+0x28e>
     278:	2b45      	cmp	r3, #69	; 0x45
     27a:	f000 8173 	beq.w	564 <ParseCertRelative+0x564>
            if (critical) {
     27e:	2f00      	cmp	r7, #0
     280:	f000 81d0 	beq.w	624 <ParseCertRelative+0x624>
            criticalFail = 1;
     284:	2301      	movs	r3, #1
     286:	9307      	str	r3, [sp, #28]
     288:	e1cc      	b.n	624 <ParseCertRelative+0x624>
        critical = 0;
     28a:	462f      	mov	r7, r5
     28c:	e7e3      	b.n	256 <ParseCertRelative+0x256>
    switch (oid) {
     28e:	3b80      	subs	r3, #128	; 0x80
     290:	2b17      	cmp	r3, #23
     292:	d8f4      	bhi.n	27e <ParseCertRelative+0x27e>
     294:	a201      	add	r2, pc, #4	; (adr r2, 29c <ParseCertRelative+0x29c>)
     296:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     29a:	bf00      	nop
     29c:	000009f9 	.word	0x000009f9
     2a0:	00000a4d 	.word	0x00000a4d
     2a4:	0000027f 	.word	0x0000027f
     2a8:	0000062f 	.word	0x0000062f
     2ac:	0000027f 	.word	0x0000027f
     2b0:	00000337 	.word	0x00000337
     2b4:	0000027f 	.word	0x0000027f
     2b8:	0000027f 	.word	0x0000027f
     2bc:	0000027f 	.word	0x0000027f
     2c0:	0000027f 	.word	0x0000027f
     2c4:	0000027f 	.word	0x0000027f
     2c8:	0000027f 	.word	0x0000027f
     2cc:	0000027f 	.word	0x0000027f
     2d0:	0000027f 	.word	0x0000027f
     2d4:	0000027f 	.word	0x0000027f
     2d8:	0000027f 	.word	0x0000027f
     2dc:	00000ba5 	.word	0x00000ba5
     2e0:	000003eb 	.word	0x000003eb
     2e4:	00000625 	.word	0x00000625
     2e8:	0000027f 	.word	0x0000027f
     2ec:	0000027f 	.word	0x0000027f
     2f0:	0000095b 	.word	0x0000095b
     2f4:	00000d17 	.word	0x00000d17
     2f8:	00000ab7 	.word	0x00000ab7
     2fc:	2ba8      	cmp	r3, #168	; 0xa8
     2fe:	f000 8501 	beq.w	d04 <ParseCertRelative+0xd04>
     302:	f240 22f1 	movw	r2, #753	; 0x2f1
     306:	4293      	cmp	r3, r2
     308:	d1b9      	bne.n	27e <ParseCertRelative+0x27e>
    word32 idx = 0;
     30a:	2300      	movs	r3, #0
    int len = 0;
     30c:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
    if (CheckBitString(input, &idx, &len, (word32)sz, 0, NULL) < 0)
     310:	e9cd 3300 	strd	r3, r3, [sp]
     314:	aa16      	add	r2, sp, #88	; 0x58
     316:	4633      	mov	r3, r6
     318:	a915      	add	r1, sp, #84	; 0x54
     31a:	4628      	mov	r0, r5
     31c:	f7ff fffe 	bl	0 <ParseCertRelative>
     320:	2800      	cmp	r0, #0
     322:	f2c0 8147 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (idx < (word32)sz)
     326:	9b15      	ldr	r3, [sp, #84]	; 0x54
     328:	429e      	cmp	r6, r3
     32a:	f240 8143 	bls.w	5b4 <ParseCertRelative+0x5b4>
        cert->nsCertType = input[idx];
     32e:	5ceb      	ldrb	r3, [r5, r3]
     330:	f889 3320 	strb.w	r3, [r9, #800]	; 0x320
        if (ret == ASN_CRIT_EXT_E) {
     334:	e176      	b.n	624 <ParseCertRelative+0x624>
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
     336:	f899 3355 	ldrb.w	r3, [r9, #853]	; 0x355
     33a:	f013 0308 	ands.w	r3, r3, #8
     33e:	f040 853e 	bne.w	dbe <ParseCertRelative+0xdbe>
            cert->extBasicConstCrit = critical ? 1 : 0;
     342:	3f00      	subs	r7, #0
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
     344:	f8d9 2354 	ldr.w	r2, [r9, #852]	; 0x354
            cert->extBasicConstCrit = critical ? 1 : 0;
     348:	bf18      	it	ne
     34a:	2701      	movne	r7, #1
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
     34c:	053f      	lsls	r7, r7, #20
     34e:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
     352:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
     356:	f447 6700 	orr.w	r7, r7, #2048	; 0x800
     35a:	4317      	orrs	r7, r2
    int length = 0;
     35c:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
     360:	f8c9 7354 	str.w	r7, [r9, #852]	; 0x354
    if (GetSequence(input, &idx, &length, (word32)sz) < 0) {
     364:	4633      	mov	r3, r6
     366:	aa15      	add	r2, sp, #84	; 0x54
     368:	a914      	add	r1, sp, #80	; 0x50
     36a:	4628      	mov	r0, r5
     36c:	f7ff fffe 	bl	0 <ParseCertRelative>
     370:	2800      	cmp	r0, #0
     372:	f2c0 811f 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (length == 0)
     376:	9b15      	ldr	r3, [sp, #84]	; 0x54
     378:	2b00      	cmp	r3, #0
     37a:	f000 8153 	beq.w	624 <ParseCertRelative+0x624>
    ret = GetBoolean(input, &idx, (word32)sz);
     37e:	4632      	mov	r2, r6
     380:	a914      	add	r1, sp, #80	; 0x50
     382:	4628      	mov	r0, r5
     384:	f7ff fffe 	bl	0 <ParseCertRelative>
    cert->isCA = ret ? 1 : 0;
     388:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     38c:	2800      	cmp	r0, #0
     38e:	bfd4      	ite	le
     390:	2000      	movle	r0, #0
     392:	2001      	movgt	r0, #1
     394:	f360 1304 	bfi	r3, r0, #4, #1
     398:	f889 3354 	strb.w	r3, [r9, #852]	; 0x354
    if (idx >= (word32)sz) {
     39c:	9b14      	ldr	r3, [sp, #80]	; 0x50
     39e:	429e      	cmp	r6, r3
     3a0:	f240 8140 	bls.w	624 <ParseCertRelative+0x624>
    word32 idx = *inOutIdx;
     3a4:	9316      	str	r3, [sp, #88]	; 0x58
    if ((idx + 3) > maxIdx)
     3a6:	3303      	adds	r3, #3
     3a8:	429e      	cmp	r6, r3
     3aa:	f0c0 8103 	bcc.w	5b4 <ParseCertRelative+0x5b4>
    if (GetASNTag(input, &idx, &b, maxIdx) != 0)
     3ae:	4633      	mov	r3, r6
     3b0:	aa13      	add	r2, sp, #76	; 0x4c
     3b2:	a916      	add	r1, sp, #88	; 0x58
     3b4:	4628      	mov	r0, r5
     3b6:	f7ff fffe 	bl	0 <ParseCertRelative>
     3ba:	2800      	cmp	r0, #0
     3bc:	f040 80fa 	bne.w	5b4 <ParseCertRelative+0x5b4>
    if (b != ASN_INTEGER)
     3c0:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
     3c4:	2b02      	cmp	r3, #2
     3c6:	f040 80f5 	bne.w	5b4 <ParseCertRelative+0x5b4>
    if (input[idx++] != 1)
     3ca:	9b16      	ldr	r3, [sp, #88]	; 0x58
     3cc:	1c5a      	adds	r2, r3, #1
     3ce:	5ceb      	ldrb	r3, [r5, r3]
     3d0:	2b01      	cmp	r3, #1
     3d2:	f040 80ef 	bne.w	5b4 <ParseCertRelative+0x5b4>
    b = input[idx++];
     3d6:	5cab      	ldrb	r3, [r5, r2]
    cert->pathLength = (byte)ret;
     3d8:	f889 32f4 	strb.w	r3, [r9, #756]	; 0x2f4
    cert->pathLengthSet = 1;
     3dc:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     3e0:	f043 0320 	orr.w	r3, r3, #32
        cert->extAuthKeyIdSet = 0;
     3e4:	f889 3354 	strb.w	r3, [r9, #852]	; 0x354
        return 0;
     3e8:	e11c      	b.n	624 <ParseCertRelative+0x624>
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
     3ea:	f899 3355 	ldrb.w	r3, [r9, #853]	; 0x355
     3ee:	f013 0302 	ands.w	r3, r3, #2
     3f2:	f040 84e4 	bne.w	dbe <ParseCertRelative+0xdbe>
            cert->extCRLdistCrit = critical ? 1 : 0;
     3f6:	3f00      	subs	r7, #0
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
     3f8:	f8d9 2354 	ldr.w	r2, [r9, #852]	; 0x354
    word32 idx = 0, localIdx;
     3fc:	9314      	str	r3, [sp, #80]	; 0x50
            cert->extCRLdistCrit = critical ? 1 : 0;
     3fe:	bf18      	it	ne
     400:	2701      	movne	r7, #1
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
     402:	04bf      	lsls	r7, r7, #18
     404:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     408:	f422 7200 	bic.w	r2, r2, #512	; 0x200
     40c:	f447 7700 	orr.w	r7, r7, #512	; 0x200
     410:	4317      	orrs	r7, r2
    int length = 0;
     412:	9316      	str	r3, [sp, #88]	; 0x58
    byte tag   = 0;
     414:	f88d 304c 	strb.w	r3, [sp, #76]	; 0x4c
    cert->extCrlInfoRawSz = (int)sz;
     418:	e9c9 56af 	strd	r5, r6, [r9, #700]	; 0x2bc
            VERIFY_AND_SET_OID(cert->extCRLdistSet);
     41c:	f8c9 7354 	str.w	r7, [r9, #852]	; 0x354
    if (GetSequence(input, &idx, &length, sz) < 0)
     420:	4633      	mov	r3, r6
     422:	aa16      	add	r2, sp, #88	; 0x58
     424:	a914      	add	r1, sp, #80	; 0x50
     426:	4628      	mov	r0, r5
     428:	f7ff fffe 	bl	0 <ParseCertRelative>
     42c:	2800      	cmp	r0, #0
     42e:	f2c0 80c1 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (GetSequence(input, &idx, &length, sz) < 0)
     432:	4633      	mov	r3, r6
     434:	aa16      	add	r2, sp, #88	; 0x58
     436:	a914      	add	r1, sp, #80	; 0x50
     438:	4628      	mov	r0, r5
     43a:	f7ff fffe 	bl	0 <ParseCertRelative>
     43e:	2800      	cmp	r0, #0
     440:	f2c0 80b8 	blt.w	5b4 <ParseCertRelative+0x5b4>
    localIdx = idx;
     444:	9b14      	ldr	r3, [sp, #80]	; 0x50
     446:	9315      	str	r3, [sp, #84]	; 0x54
    if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
     448:	aa13      	add	r2, sp, #76	; 0x4c
     44a:	4633      	mov	r3, r6
     44c:	a915      	add	r1, sp, #84	; 0x54
     44e:	4628      	mov	r0, r5
     450:	f7ff fffe 	bl	0 <ParseCertRelative>
     454:	2800      	cmp	r0, #0
     456:	d149      	bne.n	4ec <ParseCertRelative+0x4ec>
     458:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
     45c:	2ba0      	cmp	r3, #160	; 0xa0
     45e:	d145      	bne.n	4ec <ParseCertRelative+0x4ec>
        idx++;
     460:	9b14      	ldr	r3, [sp, #80]	; 0x50
     462:	3301      	adds	r3, #1
     464:	9314      	str	r3, [sp, #80]	; 0x50
        if (GetLength(input, &idx, &length, sz) < 0)
     466:	aa16      	add	r2, sp, #88	; 0x58
     468:	4633      	mov	r3, r6
     46a:	a914      	add	r1, sp, #80	; 0x50
     46c:	4628      	mov	r0, r5
     46e:	f7ff fffe 	bl	0 <ParseCertRelative>
     472:	2800      	cmp	r0, #0
     474:	f2c0 809e 	blt.w	5b4 <ParseCertRelative+0x5b4>
        localIdx = idx;
     478:	9a14      	ldr	r2, [sp, #80]	; 0x50
     47a:	9215      	str	r2, [sp, #84]	; 0x54
        if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
     47c:	a915      	add	r1, sp, #84	; 0x54
     47e:	aa13      	add	r2, sp, #76	; 0x4c
     480:	4628      	mov	r0, r5
     482:	f7ff fffe 	bl	0 <ParseCertRelative>
     486:	9b14      	ldr	r3, [sp, #80]	; 0x50
     488:	2800      	cmp	r0, #0
     48a:	d169      	bne.n	560 <ParseCertRelative+0x560>
     48c:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
     490:	2aa0      	cmp	r2, #160	; 0xa0
     492:	d165      	bne.n	560 <ParseCertRelative+0x560>
            idx++;
     494:	3301      	adds	r3, #1
     496:	9314      	str	r3, [sp, #80]	; 0x50
            if (GetLength(input, &idx, &length, sz) < 0)
     498:	aa16      	add	r2, sp, #88	; 0x58
     49a:	4633      	mov	r3, r6
     49c:	a914      	add	r1, sp, #80	; 0x50
     49e:	4628      	mov	r0, r5
     4a0:	f7ff fffe 	bl	0 <ParseCertRelative>
     4a4:	2800      	cmp	r0, #0
     4a6:	f2c0 8085 	blt.w	5b4 <ParseCertRelative+0x5b4>
            localIdx = idx;
     4aa:	9a14      	ldr	r2, [sp, #80]	; 0x50
     4ac:	9215      	str	r2, [sp, #84]	; 0x54
            if (GetASNTag(input, &localIdx, &tag, sz) == 0 &&
     4ae:	a915      	add	r1, sp, #84	; 0x54
     4b0:	aa13      	add	r2, sp, #76	; 0x4c
     4b2:	4628      	mov	r0, r5
     4b4:	f7ff fffe 	bl	0 <ParseCertRelative>
     4b8:	9b14      	ldr	r3, [sp, #80]	; 0x50
     4ba:	2800      	cmp	r0, #0
     4bc:	d150      	bne.n	560 <ParseCertRelative+0x560>
     4be:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
     4c2:	2a86      	cmp	r2, #134	; 0x86
     4c4:	d14c      	bne.n	560 <ParseCertRelative+0x560>
                idx++;
     4c6:	3301      	adds	r3, #1
     4c8:	9314      	str	r3, [sp, #80]	; 0x50
                if (GetLength(input, &idx, &length, sz) < 0)
     4ca:	aa16      	add	r2, sp, #88	; 0x58
     4cc:	4633      	mov	r3, r6
     4ce:	a914      	add	r1, sp, #80	; 0x50
     4d0:	4628      	mov	r0, r5
     4d2:	f7ff fffe 	bl	0 <ParseCertRelative>
     4d6:	2800      	cmp	r0, #0
     4d8:	db6c      	blt.n	5b4 <ParseCertRelative+0x5b4>
                cert->extCrlInfo = input + idx;
     4da:	9a14      	ldr	r2, [sp, #80]	; 0x50
                cert->extCrlInfoSz = length;
     4dc:	9b16      	ldr	r3, [sp, #88]	; 0x58
     4de:	f8c9 32c8 	str.w	r3, [r9, #712]	; 0x2c8
                cert->extCrlInfo = input + idx;
     4e2:	18a9      	adds	r1, r5, r2
     4e4:	f8c9 12c4 	str.w	r1, [r9, #708]	; 0x2c4
            idx += (word32)length;
     4e8:	4413      	add	r3, r2
     4ea:	9314      	str	r3, [sp, #80]	; 0x50
    localIdx = idx;
     4ec:	9b14      	ldr	r3, [sp, #80]	; 0x50
     4ee:	9315      	str	r3, [sp, #84]	; 0x54
    if (idx < (word32)sz &&
     4f0:	429e      	cmp	r6, r3
     4f2:	d919      	bls.n	528 <ParseCertRelative+0x528>
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
     4f4:	4633      	mov	r3, r6
     4f6:	aa13      	add	r2, sp, #76	; 0x4c
     4f8:	a915      	add	r1, sp, #84	; 0x54
     4fa:	4628      	mov	r0, r5
     4fc:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (idx < (word32)sz &&
     500:	b990      	cbnz	r0, 528 <ParseCertRelative+0x528>
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
     502:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
     506:	2ba1      	cmp	r3, #161	; 0xa1
     508:	d10e      	bne.n	528 <ParseCertRelative+0x528>
        idx++;
     50a:	9b14      	ldr	r3, [sp, #80]	; 0x50
     50c:	3301      	adds	r3, #1
     50e:	9314      	str	r3, [sp, #80]	; 0x50
        if (GetLength(input, &idx, &length, sz) < 0)
     510:	aa16      	add	r2, sp, #88	; 0x58
     512:	4633      	mov	r3, r6
     514:	a914      	add	r1, sp, #80	; 0x50
     516:	4628      	mov	r0, r5
     518:	f7ff fffe 	bl	0 <ParseCertRelative>
     51c:	2800      	cmp	r0, #0
     51e:	db49      	blt.n	5b4 <ParseCertRelative+0x5b4>
        idx += (word32)length;
     520:	9b14      	ldr	r3, [sp, #80]	; 0x50
     522:	9a16      	ldr	r2, [sp, #88]	; 0x58
     524:	4413      	add	r3, r2
     526:	9314      	str	r3, [sp, #80]	; 0x50
    localIdx = idx;
     528:	9b14      	ldr	r3, [sp, #80]	; 0x50
     52a:	9315      	str	r3, [sp, #84]	; 0x54
    if (idx < (word32)sz &&
     52c:	429e      	cmp	r6, r3
     52e:	d979      	bls.n	624 <ParseCertRelative+0x624>
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
     530:	4633      	mov	r3, r6
     532:	aa13      	add	r2, sp, #76	; 0x4c
     534:	a915      	add	r1, sp, #84	; 0x54
     536:	4628      	mov	r0, r5
     538:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (idx < (word32)sz &&
     53c:	2800      	cmp	r0, #0
     53e:	d171      	bne.n	624 <ParseCertRelative+0x624>
        GetASNTag(input, &localIdx, &tag, sz) == 0 &&
     540:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
     544:	2ba2      	cmp	r3, #162	; 0xa2
     546:	d16d      	bne.n	624 <ParseCertRelative+0x624>
        idx++;
     548:	9b14      	ldr	r3, [sp, #80]	; 0x50
     54a:	3301      	adds	r3, #1
     54c:	9314      	str	r3, [sp, #80]	; 0x50
        if (GetLength(input, &idx, &length, sz) < 0)
     54e:	aa16      	add	r2, sp, #88	; 0x58
     550:	4633      	mov	r3, r6
     552:	a914      	add	r1, sp, #80	; 0x50
     554:	4628      	mov	r0, r5
     556:	f7ff fffe 	bl	0 <ParseCertRelative>
            if ((ret == 0) && (DecodeAuthKeyId(input, length, cert) < 0)) {
     55a:	2800      	cmp	r0, #0
     55c:	da62      	bge.n	624 <ParseCertRelative+0x624>
     55e:	e029      	b.n	5b4 <ParseCertRelative+0x5b4>
            idx += (word32)length;
     560:	9a16      	ldr	r2, [sp, #88]	; 0x58
     562:	e7c1      	b.n	4e8 <ParseCertRelative+0x4e8>
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
     564:	f899 3355 	ldrb.w	r3, [r9, #853]	; 0x355
     568:	0758      	lsls	r0, r3, #29
     56a:	f100 8428 	bmi.w	dbe <ParseCertRelative+0xdbe>
     56e:	f8d9 2354 	ldr.w	r2, [r9, #852]	; 0x354
            cert->extAuthInfoCrit = critical ? 1 : 0;
     572:	2f00      	cmp	r7, #0
     574:	bf14      	ite	ne
     576:	2301      	movne	r3, #1
     578:	2300      	moveq	r3, #0
            VERIFY_AND_SET_OID(cert->extAuthInfoSet);
     57a:	ea4f 43c3 	mov.w	r3, r3, lsl #19
     57e:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
     582:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
     586:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
     58a:	ea43 0302 	orr.w	r3, r3, r2
     58e:	f8c9 3354 	str.w	r3, [r9, #852]	; 0x354
            if (critical) {
     592:	f47f ae77 	bne.w	284 <ParseCertRelative+0x284>
    if (GetSequence(input, &idx, &length, sz) < 0)
     596:	f10d 0854 	add.w	r8, sp, #84	; 0x54
     59a:	ac14      	add	r4, sp, #80	; 0x50
     59c:	4633      	mov	r3, r6
     59e:	4642      	mov	r2, r8
     5a0:	4621      	mov	r1, r4
     5a2:	4628      	mov	r0, r5
    int length = 0;
     5a4:	e9cd 7714 	strd	r7, r7, [sp, #80]	; 0x50
    byte b = 0;
     5a8:	f88d 704c 	strb.w	r7, [sp, #76]	; 0x4c
    if (GetSequence(input, &idx, &length, sz) < 0)
     5ac:	f7ff fffe 	bl	0 <ParseCertRelative>
     5b0:	2800      	cmp	r0, #0
     5b2:	da05      	bge.n	5c0 <ParseCertRelative+0x5c0>
                return ASN_PARSE_E;
     5b4:	f06f 048b 	mvn.w	r4, #139	; 0x8b
     5b8:	f000 bc03 	b.w	dc2 <ParseCertRelative+0xdc2>
        idx += (word32)length;
     5bc:	4418      	add	r0, r3
     5be:	9014      	str	r0, [sp, #80]	; 0x50
    while ((idx < (word32)sz) && (count < MAX_AIA_SZ)) {
     5c0:	9b14      	ldr	r3, [sp, #80]	; 0x50
     5c2:	429e      	cmp	r6, r3
     5c4:	d92e      	bls.n	624 <ParseCertRelative+0x624>
        if (GetSequence(input, &idx, &length, sz) < 0)
     5c6:	4633      	mov	r3, r6
     5c8:	4642      	mov	r2, r8
     5ca:	4621      	mov	r1, r4
     5cc:	4628      	mov	r0, r5
     5ce:	f7ff fffe 	bl	0 <ParseCertRelative>
     5d2:	2800      	cmp	r0, #0
     5d4:	dbee      	blt.n	5b4 <ParseCertRelative+0x5b4>
        if (GetObjectId(input, &idx, &oid, oidCertAuthInfoType, sz) < 0) {
     5d6:	9600      	str	r6, [sp, #0]
     5d8:	2307      	movs	r3, #7
     5da:	aa16      	add	r2, sp, #88	; 0x58
     5dc:	4621      	mov	r1, r4
     5de:	4628      	mov	r0, r5
        oid = 0;
     5e0:	9716      	str	r7, [sp, #88]	; 0x58
        if (GetObjectId(input, &idx, &oid, oidCertAuthInfoType, sz) < 0) {
     5e2:	f7ff fffe 	bl	0 <ParseCertRelative>
     5e6:	2800      	cmp	r0, #0
     5e8:	dbe4      	blt.n	5b4 <ParseCertRelative+0x5b4>
        if (GetASNTag(input, &idx, &b, sz) < 0)
     5ea:	4633      	mov	r3, r6
     5ec:	aa13      	add	r2, sp, #76	; 0x4c
     5ee:	4621      	mov	r1, r4
     5f0:	4628      	mov	r0, r5
     5f2:	f7ff fffe 	bl	0 <ParseCertRelative>
     5f6:	2800      	cmp	r0, #0
     5f8:	dbdc      	blt.n	5b4 <ParseCertRelative+0x5b4>
        if (GetLength(input, &idx, &length, sz) < 0)
     5fa:	4633      	mov	r3, r6
     5fc:	4642      	mov	r2, r8
     5fe:	4628      	mov	r0, r5
     600:	f7ff fffe 	bl	0 <ParseCertRelative>
     604:	2800      	cmp	r0, #0
     606:	dbd5      	blt.n	5b4 <ParseCertRelative+0x5b4>
        if (b == GENERALNAME_URI && oid == AIA_OCSP_OID)
     608:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
     60c:	2b86      	cmp	r3, #134	; 0x86
     60e:	e9dd 0314 	ldrd	r0, r3, [sp, #80]	; 0x50
     612:	d1d3      	bne.n	5bc <ParseCertRelative+0x5bc>
     614:	9a16      	ldr	r2, [sp, #88]	; 0x58
     616:	2a74      	cmp	r2, #116	; 0x74
     618:	d1d0      	bne.n	5bc <ParseCertRelative+0x5bc>
            cert->extAuthInfo = input + idx;
     61a:	4428      	add	r0, r5
            cert->extAuthInfoSz = length;
     61c:	f8c9 32b8 	str.w	r3, [r9, #696]	; 0x2b8
            cert->extAuthInfo = input + idx;
     620:	f8c9 02b4 	str.w	r0, [r9, #692]	; 0x2b4
        idx += (word32)length;
     624:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
     628:	4413      	add	r3, r2
     62a:	930d      	str	r3, [sp, #52]	; 0x34
     62c:	e543      	b.n	b6 <ParseCertRelative+0xb6>
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
     62e:	f999 3355 	ldrsb.w	r3, [r9, #853]	; 0x355
     632:	2b00      	cmp	r3, #0
     634:	f2c0 83c3 	blt.w	dbe <ParseCertRelative+0xdbe>
            cert->extSubjAltNameCrit = critical ? 1 : 0;
     638:	3f00      	subs	r7, #0
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
     63a:	f8d9 3354 	ldr.w	r3, [r9, #852]	; 0x354
            cert->extSubjAltNameCrit = critical ? 1 : 0;
     63e:	bf18      	it	ne
     640:	2701      	movne	r7, #1
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
     642:	05bf      	lsls	r7, r7, #22
     644:	f423 0381 	bic.w	r3, r3, #4227072	; 0x408000
     648:	f447 4700 	orr.w	r7, r7, #32768	; 0x8000
     64c:	431f      	orrs	r7, r3
    if (GetSequence(input, &idx, &length, sz) < 0) {
     64e:	ac12      	add	r4, sp, #72	; 0x48
    word32 idx = 0;
     650:	2300      	movs	r3, #0
    int length = 0;
     652:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
            VERIFY_AND_SET_OID(cert->extSubjAltNameSet);
     656:	f8c9 7354 	str.w	r7, [r9, #852]	; 0x354
    if (GetSequence(input, &idx, &length, sz) < 0) {
     65a:	4633      	mov	r3, r6
     65c:	aa13      	add	r2, sp, #76	; 0x4c
     65e:	4621      	mov	r1, r4
     660:	4628      	mov	r0, r5
     662:	f7ff fffe 	bl	0 <ParseCertRelative>
     666:	2800      	cmp	r0, #0
     668:	dba4      	blt.n	5b4 <ParseCertRelative+0x5b4>
    if (length == 0) {
     66a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     66c:	2b00      	cmp	r3, #0
     66e:	d0a1      	beq.n	5b4 <ParseCertRelative+0x5b4>
    cert->weOwnAltNames = 1;
     670:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     674:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     678:	f889 3354 	strb.w	r3, [r9, #852]	; 0x354
    while (length > 0) {
     67c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
     67e:	2a00      	cmp	r2, #0
     680:	ddd0      	ble.n	624 <ParseCertRelative+0x624>
        if (idx >= (word32)sz) {
     682:	9b12      	ldr	r3, [sp, #72]	; 0x48
     684:	429e      	cmp	r6, r3
     686:	f240 85e6 	bls.w	1256 <ParseCertRelative+0x1256>
        current_byte = input[idx++];
     68a:	1c5f      	adds	r7, r3, #1
     68c:	9712      	str	r7, [sp, #72]	; 0x48
     68e:	5ceb      	ldrb	r3, [r5, r3]
        length--;
     690:	3a01      	subs	r2, #1
        if (current_byte == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {
     692:	2b82      	cmp	r3, #130	; 0x82
        length--;
     694:	9213      	str	r2, [sp, #76]	; 0x4c
        if (current_byte == (ASN_CONTEXT_SPECIFIC | ASN_DNS_TYPE)) {
     696:	d12c      	bne.n	6f2 <ParseCertRelative+0x6f2>
            if (GetLength(input, &idx, &strLen, sz) < 0) {
     698:	4633      	mov	r3, r6
     69a:	aa16      	add	r2, sp, #88	; 0x58
     69c:	4621      	mov	r1, r4
     69e:	4628      	mov	r0, r5
     6a0:	f7ff fffe 	bl	0 <ParseCertRelative>
     6a4:	2800      	cmp	r0, #0
     6a6:	db85      	blt.n	5b4 <ParseCertRelative+0x5b4>
            length -= (int)(idx - lenStartIdx);
     6a8:	9b12      	ldr	r3, [sp, #72]	; 0x48
            dnsEntry = AltNameNew(cert->heap);
     6aa:	f8d9 0280 	ldr.w	r0, [r9, #640]	; 0x280
            length -= (int)(idx - lenStartIdx);
     6ae:	1bdf      	subs	r7, r3, r7
     6b0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     6b2:	1bdb      	subs	r3, r3, r7
     6b4:	9313      	str	r3, [sp, #76]	; 0x4c
            dnsEntry = AltNameNew(cert->heap);
     6b6:	f7ff fffe 	bl	0 <ParseCertRelative>
            if (dnsEntry == NULL) {
     6ba:	4607      	mov	r7, r0
     6bc:	2800      	cmp	r0, #0
     6be:	d03f      	beq.n	740 <ParseCertRelative+0x740>
            dnsEntry->type = ASN_DNS_TYPE;
     6c0:	2302      	movs	r3, #2
            uriEntry->type = ASN_URI_TYPE;
     6c2:	607b      	str	r3, [r7, #4]
            uriEntry->name = (char*)XMALLOC((size_t)strLen + 1, cert->heap,
     6c4:	9816      	ldr	r0, [sp, #88]	; 0x58
     6c6:	3001      	adds	r0, #1
     6c8:	f7ff fffe 	bl	0 <malloc>
     6cc:	60f8      	str	r0, [r7, #12]
            if (uriEntry->name == NULL) {
     6ce:	2800      	cmp	r0, #0
     6d0:	d033      	beq.n	73a <ParseCertRelative+0x73a>
            uriEntry->len = strLen;
     6d2:	9a16      	ldr	r2, [sp, #88]	; 0x58
     6d4:	60ba      	str	r2, [r7, #8]
            XMEMCPY(uriEntry->name, &input[idx], (size_t)strLen);
     6d6:	9912      	ldr	r1, [sp, #72]	; 0x48
     6d8:	4429      	add	r1, r5
     6da:	f7ff fffe 	bl	0 <memcpy>
            uriEntry->name[strLen] = '\0';
     6de:	9b16      	ldr	r3, [sp, #88]	; 0x58
     6e0:	68fa      	ldr	r2, [r7, #12]
     6e2:	2100      	movs	r1, #0
     6e4:	54d1      	strb	r1, [r2, r3]
    dnsEntry->next = cert->altNames;
     6e6:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
     6ea:	603b      	str	r3, [r7, #0]
    cert->altNames = dnsEntry;
     6ec:	f8c9 7024 	str.w	r7, [r9, #36]	; 0x24
     6f0:	e038      	b.n	764 <ParseCertRelative+0x764>
        else if (current_byte ==
     6f2:	2ba4      	cmp	r3, #164	; 0xa4
     6f4:	d13e      	bne.n	774 <ParseCertRelative+0x774>
            if (GetLength(input, &idx, &strLen, sz) < 0) {
     6f6:	4633      	mov	r3, r6
     6f8:	aa16      	add	r2, sp, #88	; 0x58
     6fa:	4621      	mov	r1, r4
     6fc:	4628      	mov	r0, r5
     6fe:	f7ff fffe 	bl	0 <ParseCertRelative>
     702:	2800      	cmp	r0, #0
     704:	f6ff af56 	blt.w	5b4 <ParseCertRelative+0x5b4>
            if (GetSequence(input, &idx, &strLen, sz) < 0) {
     708:	4628      	mov	r0, r5
     70a:	f7ff fffe 	bl	0 <ParseCertRelative>
     70e:	2800      	cmp	r0, #0
     710:	f6ff af50 	blt.w	5b4 <ParseCertRelative+0x5b4>
            length -= (int)(idx - lenStartIdx);
     714:	9b12      	ldr	r3, [sp, #72]	; 0x48
            dirEntry = AltNameNew(cert->heap);
     716:	f8d9 0280 	ldr.w	r0, [r9, #640]	; 0x280
            length -= (int)(idx - lenStartIdx);
     71a:	1bdf      	subs	r7, r3, r7
     71c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     71e:	1bdb      	subs	r3, r3, r7
     720:	9313      	str	r3, [sp, #76]	; 0x4c
            dirEntry = AltNameNew(cert->heap);
     722:	f7ff fffe 	bl	0 <ParseCertRelative>
            if (dirEntry == NULL) {
     726:	4607      	mov	r7, r0
     728:	b150      	cbz	r0, 740 <ParseCertRelative+0x740>
            dirEntry->type = ASN_DIR_TYPE;
     72a:	2304      	movs	r3, #4
     72c:	6043      	str	r3, [r0, #4]
            dirEntry->name = (char*)XMALLOC((size_t)strLen + 1, cert->heap,
     72e:	9816      	ldr	r0, [sp, #88]	; 0x58
     730:	3001      	adds	r0, #1
     732:	f7ff fffe 	bl	0 <malloc>
     736:	60f8      	str	r0, [r7, #12]
            if (dirEntry->name == NULL) {
     738:	b928      	cbnz	r0, 746 <ParseCertRelative+0x746>
                XFREE(uriEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);
     73a:	4638      	mov	r0, r7
     73c:	f7ff fffe 	bl	0 <free>
                return MEMORY_E;
     740:	f06f 047c 	mvn.w	r4, #124	; 0x7c
     744:	e33d      	b.n	dc2 <ParseCertRelative+0xdc2>
            dirEntry->len = strLen;
     746:	9a16      	ldr	r2, [sp, #88]	; 0x58
     748:	60ba      	str	r2, [r7, #8]
            XMEMCPY(dirEntry->name, &input[idx], (size_t)strLen);
     74a:	9912      	ldr	r1, [sp, #72]	; 0x48
     74c:	4429      	add	r1, r5
     74e:	f7ff fffe 	bl	0 <memcpy>
            dirEntry->name[strLen] = '\0';
     752:	9b16      	ldr	r3, [sp, #88]	; 0x58
     754:	68fa      	ldr	r2, [r7, #12]
     756:	2100      	movs	r1, #0
     758:	54d1      	strb	r1, [r2, r3]
            dirEntry->next = cert->altDirNames;
     75a:	f8d9 302c 	ldr.w	r3, [r9, #44]	; 0x2c
     75e:	603b      	str	r3, [r7, #0]
            cert->altDirNames = dirEntry;
     760:	f8c9 702c 	str.w	r7, [r9, #44]	; 0x2c
            length -= strLen;
     764:	9916      	ldr	r1, [sp, #88]	; 0x58
     766:	9a13      	ldr	r2, [sp, #76]	; 0x4c
            idx    += (word32)strLen;
     768:	9b12      	ldr	r3, [sp, #72]	; 0x48
            length -= strLen;
     76a:	1a52      	subs	r2, r2, r1
     76c:	9213      	str	r2, [sp, #76]	; 0x4c
            idx    += (word32)strLen;
     76e:	440b      	add	r3, r1
            idx += (word32)strLen;
     770:	9312      	str	r3, [sp, #72]	; 0x48
     772:	e783      	b.n	67c <ParseCertRelative+0x67c>
        else if (current_byte == (ASN_CONTEXT_SPECIFIC | ASN_RFC822_TYPE)) {
     774:	2b81      	cmp	r3, #129	; 0x81
     776:	d12d      	bne.n	7d4 <ParseCertRelative+0x7d4>
            if (GetLength(input, &idx, &strLen, sz) < 0) {
     778:	4633      	mov	r3, r6
     77a:	aa16      	add	r2, sp, #88	; 0x58
     77c:	4621      	mov	r1, r4
     77e:	4628      	mov	r0, r5
     780:	f7ff fffe 	bl	0 <ParseCertRelative>
     784:	2800      	cmp	r0, #0
     786:	f6ff af15 	blt.w	5b4 <ParseCertRelative+0x5b4>
            length -= (int)(idx - lenStartIdx);
     78a:	9b12      	ldr	r3, [sp, #72]	; 0x48
            emailEntry = AltNameNew(cert->heap);
     78c:	f8d9 0280 	ldr.w	r0, [r9, #640]	; 0x280
            length -= (int)(idx - lenStartIdx);
     790:	1bdf      	subs	r7, r3, r7
     792:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     794:	1bdb      	subs	r3, r3, r7
     796:	9313      	str	r3, [sp, #76]	; 0x4c
            emailEntry = AltNameNew(cert->heap);
     798:	f7ff fffe 	bl	0 <ParseCertRelative>
            if (emailEntry == NULL) {
     79c:	4607      	mov	r7, r0
     79e:	2800      	cmp	r0, #0
     7a0:	d0ce      	beq.n	740 <ParseCertRelative+0x740>
            emailEntry->type = ASN_RFC822_TYPE;
     7a2:	2301      	movs	r3, #1
     7a4:	6043      	str	r3, [r0, #4]
            emailEntry->name = (char*)XMALLOC((size_t)strLen + 1, cert->heap,
     7a6:	9816      	ldr	r0, [sp, #88]	; 0x58
     7a8:	4418      	add	r0, r3
     7aa:	f7ff fffe 	bl	0 <malloc>
     7ae:	60f8      	str	r0, [r7, #12]
            if (emailEntry->name == NULL) {
     7b0:	2800      	cmp	r0, #0
     7b2:	d0c2      	beq.n	73a <ParseCertRelative+0x73a>
            emailEntry->len = strLen;
     7b4:	9a16      	ldr	r2, [sp, #88]	; 0x58
     7b6:	60ba      	str	r2, [r7, #8]
            XMEMCPY(emailEntry->name, &input[idx], (size_t)strLen);
     7b8:	9912      	ldr	r1, [sp, #72]	; 0x48
     7ba:	4429      	add	r1, r5
     7bc:	f7ff fffe 	bl	0 <memcpy>
            emailEntry->name[strLen] = '\0';
     7c0:	9b16      	ldr	r3, [sp, #88]	; 0x58
     7c2:	68fa      	ldr	r2, [r7, #12]
     7c4:	2100      	movs	r1, #0
     7c6:	54d1      	strb	r1, [r2, r3]
            emailEntry->next = cert->altEmailNames;
     7c8:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
     7cc:	603b      	str	r3, [r7, #0]
            cert->altEmailNames = emailEntry;
     7ce:	f8c9 7028 	str.w	r7, [r9, #40]	; 0x28
            length -= strLen;
     7d2:	e7c7      	b.n	764 <ParseCertRelative+0x764>
        else if (current_byte == (ASN_CONTEXT_SPECIFIC | ASN_URI_TYPE)) {
     7d4:	2b86      	cmp	r3, #134	; 0x86
     7d6:	d122      	bne.n	81e <ParseCertRelative+0x81e>
            if (GetLength(input, &idx, &strLen, sz) < 0) {
     7d8:	4633      	mov	r3, r6
     7da:	aa16      	add	r2, sp, #88	; 0x58
     7dc:	4621      	mov	r1, r4
     7de:	4628      	mov	r0, r5
     7e0:	f7ff fffe 	bl	0 <ParseCertRelative>
     7e4:	2800      	cmp	r0, #0
     7e6:	f6ff aee5 	blt.w	5b4 <ParseCertRelative+0x5b4>
            length -= (int)(idx - lenStartIdx);
     7ea:	9b12      	ldr	r3, [sp, #72]	; 0x48
     7ec:	9a13      	ldr	r2, [sp, #76]	; 0x4c
            if ((word32)strLen + idx > sz) {
     7ee:	9916      	ldr	r1, [sp, #88]	; 0x58
            length -= (int)(idx - lenStartIdx);
     7f0:	1bdf      	subs	r7, r3, r7
     7f2:	1bd2      	subs	r2, r2, r7
     7f4:	9213      	str	r2, [sp, #76]	; 0x4c
            if ((word32)strLen + idx > sz) {
     7f6:	185a      	adds	r2, r3, r1
     7f8:	4296      	cmp	r6, r2
     7fa:	f0c0 852c 	bcc.w	1256 <ParseCertRelative+0x1256>
     7fe:	442b      	add	r3, r5
                for (i = 0; i < (word32)strLen; i++) {
     800:	2200      	movs	r2, #0
     802:	4291      	cmp	r1, r2
     804:	d102      	bne.n	80c <ParseCertRelative+0x80c>
                        return ASN_ALT_NAME_E;
     806:	f06f 04a0 	mvn.w	r4, #160	; 0xa0
        if (ret == ASN_CRIT_EXT_E) {
     80a:	e2da      	b.n	dc2 <ParseCertRelative+0xdc2>
                    if (input[idx + i] == ':') {
     80c:	f813 0b01 	ldrb.w	r0, [r3], #1
     810:	283a      	cmp	r0, #58	; 0x3a
     812:	f000 850d 	beq.w	1230 <ParseCertRelative+0x1230>
                    if (input[idx + i] == '/') {
     816:	282f      	cmp	r0, #47	; 0x2f
     818:	d0f5      	beq.n	806 <ParseCertRelative+0x806>
                for (i = 0; i < (word32)strLen; i++) {
     81a:	3201      	adds	r2, #1
     81c:	e7f1      	b.n	802 <ParseCertRelative+0x802>
        else if (current_byte ==
     81e:	2ba0      	cmp	r3, #160	; 0xa0
     820:	f040 808a 	bne.w	938 <ParseCertRelative+0x938>
            word32 oid = 0;
     824:	2300      	movs	r3, #0
     826:	9315      	str	r3, [sp, #84]	; 0x54
            if (GetLength(input, &idx, &strLen, sz) < 0) {
     828:	aa14      	add	r2, sp, #80	; 0x50
     82a:	4633      	mov	r3, r6
     82c:	4621      	mov	r1, r4
     82e:	4628      	mov	r0, r5
     830:	f7ff fffe 	bl	0 <ParseCertRelative>
     834:	2800      	cmp	r0, #0
     836:	f6ff aebd 	blt.w	5b4 <ParseCertRelative+0x5b4>
            length -= (int)(((word32)strLen + idx - lenStartIdx));
     83a:	9a12      	ldr	r2, [sp, #72]	; 0x48
     83c:	9b14      	ldr	r3, [sp, #80]	; 0x50
            if (GetObjectId(input, &idx, &oid, oidCertAltNameType, sz) < 0) {
     83e:	9600      	str	r6, [sp, #0]
            length -= (int)(((word32)strLen + idx - lenStartIdx));
     840:	4413      	add	r3, r2
     842:	1bdf      	subs	r7, r3, r7
     844:	9b13      	ldr	r3, [sp, #76]	; 0x4c
            if (GetObjectId(input, &idx, &oid, oidCertAltNameType, sz) < 0) {
     846:	aa15      	add	r2, sp, #84	; 0x54
            length -= (int)(((word32)strLen + idx - lenStartIdx));
     848:	1bdf      	subs	r7, r3, r7
            if (GetObjectId(input, &idx, &oid, oidCertAltNameType, sz) < 0) {
     84a:	4628      	mov	r0, r5
     84c:	2309      	movs	r3, #9
            length -= (int)(((word32)strLen + idx - lenStartIdx));
     84e:	9713      	str	r7, [sp, #76]	; 0x4c
            if (GetObjectId(input, &idx, &oid, oidCertAltNameType, sz) < 0) {
     850:	f7ff fffe 	bl	0 <ParseCertRelative>
     854:	2800      	cmp	r0, #0
     856:	f6ff aead 	blt.w	5b4 <ParseCertRelative+0x5b4>
                    if (GetLength(input, &idx, &strLen, sz) < 0) {
     85a:	4633      	mov	r3, r6
     85c:	aa14      	add	r2, sp, #80	; 0x50
     85e:	4621      	mov	r1, r4
     860:	4628      	mov	r0, r5
     862:	f7ff fffe 	bl	0 <ParseCertRelative>
     866:	2800      	cmp	r0, #0
     868:	da63      	bge.n	932 <ParseCertRelative+0x932>
    int strLen = 0;
     86a:	2300      	movs	r3, #0
     86c:	9316      	str	r3, [sp, #88]	; 0x58
    if (GetASNTag(input, idx, &tag, sz) < 0) {
     86e:	aa11      	add	r2, sp, #68	; 0x44
     870:	4633      	mov	r3, r6
     872:	4628      	mov	r0, r5
                        if (DecodeConstructedOtherName(cert, input, &idx, sz,
     874:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
    if (GetASNTag(input, idx, &tag, sz) < 0) {
     878:	f7ff fffe 	bl	0 <ParseCertRelative>
     87c:	2800      	cmp	r0, #0
     87e:	f6ff ae99 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (ret == 0 && (tag != (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED))) {
     882:	f89d 3044 	ldrb.w	r3, [sp, #68]	; 0x44
     886:	2ba0      	cmp	r3, #160	; 0xa0
     888:	f47f ae94 	bne.w	5b4 <ParseCertRelative+0x5b4>
    if (ret == 0 && (GetLength(input, idx, &strLen, sz) < 0)) {
     88c:	4633      	mov	r3, r6
     88e:	aa16      	add	r2, sp, #88	; 0x58
     890:	4628      	mov	r0, r5
     892:	f7ff fffe 	bl	0 <ParseCertRelative>
     896:	2800      	cmp	r0, #0
     898:	f6ff ae8c 	blt.w	5b4 <ParseCertRelative+0x5b4>
        dnsEntry = AltNameNew(cert->heap);
     89c:	f8d9 0280 	ldr.w	r0, [r9, #640]	; 0x280
     8a0:	f7ff fffe 	bl	0 <ParseCertRelative>
        if (dnsEntry == NULL) {
     8a4:	4607      	mov	r7, r0
     8a6:	2800      	cmp	r0, #0
     8a8:	f43f ae84 	beq.w	5b4 <ParseCertRelative+0x5b4>
        switch (oid) {
     8ac:	f240 1309 	movw	r3, #265	; 0x109
     8b0:	4598      	cmp	r8, r3
     8b2:	d11f      	bne.n	8f4 <ParseCertRelative+0x8f4>
                if (GetASNTag(input, idx, &tag, sz) < 0) {
     8b4:	4633      	mov	r3, r6
     8b6:	aa11      	add	r2, sp, #68	; 0x44
     8b8:	4621      	mov	r1, r4
     8ba:	4628      	mov	r0, r5
     8bc:	f7ff fffe 	bl	0 <ParseCertRelative>
     8c0:	2800      	cmp	r0, #0
     8c2:	db13      	blt.n	8ec <ParseCertRelative+0x8ec>
                        tag != ASN_PRINTABLE_STRING && tag != ASN_UTF8STRING &&
     8c4:	f89d 8044 	ldrb.w	r8, [sp, #68]	; 0x44
     8c8:	f1b8 0f16 	cmp.w	r8, #22
     8cc:	d80e      	bhi.n	8ec <ParseCertRelative+0x8ec>
     8ce:	4bb4      	ldr	r3, [pc, #720]	; (ba0 <ParseCertRelative+0xba0>)
     8d0:	fa23 f808 	lsr.w	r8, r3, r8
     8d4:	ea6f 0808 	mvn.w	r8, r8
     8d8:	f018 0801 	ands.w	r8, r8, #1
     8dc:	d106      	bne.n	8ec <ParseCertRelative+0x8ec>
                if (ret == 0 && (GetLength(input, idx, &strLen, sz) < 0)) {
     8de:	4633      	mov	r3, r6
     8e0:	aa16      	add	r2, sp, #88	; 0x58
     8e2:	4628      	mov	r0, r5
     8e4:	f7ff fffe 	bl	0 <ParseCertRelative>
     8e8:	2800      	cmp	r0, #0
     8ea:	da09      	bge.n	900 <ParseCertRelative+0x900>
        XFREE(dnsEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);
     8ec:	4638      	mov	r0, r7
                XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);
     8ee:	f7ff fffe 	bl	0 <free>
                return MEMORY_E;
     8f2:	e65f      	b.n	5b4 <ParseCertRelative+0x5b4>
                XFREE(dnsEntry, cert->heap, DYNAMIC_TYPE_ALTNAME);
     8f4:	f7ff fffe 	bl	0 <free>
        *idx += (word32)strLen;
     8f8:	9b12      	ldr	r3, [sp, #72]	; 0x48
     8fa:	9a16      	ldr	r2, [sp, #88]	; 0x58
                        idx += (word32)strLen;
     8fc:	4413      	add	r3, r2
     8fe:	e737      	b.n	770 <ParseCertRelative+0x770>
        dnsEntry->type = ASN_OTHER_TYPE;
     900:	f8c7 8004 	str.w	r8, [r7, #4]
        dnsEntry->len = strLen;
     904:	9816      	ldr	r0, [sp, #88]	; 0x58
     906:	60b8      	str	r0, [r7, #8]
        dnsEntry->name = (char*)XMALLOC((size_t)strLen + 1, cert->heap,
     908:	3001      	adds	r0, #1
     90a:	f7ff fffe 	bl	0 <malloc>
     90e:	60f8      	str	r0, [r7, #12]
        if (dnsEntry->name == NULL) {
     910:	2800      	cmp	r0, #0
     912:	d0eb      	beq.n	8ec <ParseCertRelative+0x8ec>
            XMEMCPY(dnsEntry->name, &input[*idx], (size_t)strLen);
     914:	9912      	ldr	r1, [sp, #72]	; 0x48
     916:	9a16      	ldr	r2, [sp, #88]	; 0x58
     918:	4429      	add	r1, r5
     91a:	f7ff fffe 	bl	0 <memcpy>
            dnsEntry->name[strLen] = '\0';
     91e:	9b16      	ldr	r3, [sp, #88]	; 0x58
     920:	68fa      	ldr	r2, [r7, #12]
     922:	2100      	movs	r1, #0
     924:	54d1      	strb	r1, [r2, r3]
    dnsEntry->next = cert->altNames;
     926:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
     92a:	603b      	str	r3, [r7, #0]
    cert->altNames = dnsEntry;
     92c:	f8c9 7024 	str.w	r7, [r9, #36]	; 0x24
    if (ret == 0) {
     930:	e7e2      	b.n	8f8 <ParseCertRelative+0x8f8>
                        idx += (word32)strLen;
     932:	9b12      	ldr	r3, [sp, #72]	; 0x48
     934:	9a14      	ldr	r2, [sp, #80]	; 0x50
     936:	e7e1      	b.n	8fc <ParseCertRelative+0x8fc>
            if (GetLength(input, &idx, &strLen, sz) < 0) {
     938:	4633      	mov	r3, r6
     93a:	aa16      	add	r2, sp, #88	; 0x58
     93c:	4621      	mov	r1, r4
     93e:	4628      	mov	r0, r5
     940:	f7ff fffe 	bl	0 <ParseCertRelative>
     944:	2800      	cmp	r0, #0
     946:	f6ff ae35 	blt.w	5b4 <ParseCertRelative+0x5b4>
            length -= (int)((word32)strLen + idx - lenStartIdx);
     94a:	9a12      	ldr	r2, [sp, #72]	; 0x48
     94c:	9b16      	ldr	r3, [sp, #88]	; 0x58
     94e:	4413      	add	r3, r2
     950:	9a13      	ldr	r2, [sp, #76]	; 0x4c
     952:	1bdf      	subs	r7, r3, r7
     954:	1bd7      	subs	r7, r2, r7
     956:	9713      	str	r7, [sp, #76]	; 0x4c
     958:	e70a      	b.n	770 <ParseCertRelative+0x770>
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
     95a:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     95e:	0759      	lsls	r1, r3, #29
     960:	f100 822d 	bmi.w	dbe <ParseCertRelative+0xdbe>
     964:	f8d9 2354 	ldr.w	r2, [r9, #852]	; 0x354
            cert->extAuthKeyIdCrit = critical ? 1 : 0;
     968:	2f00      	cmp	r7, #0
     96a:	bf14      	ite	ne
     96c:	2301      	movne	r3, #1
     96e:	2300      	moveq	r3, #0
            VERIFY_AND_SET_OID(cert->extAuthKeyIdSet);
     970:	ea4f 53c3 	mov.w	r3, r3, lsl #23
     974:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
     978:	f043 0304 	orr.w	r3, r3, #4
     97c:	f022 0204 	bic.w	r2, r2, #4
     980:	ea43 0302 	orr.w	r3, r3, r2
     984:	f8c9 3354 	str.w	r3, [r9, #852]	; 0x354
            if (critical) {
     988:	f47f ac7c 	bne.w	284 <ParseCertRelative+0x284>
    if (GetSequence(input, &idx, &length, sz) < 0) {
     98c:	4633      	mov	r3, r6
     98e:	aa16      	add	r2, sp, #88	; 0x58
     990:	a915      	add	r1, sp, #84	; 0x54
     992:	4628      	mov	r0, r5
    int length = 0;
     994:	e9cd 7715 	strd	r7, r7, [sp, #84]	; 0x54
    if (GetSequence(input, &idx, &length, sz) < 0) {
     998:	f7ff fffe 	bl	0 <ParseCertRelative>
     99c:	2800      	cmp	r0, #0
     99e:	f6ff ae09 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (GetASNTag(input, &idx, &tag, sz) < 0) {
     9a2:	4633      	mov	r3, r6
     9a4:	aa14      	add	r2, sp, #80	; 0x50
     9a6:	a915      	add	r1, sp, #84	; 0x54
     9a8:	4628      	mov	r0, r5
     9aa:	f7ff fffe 	bl	0 <ParseCertRelative>
     9ae:	2800      	cmp	r0, #0
     9b0:	f6ff ae00 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (tag != (ASN_CONTEXT_SPECIFIC | 0)) {
     9b4:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
     9b8:	2b80      	cmp	r3, #128	; 0x80
     9ba:	d004      	beq.n	9c6 <ParseCertRelative+0x9c6>
        cert->extAuthKeyIdSet = 0;
     9bc:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     9c0:	f367 0382 	bfi	r3, r7, #2, #1
     9c4:	e50e      	b.n	3e4 <ParseCertRelative+0x3e4>
    if (GetLength(input, &idx, &length, sz) <= 0) {
     9c6:	4633      	mov	r3, r6
     9c8:	aa16      	add	r2, sp, #88	; 0x58
     9ca:	4628      	mov	r0, r5
     9cc:	f7ff fffe 	bl	0 <ParseCertRelative>
     9d0:	2800      	cmp	r0, #0
     9d2:	f77f adef 	ble.w	5b4 <ParseCertRelative+0x5b4>
    return GetHashId(input + idx, length, cert->extAuthKeyId,
     9d6:	9815      	ldr	r0, [sp, #84]	; 0x54
     9d8:	9916      	ldr	r1, [sp, #88]	; 0x58
     9da:	4405      	add	r5, r0
     9dc:	f509 7038 	add.w	r0, r9, #736	; 0x2e0
    if (length == KEYID_SIZE)
     9e0:	2914      	cmp	r1, #20
     9e2:	d104      	bne.n	9ee <ParseCertRelative+0x9ee>
        XMEMCPY(hash, id, (size_t)length);
     9e4:	460a      	mov	r2, r1
     9e6:	4629      	mov	r1, r5
     9e8:	f7ff fffe 	bl	0 <memcpy>
    return ret;
     9ec:	e61a      	b.n	624 <ParseCertRelative+0x624>
        ret = wc_ShaHash(data, len, hash);
     9ee:	4602      	mov	r2, r0
     9f0:	4628      	mov	r0, r5
     9f2:	f7ff fffe 	bl	0 <wc_ShaHash>
     9f6:	e5b0      	b.n	55a <ParseCertRelative+0x55a>
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
     9f8:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     9fc:	079a      	lsls	r2, r3, #30
     9fe:	f100 81de 	bmi.w	dbe <ParseCertRelative+0xdbe>
     a02:	f8d9 2354 	ldr.w	r2, [r9, #852]	; 0x354
            cert->extSubjKeyIdCrit = critical ? 1 : 0;
     a06:	2f00      	cmp	r7, #0
     a08:	bf14      	ite	ne
     a0a:	2301      	movne	r3, #1
     a0c:	2300      	moveq	r3, #0
            VERIFY_AND_SET_OID(cert->extSubjKeyIdSet);
     a0e:	ea4f 6343 	mov.w	r3, r3, lsl #25
     a12:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
     a16:	f043 0302 	orr.w	r3, r3, #2
     a1a:	f022 0202 	bic.w	r2, r2, #2
     a1e:	ea43 0302 	orr.w	r3, r3, r2
     a22:	f8c9 3354 	str.w	r3, [r9, #852]	; 0x354
            if (critical) {
     a26:	f47f ac2d 	bne.w	284 <ParseCertRelative+0x284>
    ret = GetOctetString(input, &idx, &length, sz);
     a2a:	4633      	mov	r3, r6
     a2c:	aa16      	add	r2, sp, #88	; 0x58
     a2e:	a915      	add	r1, sp, #84	; 0x54
     a30:	4628      	mov	r0, r5
    int length = 0;
     a32:	e9cd 7715 	strd	r7, r7, [sp, #84]	; 0x54
    ret = GetOctetString(input, &idx, &length, sz);
     a36:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (ret > 0) {
     a3a:	2800      	cmp	r0, #0
     a3c:	f77f ad8d 	ble.w	55a <ParseCertRelative+0x55a>
        ret = GetHashId(input + idx, length, cert->extSubjKeyId,
     a40:	9815      	ldr	r0, [sp, #84]	; 0x54
     a42:	9916      	ldr	r1, [sp, #88]	; 0x58
     a44:	4405      	add	r5, r0
     a46:	f509 7033 	add.w	r0, r9, #716	; 0x2cc
     a4a:	e7c9      	b.n	9e0 <ParseCertRelative+0x9e0>
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
     a4c:	f999 3354 	ldrsb.w	r3, [r9, #852]	; 0x354
     a50:	2b00      	cmp	r3, #0
     a52:	f2c0 81b4 	blt.w	dbe <ParseCertRelative+0xdbe>
     a56:	f8d9 3354 	ldr.w	r3, [r9, #852]	; 0x354
            cert->extKeyUsageCrit = critical ? 1 : 0;
     a5a:	3f00      	subs	r7, #0
     a5c:	bf18      	it	ne
     a5e:	2701      	movne	r7, #1
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
     a60:	06bf      	lsls	r7, r7, #26
     a62:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
     a66:	f023 0380 	bic.w	r3, r3, #128	; 0x80
     a6a:	f047 0780 	orr.w	r7, r7, #128	; 0x80
     a6e:	431f      	orrs	r7, r3
    word32 idx = 0;
     a70:	2300      	movs	r3, #0
            VERIFY_AND_SET_OID(cert->extKeyUsageSet);
     a72:	f8c9 7354 	str.w	r7, [r9, #852]	; 0x354
    word32 idx = 0;
     a76:	9315      	str	r3, [sp, #84]	; 0x54
    ret = CheckBitString(input, &idx, &length, sz, 0, NULL);
     a78:	e9cd 3300 	strd	r3, r3, [sp]
     a7c:	aa16      	add	r2, sp, #88	; 0x58
     a7e:	4633      	mov	r3, r6
     a80:	a915      	add	r1, sp, #84	; 0x54
     a82:	4628      	mov	r0, r5
     a84:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (ret != 0)
     a88:	2800      	cmp	r0, #0
     a8a:	f47f ad67 	bne.w	55c <ParseCertRelative+0x55c>
    if (length == 0 || length > 2)
     a8e:	9b16      	ldr	r3, [sp, #88]	; 0x58
     a90:	2b00      	cmp	r3, #0
     a92:	f43f ad8f 	beq.w	5b4 <ParseCertRelative+0x5b4>
     a96:	2b02      	cmp	r3, #2
     a98:	f73f ad8c 	bgt.w	5b4 <ParseCertRelative+0x5b4>
    cert->extKeyUsage = (word16)(input[idx]);
     a9c:	9815      	ldr	r0, [sp, #84]	; 0x54
     a9e:	5c2b      	ldrb	r3, [r5, r0]
     aa0:	f8a9 32f8 	strh.w	r3, [r9, #760]	; 0x2f8
    if (length == 2)
     aa4:	f47f adbe 	bne.w	624 <ParseCertRelative+0x624>
        cert->extKeyUsage |= (word16)(input[idx+1] << 8);
     aa8:	4428      	add	r0, r5
     aaa:	7842      	ldrb	r2, [r0, #1]
     aac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
     ab0:	f8a9 32f8 	strh.w	r3, [r9, #760]	; 0x2f8
     ab4:	e5b6      	b.n	624 <ParseCertRelative+0x624>
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
     ab6:	f899 2355 	ldrb.w	r2, [r9, #853]	; 0x355
     aba:	f012 0201 	ands.w	r2, r2, #1
     abe:	f040 817e 	bne.w	dbe <ParseCertRelative+0xdbe>
            cert->extExtKeyUsageCrit = critical ? 1 : 0;
     ac2:	3f00      	subs	r7, #0
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
     ac4:	f8d9 3354 	ldr.w	r3, [r9, #852]	; 0x354
    word32 idx = 0, oid;
     ac8:	9214      	str	r2, [sp, #80]	; 0x50
            cert->extExtKeyUsageCrit = critical ? 1 : 0;
     aca:	bf18      	it	ne
     acc:	2701      	movne	r7, #1
            VERIFY_AND_SET_OID(cert->extExtKeyUsageSet);
     ace:	06ff      	lsls	r7, r7, #27
     ad0:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
     ad4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
     ad8:	f447 7780 	orr.w	r7, r7, #256	; 0x100
     adc:	431f      	orrs	r7, r3
     ade:	f8c9 7354 	str.w	r7, [r9, #852]	; 0x354
    if (GetSequence(input, &idx, &length, sz) < 0) {
     ae2:	4633      	mov	r3, r6
     ae4:	aa16      	add	r2, sp, #88	; 0x58
     ae6:	a914      	add	r1, sp, #80	; 0x50
     ae8:	4628      	mov	r0, r5
     aea:	f7ff fffe 	bl	0 <ParseCertRelative>
     aee:	2800      	cmp	r0, #0
     af0:	f6ff ad60 	blt.w	5b4 <ParseCertRelative+0x5b4>
    while (idx < (word32)sz) {
     af4:	9b14      	ldr	r3, [sp, #80]	; 0x50
     af6:	429e      	cmp	r6, r3
     af8:	f67f ad94 	bls.w	624 <ParseCertRelative+0x624>
        ret = GetObjectId(input, &idx, &oid, oidCertKeyUseType, sz);
     afc:	9600      	str	r6, [sp, #0]
     afe:	230a      	movs	r3, #10
     b00:	aa15      	add	r2, sp, #84	; 0x54
     b02:	a914      	add	r1, sp, #80	; 0x50
     b04:	4628      	mov	r0, r5
     b06:	f7ff fffe 	bl	0 <ParseCertRelative>
        if (ret == ASN_UNKNOWN_OID_E)
     b0a:	f110 0f94 	cmn.w	r0, #148	; 0x94
     b0e:	d0f1      	beq.n	af4 <ParseCertRelative+0xaf4>
        else if (ret < 0)
     b10:	2800      	cmp	r0, #0
     b12:	f6ff ad4f 	blt.w	5b4 <ParseCertRelative+0x5b4>
        switch (oid) {
     b16:	9b15      	ldr	r3, [sp, #84]	; 0x54
     b18:	2b4f      	cmp	r3, #79	; 0x4f
     b1a:	d819      	bhi.n	b50 <ParseCertRelative+0xb50>
     b1c:	2b46      	cmp	r3, #70	; 0x46
     b1e:	d9e9      	bls.n	af4 <ParseCertRelative+0xaf4>
     b20:	3b47      	subs	r3, #71	; 0x47
     b22:	2b08      	cmp	r3, #8
     b24:	d8e6      	bhi.n	af4 <ParseCertRelative+0xaf4>
     b26:	a201      	add	r2, pc, #4	; (adr r2, b2c <ParseCertRelative+0xb2c>)
     b28:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     b2c:	00000b63 	.word	0x00000b63
     b30:	00000b6d 	.word	0x00000b6d
     b34:	00000b77 	.word	0x00000b77
     b38:	00000b81 	.word	0x00000b81
     b3c:	00000af5 	.word	0x00000af5
     b40:	00000af5 	.word	0x00000af5
     b44:	00000af5 	.word	0x00000af5
     b48:	00000b8b 	.word	0x00000b8b
     b4c:	00000b95 	.word	0x00000b95
     b50:	2b97      	cmp	r3, #151	; 0x97
     b52:	d1cf      	bne.n	af4 <ParseCertRelative+0xaf4>
                cert->extExtKeyUsage |= EXTKEYUSE_ANY;
     b54:	f899 32fa 	ldrb.w	r3, [r9, #762]	; 0x2fa
     b58:	f043 0301 	orr.w	r3, r3, #1
                cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;
     b5c:	f889 32fa 	strb.w	r3, [r9, #762]	; 0x2fa
                break;
     b60:	e7c8      	b.n	af4 <ParseCertRelative+0xaf4>
                cert->extExtKeyUsage |= EXTKEYUSE_SERVER_AUTH;
     b62:	f899 32fa 	ldrb.w	r3, [r9, #762]	; 0x2fa
     b66:	f043 0302 	orr.w	r3, r3, #2
     b6a:	e7f7      	b.n	b5c <ParseCertRelative+0xb5c>
                cert->extExtKeyUsage |= EXTKEYUSE_CLIENT_AUTH;
     b6c:	f899 32fa 	ldrb.w	r3, [r9, #762]	; 0x2fa
     b70:	f043 0304 	orr.w	r3, r3, #4
     b74:	e7f2      	b.n	b5c <ParseCertRelative+0xb5c>
                cert->extExtKeyUsage |= EXTKEYUSE_CODESIGN;
     b76:	f899 32fa 	ldrb.w	r3, [r9, #762]	; 0x2fa
     b7a:	f043 0308 	orr.w	r3, r3, #8
     b7e:	e7ed      	b.n	b5c <ParseCertRelative+0xb5c>
                cert->extExtKeyUsage |= EXTKEYUSE_EMAILPROT;
     b80:	f899 32fa 	ldrb.w	r3, [r9, #762]	; 0x2fa
     b84:	f043 0310 	orr.w	r3, r3, #16
     b88:	e7e8      	b.n	b5c <ParseCertRelative+0xb5c>
                cert->extExtKeyUsage |= EXTKEYUSE_TIMESTAMP;
     b8a:	f899 32fa 	ldrb.w	r3, [r9, #762]	; 0x2fa
     b8e:	f043 0320 	orr.w	r3, r3, #32
     b92:	e7e3      	b.n	b5c <ParseCertRelative+0xb5c>
                cert->extExtKeyUsage |= EXTKEYUSE_OCSP_SIGN;
     b94:	f899 32fa 	ldrb.w	r3, [r9, #762]	; 0x2fa
     b98:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     b9c:	e7de      	b.n	b5c <ParseCertRelative+0xb5c>
     b9e:	bf00      	nop
     ba0:	00481000 	.word	0x00481000
            if (!cert->isCA) {
     ba4:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
                ret = ASN_NAME_INVALID_E;
     ba8:	f013 0f10 	tst.w	r3, #16
     bac:	bf14      	ite	ne
     bae:	2400      	movne	r4, #0
     bb0:	f06f 04c5 	mvneq.w	r4, #197	; 0xc5
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
     bb4:	f013 0308 	ands.w	r3, r3, #8
     bb8:	f040 8101 	bne.w	dbe <ParseCertRelative+0xdbe>
            cert->extNameConstraintCrit = critical ? 1 : 0;
     bbc:	3f00      	subs	r7, #0
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
     bbe:	f8d9 2354 	ldr.w	r2, [r9, #852]	; 0x354
            cert->extNameConstraintCrit = critical ? 1 : 0;
     bc2:	bf18      	it	ne
     bc4:	2701      	movne	r7, #1
            VERIFY_AND_SET_OID(cert->extNameConstraintSet);
     bc6:	063f      	lsls	r7, r7, #24
     bc8:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
     bcc:	f022 0208 	bic.w	r2, r2, #8
     bd0:	f047 0708 	orr.w	r7, r7, #8
     bd4:	4317      	orrs	r7, r2
     bd6:	f8c9 7354 	str.w	r7, [r9, #852]	; 0x354
    if (GetSequence(input, &idx, &length, sz) < 0) {
     bda:	af12      	add	r7, sp, #72	; 0x48
    int length = 0;
     bdc:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
    if (GetSequence(input, &idx, &length, sz) < 0) {
     be0:	463a      	mov	r2, r7
     be2:	4633      	mov	r3, r6
     be4:	a911      	add	r1, sp, #68	; 0x44
     be6:	4628      	mov	r0, r5
     be8:	f7ff fffe 	bl	0 <ParseCertRelative>
     bec:	2800      	cmp	r0, #0
     bee:	f6ff ace1 	blt.w	5b4 <ParseCertRelative+0x5b4>
        if (GetLength(input, &idx, &length, sz) <= 0) {
     bf2:	9709      	str	r7, [sp, #36]	; 0x24
    while (idx < (word32)sz) {
     bf4:	9b11      	ldr	r3, [sp, #68]	; 0x44
     bf6:	429e      	cmp	r6, r3
     bf8:	d807      	bhi.n	c0a <ParseCertRelative+0xc0a>
        if (ret < 0)
     bfa:	2c00      	cmp	r4, #0
     bfc:	f43f ad12 	beq.w	624 <ParseCertRelative+0x624>
                if (ret == ASN_CRIT_EXT_E)
     c00:	f114 0fa0 	cmn.w	r4, #160	; 0xa0
     c04:	f43f aa5d 	beq.w	c2 <ParseCertRelative+0xc2>
     c08:	e0db      	b.n	dc2 <ParseCertRelative+0xdc2>
        byte b = input[idx++];
     c0a:	1c5a      	adds	r2, r3, #1
     c0c:	9211      	str	r2, [sp, #68]	; 0x44
     c0e:	5cef      	ldrb	r7, [r5, r3]
        if (GetLength(input, &idx, &length, sz) <= 0) {
     c10:	9a09      	ldr	r2, [sp, #36]	; 0x24
     c12:	4633      	mov	r3, r6
     c14:	a911      	add	r1, sp, #68	; 0x44
     c16:	4628      	mov	r0, r5
     c18:	f7ff fffe 	bl	0 <ParseCertRelative>
     c1c:	2800      	cmp	r0, #0
     c1e:	f77f acc9 	ble.w	5b4 <ParseCertRelative+0x5b4>
        if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0))
     c22:	2fa0      	cmp	r7, #160	; 0xa0
     c24:	d110      	bne.n	c48 <ParseCertRelative+0xc48>
            subtree = &cert->permittedNames;
     c26:	f109 0330 	add.w	r3, r9, #48	; 0x30
        if (DecodeSubtree(input + idx, (word32)length, subtree,
     c2a:	9f11      	ldr	r7, [sp, #68]	; 0x44
     c2c:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
            subtree = &cert->excludedNames;
     c30:	9304      	str	r3, [sp, #16]
        if (DecodeSubtree(input + idx, (word32)length, subtree,
     c32:	442f      	add	r7, r5
    word32 idx = 0;
     c34:	2300      	movs	r3, #0
        idx += (word32)seqLength;
     c36:	9313      	str	r3, [sp, #76]	; 0x4c
    while (idx < (word32)sz) {
     c38:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     c3a:	4598      	cmp	r8, r3
     c3c:	d80a      	bhi.n	c54 <ParseCertRelative+0xc54>
        idx += (word32)length;
     c3e:	e9dd 3211 	ldrd	r3, r2, [sp, #68]	; 0x44
     c42:	4413      	add	r3, r2
     c44:	9311      	str	r3, [sp, #68]	; 0x44
     c46:	e7d5      	b.n	bf4 <ParseCertRelative+0xbf4>
        else if (b == (ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 1))
     c48:	2fa1      	cmp	r7, #161	; 0xa1
     c4a:	f47f acb3 	bne.w	5b4 <ParseCertRelative+0x5b4>
            subtree = &cert->excludedNames;
     c4e:	f109 0334 	add.w	r3, r9, #52	; 0x34
     c52:	e7ea      	b.n	c2a <ParseCertRelative+0xc2a>
        if (GetSequence(input, &idx, &seqLength, sz) < 0) {
     c54:	4643      	mov	r3, r8
     c56:	aa14      	add	r2, sp, #80	; 0x50
     c58:	a913      	add	r1, sp, #76	; 0x4c
     c5a:	4638      	mov	r0, r7
     c5c:	f7ff fffe 	bl	0 <ParseCertRelative>
     c60:	2800      	cmp	r0, #0
     c62:	f6ff aca7 	blt.w	5b4 <ParseCertRelative+0x5b4>
        if (idx >= (word32)sz) {
     c66:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     c68:	4598      	cmp	r8, r3
     c6a:	f67f aca3 	bls.w	5b4 <ParseCertRelative+0x5b4>
        b = input[nameIdx++];
     c6e:	1c5a      	adds	r2, r3, #1
     c70:	9216      	str	r2, [sp, #88]	; 0x58
     c72:	5cfb      	ldrb	r3, [r7, r3]
     c74:	9308      	str	r3, [sp, #32]
        if (GetLength(input, &nameIdx, &strLength, sz) <= 0) {
     c76:	aa15      	add	r2, sp, #84	; 0x54
     c78:	4643      	mov	r3, r8
     c7a:	a916      	add	r1, sp, #88	; 0x58
     c7c:	4638      	mov	r0, r7
     c7e:	f7ff fffe 	bl	0 <ParseCertRelative>
     c82:	2800      	cmp	r0, #0
     c84:	f77f ac96 	ble.w	5b4 <ParseCertRelative+0x5b4>
        bType = (byte)(b & ASN_TYPE_MASK);
     c88:	9b08      	ldr	r3, [sp, #32]
     c8a:	f003 031f 	and.w	r3, r3, #31
     c8e:	9305      	str	r3, [sp, #20]
        if (bType == ASN_DNS_TYPE || bType == ASN_RFC822_TYPE ||
     c90:	3b01      	subs	r3, #1
     c92:	2b01      	cmp	r3, #1
     c94:	d902      	bls.n	c9c <ParseCertRelative+0xc9c>
     c96:	9b05      	ldr	r3, [sp, #20]
     c98:	2b04      	cmp	r3, #4
     c9a:	d12f      	bne.n	cfc <ParseCertRelative+0xcfc>
            if (b & ASN_CONSTRUCTED) {
     c9c:	9b08      	ldr	r3, [sp, #32]
     c9e:	069b      	lsls	r3, r3, #26
     ca0:	d40f      	bmi.n	cc2 <ParseCertRelative+0xcc2>
            entry = (Base_entry*)XMALLOC(sizeof(Base_entry), heap,
     ca2:	2010      	movs	r0, #16
     ca4:	f7ff fffe 	bl	0 <malloc>
            if (entry == NULL) {
     ca8:	2800      	cmp	r0, #0
     caa:	f43f ac83 	beq.w	5b4 <ParseCertRelative+0x5b4>
     cae:	9008      	str	r0, [sp, #32]
            entry->name = (char*)XMALLOC((size_t)strLength+1, heap,
     cb0:	9815      	ldr	r0, [sp, #84]	; 0x54
     cb2:	3001      	adds	r0, #1
     cb4:	f7ff fffe 	bl	0 <malloc>
     cb8:	9b08      	ldr	r3, [sp, #32]
     cba:	6058      	str	r0, [r3, #4]
            if (entry->name == NULL) {
     cbc:	b950      	cbnz	r0, cd4 <ParseCertRelative+0xcd4>
                XFREE(entry, heap, DYNAMIC_TYPE_ALTNAME);
     cbe:	4618      	mov	r0, r3
     cc0:	e615      	b.n	8ee <ParseCertRelative+0x8ee>
                if (GetSequence(input, &nameIdx, &strLength, sz) < 0) {
     cc2:	4643      	mov	r3, r8
     cc4:	aa15      	add	r2, sp, #84	; 0x54
     cc6:	a916      	add	r1, sp, #88	; 0x58
     cc8:	4638      	mov	r0, r7
     cca:	f7ff fffe 	bl	0 <ParseCertRelative>
     cce:	2800      	cmp	r0, #0
     cd0:	dae7      	bge.n	ca2 <ParseCertRelative+0xca2>
     cd2:	e46f      	b.n	5b4 <ParseCertRelative+0x5b4>
            XMEMCPY(entry->name, &input[nameIdx], (size_t)strLength);
     cd4:	e9dd 2115 	ldrd	r2, r1, [sp, #84]	; 0x54
     cd8:	4439      	add	r1, r7
     cda:	9308      	str	r3, [sp, #32]
     cdc:	f7ff fffe 	bl	0 <memcpy>
            entry->name[strLength] = '\0';
     ce0:	9b08      	ldr	r3, [sp, #32]
     ce2:	9815      	ldr	r0, [sp, #84]	; 0x54
     ce4:	685a      	ldr	r2, [r3, #4]
     ce6:	2100      	movs	r1, #0
     ce8:	5411      	strb	r1, [r2, r0]
            entry->nameSz = strLength;
     cea:	9a15      	ldr	r2, [sp, #84]	; 0x54
     cec:	609a      	str	r2, [r3, #8]
            entry->type = bType;
     cee:	9a05      	ldr	r2, [sp, #20]
     cf0:	731a      	strb	r2, [r3, #12]
            entry->next = *head;
     cf2:	9a04      	ldr	r2, [sp, #16]
     cf4:	6812      	ldr	r2, [r2, #0]
     cf6:	601a      	str	r2, [r3, #0]
            *head = entry;
     cf8:	9a04      	ldr	r2, [sp, #16]
     cfa:	6013      	str	r3, [r2, #0]
        idx += (word32)seqLength;
     cfc:	e9dd 3213 	ldrd	r3, r2, [sp, #76]	; 0x4c
     d00:	4413      	add	r3, r2
     d02:	e798      	b.n	c36 <ParseCertRelative+0xc36>
            VERIFY_AND_SET_OID(cert->inhibitAnyOidSet);
     d04:	f899 3356 	ldrb.w	r3, [r9, #854]	; 0x356
     d08:	07dc      	lsls	r4, r3, #31
     d0a:	d458      	bmi.n	dbe <ParseCertRelative+0xdbe>
     d0c:	f043 0301 	orr.w	r3, r3, #1
     d10:	f889 3356 	strb.w	r3, [r9, #854]	; 0x356
        if (ret == ASN_CRIT_EXT_E) {
     d14:	e486      	b.n	624 <ParseCertRelative+0x624>
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
     d16:	f899 3355 	ldrb.w	r3, [r9, #853]	; 0x355
     d1a:	f013 0310 	ands.w	r3, r3, #16
     d1e:	d14e      	bne.n	dbe <ParseCertRelative+0xdbe>
            cert->extPolicyConstCrit = critical ? 1 : 0;
     d20:	3f00      	subs	r7, #0
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
     d22:	f8d9 2354 	ldr.w	r2, [r9, #852]	; 0x354
    int skipLength = 0;
     d26:	9316      	str	r3, [sp, #88]	; 0x58
            cert->extPolicyConstCrit = critical ? 1 : 0;
     d28:	bf18      	it	ne
     d2a:	2701      	movne	r7, #1
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
     d2c:	057f      	lsls	r7, r7, #21
     d2e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
     d32:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
     d36:	f447 5780 	orr.w	r7, r7, #4096	; 0x1000
     d3a:	4317      	orrs	r7, r2
    int length = 0;
     d3c:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
            VERIFY_AND_SET_OID(cert->extPolicyConstSet);
     d40:	f8c9 7354 	str.w	r7, [r9, #852]	; 0x354
    if (GetSequence(input, &idx, &length, (word32)sz) < 0) {
     d44:	4633      	mov	r3, r6
     d46:	aa15      	add	r2, sp, #84	; 0x54
     d48:	a914      	add	r1, sp, #80	; 0x50
     d4a:	4628      	mov	r0, r5
     d4c:	f7ff fffe 	bl	0 <ParseCertRelative>
     d50:	2800      	cmp	r0, #0
     d52:	f6ff ac2f 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (length == 0)
     d56:	9b15      	ldr	r3, [sp, #84]	; 0x54
     d58:	2b00      	cmp	r3, #0
     d5a:	f43f ac2b 	beq.w	5b4 <ParseCertRelative+0x5b4>
    if (GetASNTag(input, &idx, &tag, (word32)sz) < 0) {
     d5e:	4633      	mov	r3, r6
     d60:	aa13      	add	r2, sp, #76	; 0x4c
     d62:	a914      	add	r1, sp, #80	; 0x50
     d64:	4628      	mov	r0, r5
     d66:	f7ff fffe 	bl	0 <ParseCertRelative>
     d6a:	2800      	cmp	r0, #0
     d6c:	f6ff ac22 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (tag == (ASN_CONTEXT_SPECIFIC | 0)) {
     d70:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
     d74:	2b80      	cmp	r3, #128	; 0x80
     d76:	d11a      	bne.n	dae <ParseCertRelative+0xdae>
        cert->extPolicyConstRxpSet = 1;
     d78:	f899 3355 	ldrb.w	r3, [r9, #853]	; 0x355
     d7c:	f043 0320 	orr.w	r3, r3, #32
        cert->extPolicyConstIpmSet = 1;
     d80:	f889 3355 	strb.w	r3, [r9, #853]	; 0x355
    ret = GetLength(input, &idx, &skipLength, (word32)sz);
     d84:	aa16      	add	r2, sp, #88	; 0x58
     d86:	4633      	mov	r3, r6
     d88:	a914      	add	r1, sp, #80	; 0x50
     d8a:	4628      	mov	r0, r5
     d8c:	f7ff fffe 	bl	0 <ParseCertRelative>
    if (ret < 0) {
     d90:	2800      	cmp	r0, #0
     d92:	f6ff ac0f 	blt.w	5b4 <ParseCertRelative+0x5b4>
    if (skipLength > 1) {
     d96:	9b16      	ldr	r3, [sp, #88]	; 0x58
     d98:	2b01      	cmp	r3, #1
     d9a:	f73f ac0b 	bgt.w	5b4 <ParseCertRelative+0x5b4>
    if (idx >= (word32)sz) {
     d9e:	9b14      	ldr	r3, [sp, #80]	; 0x50
     da0:	429e      	cmp	r6, r3
     da2:	f67f ac07 	bls.w	5b4 <ParseCertRelative+0x5b4>
    cert->policyConstSkip = input[idx];
     da6:	5ceb      	ldrb	r3, [r5, r3]
     da8:	f889 32f6 	strb.w	r3, [r9, #758]	; 0x2f6
        if (ret == ASN_CRIT_EXT_E) {
     dac:	e43a      	b.n	624 <ParseCertRelative+0x624>
    else if (tag == (ASN_CONTEXT_SPECIFIC | 1)) {
     dae:	2b81      	cmp	r3, #129	; 0x81
     db0:	f47f ac00 	bne.w	5b4 <ParseCertRelative+0x5b4>
        cert->extPolicyConstIpmSet = 1;
     db4:	f899 3355 	ldrb.w	r3, [r9, #853]	; 0x355
     db8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     dbc:	e7e0      	b.n	d80 <ParseCertRelative+0xd80>
            VERIFY_AND_SET_OID(cert->extBasicConstSet);
     dbe:	f06f 048f 	mvn.w	r4, #143	; 0x8f
}
     dc2:	4620      	mov	r0, r4
     dc4:	b01b      	add	sp, #108	; 0x6c
     dc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((ret = GetSignature(cert)) < 0) {
     dca:	dbfa      	blt.n	dc2 <ParseCertRelative+0xdc2>
     dcc:	f7ff b9aa 	b.w	124 <ParseCertRelative+0x124>
                cert->ca = GetCA(cm, cert->extAuthKeyId);
     dd0:	9806      	ldr	r0, [sp, #24]
     dd2:	f509 7138 	add.w	r1, r9, #736	; 0x2e0
     dd6:	f7ff fffe 	bl	0 <GetCA>
     dda:	f8c9 0324 	str.w	r0, [r9, #804]	; 0x324
            if (cert->ca == NULL && cert->extSubjKeyIdSet
     dde:	2800      	cmp	r0, #0
     de0:	f47f a9e5 	bne.w	1ae <ParseCertRelative+0x1ae>
     de4:	f7ff b9de 	b.w	1a4 <ParseCertRelative+0x1a4>
                                 && verify != VERIFY_OCSP) {
     de8:	9b02      	ldr	r3, [sp, #8]
     dea:	2b03      	cmp	r3, #3
     dec:	f43f a9df 	beq.w	1ae <ParseCertRelative+0x1ae>
                cert->ca = GetCA(cm, cert->extSubjKeyId);
     df0:	9806      	ldr	r0, [sp, #24]
     df2:	f509 7133 	add.w	r1, r9, #716	; 0x2cc
     df6:	f7ff fffe 	bl	0 <GetCA>
     dfa:	f8c9 0324 	str.w	r0, [r9, #804]	; 0x324
     dfe:	f7ff b9d6 	b.w	1ae <ParseCertRelative+0x1ae>
            if (cert->ca == NULL) {
     e02:	f8d9 3324 	ldr.w	r3, [r9, #804]	; 0x324
     e06:	2b00      	cmp	r3, #0
     e08:	f43f a9e1 	beq.w	1ce <ParseCertRelative+0x1ce>
        if (cert->pathLengthSet)
     e0c:	f899 3354 	ldrb.w	r3, [r9, #852]	; 0x354
     e10:	0698      	lsls	r0, r3, #26
            cert->maxPathLen = cert->pathLength;
     e12:	bf44      	itt	mi
     e14:	f899 22f4 	ldrbmi.w	r2, [r9, #756]	; 0x2f4
     e18:	f889 22f5 	strbmi.w	r2, [r9, #757]	; 0x2f5
        if (!cert->selfSigned) {
     e1c:	f899 2356 	ldrb.w	r2, [r9, #854]	; 0x356
     e20:	0791      	lsls	r1, r2, #30
     e22:	d421      	bmi.n	e68 <ParseCertRelative+0xe68>
            if (type != CERT_TYPE && cert->isCA && cert->extKeyUsageSet &&
     e24:	9a03      	ldr	r2, [sp, #12]
     e26:	2a00      	cmp	r2, #0
     e28:	f000 8210 	beq.w	124c <ParseCertRelative+0x124c>
     e2c:	f003 0390 	and.w	r3, r3, #144	; 0x90
     e30:	2b90      	cmp	r3, #144	; 0x90
     e32:	d119      	bne.n	e68 <ParseCertRelative+0xe68>
     e34:	f8b9 32f8 	ldrh.w	r3, [r9, #760]	; 0x2f8
     e38:	075a      	lsls	r2, r3, #29
     e3a:	d515      	bpl.n	e68 <ParseCertRelative+0xe68>
                (cert->extKeyUsage & KEYUSE_KEY_CERT_SIGN) != 0 && cert->ca) {
     e3c:	f8d9 3324 	ldr.w	r3, [r9, #804]	; 0x324
     e40:	b193      	cbz	r3, e68 <ParseCertRelative+0xe68>
                if (cert->ca->maxPathLen == 0) {
     e42:	7a9b      	ldrb	r3, [r3, #10]
     e44:	b943      	cbnz	r3, e58 <ParseCertRelative+0xe58>
                    cert->maxPathLen = 0;
     e46:	f889 32f5 	strb.w	r3, [r9, #757]	; 0x2f5
                    if (verify != NO_VERIFY) {
     e4a:	9b02      	ldr	r3, [sp, #8]
     e4c:	2b00      	cmp	r3, #0
     e4e:	f000 81a2 	beq.w	1196 <ParseCertRelative+0x1196>
                        return ASN_PATHLEN_INV_E;
     e52:	f06f 04ed 	mvn.w	r4, #237	; 0xed
     e56:	e7b4      	b.n	dc2 <ParseCertRelative+0xdc2>
                    cert->maxPathLen = (byte)min(cert->ca->maxPathLen - 1,
     e58:	f899 22f5 	ldrb.w	r2, [r9, #757]	; 0x2f5
     e5c:	3b01      	subs	r3, #1
        return a > b ? b : a;
     e5e:	4293      	cmp	r3, r2
     e60:	bf28      	it	cs
     e62:	4613      	movcs	r3, r2
     e64:	f889 32f5 	strb.w	r3, [r9, #757]	; 0x2f5
    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {
     e68:	9b02      	ldr	r3, [sp, #8]
     e6a:	2b00      	cmp	r3, #0
     e6c:	f000 8193 	beq.w	1196 <ParseCertRelative+0x1196>
     e70:	9b03      	ldr	r3, [sp, #12]
     e72:	2b05      	cmp	r3, #5
     e74:	f000 818f 	beq.w	1196 <ParseCertRelative+0x1196>
     e78:	2b0f      	cmp	r3, #15
     e7a:	f000 818c 	beq.w	1196 <ParseCertRelative+0x1196>
        if (cert->ca) {
     e7e:	f8d9 3324 	ldr.w	r3, [r9, #804]	; 0x324
     e82:	2b00      	cmp	r3, #0
     e84:	f000 81cd 	beq.w	1222 <ParseCertRelative+0x1222>
            if (verify == VERIFY || verify == VERIFY_OCSP ||
     e88:	9a02      	ldr	r2, [sp, #8]
     e8a:	f022 0202 	bic.w	r2, r2, #2
     e8e:	2a01      	cmp	r2, #1
     e90:	9204      	str	r2, [sp, #16]
     e92:	d002      	beq.n	e9a <ParseCertRelative+0xe9a>
     e94:	9a02      	ldr	r2, [sp, #8]
     e96:	2a05      	cmp	r2, #5
     e98:	d147      	bne.n	f2a <ParseCertRelative+0xf2a>
                        cert->source + cert->certBegin,
     e9a:	f8d9 200c 	ldr.w	r2, [r9, #12]
                if ((ret = ConfirmSignature(&cert->sigCtx,
     e9e:	f8d9 6274 	ldr.w	r6, [r9, #628]	; 0x274
     ea2:	f8d9 7010 	ldr.w	r7, [r9, #16]
     ea6:	f8d3 a00c 	ldr.w	sl, [r3, #12]
     eaa:	f8d9 8060 	ldr.w	r8, [r9, #96]	; 0x60
     eae:	f8d9 4018 	ldr.w	r4, [r9, #24]
     eb2:	e9d3 b500 	ldrd	fp, r5, [r3]
    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||
     eb6:	18b6      	adds	r6, r6, r2
                if ((ret = ConfirmSignature(&cert->sigCtx,
     eb8:	f8d9 3014 	ldr.w	r3, [r9, #20]
     ebc:	9303      	str	r3, [sp, #12]
     ebe:	eba7 0702 	sub.w	r7, r7, r2
    if (sigCtx == NULL || buf == NULL || bufSz == 0 || key == NULL ||
     ec2:	f43f a8a7 	beq.w	14 <ParseCertRelative+0x14>
     ec6:	2f00      	cmp	r7, #0
     ec8:	f43f a8a4 	beq.w	14 <ParseCertRelative+0x14>
     ecc:	f1ba 0f00 	cmp.w	sl, #0
     ed0:	f43f a8a0 	beq.w	14 <ParseCertRelative+0x14>
     ed4:	f1bb 0f00 	cmp.w	fp, #0
     ed8:	f43f a89c 	beq.w	14 <ParseCertRelative+0x14>
        keySz == 0 || sig == NULL || sigSz == 0) {
     edc:	f1b8 0f00 	cmp.w	r8, #0
     ee0:	f43f a898 	beq.w	14 <ParseCertRelative+0x14>
     ee4:	2b00      	cmp	r3, #0
     ee6:	f43f a895 	beq.w	14 <ParseCertRelative+0x14>
    switch (sigCtx->state) {
     eea:	f8d9 333c 	ldr.w	r3, [r9, #828]	; 0x33c
     eee:	2b04      	cmp	r3, #4
     ef0:	f200 811b 	bhi.w	112a <ParseCertRelative+0x112a>
     ef4:	e8df f013 	tbh	[pc, r3, lsl #1]
     ef8:	00300005 	.word	0x00300005
     efc:	00aa007c 	.word	0x00aa007c
     f00:	011b      	.short	0x011b
            sigCtx->keyOID = keyOID; /* must set early for cleanup */
     f02:	f8c9 5348 	str.w	r5, [r9, #840]	; 0x348
            sigCtx->digest = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, sigCtx->heap,
     f06:	2040      	movs	r0, #64	; 0x40
     f08:	f7ff fffe 	bl	0 <malloc>
     f0c:	f8c9 032c 	str.w	r0, [r9, #812]	; 0x32c
            if (sigCtx->digest == NULL) {
     f10:	b9f8      	cbnz	r0, f52 <ParseCertRelative+0xf52>
                        ERROR_OUT(MEMORY_E, exit_cs);
     f12:	f06f 047c 	mvn.w	r4, #124	; 0x7c
    FreeSignatureCtx(sigCtx);
     f16:	f509 704a 	add.w	r0, r9, #808	; 0x328
     f1a:	f7ff fffe 	bl	0 <ParseCertRelative>
                if ((ret = ConfirmSignature(&cert->sigCtx,
     f1e:	2c00      	cmp	r4, #0
     f20:	f47f af4f 	bne.w	dc2 <ParseCertRelative+0xdc2>
            if (verify == VERIFY || verify == VERIFY_OCSP ||
     f24:	9b04      	ldr	r3, [sp, #16]
     f26:	2b01      	cmp	r3, #1
     f28:	d004      	beq.n	f34 <ParseCertRelative+0xf34>
     f2a:	9b02      	ldr	r3, [sp, #8]
     f2c:	3b04      	subs	r3, #4
     f2e:	2b01      	cmp	r3, #1
     f30:	f200 8131 	bhi.w	1196 <ParseCertRelative+0x1196>
    const byte nameTypes[] = {ASN_RFC822_TYPE, ASN_DNS_TYPE, ASN_DIR_TYPE};
     f34:	4bbd      	ldr	r3, [pc, #756]	; (122c <ParseCertRelative+0x122c>)
                if (!ConfirmNameConstraints(cert->ca, cert)) {
     f36:	f8d9 6324 	ldr.w	r6, [r9, #804]	; 0x324
    const byte nameTypes[] = {ASN_RFC822_TYPE, ASN_DNS_TYPE, ASN_DIR_TYPE};
     f3a:	881a      	ldrh	r2, [r3, #0]
     f3c:	789b      	ldrb	r3, [r3, #2]
     f3e:	f8ad 2054 	strh.w	r2, [sp, #84]	; 0x54
     f42:	f88d 3056 	strb.w	r3, [sp, #86]	; 0x56
    if (signer == NULL || cert == NULL)
     f46:	2e00      	cmp	r6, #0
     f48:	f040 80f6 	bne.w	1138 <ParseCertRelative+0x1138>
                    return ASN_NAME_INVALID_E;
     f4c:	f06f 04c5 	mvn.w	r4, #197	; 0xc5
     f50:	e737      	b.n	dc2 <ParseCertRelative+0xdc2>
            sigCtx->state = SIG_STATE_HASH;
     f52:	2301      	movs	r3, #1
     f54:	f8c9 333c 	str.w	r3, [r9, #828]	; 0x33c
    switch (sigOID) {
     f58:	f240 230e 	movw	r3, #526	; 0x20e
     f5c:	429c      	cmp	r4, r3
                ret = HashForSignature(buf, bufSz, sigOID, sigCtx->digest,
     f5e:	f8d9 232c 	ldr.w	r2, [r9, #812]	; 0x32c
    switch (sigOID) {
     f62:	d829      	bhi.n	fb8 <ParseCertRelative+0xfb8>
     f64:	f5b4 7f01 	cmp.w	r4, #516	; 0x204
     f68:	d809      	bhi.n	f7e <ParseCertRelative+0xf7e>
     f6a:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
     f6e:	d03c      	beq.n	fea <ParseCertRelative+0xfea>
     f70:	f5b4 7fd0 	cmp.w	r4, #416	; 0x1a0
     f74:	f000 8085 	beq.w	1082 <ParseCertRelative+0x1082>
     f78:	f06f 04e7 	mvn.w	r4, #231	; 0xe7
     f7c:	e7cb      	b.n	f16 <ParseCertRelative+0xf16>
     f7e:	f46f 7301 	mvn.w	r3, #516	; 0x204
     f82:	441c      	add	r4, r3
     f84:	2c09      	cmp	r4, #9
     f86:	d8f7      	bhi.n	f78 <ParseCertRelative+0xf78>
     f88:	a301      	add	r3, pc, #4	; (adr r3, f90 <ParseCertRelative+0xf90>)
     f8a:	f853 f024 	ldr.w	pc, [r3, r4, lsl #2]
     f8e:	bf00      	nop
     f90:	00000fd1 	.word	0x00000fd1
     f94:	00000f79 	.word	0x00000f79
     f98:	00000f79 	.word	0x00000f79
     f9c:	00000fd1 	.word	0x00000fd1
     fa0:	00000f79 	.word	0x00000f79
     fa4:	00000f79 	.word	0x00000f79
     fa8:	00000f79 	.word	0x00000f79
     fac:	00001083 	.word	0x00001083
     fb0:	00000f79 	.word	0x00000f79
     fb4:	0000109f 	.word	0x0000109f
     fb8:	f240 238f 	movw	r3, #655	; 0x28f
     fbc:	429c      	cmp	r4, r3
     fbe:	d060      	beq.n	1082 <ParseCertRelative+0x1082>
     fc0:	f240 2391 	movw	r3, #657	; 0x291
     fc4:	429c      	cmp	r4, r3
     fc6:	d06a      	beq.n	109e <ParseCertRelative+0x109e>
     fc8:	f240 2389 	movw	r3, #649	; 0x289
     fcc:	429c      	cmp	r4, r3
     fce:	d1d3      	bne.n	f78 <ParseCertRelative+0xf78>
            if ((ret = wc_ShaHash(buf, bufSz, digest)) == 0) {
     fd0:	4639      	mov	r1, r7
     fd2:	4630      	mov	r0, r6
     fd4:	f7ff fffe 	bl	0 <wc_ShaHash>
     fd8:	4604      	mov	r4, r0
     fda:	2800      	cmp	r0, #0
     fdc:	d19b      	bne.n	f16 <ParseCertRelative+0xf16>
                *typeH    = SHAh;
     fde:	2358      	movs	r3, #88	; 0x58
     fe0:	f8c9 3340 	str.w	r3, [r9, #832]	; 0x340
                *digestSz = WC_SHA_DIGEST_SIZE;
     fe4:	2314      	movs	r3, #20
                *digestSz = WC_SHA512_DIGEST_SIZE;
     fe6:	f8c9 3344 	str.w	r3, [r9, #836]	; 0x344
            sigCtx->state = SIG_STATE_KEY;
     fea:	2302      	movs	r3, #2
     fec:	f8c9 333c 	str.w	r3, [r9, #828]	; 0x33c
            switch (keyOID) {
     ff0:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
     ff4:	d061      	beq.n	10ba <ParseCertRelative+0x10ba>
     ff6:	f240 2306 	movw	r3, #518	; 0x206
     ffa:	429d      	cmp	r5, r3
     ffc:	f040 8099 	bne.w	1132 <ParseCertRelative+0x1132>
                    word32 idx = 0;
    1000:	2300      	movs	r3, #0
                    sigCtx->verify = 0;
    1002:	f8c9 3330 	str.w	r3, [r9, #816]	; 0x330
                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),
    1006:	f44f 70de 	mov.w	r0, #444	; 0x1bc
                    word32 idx = 0;
    100a:	9316      	str	r3, [sp, #88]	; 0x58
                    sigCtx->key.ecc = (ecc_key*)XMALLOC(sizeof(ecc_key),
    100c:	f7ff fffe 	bl	0 <malloc>
    1010:	f8c9 0334 	str.w	r0, [r9, #820]	; 0x334
                    if (sigCtx->key.ecc == NULL) {
    1014:	2800      	cmp	r0, #0
    1016:	f43f af7c 	beq.w	f12 <ParseCertRelative+0xf12>
                    if ((ret = wc_ecc_init_ex(sigCtx->key.ecc, sigCtx->heap,
    101a:	f8d9 2338 	ldr.w	r2, [r9, #824]	; 0x338
    101e:	f8d9 1328 	ldr.w	r1, [r9, #808]	; 0x328
    1022:	f7ff fffe 	bl	0 <wc_ecc_init_ex>
    1026:	1e04      	subs	r4, r0, #0
    1028:	f6ff af75 	blt.w	f16 <ParseCertRelative+0xf16>
                    ret = wc_EccPublicKeyDecode(key, &idx, sigCtx->key.ecc,
    102c:	f8d9 2334 	ldr.w	r2, [r9, #820]	; 0x334
    1030:	465b      	mov	r3, fp
    1032:	a916      	add	r1, sp, #88	; 0x58
    1034:	4650      	mov	r0, sl
    1036:	f7ff fffe 	bl	0 <ParseCertRelative>
                    if ((ret = wc_ed25519_import_public(key, keySz,
    103a:	1e04      	subs	r4, r0, #0
    103c:	f6ff af6b 	blt.w	f16 <ParseCertRelative+0xf16>
            if (ret != 0) {
    1040:	2c00      	cmp	r4, #0
    1042:	f47f af68 	bne.w	f16 <ParseCertRelative+0xf16>
            sigCtx->state = SIG_STATE_DO;
    1046:	2303      	movs	r3, #3
    1048:	f8c9 333c 	str.w	r3, [r9, #828]	; 0x33c
            switch (keyOID) {
    104c:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
    1050:	d04e      	beq.n	10f0 <ParseCertRelative+0x10f0>
    1052:	f240 2306 	movw	r3, #518	; 0x206
    1056:	429d      	cmp	r5, r3
    1058:	d157      	bne.n	110a <ParseCertRelative+0x110a>
                        ret = wc_ecc_verify_hash(sig, sigSz, sigCtx->digest,
    105a:	f8d9 3334 	ldr.w	r3, [r9, #820]	; 0x334
    105e:	9301      	str	r3, [sp, #4]
    1060:	f509 734c 	add.w	r3, r9, #816	; 0x330
    1064:	9300      	str	r3, [sp, #0]
    1066:	f8d9 3344 	ldr.w	r3, [r9, #836]	; 0x344
    106a:	f8d9 232c 	ldr.w	r2, [r9, #812]	; 0x32c
    106e:	9903      	ldr	r1, [sp, #12]
    1070:	4640      	mov	r0, r8
    1072:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
            if (ret < 0) {
    1076:	2800      	cmp	r0, #0
                    ret = wc_ed25519_verify_msg(sig, sigSz, buf, bufSz,
    1078:	4604      	mov	r4, r0
            if (ret < 0) {
    107a:	da47      	bge.n	110c <ParseCertRelative+0x110c>
                ret = ASN_SIG_CONFIRM_E;
    107c:	f06f 049a 	mvn.w	r4, #154	; 0x9a
    1080:	e749      	b.n	f16 <ParseCertRelative+0xf16>
            if ((ret = wc_Sha256Hash(buf, bufSz, digest)) == 0) {
    1082:	4639      	mov	r1, r7
    1084:	4630      	mov	r0, r6
    1086:	f7ff fffe 	bl	0 <wc_Sha256Hash>
    108a:	4604      	mov	r4, r0
    108c:	2800      	cmp	r0, #0
    108e:	f47f af42 	bne.w	f16 <ParseCertRelative+0xf16>
                *typeH    = SHA256h;
    1092:	f44f 73cf 	mov.w	r3, #414	; 0x19e
    1096:	f8c9 3340 	str.w	r3, [r9, #832]	; 0x340
                *digestSz = WC_SHA256_DIGEST_SIZE;
    109a:	2320      	movs	r3, #32
    109c:	e7a3      	b.n	fe6 <ParseCertRelative+0xfe6>
            if ((ret = wc_Sha512Hash(buf, bufSz, digest)) == 0) {
    109e:	4639      	mov	r1, r7
    10a0:	4630      	mov	r0, r6
    10a2:	f7ff fffe 	bl	0 <wc_Sha512Hash>
    10a6:	4604      	mov	r4, r0
    10a8:	2800      	cmp	r0, #0
    10aa:	f47f af34 	bne.w	f16 <ParseCertRelative+0xf16>
                *typeH    = SHA512h;
    10ae:	f44f 73d0 	mov.w	r3, #416	; 0x1a0
    10b2:	f8c9 3340 	str.w	r3, [r9, #832]	; 0x340
                *digestSz = WC_SHA512_DIGEST_SIZE;
    10b6:	2340      	movs	r3, #64	; 0x40
    10b8:	e795      	b.n	fe6 <ParseCertRelative+0xfe6>
                    sigCtx->verify = 0;
    10ba:	2300      	movs	r3, #0
    10bc:	f8c9 3330 	str.w	r3, [r9, #816]	; 0x330
                    sigCtx->key.ed25519 = (ed25519_key*)XMALLOC(
    10c0:	2068      	movs	r0, #104	; 0x68
    10c2:	f7ff fffe 	bl	0 <malloc>
    10c6:	f8c9 0334 	str.w	r0, [r9, #820]	; 0x334
                    if (sigCtx->key.ed25519 == NULL) {
    10ca:	2800      	cmp	r0, #0
    10cc:	f43f af21 	beq.w	f12 <ParseCertRelative+0xf12>
                    if ((ret = wc_ed25519_init_ex(sigCtx->key.ed25519,
    10d0:	f8d9 2338 	ldr.w	r2, [r9, #824]	; 0x338
    10d4:	f8d9 1328 	ldr.w	r1, [r9, #808]	; 0x328
    10d8:	f7ff fffe 	bl	0 <wc_ed25519_init_ex>
    10dc:	1e04      	subs	r4, r0, #0
    10de:	f6ff af1a 	blt.w	f16 <ParseCertRelative+0xf16>
                    if ((ret = wc_ed25519_import_public(key, keySz,
    10e2:	f8d9 2334 	ldr.w	r2, [r9, #820]	; 0x334
    10e6:	4659      	mov	r1, fp
    10e8:	4650      	mov	r0, sl
    10ea:	f7ff fffe 	bl	0 <wc_ed25519_import_public>
    10ee:	e7a4      	b.n	103a <ParseCertRelative+0x103a>
                    ret = wc_ed25519_verify_msg(sig, sigSz, buf, bufSz,
    10f0:	f8d9 3334 	ldr.w	r3, [r9, #820]	; 0x334
    10f4:	9301      	str	r3, [sp, #4]
    10f6:	f509 734c 	add.w	r3, r9, #816	; 0x330
    10fa:	9300      	str	r3, [sp, #0]
    10fc:	9903      	ldr	r1, [sp, #12]
    10fe:	463b      	mov	r3, r7
    1100:	4632      	mov	r2, r6
    1102:	4640      	mov	r0, r8
    1104:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
    1108:	e7b5      	b.n	1076 <ParseCertRelative+0x1076>
    110a:	2400      	movs	r4, #0
            sigCtx->state = SIG_STATE_CHECK;
    110c:	2304      	movs	r3, #4
    110e:	f8c9 333c 	str.w	r3, [r9, #828]	; 0x33c
            switch (keyOID) {
    1112:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
    1116:	d004      	beq.n	1122 <ParseCertRelative+0x1122>
    1118:	f240 2306 	movw	r3, #518	; 0x206
    111c:	429d      	cmp	r5, r3
    111e:	f47f aefa 	bne.w	f16 <ParseCertRelative+0xf16>
                    if (sigCtx->verify == 1) {
    1122:	f8d9 3330 	ldr.w	r3, [r9, #816]	; 0x330
    1126:	2b01      	cmp	r3, #1
    1128:	d1a8      	bne.n	107c <ParseCertRelative+0x107c>
    switch (sigCtx->state) {
    112a:	2400      	movs	r4, #0
    112c:	e6f3      	b.n	f16 <ParseCertRelative+0xf16>
    112e:	2400      	movs	r4, #0
    1130:	e7ef      	b.n	1112 <ParseCertRelative+0x1112>
    1132:	f06f 0493 	mvn.w	r4, #147	; 0x93
    1136:	e6ee      	b.n	f16 <ParseCertRelative+0xf16>
    if (signer->excludedNames == NULL && signer->permittedNames == NULL)
    1138:	69f3      	ldr	r3, [r6, #28]
    113a:	b90b      	cbnz	r3, 1140 <ParseCertRelative+0x1140>
    113c:	69b3      	ldr	r3, [r6, #24]
    113e:	b353      	cbz	r3, 1196 <ParseCertRelative+0x1196>
                        ret = 0;
    1140:	f04f 0800 	mov.w	r8, #0
    1144:	af15      	add	r7, sp, #84	; 0x54
        XMEMSET(&subjectDnsName, 0, sizeof(DNS_entry));
    1146:	46c3      	mov	fp, r8
        byte nameType = nameTypes[i];
    1148:	f817 5b01 	ldrb.w	r5, [r7], #1
        XMEMSET(&subjectDnsName, 0, sizeof(DNS_entry));
    114c:	2210      	movs	r2, #16
    114e:	2100      	movs	r1, #0
    1150:	a816      	add	r0, sp, #88	; 0x58
    1152:	f7ff fffe 	bl	0 <memset>
        switch (nameType) {
    1156:	2d02      	cmp	r5, #2
    1158:	d010      	beq.n	117c <ParseCertRelative+0x117c>
    115a:	2d04      	cmp	r5, #4
    115c:	d027      	beq.n	11ae <ParseCertRelative+0x11ae>
    115e:	2d01      	cmp	r5, #1
    1160:	f47f aef4 	bne.w	f4c <ParseCertRelative+0xf4c>
                if (cert->subjectEmail != NULL) {
    1164:	f8d9 3318 	ldr.w	r3, [r9, #792]	; 0x318
                name = cert->altEmailNames;
    1168:	f8d9 a028 	ldr.w	sl, [r9, #40]	; 0x28
                if (cert->subjectEmail != NULL) {
    116c:	b143      	cbz	r3, 1180 <ParseCertRelative+0x1180>
                    subjectDnsName.type = ASN_RFC822_TYPE;
    116e:	e9cd b516 	strd	fp, r5, [sp, #88]	; 0x58
                    subjectDnsName.len  = cert->subjectEmailLen;
    1172:	f8d9 231c 	ldr.w	r2, [r9, #796]	; 0x31c
                    subjectDnsName.name = (char *)cert->subjectRaw;
    1176:	e9cd 2318 	strd	r2, r3, [sp, #96]	; 0x60
    117a:	e001      	b.n	1180 <ParseCertRelative+0x1180>
                name = cert->altNames;
    117c:	f8d9 a024 	ldr.w	sl, [r9, #36]	; 0x24
        while (name != NULL) {
    1180:	f1ba 0f00 	cmp.w	sl, #0
    1184:	d11e      	bne.n	11c4 <ParseCertRelative+0x11c4>
        if (subjectDnsName.len > 0 && subjectDnsName.name != NULL) {
    1186:	9b18      	ldr	r3, [sp, #96]	; 0x60
    1188:	2b00      	cmp	r3, #0
    118a:	dc2e      	bgt.n	11ea <ParseCertRelative+0x11ea>
    for (i=0; i < (int)sizeof(nameTypes); i++) {
    118c:	f108 0801 	add.w	r8, r8, #1
    1190:	f1b8 0f03 	cmp.w	r8, #3
    1194:	d1d8      	bne.n	1148 <ParseCertRelative+0x1148>
    if (cert->badDate != 0) {
    1196:	f8d9 334c 	ldr.w	r3, [r9, #844]	; 0x34c
    119a:	b113      	cbz	r3, 11a2 <ParseCertRelative+0x11a2>
        if (verify != VERIFY_SKIP_DATE) {
    119c:	9a02      	ldr	r2, [sp, #8]
    119e:	2a05      	cmp	r2, #5
    11a0:	d142      	bne.n	1228 <ParseCertRelative+0x1228>
    if (cert->criticalExt != 0)
    11a2:	f8d9 3350 	ldr.w	r3, [r9, #848]	; 0x350
    11a6:	2b00      	cmp	r3, #0
    11a8:	bf18      	it	ne
    11aa:	461c      	movne	r4, r3
    11ac:	e609      	b.n	dc2 <ParseCertRelative+0xdc2>
                if (cert->subjectRaw != NULL) {
    11ae:	f8d9 3310 	ldr.w	r3, [r9, #784]	; 0x310
                name = cert->altDirNames;
    11b2:	f8d9 a02c 	ldr.w	sl, [r9, #44]	; 0x2c
                if (cert->subjectRaw != NULL) {
    11b6:	2b00      	cmp	r3, #0
    11b8:	d0e2      	beq.n	1180 <ParseCertRelative+0x1180>
                    subjectDnsName.type = ASN_DIR_TYPE;
    11ba:	e9cd b516 	strd	fp, r5, [sp, #88]	; 0x58
                    subjectDnsName.len = cert->subjectRawLen;
    11be:	f8d9 2314 	ldr.w	r2, [r9, #788]	; 0x314
    11c2:	e7d8      	b.n	1176 <ParseCertRelative+0x1176>
            if (IsInExcludedList(name, signer->excludedNames, nameType) == 1) {
    11c4:	69f1      	ldr	r1, [r6, #28]
    11c6:	462a      	mov	r2, r5
    11c8:	4650      	mov	r0, sl
    11ca:	f7ff fffe 	bl	0 <ParseCertRelative>
    11ce:	2801      	cmp	r0, #1
    11d0:	f43f aebc 	beq.w	f4c <ParseCertRelative+0xf4c>
            if (PermittedListOk(name, signer->permittedNames, nameType) != 1) {
    11d4:	69b1      	ldr	r1, [r6, #24]
    11d6:	462a      	mov	r2, r5
    11d8:	4650      	mov	r0, sl
    11da:	f7ff fffe 	bl	0 <ParseCertRelative>
    11de:	2801      	cmp	r0, #1
    11e0:	f47f aeb4 	bne.w	f4c <ParseCertRelative+0xf4c>
            name = name->next;
    11e4:	f8da a000 	ldr.w	sl, [sl]
    11e8:	e7ca      	b.n	1180 <ParseCertRelative+0x1180>
        if (subjectDnsName.len > 0 && subjectDnsName.name != NULL) {
    11ea:	9b19      	ldr	r3, [sp, #100]	; 0x64
    11ec:	2b00      	cmp	r3, #0
    11ee:	d0cd      	beq.n	118c <ParseCertRelative+0x118c>
            if (IsInExcludedList(&subjectDnsName, signer->excludedNames,
    11f0:	69f1      	ldr	r1, [r6, #28]
    11f2:	462a      	mov	r2, r5
    11f4:	a816      	add	r0, sp, #88	; 0x58
    11f6:	f7ff fffe 	bl	0 <ParseCertRelative>
    11fa:	2801      	cmp	r0, #1
    11fc:	f43f aea6 	beq.w	f4c <ParseCertRelative+0xf4c>
            if (PermittedListOk(&subjectDnsName, signer->permittedNames,
    1200:	69b1      	ldr	r1, [r6, #24]
    1202:	462a      	mov	r2, r5
    1204:	a816      	add	r0, sp, #88	; 0x58
    1206:	f7ff fffe 	bl	0 <ParseCertRelative>
    120a:	2801      	cmp	r0, #1
    120c:	d0be      	beq.n	118c <ParseCertRelative+0x118c>
    120e:	e69d      	b.n	f4c <ParseCertRelative+0xf4c>
                return ASN_VERSION_E;
    1210:	f06f 048c 	mvn.w	r4, #140	; 0x8c
    1214:	e5d5      	b.n	dc2 <ParseCertRelative+0xdc2>
            return ASN_SIG_OID_E;
    1216:	f06f 0497 	mvn.w	r4, #151	; 0x97
    121a:	e5d2      	b.n	dc2 <ParseCertRelative+0xdc2>
            return KEYUSAGE_E;
    121c:	f06f 04e1 	mvn.w	r4, #225	; 0xe1
    1220:	e5cf      	b.n	dc2 <ParseCertRelative+0xdc2>
                return ASN_NO_SIGNER_E;
    1222:	f06f 04bb 	mvn.w	r4, #187	; 0xbb
    1226:	e5cc      	b.n	dc2 <ParseCertRelative+0xdc2>
    1228:	461c      	mov	r4, r3
    122a:	e5ca      	b.n	dc2 <ParseCertRelative+0xdc2>
    122c:	00000000 	.word	0x00000000
                if (i == 0 || i == (word32)strLen) {
    1230:	2a00      	cmp	r2, #0
    1232:	f43f aae8 	beq.w	806 <ParseCertRelative+0x806>
            uriEntry = AltNameNew(cert->heap);
    1236:	f8d9 0280 	ldr.w	r0, [r9, #640]	; 0x280
    123a:	f7ff fffe 	bl	0 <ParseCertRelative>
            if (uriEntry == NULL) {
    123e:	4607      	mov	r7, r0
    1240:	2800      	cmp	r0, #0
    1242:	f43f aa7d 	beq.w	740 <ParseCertRelative+0x740>
            uriEntry->type = ASN_URI_TYPE;
    1246:	2306      	movs	r3, #6
    1248:	f7ff ba3b 	b.w	6c2 <ParseCertRelative+0x6c2>
    if (verify != NO_VERIFY && type != CA_TYPE && type != TRUSTED_PEER_TYPE) {
    124c:	9b02      	ldr	r3, [sp, #8]
    124e:	2b00      	cmp	r3, #0
    1250:	f47f ae15 	bne.w	e7e <ParseCertRelative+0xe7e>
    1254:	e79f      	b.n	1196 <ParseCertRelative+0x1196>
                return BUFFER_E;
    1256:	f06f 0483 	mvn.w	r4, #131	; 0x83
    125a:	e5b2      	b.n	dc2 <ParseCertRelative+0xdc2>

Disassembly of section .text.ParseCert:

00000000 <ParseCert>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4604      	mov	r4, r0
    ret = ParseCertRelative(cert, type, verify, cm);
   4:	f7ff fffe 	bl	0 <ParseCert>
    if (ret < 0)
   8:	1e05      	subs	r5, r0, #0
   a:	db09      	blt.n	20 <ParseCert+0x20>
    if (cert->subjectCNLen > 0) {
   c:	6ea0      	ldr	r0, [r4, #104]	; 0x68
   e:	2800      	cmp	r0, #0
  10:	dd16      	ble.n	40 <ParseCert+0x40>
        ptr = (char*)XMALLOC((size_t)cert->subjectCNLen + 1, cert->heap,
  12:	3001      	adds	r0, #1
  14:	f7ff fffe 	bl	0 <malloc>
        if (ptr == NULL)
  18:	4606      	mov	r6, r0
  1a:	b918      	cbnz	r0, 24 <ParseCert+0x24>
            return MEMORY_E;
  1c:	f06f 057c 	mvn.w	r5, #124	; 0x7c
}
  20:	4628      	mov	r0, r5
  22:	bd70      	pop	{r4, r5, r6, pc}
        XMEMCPY(ptr, cert->subjectCN, (size_t)cert->subjectCNLen);
  24:	e9d4 1219 	ldrd	r1, r2, [r4, #100]	; 0x64
  28:	f7ff fffe 	bl	0 <memcpy>
        ptr[cert->subjectCNLen] = '\0';
  2c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
        cert->subjectCN = ptr;
  2e:	6666      	str	r6, [r4, #100]	; 0x64
        ptr[cert->subjectCNLen] = '\0';
  30:	2200      	movs	r2, #0
  32:	54f2      	strb	r2, [r6, r3]
        cert->subjectCNStored = 1;
  34:	f894 3354 	ldrb.w	r3, [r4, #852]	; 0x354
  38:	f043 0301 	orr.w	r3, r3, #1
  3c:	f884 3354 	strb.w	r3, [r4, #852]	; 0x354
    if ((cert->keyOID == RSAk
  40:	69e2      	ldr	r2, [r4, #28]
  42:	f240 2385 	movw	r3, #645	; 0x285
  46:	429a      	cmp	r2, r3
  48:	d1ea      	bne.n	20 <ParseCert+0x20>
         ) && cert->publicKey != NULL && cert->pubKeySize > 0) {
  4a:	6823      	ldr	r3, [r4, #0]
  4c:	2b00      	cmp	r3, #0
  4e:	d0e7      	beq.n	20 <ParseCert+0x20>
  50:	6860      	ldr	r0, [r4, #4]
  52:	2800      	cmp	r0, #0
  54:	d0e4      	beq.n	20 <ParseCert+0x20>
        ptr = (char*)XMALLOC(cert->pubKeySize, cert->heap,
  56:	f7ff fffe 	bl	0 <malloc>
        if (ptr == NULL)
  5a:	4606      	mov	r6, r0
  5c:	2800      	cmp	r0, #0
  5e:	d0dd      	beq.n	1c <ParseCert+0x1c>
        XMEMCPY(ptr, cert->publicKey, cert->pubKeySize);
  60:	e9d4 1200 	ldrd	r1, r2, [r4]
  64:	f7ff fffe 	bl	0 <memcpy>
        cert->pubKeyStored = 1;
  68:	2301      	movs	r3, #1
        cert->publicKey = (byte *)ptr;
  6a:	6026      	str	r6, [r4, #0]
        cert->pubKeyStored = 1;
  6c:	60a3      	str	r3, [r4, #8]
  6e:	e7d7      	b.n	20 <ParseCert+0x20>

Disassembly of section .text.wc_ParseCert:

00000000 <wc_ParseCert>:
    return ParseCert(cert, type, verify, cm);
   0:	f7ff bffe 	b.w	0 <wc_ParseCert>

Disassembly of section .text.wc_BuildEccKeyDer:

00000000 <wc_BuildEccKeyDer>:
#if defined(HAVE_ECC_KEY_EXPORT) && !defined(NO_ASN_CRYPT)
/* build DER formatted ECC key, include optional public key if requested,
 * return length on success, negative on error */
int wc_BuildEccKeyDer(ecc_key* key, byte* output, word32 *inLen,
                             int pubIn, int curveIn)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b091      	sub	sp, #68	; 0x44
   6:	469b      	mov	fp, r3
   8:	9201      	str	r2, [sp, #4]
#else
    byte   *prv = NULL, *pub = NULL;
#endif

    word32 idx = 0, prvidx = 0, pubidx = 0, curveidx = 0;
    word32 seqSz, privSz, pubSz = ECC_BUFSIZE;
   a:	f240 1201 	movw	r2, #257	; 0x101
{
   e:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    word32 seqSz, privSz, pubSz = ECC_BUFSIZE;
  10:	9205      	str	r2, [sp, #20]
{
  12:	4689      	mov	r9, r1

    if (key == NULL || (output == NULL && inLen == NULL))
  14:	4604      	mov	r4, r0
  16:	b910      	cbnz	r0, 1e <wc_BuildEccKeyDer+0x1e>
        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
        if (pubIn) {
            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
        }
        #endif
        return BAD_FUNC_ARG;
  18:	f06f 0aac 	mvn.w	sl, #172	; 0xac
  1c:	e02e      	b.n	7c <wc_BuildEccKeyDer+0x7c>
    if (key == NULL || (output == NULL && inLen == NULL))
  1e:	b911      	cbnz	r1, 26 <wc_BuildEccKeyDer+0x26>
  20:	9a01      	ldr	r2, [sp, #4]
  22:	2a00      	cmp	r2, #0
  24:	d0f8      	beq.n	18 <wc_BuildEccKeyDer+0x18>
    if (curveIn) {
  26:	b36b      	cbz	r3, 84 <wc_BuildEccKeyDer+0x84>
        curve[curveidx++] = ECC_PREFIX_0;
  28:	23a0      	movs	r3, #160	; 0xa0
        curveSz = SetCurve(key, curve+curveidx, MAX_ALGO_SZ);
  2a:	2214      	movs	r2, #20
  2c:	f10d 012a 	add.w	r1, sp, #42	; 0x2a
  30:	4620      	mov	r0, r4
        curve[curveidx++] = ECC_PREFIX_0;
  32:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
        curveSz = SetCurve(key, curve+curveidx, MAX_ALGO_SZ);
  36:	f7ff fffe 	bl	0 <wc_BuildEccKeyDer>
        if (curveSz < 0)
  3a:	f1b0 0a00 	subs.w	sl, r0, #0
  3e:	db1d      	blt.n	7c <wc_BuildEccKeyDer+0x7c>
        curve[1] = (byte)curveSz;
  40:	f88d a029 	strb.w	sl, [sp, #41]	; 0x29
        curveidx += (word32)curveSz;
  44:	f10a 0802 	add.w	r8, sl, #2
    privSz = (word32)key->dp->size;
  48:	6923      	ldr	r3, [r4, #16]
  4a:	6818      	ldr	r0, [r3, #0]
  4c:	9004      	str	r0, [sp, #16]
    prv = (byte*)XMALLOC(privSz + (word32)privHdrSz + MAX_SEQ_SZ,
  4e:	3007      	adds	r0, #7
  50:	f7ff fffe 	bl	0 <malloc>
    if (prv == NULL) {
  54:	4606      	mov	r6, r0
  56:	b398      	cbz	r0, c0 <wc_BuildEccKeyDer+0xc0>
    if (privSz < ASN_LONG_LENGTH) {
  58:	9804      	ldr	r0, [sp, #16]
  5a:	287f      	cmp	r0, #127	; 0x7f
  5c:	d814      	bhi.n	88 <wc_BuildEccKeyDer+0x88>
    output[0] = ASN_OCTET_STRING;
  5e:	2304      	movs	r3, #4
  60:	7033      	strb	r3, [r6, #0]
    output[1] = (byte)len;
  62:	7070      	strb	r0, [r6, #1]
        prvidx += SetOctetString8Bit(privSz, &prv[prvidx]);
  64:	2702      	movs	r7, #2
    ret = wc_ecc_export_private_only(key, prv + prvidx, &privSz);
  66:	aa04      	add	r2, sp, #16
  68:	19f1      	adds	r1, r6, r7
  6a:	4620      	mov	r0, r4
  6c:	f7ff fffe 	bl	0 <wc_ecc_export_private_only>
    if (ret < 0) {
  70:	f1b0 0a00 	subs.w	sl, r0, #0
  74:	da0d      	bge.n	92 <wc_BuildEccKeyDer+0x92>
            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  76:	4630      	mov	r0, r6
            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  78:	f7ff fffe 	bl	0 <free>
    }

    FREE_ASNSETDATA(dataASN, key->heap);
    return ret;
#endif
}
  7c:	4650      	mov	r0, sl
  7e:	b011      	add	sp, #68	; 0x44
  80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    word32 idx = 0, prvidx = 0, pubidx = 0, curveidx = 0;
  84:	4698      	mov	r8, r3
  86:	e7df      	b.n	48 <wc_BuildEccKeyDer+0x48>
        prvidx += SetOctetString(privSz, &prv[prvidx]);
  88:	4631      	mov	r1, r6
  8a:	f7ff fffe 	bl	0 <wc_BuildEccKeyDer>
  8e:	4607      	mov	r7, r0
  90:	e7e9      	b.n	66 <wc_BuildEccKeyDer+0x66>
    prvidx += privSz;
  92:	9b04      	ldr	r3, [sp, #16]
  94:	9302      	str	r3, [sp, #8]
    if (pubIn) {
  96:	f1bb 0f00 	cmp.w	fp, #0
  9a:	d062      	beq.n	162 <wc_BuildEccKeyDer+0x162>
        ret = wc_ecc_export_x963(key, NULL, &pubSz);
  9c:	aa05      	add	r2, sp, #20
  9e:	2100      	movs	r1, #0
  a0:	4620      	mov	r0, r4
  a2:	f7ff fffe 	bl	0 <wc_ecc_export_x963>
        if (ret != LENGTH_ONLY_E) {
  a6:	f110 0fca 	cmn.w	r0, #202	; 0xca
        ret = wc_ecc_export_x963(key, NULL, &pubSz);
  aa:	4682      	mov	sl, r0
        if (ret != LENGTH_ONLY_E) {
  ac:	d1e3      	bne.n	76 <wc_BuildEccKeyDer+0x76>
        pub = (byte*)XMALLOC(pubSz + (word32)pubHdrSz + MAX_SEQ_SZ,
  ae:	9805      	ldr	r0, [sp, #20]
  b0:	3009      	adds	r0, #9
  b2:	f7ff fffe 	bl	0 <malloc>
        if (pub == NULL) {
  b6:	4605      	mov	r5, r0
  b8:	b928      	cbnz	r0, c6 <wc_BuildEccKeyDer+0xc6>
            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  ba:	4630      	mov	r0, r6
  bc:	f7ff fffe 	bl	0 <free>
        return MEMORY_E;
  c0:	f06f 0a7c 	mvn.w	sl, #124	; 0x7c
  c4:	e7da      	b.n	7c <wc_BuildEccKeyDer+0x7c>
        pub[pubidx++] = ECC_PREFIX_1;
  c6:	4601      	mov	r1, r0
        if (pubSz > 128) /* leading zero + extra size byte */
  c8:	9805      	ldr	r0, [sp, #20]
        pub[pubidx++] = ECC_PREFIX_1;
  ca:	23a1      	movs	r3, #161	; 0xa1
        if (pubSz > 128) /* leading zero + extra size byte */
  cc:	2880      	cmp	r0, #128	; 0x80
        pub[pubidx++] = ECC_PREFIX_1;
  ce:	f801 3b01 	strb.w	r3, [r1], #1
            pubidx += SetLength(pubSz + ASN_ECC_CONTEXT_SZ + 2, pub+pubidx);
  d2:	bf8c      	ite	hi
  d4:	3004      	addhi	r0, #4
            pubidx += SetLength(pubSz + ASN_ECC_CONTEXT_SZ + 1, pub+pubidx);
  d6:	3003      	addls	r0, #3
  d8:	f7ff fffe 	bl	0 <wc_BuildEccKeyDer>
  dc:	f100 0a01 	add.w	sl, r0, #1
        pubidx += SetBitString(pubSz, 0, pub + pubidx);
  e0:	eb05 020a 	add.w	r2, r5, sl
  e4:	2100      	movs	r1, #0
  e6:	9805      	ldr	r0, [sp, #20]
  e8:	f7ff fffe 	bl	0 <wc_BuildEccKeyDer>
  ec:	eb0a 0300 	add.w	r3, sl, r0
        ret = wc_ecc_export_x963(key, pub + pubidx, &pubSz);
  f0:	18e9      	adds	r1, r5, r3
  f2:	aa05      	add	r2, sp, #20
  f4:	4620      	mov	r0, r4
  f6:	9303      	str	r3, [sp, #12]
  f8:	f7ff fffe 	bl	0 <wc_ecc_export_x963>
        if (ret != 0) {
  fc:	9b03      	ldr	r3, [sp, #12]
  fe:	4682      	mov	sl, r0
 100:	b120      	cbz	r0, 10c <wc_BuildEccKeyDer+0x10c>
            XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 102:	4630      	mov	r0, r6
 104:	f7ff fffe 	bl	0 <free>
            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 108:	4628      	mov	r0, r5
 10a:	e7b5      	b.n	78 <wc_BuildEccKeyDer+0x78>
        pubidx += pubSz;
 10c:	9a05      	ldr	r2, [sp, #20]
 10e:	4413      	add	r3, r2
    prvidx += privSz;
 110:	9a02      	ldr	r2, [sp, #8]
    seqSz = SetSequence((word32)verSz + prvidx + pubidx + curveidx, seq);
 112:	9302      	str	r3, [sp, #8]
    prvidx += privSz;
 114:	443a      	add	r2, r7
 116:	4617      	mov	r7, r2
    seqSz = SetSequence((word32)verSz + prvidx + pubidx + curveidx, seq);
 118:	f108 0403 	add.w	r4, r8, #3
 11c:	443c      	add	r4, r7
 11e:	441c      	add	r4, r3
    output[i++] = ASN_INTEGER;
 120:	2202      	movs	r2, #2
 122:	f88d 2018 	strb.w	r2, [sp, #24]
    seqSz = SetSequence((word32)verSz + prvidx + pubidx + curveidx, seq);
 126:	4620      	mov	r0, r4
    output[i++] = 0x01;
 128:	2201      	movs	r2, #1
    seqSz = SetSequence((word32)verSz + prvidx + pubidx + curveidx, seq);
 12a:	a908      	add	r1, sp, #32
    output[i++] = 0x01;
 12c:	f88d 2019 	strb.w	r2, [sp, #25]
    output[i++] = (byte)version;
 130:	f88d 201a 	strb.w	r2, [sp, #26]
    seqSz = SetSequence((word32)verSz + prvidx + pubidx + curveidx, seq);
 134:	f7ff fffe 	bl	0 <wc_BuildEccKeyDer>
    if (output == NULL) {
 138:	9b02      	ldr	r3, [sp, #8]
    seqSz = SetSequence((word32)verSz + prvidx + pubidx + curveidx, seq);
 13a:	4682      	mov	sl, r0
    totalSz = prvidx + pubidx + curveidx + (word32)verSz + seqSz;
 13c:	4404      	add	r4, r0
    if (output == NULL) {
 13e:	f1b9 0f00 	cmp.w	r9, #0
 142:	d111      	bne.n	168 <wc_BuildEccKeyDer+0x168>
        *inLen = totalSz;
 144:	9b01      	ldr	r3, [sp, #4]
        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 146:	4630      	mov	r0, r6
        *inLen = totalSz;
 148:	601c      	str	r4, [r3, #0]
        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 14a:	f7ff fffe 	bl	0 <free>
        if (pubIn) {
 14e:	f1bb 0f00 	cmp.w	fp, #0
 152:	d003      	beq.n	15c <wc_BuildEccKeyDer+0x15c>
            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 154:	b115      	cbz	r5, 15c <wc_BuildEccKeyDer+0x15c>
 156:	4628      	mov	r0, r5
 158:	f7ff fffe 	bl	0 <free>
        return LENGTH_ONLY_E;
 15c:	f06f 0ac9 	mvn.w	sl, #201	; 0xc9
 160:	e78c      	b.n	7c <wc_BuildEccKeyDer+0x7c>
    word32 idx = 0, prvidx = 0, pubidx = 0, curveidx = 0;
 162:	465b      	mov	r3, fp
    byte   *prv = NULL, *pub = NULL;
 164:	465d      	mov	r5, fp
 166:	e7d3      	b.n	110 <wc_BuildEccKeyDer+0x110>
    if (inLen != NULL && totalSz > *inLen) {
 168:	9a01      	ldr	r2, [sp, #4]
 16a:	b182      	cbz	r2, 18e <wc_BuildEccKeyDer+0x18e>
 16c:	6812      	ldr	r2, [r2, #0]
 16e:	42a2      	cmp	r2, r4
 170:	d20d      	bcs.n	18e <wc_BuildEccKeyDer+0x18e>
        XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 172:	4630      	mov	r0, r6
 174:	f7ff fffe 	bl	0 <free>
        if (pubIn) {
 178:	f1bb 0f00 	cmp.w	fp, #0
 17c:	f43f af4c 	beq.w	18 <wc_BuildEccKeyDer+0x18>
            XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 180:	2d00      	cmp	r5, #0
 182:	f43f af49 	beq.w	18 <wc_BuildEccKeyDer+0x18>
 186:	4628      	mov	r0, r5
 188:	f7ff fffe 	bl	0 <free>
 18c:	e744      	b.n	18 <wc_BuildEccKeyDer+0x18>
    XMEMCPY(output + idx, seq, seqSz);
 18e:	4652      	mov	r2, sl
 190:	a908      	add	r1, sp, #32
 192:	4648      	mov	r0, r9
 194:	9301      	str	r3, [sp, #4]
 196:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(output + idx, ver, (size_t)verSz);
 19a:	2203      	movs	r2, #3
 19c:	a906      	add	r1, sp, #24
 19e:	eb09 000a 	add.w	r0, r9, sl
    idx += (word32)verSz;
 1a2:	f10a 0a03 	add.w	sl, sl, #3
    XMEMCPY(output + idx, ver, (size_t)verSz);
 1a6:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(output + idx, prv, prvidx);
 1aa:	463a      	mov	r2, r7
 1ac:	4631      	mov	r1, r6
 1ae:	eb09 000a 	add.w	r0, r9, sl
 1b2:	f7ff fffe 	bl	0 <memcpy>
    idx += prvidx;
 1b6:	44ba      	add	sl, r7
    XFREE(prv, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1b8:	4630      	mov	r0, r6
 1ba:	f7ff fffe 	bl	0 <free>
    XMEMCPY(output + idx, curve, curveidx);
 1be:	4642      	mov	r2, r8
 1c0:	a90a      	add	r1, sp, #40	; 0x28
 1c2:	eb09 000a 	add.w	r0, r9, sl
 1c6:	f7ff fffe 	bl	0 <memcpy>
    if (pubIn) {
 1ca:	9b01      	ldr	r3, [sp, #4]
 1cc:	f1bb 0f00 	cmp.w	fp, #0
 1d0:	d00a      	beq.n	1e8 <wc_BuildEccKeyDer+0x1e8>
    idx += curveidx;
 1d2:	eb08 000a 	add.w	r0, r8, sl
        XMEMCPY(output + idx, pub, pubidx);
 1d6:	461a      	mov	r2, r3
 1d8:	4629      	mov	r1, r5
 1da:	4448      	add	r0, r9
 1dc:	f7ff fffe 	bl	0 <memcpy>
        XFREE(pub, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
 1e0:	b115      	cbz	r5, 1e8 <wc_BuildEccKeyDer+0x1e8>
 1e2:	4628      	mov	r0, r5
 1e4:	f7ff fffe 	bl	0 <free>
    return (int)totalSz;
 1e8:	46a2      	mov	sl, r4
 1ea:	e747      	b.n	7c <wc_BuildEccKeyDer+0x7c>

Disassembly of section .text.eccToPKCS8:

00000000 <eccToPKCS8>:
 * returns LENGTH_ONLY_E.
 *
 * return length on success else < 0 */
static int eccToPKCS8(ecc_key* key, byte* output, word32* outLen,
        int includePublic)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36	; 0x24
    int ret;
    word32 tmpDerSz;
    int algoID = 0;
    word32 oidSz = 0;
   6:	f04f 0800 	mov.w	r8, #0
#ifdef WOLFSSL_NO_MALLOC
    byte  tmpDer[ECC_BUFSIZE];
#else
    byte* tmpDer = NULL;
#endif
    word32 sz = ECC_BUFSIZE;
   a:	f240 1b01 	movw	fp, #257	; 0x101
    word32 pkcs8Sz = 0;
   e:	e9cd 8804 	strd	r8, r8, [sp, #16]
{
  12:	4689      	mov	r9, r1
  14:	4616      	mov	r6, r2
  16:	469a      	mov	sl, r3
    const byte* curveOID = NULL;
  18:	f8cd 8018 	str.w	r8, [sp, #24]
    word32 sz = ECC_BUFSIZE;
  1c:	f8cd b01c 	str.w	fp, [sp, #28]

    if (key == NULL || key->dp == NULL || outLen == NULL)
  20:	4607      	mov	r7, r0
  22:	2800      	cmp	r0, #0
  24:	d057      	beq.n	d6 <eccToPKCS8+0xd6>
  26:	6903      	ldr	r3, [r0, #16]
  28:	2b00      	cmp	r3, #0
  2a:	d054      	beq.n	d6 <eccToPKCS8+0xd6>
  2c:	2a00      	cmp	r2, #0
  2e:	d052      	beq.n	d6 <eccToPKCS8+0xd6>
        return BAD_FUNC_ARG;

    /* set algoID, get curve OID */
    algoID = ECDSAk;
    ret = wc_ecc_get_oid(key->dp->oidSum, &curveOID, &oidSz);
  30:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  32:	aa04      	add	r2, sp, #16
  34:	a906      	add	r1, sp, #24
  36:	f7ff fffe 	bl	0 <wc_ecc_get_oid>
    if (ret < 0)
  3a:	1e04      	subs	r4, r0, #0
  3c:	db27      	blt.n	8e <eccToPKCS8+0x8e>
        return ret;

#ifndef WOLFSSL_NO_MALLOC
    /* temp buffer for plain DER key */
    tmpDer = (byte*)XMALLOC(ECC_BUFSIZE, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  3e:	4658      	mov	r0, fp
  40:	f7ff fffe 	bl	0 <malloc>
    if (tmpDer == NULL)
  44:	4605      	mov	r5, r0
  46:	2800      	cmp	r0, #0
  48:	d048      	beq.n	dc <eccToPKCS8+0xdc>
        return MEMORY_E;
#endif
    XMEMSET(tmpDer, 0, ECC_BUFSIZE);
  4a:	465a      	mov	r2, fp
  4c:	4641      	mov	r1, r8
  4e:	f7ff fffe 	bl	0 <memset>

    ret = wc_BuildEccKeyDer(key, tmpDer, &sz, includePublic, 0);
  52:	f8cd 8000 	str.w	r8, [sp]
  56:	4653      	mov	r3, sl
  58:	aa07      	add	r2, sp, #28
  5a:	4629      	mov	r1, r5
  5c:	4638      	mov	r0, r7
  5e:	f7ff fffe 	bl	0 <eccToPKCS8>
    if (ret < 0) {
  62:	1e04      	subs	r4, r0, #0
  64:	da03      	bge.n	6e <eccToPKCS8+0x6e>
    #ifndef WOLFSSL_NO_MALLOC
        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  66:	4628      	mov	r0, r5

    ret = wc_CreatePKCS8Key(output, &pkcs8Sz, tmpDer, tmpDerSz,
                            algoID, curveOID, oidSz);
    if (ret < 0) {
    #ifndef WOLFSSL_NO_MALLOC
        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  68:	f7ff fffe 	bl	0 <free>
    #endif
        return ret;
  6c:	e00f      	b.n	8e <eccToPKCS8+0x8e>
    ret = wc_CreatePKCS8Key(NULL, &pkcs8Sz, tmpDer, tmpDerSz, algoID,
  6e:	9a06      	ldr	r2, [sp, #24]
  70:	9904      	ldr	r1, [sp, #16]
                 + MAX_LENGTH_SZ + MAX_LENGTH_SZ + 2;
  72:	f104 0028 	add.w	r0, r4, #40	; 0x28
        if (curveOID != NULL)
  76:	b972      	cbnz	r2, 96 <eccToPKCS8+0x96>
        *outSz = keySz + MAX_SEQ_SZ + MAX_VERSION_SZ + MAX_ALGO_SZ
  78:	9005      	str	r0, [sp, #20]
    if (output == NULL) {
  7a:	f1b9 0f00 	cmp.w	r9, #0
  7e:	d10e      	bne.n	9e <eccToPKCS8+0x9e>
        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  80:	4628      	mov	r0, r5
  82:	f7ff fffe 	bl	0 <free>
        *outLen = pkcs8Sz;
  86:	9b05      	ldr	r3, [sp, #20]
  88:	6033      	str	r3, [r6, #0]
        return LENGTH_ONLY_E;
  8a:	f06f 04c9 	mvn.w	r4, #201	; 0xc9
    XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
#endif

    *outLen = (word32)ret;
    return ret;
}
  8e:	4620      	mov	r0, r4
  90:	b009      	add	sp, #36	; 0x24
  92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *outSz += oidSz + MAX_LENGTH_SZ + 1;
  96:	1d4b      	adds	r3, r1, #5
  98:	4403      	add	r3, r0
  9a:	9305      	str	r3, [sp, #20]
  9c:	e7ed      	b.n	7a <eccToPKCS8+0x7a>
    else if (*outLen < pkcs8Sz) {
  9e:	6830      	ldr	r0, [r6, #0]
  a0:	9b05      	ldr	r3, [sp, #20]
  a2:	4298      	cmp	r0, r3
  a4:	d205      	bcs.n	b2 <eccToPKCS8+0xb2>
        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  a6:	4628      	mov	r0, r5
  a8:	f7ff fffe 	bl	0 <free>
        return BUFFER_E;
  ac:	f06f 0483 	mvn.w	r4, #131	; 0x83
  b0:	e7ed      	b.n	8e <eccToPKCS8+0x8e>
    ret = wc_CreatePKCS8Key(output, &pkcs8Sz, tmpDer, tmpDerSz,
  b2:	f240 2306 	movw	r3, #518	; 0x206
  b6:	e9cd 2101 	strd	r2, r1, [sp, #4]
  ba:	9300      	str	r3, [sp, #0]
  bc:	462a      	mov	r2, r5
  be:	4623      	mov	r3, r4
  c0:	a905      	add	r1, sp, #20
  c2:	4648      	mov	r0, r9
  c4:	f7ff fffe 	bl	0 <eccToPKCS8>
    if (ret < 0) {
  c8:	1e04      	subs	r4, r0, #0
        XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  ca:	4628      	mov	r0, r5
    if (ret < 0) {
  cc:	dbcc      	blt.n	68 <eccToPKCS8+0x68>
    XFREE(tmpDer, key->heap, DYNAMIC_TYPE_TMP_BUFFER);
  ce:	f7ff fffe 	bl	0 <free>
    *outLen = (word32)ret;
  d2:	6034      	str	r4, [r6, #0]
    return ret;
  d4:	e7db      	b.n	8e <eccToPKCS8+0x8e>
        return BAD_FUNC_ARG;
  d6:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  da:	e7d8      	b.n	8e <eccToPKCS8+0x8e>
        return MEMORY_E;
  dc:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  e0:	e7d5      	b.n	8e <eccToPKCS8+0x8e>

Disassembly of section .text.wc_EccKeyToDer:

00000000 <wc_EccKeyToDer>:
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return wc_BuildEccKeyDer(key, output, &inLen, 1, 1);
   2:	2301      	movs	r3, #1
{
   4:	9203      	str	r2, [sp, #12]
    return wc_BuildEccKeyDer(key, output, &inLen, 1, 1);
   6:	9300      	str	r3, [sp, #0]
   8:	aa03      	add	r2, sp, #12
   a:	f7ff fffe 	bl	0 <wc_EccKeyToDer>
}
   e:	b005      	add	sp, #20
  10:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.wc_EccKeyDerSize:

00000000 <wc_EccKeyDerSize>:
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    ret = wc_BuildEccKeyDer(key, NULL, &sz, pub, 1);
   2:	2201      	movs	r2, #1
{
   4:	460b      	mov	r3, r1
    ret = wc_BuildEccKeyDer(key, NULL, &sz, pub, 1);
   6:	9200      	str	r2, [sp, #0]
    word32 sz = 0;
   8:	2100      	movs	r1, #0
    ret = wc_BuildEccKeyDer(key, NULL, &sz, pub, 1);
   a:	aa03      	add	r2, sp, #12
    word32 sz = 0;
   c:	9103      	str	r1, [sp, #12]
    ret = wc_BuildEccKeyDer(key, NULL, &sz, pub, 1);
   e:	f7ff fffe 	bl	0 <wc_EccKeyDerSize>
    if (ret != LENGTH_ONLY_E) {
  12:	f110 0fca 	cmn.w	r0, #202	; 0xca
    return (int)sz;
  16:	bf08      	it	eq
  18:	9803      	ldreq	r0, [sp, #12]
 }
  1a:	b005      	add	sp, #20
  1c:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.wc_EccPrivateKeyToDer:

00000000 <wc_EccPrivateKeyToDer>:
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return wc_BuildEccKeyDer(key, output, &inLen, 0, 1);
   2:	2301      	movs	r3, #1
{
   4:	9203      	str	r2, [sp, #12]
    return wc_BuildEccKeyDer(key, output, &inLen, 0, 1);
   6:	9300      	str	r3, [sp, #0]
   8:	aa03      	add	r2, sp, #12
   a:	2300      	movs	r3, #0
   c:	f7ff fffe 	bl	0 <wc_EccPrivateKeyToDer>
}
  10:	b005      	add	sp, #20
  12:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.wc_EccPrivateKeyToPKCS8:

00000000 <wc_EccPrivateKeyToPKCS8>:
/* Write only private ecc key to unencrypted PKCS#8 format.
 *
 * return length on success else < 0 */
int wc_EccPrivateKeyToPKCS8(ecc_key* key, byte* output, word32* outLen)
{
    return eccToPKCS8(key, output, outLen, 0);
   0:	2300      	movs	r3, #0
   2:	f7ff bffe 	b.w	0 <wc_EccPrivateKeyToPKCS8>

Disassembly of section .text.wc_EccKeyToPKCS8:

00000000 <wc_EccKeyToPKCS8>:
 *
 * return length on success else < 0 */
int wc_EccKeyToPKCS8(ecc_key* key, byte* output,
                     word32* outLen)
{
    return eccToPKCS8(key, output, outLen, 1);
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <wc_EccKeyToPKCS8>

Disassembly of section .text.DecodeAsymKey:

00000000 <DecodeAsymKey>:
    || (defined(HAVE_PQC) && defined(HAVE_SPHINCS)))

int DecodeAsymKey(const byte* input, word32* inOutIdx, word32 inSz,
    byte* privKey, word32* privKeyLen,
    byte* pubKey, word32* pubKeyLen, int keyType)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36	; 0x24
   6:	460c      	mov	r4, r1
   8:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
   c:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  10:	4617      	mov	r7, r2
  12:	4699      	mov	r9, r3
    int ret = 0;
    DECL_ASNGETDATA(dataASN, edKeyASN_Length);
    CALLOC_ASNGETDATA(dataASN, edKeyASN_Length, ret, NULL);
#endif

    if (input == NULL || inOutIdx == NULL || inSz == 0 ||
  14:	4605      	mov	r5, r0
  16:	b920      	cbnz	r0, 22 <DecodeAsymKey+0x22>
        privKey == NULL || privKeyLen == NULL) {
    #ifdef WOLFSSL_ASN_TEMPLATE
        FREE_ASNGETDATA(dataASN, NULL);
    #endif
        return BAD_FUNC_ARG;
  18:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }

    FREE_ASNGETDATA(dataASN, NULL);
    return ret;
#endif /* WOLFSSL_ASN_TEMPLATE */
}
  1c:	b009      	add	sp, #36	; 0x24
  1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (input == NULL || inOutIdx == NULL || inSz == 0 ||
  22:	2900      	cmp	r1, #0
  24:	d0f8      	beq.n	18 <DecodeAsymKey+0x18>
  26:	2a00      	cmp	r2, #0
  28:	d0f6      	beq.n	18 <DecodeAsymKey+0x18>
  2a:	2b00      	cmp	r3, #0
  2c:	d0f4      	beq.n	18 <DecodeAsymKey+0x18>
        privKey == NULL || privKeyLen == NULL) {
  2e:	f1ba 0f00 	cmp.w	sl, #0
  32:	d0f1      	beq.n	18 <DecodeAsymKey+0x18>
    if (GetSequence(input, inOutIdx, &length, inSz) >= 0) {
  34:	4613      	mov	r3, r2
  36:	aa05      	add	r2, sp, #20
  38:	f7ff fffe 	bl	0 <DecodeAsymKey>
  3c:	2800      	cmp	r0, #0
  3e:	db38      	blt.n	b2 <DecodeAsymKey+0xb2>
        endKeyIdx = (int)*inOutIdx + length;
  40:	9b05      	ldr	r3, [sp, #20]
  42:	6826      	ldr	r6, [r4, #0]
        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)
  44:	aa04      	add	r2, sp, #16
        endKeyIdx = (int)*inOutIdx + length;
  46:	441e      	add	r6, r3
        if (GetMyVersion(input, inOutIdx, &version, inSz) < 0)
  48:	4621      	mov	r1, r4
  4a:	463b      	mov	r3, r7
  4c:	4628      	mov	r0, r5
  4e:	f7ff fffe 	bl	0 <DecodeAsymKey>
  52:	2800      	cmp	r0, #0
  54:	db4e      	blt.n	f4 <DecodeAsymKey+0xf4>
        if (version != 0) {
  56:	9b04      	ldr	r3, [sp, #16]
  58:	2b00      	cmp	r3, #0
  5a:	d14b      	bne.n	f4 <DecodeAsymKey+0xf4>
        if (GetAlgoId(input, inOutIdx, &oid, oidKeyType, inSz) < 0)
  5c:	9700      	str	r7, [sp, #0]
  5e:	2302      	movs	r3, #2
  60:	aa03      	add	r2, sp, #12
  62:	4621      	mov	r1, r4
  64:	4628      	mov	r0, r5
  66:	f7ff fffe 	bl	0 <DecodeAsymKey>
  6a:	2800      	cmp	r0, #0
  6c:	db42      	blt.n	f4 <DecodeAsymKey+0xf4>
        if (oid != (word32)keyType)
  6e:	9b15      	ldr	r3, [sp, #84]	; 0x54
  70:	9a03      	ldr	r2, [sp, #12]
  72:	429a      	cmp	r2, r3
  74:	d13e      	bne.n	f4 <DecodeAsymKey+0xf4>
        if (GetOctetString(input, inOutIdx, &length, inSz) < 0)
  76:	463b      	mov	r3, r7
  78:	aa05      	add	r2, sp, #20
  7a:	4621      	mov	r1, r4
  7c:	4628      	mov	r0, r5
  7e:	f7ff fffe 	bl	0 <DecodeAsymKey>
  82:	2800      	cmp	r0, #0
  84:	db36      	blt.n	f4 <DecodeAsymKey+0xf4>
        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)
  86:	463b      	mov	r3, r7
  88:	aa06      	add	r2, sp, #24
  8a:	4621      	mov	r1, r4
  8c:	4628      	mov	r0, r5
  8e:	f7ff fffe 	bl	0 <DecodeAsymKey>
  92:	2800      	cmp	r0, #0
  94:	db2e      	blt.n	f4 <DecodeAsymKey+0xf4>
        priv = input + *inOutIdx;
  96:	6822      	ldr	r2, [r4, #0]
        *inOutIdx += (word32)privSz;
  98:	9b06      	ldr	r3, [sp, #24]
  9a:	4413      	add	r3, r2
        priv = input + *inOutIdx;
  9c:	eb05 0b02 	add.w	fp, r5, r2
        *inOutIdx += (word32)privSz;
  a0:	6023      	str	r3, [r4, #0]
    if ((word32)privSz > *privKeyLen)
  a2:	9a06      	ldr	r2, [sp, #24]
  a4:	f8da 3000 	ldr.w	r3, [sl]
  a8:	4293      	cmp	r3, r2
  aa:	d211      	bcs.n	d0 <DecodeAsymKey+0xd0>
        return BUFFER_E;
  ac:	f06f 0083 	mvn.w	r0, #131	; 0x83
  b0:	e7b4      	b.n	1c <DecodeAsymKey+0x1c>
        if (GetOctetString(input, inOutIdx, &privSz, inSz) < 0)
  b2:	463b      	mov	r3, r7
  b4:	aa06      	add	r2, sp, #24
  b6:	4621      	mov	r1, r4
  b8:	4628      	mov	r0, r5
  ba:	f7ff fffe 	bl	0 <DecodeAsymKey>
  be:	2800      	cmp	r0, #0
  c0:	db18      	blt.n	f4 <DecodeAsymKey+0xf4>
        priv = input + *inOutIdx;
  c2:	6826      	ldr	r6, [r4, #0]
        *inOutIdx += (word32)privSz;
  c4:	9b06      	ldr	r3, [sp, #24]
        priv = input + *inOutIdx;
  c6:	eb05 0b06 	add.w	fp, r5, r6
        *inOutIdx += (word32)privSz;
  ca:	441e      	add	r6, r3
  cc:	6026      	str	r6, [r4, #0]
        endKeyIdx = (int)*inOutIdx;
  ce:	e7e8      	b.n	a2 <DecodeAsymKey+0xa2>
    if (endKeyIdx == (int)*inOutIdx) {
  d0:	6823      	ldr	r3, [r4, #0]
  d2:	42b3      	cmp	r3, r6
  d4:	d111      	bne.n	fa <DecodeAsymKey+0xfa>
        *privKeyLen = (word32)privSz;
  d6:	f8ca 2000 	str.w	r2, [sl]
        XMEMCPY(privKey, priv, *privKeyLen);
  da:	4659      	mov	r1, fp
  dc:	4648      	mov	r0, r9
  de:	f7ff fffe 	bl	0 <memcpy>
        if (pubKeyLen != NULL)
  e2:	f1b8 0f00 	cmp.w	r8, #0
  e6:	d002      	beq.n	ee <DecodeAsymKey+0xee>
            *pubKeyLen = 0;
  e8:	2300      	movs	r3, #0
  ea:	f8c8 3000 	str.w	r3, [r8]
    if (endKeyIdx != (int)*inOutIdx)
  ee:	6823      	ldr	r3, [r4, #0]
  f0:	42b3      	cmp	r3, r6
  f2:	d02a      	beq.n	14a <DecodeAsymKey+0x14a>
        return ASN_PARSE_E;
  f4:	f06f 008b 	mvn.w	r0, #139	; 0x8b
  f8:	e790      	b.n	1c <DecodeAsymKey+0x1c>
        if (pubKeyLen == NULL) {
  fa:	f1b8 0f00 	cmp.w	r8, #0
  fe:	d08b      	beq.n	18 <DecodeAsymKey+0x18>
    return GetASNHeader_ex(input, tag, inOutIdx, len, maxIdx, 1);
 100:	2301      	movs	r3, #1
 102:	e9cd 7300 	strd	r7, r3, [sp]
 106:	4622      	mov	r2, r4
 108:	ab07      	add	r3, sp, #28
 10a:	2181      	movs	r1, #129	; 0x81
 10c:	4628      	mov	r0, r5
 10e:	f7ff fffe 	bl	0 <DecodeAsymKey>
        if (GetASNHeader(input, ASN_CONTEXT_SPECIFIC | ASN_ASYMKEY_PUBKEY | 1,
 112:	2800      	cmp	r0, #0
 114:	dbee      	blt.n	f4 <DecodeAsymKey+0xf4>
        if ((word32)pubSz > *pubKeyLen)
 116:	9b07      	ldr	r3, [sp, #28]
 118:	f8d8 2000 	ldr.w	r2, [r8]
 11c:	429a      	cmp	r2, r3
 11e:	d3c5      	bcc.n	ac <DecodeAsymKey+0xac>
        pub = input + *inOutIdx;
 120:	6827      	ldr	r7, [r4, #0]
        *privKeyLen = (word32)privSz;
 122:	9a06      	ldr	r2, [sp, #24]
        *inOutIdx += (word32)pubSz;
 124:	443b      	add	r3, r7
 126:	6023      	str	r3, [r4, #0]
        XMEMCPY(privKey, priv, *privKeyLen);
 128:	4659      	mov	r1, fp
        *privKeyLen = (word32)privSz;
 12a:	f8ca 2000 	str.w	r2, [sl]
        XMEMCPY(privKey, priv, *privKeyLen);
 12e:	4648      	mov	r0, r9
 130:	f7ff fffe 	bl	0 <memcpy>
        if (pubKey != NULL)
 134:	9b13      	ldr	r3, [sp, #76]	; 0x4c
        *pubKeyLen = (word32)pubSz;
 136:	9a07      	ldr	r2, [sp, #28]
 138:	f8c8 2000 	str.w	r2, [r8]
        if (pubKey != NULL)
 13c:	2b00      	cmp	r3, #0
 13e:	d0d6      	beq.n	ee <DecodeAsymKey+0xee>
            XMEMCPY(pubKey, pub, *pubKeyLen);
 140:	19e9      	adds	r1, r5, r7
 142:	4618      	mov	r0, r3
 144:	f7ff fffe 	bl	0 <memcpy>
 148:	e7d1      	b.n	ee <DecodeAsymKey+0xee>
    return 0;
 14a:	2000      	movs	r0, #0
 14c:	e766      	b.n	1c <DecodeAsymKey+0x1c>

Disassembly of section .text.DecodeAsymKeyPublic:

00000000 <DecodeAsymKeyPublic>:

int DecodeAsymKeyPublic(const byte* input, word32* inOutIdx, word32 inSz,
    byte* pubKey, word32* pubKeyLen, int keyType)
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	b085      	sub	sp, #20
   6:	460d      	mov	r5, r1
   8:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
   c:	4616      	mov	r6, r2
   e:	4698      	mov	r8, r3
#else
    word32 len;
    DECL_ASNGETDATA(dataASN, edPubKeyASN_Length);
#endif

    if (input == NULL || inSz == 0 || inOutIdx == NULL ||
  10:	4607      	mov	r7, r0
  12:	2800      	cmp	r0, #0
  14:	d047      	beq.n	a6 <DecodeAsymKeyPublic+0xa6>
  16:	2a00      	cmp	r2, #0
  18:	d045      	beq.n	a6 <DecodeAsymKeyPublic+0xa6>
  1a:	2900      	cmp	r1, #0
  1c:	d043      	beq.n	a6 <DecodeAsymKeyPublic+0xa6>
  1e:	2b00      	cmp	r3, #0
  20:	d041      	beq.n	a6 <DecodeAsymKeyPublic+0xa6>
        pubKey == NULL || pubKeyLen == NULL) {
  22:	f1b9 0f00 	cmp.w	r9, #0
  26:	d03e      	beq.n	a6 <DecodeAsymKeyPublic+0xa6>
        return BAD_FUNC_ARG;
    }

#ifndef WOLFSSL_ASN_TEMPLATE
    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
  28:	4613      	mov	r3, r2
  2a:	aa02      	add	r2, sp, #8
  2c:	f7ff fffe 	bl	0 <DecodeAsymKeyPublic>
  30:	2800      	cmp	r0, #0
  32:	da05      	bge.n	40 <DecodeAsymKeyPublic+0x40>
        return ASN_PARSE_E;
  34:	f06f 048b 	mvn.w	r4, #139	; 0x8b
    }

    FREE_ASNGETDATA(dataASN, NULL);
#endif /* WOLFSSL_ASN_TEMPLATE */
    return ret;
}
  38:	4620      	mov	r0, r4
  3a:	b005      	add	sp, #20
  3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (GetSequence(input, inOutIdx, &length, inSz) < 0)
  40:	4633      	mov	r3, r6
  42:	aa02      	add	r2, sp, #8
  44:	4629      	mov	r1, r5
  46:	4638      	mov	r0, r7
  48:	f7ff fffe 	bl	0 <DecodeAsymKeyPublic>
  4c:	2800      	cmp	r0, #0
  4e:	dbf1      	blt.n	34 <DecodeAsymKeyPublic+0x34>
    if (GetObjectId(input, inOutIdx, &oid, oidKeyType, inSz) < 0)
  50:	9600      	str	r6, [sp, #0]
  52:	2302      	movs	r3, #2
  54:	aa03      	add	r2, sp, #12
  56:	4629      	mov	r1, r5
  58:	4638      	mov	r0, r7
  5a:	f7ff fffe 	bl	0 <DecodeAsymKeyPublic>
  5e:	2800      	cmp	r0, #0
  60:	dbe8      	blt.n	34 <DecodeAsymKeyPublic+0x34>
    if (oid != (word32)keyType)
  62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  64:	9a03      	ldr	r2, [sp, #12]
  66:	429a      	cmp	r2, r3
  68:	d1e4      	bne.n	34 <DecodeAsymKeyPublic+0x34>
    ret = CheckBitString(input, inOutIdx, &length, inSz, 1, NULL);
  6a:	2301      	movs	r3, #1
  6c:	2200      	movs	r2, #0
  6e:	e9cd 3200 	strd	r3, r2, [sp]
  72:	4629      	mov	r1, r5
  74:	4633      	mov	r3, r6
  76:	aa02      	add	r2, sp, #8
  78:	4638      	mov	r0, r7
  7a:	f7ff fffe 	bl	0 <DecodeAsymKeyPublic>
    if (ret != 0)
  7e:	4604      	mov	r4, r0
  80:	2800      	cmp	r0, #0
  82:	d1d9      	bne.n	38 <DecodeAsymKeyPublic+0x38>
    if ((word32)length > *pubKeyLen)
  84:	9a02      	ldr	r2, [sp, #8]
  86:	f8d9 3000 	ldr.w	r3, [r9]
  8a:	4293      	cmp	r3, r2
  8c:	d3d2      	bcc.n	34 <DecodeAsymKeyPublic+0x34>
    if (*inOutIdx + (word32)length != inSz)
  8e:	682b      	ldr	r3, [r5, #0]
  90:	4413      	add	r3, r2
  92:	42b3      	cmp	r3, r6
  94:	d1ce      	bne.n	34 <DecodeAsymKeyPublic+0x34>
    *pubKeyLen = (word32)length;
  96:	f8c9 2000 	str.w	r2, [r9]
    XMEMCPY(pubKey, input + *inOutIdx, *pubKeyLen);
  9a:	6829      	ldr	r1, [r5, #0]
  9c:	4640      	mov	r0, r8
  9e:	4439      	add	r1, r7
  a0:	f7ff fffe 	bl	0 <memcpy>
    return ret;
  a4:	e7c8      	b.n	38 <DecodeAsymKeyPublic+0x38>
        return BAD_FUNC_ARG;
  a6:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  aa:	e7c5      	b.n	38 <DecodeAsymKeyPublic+0x38>

Disassembly of section .text.wc_Ed25519PrivateKeyDecode:

00000000 <wc_Ed25519PrivateKeyDecode>:
#endif /* WC_ENABLE_ASYM_KEY_IMPORT */

#if defined(HAVE_ED25519) && defined(HAVE_ED25519_KEY_IMPORT)
int wc_Ed25519PrivateKeyDecode(const byte* input, word32* inOutIdx,
                               ed25519_key* key, word32 inSz)
{
   0:	b530      	push	{r4, r5, lr}
    int ret;
    byte privKey[ED25519_KEY_SIZE], pubKey[2*ED25519_PUB_KEY_SIZE+1];
    word32 privKeyLen = (word32)sizeof(privKey);
    word32 pubKeyLen = (word32)sizeof(pubKey);
   2:	f04f 0c20 	mov.w	ip, #32
{
   6:	b0a1      	sub	sp, #132	; 0x84
   8:	4614      	mov	r4, r2
   a:	461a      	mov	r2, r3
    word32 pubKeyLen = (word32)sizeof(pubKey);
   c:	2341      	movs	r3, #65	; 0x41
   e:	e9cd c305 	strd	ip, r3, [sp, #20]

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0) {
  12:	b1f0      	cbz	r0, 52 <wc_Ed25519PrivateKeyDecode+0x52>
  14:	b1e9      	cbz	r1, 52 <wc_Ed25519PrivateKeyDecode+0x52>
  16:	b1e4      	cbz	r4, 52 <wc_Ed25519PrivateKeyDecode+0x52>
  18:	b1da      	cbz	r2, 52 <wc_Ed25519PrivateKeyDecode+0x52>
        return BAD_FUNC_ARG;
    }

    ret = DecodeAsymKey(input, inOutIdx, inSz, privKey, &privKeyLen,
  1a:	f44f 7380 	mov.w	r3, #256	; 0x100
  1e:	9303      	str	r3, [sp, #12]
  20:	ab06      	add	r3, sp, #24
  22:	9302      	str	r3, [sp, #8]
  24:	ad0f      	add	r5, sp, #60	; 0x3c
  26:	ab05      	add	r3, sp, #20
  28:	9300      	str	r3, [sp, #0]
  2a:	9501      	str	r5, [sp, #4]
  2c:	ab07      	add	r3, sp, #28
  2e:	f7ff fffe 	bl	0 <wc_Ed25519PrivateKeyDecode>
        pubKey, &pubKeyLen, ED25519k);
    if (ret == 0) {
  32:	b930      	cbnz	r0, 42 <wc_Ed25519PrivateKeyDecode+0x42>
        if (pubKeyLen == 0) {
            ret = wc_ed25519_import_private_only(privKey, privKeyLen, key);
  34:	e9dd 1305 	ldrd	r1, r3, [sp, #20]
        if (pubKeyLen == 0) {
  38:	b92b      	cbnz	r3, 46 <wc_Ed25519PrivateKeyDecode+0x46>
            ret = wc_ed25519_import_private_only(privKey, privKeyLen, key);
  3a:	4622      	mov	r2, r4
  3c:	a807      	add	r0, sp, #28
  3e:	f7ff fffe 	bl	0 <wc_ed25519_import_private_only>
            ret = wc_ed25519_import_private_key(privKey, privKeyLen,
                pubKey, pubKeyLen, key);
        }
    }
    return ret;
}
  42:	b021      	add	sp, #132	; 0x84
  44:	bd30      	pop	{r4, r5, pc}
            ret = wc_ed25519_import_private_key(privKey, privKeyLen,
  46:	9400      	str	r4, [sp, #0]
  48:	462a      	mov	r2, r5
  4a:	a807      	add	r0, sp, #28
  4c:	f7ff fffe 	bl	0 <wc_ed25519_import_private_key>
  50:	e7f7      	b.n	42 <wc_Ed25519PrivateKeyDecode+0x42>
        return BAD_FUNC_ARG;
  52:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  56:	e7f4      	b.n	42 <wc_Ed25519PrivateKeyDecode+0x42>

Disassembly of section .text.wc_CheckPrivateKey:

00000000 <wc_CheckPrivateKey>:
{
   0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4699      	mov	r9, r3
   6:	468a      	mov	sl, r1
   8:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
   c:	4617      	mov	r7, r2
    if (privKey == NULL || pubKey == NULL) {
   e:	4680      	mov	r8, r0
  10:	2800      	cmp	r0, #0
  12:	f000 8086 	beq.w	122 <wc_CheckPrivateKey+0x122>
  16:	2a00      	cmp	r2, #0
  18:	f000 8083 	beq.w	122 <wc_CheckPrivateKey+0x122>
    if (ks == ECDSAk) {
  1c:	f240 2206 	movw	r2, #518	; 0x206
  20:	4293      	cmp	r3, r2
  22:	f04f 0000 	mov.w	r0, #0
  26:	d154      	bne.n	d2 <wc_CheckPrivateKey+0xd2>
        word32   privSz = MAX_ECC_BYTES;
  28:	2420      	movs	r4, #32
        word32   keyIdx = 0;
  2a:	e9cd 4002 	strd	r4, r0, [sp, #8]
        key_pair = (ecc_key*)XMALLOC(sizeof(ecc_key), NULL, DYNAMIC_TYPE_ECC);
  2e:	f44f 70de 	mov.w	r0, #444	; 0x1bc
  32:	f7ff fffe 	bl	0 <malloc>
        if (key_pair == NULL)
  36:	4605      	mov	r5, r0
  38:	b138      	cbz	r0, 4a <wc_CheckPrivateKey+0x4a>
        privDer = (byte*)XMALLOC(MAX_ECC_BYTES, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <malloc>
        if (privDer == NULL) {
  40:	4606      	mov	r6, r0
            XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);
  42:	4628      	mov	r0, r5
        if (privDer == NULL) {
  44:	b926      	cbnz	r6, 50 <wc_CheckPrivateKey+0x50>
            XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);
  46:	f7ff fffe 	bl	0 <free>
            return MEMORY_E;
  4a:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  4e:	e009      	b.n	64 <wc_CheckPrivateKey+0x64>
        if ((ret = wc_ecc_init(key_pair)) < 0) {
  50:	f7ff fffe 	bl	0 <wc_ecc_init>
  54:	1e04      	subs	r4, r0, #0
  56:	da09      	bge.n	6c <wc_CheckPrivateKey+0x6c>
        XFREE(privDer, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  58:	4630      	mov	r0, r6
  5a:	f7ff fffe 	bl	0 <free>
        XFREE(key_pair, NULL, DYNAMIC_TYPE_ECC);
  5e:	4628      	mov	r0, r5
  60:	f7ff fffe 	bl	0 <free>
}
  64:	4620      	mov	r0, r4
  66:	b004      	add	sp, #16
  68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if ((ret = wc_EccPrivateKeyDecode(privKey, &keyIdx, key_pair,
  6c:	4653      	mov	r3, sl
  6e:	462a      	mov	r2, r5
  70:	a903      	add	r1, sp, #12
  72:	4640      	mov	r0, r8
  74:	f7ff fffe 	bl	0 <wc_CheckPrivateKey>
  78:	4604      	mov	r4, r0
  7a:	bb18      	cbnz	r0, c4 <wc_CheckPrivateKey+0xc4>
            if ((ret = wc_ecc_export_private_only(key_pair, privDer, &privSz))
  7c:	aa02      	add	r2, sp, #8
  7e:	4631      	mov	r1, r6
  80:	4628      	mov	r0, r5
  82:	f7ff fffe 	bl	0 <wc_ecc_export_private_only>
  86:	4604      	mov	r4, r0
  88:	b9e0      	cbnz	r0, c4 <wc_CheckPrivateKey+0xc4>
                wc_ecc_free(key_pair);
  8a:	4628      	mov	r0, r5
  8c:	f7ff fffe 	bl	0 <wc_ecc_free>
                ret = wc_ecc_init(key_pair);
  90:	4628      	mov	r0, r5
  92:	f7ff fffe 	bl	0 <wc_ecc_init>
                if (ret == 0) {
  96:	4604      	mov	r4, r0
  98:	b970      	cbnz	r0, b8 <wc_CheckPrivateKey+0xb8>
                    ret = wc_ecc_import_private_key(privDer,
  9a:	9902      	ldr	r1, [sp, #8]
  9c:	9500      	str	r5, [sp, #0]
  9e:	464b      	mov	r3, r9
  a0:	463a      	mov	r2, r7
  a2:	4630      	mov	r0, r6
  a4:	f7ff fffe 	bl	0 <wc_ecc_import_private_key>
                if (ret == 0) {
  a8:	4604      	mov	r4, r0
  aa:	b928      	cbnz	r0, b8 <wc_CheckPrivateKey+0xb8>
                    if ((ret = wc_ecc_check_key(key_pair)) == 0) {
  ac:	4628      	mov	r0, r5
  ae:	f7ff fffe 	bl	0 <wc_ecc_check_key>
                        ret = 1;
  b2:	1e04      	subs	r4, r0, #0
  b4:	bf08      	it	eq
  b6:	2401      	moveq	r4, #1
    while (len--) *z++ = 0;
  b8:	9b02      	ldr	r3, [sp, #8]
  ba:	2100      	movs	r1, #0
  bc:	18f2      	adds	r2, r6, r3
  be:	4633      	mov	r3, r6
  c0:	4293      	cmp	r3, r2
  c2:	d103      	bne.n	cc <wc_CheckPrivateKey+0xcc>
        wc_ecc_free(key_pair);
  c4:	4628      	mov	r0, r5
  c6:	f7ff fffe 	bl	0 <wc_ecc_free>
  ca:	e7c5      	b.n	58 <wc_CheckPrivateKey+0x58>
  cc:	f803 1b01 	strb.w	r1, [r3], #1
  d0:	e7f6      	b.n	c0 <wc_CheckPrivateKey+0xc0>
    if (ks == ED25519k) {
  d2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  d6:	d127      	bne.n	128 <wc_CheckPrivateKey+0x128>
        word32       keyIdx = 0;
  d8:	9003      	str	r0, [sp, #12]
        key_pair = (ed25519_key*)XMALLOC(sizeof(ed25519_key), NULL,
  da:	2068      	movs	r0, #104	; 0x68
  dc:	f7ff fffe 	bl	0 <malloc>
        if (key_pair == NULL)
  e0:	4605      	mov	r5, r0
  e2:	2800      	cmp	r0, #0
  e4:	d0b1      	beq.n	4a <wc_CheckPrivateKey+0x4a>
        if ((ret = wc_ed25519_init(key_pair)) < 0) {
  e6:	f7ff fffe 	bl	0 <wc_ed25519_init>
  ea:	1e04      	subs	r4, r0, #0
  ec:	dbb7      	blt.n	5e <wc_CheckPrivateKey+0x5e>
        if ((ret = wc_Ed25519PrivateKeyDecode(privKey, &keyIdx, key_pair,
  ee:	4653      	mov	r3, sl
  f0:	462a      	mov	r2, r5
  f2:	a903      	add	r1, sp, #12
  f4:	4640      	mov	r0, r8
  f6:	f7ff fffe 	bl	0 <wc_CheckPrivateKey>
  fa:	4604      	mov	r4, r0
  fc:	b968      	cbnz	r0, 11a <wc_CheckPrivateKey+0x11a>
            keyIdx = 0;
  fe:	9003      	str	r0, [sp, #12]
            if ((ret = wc_ed25519_import_public(pubKey, pubKeySz,
 100:	462a      	mov	r2, r5
 102:	4649      	mov	r1, r9
 104:	4638      	mov	r0, r7
 106:	f7ff fffe 	bl	0 <wc_ed25519_import_public>
 10a:	4604      	mov	r4, r0
 10c:	b928      	cbnz	r0, 11a <wc_CheckPrivateKey+0x11a>
                if ((ret = wc_ed25519_check_key(key_pair)) == 0) {
 10e:	4628      	mov	r0, r5
 110:	f7ff fffe 	bl	0 <wc_ed25519_check_key>
                    ret = 1;
 114:	1e04      	subs	r4, r0, #0
 116:	bf08      	it	eq
 118:	2401      	moveq	r4, #1
        wc_ed25519_free(key_pair);
 11a:	4628      	mov	r0, r5
 11c:	f7ff fffe 	bl	0 <wc_ed25519_free>
        XFREE(key_pair, NULL, DYNAMIC_TYPE_ED25519);
 120:	e79d      	b.n	5e <wc_CheckPrivateKey+0x5e>
        return BAD_FUNC_ARG;
 122:	f06f 04ac 	mvn.w	r4, #172	; 0xac
 126:	e79d      	b.n	64 <wc_CheckPrivateKey+0x64>
        ret = 0;
 128:	4604      	mov	r4, r0
 12a:	e79b      	b.n	64 <wc_CheckPrivateKey+0x64>

Disassembly of section .text.wc_CheckPrivateKeyCert:

00000000 <wc_CheckPrivateKeyCert>:
{
   0:	b507      	push	{r0, r1, r2, lr}
    if (key == NULL || der == NULL) {
   2:	b148      	cbz	r0, 18 <wc_CheckPrivateKeyCert+0x18>
   4:	b142      	cbz	r2, 18 <wc_CheckPrivateKeyCert+0x18>
    return wc_CheckPrivateKey(key, keySz, der->publicKey,
   6:	8b93      	ldrh	r3, [r2, #28]
   8:	9300      	str	r3, [sp, #0]
   a:	e9d2 2300 	ldrd	r2, r3, [r2]
   e:	f7ff fffe 	bl	0 <wc_CheckPrivateKeyCert>
}
  12:	b003      	add	sp, #12
  14:	f85d fb04 	ldr.w	pc, [sp], #4
        return BAD_FUNC_ARG;
  18:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1c:	e7f9      	b.n	12 <wc_CheckPrivateKeyCert+0x12>

Disassembly of section .text.wc_Ed25519PublicKeyDecode:

00000000 <wc_Ed25519PublicKeyDecode>:

int wc_Ed25519PublicKeyDecode(const byte* input, word32* inOutIdx,
                              ed25519_key* key, word32 inSz)
{
   0:	b530      	push	{r4, r5, lr}
   2:	b095      	sub	sp, #84	; 0x54
   4:	4614      	mov	r4, r2
   6:	461a      	mov	r2, r3
    int ret;
    byte pubKey[2*ED25519_PUB_KEY_SIZE+1];
    word32 pubKeyLen = (word32)sizeof(pubKey);
   8:	2341      	movs	r3, #65	; 0x41
   a:	9302      	str	r3, [sp, #8]

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0) {
   c:	b190      	cbz	r0, 34 <wc_Ed25519PublicKeyDecode+0x34>
   e:	b189      	cbz	r1, 34 <wc_Ed25519PublicKeyDecode+0x34>
  10:	b184      	cbz	r4, 34 <wc_Ed25519PublicKeyDecode+0x34>
  12:	b17a      	cbz	r2, 34 <wc_Ed25519PublicKeyDecode+0x34>
        return BAD_FUNC_ARG;
    }

    ret = DecodeAsymKeyPublic(input, inOutIdx, inSz,
  14:	f44f 7380 	mov.w	r3, #256	; 0x100
  18:	9301      	str	r3, [sp, #4]
  1a:	ab02      	add	r3, sp, #8
  1c:	9300      	str	r3, [sp, #0]
  1e:	ab03      	add	r3, sp, #12
  20:	f7ff fffe 	bl	0 <wc_Ed25519PublicKeyDecode>
        pubKey, &pubKeyLen, ED25519k);
    if (ret == 0) {
  24:	b920      	cbnz	r0, 30 <wc_Ed25519PublicKeyDecode+0x30>
        ret = wc_ed25519_import_public(pubKey, pubKeyLen, key);
  26:	9902      	ldr	r1, [sp, #8]
  28:	4622      	mov	r2, r4
  2a:	a803      	add	r0, sp, #12
  2c:	f7ff fffe 	bl	0 <wc_ed25519_import_public>
    }
    return ret;
}
  30:	b015      	add	sp, #84	; 0x54
  32:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  34:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  38:	e7fa      	b.n	30 <wc_Ed25519PublicKeyDecode+0x30>

Disassembly of section .text.wc_Curve25519PrivateKeyDecode:

00000000 <wc_Curve25519PrivateKeyDecode>:
#endif /* HAVE_ED25519 && HAVE_ED25519_KEY_IMPORT */

#if defined(HAVE_CURVE25519) && defined(HAVE_CURVE25519_KEY_IMPORT)
int wc_Curve25519PrivateKeyDecode(const byte* input, word32* inOutIdx,
                               curve25519_key* key, word32 inSz)
{
   0:	b530      	push	{r4, r5, lr}
   2:	b08f      	sub	sp, #60	; 0x3c
   4:	4614      	mov	r4, r2
   6:	461a      	mov	r2, r3
    int ret;
    byte privKey[CURVE25519_KEYSIZE];
    word32 privKeyLen = CURVE25519_KEYSIZE;
   8:	2320      	movs	r3, #32
   a:	9305      	str	r3, [sp, #20]

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0) {
   c:	b1a0      	cbz	r0, 38 <wc_Curve25519PrivateKeyDecode+0x38>
   e:	b199      	cbz	r1, 38 <wc_Curve25519PrivateKeyDecode+0x38>
  10:	b194      	cbz	r4, 38 <wc_Curve25519PrivateKeyDecode+0x38>
  12:	b18a      	cbz	r2, 38 <wc_Curve25519PrivateKeyDecode+0x38>
        return BAD_FUNC_ARG;
    }

    ret = DecodeAsymKey(input, inOutIdx, inSz, privKey, &privKeyLen,
  14:	2300      	movs	r3, #0
  16:	25fe      	movs	r5, #254	; 0xfe
  18:	e9cd 3502 	strd	r3, r5, [sp, #8]
  1c:	9301      	str	r3, [sp, #4]
  1e:	ab05      	add	r3, sp, #20
  20:	9300      	str	r3, [sp, #0]
  22:	ab06      	add	r3, sp, #24
  24:	f7ff fffe 	bl	0 <wc_Curve25519PrivateKeyDecode>
        NULL, NULL, X25519k);
    if (ret == 0) {
  28:	b920      	cbnz	r0, 34 <wc_Curve25519PrivateKeyDecode+0x34>
        ret = wc_curve25519_import_private(privKey, privKeyLen, key);
  2a:	9905      	ldr	r1, [sp, #20]
  2c:	4622      	mov	r2, r4
  2e:	a806      	add	r0, sp, #24
  30:	f7ff fffe 	bl	0 <wc_curve25519_import_private>
    }
    return ret;
}
  34:	b00f      	add	sp, #60	; 0x3c
  36:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  38:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  3c:	e7fa      	b.n	34 <wc_Curve25519PrivateKeyDecode+0x34>

Disassembly of section .text.wc_Curve25519PublicKeyDecode:

00000000 <wc_Curve25519PublicKeyDecode>:

int wc_Curve25519PublicKeyDecode(const byte* input, word32* inOutIdx,
                              curve25519_key* key, word32 inSz)
{
   0:	b530      	push	{r4, r5, lr}
   2:	b08d      	sub	sp, #52	; 0x34
   4:	4614      	mov	r4, r2
   6:	461a      	mov	r2, r3
    int ret;
    byte pubKey[CURVE25519_KEYSIZE];
    word32 pubKeyLen = (word32)sizeof(pubKey);
   8:	2320      	movs	r3, #32
   a:	9303      	str	r3, [sp, #12]

    if (input == NULL || inOutIdx == NULL || key == NULL || inSz == 0) {
   c:	b188      	cbz	r0, 32 <wc_Curve25519PublicKeyDecode+0x32>
   e:	b181      	cbz	r1, 32 <wc_Curve25519PublicKeyDecode+0x32>
  10:	b17c      	cbz	r4, 32 <wc_Curve25519PublicKeyDecode+0x32>
  12:	b172      	cbz	r2, 32 <wc_Curve25519PublicKeyDecode+0x32>
        return BAD_FUNC_ARG;
    }

    ret = DecodeAsymKeyPublic(input, inOutIdx, inSz,
  14:	23fe      	movs	r3, #254	; 0xfe
  16:	9301      	str	r3, [sp, #4]
  18:	ab03      	add	r3, sp, #12
  1a:	9300      	str	r3, [sp, #0]
  1c:	ab04      	add	r3, sp, #16
  1e:	f7ff fffe 	bl	0 <wc_Curve25519PublicKeyDecode>
        pubKey, &pubKeyLen, X25519k);
    if (ret == 0) {
  22:	b920      	cbnz	r0, 2e <wc_Curve25519PublicKeyDecode+0x2e>
        ret = wc_curve25519_import_public(pubKey, pubKeyLen, key);
  24:	9903      	ldr	r1, [sp, #12]
  26:	4622      	mov	r2, r4
  28:	a804      	add	r0, sp, #16
  2a:	f7ff fffe 	bl	0 <wc_curve25519_import_public>
    }
    return ret;
}
  2e:	b00d      	add	sp, #52	; 0x34
  30:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  32:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  36:	e7fa      	b.n	2e <wc_Curve25519PublicKeyDecode+0x2e>

Disassembly of section .text.SetAsymKeyDer:

00000000 <SetAsymKeyDer>:
 * @return  MEMORY_E when dynamic memory allocation failed.
 */
int SetAsymKeyDer(const byte* privKey, word32 privKeyLen,
    const byte* pubKey, word32 pubKeyLen,
    byte* output, word32 outLen, int keyType)
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
   6:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
   a:	460e      	mov	r6, r1
   c:	4690      	mov	r8, r2
   e:	461f      	mov	r7, r3
    DECL_ASNSETDATA(dataASN, edKeyASN_Length);
    int sz;
#endif

    /* Validate parameters. */
    if (privKey == NULL || outLen == 0) {
  10:	4681      	mov	r9, r0
  12:	b918      	cbnz	r0, 1c <SetAsymKeyDer+0x1c>
        return BAD_FUNC_ARG;
  14:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    }

    FREE_ASNSETDATA(dataASN, NULL);
#endif
    return ret;
}
  18:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (privKey == NULL || outLen == 0) {
  1c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  1e:	2b00      	cmp	r3, #0
  20:	d0f8      	beq.n	14 <SetAsymKeyDer+0x14>
    if (pubKey) {
  22:	2a00      	cmp	r2, #0
  24:	d047      	beq.n	b6 <SetAsymKeyDer+0xb6>
        pubSz = 2 + pubKeyLen;
  26:	1cbc      	adds	r4, r7, #2
    algoSz = SetAlgoID(keyType, NULL, oidKeyType, 0);
  28:	2300      	movs	r3, #0
  2a:	4619      	mov	r1, r3
  2c:	2202      	movs	r2, #2
  2e:	4650      	mov	r0, sl
  30:	f7ff fffe 	bl	0 <SetAsymKeyDer>
    seqSz  = SetSequence(verSz + algoSz + privSz + pubSz, NULL);
  34:	1df3      	adds	r3, r6, #7
  36:	4423      	add	r3, r4
  38:	eb03 0b00 	add.w	fp, r3, r0
  3c:	2100      	movs	r1, #0
  3e:	4658      	mov	r0, fp
  40:	f7ff fffe 	bl	0 <SetAsymKeyDer>
    sz = seqSz + verSz + algoSz + privSz + pubSz;
  44:	eb0b 0400 	add.w	r4, fp, r0
    if (output != NULL && sz > outLen) {
  48:	b39d      	cbz	r5, b2 <SetAsymKeyDer+0xb2>
  4a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  4c:	42a3      	cmp	r3, r4
  4e:	d3e1      	bcc.n	14 <SetAsymKeyDer+0x14>
        seqSz = SetSequence(verSz + algoSz + privSz + pubSz, output);
  50:	4629      	mov	r1, r5
  52:	4658      	mov	r0, fp
  54:	f7ff fffe 	bl	0 <SetAsymKeyDer>
        SetMyVersion(0, output + idx, FALSE);
  58:	2200      	movs	r2, #0
        seqSz = SetSequence(verSz + algoSz + privSz + pubSz, output);
  5a:	4604      	mov	r4, r0
        SetMyVersion(0, output + idx, FALSE);
  5c:	1829      	adds	r1, r5, r0
        idx += verSz;
  5e:	3403      	adds	r4, #3
        SetMyVersion(0, output + idx, FALSE);
  60:	4610      	mov	r0, r2
  62:	f7ff fffe 	bl	0 <SetAsymKeyDer>
        algoSz = SetAlgoID(keyType, output + idx, oidKeyType, 0);
  66:	2300      	movs	r3, #0
  68:	2202      	movs	r2, #2
  6a:	1929      	adds	r1, r5, r4
  6c:	4650      	mov	r0, sl
  6e:	f7ff fffe 	bl	0 <SetAsymKeyDer>
        idx += algoSz;
  72:	4404      	add	r4, r0
        idx += SetOctetString(2 + privKeyLen, output + idx);
  74:	1929      	adds	r1, r5, r4
  76:	1cb0      	adds	r0, r6, #2
  78:	f7ff fffe 	bl	0 <SetAsymKeyDer>
  7c:	4404      	add	r4, r0
        idx += SetOctetString(privKeyLen, output + idx);
  7e:	1929      	adds	r1, r5, r4
  80:	4630      	mov	r0, r6
  82:	f7ff fffe 	bl	0 <SetAsymKeyDer>
  86:	4404      	add	r4, r0
        XMEMCPY(output + idx, privKey, privKeyLen);
  88:	1928      	adds	r0, r5, r4
  8a:	4632      	mov	r2, r6
  8c:	4649      	mov	r1, r9
  8e:	f7ff fffe 	bl	0 <memcpy>
        idx += privKeyLen;
  92:	4434      	add	r4, r6
        if (pubKey) {
  94:	f1b8 0f00 	cmp.w	r8, #0
  98:	d00b      	beq.n	b2 <SetAsymKeyDer+0xb2>
            idx += SetHeader(ASN_CONTEXT_SPECIFIC | ASN_ASYMKEY_PUBKEY |
  9a:	192a      	adds	r2, r5, r4
  9c:	4639      	mov	r1, r7
  9e:	2081      	movs	r0, #129	; 0x81
  a0:	f7ff fffe 	bl	0 <SetAsymKeyDer>
  a4:	4404      	add	r4, r0
            XMEMCPY(output + idx, pubKey, pubKeyLen);
  a6:	1928      	adds	r0, r5, r4
  a8:	463a      	mov	r2, r7
  aa:	4641      	mov	r1, r8
  ac:	f7ff fffe 	bl	0 <memcpy>
            idx += pubKeyLen;
  b0:	443c      	add	r4, r7
        ret = (int)sz;
  b2:	4620      	mov	r0, r4
  b4:	e7b0      	b.n	18 <SetAsymKeyDer+0x18>
    word32 idx = 0, seqSz, verSz, algoSz, privSz, pubSz = 0, sz;
  b6:	4614      	mov	r4, r2
  b8:	e7b6      	b.n	28 <SetAsymKeyDer+0x28>

Disassembly of section .text.wc_Ed25519KeyToDer:

00000000 <wc_Ed25519KeyToDer>:

#if defined(HAVE_ED25519) && defined(HAVE_ED25519_KEY_EXPORT)
/* Write a Private ED25519 key, including public to DER format,
 * length on success else < 0 */
int wc_Ed25519KeyToDer(ed25519_key* key, byte* output, word32 inLen)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   2:	4613      	mov	r3, r2
    if (key == NULL) {
   4:	4602      	mov	r2, r0
   6:	b160      	cbz	r0, 22 <wc_Ed25519KeyToDer+0x22>
        return BAD_FUNC_ARG;
    }
    return SetAsymKeyDer(key->k, ED25519_KEY_SIZE,
   8:	f44f 7080 	mov.w	r0, #256	; 0x100
   c:	e9cd 3001 	strd	r3, r0, [sp, #4]
  10:	2320      	movs	r3, #32
  12:	9100      	str	r1, [sp, #0]
  14:	18d0      	adds	r0, r2, r3
  16:	4619      	mov	r1, r3
  18:	f7ff fffe 	bl	0 <wc_Ed25519KeyToDer>
        key->p, ED25519_PUB_KEY_SIZE, output, inLen, ED25519k);
}
  1c:	b005      	add	sp, #20
  1e:	f85d fb04 	ldr.w	pc, [sp], #4
        return BAD_FUNC_ARG;
  22:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  26:	e7f9      	b.n	1c <wc_Ed25519KeyToDer+0x1c>

Disassembly of section .text.wc_Ed25519PrivateKeyToDer:

00000000 <wc_Ed25519PrivateKeyToDer>:

/* Write only private ED25519 key to DER format,
 * length on success else < 0 */
int wc_Ed25519PrivateKeyToDer(ed25519_key* key, byte* output, word32 inLen)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    if (key == NULL) {
   2:	b168      	cbz	r0, 20 <wc_Ed25519PrivateKeyToDer+0x20>
        return BAD_FUNC_ARG;
    }
    return SetAsymKeyDer(key->k, ED25519_KEY_SIZE,
   4:	f44f 7380 	mov.w	r3, #256	; 0x100
   8:	e9cd 2301 	strd	r2, r3, [sp, #4]
   c:	9100      	str	r1, [sp, #0]
   e:	2300      	movs	r3, #0
  10:	2120      	movs	r1, #32
  12:	461a      	mov	r2, r3
  14:	4408      	add	r0, r1
  16:	f7ff fffe 	bl	0 <wc_Ed25519PrivateKeyToDer>
        NULL, 0, output, inLen, ED25519k);
}
  1a:	b005      	add	sp, #20
  1c:	f85d fb04 	ldr.w	pc, [sp], #4
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  24:	e7f9      	b.n	1a <wc_Ed25519PrivateKeyToDer+0x1a>

Disassembly of section .text.wc_Curve25519PrivateKeyToDer:

00000000 <wc_Curve25519PrivateKeyToDer>:

#if defined(HAVE_CURVE25519) && defined(HAVE_CURVE25519_KEY_EXPORT)
/* Write only private Curve25519 key to DER format,
 * length on success else < 0 */
int wc_Curve25519PrivateKeyToDer(curve25519_key* key, byte* output, word32 inLen)
{
   0:	b530      	push	{r4, r5, lr}
   2:	b08f      	sub	sp, #60	; 0x3c
    int    ret;
    byte   privKey[CURVE25519_KEYSIZE];
    word32 privKeyLen = CURVE25519_KEYSIZE;
   4:	2320      	movs	r3, #32
{
   6:	460c      	mov	r4, r1
   8:	4615      	mov	r5, r2
    word32 privKeyLen = CURVE25519_KEYSIZE;
   a:	9305      	str	r3, [sp, #20]

    if (key == NULL) {
   c:	b180      	cbz	r0, 30 <wc_Curve25519PrivateKeyToDer+0x30>
        return BAD_FUNC_ARG;
    }

    ret = wc_curve25519_export_private_raw(key, privKey, &privKeyLen);
   e:	aa05      	add	r2, sp, #20
  10:	a906      	add	r1, sp, #24
  12:	f7ff fffe 	bl	0 <wc_curve25519_export_private_raw>
    if (ret == 0) {
  16:	b948      	cbnz	r0, 2c <wc_Curve25519PrivateKeyToDer+0x2c>
        ret = SetAsymKeyDer(privKey, privKeyLen, NULL, 0, output, inLen,
  18:	23fe      	movs	r3, #254	; 0xfe
  1a:	e9cd 5301 	strd	r5, r3, [sp, #4]
  1e:	4602      	mov	r2, r0
  20:	4603      	mov	r3, r0
  22:	9905      	ldr	r1, [sp, #20]
  24:	9400      	str	r4, [sp, #0]
  26:	a806      	add	r0, sp, #24
  28:	f7ff fffe 	bl	0 <wc_Curve25519PrivateKeyToDer>
            X25519k);
    }
    return ret;
}
  2c:	b00f      	add	sp, #60	; 0x3c
  2e:	bd30      	pop	{r4, r5, pc}
        return BAD_FUNC_ARG;
  30:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  34:	e7fa      	b.n	2c <wc_Curve25519PrivateKeyToDer+0x2c>

Disassembly of section .text.wc_Curve25519PublicKeyToDer:

00000000 <wc_Curve25519PublicKeyToDer>:

/* Write a public Curve25519 key to DER format,
 * length on success else < 0 */
int wc_Curve25519PublicKeyToDer(curve25519_key* key, byte* output, word32 inLen,
                             int withAlg)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b08c      	sub	sp, #48	; 0x30
   4:	461e      	mov	r6, r3
    int    ret;
    byte   pubKey[CURVE25519_PUB_KEY_SIZE];
    word32 pubKeyLen = (word32)sizeof(pubKey);
   6:	2320      	movs	r3, #32
{
   8:	460c      	mov	r4, r1
   a:	4615      	mov	r5, r2
    word32 pubKeyLen = (word32)sizeof(pubKey);
   c:	9303      	str	r3, [sp, #12]

    if (key == NULL || output == NULL) {
   e:	b180      	cbz	r0, 32 <wc_Curve25519PublicKeyToDer+0x32>
  10:	b179      	cbz	r1, 32 <wc_Curve25519PublicKeyToDer+0x32>
        return BAD_FUNC_ARG;
    }

    ret = wc_curve25519_export_public(key, pubKey, &pubKeyLen);
  12:	aa03      	add	r2, sp, #12
  14:	a904      	add	r1, sp, #16
  16:	f7ff fffe 	bl	0 <wc_curve25519_export_public>
    if (ret == 0) {
  1a:	b940      	cbnz	r0, 2e <wc_Curve25519PublicKeyToDer+0x2e>
        ret = SetAsymKeyDerPublic(pubKey, pubKeyLen, output, inLen,
  1c:	23fe      	movs	r3, #254	; 0xfe
  1e:	9300      	str	r3, [sp, #0]
  20:	9903      	ldr	r1, [sp, #12]
  22:	9601      	str	r6, [sp, #4]
  24:	462b      	mov	r3, r5
  26:	4622      	mov	r2, r4
  28:	a804      	add	r0, sp, #16
  2a:	f7ff fffe 	bl	0 <wc_Curve25519PublicKeyToDer>
            X25519k, withAlg);
    }
    return ret;
}
  2e:	b00c      	add	sp, #48	; 0x30
  30:	bd70      	pop	{r4, r5, r6, pc}
        return BAD_FUNC_ARG;
  32:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  36:	e7fa      	b.n	2e <wc_Curve25519PublicKeyToDer+0x2e>

Disassembly of section .text.GetNameHash_ex:

00000000 <GetNameHash_ex>:
}

/* store WC_SHA hash of NAME */
int GetNameHash_ex(const byte* source, word32* idx, byte* hash, int maxIdx,
    word32 sigOID)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	b085      	sub	sp, #20
   4:	4617      	mov	r7, r2
    word32 dummy;
    byte   tag;

    WOLFSSL_ENTER("GetNameHash");

    dummy = *idx;
   6:	680a      	ldr	r2, [r1, #0]
   8:	9203      	str	r2, [sp, #12]
{
   a:	460c      	mov	r4, r1
    if (GetASNTag(source, &dummy, &tag, (word32)maxIdx) == 0 &&
   c:	f10d 0207 	add.w	r2, sp, #7
  10:	a903      	add	r1, sp, #12
{
  12:	4605      	mov	r5, r0
  14:	461e      	mov	r6, r3
    if (GetASNTag(source, &dummy, &tag, (word32)maxIdx) == 0 &&
  16:	f7ff fffe 	bl	0 <GetNameHash_ex>
  1a:	b998      	cbnz	r0, 44 <GetNameHash_ex+0x44>
  1c:	f89d 3007 	ldrb.w	r3, [sp, #7]
  20:	2b06      	cmp	r3, #6
  22:	d10f      	bne.n	44 <GetNameHash_ex+0x44>
            tag == ASN_OBJECT_ID) {
        WOLFSSL_MSG("Trying optional prefix...");

        if (GetLength(source, idx, &length, (word32)maxIdx) < 0)
  24:	4633      	mov	r3, r6
  26:	aa02      	add	r2, sp, #8
  28:	4621      	mov	r1, r4
  2a:	4628      	mov	r0, r5
  2c:	f7ff fffe 	bl	0 <GetNameHash_ex>
  30:	2800      	cmp	r0, #0
  32:	da03      	bge.n	3c <GetNameHash_ex+0x3c>
            return ASN_PARSE_E;
  34:	f06f 008b 	mvn.w	r0, #139	; 0x8b
                hash, HashIdAlg(sigOID));
    }

    return ret;
#endif /* WOLFSSL_ASN_TEMPLATE */
}
  38:	b005      	add	sp, #20
  3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *idx += (word32)length;
  3c:	6823      	ldr	r3, [r4, #0]
  3e:	9a02      	ldr	r2, [sp, #8]
  40:	4413      	add	r3, r2
  42:	6023      	str	r3, [r4, #0]
    dummy = *idx;
  44:	6823      	ldr	r3, [r4, #0]
  46:	9303      	str	r3, [sp, #12]
    if (GetSequence(source, idx, &length, (word32)maxIdx) < 0)
  48:	aa02      	add	r2, sp, #8
  4a:	4633      	mov	r3, r6
  4c:	4621      	mov	r1, r4
  4e:	4628      	mov	r0, r5
  50:	f7ff fffe 	bl	0 <GetNameHash_ex>
  54:	2800      	cmp	r0, #0
  56:	dbed      	blt.n	34 <GetNameHash_ex+0x34>
    ret = CalcHashId_ex(source + dummy, (word32)length + *idx - dummy, hash,
  58:	e9dd 1002 	ldrd	r1, r0, [sp, #8]
  5c:	6823      	ldr	r3, [r4, #0]
  5e:	1a09      	subs	r1, r1, r0
        ret = wc_ShaHash(data, len, hash);
  60:	463a      	mov	r2, r7
  62:	4419      	add	r1, r3
  64:	4428      	add	r0, r5
  66:	f7ff fffe 	bl	0 <wc_ShaHash>
    *idx += (word32)length;
  6a:	6823      	ldr	r3, [r4, #0]
  6c:	9a02      	ldr	r2, [sp, #8]
  6e:	4413      	add	r3, r2
  70:	6023      	str	r3, [r4, #0]
    return ret;
  72:	e7e1      	b.n	38 <GetNameHash_ex+0x38>

Disassembly of section .text.GetNameHash:

00000000 <GetNameHash>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return GetNameHash_ex(source, idx, hash, maxIdx, 0);
   2:	2400      	movs	r4, #0
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <GetNameHash>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

blake2s.o:     file format elf32-littlearm


chacha.o:     file format elf32-littlearm


chacha20_poly1305.o:     file format elf32-littlearm


coding.o:     file format elf32-littlearm


Disassembly of section .text.Base64_Char2Val:

00000000 <Base64_Char2Val>:
     * 64 bytes in a cache line - first line has 64, second has 16
     */
    byte v;
    byte mask;

    c -= BASE64_MIN;
   0:	f1a0 032b 	sub.w	r3, r0, #43	; 0x2b
   4:	b2db      	uxtb	r3, r3
    mask = (byte)((((byte)(0x3f - c)) >> 7) - 1);
   6:	f1c3 023f 	rsb	r2, r3, #63	; 0x3f
    /* Load a value from the first cache line and use when mask set. */
    v  = (byte)(base64Decode[ c & 0x3f        ] &   mask);
   a:	f003 003f 	and.w	r0, r3, #63	; 0x3f
    /* Load a value from the second cache line and use when mask not set. */
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
   e:	f003 030f 	and.w	r3, r3, #15
    v  = (byte)(base64Decode[ c & 0x3f        ] &   mask);
  12:	4907      	ldr	r1, [pc, #28]	; (30 <Base64_Char2Val+0x30>)
{
  14:	b510      	push	{r4, lr}
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
  16:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    v  = (byte)(base64Decode[ c & 0x3f        ] &   mask);
  1a:	5c08      	ldrb	r0, [r1, r0]
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
  1c:	5ccb      	ldrb	r3, [r1, r3]
    mask = (byte)((((byte)(0x3f - c)) >> 7) - 1);
  1e:	f3c2 12c0 	ubfx	r2, r2, #7, #1
  22:	1e54      	subs	r4, r2, #1
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
  24:	4252      	negs	r2, r2
    v  = (byte)(base64Decode[ c & 0x3f        ] &   mask);
  26:	4020      	ands	r0, r4
    v |= (byte)(base64Decode[(c & 0x0f) | 0x40] & (~mask));
  28:	401a      	ands	r2, r3

    return v;
#else
    return base64Decode[c - BASE64_MIN];
#endif
}
  2a:	4310      	orrs	r0, r2
  2c:	bd10      	pop	{r4, pc}
  2e:	bf00      	nop
  30:	00000000 	.word	0x00000000

Disassembly of section .text.CEscape:

00000000 <CEscape>:

/* make sure *i (idx) won't exceed max, store and possibly escape to out,
 * raw means use e w/o decode,  0 on success */
static int CEscape(int escaped, byte e, byte* out, word32* i, word32 maxSz,
                  int raw, int getSzOnly)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	469c      	mov	ip, r3
   6:	e9dd 3e07 	ldrd	r3, lr, [sp, #28]
    int    doEscape = 0;
    word32 needed = 1;
    word32 idx = *i;
   a:	f8dc 4000 	ldr.w	r4, [ip]
    byte basic;
    byte plus    = 0;
    byte equals  = 0;
    byte newline = 0;

    if (raw)
   e:	b90b      	cbnz	r3, 14 <CEscape+0x14>
        basic = e;
    else
        basic = base64Encode[e];
  10:	4b2a      	ldr	r3, [pc, #168]	; (bc <CEscape+0xbc>)
  12:	5c59      	ldrb	r1, [r3, r1]

    /* check whether to escape. Only escape for EncodeEsc */
    if (escaped == WC_ESC_NL_ENC) {
  14:	2801      	cmp	r0, #1
  16:	d105      	bne.n	24 <CEscape+0x24>
        switch ((char)basic) {
  18:	292b      	cmp	r1, #43	; 0x2b
  1a:	d013      	beq.n	44 <CEscape+0x44>
  1c:	293d      	cmp	r1, #61	; 0x3d
  1e:	d016      	beq.n	4e <CEscape+0x4e>
  20:	290a      	cmp	r1, #10
  22:	d018      	beq.n	56 <CEscape+0x56>
    byte newline = 0;
  24:	2500      	movs	r5, #0
    byte equals  = 0;
  26:	462f      	mov	r7, r5
    byte plus    = 0;
  28:	462b      	mov	r3, r5
    word32 needed = 1;
  2a:	2601      	movs	r6, #1
    int    doEscape = 0;
  2c:	4628      	mov	r0, r5
                break;
        }
    }

    /* check size */
    if ( (idx+needed) > maxSz && !getSzOnly) {
  2e:	f8dd 8018 	ldr.w	r8, [sp, #24]
  32:	4426      	add	r6, r4
  34:	4546      	cmp	r6, r8
  36:	d912      	bls.n	5e <CEscape+0x5e>
  38:	f1be 0f00 	cmp.w	lr, #0
  3c:	d13b      	bne.n	b6 <CEscape+0xb6>
        WOLFSSL_MSG("Escape buffer max too small");
        return BUFFER_E;
  3e:	f06f 0083 	mvn.w	r0, #131	; 0x83
  42:	e015      	b.n	70 <CEscape+0x70>
    byte newline = 0;
  44:	2500      	movs	r5, #0
    byte equals  = 0;
  46:	462f      	mov	r7, r5
                plus     = 1;
  48:	4603      	mov	r3, r0
                needed  += 2;
  4a:	2603      	movs	r6, #3
  4c:	e7ef      	b.n	2e <CEscape+0x2e>
    byte newline = 0;
  4e:	2500      	movs	r5, #0
                equals   = 1;
  50:	4607      	mov	r7, r0
    byte plus    = 0;
  52:	462b      	mov	r3, r5
  54:	e7f9      	b.n	4a <CEscape+0x4a>
    byte equals  = 0;
  56:	2700      	movs	r7, #0
                newline  = 1;
  58:	4605      	mov	r5, r0
    byte plus    = 0;
  5a:	463b      	mov	r3, r7
  5c:	e7f5      	b.n	4a <CEscape+0x4a>
    }

    /* store it */
    if (doEscape == 0) {
  5e:	b958      	cbnz	r0, 78 <CEscape+0x78>
        if(getSzOnly)
            idx++;
        else
            out[idx++] = basic;
  60:	1c60      	adds	r0, r4, #1
        if(getSzOnly)
  62:	f1be 0f00 	cmp.w	lr, #0
  66:	d005      	beq.n	74 <CEscape+0x74>
            idx++;
  68:	1c60      	adds	r0, r4, #1
                out[idx++] = '0';
                out[idx++] = 'A';
            }
        }
    }
    *i = idx;
  6a:	f8cc 0000 	str.w	r0, [ip]

    return 0;
  6e:	2000      	movs	r0, #0
}
  70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            out[idx++] = basic;
  74:	5511      	strb	r1, [r2, r4]
  76:	e7f8      	b.n	6a <CEscape+0x6a>
        if(getSzOnly)
  78:	f1be 0f00 	cmp.w	lr, #0
  7c:	d001      	beq.n	82 <CEscape+0x82>
            idx+=3;
  7e:	1ce0      	adds	r0, r4, #3
  80:	e7f3      	b.n	6a <CEscape+0x6a>
            out[idx++] = '%';  /* start escape */
  82:	2125      	movs	r1, #37	; 0x25
  84:	5511      	strb	r1, [r2, r4]
  86:	1c60      	adds	r0, r4, #1
            if (plus) {
  88:	b133      	cbz	r3, 98 <CEscape+0x98>
                out[idx++] = '2';
  8a:	2332      	movs	r3, #50	; 0x32
  8c:	5413      	strb	r3, [r2, r0]
                out[idx++] = 'B';
  8e:	1ce0      	adds	r0, r4, #3
  90:	4422      	add	r2, r4
  92:	2342      	movs	r3, #66	; 0x42
                out[idx++] = 'A';
  94:	7093      	strb	r3, [r2, #2]
  96:	e7e8      	b.n	6a <CEscape+0x6a>
            else if (equals) {
  98:	b12f      	cbz	r7, a6 <CEscape+0xa6>
                out[idx++] = '3';
  9a:	2333      	movs	r3, #51	; 0x33
  9c:	5413      	strb	r3, [r2, r0]
                out[idx++] = 'D';
  9e:	1ce0      	adds	r0, r4, #3
  a0:	4422      	add	r2, r4
  a2:	2344      	movs	r3, #68	; 0x44
  a4:	e7f6      	b.n	94 <CEscape+0x94>
            else if (newline) {
  a6:	2d00      	cmp	r5, #0
  a8:	d0df      	beq.n	6a <CEscape+0x6a>
                out[idx++] = '0';
  aa:	2330      	movs	r3, #48	; 0x30
  ac:	5413      	strb	r3, [r2, r0]
                out[idx++] = 'A';
  ae:	1ce0      	adds	r0, r4, #3
  b0:	4422      	add	r2, r4
  b2:	2341      	movs	r3, #65	; 0x41
  b4:	e7ee      	b.n	94 <CEscape+0x94>
    if (doEscape == 0) {
  b6:	2800      	cmp	r0, #0
  b8:	d0d6      	beq.n	68 <CEscape+0x68>
  ba:	e7e0      	b.n	7e <CEscape+0x7e>
  bc:	00000000 	.word	0x00000000

Disassembly of section .text.DoBase64_Encode:

00000000 <DoBase64_Encode>:

/* internal worker, handles both escaped and normal line endings.
   If out buffer is NULL, will return sz needed in outLen */
static int DoBase64_Encode(const byte* in, word32 inLen, byte* out,
                           word32* outLen, int escaped)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b08b      	sub	sp, #44	; 0x2c
   6:	461d      	mov	r5, r3
   8:	9e14      	ldr	r6, [sp, #80]	; 0x50
    int    ret = 0;
    word32 i = 0,
   a:	2300      	movs	r3, #0
{
   c:	460f      	mov	r7, r1
    word32 i = 0,
   e:	9309      	str	r3, [sp, #36]	; 0x24
           j = 0,
           n = 0;   /* new line counter */

    int    getSzOnly = (out == NULL);

    word32 outSz = (inLen + 3 - 1) / 3 * 4;
  10:	3102      	adds	r1, #2
  12:	2303      	movs	r3, #3
  14:	fbb1 f1f3 	udiv	r1, r1, r3
  18:	0089      	lsls	r1, r1, #2
    int    getSzOnly = (out == NULL);
  1a:	fab2 f482 	clz	r4, r2
    word32 addSz = (outSz + BASE64_LINE_SZ - 1) / BASE64_LINE_SZ;  /* new lines */
  1e:	f101 033f 	add.w	r3, r1, #63	; 0x3f

    if (escaped == WC_ESC_NL_ENC)
  22:	2e01      	cmp	r6, #1
{
  24:	4680      	mov	r8, r0
    int    getSzOnly = (out == NULL);
  26:	4693      	mov	fp, r2
  28:	ea4f 1454 	mov.w	r4, r4, lsr #5
    word32 addSz = (outSz + BASE64_LINE_SZ - 1) / BASE64_LINE_SZ;  /* new lines */
  2c:	ea4f 1393 	mov.w	r3, r3, lsr #6
    if (escaped == WC_ESC_NL_ENC)
  30:	f040 8089 	bne.w	146 <DoBase64_Encode+0x146>
        addSz *= 3;   /* instead of just \n, we're doing %0A triplet */
  34:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    else if (escaped == WC_NO_NL_ENC)
        addSz = 0;    /* encode without \n */

    outSz += addSz;
  38:	440b      	add	r3, r1
  3a:	9305      	str	r3, [sp, #20]

    /* if escaped we can't predetermine size for one pass encoding, but
     * make sure we have enough if no escapes are in input
     * Also need to ensure outLen valid before dereference */
    if (!outLen || (outSz > *outLen && !getSzOnly)) return BAD_FUNC_ARG;
  3c:	2d00      	cmp	r5, #0
  3e:	f000 80f0 	beq.w	222 <DoBase64_Encode+0x222>
  42:	682b      	ldr	r3, [r5, #0]
  44:	9a05      	ldr	r2, [sp, #20]
  46:	4293      	cmp	r3, r2
  48:	d203      	bcs.n	52 <DoBase64_Encode+0x52>
  4a:	f1bb 0f00 	cmp.w	fp, #0
  4e:	f040 80e8 	bne.w	222 <DoBase64_Encode+0x222>
        addSz = 0;    /* encode without \n */
  52:	2300      	movs	r3, #0
  54:	46c1      	mov	r9, r8
  56:	9304      	str	r3, [sp, #16]

    while (inLen > 2) {
  58:	2f02      	cmp	r7, #2
  5a:	eba9 0008 	sub.w	r0, r9, r8
  5e:	d876      	bhi.n	14e <DoBase64_Encode+0x14e>
            if (ret != 0) break;
        }
    }

    /* last integral */
    if (inLen && ret == 0) {
  60:	2f00      	cmp	r7, #0
  62:	d046      	beq.n	f2 <DoBase64_Encode+0xf2>
        int twoBytes = (inLen == 2);

        byte b1 = in[j++];
        byte b2 = (twoBytes) ? in[j++] : 0;
  64:	2f02      	cmp	r7, #2
        byte b1 = in[j++];
  66:	f818 9000 	ldrb.w	r9, [r8, r0]
        byte b2 = (twoBytes) ? in[j++] : 0;
  6a:	bf08      	it	eq
  6c:	4440      	addeq	r0, r8

        byte e1 = b1 >> 2;
        byte e2 = (byte)(((b1 & 0x3) << 4) | (b2 >> 4));
        byte e3 = (byte)((b2 & 0xF) << 2);

        ret = CEscape(escaped, e1, out, &i, *outLen, 0, getSzOnly);
  6e:	f04f 0300 	mov.w	r3, #0
        byte b2 = (twoBytes) ? in[j++] : 0;
  72:	bf08      	it	eq
  74:	f890 8001 	ldrbeq.w	r8, [r0, #1]
        ret = CEscape(escaped, e1, out, &i, *outLen, 0, getSzOnly);
  78:	9301      	str	r3, [sp, #4]
  7a:	682b      	ldr	r3, [r5, #0]
  7c:	9300      	str	r3, [sp, #0]
  7e:	9402      	str	r4, [sp, #8]
  80:	ab09      	add	r3, sp, #36	; 0x24
  82:	465a      	mov	r2, fp
  84:	ea4f 0199 	mov.w	r1, r9, lsr #2
  88:	4630      	mov	r0, r6
        byte b2 = (twoBytes) ? in[j++] : 0;
  8a:	bf18      	it	ne
  8c:	f04f 0800 	movne.w	r8, #0
        ret = CEscape(escaped, e1, out, &i, *outLen, 0, getSzOnly);
  90:	f7ff fffe 	bl	0 <DoBase64_Encode>
        if (ret == 0)
  94:	2800      	cmp	r0, #0
  96:	d13a      	bne.n	10e <DoBase64_Encode+0x10e>
        byte e2 = (byte)(((b1 & 0x3) << 4) | (b2 >> 4));
  98:	ea4f 1109 	mov.w	r1, r9, lsl #4
            ret = CEscape(escaped, e2, out, &i, *outLen, 0, getSzOnly);
  9c:	682b      	ldr	r3, [r5, #0]
  9e:	9300      	str	r3, [sp, #0]
        byte e2 = (byte)(((b1 & 0x3) << 4) | (b2 >> 4));
  a0:	f001 0130 	and.w	r1, r1, #48	; 0x30
            ret = CEscape(escaped, e2, out, &i, *outLen, 0, getSzOnly);
  a4:	e9cd 0401 	strd	r0, r4, [sp, #4]
  a8:	ab09      	add	r3, sp, #36	; 0x24
  aa:	465a      	mov	r2, fp
  ac:	ea41 1118 	orr.w	r1, r1, r8, lsr #4
  b0:	4630      	mov	r0, r6
  b2:	f7ff fffe 	bl	0 <DoBase64_Encode>
        if (ret == 0) {
  b6:	bb50      	cbnz	r0, 10e <DoBase64_Encode+0x10e>
            /* third */
            if (twoBytes)
  b8:	2f02      	cmp	r7, #2
                ret = CEscape(escaped, e3, out, &i, *outLen, 0, getSzOnly);
  ba:	682b      	ldr	r3, [r5, #0]
            if (twoBytes)
  bc:	f040 80a7 	bne.w	20e <DoBase64_Encode+0x20e>
                ret = CEscape(escaped, e3, out, &i, *outLen, 0, getSzOnly);
  c0:	e9cd 0401 	strd	r0, r4, [sp, #4]
        byte e3 = (byte)((b2 & 0xF) << 2);
  c4:	ea4f 0188 	mov.w	r1, r8, lsl #2
                ret = CEscape(escaped, e3, out, &i, *outLen, 0, getSzOnly);
  c8:	9300      	str	r3, [sp, #0]
  ca:	465a      	mov	r2, fp
  cc:	ab09      	add	r3, sp, #36	; 0x24
  ce:	f001 013c 	and.w	r1, r1, #60	; 0x3c
            else
                ret = CEscape(escaped, '=', out, &i, *outLen, 1, getSzOnly);
  d2:	4630      	mov	r0, r6
  d4:	f7ff fffe 	bl	0 <DoBase64_Encode>
        }
        /* fourth always pad */
        if (ret == 0)
  d8:	b9c8      	cbnz	r0, 10e <DoBase64_Encode+0x10e>
            ret = CEscape(escaped, '=', out, &i, *outLen, 1, getSzOnly);
  da:	2301      	movs	r3, #1
  dc:	9301      	str	r3, [sp, #4]
  de:	682b      	ldr	r3, [r5, #0]
  e0:	9300      	str	r3, [sp, #0]
  e2:	9402      	str	r4, [sp, #8]
  e4:	ab09      	add	r3, sp, #36	; 0x24
  e6:	465a      	mov	r2, fp
  e8:	213d      	movs	r1, #61	; 0x3d
  ea:	4630      	mov	r0, r6
  ec:	f7ff fffe 	bl	0 <DoBase64_Encode>
    }

    if (ret == 0 && escaped != WC_NO_NL_ENC)
  f0:	b968      	cbnz	r0, 10e <DoBase64_Encode+0x10e>
  f2:	2e02      	cmp	r6, #2
  f4:	f000 8093 	beq.w	21e <DoBase64_Encode+0x21e>
        ret = CEscape(escaped, '\n', out, &i, *outLen, 1, getSzOnly);
  f8:	2301      	movs	r3, #1
  fa:	9301      	str	r3, [sp, #4]
  fc:	682b      	ldr	r3, [r5, #0]
  fe:	9300      	str	r3, [sp, #0]
 100:	9402      	str	r4, [sp, #8]
 102:	ab09      	add	r3, sp, #36	; 0x24
 104:	465a      	mov	r2, fp
 106:	210a      	movs	r1, #10
 108:	4630      	mov	r0, r6
 10a:	f7ff fffe 	bl	0 <DoBase64_Encode>

    if (i != outSz && escaped != 1 && ret == 0)
 10e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 110:	9a05      	ldr	r2, [sp, #20]
 112:	4293      	cmp	r3, r2
 114:	d004      	beq.n	120 <DoBase64_Encode+0x120>
 116:	2e01      	cmp	r6, #1
 118:	d002      	beq.n	120 <DoBase64_Encode+0x120>
 11a:	2800      	cmp	r0, #0
 11c:	f000 8084 	beq.w	228 <DoBase64_Encode+0x228>
        return ASN_INPUT_E;
/* If the output buffer has a room for an extra byte, add a null terminator */
    if (out && *outLen > i)
 120:	f1bb 0f00 	cmp.w	fp, #0
 124:	d005      	beq.n	132 <DoBase64_Encode+0x132>
 126:	6829      	ldr	r1, [r5, #0]
 128:	428b      	cmp	r3, r1
        out[i]= '\0';
 12a:	bf3c      	itt	cc
 12c:	2100      	movcc	r1, #0
 12e:	f80b 1003 	strbcc.w	r1, [fp, r3]

    *outLen = i;
 132:	602b      	str	r3, [r5, #0]

    if (ret == 0)
 134:	b920      	cbnz	r0, 140 <DoBase64_Encode+0x140>
        return getSzOnly ? LENGTH_ONLY_E : 0;
 136:	f1bb 0f00 	cmp.w	fp, #0
 13a:	bf08      	it	eq
 13c:	f06f 00c9 	mvneq.w	r0, #201	; 0xc9

    return ret;
}
 140:	b00b      	add	sp, #44	; 0x2c
 142:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        addSz = 0;    /* encode without \n */
 146:	2e02      	cmp	r6, #2
 148:	bf08      	it	eq
 14a:	2300      	moveq	r3, #0
 14c:	e774      	b.n	38 <DoBase64_Encode+0x38>
        byte b1 = in[j++];
 14e:	f899 1000 	ldrb.w	r1, [r9]
        byte b2 = in[j++];
 152:	f899 3001 	ldrb.w	r3, [r9, #1]
        byte b3 = in[j++];
 156:	f899 0002 	ldrb.w	r0, [r9, #2]
        ret = CEscape(escaped, e1, out, &i, *outLen, 0, getSzOnly);
 15a:	9402      	str	r4, [sp, #8]
        byte e2 = (byte)(((b1 & 0x3) << 4) | (b2 >> 4));
 15c:	ea4f 1a01 	mov.w	sl, r1, lsl #4
 160:	f00a 0a30 	and.w	sl, sl, #48	; 0x30
 164:	ea4a 1a13 	orr.w	sl, sl, r3, lsr #4
        byte e3 = (byte)(((b2 & 0xF) << 2) | (b3 >> 6));
 168:	009b      	lsls	r3, r3, #2
 16a:	f003 033c 	and.w	r3, r3, #60	; 0x3c
 16e:	ea43 1390 	orr.w	r3, r3, r0, lsr #6
 172:	9306      	str	r3, [sp, #24]
        byte e4 = b3 & 0x3F;
 174:	f000 033f 	and.w	r3, r0, #63	; 0x3f
 178:	9307      	str	r3, [sp, #28]
        ret = CEscape(escaped, e1, out, &i, *outLen, 0, getSzOnly);
 17a:	2300      	movs	r3, #0
 17c:	9301      	str	r3, [sp, #4]
 17e:	682b      	ldr	r3, [r5, #0]
 180:	9300      	str	r3, [sp, #0]
 182:	465a      	mov	r2, fp
 184:	ab09      	add	r3, sp, #36	; 0x24
 186:	0889      	lsrs	r1, r1, #2
 188:	4630      	mov	r0, r6
 18a:	f7ff fffe 	bl	0 <DoBase64_Encode>
        if (ret != 0) break;
 18e:	2800      	cmp	r0, #0
 190:	d1bd      	bne.n	10e <DoBase64_Encode+0x10e>
        ret = CEscape(escaped, e2, out, &i, *outLen, 0, getSzOnly);
 192:	682b      	ldr	r3, [r5, #0]
 194:	9300      	str	r3, [sp, #0]
 196:	e9cd 0401 	strd	r0, r4, [sp, #4]
 19a:	ab09      	add	r3, sp, #36	; 0x24
 19c:	465a      	mov	r2, fp
 19e:	4651      	mov	r1, sl
 1a0:	4630      	mov	r0, r6
 1a2:	f7ff fffe 	bl	0 <DoBase64_Encode>
        if (ret != 0) break;
 1a6:	2800      	cmp	r0, #0
 1a8:	d1b1      	bne.n	10e <DoBase64_Encode+0x10e>
        ret = CEscape(escaped, e3, out, &i, *outLen, 0, getSzOnly);
 1aa:	682b      	ldr	r3, [r5, #0]
 1ac:	9300      	str	r3, [sp, #0]
 1ae:	e9cd 0401 	strd	r0, r4, [sp, #4]
 1b2:	9906      	ldr	r1, [sp, #24]
 1b4:	ab09      	add	r3, sp, #36	; 0x24
 1b6:	465a      	mov	r2, fp
 1b8:	4630      	mov	r0, r6
 1ba:	f7ff fffe 	bl	0 <DoBase64_Encode>
        if (ret != 0) break;
 1be:	2800      	cmp	r0, #0
 1c0:	d1a5      	bne.n	10e <DoBase64_Encode+0x10e>
        ret = CEscape(escaped, e4, out, &i, *outLen, 0, getSzOnly);
 1c2:	682b      	ldr	r3, [r5, #0]
 1c4:	9300      	str	r3, [sp, #0]
 1c6:	e9cd 0401 	strd	r0, r4, [sp, #4]
 1ca:	9907      	ldr	r1, [sp, #28]
 1cc:	ab09      	add	r3, sp, #36	; 0x24
 1ce:	465a      	mov	r2, fp
 1d0:	4630      	mov	r0, r6
 1d2:	f7ff fffe 	bl	0 <DoBase64_Encode>
        if (ret != 0) break;
 1d6:	2800      	cmp	r0, #0
 1d8:	d199      	bne.n	10e <DoBase64_Encode+0x10e>
        if (escaped != WC_NO_NL_ENC && (++n % (BASE64_LINE_SZ/4)) == 0 && inLen) {
 1da:	2e02      	cmp	r6, #2
        inLen -= 3;
 1dc:	f1a7 0703 	sub.w	r7, r7, #3
        if (escaped != WC_NO_NL_ENC && (++n % (BASE64_LINE_SZ/4)) == 0 && inLen) {
 1e0:	d012      	beq.n	208 <DoBase64_Encode+0x208>
 1e2:	9b04      	ldr	r3, [sp, #16]
 1e4:	3301      	adds	r3, #1
 1e6:	9304      	str	r3, [sp, #16]
 1e8:	071b      	lsls	r3, r3, #28
 1ea:	d10d      	bne.n	208 <DoBase64_Encode+0x208>
 1ec:	b167      	cbz	r7, 208 <DoBase64_Encode+0x208>
            ret = CEscape(escaped, '\n', out, &i, *outLen, 1, getSzOnly);
 1ee:	2301      	movs	r3, #1
 1f0:	9301      	str	r3, [sp, #4]
 1f2:	682b      	ldr	r3, [r5, #0]
 1f4:	9300      	str	r3, [sp, #0]
 1f6:	9402      	str	r4, [sp, #8]
 1f8:	ab09      	add	r3, sp, #36	; 0x24
 1fa:	465a      	mov	r2, fp
 1fc:	210a      	movs	r1, #10
 1fe:	4630      	mov	r0, r6
 200:	f7ff fffe 	bl	0 <DoBase64_Encode>
            if (ret != 0) break;
 204:	2800      	cmp	r0, #0
 206:	d182      	bne.n	10e <DoBase64_Encode+0x10e>
 208:	f109 0903 	add.w	r9, r9, #3
 20c:	e724      	b.n	58 <DoBase64_Encode+0x58>
                ret = CEscape(escaped, '=', out, &i, *outLen, 1, getSzOnly);
 20e:	2101      	movs	r1, #1
 210:	e9cd 3100 	strd	r3, r1, [sp]
 214:	9402      	str	r4, [sp, #8]
 216:	ab09      	add	r3, sp, #36	; 0x24
 218:	465a      	mov	r2, fp
 21a:	213d      	movs	r1, #61	; 0x3d
 21c:	e759      	b.n	d2 <DoBase64_Encode+0xd2>
 21e:	2000      	movs	r0, #0
 220:	e775      	b.n	10e <DoBase64_Encode+0x10e>
    if (!outLen || (outSz > *outLen && !getSzOnly)) return BAD_FUNC_ARG;
 222:	f06f 00ac 	mvn.w	r0, #172	; 0xac
 226:	e78b      	b.n	140 <DoBase64_Encode+0x140>
        return ASN_INPUT_E;
 228:	f06f 0099 	mvn.w	r0, #153	; 0x99
 22c:	e788      	b.n	140 <DoBase64_Encode+0x140>

Disassembly of section .text.Base64_SkipNewline:

00000000 <Base64_SkipNewline>:
    word32 len = *inLen;
   0:	680b      	ldr	r3, [r1, #0]
{
   2:	b5f0      	push	{r4, r5, r6, r7, lr}
    word32 j = *outJ;
   4:	6814      	ldr	r4, [r2, #0]
    if (len == 0) {
   6:	b353      	cbz	r3, 5e <Base64_SkipNewline+0x5e>
    curChar = in[j];
   8:	5d05      	ldrb	r5, [r0, r4]
    while (len > 1 && curChar == ' ') {
   a:	2b01      	cmp	r3, #1
   c:	d001      	beq.n	12 <Base64_SkipNewline+0x12>
   e:	2d20      	cmp	r5, #32
  10:	d019      	beq.n	46 <Base64_SkipNewline+0x46>
    if (len && (curChar == '\r' || curChar == '\n')) {
  12:	2d0d      	cmp	r5, #13
  14:	d001      	beq.n	1a <Base64_SkipNewline+0x1a>
  16:	2d0a      	cmp	r5, #10
  18:	d10f      	bne.n	3a <Base64_SkipNewline+0x3a>
        if (curChar == '\r') {
  1a:	2d0d      	cmp	r5, #13
        j++;
  1c:	f104 0701 	add.w	r7, r4, #1
        len--;
  20:	f103 36ff 	add.w	r6, r3, #4294967295	; 0xffffffff
        if (curChar == '\r') {
  24:	d103      	bne.n	2e <Base64_SkipNewline+0x2e>
            if (len) {
  26:	b1be      	cbz	r6, 58 <Base64_SkipNewline+0x58>
                curChar = in[j++];
  28:	5dc5      	ldrb	r5, [r0, r7]
                len--;
  2a:	1e9e      	subs	r6, r3, #2
                curChar = in[j++];
  2c:	1ca7      	adds	r7, r4, #2
        if (curChar != '\n') {
  2e:	2d0a      	cmp	r5, #10
  30:	d112      	bne.n	58 <Base64_SkipNewline+0x58>
        if (len) {
  32:	b1a6      	cbz	r6, 5e <Base64_SkipNewline+0x5e>
            curChar = in[j];
  34:	5dc5      	ldrb	r5, [r0, r7]
  36:	463c      	mov	r4, r7
  38:	4633      	mov	r3, r6
    while (len && curChar == ' ') {
  3a:	2d20      	cmp	r5, #32
  3c:	d007      	beq.n	4e <Base64_SkipNewline+0x4e>
    *inLen = len;
  3e:	600b      	str	r3, [r1, #0]
    return 0;
  40:	2000      	movs	r0, #0
    *outJ = j;
  42:	6014      	str	r4, [r2, #0]
    return 0;
  44:	e00a      	b.n	5c <Base64_SkipNewline+0x5c>
        curChar = in[++j];
  46:	3401      	adds	r4, #1
        len--;
  48:	3b01      	subs	r3, #1
        curChar = in[++j];
  4a:	5d05      	ldrb	r5, [r0, r4]
        len--;
  4c:	e7dd      	b.n	a <Base64_SkipNewline+0xa>
        if (--len > 0) {
  4e:	3b01      	subs	r3, #1
  50:	d005      	beq.n	5e <Base64_SkipNewline+0x5e>
            curChar = in[++j];
  52:	3401      	adds	r4, #1
  54:	5d05      	ldrb	r5, [r0, r4]
    while (len && curChar == ' ') {
  56:	e7f0      	b.n	3a <Base64_SkipNewline+0x3a>
            return ASN_INPUT_E;
  58:	f06f 0099 	mvn.w	r0, #153	; 0x99
}
  5c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return BUFFER_E;
  5e:	f06f 0083 	mvn.w	r0, #131	; 0x83
  62:	e7fb      	b.n	5c <Base64_SkipNewline+0x5c>

Disassembly of section .text.Base64_Decode:

00000000 <Base64_Decode>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b087      	sub	sp, #28
   6:	4699      	mov	r9, r3
   8:	9103      	str	r1, [sp, #12]
    plainSz = (plainSz * 3 + 3) / 4;
   a:	1c4b      	adds	r3, r1, #1
    word32 plainSz = inLen - ((inLen + (BASE64_LINE_SZ - 1)) / BASE64_LINE_SZ );
   c:	313f      	adds	r1, #63	; 0x3f
    plainSz = (plainSz * 3 + 3) / 4;
   e:	eba3 1191 	sub.w	r1, r3, r1, lsr #6
    if (plainSz > *outLen) return BAD_FUNC_ARG;
  12:	f8d9 3000 	ldr.w	r3, [r9]
    plainSz = (plainSz * 3 + 3) / 4;
  16:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    word32 j = 0;
  1a:	2500      	movs	r5, #0
    if (plainSz > *outLen) return BAD_FUNC_ARG;
  1c:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
{
  20:	4606      	mov	r6, r0
  22:	4690      	mov	r8, r2
    word32 j = 0;
  24:	9505      	str	r5, [sp, #20]
    if (plainSz > *outLen) return BAD_FUNC_ARG;
  26:	f080 809a 	bcs.w	15e <Base64_Decode+0x15e>
  2a:	f06f 04ac 	mvn.w	r4, #172	; 0xac
}
  2e:	4620      	mov	r0, r4
  30:	b007      	add	sp, #28
  32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        e1 = in[j++];
  36:	9b05      	ldr	r3, [sp, #20]
  38:	f816 b003 	ldrb.w	fp, [r6, r3]
  3c:	1c58      	adds	r0, r3, #1
  3e:	9005      	str	r0, [sp, #20]
        if (e1 == '\0') {
  40:	f1bb 0f00 	cmp.w	fp, #0
  44:	f000 809b 	beq.w	17e <Base64_Decode+0x17e>
        inLen--;
  48:	9b03      	ldr	r3, [sp, #12]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
  4a:	4630      	mov	r0, r6
        inLen--;
  4c:	3b01      	subs	r3, #1
  4e:	9303      	str	r3, [sp, #12]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
  50:	f7ff fffe 	bl	0 <Base64_Decode>
  54:	4604      	mov	r4, r0
  56:	2800      	cmp	r0, #0
  58:	d1e9      	bne.n	2e <Base64_Decode+0x2e>
        e2 = in[j++];
  5a:	9b05      	ldr	r3, [sp, #20]
  5c:	1c58      	adds	r0, r3, #1
  5e:	5cf7      	ldrb	r7, [r6, r3]
        inLen--;
  60:	9b03      	ldr	r3, [sp, #12]
        e2 = in[j++];
  62:	9005      	str	r0, [sp, #20]
        inLen--;
  64:	3b01      	subs	r3, #1
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
  66:	4630      	mov	r0, r6
        inLen--;
  68:	9303      	str	r3, [sp, #12]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
  6a:	f7ff fffe 	bl	0 <Base64_Decode>
  6e:	4604      	mov	r4, r0
  70:	2800      	cmp	r0, #0
  72:	d1dc      	bne.n	2e <Base64_Decode+0x2e>
        e3 = in[j++];
  74:	9b05      	ldr	r3, [sp, #20]
  76:	1c58      	adds	r0, r3, #1
  78:	f816 a003 	ldrb.w	sl, [r6, r3]
        inLen--;
  7c:	9b03      	ldr	r3, [sp, #12]
        e3 = in[j++];
  7e:	9005      	str	r0, [sp, #20]
        inLen--;
  80:	3b01      	subs	r3, #1
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
  82:	4630      	mov	r0, r6
        inLen--;
  84:	9303      	str	r3, [sp, #12]
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
  86:	f7ff fffe 	bl	0 <Base64_Decode>
  8a:	4604      	mov	r4, r0
  8c:	2800      	cmp	r0, #0
  8e:	d1ce      	bne.n	2e <Base64_Decode+0x2e>
        e4 = in[j++];
  90:	9b05      	ldr	r3, [sp, #20]
  92:	1c5a      	adds	r2, r3, #1
  94:	9205      	str	r2, [sp, #20]
  96:	5cf3      	ldrb	r3, [r6, r3]
        inLen--;
  98:	9a03      	ldr	r2, [sp, #12]
        if (e4 == PAD)
  9a:	2b3d      	cmp	r3, #61	; 0x3d
        inLen--;
  9c:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
  a0:	9203      	str	r2, [sp, #12]
        if (e4 == PAD)
  a2:	d17e      	bne.n	1a2 <Base64_Decode+0x1a2>
            pad4 = 1;
  a4:	2401      	movs	r4, #1
        if (e1 < BASE64_MIN || e2 < BASE64_MIN || e3 < BASE64_MIN ||
  a6:	f1ab 022b 	sub.w	r2, fp, #43	; 0x2b
  aa:	2a4f      	cmp	r2, #79	; 0x4f
  ac:	d87d      	bhi.n	1aa <Base64_Decode+0x1aa>
  ae:	f1a7 022b 	sub.w	r2, r7, #43	; 0x2b
  b2:	2a4f      	cmp	r2, #79	; 0x4f
  b4:	d879      	bhi.n	1aa <Base64_Decode+0x1aa>
  b6:	f1aa 022b 	sub.w	r2, sl, #43	; 0x2b
  ba:	2a4f      	cmp	r2, #79	; 0x4f
  bc:	d875      	bhi.n	1aa <Base64_Decode+0x1aa>
  be:	f1a3 022b 	sub.w	r2, r3, #43	; 0x2b
  c2:	2a4f      	cmp	r2, #79	; 0x4f
  c4:	9301      	str	r3, [sp, #4]
  c6:	d870      	bhi.n	1aa <Base64_Decode+0x1aa>
        if (i + 1 + !pad3 + !pad4 > *outLen) {
  c8:	f1ba 023d 	subs.w	r2, sl, #61	; 0x3d
  cc:	bf18      	it	ne
  ce:	2201      	movne	r2, #1
  d0:	3201      	adds	r2, #1
  d2:	f084 0101 	eor.w	r1, r4, #1
  d6:	442a      	add	r2, r5
  d8:	440a      	add	r2, r1
  da:	f8d9 1000 	ldr.w	r1, [r9]
  de:	428a      	cmp	r2, r1
  e0:	d8a3      	bhi.n	2a <Base64_Decode+0x2a>
        e1 = Base64_Char2Val(e1);
  e2:	4658      	mov	r0, fp
  e4:	f7ff fffe 	bl	0 <Base64_Decode>
  e8:	4683      	mov	fp, r0
        e2 = Base64_Char2Val(e2);
  ea:	4638      	mov	r0, r7
  ec:	f7ff fffe 	bl	0 <Base64_Decode>
        e3 = (byte)((e3 == PAD) ? 0 : Base64_Char2Val(e3));
  f0:	f1ba 0f3d 	cmp.w	sl, #61	; 0x3d
  f4:	9b01      	ldr	r3, [sp, #4]
        e2 = Base64_Char2Val(e2);
  f6:	4602      	mov	r2, r0
        e3 = (byte)((e3 == PAD) ? 0 : Base64_Char2Val(e3));
  f8:	d04f      	beq.n	19a <Base64_Decode+0x19a>
  fa:	9002      	str	r0, [sp, #8]
  fc:	4650      	mov	r0, sl
  fe:	f7ff fffe 	bl	0 <Base64_Decode>
 102:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 106:	4607      	mov	r7, r0
        e4 = (byte)((e4 == PAD) ? 0 : Base64_Char2Val(e4));
 108:	2b3d      	cmp	r3, #61	; 0x3d
 10a:	d048      	beq.n	19e <Base64_Decode+0x19e>
 10c:	4618      	mov	r0, r3
 10e:	9201      	str	r2, [sp, #4]
 110:	f7ff fffe 	bl	0 <Base64_Decode>
 114:	9a01      	ldr	r2, [sp, #4]
        if (e1 == BAD || e2 == BAD || e3 == BAD || e4 == BAD) {
 116:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 11a:	d046      	beq.n	1aa <Base64_Decode+0x1aa>
 11c:	2aff      	cmp	r2, #255	; 0xff
 11e:	d044      	beq.n	1aa <Base64_Decode+0x1aa>
 120:	2fff      	cmp	r7, #255	; 0xff
 122:	d042      	beq.n	1aa <Base64_Decode+0x1aa>
 124:	28ff      	cmp	r0, #255	; 0xff
 126:	d040      	beq.n	1aa <Base64_Decode+0x1aa>
        if (!pad3)
 128:	f1ba 0f3d 	cmp.w	sl, #61	; 0x3d
        b3 = (byte)(((e3 & 0x3) << 6) | e4);
 12c:	ea40 1087 	orr.w	r0, r0, r7, lsl #6
        out[i++] = b1;
 130:	f105 0301 	add.w	r3, r5, #1
        b2 = (byte)(((e2 & 0xF) << 4) | (e3 >> 2));
 134:	bf18      	it	ne
 136:	08bf      	lsrne	r7, r7, #2
        b1 = (byte)((e1 << 2) | (e2 >> 4));
 138:	ea4f 1112 	mov.w	r1, r2, lsr #4
 13c:	ea41 0b8b 	orr.w	fp, r1, fp, lsl #2
        b2 = (byte)(((e2 & 0xF) << 4) | (e3 >> 2));
 140:	bf18      	it	ne
 142:	ea47 1702 	orrne.w	r7, r7, r2, lsl #4
        out[i++] = b1;
 146:	f808 b005 	strb.w	fp, [r8, r5]
        b3 = (byte)(((e3 & 0x3) << 6) | e4);
 14a:	b2c0      	uxtb	r0, r0
            out[i++] = b2;
 14c:	bf1a      	itte	ne
 14e:	f808 7003 	strbne.w	r7, [r8, r3]
 152:	3502      	addne	r5, #2
        out[i++] = b1;
 154:	461d      	moveq	r5, r3
        if (!pad4)
 156:	b994      	cbnz	r4, 17e <Base64_Decode+0x17e>
            out[i++] = b3;
 158:	f808 0005 	strb.w	r0, [r8, r5]
 15c:	3501      	adds	r5, #1
    while (inLen > 3) {
 15e:	9b03      	ldr	r3, [sp, #12]
 160:	2b03      	cmp	r3, #3
 162:	d90c      	bls.n	17e <Base64_Decode+0x17e>
        if ((ret = Base64_SkipNewline(in, &inLen, &j)) != 0) {
 164:	aa05      	add	r2, sp, #20
 166:	a903      	add	r1, sp, #12
 168:	4630      	mov	r0, r6
 16a:	f7ff fffe 	bl	0 <Base64_Decode>
 16e:	4604      	mov	r4, r0
 170:	2800      	cmp	r0, #0
 172:	f43f af60 	beq.w	36 <Base64_Decode+0x36>
            if (ret == BUFFER_E) {
 176:	f110 0f84 	cmn.w	r0, #132	; 0x84
 17a:	f47f af58 	bne.w	2e <Base64_Decode+0x2e>
    if (out && *outLen > i)
 17e:	f1b8 0f00 	cmp.w	r8, #0
 182:	d006      	beq.n	192 <Base64_Decode+0x192>
 184:	f8d9 3000 	ldr.w	r3, [r9]
 188:	42ab      	cmp	r3, r5
        out[i]= '\0';
 18a:	bf84      	itt	hi
 18c:	2300      	movhi	r3, #0
 18e:	f808 3005 	strbhi.w	r3, [r8, r5]
    *outLen = i;
 192:	f8c9 5000 	str.w	r5, [r9]
    return 0;
 196:	2400      	movs	r4, #0
 198:	e749      	b.n	2e <Base64_Decode+0x2e>
        e3 = (byte)((e3 == PAD) ? 0 : Base64_Char2Val(e3));
 19a:	2700      	movs	r7, #0
 19c:	e7b4      	b.n	108 <Base64_Decode+0x108>
        e4 = (byte)((e4 == PAD) ? 0 : Base64_Char2Val(e4));
 19e:	2000      	movs	r0, #0
 1a0:	e7b9      	b.n	116 <Base64_Decode+0x116>
        if (pad3 && !pad4)
 1a2:	f1ba 0f3d 	cmp.w	sl, #61	; 0x3d
 1a6:	f47f af7e 	bne.w	a6 <Base64_Decode+0xa6>
            return ASN_INPUT_E;
 1aa:	f06f 0499 	mvn.w	r4, #153	; 0x99
 1ae:	e73e      	b.n	2e <Base64_Decode+0x2e>

Disassembly of section .text.Base64_Encode:

00000000 <Base64_Encode>:


/* Base64 Encode, PEM style, with \n line endings */
int Base64_Encode(const byte* in, word32 inLen, byte* out, word32* outLen)
{
   0:	b513      	push	{r0, r1, r4, lr}
    return DoBase64_Encode(in, inLen, out, outLen, WC_STD_ENC);
   2:	2400      	movs	r4, #0
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <Base64_Encode>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.Base64_EncodeEsc:

00000000 <Base64_EncodeEsc>:


/* Base64 Encode, with %0A escaped line endings instead of \n */
int Base64_EncodeEsc(const byte* in, word32 inLen, byte* out, word32* outLen)
{
   0:	b513      	push	{r0, r1, r4, lr}
    return DoBase64_Encode(in, inLen, out, outLen, WC_ESC_NL_ENC);
   2:	2401      	movs	r4, #1
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <Base64_EncodeEsc>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.Base64_Encode_NoNl:

00000000 <Base64_Encode_NoNl>:

int Base64_Encode_NoNl(const byte* in, word32 inLen, byte* out, word32* outLen)
{
   0:	b513      	push	{r0, r1, r4, lr}
    return DoBase64_Encode(in, inLen, out, outLen, WC_NO_NL_ENC);
   2:	2402      	movs	r4, #2
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <Base64_Encode_NoNl>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

compress.o:     file format elf32-littlearm


cpuid.o:     file format elf32-littlearm


cryptocb.o:     file format elf32-littlearm


curve25519.o:     file format elf32-littlearm


Disassembly of section .text.curve25519_copy_point:

00000000 <curve25519_copy_point>:
}

static WC_INLINE void curve25519_copy_point(byte* out, const byte* point,
    int endian)
{
    if (endian == EC25519_BIG_ENDIAN) {
   0:	2a01      	cmp	r2, #1
{
   2:	b410      	push	{r4}
   4:	460c      	mov	r4, r1
    if (endian == EC25519_BIG_ENDIAN) {
   6:	d10a      	bne.n	1e <curve25519_copy_point+0x1e>
   8:	f101 0220 	add.w	r2, r1, #32
   c:	3801      	subs	r0, #1
        int i;
        /* put shared secret key in Big Endian format */
        for (i = 0; i < CURVE25519_KEYSIZE; i++) {
            out[i] = point[CURVE25519_KEYSIZE - i -1];
   e:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
  12:	f800 3f01 	strb.w	r3, [r0, #1]!
        for (i = 0; i < CURVE25519_KEYSIZE; i++) {
  16:	42a2      	cmp	r2, r4
  18:	d1f9      	bne.n	e <curve25519_copy_point+0xe>
        }
    }
    else { /* put shared secret key in Little Endian format */
        XMEMCPY(out, point, CURVE25519_KEYSIZE);
    }
}
  1a:	bc10      	pop	{r4}
  1c:	4770      	bx	lr
  1e:	bc10      	pop	{r4}
        XMEMCPY(out, point, CURVE25519_KEYSIZE);
  20:	2220      	movs	r2, #32
  22:	f7ff bffe 	b.w	0 <memcpy>

Disassembly of section .text.wc_curve25519_make_pub:

00000000 <wc_curve25519_make_pub>:
#ifdef FREESCALE_LTC_ECC
    const ECPoint* basepoint = nxp_ltc_curve25519_GetBasePoint();
    ECPoint wc_pub;
#endif

    if ( (public_size != CURVE25519_KEYSIZE) ||
   0:	2820      	cmp	r0, #32
{
   2:	b538      	push	{r3, r4, r5, lr}
   4:	460d      	mov	r5, r1
   6:	461c      	mov	r4, r3
    if ( (public_size != CURVE25519_KEYSIZE) ||
   8:	d113      	bne.n	32 <wc_curve25519_make_pub+0x32>
   a:	2a20      	cmp	r2, #32
   c:	d111      	bne.n	32 <wc_curve25519_make_pub+0x32>
        (private_size != CURVE25519_KEYSIZE)) {
        return ECC_BAD_ARG_E;
    }
    if ((pub == NULL) || (priv == NULL)) {
   e:	b181      	cbz	r1, 32 <wc_curve25519_make_pub+0x32>
  10:	b17b      	cbz	r3, 32 <wc_curve25519_make_pub+0x32>
    if ((priv[0] & ~248) ||
  12:	781b      	ldrb	r3, [r3, #0]
  14:	075b      	lsls	r3, r3, #29
  16:	d10c      	bne.n	32 <wc_curve25519_make_pub+0x32>
  18:	f994 301f 	ldrsb.w	r3, [r4, #31]
  1c:	2b00      	cmp	r3, #0
  1e:	db08      	blt.n	32 <wc_curve25519_make_pub+0x32>
    ret = nxp_ltc_curve25519(&wc_pub, priv, basepoint, kLTC_Weierstrass);
    if (ret == 0) {
        XMEMCPY(pub, wc_pub.point, CURVE25519_KEYSIZE);
    }
#else
    fe_init();
  20:	f7ff fffe 	bl	0 <fe_init>

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

    ret = curve25519(pub, priv, (byte*)kCurve25519BasePoint);
  24:	4621      	mov	r1, r4
  26:	4628      	mov	r0, r5
  28:	4a03      	ldr	r2, [pc, #12]	; (38 <wc_curve25519_make_pub+0x38>)

    RESTORE_VECTOR_REGISTERS();
#endif

    return ret;
}
  2a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = curve25519(pub, priv, (byte*)kCurve25519BasePoint);
  2e:	f7ff bffe 	b.w	0 <curve25519>
}
  32:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  36:	bd38      	pop	{r3, r4, r5, pc}
  38:	00000000 	.word	0x00000000

Disassembly of section .text.wc_curve25519_generic:

00000000 <wc_curve25519_generic>:
 * and the byte vectors are little endian.
 */
int wc_curve25519_generic(int public_size, byte* pub,
                          int private_size, const byte* priv,
                          int basepoint_size, const byte* basepoint)
{
   0:	b570      	push	{r4, r5, r6, lr}
     * nxp_ltc_curve25519_GetBasePoint() */
    return WC_HW_E;
#else
    int ret;

    if ((public_size != CURVE25519_KEYSIZE) ||
   2:	2820      	cmp	r0, #32
{
   4:	461c      	mov	r4, r3
   6:	460d      	mov	r5, r1
   8:	e9dd 3604 	ldrd	r3, r6, [sp, #16]
    if ((public_size != CURVE25519_KEYSIZE) ||
   c:	d116      	bne.n	3c <wc_curve25519_generic+0x3c>
   e:	2a20      	cmp	r2, #32
  10:	d114      	bne.n	3c <wc_curve25519_generic+0x3c>
        (private_size != CURVE25519_KEYSIZE) ||
  12:	2b20      	cmp	r3, #32
  14:	d112      	bne.n	3c <wc_curve25519_generic+0x3c>
        (basepoint_size != CURVE25519_KEYSIZE)) {
        return ECC_BAD_ARG_E;
    }
    if ((pub == NULL) || (priv == NULL) || (basepoint == NULL))
  16:	b18d      	cbz	r5, 3c <wc_curve25519_generic+0x3c>
  18:	b184      	cbz	r4, 3c <wc_curve25519_generic+0x3c>
  1a:	b17e      	cbz	r6, 3c <wc_curve25519_generic+0x3c>
    if ((priv[0] & ~248) ||
  1c:	7823      	ldrb	r3, [r4, #0]
  1e:	075b      	lsls	r3, r3, #29
  20:	d10c      	bne.n	3c <wc_curve25519_generic+0x3c>
  22:	f994 301f 	ldrsb.w	r3, [r4, #31]
  26:	2b00      	cmp	r3, #0
  28:	db08      	blt.n	3c <wc_curve25519_generic+0x3c>
    /* check clamping */
    ret = curve25519_priv_clamp_check(priv);
    if (ret != 0)
        return ret;

    fe_init();
  2a:	f7ff fffe 	bl	0 <fe_init>

    SAVE_VECTOR_REGISTERS(return _svr_ret;);

    ret = curve25519(pub, priv, basepoint);
  2e:	4632      	mov	r2, r6
  30:	4621      	mov	r1, r4
  32:	4628      	mov	r0, r5

    RESTORE_VECTOR_REGISTERS();

    return ret;
#endif /* FREESCALE_LTC_ECC */
}
  34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ret = curve25519(pub, priv, basepoint);
  38:	f7ff bffe 	b.w	0 <curve25519>
}
  3c:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  40:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.wc_curve25519_make_priv:

00000000 <wc_curve25519_make_priv>:
 *
 * return value is propagated from wc_RNG_GenerateBlock(() (0 on success),
 * or BAD_FUNC_ARG/ECC_BAD_ARG_E, and the byte vector is little endian.
 */
int wc_curve25519_make_priv(WC_RNG* rng, int keysize, byte* key)
{
   0:	b510      	push	{r4, lr}
    int ret;

    if (key == NULL || rng == NULL)
   2:	4614      	mov	r4, r2
   4:	b192      	cbz	r2, 2c <wc_curve25519_make_priv+0x2c>
   6:	b188      	cbz	r0, 2c <wc_curve25519_make_priv+0x2c>
        return BAD_FUNC_ARG;

    /* currently only a key size of 32 bytes is used */
    if (keysize != CURVE25519_KEYSIZE)
   8:	2920      	cmp	r1, #32
   a:	d112      	bne.n	32 <wc_curve25519_make_priv+0x32>
        return ECC_BAD_ARG_E;

    /* random number for private key */
    ret = wc_RNG_GenerateBlock(rng, key, (word32)keysize);
   c:	460a      	mov	r2, r1
   e:	4621      	mov	r1, r4
  10:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
    if (ret == 0) {
  14:	b948      	cbnz	r0, 2a <wc_curve25519_make_priv+0x2a>
    priv[0]  &= 248;
  16:	7823      	ldrb	r3, [r4, #0]
  18:	f023 0307 	bic.w	r3, r3, #7
  1c:	7023      	strb	r3, [r4, #0]
    priv[CURVE25519_KEYSIZE-1] &= 127;
  1e:	7fe3      	ldrb	r3, [r4, #31]
  20:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    priv[CURVE25519_KEYSIZE-1] |= 64;
  24:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  28:	77e3      	strb	r3, [r4, #31]
        /* Clamp the private key */
        ret = curve25519_priv_clamp(key);
    }

    return ret;
}
  2a:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  2c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  30:	e7fb      	b.n	2a <wc_curve25519_make_priv+0x2a>
        return ECC_BAD_ARG_E;
  32:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  36:	e7f8      	b.n	2a <wc_curve25519_make_priv+0x2a>

Disassembly of section .text.wc_curve25519_make_key:

00000000 <wc_curve25519_make_key>:
 *
 * return value is propagated from wc_curve25519_make_private() or
 * wc_curve25519_make_pub() (0 on success).
 */
int wc_curve25519_make_key(WC_RNG* rng, int keysize, curve25519_key* key)
{
   0:	b538      	push	{r3, r4, r5, lr}
    int ret;

    if (key == NULL || rng == NULL)
   2:	4614      	mov	r4, r2
   4:	b1ea      	cbz	r2, 42 <wc_curve25519_make_key+0x42>
   6:	b1e0      	cbz	r0, 42 <wc_curve25519_make_key+0x42>
#endif

#ifdef WOLFSSL_SE050
    ret = se050_curve25519_create_key(key, keysize);
#else
    ret = wc_curve25519_make_priv(rng, keysize, key->k);
   8:	f102 0529 	add.w	r5, r2, #41	; 0x29
   c:	462a      	mov	r2, r5
   e:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
    if (ret == 0) {
  12:	b9a8      	cbnz	r0, 40 <wc_curve25519_make_key+0x40>
        key->privSet = 1;
  14:	f894 1049 	ldrb.w	r1, [r4, #73]	; 0x49
        ret = wc_curve25519_make_pub((int)sizeof(key->p.point), key->p.point,
  18:	2220      	movs	r2, #32
        key->privSet = 1;
  1a:	f041 0102 	orr.w	r1, r1, #2
  1e:	f884 1049 	strb.w	r1, [r4, #73]	; 0x49
        ret = wc_curve25519_make_pub((int)sizeof(key->p.point), key->p.point,
  22:	462b      	mov	r3, r5
  24:	4610      	mov	r0, r2
  26:	f104 0108 	add.w	r1, r4, #8
  2a:	f7ff fffe 	bl	0 <wc_curve25519_make_key>
                                     (int)sizeof(key->k), key->k);
        key->pubSet = (ret == 0);
  2e:	f894 2049 	ldrb.w	r2, [r4, #73]	; 0x49
  32:	fab0 f380 	clz	r3, r0
  36:	095b      	lsrs	r3, r3, #5
  38:	f363 0200 	bfi	r2, r3, #0, #1
  3c:	f884 2049 	strb.w	r2, [r4, #73]	; 0x49
    }
#endif
    return ret;
}
  40:	bd38      	pop	{r3, r4, r5, pc}
        return BAD_FUNC_ARG;
  42:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  46:	e7fb      	b.n	40 <wc_curve25519_make_key+0x40>

Disassembly of section .text.wc_curve25519_shared_secret_ex:

00000000 <wc_curve25519_shared_secret_ex>:
}

int wc_curve25519_shared_secret_ex(curve25519_key* private_key,
                                   curve25519_key* public_key,
                                   byte* out, word32* outlen, int endian)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	460c      	mov	r4, r1
   4:	b08b      	sub	sp, #44	; 0x2c
   6:	4617      	mov	r7, r2
   8:	461d      	mov	r5, r3
    int ret;
    ECPoint o;

    /* sanity check */
    if (private_key == NULL || public_key == NULL ||
   a:	4606      	mov	r6, r0
   c:	b390      	cbz	r0, 74 <wc_curve25519_shared_secret_ex+0x74>
   e:	b389      	cbz	r1, 74 <wc_curve25519_shared_secret_ex+0x74>
  10:	b382      	cbz	r2, 74 <wc_curve25519_shared_secret_ex+0x74>
        out == NULL || outlen == NULL || *outlen < CURVE25519_KEYSIZE) {
  12:	b37b      	cbz	r3, 74 <wc_curve25519_shared_secret_ex+0x74>
  14:	681b      	ldr	r3, [r3, #0]
  16:	2b1f      	cmp	r3, #31
  18:	d92c      	bls.n	74 <wc_curve25519_shared_secret_ex+0x74>
        return BAD_FUNC_ARG;
    }

    /* make sure we have a populated private and public key */
    if (!public_key->pubSet
  1a:	f891 3049 	ldrb.w	r3, [r1, #73]	; 0x49
  1e:	07da      	lsls	r2, r3, #31
  20:	d52b      	bpl.n	7a <wc_curve25519_shared_secret_ex+0x7a>
    #ifndef WOLFSSL_SE050
        || !private_key->privSet
  22:	f890 3049 	ldrb.w	r3, [r0, #73]	; 0x49
  26:	079b      	lsls	r3, r3, #30
  28:	d527      	bpl.n	7a <wc_curve25519_shared_secret_ex+0x7a>
    ) {
        return ECC_BAD_ARG_E;
    }

    /* avoid implementation fingerprinting - make sure signed bit is not set */
    if (public_key->p.point[CURVE25519_KEYSIZE-1] & 0x80) {
  2a:	f991 3027 	ldrsb.w	r3, [r1, #39]	; 0x27
  2e:	2b00      	cmp	r3, #0
  30:	db23      	blt.n	7a <wc_curve25519_shared_secret_ex+0x7a>
            return ret;
        /* fall-through when unavailable */
    }
#endif

    XMEMSET(&o, 0, sizeof(o));
  32:	2221      	movs	r2, #33	; 0x21
  34:	2100      	movs	r1, #0
  36:	a801      	add	r0, sp, #4
  38:	f7ff fffe 	bl	0 <memset>
    else
    #endif
    {
    SAVE_VECTOR_REGISTERS(return _svr_ret;);

    ret = curve25519(o.point, private_key->k, public_key->p.point);
  3c:	f104 0208 	add.w	r2, r4, #8
  40:	f106 0129 	add.w	r1, r6, #41	; 0x29
  44:	a801      	add	r0, sp, #4
  46:	f7ff fffe 	bl	0 <curve25519>
        if (t == 0) {
            ret = ECC_OUT_OF_RANGE_E;
        }
    }
#endif
    if (ret == 0) {
  4a:	4604      	mov	r4, r0
  4c:	b930      	cbnz	r0, 5c <wc_curve25519_shared_secret_ex+0x5c>
        curve25519_copy_point(out, o.point, endian);
  4e:	9a10      	ldr	r2, [sp, #64]	; 0x40
  50:	a901      	add	r1, sp, #4
  52:	4638      	mov	r0, r7
  54:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret_ex>
        *outlen = CURVE25519_KEYSIZE;
  58:	2320      	movs	r3, #32
  5a:	602b      	str	r3, [r5, #0]
{
  5c:	2300      	movs	r3, #0
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
  5e:	4619      	mov	r1, r3
  60:	aa01      	add	r2, sp, #4
  62:	441a      	add	r2, r3
  64:	3301      	adds	r3, #1
  66:	2b22      	cmp	r3, #34	; 0x22
  68:	d102      	bne.n	70 <wc_curve25519_shared_secret_ex+0x70>
    }

    ForceZero(&o, sizeof(o));

    return ret;
}
  6a:	4620      	mov	r0, r4
  6c:	b00b      	add	sp, #44	; 0x2c
  6e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  70:	7011      	strb	r1, [r2, #0]
  72:	e7f5      	b.n	60 <wc_curve25519_shared_secret_ex+0x60>
        return BAD_FUNC_ARG;
  74:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  78:	e7f7      	b.n	6a <wc_curve25519_shared_secret_ex+0x6a>
        return ECC_BAD_ARG_E;
  7a:	f06f 04a9 	mvn.w	r4, #169	; 0xa9
  7e:	e7f4      	b.n	6a <wc_curve25519_shared_secret_ex+0x6a>

Disassembly of section .text.wc_curve25519_shared_secret:

00000000 <wc_curve25519_shared_secret>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_curve25519_shared_secret_ex(private_key, public_key,
   2:	2401      	movs	r4, #1
   4:	9400      	str	r4, [sp, #0]
   6:	f7ff fffe 	bl	0 <wc_curve25519_shared_secret>
}
   a:	b002      	add	sp, #8
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_curve25519_export_public_ex:

00000000 <wc_curve25519_export_public_ex>:

/* export curve25519 public key (Big or Little endian)
 * return 0 on success */
int wc_curve25519_export_public_ex(curve25519_key* key, byte* out,
                                   word32* outLen, int endian)
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	460f      	mov	r7, r1
   6:	4616      	mov	r6, r2
   8:	4698      	mov	r8, r3
    int ret = 0;

    if (key == NULL || out == NULL || outLen == NULL) {
   a:	4604      	mov	r4, r0
   c:	b360      	cbz	r0, 68 <wc_curve25519_export_public_ex+0x68>
   e:	b359      	cbz	r1, 68 <wc_curve25519_export_public_ex+0x68>
  10:	b352      	cbz	r2, 68 <wc_curve25519_export_public_ex+0x68>
        return BAD_FUNC_ARG;
    }

    /* check and set outgoing key size */
    if (*outLen < CURVE25519_KEYSIZE) {
  12:	6813      	ldr	r3, [r2, #0]
  14:	2b1f      	cmp	r3, #31
  16:	d806      	bhi.n	26 <wc_curve25519_export_public_ex+0x26>
        *outLen = CURVE25519_KEYSIZE;
  18:	2320      	movs	r3, #32
  1a:	6013      	str	r3, [r2, #0]
        return ECC_BAD_ARG_E;
  1c:	f06f 05a9 	mvn.w	r5, #169	; 0xa9
    /* export public point with endianness */
    curve25519_copy_point(out, key->p.point, endian);
    *outLen = CURVE25519_KEYSIZE;

    return ret;
}
  20:	4628      	mov	r0, r5
  22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (!key->pubSet) {
  26:	f890 3049 	ldrb.w	r3, [r0, #73]	; 0x49
  2a:	07db      	lsls	r3, r3, #31
        ret = wc_curve25519_make_pub((int)sizeof(key->p.point), key->p.point,
  2c:	f100 0908 	add.w	r9, r0, #8
    if (!key->pubSet) {
  30:	d418      	bmi.n	64 <wc_curve25519_export_public_ex+0x64>
        ret = wc_curve25519_make_pub((int)sizeof(key->p.point), key->p.point,
  32:	2220      	movs	r2, #32
  34:	f100 0329 	add.w	r3, r0, #41	; 0x29
  38:	4649      	mov	r1, r9
  3a:	4610      	mov	r0, r2
  3c:	f7ff fffe 	bl	0 <wc_curve25519_export_public_ex>
        key->pubSet = (ret == 0);
  40:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
  44:	4605      	mov	r5, r0
  46:	fab0 f080 	clz	r0, r0
  4a:	0940      	lsrs	r0, r0, #5
  4c:	f360 0300 	bfi	r3, r0, #0, #1
  50:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
    curve25519_copy_point(out, key->p.point, endian);
  54:	4642      	mov	r2, r8
  56:	4649      	mov	r1, r9
  58:	4638      	mov	r0, r7
  5a:	f7ff fffe 	bl	0 <wc_curve25519_export_public_ex>
    *outLen = CURVE25519_KEYSIZE;
  5e:	2320      	movs	r3, #32
  60:	6033      	str	r3, [r6, #0]
    return ret;
  62:	e7dd      	b.n	20 <wc_curve25519_export_public_ex+0x20>
    int ret = 0;
  64:	2500      	movs	r5, #0
  66:	e7f5      	b.n	54 <wc_curve25519_export_public_ex+0x54>
        return BAD_FUNC_ARG;
  68:	f06f 05ac 	mvn.w	r5, #172	; 0xac
  6c:	e7d8      	b.n	20 <wc_curve25519_export_public_ex+0x20>

Disassembly of section .text.wc_curve25519_export_public:

00000000 <wc_curve25519_export_public>:
    return wc_curve25519_export_public_ex(key, out, outLen, EC25519_BIG_ENDIAN);
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <wc_curve25519_export_public>

Disassembly of section .text.wc_curve25519_import_public_ex:

00000000 <wc_curve25519_import_public_ex>:

/* import curve25519 public key (Big or Little endian)
 * return 0 on success */
int wc_curve25519_import_public_ex(const byte* in, word32 inLen,
                                curve25519_key* key, int endian)
{
   0:	b510      	push	{r4, lr}
   2:	4614      	mov	r4, r2
   4:	461a      	mov	r2, r3
#ifdef FREESCALE_LTC_ECC
    ltc_pkha_ecc_point_t ltcPoint;
#endif

    /* sanity check */
    if (key == NULL || in == NULL) {
   6:	b18c      	cbz	r4, 2c <wc_curve25519_import_public_ex+0x2c>
   8:	b180      	cbz	r0, 2c <wc_curve25519_import_public_ex+0x2c>
        return BAD_FUNC_ARG;
    }

    /* check size of incoming keys */
    if (inLen != CURVE25519_KEYSIZE) {
   a:	2920      	cmp	r1, #32
   c:	d111      	bne.n	32 <wc_curve25519_import_public_ex+0x32>
       return ECC_BAD_ARG_E;
    }

    /* import public point with endianness */
    curve25519_copy_point(key->p.point, in, endian);
   e:	4601      	mov	r1, r0
  10:	f104 0008 	add.w	r0, r4, #8
  14:	f7ff fffe 	bl	0 <wc_curve25519_import_public_ex>
    key->pubSet = 1;
  18:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
  1c:	f043 0301 	orr.w	r3, r3, #1
  20:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49

    key->dp = &curve25519_sets[0];
  24:	4b04      	ldr	r3, [pc, #16]	; (38 <wc_curve25519_import_public_ex+0x38>)
  26:	6063      	str	r3, [r4, #4]
    ltcPoint.X = &key->p.point[0];
    ltcPoint.Y = &key->p.pointY[0];
    LTC_PKHA_Curve25519ComputeY(&ltcPoint);
#endif

    return 0;
  28:	2000      	movs	r0, #0
}
  2a:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  2c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  30:	e7fb      	b.n	2a <wc_curve25519_import_public_ex+0x2a>
       return ECC_BAD_ARG_E;
  32:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  36:	e7f8      	b.n	2a <wc_curve25519_import_public_ex+0x2a>
  38:	00000000 	.word	0x00000000

Disassembly of section .text.wc_curve25519_import_public:

00000000 <wc_curve25519_import_public>:
    return wc_curve25519_import_public_ex(in, inLen, key, EC25519_BIG_ENDIAN);
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <wc_curve25519_import_public>

Disassembly of section .text.wc_curve25519_check_public:

00000000 <wc_curve25519_check_public>:
 *         ECC_BAD_ARG_E if key length is not 32 bytes, public key value is
 *         zero or one; and
 *         0 otherwise.
 */
int wc_curve25519_check_public(const byte* pub, word32 pubSz, int endian)
{
   0:	b510      	push	{r4, lr}
    word32 i;

    if (pub == NULL)
   2:	4603      	mov	r3, r0
   4:	2800      	cmp	r0, #0
   6:	d042      	beq.n	8e <wc_curve25519_check_public+0x8e>
        return BAD_FUNC_ARG;

    /* Check for empty key data */
    if (pubSz == 0)
   8:	2900      	cmp	r1, #0
   a:	d044      	beq.n	96 <wc_curve25519_check_public+0x96>
        return BUFFER_E;

    /* Check key length */
    if (pubSz != CURVE25519_KEYSIZE)
   c:	2920      	cmp	r1, #32
   e:	d10a      	bne.n	26 <wc_curve25519_check_public+0x26>
        return ECC_BAD_ARG_E;


    if (endian == EC25519_LITTLE_ENDIAN) {
  10:	bb0a      	cbnz	r2, 56 <wc_curve25519_check_public+0x56>
  12:	f100 011f 	add.w	r1, r0, #31
        /* Check for value of zero or one */
        for (i = CURVE25519_KEYSIZE - 1; i > 0; i--) {
            if (pub[i] != 0)
  16:	f811 0901 	ldrb.w	r0, [r1], #-1
  1a:	b938      	cbnz	r0, 2c <wc_curve25519_check_public+0x2c>
        for (i = CURVE25519_KEYSIZE - 1; i > 0; i--) {
  1c:	428b      	cmp	r3, r1
  1e:	d1fa      	bne.n	16 <wc_curve25519_check_public+0x16>
                break;
        }
        if (i == 0 && (pub[0] == 0 || pub[0] == 1))
  20:	7819      	ldrb	r1, [r3, #0]
  22:	2901      	cmp	r1, #1
  24:	d802      	bhi.n	2c <wc_curve25519_check_public+0x2c>
            for (i = CURVE25519_KEYSIZE - 2; i > 0; i--) {
                if (pub[i] != 0xff)
                    break;
            }
            if (i == 0 && (pub[0] >= 0xec))
                return ECC_BAD_ARG_E;
  26:	f06f 02a9 	mvn.w	r2, #169	; 0xa9
  2a:	e032      	b.n	92 <wc_curve25519_check_public+0x92>
        if (pub[CURVE25519_KEYSIZE - 1] & 0x80)
  2c:	f993 001f 	ldrsb.w	r0, [r3, #31]
  30:	7fd9      	ldrb	r1, [r3, #31]
  32:	2800      	cmp	r0, #0
  34:	db32      	blt.n	9c <wc_curve25519_check_public+0x9c>
        if (pub[CURVE25519_KEYSIZE - 1] == 0x7f) {
  36:	297f      	cmp	r1, #127	; 0x7f
  38:	d12b      	bne.n	92 <wc_curve25519_check_public+0x92>
  3a:	f103 011e 	add.w	r1, r3, #30
                if (pub[i] != 0xff)
  3e:	f811 0901 	ldrb.w	r0, [r1], #-1
  42:	28ff      	cmp	r0, #255	; 0xff
  44:	d125      	bne.n	92 <wc_curve25519_check_public+0x92>
            for (i = CURVE25519_KEYSIZE - 2; i > 0; i--) {
  46:	428b      	cmp	r3, r1
  48:	d1f9      	bne.n	3e <wc_curve25519_check_public+0x3e>
            if (i == 0 && (pub[0] >= 0xec))
  4a:	781b      	ldrb	r3, [r3, #0]
                return ECC_BAD_ARG_E;
  4c:	2bec      	cmp	r3, #236	; 0xec
  4e:	bf28      	it	cs
  50:	f06f 02a9 	mvncs.w	r2, #169	; 0xa9
  54:	e01d      	b.n	92 <wc_curve25519_check_public+0x92>
  56:	1e41      	subs	r1, r0, #1
  58:	4602      	mov	r2, r0
  5a:	301e      	adds	r0, #30
         }
    }
    else {
        /* Check for value of zero or one */
        for (i = 0; i < CURVE25519_KEYSIZE - 1; i++) {
            if (pub[i] != 0)
  5c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  60:	b924      	cbnz	r4, 6c <wc_curve25519_check_public+0x6c>
        for (i = 0; i < CURVE25519_KEYSIZE - 1; i++) {
  62:	4288      	cmp	r0, r1
  64:	d1fa      	bne.n	5c <wc_curve25519_check_public+0x5c>
                break;
        }
        if (i == CURVE25519_KEYSIZE - 1 && (pub[i] == 0 || pub[i] == 1))
  66:	7fd9      	ldrb	r1, [r3, #31]
  68:	2901      	cmp	r1, #1
  6a:	d9dc      	bls.n	26 <wc_curve25519_check_public+0x26>
            return ECC_BAD_ARG_E;

        /* Check high bit set */
        if (pub[0] & 0x80)
  6c:	f993 4000 	ldrsb.w	r4, [r3]
  70:	7819      	ldrb	r1, [r3, #0]
  72:	2c00      	cmp	r4, #0
  74:	db12      	blt.n	9c <wc_curve25519_check_public+0x9c>
            return ECC_OUT_OF_RANGE_E;

        /* Check for order-1 or higher. */
        if (pub[0] == 0x7f) {
  76:	297f      	cmp	r1, #127	; 0x7f
  78:	d113      	bne.n	a2 <wc_curve25519_check_public+0xa2>
            for (i = 1; i < CURVE25519_KEYSIZE - 1; i++) {
                if (pub[i] != 0)
  7a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  7e:	b981      	cbnz	r1, a2 <wc_curve25519_check_public+0xa2>
            for (i = 1; i < CURVE25519_KEYSIZE - 1; i++) {
  80:	4290      	cmp	r0, r2
  82:	d1fa      	bne.n	7a <wc_curve25519_check_public+0x7a>
                    break;
            }
            if (i == CURVE25519_KEYSIZE - 1 && (pub[i] >= 0xec))
  84:	7fdb      	ldrb	r3, [r3, #31]
                return ECC_BAD_ARG_E;
  86:	2bec      	cmp	r3, #236	; 0xec
  88:	bf38      	it	cc
  8a:	2200      	movcc	r2, #0
  8c:	e7df      	b.n	4e <wc_curve25519_check_public+0x4e>
        return BAD_FUNC_ARG;
  8e:	f06f 02ac 	mvn.w	r2, #172	; 0xac
                return ECC_BAD_ARG_E;
         }
    }

    return 0;
}
  92:	4610      	mov	r0, r2
  94:	bd10      	pop	{r4, pc}
        return BUFFER_E;
  96:	f06f 0283 	mvn.w	r2, #131	; 0x83
  9a:	e7fa      	b.n	92 <wc_curve25519_check_public+0x92>
            return ECC_OUT_OF_RANGE_E;
  9c:	f06f 02d8 	mvn.w	r2, #216	; 0xd8
  a0:	e7f7      	b.n	92 <wc_curve25519_check_public+0x92>
    return 0;
  a2:	2200      	movs	r2, #0
  a4:	e7f5      	b.n	92 <wc_curve25519_check_public+0x92>

Disassembly of section .text.wc_curve25519_export_private_raw_ex:

00000000 <wc_curve25519_export_private_raw_ex>:
/* export curve25519 private key only raw (Big or Little endian)
 * outLen is in/out size
 * return 0 on success */
int wc_curve25519_export_private_raw_ex(curve25519_key* key, byte* out,
                                        word32* outLen, int endian)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4614      	mov	r4, r2
   4:	460d      	mov	r5, r1
   6:	461a      	mov	r2, r3
    /* sanity check */
    if (key == NULL || out == NULL || outLen == NULL)
   8:	b190      	cbz	r0, 30 <wc_curve25519_export_private_raw_ex+0x30>
   a:	b189      	cbz	r1, 30 <wc_curve25519_export_private_raw_ex+0x30>
   c:	b184      	cbz	r4, 30 <wc_curve25519_export_private_raw_ex+0x30>
        return BAD_FUNC_ARG;

    /* check size of outgoing buffer */
    if (*outLen < CURVE25519_KEYSIZE) {
   e:	6823      	ldr	r3, [r4, #0]
  10:	2b1f      	cmp	r3, #31
  12:	d804      	bhi.n	1e <wc_curve25519_export_private_raw_ex+0x1e>
        *outLen = CURVE25519_KEYSIZE;
  14:	2320      	movs	r3, #32
  16:	6023      	str	r3, [r4, #0]
        return ECC_BAD_ARG_E;
  18:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
    /* export private scalar with endianness */
    curve25519_copy_point(out, key->k, endian);
    *outLen = CURVE25519_KEYSIZE;

    return 0;
}
  1c:	bd38      	pop	{r3, r4, r5, pc}
    curve25519_copy_point(out, key->k, endian);
  1e:	f100 0129 	add.w	r1, r0, #41	; 0x29
  22:	4628      	mov	r0, r5
  24:	f7ff fffe 	bl	0 <wc_curve25519_export_private_raw_ex>
    *outLen = CURVE25519_KEYSIZE;
  28:	2320      	movs	r3, #32
  2a:	6023      	str	r3, [r4, #0]
    return 0;
  2c:	2000      	movs	r0, #0
  2e:	e7f5      	b.n	1c <wc_curve25519_export_private_raw_ex+0x1c>
        return BAD_FUNC_ARG;
  30:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  34:	e7f2      	b.n	1c <wc_curve25519_export_private_raw_ex+0x1c>

Disassembly of section .text.wc_curve25519_export_private_raw:

00000000 <wc_curve25519_export_private_raw>:
    return wc_curve25519_export_private_raw_ex(key, out, outLen,
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <wc_curve25519_export_private_raw>

Disassembly of section .text.wc_curve25519_export_key_raw_ex:

00000000 <wc_curve25519_export_key_raw_ex>:
 * return 0 on success */
int wc_curve25519_export_key_raw_ex(curve25519_key* key,
                                    byte* priv, word32 *privSz,
                                    byte* pub, word32 *pubSz,
                                    int endian)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	e9dd 7606 	ldrd	r7, r6, [sp, #24]
   8:	461d      	mov	r5, r3
    int ret;

    /* export private part */
    ret = wc_curve25519_export_private_raw_ex(key, priv, privSz, endian);
   a:	4633      	mov	r3, r6
{
   c:	4604      	mov	r4, r0
    ret = wc_curve25519_export_private_raw_ex(key, priv, privSz, endian);
   e:	f7ff fffe 	bl	0 <wc_curve25519_export_key_raw_ex>
    if (ret != 0)
  12:	b938      	cbnz	r0, 24 <wc_curve25519_export_key_raw_ex+0x24>
        return ret;

    /* export public part */
    return wc_curve25519_export_public_ex(key, pub, pubSz, endian);
  14:	4633      	mov	r3, r6
  16:	463a      	mov	r2, r7
  18:	4629      	mov	r1, r5
  1a:	4620      	mov	r0, r4
}
  1c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return wc_curve25519_export_public_ex(key, pub, pubSz, endian);
  20:	f7ff bffe 	b.w	0 <wc_curve25519_export_key_raw_ex>
}
  24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.wc_curve25519_export_key_raw:

00000000 <wc_curve25519_export_key_raw>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_curve25519_export_key_raw_ex(key, priv, privSz,
   2:	2401      	movs	r4, #1
   4:	9401      	str	r4, [sp, #4]
   6:	9c04      	ldr	r4, [sp, #16]
   8:	9400      	str	r4, [sp, #0]
   a:	f7ff fffe 	bl	0 <wc_curve25519_export_key_raw>
}
   e:	b002      	add	sp, #8
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_curve25519_import_private_ex:

00000000 <wc_curve25519_import_private_ex>:

/* curve25519 private key import only. (Big or Little endian)
 * return 0 on success */
int wc_curve25519_import_private_ex(const byte* priv, word32 privSz,
                                    curve25519_key* key, int endian)
{
   0:	b510      	push	{r4, lr}
    /* sanity check */
    if (key == NULL || priv == NULL) {
   2:	4614      	mov	r4, r2
   4:	b302      	cbz	r2, 48 <wc_curve25519_import_private_ex+0x48>
   6:	b1f8      	cbz	r0, 48 <wc_curve25519_import_private_ex+0x48>
        return BAD_FUNC_ARG;
    }

    /* check size of incoming keys */
    if ((int)privSz != CURVE25519_KEYSIZE) {
   8:	2920      	cmp	r1, #32
   a:	d120      	bne.n	4e <wc_curve25519_import_private_ex+0x4e>
    /* release NXP resources if set */
    se050_curve25519_free_key(key);
#endif

    /* import private scalar with endianness */
    curve25519_copy_point(key->k, priv, endian);
   c:	461a      	mov	r2, r3
   e:	4601      	mov	r1, r0
  10:	f104 0029 	add.w	r0, r4, #41	; 0x29
  14:	f7ff fffe 	bl	0 <wc_curve25519_import_private_ex>
    key->privSet = 1;
  18:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
  1c:	f043 0302 	orr.w	r3, r3, #2
  20:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49

    key->dp = &curve25519_sets[0];
  24:	4b0b      	ldr	r3, [pc, #44]	; (54 <wc_curve25519_import_private_ex+0x54>)
  26:	6063      	str	r3, [r4, #4]
    priv[0]  &= 248;
  28:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
  2c:	f023 0307 	bic.w	r3, r3, #7
  30:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
    priv[CURVE25519_KEYSIZE-1] &= 127;
  34:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
  38:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    priv[CURVE25519_KEYSIZE-1] |= 64;
  3c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48

    /* Clamp the key */
    return curve25519_priv_clamp(key->k);
  44:	2000      	movs	r0, #0
}
  46:	bd10      	pop	{r4, pc}
        return BAD_FUNC_ARG;
  48:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  4c:	e7fb      	b.n	46 <wc_curve25519_import_private_ex+0x46>
        return ECC_BAD_ARG_E;
  4e:	f06f 00a9 	mvn.w	r0, #169	; 0xa9
  52:	e7f8      	b.n	46 <wc_curve25519_import_private_ex+0x46>
  54:	00000000 	.word	0x00000000

Disassembly of section .text.wc_curve25519_import_private_raw_ex:

00000000 <wc_curve25519_import_private_raw_ex>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
   8:	4614      	mov	r4, r2
   a:	461d      	mov	r5, r3
    ret = wc_curve25519_import_private_ex(priv, privSz, key, endian);
   c:	4632      	mov	r2, r6
   e:	463b      	mov	r3, r7
  10:	f7ff fffe 	bl	0 <wc_curve25519_import_private_raw_ex>
    if (ret != 0)
  14:	b938      	cbnz	r0, 26 <wc_curve25519_import_private_raw_ex+0x26>
    return wc_curve25519_import_public_ex(pub, pubSz, key, endian);
  16:	463b      	mov	r3, r7
  18:	4632      	mov	r2, r6
  1a:	4629      	mov	r1, r5
  1c:	4620      	mov	r0, r4
}
  1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    return wc_curve25519_import_public_ex(pub, pubSz, key, endian);
  22:	f7ff bffe 	b.w	0 <wc_curve25519_import_private_raw_ex>
}
  26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.wc_curve25519_import_private_raw:

00000000 <wc_curve25519_import_private_raw>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_curve25519_import_private_raw_ex(priv, privSz, pub, pubSz,
   2:	2401      	movs	r4, #1
   4:	9401      	str	r4, [sp, #4]
   6:	9c04      	ldr	r4, [sp, #16]
   8:	9400      	str	r4, [sp, #0]
   a:	f7ff fffe 	bl	0 <wc_curve25519_import_private_raw>
}
   e:	b002      	add	sp, #8
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_curve25519_import_private:

00000000 <wc_curve25519_import_private>:
    return wc_curve25519_import_private_ex(priv, privSz,
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <wc_curve25519_import_private>

Disassembly of section .text.wc_curve25519_init_ex:

00000000 <wc_curve25519_init_ex>:

#endif /* HAVE_CURVE25519_KEY_IMPORT */

int wc_curve25519_init_ex(curve25519_key* key, void* heap, int devId)
{
   0:	b510      	push	{r4, lr}
    if (key == NULL)
   2:	4604      	mov	r4, r0
   4:	b148      	cbz	r0, 1a <wc_curve25519_init_ex+0x1a>
       return BAD_FUNC_ARG;

    XMEMSET(key, 0, sizeof(*key));
   6:	224c      	movs	r2, #76	; 0x4c
   8:	2100      	movs	r1, #0
   a:	f7ff fffe 	bl	0 <memset>

    /* currently the format for curve25519 */
    key->dp = &curve25519_sets[0];
   e:	4b04      	ldr	r3, [pc, #16]	; (20 <wc_curve25519_init_ex+0x20>)
  10:	6063      	str	r3, [r4, #4]
    (void)devId;
#endif
    (void)heap; /* if needed for XMALLOC/XFREE in future */

#ifndef FREESCALE_LTC_ECC
    fe_init();
  12:	f7ff fffe 	bl	0 <fe_init>

#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Add("wc_curve25519_init_ex key->k", key->k, CURVE25519_KEYSIZE);
#endif

    return 0;
  16:	2000      	movs	r0, #0
}
  18:	bd10      	pop	{r4, pc}
       return BAD_FUNC_ARG;
  1a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1e:	e7fb      	b.n	18 <wc_curve25519_init_ex+0x18>
  20:	00000000 	.word	0x00000000

Disassembly of section .text.wc_curve25519_init:

00000000 <wc_curve25519_init>:

int wc_curve25519_init(curve25519_key* key)
{
    return wc_curve25519_init_ex(key, NULL, INVALID_DEVID);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_curve25519_init>

Disassembly of section .text.wc_curve25519_free:

00000000 <wc_curve25519_free>:
}

/* Clean the memory of a key */
void wc_curve25519_free(curve25519_key* key)
{
   0:	b510      	push	{r4, lr}
    if (key == NULL)
   2:	4604      	mov	r4, r0
   4:	b198      	cbz	r0, 2e <wc_curve25519_free+0x2e>

#ifdef WOLFSSL_SE050
    se050_curve25519_free_key(key);
#endif

    key->dp = NULL;
   6:	2200      	movs	r2, #0
   8:	6042      	str	r2, [r0, #4]
    ForceZero(key->k, sizeof(key->k));
   a:	f100 0329 	add.w	r3, r0, #41	; 0x29
   e:	f100 0149 	add.w	r1, r0, #73	; 0x49
  12:	428b      	cmp	r3, r1
  14:	d10c      	bne.n	30 <wc_curve25519_free+0x30>
    XMEMSET(&key->p, 0, sizeof(key->p));
  16:	2221      	movs	r2, #33	; 0x21
  18:	2100      	movs	r1, #0
  1a:	f104 0008 	add.w	r0, r4, #8
  1e:	f7ff fffe 	bl	0 <memset>
    key->pubSet = 0;
  22:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
  26:	f023 0303 	bic.w	r3, r3, #3
  2a:	f884 3049 	strb.w	r3, [r4, #73]	; 0x49
    key->privSet = 0;
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(key, sizeof(curve25519_key));
#endif
}
  2e:	bd10      	pop	{r4, pc}
  30:	f803 2b01 	strb.w	r2, [r3], #1
  34:	e7ed      	b.n	12 <wc_curve25519_free+0x12>

Disassembly of section .text.wc_curve25519_size:

00000000 <wc_curve25519_size>:

/* get key size */
int wc_curve25519_size(curve25519_key* key)
{
    if (key == NULL)
   0:	b108      	cbz	r0, 6 <wc_curve25519_size+0x6>
        return 0;

    return key->dp->size;
   2:	6843      	ldr	r3, [r0, #4]
   4:	6818      	ldr	r0, [r3, #0]
}
   6:	4770      	bx	lr

curve448.o:     file format elf32-littlearm


ecc_fp.o:     file format elf32-littlearm


eccsi.o:     file format elf32-littlearm


ed25519.o:     file format elf32-littlearm


Disassembly of section .text.ed25519_hash_init:

00000000 <ed25519_hash_init>:
    ** more char for saving the line ending in our ed25519Ctx[] here: */
    static const byte ed25519Ctx[ED25519CTX_SIZE + 1] = ED25519CTX_SNC_MESSAGE;
#endif

static int ed25519_hash_init(ed25519_key* key, wc_Sha512 *sha)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460c      	mov	r4, r1
   4:	4605      	mov	r5, r0
    int ret;

#ifndef WOLFSSL_ED25519_PERSISTENT_SHA
    /* when not using persistent SHA, we'll zero the sha param */
    XMEMSET(sha, 0, sizeof(wc_Sha512));
   6:	22e0      	movs	r2, #224	; 0xe0
   8:	2100      	movs	r1, #0
   a:	4620      	mov	r0, r4
   c:	f7ff fffe 	bl	0 <memset>
#endif

    ret = wc_InitSha512_ex(sha, key->heap,
  10:	6e69      	ldr	r1, [r5, #100]	; 0x64
  12:	4620      	mov	r0, r4
  14:	f06f 0201 	mvn.w	r2, #1
    if (ret == 0)
        key->sha_clean_flag = 1;
#endif

    return ret;
}
  18:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    ret = wc_InitSha512_ex(sha, key->heap,
  1c:	f7ff bffe 	b.w	0 <wc_InitSha512_ex>

Disassembly of section .text.ed25519_hash:

00000000 <ed25519_hash>:
}


static int ed25519_hash(ed25519_key* key, const byte* in, word32 inLen,
    byte* hash)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	460d      	mov	r5, r1
   4:	b0b9      	sub	sp, #228	; 0xe4
   6:	4616      	mov	r6, r2
   8:	461f      	mov	r7, r3
    wc_Sha512 sha[1];
#else
    wc_Sha512 *sha;
#endif

    if (key == NULL || (in == NULL && inLen > 0) || hash == NULL) {
   a:	b1c0      	cbz	r0, 3e <ed25519_hash+0x3e>
   c:	b901      	cbnz	r1, 10 <ed25519_hash+0x10>
   e:	b9b2      	cbnz	r2, 3e <ed25519_hash+0x3e>

#ifdef WOLFSSL_ED25519_PERSISTENT_SHA
    sha = &key->sha;
    ret = ed25519_hash_reset(key);
#else
    ret = ed25519_hash_init(key, sha);
  10:	4669      	mov	r1, sp
  12:	f7ff fffe 	bl	0 <ed25519_hash>
#endif
    if (ret < 0)
  16:	1e04      	subs	r4, r0, #0
  18:	db0e      	blt.n	38 <ed25519_hash+0x38>
    return wc_Sha512Update(sha, data, len);
  1a:	4632      	mov	r2, r6
  1c:	4629      	mov	r1, r5
  1e:	4668      	mov	r0, sp
  20:	f7ff fffe 	bl	0 <wc_Sha512Update>
        return ret;

    ret = ed25519_hash_update(key, sha, in, inLen);
    if (ret == 0)
  24:	4604      	mov	r4, r0
  26:	b920      	cbnz	r0, 32 <ed25519_hash+0x32>
    int ret = wc_Sha512Final(sha, hash);
  28:	4639      	mov	r1, r7
  2a:	4668      	mov	r0, sp
  2c:	f7ff fffe 	bl	0 <wc_Sha512Final>
  30:	4604      	mov	r4, r0
    wc_Sha512Free(sha);
  32:	4668      	mov	r0, sp
  34:	f7ff fffe 	bl	0 <wc_Sha512Free>
#ifndef WOLFSSL_ED25519_PERSISTENT_SHA
    ed25519_hash_free(key, sha);
#endif

    return ret;
}
  38:	4620      	mov	r0, r4
  3a:	b039      	add	sp, #228	; 0xe4
  3c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return BAD_FUNC_ARG;
  3e:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  42:	e7f9      	b.n	38 <ed25519_hash+0x38>

Disassembly of section .text.wc_ed25519_make_public:

00000000 <wc_ed25519_make_public>:

#ifdef HAVE_ED25519_MAKE_KEY
int wc_ed25519_make_public(ed25519_key* key, unsigned char* pubKey,
                           word32 pubKeySz)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460e      	mov	r6, r1
   4:	b0b8      	sub	sp, #224	; 0xe0
    ALIGN16 byte az[ED25519_PRV_KEY_SIZE];
#if !defined(FREESCALE_LTC_ECC)
    ge_p3 A;
#endif

    if (key == NULL || pubKey == NULL || pubKeySz != ED25519_PUB_KEY_SIZE)
   6:	4605      	mov	r5, r0
   8:	b360      	cbz	r0, 64 <wc_ed25519_make_public+0x64>
   a:	b359      	cbz	r1, 64 <wc_ed25519_make_public+0x64>
   c:	2a20      	cmp	r2, #32
   e:	d129      	bne.n	64 <wc_ed25519_make_public+0x64>
        ret = BAD_FUNC_ARG;

    if ((ret == 0) && (!key->privKeySet)) {
  10:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
  14:	07db      	lsls	r3, r3, #31
  16:	d528      	bpl.n	6a <wc_ed25519_make_public+0x6a>
        ret = ECC_PRIV_KEY_E;
    }

    if (ret == 0)
        ret = ed25519_hash(key, key->k, ED25519_KEY_SIZE, az);
  18:	466b      	mov	r3, sp
  1a:	f100 0120 	add.w	r1, r0, #32
  1e:	f7ff fffe 	bl	0 <wc_ed25519_make_public>
    if (ret == 0) {
  22:	4604      	mov	r4, r0
  24:	b9d8      	cbnz	r0, 5e <wc_ed25519_make_public+0x5e>
        /* apply clamp */
        az[0]  &= 248;
  26:	f89d 3000 	ldrb.w	r3, [sp]
  2a:	f023 0307 	bic.w	r3, r3, #7
  2e:	f88d 3000 	strb.w	r3, [sp]
        az[31] &= 63; /* same than az[31] &= 127 because of az[31] |= 64 */
  32:	f89d 301f 	ldrb.w	r3, [sp, #31]
  36:	f003 033f 	and.w	r3, r3, #63	; 0x3f
        az[31] |= 64;
  3a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
        publicKey.Y = key->pointY;
        LTC_PKHA_Ed25519_PointMul(LTC_PKHA_Ed25519_BasePoint(), az,
            ED25519_KEY_SIZE, &publicKey, kLTC_Ed25519 /* result on Ed25519 */);
        LTC_PKHA_Ed25519_Compress(&publicKey, pubKey);
    #else
        ge_scalarmult_base(&A, az);
  3e:	4669      	mov	r1, sp
  40:	a810      	add	r0, sp, #64	; 0x40
        az[31] |= 64;
  42:	f88d 301f 	strb.w	r3, [sp, #31]
        ge_scalarmult_base(&A, az);
  46:	f7ff fffe 	bl	0 <ge_scalarmult_base>
        ge_p3_tobytes(pubKey, &A);
  4a:	a910      	add	r1, sp, #64	; 0x40
  4c:	4630      	mov	r0, r6
  4e:	f7ff fffe 	bl	0 <ge_tobytes>
    #endif

        key->pubKeySet = 1;
  52:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
  56:	f043 0302 	orr.w	r3, r3, #2
  5a:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
    }

    return ret;
}
  5e:	4620      	mov	r0, r4
  60:	b038      	add	sp, #224	; 0xe0
  62:	bd70      	pop	{r4, r5, r6, pc}
  64:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  68:	e7f9      	b.n	5e <wc_ed25519_make_public+0x5e>
        ret = ECC_PRIV_KEY_E;
  6a:	f06f 04d7 	mvn.w	r4, #215	; 0xd7
    return ret;
  6e:	e7f6      	b.n	5e <wc_ed25519_make_public+0x5e>

Disassembly of section .text.wc_ed25519_make_key:

00000000 <wc_ed25519_make_key>:

/* generate an ed25519 key pair.
 * returns 0 on success
 */
int wc_ed25519_make_key(WC_RNG* rng, int keySz, ed25519_key* key)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460f      	mov	r7, r1
   4:	4614      	mov	r4, r2
    int ret;

    if (rng == NULL || key == NULL)
   6:	b390      	cbz	r0, 6e <wc_ed25519_make_key+0x6e>
   8:	b38a      	cbz	r2, 6e <wc_ed25519_make_key+0x6e>
        return BAD_FUNC_ARG;

    /* ed25519 has 32 byte key sizes */
    if (keySz != ED25519_KEY_SIZE)
   a:	2920      	cmp	r1, #32
   c:	d12f      	bne.n	6e <wc_ed25519_make_key+0x6e>
        return BAD_FUNC_ARG;

    key->privKeySet = 0;
   e:	f892 3060 	ldrb.w	r3, [r2, #96]	; 0x60
            return ret;
        /* fall-through when unavailable */
    }
#endif

    ret = wc_RNG_GenerateBlock(rng, key->k, ED25519_KEY_SIZE);
  12:	f102 0620 	add.w	r6, r2, #32
    key->privKeySet = 0;
  16:	f023 0303 	bic.w	r3, r3, #3
  1a:	f882 3060 	strb.w	r3, [r2, #96]	; 0x60
    ret = wc_RNG_GenerateBlock(rng, key->k, ED25519_KEY_SIZE);
  1e:	460a      	mov	r2, r1
  20:	4631      	mov	r1, r6
  22:	f7ff fffe 	bl	0 <wc_RNG_GenerateBlock>
    if (ret != 0)
  26:	4605      	mov	r5, r0
  28:	b9b8      	cbnz	r0, 5a <wc_ed25519_make_key+0x5a>
        return ret;

    key->privKeySet = 1;
  2a:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  2e:	f043 0301 	orr.w	r3, r3, #1
  32:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    ret = wc_ed25519_make_public(key, key->p, ED25519_PUB_KEY_SIZE);
  36:	463a      	mov	r2, r7
  38:	4621      	mov	r1, r4
  3a:	4620      	mov	r0, r4
  3c:	f7ff fffe 	bl	0 <wc_ed25519_make_key>
    if (ret != 0) {
  40:	4605      	mov	r5, r0
  42:	f104 0040 	add.w	r0, r4, #64	; 0x40
  46:	b16d      	cbz	r5, 64 <wc_ed25519_make_key+0x64>
        key->privKeySet = 0;
  48:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  4c:	f36f 0300 	bfc	r3, #0, #1
  50:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
  54:	2300      	movs	r3, #0
  56:	4286      	cmp	r6, r0
  58:	d101      	bne.n	5e <wc_ed25519_make_key+0x5e>

    /* put public key after private key, on the same buffer */
    XMEMMOVE(key->k + ED25519_KEY_SIZE, key->p, ED25519_PUB_KEY_SIZE);

    return ret;
}
  5a:	4628      	mov	r0, r5
  5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  5e:	f806 3b01 	strb.w	r3, [r6], #1
  62:	e7f8      	b.n	56 <wc_ed25519_make_key+0x56>
    XMEMMOVE(key->k + ED25519_KEY_SIZE, key->p, ED25519_PUB_KEY_SIZE);
  64:	463a      	mov	r2, r7
  66:	4621      	mov	r1, r4
  68:	f7ff fffe 	bl	0 <memmove>
    return ret;
  6c:	e7f5      	b.n	5a <wc_ed25519_make_key+0x5a>
        return BAD_FUNC_ARG;
  6e:	f06f 05ac 	mvn.w	r5, #172	; 0xac
  72:	e7f2      	b.n	5a <wc_ed25519_make_key+0x5a>

Disassembly of section .text.wc_ed25519_sign_msg_ex:

00000000 <wc_ed25519_sign_msg_ex>:
    return 0 on success
 */
int wc_ed25519_sign_msg_ex(const byte* in, word32 inLen, byte* out,
                            word32 *outLen, ed25519_key* key, byte type,
                            const byte* context, byte contextLen)
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	f5ad 7d11 	sub.w	sp, sp, #580	; 0x244
   8:	460f      	mov	r7, r1
   a:	f8dd 8260 	ldr.w	r8, [sp, #608]	; 0x260
   e:	f8dd 9268 	ldr.w	r9, [sp, #616]	; 0x268
  12:	4615      	mov	r5, r2
    ALIGN16 byte nonce[WC_SHA512_DIGEST_SIZE];
    ALIGN16 byte hram[WC_SHA512_DIGEST_SIZE];
    ALIGN16 byte az[ED25519_PRV_KEY_SIZE];

    /* sanity check on arguments */
    if (in == NULL || out == NULL || outLen == NULL || key == NULL ||
  14:	4606      	mov	r6, r0
  16:	2800      	cmp	r0, #0
  18:	f000 80e9 	beq.w	1ee <wc_ed25519_sign_msg_ex+0x1ee>
  1c:	2a00      	cmp	r2, #0
  1e:	f000 80e6 	beq.w	1ee <wc_ed25519_sign_msg_ex+0x1ee>
  22:	2b00      	cmp	r3, #0
  24:	f000 80e3 	beq.w	1ee <wc_ed25519_sign_msg_ex+0x1ee>
  28:	f1b8 0f00 	cmp.w	r8, #0
  2c:	f000 80df 	beq.w	1ee <wc_ed25519_sign_msg_ex+0x1ee>
  30:	f1b9 0f00 	cmp.w	r9, #0
  34:	d104      	bne.n	40 <wc_ed25519_sign_msg_ex+0x40>
                                         (context == NULL && contextLen != 0)) {
  36:	f89d 226c 	ldrb.w	r2, [sp, #620]	; 0x26c
  3a:	2a00      	cmp	r2, #0
  3c:	f040 80d7 	bne.w	1ee <wc_ed25519_sign_msg_ex+0x1ee>
            return ret;
        /* fall-through when unavailable */
    }
#endif

    if (!key->pubKeySet)
  40:	f898 2060 	ldrb.w	r2, [r8, #96]	; 0x60
  44:	0792      	lsls	r2, r2, #30
  46:	f140 80d2 	bpl.w	1ee <wc_ed25519_sign_msg_ex+0x1ee>
        return BAD_FUNC_ARG;

    /* check and set up out length */
    if (*outLen < ED25519_SIG_SIZE) {
  4a:	681a      	ldr	r2, [r3, #0]
  4c:	2a3f      	cmp	r2, #63	; 0x3f
  4e:	f04f 0240 	mov.w	r2, #64	; 0x40
        *outLen = ED25519_SIG_SIZE;
  52:	601a      	str	r2, [r3, #0]
    if (*outLen < ED25519_SIG_SIZE) {
  54:	d806      	bhi.n	64 <wc_ed25519_sign_msg_ex+0x64>
        return BUFFER_E;
  56:	f06f 0483 	mvn.w	r4, #131	; 0x83
    sc_reduce(hram);
    sc_muladd(out + (ED25519_SIG_SIZE/2), hram, az, nonce);
#endif
#endif /* WOLFSSL_SE050 */
    return ret;
}
  5a:	4620      	mov	r0, r4
  5c:	f50d 7d11 	add.w	sp, sp, #580	; 0x244
  60:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    ret = ed25519_hash(key, key->k, ED25519_KEY_SIZE, az);
  64:	2220      	movs	r2, #32
  66:	ab20      	add	r3, sp, #128	; 0x80
  68:	eb08 0102 	add.w	r1, r8, r2
  6c:	4640      	mov	r0, r8
  6e:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg_ex>
    if (ret != 0)
  72:	4604      	mov	r4, r0
  74:	2800      	cmp	r0, #0
  76:	d1f0      	bne.n	5a <wc_ed25519_sign_msg_ex+0x5a>
    az[0]  &= 248;
  78:	f89d 3080 	ldrb.w	r3, [sp, #128]	; 0x80
  7c:	f023 0307 	bic.w	r3, r3, #7
  80:	f88d 3080 	strb.w	r3, [sp, #128]	; 0x80
    az[31] &= 63; /* same than az[31] &= 127 because of az[31] |= 64 */
  84:	f89d 309f 	ldrb.w	r3, [sp, #159]	; 0x9f
  88:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    az[31] |= 64;
  8c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
        ret = ed25519_hash_init(key, sha);
  90:	a958      	add	r1, sp, #352	; 0x160
  92:	4640      	mov	r0, r8
    az[31] |= 64;
  94:	f88d 309f 	strb.w	r3, [sp, #159]	; 0x9f
        ret = ed25519_hash_init(key, sha);
  98:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg_ex>
        if (ret < 0) {
  9c:	1e04      	subs	r4, r0, #0
  9e:	dbdc      	blt.n	5a <wc_ed25519_sign_msg_ex+0x5a>
        if (type == Ed25519ctx || type == Ed25519ph) {
  a0:	f89d 3264 	ldrb.w	r3, [sp, #612]	; 0x264
  a4:	2b01      	cmp	r3, #1
  a6:	d871      	bhi.n	18c <wc_ed25519_sign_msg_ex+0x18c>
    return wc_Sha512Update(sha, data, len);
  a8:	4952      	ldr	r1, [pc, #328]	; (1f4 <wc_ed25519_sign_msg_ex+0x1f4>)
  aa:	2220      	movs	r2, #32
  ac:	a858      	add	r0, sp, #352	; 0x160
  ae:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret == 0)
  b2:	4604      	mov	r4, r0
  b4:	b9c0      	cbnz	r0, e8 <wc_ed25519_sign_msg_ex+0xe8>
    return wc_Sha512Update(sha, data, len);
  b6:	2201      	movs	r2, #1
  b8:	a999      	add	r1, sp, #612	; 0x264
  ba:	a858      	add	r0, sp, #352	; 0x160
  bc:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret == 0)
  c0:	4604      	mov	r4, r0
  c2:	b988      	cbnz	r0, e8 <wc_ed25519_sign_msg_ex+0xe8>
    return wc_Sha512Update(sha, data, len);
  c4:	2201      	movs	r2, #1
  c6:	a99b      	add	r1, sp, #620	; 0x26c
  c8:	a858      	add	r0, sp, #352	; 0x160
  ca:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret == 0 && context != NULL)
  ce:	4604      	mov	r4, r0
  d0:	b950      	cbnz	r0, e8 <wc_ed25519_sign_msg_ex+0xe8>
  d2:	f1b9 0f00 	cmp.w	r9, #0
  d6:	d152      	bne.n	17e <wc_ed25519_sign_msg_ex+0x17e>
    return wc_Sha512Update(sha, data, len);
  d8:	2220      	movs	r2, #32
  da:	a928      	add	r1, sp, #160	; 0xa0
  dc:	a858      	add	r0, sp, #352	; 0x160
  de:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0)
  e2:	4604      	mov	r4, r0
  e4:	2800      	cmp	r0, #0
  e6:	d054      	beq.n	192 <wc_ed25519_sign_msg_ex+0x192>
    wc_Sha512Free(sha);
  e8:	a858      	add	r0, sp, #352	; 0x160
  ea:	f7ff fffe 	bl	0 <wc_Sha512Free>
    if (ret != 0)
  ee:	2c00      	cmp	r4, #0
  f0:	d1b3      	bne.n	5a <wc_ed25519_sign_msg_ex+0x5a>
    sc_reduce(nonce);
  f2:	4668      	mov	r0, sp
  f4:	f7ff fffe 	bl	0 <sc_reduce>
    ge_scalarmult_base(&R,nonce);
  f8:	4669      	mov	r1, sp
  fa:	a830      	add	r0, sp, #192	; 0xc0
  fc:	f7ff fffe 	bl	0 <ge_scalarmult_base>
    ge_p3_tobytes(out,&R);
 100:	a930      	add	r1, sp, #192	; 0xc0
 102:	4628      	mov	r0, r5
 104:	f7ff fffe 	bl	0 <ge_tobytes>
        ret = ed25519_hash_init(key, sha);
 108:	a958      	add	r1, sp, #352	; 0x160
 10a:	4640      	mov	r0, r8
 10c:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg_ex>
        if (ret < 0)
 110:	1e04      	subs	r4, r0, #0
 112:	dba2      	blt.n	5a <wc_ed25519_sign_msg_ex+0x5a>
        if (type == Ed25519ctx || type == Ed25519ph) {
 114:	f89d 3264 	ldrb.w	r3, [sp, #612]	; 0x264
 118:	2b01      	cmp	r3, #1
 11a:	d84f      	bhi.n	1bc <wc_ed25519_sign_msg_ex+0x1bc>
    return wc_Sha512Update(sha, data, len);
 11c:	4935      	ldr	r1, [pc, #212]	; (1f4 <wc_ed25519_sign_msg_ex+0x1f4>)
 11e:	2220      	movs	r2, #32
 120:	a858      	add	r0, sp, #352	; 0x160
 122:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret == 0)
 126:	4604      	mov	r4, r0
 128:	b9c0      	cbnz	r0, 15c <wc_ed25519_sign_msg_ex+0x15c>
    return wc_Sha512Update(sha, data, len);
 12a:	2201      	movs	r2, #1
 12c:	a999      	add	r1, sp, #612	; 0x264
 12e:	a858      	add	r0, sp, #352	; 0x160
 130:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret == 0)
 134:	4604      	mov	r4, r0
 136:	b988      	cbnz	r0, 15c <wc_ed25519_sign_msg_ex+0x15c>
    return wc_Sha512Update(sha, data, len);
 138:	2201      	movs	r2, #1
 13a:	a99b      	add	r1, sp, #620	; 0x26c
 13c:	a858      	add	r0, sp, #352	; 0x160
 13e:	f7ff fffe 	bl	0 <wc_Sha512Update>
            if (ret == 0 && context != NULL)
 142:	4604      	mov	r4, r0
 144:	b950      	cbnz	r0, 15c <wc_ed25519_sign_msg_ex+0x15c>
 146:	f1b9 0f00 	cmp.w	r9, #0
 14a:	d130      	bne.n	1ae <wc_ed25519_sign_msg_ex+0x1ae>
    return wc_Sha512Update(sha, data, len);
 14c:	2220      	movs	r2, #32
 14e:	4629      	mov	r1, r5
 150:	a858      	add	r0, sp, #352	; 0x160
 152:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0)
 156:	4604      	mov	r4, r0
 158:	2800      	cmp	r0, #0
 15a:	d032      	beq.n	1c2 <wc_ed25519_sign_msg_ex+0x1c2>
    wc_Sha512Free(sha);
 15c:	a858      	add	r0, sp, #352	; 0x160
 15e:	f7ff fffe 	bl	0 <wc_Sha512Free>
    if (ret != 0)
 162:	2c00      	cmp	r4, #0
 164:	f47f af79 	bne.w	5a <wc_ed25519_sign_msg_ex+0x5a>
    sc_reduce(hram);
 168:	a810      	add	r0, sp, #64	; 0x40
 16a:	f7ff fffe 	bl	0 <sc_reduce>
    sc_muladd(out + (ED25519_SIG_SIZE/2), hram, az, nonce);
 16e:	466b      	mov	r3, sp
 170:	aa20      	add	r2, sp, #128	; 0x80
 172:	a910      	add	r1, sp, #64	; 0x40
 174:	f105 0020 	add.w	r0, r5, #32
 178:	f7ff fffe 	bl	0 <sc_muladd>
    return ret;
 17c:	e76d      	b.n	5a <wc_ed25519_sign_msg_ex+0x5a>
    return wc_Sha512Update(sha, data, len);
 17e:	f89d 226c 	ldrb.w	r2, [sp, #620]	; 0x26c
 182:	4649      	mov	r1, r9
 184:	a858      	add	r0, sp, #352	; 0x160
 186:	f7ff fffe 	bl	0 <wc_Sha512Update>
 18a:	4604      	mov	r4, r0
        if (ret == 0)
 18c:	2c00      	cmp	r4, #0
 18e:	d1ab      	bne.n	e8 <wc_ed25519_sign_msg_ex+0xe8>
 190:	e7a2      	b.n	d8 <wc_ed25519_sign_msg_ex+0xd8>
    return wc_Sha512Update(sha, data, len);
 192:	463a      	mov	r2, r7
 194:	4631      	mov	r1, r6
 196:	a858      	add	r0, sp, #352	; 0x160
 198:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0)
 19c:	4604      	mov	r4, r0
 19e:	2800      	cmp	r0, #0
 1a0:	d1a2      	bne.n	e8 <wc_ed25519_sign_msg_ex+0xe8>
    int ret = wc_Sha512Final(sha, hash);
 1a2:	4669      	mov	r1, sp
 1a4:	a858      	add	r0, sp, #352	; 0x160
 1a6:	f7ff fffe 	bl	0 <wc_Sha512Final>
 1aa:	4604      	mov	r4, r0
    return ret;
 1ac:	e79c      	b.n	e8 <wc_ed25519_sign_msg_ex+0xe8>
    return wc_Sha512Update(sha, data, len);
 1ae:	f89d 226c 	ldrb.w	r2, [sp, #620]	; 0x26c
 1b2:	4649      	mov	r1, r9
 1b4:	a858      	add	r0, sp, #352	; 0x160
 1b6:	f7ff fffe 	bl	0 <wc_Sha512Update>
 1ba:	4604      	mov	r4, r0
        if (ret == 0)
 1bc:	2c00      	cmp	r4, #0
 1be:	d1cd      	bne.n	15c <wc_ed25519_sign_msg_ex+0x15c>
 1c0:	e7c4      	b.n	14c <wc_ed25519_sign_msg_ex+0x14c>
    return wc_Sha512Update(sha, data, len);
 1c2:	2220      	movs	r2, #32
 1c4:	4641      	mov	r1, r8
 1c6:	a858      	add	r0, sp, #352	; 0x160
 1c8:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0)
 1cc:	4604      	mov	r4, r0
 1ce:	2800      	cmp	r0, #0
 1d0:	d1c4      	bne.n	15c <wc_ed25519_sign_msg_ex+0x15c>
    return wc_Sha512Update(sha, data, len);
 1d2:	463a      	mov	r2, r7
 1d4:	4631      	mov	r1, r6
 1d6:	a858      	add	r0, sp, #352	; 0x160
 1d8:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0)
 1dc:	4604      	mov	r4, r0
 1de:	2800      	cmp	r0, #0
 1e0:	d1bc      	bne.n	15c <wc_ed25519_sign_msg_ex+0x15c>
    int ret = wc_Sha512Final(sha, hash);
 1e2:	a910      	add	r1, sp, #64	; 0x40
 1e4:	a858      	add	r0, sp, #352	; 0x160
 1e6:	f7ff fffe 	bl	0 <wc_Sha512Final>
 1ea:	4604      	mov	r4, r0
    return ret;
 1ec:	e7b6      	b.n	15c <wc_ed25519_sign_msg_ex+0x15c>
        return BAD_FUNC_ARG;
 1ee:	f06f 04ac 	mvn.w	r4, #172	; 0xac
 1f2:	e732      	b.n	5a <wc_ed25519_sign_msg_ex+0x5a>
 1f4:	00000000 	.word	0x00000000

Disassembly of section .text.wc_ed25519_sign_msg:

00000000 <wc_ed25519_sign_msg>:
    key    is the ed25519 key to use when signing
    return 0 on success
 */
int wc_ed25519_sign_msg(const byte* in, word32 inLen, byte* out,
                        word32 *outLen, ed25519_key* key)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return wc_ed25519_sign_msg_ex(in, inLen, out, outLen, key, (byte)Ed25519,
   2:	2400      	movs	r4, #0
   4:	e9cd 4402 	strd	r4, r4, [sp, #8]
   8:	24ff      	movs	r4, #255	; 0xff
   a:	9401      	str	r4, [sp, #4]
   c:	9c06      	ldr	r4, [sp, #24]
   e:	9400      	str	r4, [sp, #0]
  10:	f7ff fffe 	bl	0 <wc_ed25519_sign_msg>
        NULL, 0);
}
  14:	b004      	add	sp, #16
  16:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519ctx_sign_msg:

00000000 <wc_ed25519ctx_sign_msg>:
    return 0 on success
 */
int wc_ed25519ctx_sign_msg(const byte* in, word32 inLen, byte* out,
                           word32 *outLen, ed25519_key* key,
                           const byte* context, byte contextLen)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return wc_ed25519_sign_msg_ex(in, inLen, out, outLen, key, Ed25519ctx,
   2:	f89d 4020 	ldrb.w	r4, [sp, #32]
   6:	9403      	str	r4, [sp, #12]
   8:	9c07      	ldr	r4, [sp, #28]
   a:	9402      	str	r4, [sp, #8]
   c:	2400      	movs	r4, #0
   e:	9401      	str	r4, [sp, #4]
  10:	9c06      	ldr	r4, [sp, #24]
  12:	9400      	str	r4, [sp, #0]
  14:	f7ff fffe 	bl	0 <wc_ed25519ctx_sign_msg>
                                                           context, contextLen);
}
  18:	b004      	add	sp, #16
  1a:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519ph_sign_hash:

00000000 <wc_ed25519ph_sign_hash>:
    return 0 on success
 */
int wc_ed25519ph_sign_hash(const byte* hash, word32 hashLen, byte* out,
                           word32 *outLen, ed25519_key* key,
                           const byte* context, byte contextLen)
{
   0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return wc_ed25519_sign_msg_ex(hash, hashLen, out, outLen, key, Ed25519ph,
   2:	f89d 4020 	ldrb.w	r4, [sp, #32]
   6:	9403      	str	r4, [sp, #12]
   8:	9c07      	ldr	r4, [sp, #28]
   a:	9402      	str	r4, [sp, #8]
   c:	2401      	movs	r4, #1
   e:	9401      	str	r4, [sp, #4]
  10:	9c06      	ldr	r4, [sp, #24]
  12:	9400      	str	r4, [sp, #0]
  14:	f7ff fffe 	bl	0 <wc_ed25519ph_sign_hash>
                                                           context, contextLen);
}
  18:	b004      	add	sp, #16
  1a:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519ph_sign_msg:

00000000 <wc_ed25519ph_sign_msg>:
    return 0 on success
 */
int wc_ed25519ph_sign_msg(const byte* in, word32 inLen, byte* out,
                          word32 *outLen, ed25519_key* key,
                          const byte* context, byte contextLen)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b094      	sub	sp, #80	; 0x50
   4:	4614      	mov	r4, r2
   6:	9e18      	ldr	r6, [sp, #96]	; 0x60
   8:	461d      	mov	r5, r3
    int  ret;
    byte hash[WC_SHA512_DIGEST_SIZE];

    ret = ed25519_hash(key, in, inLen, hash);
   a:	460a      	mov	r2, r1
   c:	ab04      	add	r3, sp, #16
   e:	4601      	mov	r1, r0
  10:	4630      	mov	r0, r6
  12:	f7ff fffe 	bl	0 <wc_ed25519ph_sign_msg>
    if (ret != 0)
  16:	b968      	cbnz	r0, 34 <wc_ed25519ph_sign_msg+0x34>
        return ret;

    return wc_ed25519_sign_msg_ex(hash, sizeof(hash), out, outLen, key,
  18:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
  1c:	9303      	str	r3, [sp, #12]
  1e:	9b19      	ldr	r3, [sp, #100]	; 0x64
  20:	9302      	str	r3, [sp, #8]
  22:	2301      	movs	r3, #1
  24:	e9cd 6300 	strd	r6, r3, [sp]
  28:	4622      	mov	r2, r4
  2a:	462b      	mov	r3, r5
  2c:	2140      	movs	r1, #64	; 0x40
  2e:	a804      	add	r0, sp, #16
  30:	f7ff fffe 	bl	0 <wc_ed25519ph_sign_msg>
                                                Ed25519ph, context, contextLen);
}
  34:	b014      	add	sp, #80	; 0x50
  36:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.wc_ed25519_verify_msg_ex:

00000000 <wc_ed25519_verify_msg_ex>:
   return  0 and res of 1 on success
*/
int wc_ed25519_verify_msg_ex(const byte* sig, word32 sigLen, const byte* msg,
                              word32 msgLen, int* res, ed25519_key* key,
                              byte type, const byte* context, byte contextLen)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	f5ad 7d19 	sub.w	sp, sp, #612	; 0x264
   8:	469a      	mov	sl, r3
   a:	9ea3      	ldr	r6, [sp, #652]	; 0x28c
   c:	f89d 8290 	ldrb.w	r8, [sp, #656]	; 0x290
  10:	f8dd 9294 	ldr.w	r9, [sp, #660]	; 0x294
  14:	f89d 3298 	ldrb.w	r3, [sp, #664]	; 0x298
  18:	468b      	mov	fp, r1
  1a:	4617      	mov	r7, r2
#else
    wc_Sha512 sha[1];
#endif

    /* sanity check on arguments */
    if (sig == NULL || msg == NULL || res == NULL || key == NULL ||
  1c:	4605      	mov	r5, r0
  1e:	2800      	cmp	r0, #0
  20:	f000 80bf 	beq.w	1a2 <wc_ed25519_verify_msg_ex+0x1a2>
  24:	2a00      	cmp	r2, #0
  26:	f000 80bc 	beq.w	1a2 <wc_ed25519_verify_msg_ex+0x1a2>
  2a:	9aa2      	ldr	r2, [sp, #648]	; 0x288
  2c:	2a00      	cmp	r2, #0
  2e:	f000 80b8 	beq.w	1a2 <wc_ed25519_verify_msg_ex+0x1a2>
  32:	2e00      	cmp	r6, #0
  34:	f000 80b5 	beq.w	1a2 <wc_ed25519_verify_msg_ex+0x1a2>
  38:	f1b9 0f00 	cmp.w	r9, #0
  3c:	d102      	bne.n	44 <wc_ed25519_verify_msg_ex+0x44>
                                         (context == NULL && contextLen != 0))
  3e:	2b00      	cmp	r3, #0
  40:	f040 80af 	bne.w	1a2 <wc_ed25519_verify_msg_ex+0x1a2>
#endif

#ifdef WOLFSSL_ED25519_PERSISTENT_SHA
    sha = &key->sha;
#else
    ret = ed25519_hash_init(key, sha);
  44:	a960      	add	r1, sp, #384	; 0x180
  46:	4630      	mov	r0, r6
  48:	9301      	str	r3, [sp, #4]
  4a:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg_ex>
    if (ret < 0) {
  4e:	1e04      	subs	r4, r0, #0
  50:	db6f      	blt.n	132 <wc_ed25519_verify_msg_ex+0x132>
        return ret;
    }
#endif /* WOLFSSL_ED25519_PERSISTENT_SHA */

    ret = ed25519_verify_msg_init_with_sha(sig, sigLen, key, sha, type, context,
  52:	9b01      	ldr	r3, [sp, #4]
  54:	f88d 8068 	strb.w	r8, [sp, #104]	; 0x68
  58:	f88d 30e0 	strb.w	r3, [sp, #224]	; 0xe0
    if (sig == NULL || key == NULL ||
  5c:	f1b9 0f00 	cmp.w	r9, #0
  60:	d103      	bne.n	6a <wc_ed25519_verify_msg_ex+0x6a>
        (context == NULL && contextLen != 0)) {
  62:	b113      	cbz	r3, 6a <wc_ed25519_verify_msg_ex+0x6a>
        return BAD_FUNC_ARG;
  64:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  68:	e060      	b.n	12c <wc_ed25519_verify_msg_ex+0x12c>
    if (sigLen != ED25519_SIG_SIZE || (sig[ED25519_SIG_SIZE-1] & 224))
  6a:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
  6e:	d1f9      	bne.n	64 <wc_ed25519_verify_msg_ex+0x64>
  70:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
  74:	f013 0fe0 	tst.w	r3, #224	; 0xe0
  78:	d1f4      	bne.n	64 <wc_ed25519_verify_msg_ex+0x64>
    if (type == Ed25519ctx || type == Ed25519ph) {
  7a:	f1b8 0f01 	cmp.w	r8, #1
  7e:	d934      	bls.n	ea <wc_ed25519_verify_msg_ex+0xea>
    return wc_Sha512Update(sha, data, len);
  80:	2220      	movs	r2, #32
  82:	4629      	mov	r1, r5
  84:	a860      	add	r0, sp, #384	; 0x180
  86:	f7ff fffe 	bl	0 <wc_Sha512Update>
    if (ret == 0)
  8a:	4604      	mov	r4, r0
  8c:	2800      	cmp	r0, #0
  8e:	d14d      	bne.n	12c <wc_ed25519_verify_msg_ex+0x12c>
    return wc_Sha512Update(sha, data, len);
  90:	2220      	movs	r2, #32
  92:	4631      	mov	r1, r6
  94:	a860      	add	r0, sp, #384	; 0x180
  96:	f7ff fffe 	bl	0 <wc_Sha512Update>
        contextLen);
    if (ret == 0)
  9a:	4604      	mov	r4, r0
  9c:	2800      	cmp	r0, #0
  9e:	d145      	bne.n	12c <wc_ed25519_verify_msg_ex+0x12c>
    return wc_Sha512Update(sha, data, len);
  a0:	4652      	mov	r2, sl
  a2:	4639      	mov	r1, r7
  a4:	a860      	add	r0, sp, #384	; 0x180
  a6:	f7ff fffe 	bl	0 <wc_Sha512Update>
        ret = ed25519_verify_msg_update_with_sha(msg, msgLen, key, sha);
    if (ret == 0)
  aa:	4604      	mov	r4, r0
  ac:	2800      	cmp	r0, #0
  ae:	d13d      	bne.n	12c <wc_ed25519_verify_msg_ex+0x12c>
    *res = 0;
  b0:	9ba2      	ldr	r3, [sp, #648]	; 0x288
  b2:	6018      	str	r0, [r3, #0]
    if (sig[ED25519_SIG_SIZE-1] > 0x10)
  b4:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
  b8:	2b10      	cmp	r3, #16
  ba:	d8d3      	bhi.n	64 <wc_ed25519_verify_msg_ex+0x64>
    if (sig[ED25519_SIG_SIZE-1] == 0x10) {
  bc:	d13e      	bne.n	13c <wc_ed25519_verify_msg_ex+0x13c>
  be:	f105 033f 	add.w	r3, r5, #63	; 0x3f
  c2:	f105 0230 	add.w	r2, r5, #48	; 0x30
            if (sig[i] > 0x00)
  c6:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
  ca:	2900      	cmp	r1, #0
  cc:	d136      	bne.n	13c <wc_ed25519_verify_msg_ex+0x13c>
        for (--i; i > ED25519_SIG_LOW_ORDER_IDX; i--) {
  ce:	4293      	cmp	r3, r2
  d0:	d1f9      	bne.n	c6 <wc_ed25519_verify_msg_ex+0xc6>
  d2:	4a35      	ldr	r2, [pc, #212]	; (1a8 <wc_ed25519_verify_msg_ex+0x1a8>)
  d4:	232f      	movs	r3, #47	; 0x2f
                if (sig[i] < ed25519_low_order[j])
  d6:	5ce8      	ldrb	r0, [r5, r3]
  d8:	f812 1b01 	ldrb.w	r1, [r2], #1
  dc:	4288      	cmp	r0, r1
  de:	d32d      	bcc.n	13c <wc_ed25519_verify_msg_ex+0x13c>
                if (sig[i] > ed25519_low_order[j])
  e0:	d8c0      	bhi.n	64 <wc_ed25519_verify_msg_ex+0x64>
            for (j = 0; j < (int)sizeof(ed25519_low_order); j++, i--) {
  e2:	3b01      	subs	r3, #1
  e4:	2b1f      	cmp	r3, #31
  e6:	d1f6      	bne.n	d6 <wc_ed25519_verify_msg_ex+0xd6>
  e8:	e7bc      	b.n	64 <wc_ed25519_verify_msg_ex+0x64>
    return wc_Sha512Update(sha, data, len);
  ea:	4930      	ldr	r1, [pc, #192]	; (1ac <wc_ed25519_verify_msg_ex+0x1ac>)
  ec:	2220      	movs	r2, #32
  ee:	a860      	add	r0, sp, #384	; 0x180
  f0:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0)
  f4:	4604      	mov	r4, r0
  f6:	b9c8      	cbnz	r0, 12c <wc_ed25519_verify_msg_ex+0x12c>
    return wc_Sha512Update(sha, data, len);
  f8:	2201      	movs	r2, #1
  fa:	a91a      	add	r1, sp, #104	; 0x68
  fc:	a860      	add	r0, sp, #384	; 0x180
  fe:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0)
 102:	4604      	mov	r4, r0
 104:	b990      	cbnz	r0, 12c <wc_ed25519_verify_msg_ex+0x12c>
    return wc_Sha512Update(sha, data, len);
 106:	2201      	movs	r2, #1
 108:	a938      	add	r1, sp, #224	; 0xe0
 10a:	a860      	add	r0, sp, #384	; 0x180
 10c:	f7ff fffe 	bl	0 <wc_Sha512Update>
        if (ret == 0 && context != NULL)
 110:	4604      	mov	r4, r0
 112:	b958      	cbnz	r0, 12c <wc_ed25519_verify_msg_ex+0x12c>
 114:	f1b9 0f00 	cmp.w	r9, #0
 118:	d0b2      	beq.n	80 <wc_ed25519_verify_msg_ex+0x80>
    return wc_Sha512Update(sha, data, len);
 11a:	f89d 20e0 	ldrb.w	r2, [sp, #224]	; 0xe0
 11e:	4649      	mov	r1, r9
 120:	a860      	add	r0, sp, #384	; 0x180
 122:	f7ff fffe 	bl	0 <wc_Sha512Update>
    if (ret == 0)
 126:	4604      	mov	r4, r0
 128:	2800      	cmp	r0, #0
 12a:	d0a9      	beq.n	80 <wc_ed25519_verify_msg_ex+0x80>
    wc_Sha512Free(sha);
 12c:	a860      	add	r0, sp, #384	; 0x180
 12e:	f7ff fffe 	bl	0 <wc_Sha512Free>
#ifndef WOLFSSL_ED25519_PERSISTENT_SHA
    ed25519_hash_free(key, sha);
#endif
#endif /* WOLFSSL_SE050 */
    return ret;
}
 132:	4620      	mov	r0, r4
 134:	f50d 7d19 	add.w	sp, sp, #612	; 0x264
 138:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (ge_frombytes_negate_vartime(&A, key->p) != 0)
 13c:	4631      	mov	r1, r6
 13e:	a838      	add	r0, sp, #224	; 0xe0
 140:	f7ff fffe 	bl	0 <ge_frombytes_negate_vartime>
 144:	2800      	cmp	r0, #0
 146:	d18d      	bne.n	64 <wc_ed25519_verify_msg_ex+0x64>
    int ret = wc_Sha512Final(sha, hash);
 148:	a90a      	add	r1, sp, #40	; 0x28
 14a:	a860      	add	r0, sp, #384	; 0x180
 14c:	f7ff fffe 	bl	0 <wc_Sha512Final>
    if (ret != 0)
 150:	4604      	mov	r4, r0
 152:	2800      	cmp	r0, #0
 154:	d1ea      	bne.n	12c <wc_ed25519_verify_msg_ex+0x12c>
    sc_reduce(h);
 156:	a80a      	add	r0, sp, #40	; 0x28
 158:	f7ff fffe 	bl	0 <sc_reduce>
    ret = ge_double_scalarmult_vartime(&R, h, &A, sig + (ED25519_SIG_SIZE/2));
 15c:	f105 0320 	add.w	r3, r5, #32
 160:	aa38      	add	r2, sp, #224	; 0xe0
 162:	a90a      	add	r1, sp, #40	; 0x28
 164:	a81a      	add	r0, sp, #104	; 0x68
 166:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
    if (ret != 0)
 16a:	4604      	mov	r4, r0
 16c:	2800      	cmp	r0, #0
 16e:	d1dd      	bne.n	12c <wc_ed25519_verify_msg_ex+0x12c>
    ge_tobytes(rcheck, &R);
 170:	a91a      	add	r1, sp, #104	; 0x68
 172:	a802      	add	r0, sp, #8
 174:	f7ff fffe 	bl	0 <ge_tobytes>
                                             int length)
{
    int i;
    int compareSum = 0;

    for (i = 0; i < length; i++) {
 178:	1e6a      	subs	r2, r5, #1
 17a:	ab02      	add	r3, sp, #8
 17c:	351f      	adds	r5, #31
        compareSum |= a[i] ^ b[i];
 17e:	f812 0f01 	ldrb.w	r0, [r2, #1]!
 182:	f813 1b01 	ldrb.w	r1, [r3], #1
    for (i = 0; i < length; i++) {
 186:	4295      	cmp	r5, r2
        compareSum |= a[i] ^ b[i];
 188:	ea81 0100 	eor.w	r1, r1, r0
 18c:	ea44 0401 	orr.w	r4, r4, r1
    for (i = 0; i < length; i++) {
 190:	d1f5      	bne.n	17e <wc_ed25519_verify_msg_ex+0x17e>
    if (ret != 0) {
 192:	b91c      	cbnz	r4, 19c <wc_ed25519_verify_msg_ex+0x19c>
        *res = 1;
 194:	9aa2      	ldr	r2, [sp, #648]	; 0x288
 196:	2301      	movs	r3, #1
 198:	6013      	str	r3, [r2, #0]
 19a:	e7c7      	b.n	12c <wc_ed25519_verify_msg_ex+0x12c>
        ret = SIG_VERIFY_E;
 19c:	f06f 04e4 	mvn.w	r4, #228	; 0xe4
 1a0:	e7c4      	b.n	12c <wc_ed25519_verify_msg_ex+0x12c>
        return BAD_FUNC_ARG;
 1a2:	f06f 04ac 	mvn.w	r4, #172	; 0xac
 1a6:	e7c4      	b.n	132 <wc_ed25519_verify_msg_ex+0x132>
	...

Disassembly of section .text.wc_ed25519_verify_msg:

00000000 <wc_ed25519_verify_msg>:
   key     Ed25519 public key
   return  0 and res of 1 on success
*/
int wc_ed25519_verify_msg(const byte* sig, word32 sigLen, const byte* msg,
                          word32 msgLen, int* res, ed25519_key* key)
{
   0:	b510      	push	{r4, lr}
    return wc_ed25519_verify_msg_ex(sig, sigLen, msg, msgLen, res, key,
   2:	2400      	movs	r4, #0
{
   4:	b086      	sub	sp, #24
    return wc_ed25519_verify_msg_ex(sig, sigLen, msg, msgLen, res, key,
   6:	e9cd 4403 	strd	r4, r4, [sp, #12]
   a:	24ff      	movs	r4, #255	; 0xff
   c:	9402      	str	r4, [sp, #8]
   e:	9c09      	ldr	r4, [sp, #36]	; 0x24
  10:	9401      	str	r4, [sp, #4]
  12:	9c08      	ldr	r4, [sp, #32]
  14:	9400      	str	r4, [sp, #0]
  16:	f7ff fffe 	bl	0 <wc_ed25519_verify_msg>
                                    (byte)Ed25519, NULL, 0);
}
  1a:	b006      	add	sp, #24
  1c:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519ctx_verify_msg:

00000000 <wc_ed25519ctx_verify_msg>:
   return  0 and res of 1 on success
*/
int wc_ed25519ctx_verify_msg(const byte* sig, word32 sigLen, const byte* msg,
                             word32 msgLen, int* res, ed25519_key* key,
                             const byte* context, byte contextLen)
{
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
    return wc_ed25519_verify_msg_ex(sig, sigLen, msg, msgLen, res, key,
   4:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
   8:	9404      	str	r4, [sp, #16]
   a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   c:	9403      	str	r4, [sp, #12]
   e:	2400      	movs	r4, #0
  10:	9402      	str	r4, [sp, #8]
  12:	9c09      	ldr	r4, [sp, #36]	; 0x24
  14:	9401      	str	r4, [sp, #4]
  16:	9c08      	ldr	r4, [sp, #32]
  18:	9400      	str	r4, [sp, #0]
  1a:	f7ff fffe 	bl	0 <wc_ed25519ctx_verify_msg>
                                    Ed25519ctx, context, contextLen);
}
  1e:	b006      	add	sp, #24
  20:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519ph_verify_hash:

00000000 <wc_ed25519ph_verify_hash>:
   return  0 and res of 1 on success
*/
int wc_ed25519ph_verify_hash(const byte* sig, word32 sigLen, const byte* hash,
                             word32 hashLen, int* res, ed25519_key* key,
                             const byte* context, byte contextLen)
{
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
    return wc_ed25519_verify_msg_ex(sig, sigLen, hash, hashLen, res, key,
   4:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
   8:	9404      	str	r4, [sp, #16]
   a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
   c:	9403      	str	r4, [sp, #12]
   e:	2401      	movs	r4, #1
  10:	9402      	str	r4, [sp, #8]
  12:	9c09      	ldr	r4, [sp, #36]	; 0x24
  14:	9401      	str	r4, [sp, #4]
  16:	9c08      	ldr	r4, [sp, #32]
  18:	9400      	str	r4, [sp, #0]
  1a:	f7ff fffe 	bl	0 <wc_ed25519ph_verify_hash>
                                    Ed25519ph, context, contextLen);
}
  1e:	b006      	add	sp, #24
  20:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519ph_verify_msg:

00000000 <wc_ed25519ph_verify_msg>:
   return  0 and res of 1 on success
*/
int wc_ed25519ph_verify_msg(const byte* sig, word32 sigLen, const byte* msg,
                            word32 msgLen, int* res, ed25519_key* key,
                            const byte* context, byte contextLen)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b096      	sub	sp, #88	; 0x58
   4:	4604      	mov	r4, r0
   6:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
   8:	460d      	mov	r5, r1
    int  ret;
    byte hash[WC_SHA512_DIGEST_SIZE];

    ret = ed25519_hash(key, msg, msgLen, hash);
   a:	4630      	mov	r0, r6
{
   c:	4611      	mov	r1, r2
   e:	461a      	mov	r2, r3
    ret = ed25519_hash(key, msg, msgLen, hash);
  10:	ab06      	add	r3, sp, #24
  12:	f7ff fffe 	bl	0 <wc_ed25519ph_verify_msg>
    if (ret != 0)
  16:	b978      	cbnz	r0, 38 <wc_ed25519ph_verify_msg+0x38>
        return ret;

    return wc_ed25519_verify_msg_ex(sig, sigLen, hash, sizeof(hash), res, key,
  18:	f89d 3074 	ldrb.w	r3, [sp, #116]	; 0x74
  1c:	9304      	str	r3, [sp, #16]
  1e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
  20:	9303      	str	r3, [sp, #12]
  22:	2301      	movs	r3, #1
  24:	e9cd 6301 	strd	r6, r3, [sp, #4]
  28:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  2a:	9300      	str	r3, [sp, #0]
  2c:	aa06      	add	r2, sp, #24
  2e:	2340      	movs	r3, #64	; 0x40
  30:	4629      	mov	r1, r5
  32:	4620      	mov	r0, r4
  34:	f7ff fffe 	bl	0 <wc_ed25519ph_verify_msg>
                                    Ed25519ph, context, contextLen);
}
  38:	b016      	add	sp, #88	; 0x58
  3a:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.wc_ed25519_init_ex:

00000000 <wc_ed25519_init_ex>:
#endif /* HAVE_ED25519_VERIFY */


/* initialize information and memory for key */
int wc_ed25519_init_ex(ed25519_key* key, void* heap, int devId)
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460d      	mov	r5, r1
    if (key == NULL)
   4:	4604      	mov	r4, r0
   6:	b140      	cbz	r0, 1a <wc_ed25519_init_ex+0x1a>
        return BAD_FUNC_ARG;

    /* for init, ensure the key is zeroed*/
    XMEMSET(key, 0, sizeof(ed25519_key));
   8:	2268      	movs	r2, #104	; 0x68
   a:	2100      	movs	r1, #0
   c:	f7ff fffe 	bl	0 <memset>
#ifdef WOLF_CRYPTO_CB
    key->devId = devId;
#else
    (void)devId;
#endif
    key->heap = heap;
  10:	6665      	str	r5, [r4, #100]	; 0x64

#ifndef FREESCALE_LTC_ECC
    fe_init();
  12:	f7ff fffe 	bl	0 <fe_init>
#endif

#ifdef WOLFSSL_ED25519_PERSISTENT_SHA
    return ed25519_hash_init(key, &key->sha);
#else /* !WOLFSSL_ED25519_PERSISTENT_SHA */
    return 0;
  16:	2000      	movs	r0, #0
#endif /* WOLFSSL_ED25519_PERSISTENT_SHA */
}
  18:	bd38      	pop	{r3, r4, r5, pc}
        return BAD_FUNC_ARG;
  1a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  1e:	e7fb      	b.n	18 <wc_ed25519_init_ex+0x18>

Disassembly of section .text.wc_ed25519_init:

00000000 <wc_ed25519_init>:

int wc_ed25519_init(ed25519_key* key)
{
    return wc_ed25519_init_ex(key, NULL, INVALID_DEVID);
   0:	f06f 0201 	mvn.w	r2, #1
   4:	2100      	movs	r1, #0
   6:	f7ff bffe 	b.w	0 <wc_ed25519_init>

Disassembly of section .text.wc_ed25519_free:

00000000 <wc_ed25519_free>:
}

/* clear memory of key */
void wc_ed25519_free(ed25519_key* key)
{
    if (key == NULL)
   0:	b120      	cbz	r0, c <wc_ed25519_free+0xc>
   2:	f100 0368 	add.w	r3, r0, #104	; 0x68
    while (len--) *z++ = 0;
   6:	2200      	movs	r2, #0
   8:	4298      	cmp	r0, r3
   a:	d100      	bne.n	e <wc_ed25519_free+0xe>

    ForceZero(key, sizeof(ed25519_key));
#ifdef WOLFSSL_CHECK_MEM_ZERO
    wc_MemZero_Check(key, sizeof(ed25519_key));
#endif
}
   c:	4770      	bx	lr
   e:	f800 2b01 	strb.w	r2, [r0], #1
  12:	e7f9      	b.n	8 <wc_ed25519_free+0x8>

Disassembly of section .text.wc_ed25519_export_public:

00000000 <wc_ed25519_export_public>:
    outLen should contain the size of out buffer when input. outLen is than set
    to the final output length.
    returns 0 on success
 */
int wc_ed25519_export_public(ed25519_key* key, byte* out, word32* outLen)
{
   0:	b510      	push	{r4, lr}
   2:	4613      	mov	r3, r2
   4:	460c      	mov	r4, r1
    /* sanity check on arguments */
    if (key == NULL || out == NULL || outLen == NULL)
   6:	4601      	mov	r1, r0
   8:	b178      	cbz	r0, 2a <wc_ed25519_export_public+0x2a>
   a:	b174      	cbz	r4, 2a <wc_ed25519_export_public+0x2a>
   c:	b16a      	cbz	r2, 2a <wc_ed25519_export_public+0x2a>
        return BAD_FUNC_ARG;

    if (*outLen < ED25519_PUB_KEY_SIZE) {
   e:	6812      	ldr	r2, [r2, #0]
  10:	2a1f      	cmp	r2, #31
  12:	f04f 0220 	mov.w	r2, #32
        *outLen = ED25519_PUB_KEY_SIZE;
  16:	601a      	str	r2, [r3, #0]
    if (*outLen < ED25519_PUB_KEY_SIZE) {
  18:	d802      	bhi.n	20 <wc_ed25519_export_public+0x20>
        return BUFFER_E;
  1a:	f06f 0083 	mvn.w	r0, #131	; 0x83

    *outLen = ED25519_PUB_KEY_SIZE;
    XMEMCPY(out, key->p, ED25519_PUB_KEY_SIZE);

    return 0;
}
  1e:	bd10      	pop	{r4, pc}
    XMEMCPY(out, key->p, ED25519_PUB_KEY_SIZE);
  20:	4620      	mov	r0, r4
  22:	f7ff fffe 	bl	0 <memcpy>
    return 0;
  26:	2000      	movs	r0, #0
  28:	e7f9      	b.n	1e <wc_ed25519_export_public+0x1e>
        return BAD_FUNC_ARG;
  2a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  2e:	e7f6      	b.n	1e <wc_ed25519_export_public+0x1e>

Disassembly of section .text.wc_ed25519_export_private_only:

00000000 <wc_ed25519_export_private_only>:
 outLen should contain the size of out buffer when input. outLen is than set
 to the final output length.
 returns 0 on success
 */
int wc_ed25519_export_private_only(ed25519_key* key, byte* out, word32* outLen)
{
   0:	b510      	push	{r4, lr}
   2:	4613      	mov	r3, r2
   4:	460c      	mov	r4, r1
    /* sanity checks on arguments */
    if (key == NULL || out == NULL || outLen == NULL)
   6:	b188      	cbz	r0, 2c <wc_ed25519_export_private_only+0x2c>
   8:	b181      	cbz	r1, 2c <wc_ed25519_export_private_only+0x2c>
   a:	b17a      	cbz	r2, 2c <wc_ed25519_export_private_only+0x2c>
        return BAD_FUNC_ARG;

    if (*outLen < ED25519_KEY_SIZE) {
   c:	6812      	ldr	r2, [r2, #0]
   e:	2a1f      	cmp	r2, #31
  10:	f04f 0220 	mov.w	r2, #32
        *outLen = ED25519_KEY_SIZE;
  14:	601a      	str	r2, [r3, #0]
    if (*outLen < ED25519_KEY_SIZE) {
  16:	d802      	bhi.n	1e <wc_ed25519_export_private_only+0x1e>
        return BUFFER_E;
  18:	f06f 0083 	mvn.w	r0, #131	; 0x83

    *outLen = ED25519_KEY_SIZE;
    XMEMCPY(out, key->k, ED25519_KEY_SIZE);

    return 0;
}
  1c:	bd10      	pop	{r4, pc}
    XMEMCPY(out, key->k, ED25519_KEY_SIZE);
  1e:	f100 0120 	add.w	r1, r0, #32
  22:	4620      	mov	r0, r4
  24:	f7ff fffe 	bl	0 <memcpy>
    return 0;
  28:	2000      	movs	r0, #0
  2a:	e7f7      	b.n	1c <wc_ed25519_export_private_only+0x1c>
        return BAD_FUNC_ARG;
  2c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  30:	e7f4      	b.n	1c <wc_ed25519_export_private_only+0x1c>

Disassembly of section .text.wc_ed25519_export_private:

00000000 <wc_ed25519_export_private>:
 outLen should contain the size of out buffer when input. outLen is than set
 to the final output length.
 returns 0 on success
 */
int wc_ed25519_export_private(ed25519_key* key, byte* out, word32* outLen)
{
   0:	b510      	push	{r4, lr}
   2:	4613      	mov	r3, r2
   4:	460c      	mov	r4, r1
    /* sanity checks on arguments */
    if (key == NULL || out == NULL || outLen == NULL)
   6:	b188      	cbz	r0, 2c <wc_ed25519_export_private+0x2c>
   8:	b181      	cbz	r1, 2c <wc_ed25519_export_private+0x2c>
   a:	b17a      	cbz	r2, 2c <wc_ed25519_export_private+0x2c>
        return BAD_FUNC_ARG;

    if (*outLen < ED25519_PRV_KEY_SIZE) {
   c:	6812      	ldr	r2, [r2, #0]
   e:	2a3f      	cmp	r2, #63	; 0x3f
  10:	f04f 0240 	mov.w	r2, #64	; 0x40
        *outLen = ED25519_PRV_KEY_SIZE;
  14:	601a      	str	r2, [r3, #0]
    if (*outLen < ED25519_PRV_KEY_SIZE) {
  16:	d802      	bhi.n	1e <wc_ed25519_export_private+0x1e>
        return BUFFER_E;
  18:	f06f 0083 	mvn.w	r0, #131	; 0x83

    *outLen = ED25519_PRV_KEY_SIZE;
    XMEMCPY(out, key->k, ED25519_PRV_KEY_SIZE);

    return 0;
}
  1c:	bd10      	pop	{r4, pc}
    XMEMCPY(out, key->k, ED25519_PRV_KEY_SIZE);
  1e:	f100 0120 	add.w	r1, r0, #32
  22:	4620      	mov	r0, r4
  24:	f7ff fffe 	bl	0 <memcpy>
    return 0;
  28:	2000      	movs	r0, #0
  2a:	e7f7      	b.n	1c <wc_ed25519_export_private+0x1c>
        return BAD_FUNC_ARG;
  2c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  30:	e7f4      	b.n	1c <wc_ed25519_export_private+0x1c>

Disassembly of section .text.wc_ed25519_export_key:

00000000 <wc_ed25519_export_key>:
   return 0 on success
 */
int wc_ed25519_export_key(ed25519_key* key,
                          byte* priv, word32 *privSz,
                          byte* pub, word32 *pubSz)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	9e04      	ldr	r6, [sp, #16]
   4:	4604      	mov	r4, r0
   6:	461d      	mov	r5, r3
    int ret;

    /* export 'full' private part */
    ret = wc_ed25519_export_private(key, priv, privSz);
   8:	f7ff fffe 	bl	0 <wc_ed25519_export_key>
    if (ret != 0)
   c:	b930      	cbnz	r0, 1c <wc_ed25519_export_key+0x1c>
        return ret;

    /* export public part */
    ret = wc_ed25519_export_public(key, pub, pubSz);
   e:	4632      	mov	r2, r6
  10:	4629      	mov	r1, r5
  12:	4620      	mov	r0, r4

    return ret;
}
  14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ret = wc_ed25519_export_public(key, pub, pubSz);
  18:	f7ff bffe 	b.w	0 <wc_ed25519_export_key>
}
  1c:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.wc_ed25519_check_key:

00000000 <wc_ed25519_check_key>:

#endif /* HAVE_ED25519_KEY_EXPORT */

/* check the private and public keys match */
int wc_ed25519_check_key(ed25519_key* key)
{
   0:	b510      	push	{r4, lr}
    int ret = 0;
#ifdef HAVE_ED25519_MAKE_KEY
    ALIGN16 unsigned char pubKey[ED25519_PUB_KEY_SIZE];

    if (!key->pubKeySet)
   2:	f890 3060 	ldrb.w	r3, [r0, #96]	; 0x60
   6:	079b      	lsls	r3, r3, #30
{
   8:	b088      	sub	sp, #32
   a:	4604      	mov	r4, r0
    if (!key->pubKeySet)
   c:	d50a      	bpl.n	24 <wc_ed25519_check_key+0x24>
        ret = PUBLIC_KEY_E;
    if (ret == 0)
        ret = wc_ed25519_make_public(key, pubKey, sizeof(pubKey));
   e:	2220      	movs	r2, #32
  10:	4669      	mov	r1, sp
  12:	f7ff fffe 	bl	0 <wc_ed25519_check_key>
    if (ret == 0 && XMEMCMP(pubKey, key->p, ED25519_PUB_KEY_SIZE) != 0)
  16:	b938      	cbnz	r0, 28 <wc_ed25519_check_key+0x28>
  18:	2220      	movs	r2, #32
  1a:	4621      	mov	r1, r4
  1c:	4668      	mov	r0, sp
  1e:	f7ff fffe 	bl	0 <memcmp>
  22:	b108      	cbz	r0, 28 <wc_ed25519_check_key+0x28>
        ret = PUBLIC_KEY_E;
  24:	f06f 0085 	mvn.w	r0, #133	; 0x85
#else
     (void)key;
#endif /* HAVE_ED25519_MAKE_KEY */

    return ret;
}
  28:	b008      	add	sp, #32
  2a:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519_import_public_ex:

00000000 <wc_ed25519_import_public_ex>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	460d      	mov	r5, r1
   4:	4614      	mov	r4, r2
   6:	461e      	mov	r6, r3
    if (in == NULL || key == NULL)
   8:	4601      	mov	r1, r0
   a:	2800      	cmp	r0, #0
   c:	d03a      	beq.n	84 <wc_ed25519_import_public_ex+0x84>
   e:	2a00      	cmp	r2, #0
  10:	d038      	beq.n	84 <wc_ed25519_import_public_ex+0x84>
    if (inLen < ED25519_PUB_KEY_SIZE)
  12:	2d1f      	cmp	r5, #31
  14:	d936      	bls.n	84 <wc_ed25519_import_public_ex+0x84>
    if (in[0] == 0x40 && inLen == ED25519_PUB_KEY_SIZE + 1) {
  16:	7803      	ldrb	r3, [r0, #0]
  18:	2b40      	cmp	r3, #64	; 0x40
  1a:	d110      	bne.n	3e <wc_ed25519_import_public_ex+0x3e>
  1c:	2d21      	cmp	r5, #33	; 0x21
  1e:	d122      	bne.n	66 <wc_ed25519_import_public_ex+0x66>
        XMEMCPY(key->p, (in + 1), ED25519_PUB_KEY_SIZE);
  20:	2220      	movs	r2, #32
  22:	3101      	adds	r1, #1
        XMEMCPY(key->p, in, ED25519_PUB_KEY_SIZE);
  24:	4620      	mov	r0, r4
  26:	f7ff fffe 	bl	0 <memcpy>
        key->pubKeySet = 1;
  2a:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
  2e:	f042 0202 	orr.w	r2, r2, #2
        if (key->privKeySet && (!trusted)) {
  32:	07d3      	lsls	r3, r2, #31
        key->pubKeySet = 1;
  34:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
        if (key->privKeySet && (!trusted)) {
  38:	d419      	bmi.n	6e <wc_ed25519_import_public_ex+0x6e>
        return BAD_FUNC_ARG;
  3a:	2000      	movs	r0, #0
}
  3c:	bd70      	pop	{r4, r5, r6, pc}
    else if (in[0] == 0x04 && inLen > 2*ED25519_PUB_KEY_SIZE) {
  3e:	2b04      	cmp	r3, #4
  40:	d111      	bne.n	66 <wc_ed25519_import_public_ex+0x66>
  42:	2d40      	cmp	r5, #64	; 0x40
  44:	d90f      	bls.n	66 <wc_ed25519_import_public_ex+0x66>
        ret = ge_compress_key(key->p, in+1,
  46:	f100 0221 	add.w	r2, r0, #33	; 0x21
  4a:	2320      	movs	r3, #32
  4c:	3101      	adds	r1, #1
  4e:	4620      	mov	r0, r4
  50:	f7ff fffe 	bl	0 <ge_compress_key>
    if (ret == 0) {
  54:	2800      	cmp	r0, #0
  56:	d0e8      	beq.n	2a <wc_ed25519_import_public_ex+0x2a>
        key->pubKeySet = 0;
  58:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  5c:	f36f 0341 	bfc	r3, #1, #1
  60:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
  64:	e7ea      	b.n	3c <wc_ed25519_import_public_ex+0x3c>
    else if (inLen == ED25519_PUB_KEY_SIZE) {
  66:	2d20      	cmp	r5, #32
  68:	d109      	bne.n	7e <wc_ed25519_import_public_ex+0x7e>
        XMEMCPY(key->p, in, ED25519_PUB_KEY_SIZE);
  6a:	462a      	mov	r2, r5
  6c:	e7da      	b.n	24 <wc_ed25519_import_public_ex+0x24>
        if (key->privKeySet && (!trusted)) {
  6e:	2e00      	cmp	r6, #0
  70:	d1e3      	bne.n	3a <wc_ed25519_import_public_ex+0x3a>
            ret = wc_ed25519_check_key(key);
  72:	4620      	mov	r0, r4
  74:	f7ff fffe 	bl	0 <wc_ed25519_import_public_ex>
    if (ret != 0) {
  78:	2800      	cmp	r0, #0
  7a:	d0de      	beq.n	3a <wc_ed25519_import_public_ex+0x3a>
  7c:	e7ec      	b.n	58 <wc_ed25519_import_public_ex+0x58>
        ret = BAD_FUNC_ARG;
  7e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  82:	e7e9      	b.n	58 <wc_ed25519_import_public_ex+0x58>
        return BAD_FUNC_ARG;
  84:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  88:	e7d8      	b.n	3c <wc_ed25519_import_public_ex+0x3c>

Disassembly of section .text.wc_ed25519_import_public:

00000000 <wc_ed25519_import_public>:
    return wc_ed25519_import_public_ex(in, inLen, key, 0);
   0:	2300      	movs	r3, #0
   2:	f7ff bffe 	b.w	0 <wc_ed25519_import_public>

Disassembly of section .text.wc_ed25519_import_private_key_ex:

00000000 <wc_ed25519_import_private_key_ex>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	9d06      	ldr	r5, [sp, #24]
   6:	460c      	mov	r4, r1
   8:	4690      	mov	r8, r2
   a:	461f      	mov	r7, r3
    if (priv == NULL || key == NULL)
   c:	4601      	mov	r1, r0
   e:	b388      	cbz	r0, 74 <wc_ed25519_import_private_key_ex+0x74>
  10:	b385      	cbz	r5, 74 <wc_ed25519_import_private_key_ex+0x74>
    if (privSz != ED25519_KEY_SIZE && privSz != ED25519_PRV_KEY_SIZE)
  12:	2c20      	cmp	r4, #32
  14:	d001      	beq.n	1a <wc_ed25519_import_private_key_ex+0x1a>
  16:	2c40      	cmp	r4, #64	; 0x40
  18:	d12c      	bne.n	74 <wc_ed25519_import_private_key_ex+0x74>
    if (pub == NULL) {
  1a:	f1b8 0f00 	cmp.w	r8, #0
  1e:	d127      	bne.n	70 <wc_ed25519_import_private_key_ex+0x70>
        if (pubSz != 0)
  20:	bb47      	cbnz	r7, 74 <wc_ed25519_import_private_key_ex+0x74>
        if (privSz != ED25519_PRV_KEY_SIZE)
  22:	2c40      	cmp	r4, #64	; 0x40
  24:	d126      	bne.n	74 <wc_ed25519_import_private_key_ex+0x74>
        pub = priv + ED25519_KEY_SIZE;
  26:	f101 0820 	add.w	r8, r1, #32
        pubSz = ED25519_PUB_KEY_SIZE;
  2a:	2720      	movs	r7, #32
    XMEMCPY(key->k, priv, ED25519_KEY_SIZE);
  2c:	f105 0620 	add.w	r6, r5, #32
  30:	2220      	movs	r2, #32
  32:	4630      	mov	r0, r6
  34:	f7ff fffe 	bl	0 <memcpy>
    key->privKeySet = 1;
  38:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
  3c:	f043 0301 	orr.w	r3, r3, #1
  40:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
    ret = wc_ed25519_import_public_ex(pub, pubSz, key, trusted);
  44:	462a      	mov	r2, r5
  46:	9b07      	ldr	r3, [sp, #28]
  48:	4639      	mov	r1, r7
  4a:	4640      	mov	r0, r8
  4c:	f7ff fffe 	bl	0 <wc_ed25519_import_private_key_ex>
    if (ret != 0) {
  50:	4604      	mov	r4, r0
  52:	f105 0040 	add.w	r0, r5, #64	; 0x40
  56:	b19c      	cbz	r4, 80 <wc_ed25519_import_private_key_ex+0x80>
        key->privKeySet = 0;
  58:	f895 3060 	ldrb.w	r3, [r5, #96]	; 0x60
  5c:	f36f 0300 	bfc	r3, #0, #1
  60:	f885 3060 	strb.w	r3, [r5, #96]	; 0x60
  64:	2300      	movs	r3, #0
  66:	4286      	cmp	r6, r0
  68:	d107      	bne.n	7a <wc_ed25519_import_private_key_ex+0x7a>
}
  6a:	4620      	mov	r0, r4
  6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if (pubSz < ED25519_PUB_KEY_SIZE) {
  70:	2f1f      	cmp	r7, #31
  72:	d8db      	bhi.n	2c <wc_ed25519_import_private_key_ex+0x2c>
        return BAD_FUNC_ARG;
  74:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  78:	e7f7      	b.n	6a <wc_ed25519_import_private_key_ex+0x6a>
  7a:	f806 3b01 	strb.w	r3, [r6], #1
  7e:	e7f2      	b.n	66 <wc_ed25519_import_private_key_ex+0x66>
    XMEMCPY(key->k + ED25519_KEY_SIZE, key->p, ED25519_PUB_KEY_SIZE);
  80:	2220      	movs	r2, #32
  82:	4629      	mov	r1, r5
  84:	f7ff fffe 	bl	0 <memcpy>
    return ret;
  88:	e7ef      	b.n	6a <wc_ed25519_import_private_key_ex+0x6a>

Disassembly of section .text.wc_ed25519_import_private_key:

00000000 <wc_ed25519_import_private_key>:
{
   0:	b513      	push	{r0, r1, r4, lr}
    return wc_ed25519_import_private_key_ex(priv, privSz, pub, pubSz, key, 0);
   2:	2400      	movs	r4, #0
   4:	9401      	str	r4, [sp, #4]
   6:	9c04      	ldr	r4, [sp, #16]
   8:	9400      	str	r4, [sp, #0]
   a:	f7ff fffe 	bl	0 <wc_ed25519_import_private_key>
}
   e:	b002      	add	sp, #8
  10:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_ed25519_import_private_only:

00000000 <wc_ed25519_import_private_only>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460b      	mov	r3, r1
   4:	4614      	mov	r4, r2
    if (priv == NULL || key == NULL)
   6:	4601      	mov	r1, r0
   8:	b320      	cbz	r0, 54 <wc_ed25519_import_private_only+0x54>
   a:	b31a      	cbz	r2, 54 <wc_ed25519_import_private_only+0x54>
    if (privSz != ED25519_KEY_SIZE)
   c:	2b20      	cmp	r3, #32
   e:	d121      	bne.n	54 <wc_ed25519_import_private_only+0x54>
    XMEMCPY(key->k, priv, ED25519_KEY_SIZE);
  10:	f102 0520 	add.w	r5, r2, #32
  14:	4628      	mov	r0, r5
  16:	461a      	mov	r2, r3
  18:	f7ff fffe 	bl	0 <memcpy>
    key->privKeySet = 1;
  1c:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  20:	f043 0301 	orr.w	r3, r3, #1
  24:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    if (key->pubKeySet) {
  28:	079b      	lsls	r3, r3, #30
  2a:	d401      	bmi.n	30 <wc_ed25519_import_private_only+0x30>
    int ret = 0;
  2c:	2000      	movs	r0, #0
}
  2e:	bd38      	pop	{r3, r4, r5, pc}
        ret = wc_ed25519_check_key(key);
  30:	4620      	mov	r0, r4
  32:	f7ff fffe 	bl	0 <wc_ed25519_import_private_only>
    if (ret != 0) {
  36:	2800      	cmp	r0, #0
  38:	d0f8      	beq.n	2c <wc_ed25519_import_private_only+0x2c>
        key->privKeySet = 0;
  3a:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  3e:	f36f 0300 	bfc	r3, #0, #1
  42:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
  46:	3440      	adds	r4, #64	; 0x40
  48:	2300      	movs	r3, #0
  4a:	42a5      	cmp	r5, r4
  4c:	d0ef      	beq.n	2e <wc_ed25519_import_private_only+0x2e>
  4e:	f805 3b01 	strb.w	r3, [r5], #1
  52:	e7fa      	b.n	4a <wc_ed25519_import_private_only+0x4a>
        return BAD_FUNC_ARG;
  54:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  58:	e7e9      	b.n	2e <wc_ed25519_import_private_only+0x2e>

Disassembly of section .text.wc_ed25519_size:

00000000 <wc_ed25519_size>:

/* returns the private key size (secret only) in bytes */
int wc_ed25519_size(ed25519_key* key)
{
    if (key == NULL)
        return BAD_FUNC_ARG;
   0:	2800      	cmp	r0, #0

    return ED25519_KEY_SIZE;
}
   2:	bf14      	ite	ne
   4:	2020      	movne	r0, #32
   6:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   a:	4770      	bx	lr

Disassembly of section .text.wc_ed25519_priv_size:

00000000 <wc_ed25519_priv_size>:

/* returns the private key size (secret + public) in bytes */
int wc_ed25519_priv_size(ed25519_key* key)
{
    if (key == NULL)
        return BAD_FUNC_ARG;
   0:	2800      	cmp	r0, #0

    return ED25519_PRV_KEY_SIZE;
}
   2:	bf14      	ite	ne
   4:	2040      	movne	r0, #64	; 0x40
   6:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   a:	4770      	bx	lr

Disassembly of section .text.wc_ed25519_pub_size:

00000000 <wc_ed25519_pub_size>:
   0:	2800      	cmp	r0, #0
   2:	bf14      	ite	ne
   4:	2020      	movne	r0, #32
   6:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   a:	4770      	bx	lr

Disassembly of section .text.wc_ed25519_sig_size:

00000000 <wc_ed25519_sig_size>:
   0:	2800      	cmp	r0, #0
   2:	bf14      	ite	ne
   4:	2040      	movne	r0, #64	; 0x40
   6:	f06f 00ac 	mvneq.w	r0, #172	; 0xac
   a:	4770      	bx	lr

ed448.o:     file format elf32-littlearm


error.o:     file format elf32-littlearm


Disassembly of section .text.wc_GetErrorString:

00000000 <wc_GetErrorString>:

#ifndef NO_ERROR_STRINGS
WOLFSSL_ABI
const char* wc_GetErrorString(int error)
{
    switch (error) {
   0:	f200 102b 	addw	r0, r0, #299	; 0x12b
   4:	28c6      	cmp	r0, #198	; 0xc6
   6:	bf9a      	itte	ls
   8:	4b02      	ldrls	r3, [pc, #8]	; (14 <wc_GetErrorString+0x14>)
   a:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
   e:	4802      	ldrhi	r0, [pc, #8]	; (18 <wc_GetErrorString+0x18>)

    default:
        return "unknown error number";

    }
}
  10:	4770      	bx	lr
  12:	bf00      	nop
	...

Disassembly of section .text.wc_ErrorString:

00000000 <wc_ErrorString>:

void wc_ErrorString(int error, char* buffer)
{
   0:	b510      	push	{r4, lr}
    XSTRNCPY(buffer, wc_GetErrorString(error), WOLFSSL_MAX_ERROR_SZ);
   2:	f7ff fffe 	bl	0 <wc_ErrorString>
{
   6:	460c      	mov	r4, r1
    XSTRNCPY(buffer, wc_GetErrorString(error), WOLFSSL_MAX_ERROR_SZ);
   8:	2250      	movs	r2, #80	; 0x50
   a:	4601      	mov	r1, r0
   c:	4620      	mov	r0, r4
   e:	f7ff fffe 	bl	0 <strncpy>
    buffer[WOLFSSL_MAX_ERROR_SZ-1] = 0;
  12:	2300      	movs	r3, #0
  14:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
}
  18:	bd10      	pop	{r4, pc}

fe_448.o:     file format elf32-littlearm


fe_low_mem.o:     file format elf32-littlearm


fe_operations.o:     file format elf32-littlearm


Disassembly of section .text.load_3:

00000000 <load_3>:
word64 load_3(const unsigned char *in)
{
  word64 result;
  result = (word64) in[0];
  result |= ((word64) in[1]) << 8;
  result |= ((word64) in[2]) << 16;
   0:	7883      	ldrb	r3, [r0, #2]
  result |= ((word64) in[1]) << 8;
   2:	7841      	ldrb	r1, [r0, #1]
  result = (word64) in[0];
   4:	7802      	ldrb	r2, [r0, #0]
  result |= ((word64) in[2]) << 16;
   6:	041b      	lsls	r3, r3, #16
   8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  return result;
}
   c:	ea43 0002 	orr.w	r0, r3, r2
  10:	2100      	movs	r1, #0
  12:	4770      	bx	lr

Disassembly of section .text.load_4:

00000000 <load_4>:
  result = (word64) in[0];
  result |= ((word64) in[1]) << 8;
  result |= ((word64) in[2]) << 16;
  result |= ((word64) in[3]) << 24;
  return result;
}
   0:	6800      	ldr	r0, [r0, #0]
   2:	2100      	movs	r1, #0
   4:	4770      	bx	lr

Disassembly of section .text.fe_1:

00000000 <fe_1>:
*/

void fe_1(fe h)
{
  h[0] = 1;
  h[1] = 0;
   0:	2300      	movs	r3, #0
   2:	2201      	movs	r2, #1
   4:	e9c0 2300 	strd	r2, r3, [r0]
  h[2] = 0;
  h[3] = 0;
   8:	e9c0 3302 	strd	r3, r3, [r0, #8]
  h[4] = 0;
  h[5] = 0;
   c:	e9c0 3304 	strd	r3, r3, [r0, #16]
  h[6] = 0;
  h[7] = 0;
  10:	e9c0 3306 	strd	r3, r3, [r0, #24]
  h[8] = 0;
  h[9] = 0;
  14:	e9c0 3308 	strd	r3, r3, [r0, #32]
}
  18:	4770      	bx	lr

Disassembly of section .text.fe_0:

00000000 <fe_0>:
h = 0
*/

void fe_0(fe h)
{
  h[0] = 0;
   0:	2300      	movs	r3, #0
  h[1] = 0;
   2:	e9c0 3300 	strd	r3, r3, [r0]
  h[2] = 0;
  h[3] = 0;
   6:	e9c0 3302 	strd	r3, r3, [r0, #8]
  h[4] = 0;
  h[5] = 0;
   a:	e9c0 3304 	strd	r3, r3, [r0, #16]
  h[6] = 0;
  h[7] = 0;
   e:	e9c0 3306 	strd	r3, r3, [r0, #24]
  h[8] = 0;
  h[9] = 0;
  12:	e9c0 3308 	strd	r3, r3, [r0, #32]
}
  16:	4770      	bx	lr

Disassembly of section .text.fe_init:

00000000 <fe_init>:
     (defined(HAVE_ED25519) && !defined(ED25519_SMALL))) && \
    !defined(FREESCALE_LTC_ECC)
/* to be Complementary to fe_low_mem.c */
void fe_init(void)
{
}
   0:	4770      	bx	lr

Disassembly of section .text.fe_sq:

00000000 <fe_sq>:
/*
See fe_mul.c for discussion of implementation strategy.
*/

void fe_sq(fe h,const fe f)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	460b      	mov	r3, r1
  sword32 f0 = f[0];
  sword32 f1 = f[1];
   6:	e9d1 5200 	ldrd	r5, r2, [r1]
  sword32 f2 = f[2];
  sword32 f3 = f[3];
   a:	e9d1 c102 	ldrd	ip, r1, [r1, #8]
{
   e:	b097      	sub	sp, #92	; 0x5c
  sword32 f5_2 = 2 * f5;
  sword32 f6_2 = 2 * f6;
  sword32 f7_2 = 2 * f7;
  sword32 f5_38 = 38 * f5; /* 1.959375*2^30 */
  sword32 f6_19 = 19 * f6; /* 1.959375*2^30 */
  sword32 f7_38 = 38 * f7; /* 1.959375*2^30 */
  10:	f04f 0926 	mov.w	r9, #38	; 0x26
  sword32 f3 = f[3];
  14:	9107      	str	r1, [sp, #28]
  sword32 f5 = f[5];
  16:	e9d3 e104 	ldrd	lr, r1, [r3, #16]
  1a:	9101      	str	r1, [sp, #4]
  sword32 f7 = f[7];
  1c:	e9d3 4106 	ldrd	r4, r1, [r3, #24]
  20:	9103      	str	r1, [sp, #12]
  sword32 f8 = f[8];
  22:	6a19      	ldr	r1, [r3, #32]
  sword32 f9 = f[9];
  24:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  26:	9308      	str	r3, [sp, #32]
  sword32 f2_2 = 2 * f2;
  28:	ea4f 034c 	mov.w	r3, ip, lsl #1
  2c:	9305      	str	r3, [sp, #20]
  sword32 f3_2 = 2 * f3;
  2e:	9b07      	ldr	r3, [sp, #28]
  sword32 f8 = f[8];
  30:	9104      	str	r1, [sp, #16]
  sword32 f3_2 = 2 * f3;
  32:	ea4f 0b43 	mov.w	fp, r3, lsl #1
  sword32 f4_2 = 2 * f4;
  36:	ea4f 034e 	mov.w	r3, lr, lsl #1
  3a:	930b      	str	r3, [sp, #44]	; 0x2c
  sword32 f5_2 = 2 * f5;
  3c:	9b01      	ldr	r3, [sp, #4]
  sword32 f7_38 = 38 * f7; /* 1.959375*2^30 */
  3e:	9903      	ldr	r1, [sp, #12]
{
  40:	9000      	str	r0, [sp, #0]
  sword32 f5_2 = 2 * f5;
  42:	005b      	lsls	r3, r3, #1
  44:	9302      	str	r3, [sp, #8]
  sword32 f7_2 = 2 * f7;
  46:	9b03      	ldr	r3, [sp, #12]
  sword32 f8_19 = 19 * f8; /* 1.959375*2^30 */
  sword32 f9_38 = 38 * f9; /* 1.959375*2^30 */
  48:	9808      	ldr	r0, [sp, #32]
  sword32 f5_38 = 38 * f5; /* 1.959375*2^30 */
  4a:	9e01      	ldr	r6, [sp, #4]
  sword32 f7_38 = 38 * f7; /* 1.959375*2^30 */
  4c:	fb09 f101 	mul.w	r1, r9, r1
  50:	9106      	str	r1, [sp, #24]
  sword32 f7_2 = 2 * f7;
  52:	005b      	lsls	r3, r3, #1
  sword32 f8_19 = 19 * f8; /* 1.959375*2^30 */
  54:	9904      	ldr	r1, [sp, #16]
  sword32 f7_2 = 2 * f7;
  56:	9309      	str	r3, [sp, #36]	; 0x24
  sword32 f1_2 = 2 * f1;
  58:	ea4f 0842 	mov.w	r8, r2, lsl #1
  sword32 f9_38 = 38 * f9; /* 1.959375*2^30 */
  5c:	fb09 f000 	mul.w	r0, r9, r0
  sword32 f6_19 = 19 * f6; /* 1.959375*2^30 */
  60:	2313      	movs	r3, #19
  sword32 f8_19 = 19 * f8; /* 1.959375*2^30 */
  62:	4359      	muls	r1, r3
  sword32 f6_19 = 19 * f6; /* 1.959375*2^30 */
  64:	fb03 fa04 	mul.w	sl, r3, r4
  sword32 f5_38 = 38 * f5; /* 1.959375*2^30 */
  68:	fb09 f906 	mul.w	r9, r9, r6
  sword64 f1f4_2  = f1_2 * (sword64) f4;
  sword64 f1f5_4  = f1_2 * (sword64) f5_2;
  sword64 f1f6_2  = f1_2 * (sword64) f6;
  sword64 f1f7_4  = f1_2 * (sword64) f7_2;
  sword64 f1f8_2  = f1_2 * (sword64) f8;
  sword64 f1f9_76 = f1_2 * (sword64) f9_38;
  6c:	fb88 3600 	smull	r3, r6, r8, r0
  sword32 f0_2 = 2 * f0;
  70:	006f      	lsls	r7, r5, #1
  sword64 f7f8_38 = f7_2 * (sword64) f8_19;
  sword64 f7f9_76 = f7_2 * (sword64) f9_38;
  sword64 f8f8_19 = f8   * (sword64) f8_19;
  sword64 f8f9_38 = f8   * (sword64) f9_38;
  sword64 f9f9_38 = f9   * (sword64) f9_38;
  sword64 h0 = f0f0  +f1f9_76+f2f8_38+f3f7_76+f4f6_38+f5f5_38;
  72:	fbc5 3605 	smlal	r3, r6, r5, r5
  76:	ea4f 054c 	mov.w	r5, ip, lsl #1
  7a:	fbc5 3601 	smlal	r3, r6, r5, r1
  7e:	9d06      	ldr	r5, [sp, #24]
  80:	fbcb 3605 	smlal	r3, r6, fp, r5
  84:	ea4f 054e 	mov.w	r5, lr, lsl #1
  88:	fbc5 360a 	smlal	r3, r6, r5, sl
  8c:	461d      	mov	r5, r3
  8e:	9b01      	ldr	r3, [sp, #4]
  90:	fbc3 5609 	smlal	r5, r6, r3, r9
  94:	950a      	str	r5, [sp, #40]	; 0x28
  sword64 f2f9_38 = f2   * (sword64) f9_38;
  96:	fb8c 5900 	smull	r5, r9, ip, r0
  sword64 h1 = f0f1_2+f2f9_38+f3f8_38+f4f7_38+f5f6_38;
  9a:	9b06      	ldr	r3, [sp, #24]
  9c:	fbc7 5902 	smlal	r5, r9, r7, r2
  a0:	fbcb 5901 	smlal	r5, r9, fp, r1
  a4:	fbce 5903 	smlal	r5, r9, lr, r3
  a8:	9b02      	ldr	r3, [sp, #8]
  aa:	fbc3 590a 	smlal	r5, r9, r3, sl
  ae:	e9cd 590c 	strd	r5, r9, [sp, #48]	; 0x30
  sword64 f1f1_2  = f1_2 * (sword64) f1;
  b2:	fb82 5308 	smull	r5, r3, r2, r8
  sword64 h2 = f0f2_2+f1f1_2 +f3f9_76+f4f8_38+f5f7_76+f6f6_19;
  b6:	fbc7 530c 	smlal	r5, r3, r7, ip
  ba:	fbcb 5300 	smlal	r5, r3, fp, r0
  be:	ea4f 024e 	mov.w	r2, lr, lsl #1
  c2:	f8dd 9018 	ldr.w	r9, [sp, #24]
  c6:	fbc1 5302 	smlal	r5, r3, r1, r2
  ca:	9a02      	ldr	r2, [sp, #8]
  cc:	fbc2 5309 	smlal	r5, r3, r2, r9
  d0:	461a      	mov	r2, r3
  d2:	fbc4 520a 	smlal	r5, r2, r4, sl
  d6:	e9cd 520e 	strd	r5, r2, [sp, #56]	; 0x38
  sword64 h3 = f0f3_2+f1f2_2 +f4f9_38+f5f8_38+f6f7_38;
  da:	9a07      	ldr	r2, [sp, #28]
  sword64 f1f2_2  = f1_2 * (sword64) f2;
  dc:	fb8c 5308 	smull	r5, r3, ip, r8
  sword64 h3 = f0f3_2+f1f2_2 +f4f9_38+f5f8_38+f6f7_38;
  e0:	fbc7 5302 	smlal	r5, r3, r7, r2
  e4:	9a02      	ldr	r2, [sp, #8]
  e6:	fbce 5300 	smlal	r5, r3, lr, r0
  ea:	fbc2 5301 	smlal	r5, r3, r2, r1
  ee:	461a      	mov	r2, r3
  f0:	fbc4 5209 	smlal	r5, r2, r4, r9
  f4:	e9cd 5210 	strd	r5, r2, [sp, #64]	; 0x40
  sword64 f1f3_4  = f1_2 * (sword64) f3_2;
  f8:	fb88 2a0b 	smull	r2, sl, r8, fp
  sword64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;
  fc:	fbc7 2a0e 	smlal	r2, sl, r7, lr
 100:	fbcc 2a0c 	smlal	r2, sl, ip, ip
 104:	f8dd c008 	ldr.w	ip, [sp, #8]
  sword32 f6_2 = 2 * f6;
 108:	0065      	lsls	r5, r4, #1
  sword64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;
 10a:	fbcc 2a00 	smlal	r2, sl, ip, r0
 10e:	fbc1 2a05 	smlal	r2, sl, r1, r5
 112:	9d03      	ldr	r5, [sp, #12]
  sword64 h5 = f0f5_2+f1f4_2 +f2f3_2 +f6f9_38+f7f8_38;
 114:	f8dd c014 	ldr.w	ip, [sp, #20]
  sword64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;
 118:	fbc5 2a09 	smlal	r2, sl, r5, r9
  sword64 h5 = f0f5_2+f1f4_2 +f2f3_2 +f6f9_38+f7f8_38;
 11c:	9d01      	ldr	r5, [sp, #4]
  sword64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;
 11e:	9206      	str	r2, [sp, #24]
  sword64 f1f4_2  = f1_2 * (sword64) f4;
 120:	fb8e 3208 	smull	r3, r2, lr, r8
  sword64 h5 = f0f5_2+f1f4_2 +f2f3_2 +f6f9_38+f7f8_38;
 124:	fbc7 3205 	smlal	r3, r2, r7, r5
 128:	9d07      	ldr	r5, [sp, #28]
  sword64 h6 = f0f6_2+f1f5_4 +f2f4_2 +f3f3_2 +f7f9_76+f8f8_19;
 12a:	f8dd 9010 	ldr.w	r9, [sp, #16]
  sword64 h5 = f0f5_2+f1f4_2 +f2f3_2 +f6f9_38+f7f8_38;
 12e:	fbc5 320c 	smlal	r3, r2, r5, ip
 132:	fbc4 3200 	smlal	r3, r2, r4, r0
 136:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 13a:	461d      	mov	r5, r3
 13c:	fbcc 5201 	smlal	r5, r2, ip, r1
 140:	9512      	str	r5, [sp, #72]	; 0x48
  sword64 f1f5_4  = f1_2 * (sword64) f5_2;
 142:	9d02      	ldr	r5, [sp, #8]
 144:	fb88 3c05 	smull	r3, ip, r8, r5
  sword64 h6 = f0f6_2+f1f5_4 +f2f4_2 +f3f3_2 +f7f9_76+f8f8_19;
 148:	9d05      	ldr	r5, [sp, #20]
 14a:	fbc7 3c04 	smlal	r3, ip, r7, r4
 14e:	fbce 3c05 	smlal	r3, ip, lr, r5
 152:	9d07      	ldr	r5, [sp, #28]
 154:	fbc5 3c0b 	smlal	r3, ip, r5, fp
 158:	9d09      	ldr	r5, [sp, #36]	; 0x24
 15a:	fbc5 3c00 	smlal	r3, ip, r5, r0
 15e:	461d      	mov	r5, r3
 160:	fbc9 5c01 	smlal	r5, ip, r9, r1
  sword64 h7 = f0f7_2+f1f6_2 +f2f5_2 +f3f4_2 +f8f9_38;
 164:	9903      	ldr	r1, [sp, #12]
  sword64 h6 = f0f6_2+f1f5_4 +f2f4_2 +f3f3_2 +f7f9_76+f8f8_19;
 166:	f8cd c04c 	str.w	ip, [sp, #76]	; 0x4c
  sword64 f1f6_2  = f1_2 * (sword64) f6;
 16a:	fb84 3c08 	smull	r3, ip, r4, r8
  sword64 h6 = f0f6_2+f1f5_4 +f2f4_2 +f3f3_2 +f7f9_76+f8f8_19;
 16e:	9507      	str	r5, [sp, #28]
  sword64 h7 = f0f7_2+f1f6_2 +f2f5_2 +f3f4_2 +f8f9_38;
 170:	fbc7 3c01 	smlal	r3, ip, r7, r1
 174:	9d05      	ldr	r5, [sp, #20]
 176:	9901      	ldr	r1, [sp, #4]
 178:	fbc1 3c05 	smlal	r3, ip, r1, r5
 17c:	fbce 3c0b 	smlal	r3, ip, lr, fp
 180:	4619      	mov	r1, r3
 182:	fbc9 1c00 	smlal	r1, ip, r9, r0
 186:	e9cd 1c14 	strd	r1, ip, [sp, #80]	; 0x50
  sword64 f1f7_4  = f1_2 * (sword64) f7_2;
 18a:	9909      	ldr	r1, [sp, #36]	; 0x24
  sword64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;
 18c:	9d05      	ldr	r5, [sp, #20]
  sword64 carry6;
  sword64 carry7;
  sword64 carry8;
  sword64 carry9;

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 18e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  sword64 f1f7_4  = f1_2 * (sword64) f7_2;
 190:	fb88 1c01 	smull	r1, ip, r8, r1
  sword64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;
 194:	fbc7 1c09 	smlal	r1, ip, r7, r9
 198:	fbc4 1c05 	smlal	r1, ip, r4, r5
 19c:	9d02      	ldr	r5, [sp, #8]
 19e:	fbcb 1c05 	smlal	r1, ip, fp, r5
 1a2:	9d08      	ldr	r5, [sp, #32]
 1a4:	fbce 1c0e 	smlal	r1, ip, lr, lr
 1a8:	fbc5 1c00 	smlal	r1, ip, r5, r0
 1ac:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
  sword64 f1f8_2  = f1_2 * (sword64) f8;
 1b0:	fb89 0c08 	smull	r0, ip, r9, r8
  sword64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;
 1b4:	468e      	mov	lr, r1
  sword64 h9 = f0f9_2+f1f8_2 +f2f7_2 +f3f6_2 +f4f5_2;
 1b6:	fbc7 0c05 	smlal	r0, ip, r7, r5
 1ba:	9903      	ldr	r1, [sp, #12]
 1bc:	9d05      	ldr	r5, [sp, #20]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;

  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 1be:	9f07      	ldr	r7, [sp, #28]
  sword64 h9 = f0f9_2+f1f8_2 +f2f7_2 +f3f6_2 +f4f5_2;
 1c0:	fbc1 0c05 	smlal	r0, ip, r1, r5
 1c4:	fbc4 0c0b 	smlal	r0, ip, r4, fp
 1c8:	9901      	ldr	r1, [sp, #4]
 1ca:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 1cc:	fbc1 0c04 	smlal	r0, ip, r1, r4
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 1d0:	990a      	ldr	r1, [sp, #40]	; 0x28
  sword64 h9 = f0f9_2+f1f8_2 +f2f7_2 +f3f6_2 +f4f5_2;
 1d2:	9008      	str	r0, [sp, #32]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 1d4:	f111 7b00 	adds.w	fp, r1, #33554432	; 0x2000000
 1d8:	f146 0500 	adc.w	r5, r6, #0
 1dc:	990c      	ldr	r1, [sp, #48]	; 0x30
  sword64 h9 = f0f9_2+f1f8_2 +f2f7_2 +f3f6_2 +f4f5_2;
 1de:	f8cd c02c 	str.w	ip, [sp, #44]	; 0x2c
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 1e2:	ea4f 689b 	mov.w	r8, fp, lsr #26
 1e6:	ea48 1885 	orr.w	r8, r8, r5, lsl #6
 1ea:	eb18 0801 	adds.w	r8, r8, r1
 1ee:	990a      	ldr	r1, [sp, #40]	; 0x28
 1f0:	f00b 4b7c 	and.w	fp, fp, #4227858432	; 0xfc000000
 1f4:	eb43 69a5 	adc.w	r9, r3, r5, asr #26
 1f8:	ebb1 0b0b 	subs.w	fp, r1, fp
 1fc:	eb66 0105 	sbc.w	r1, r6, r5
 200:	910a      	str	r1, [sp, #40]	; 0x28
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 202:	9906      	ldr	r1, [sp, #24]
 204:	f111 7400 	adds.w	r4, r1, #33554432	; 0x2000000
 208:	f14a 0300 	adc.w	r3, sl, #0
 20c:	9912      	ldr	r1, [sp, #72]	; 0x48
 20e:	0ea0      	lsrs	r0, r4, #26
 210:	ea40 1083 	orr.w	r0, r0, r3, lsl #6
 214:	1840      	adds	r0, r0, r1
 216:	eb42 6ca3 	adc.w	ip, r2, r3, asr #26
 21a:	9a06      	ldr	r2, [sp, #24]
 21c:	f004 447c 	and.w	r4, r4, #4227858432	; 0xfc000000
 220:	1b14      	subs	r4, r2, r4
 222:	eb6a 0103 	sbc.w	r1, sl, r3
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
 226:	f118 7680 	adds.w	r6, r8, #16777216	; 0x1000000
 22a:	f149 0300 	adc.w	r3, r9, #0
 22e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 230:	0e75      	lsrs	r5, r6, #25
 232:	ea45 15c3 	orr.w	r5, r5, r3, lsl #7
 236:	18aa      	adds	r2, r5, r2
 238:	9203      	str	r2, [sp, #12]
 23a:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 23c:	f006 457e 	and.w	r5, r6, #4261412864	; 0xfe000000
 240:	eb42 6363 	adc.w	r3, r2, r3, asr #25
 244:	ebb8 0205 	subs.w	r2, r8, r5
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 248:	f110 7580 	adds.w	r5, r0, #16777216	; 0x1000000
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
 24c:	920c      	str	r2, [sp, #48]	; 0x30
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 24e:	ea4f 6655 	mov.w	r6, r5, lsr #25
 252:	f14c 0200 	adc.w	r2, ip, #0
 256:	ea46 16c2 	orr.w	r6, r6, r2, lsl #7
 25a:	19f6      	adds	r6, r6, r7
 25c:	9604      	str	r6, [sp, #16]
 25e:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 260:	f005 457e 	and.w	r5, r5, #4261412864	; 0xfe000000
 264:	eb46 6c62 	adc.w	ip, r6, r2, asr #25
 268:	1b42      	subs	r2, r0, r5
 26a:	9207      	str	r2, [sp, #28]

  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 26c:	9a03      	ldr	r2, [sp, #12]
 26e:	9810      	ldr	r0, [sp, #64]	; 0x40
 270:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 274:	9201      	str	r2, [sp, #4]
 276:	f143 0300 	adc.w	r3, r3, #0
 27a:	0e92      	lsrs	r2, r2, #26
 27c:	ea42 1283 	orr.w	r2, r2, r3, lsl #6
 280:	1812      	adds	r2, r2, r0
 282:	9205      	str	r2, [sp, #20]
 284:	9a11      	ldr	r2, [sp, #68]	; 0x44
 286:	eb42 63a3 	adc.w	r3, r2, r3, asr #26
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 28a:	9a04      	ldr	r2, [sp, #16]

  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;

  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 28c:	9d08      	ldr	r5, [sp, #32]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 28e:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 292:	9202      	str	r2, [sp, #8]
 294:	f14c 0c00 	adc.w	ip, ip, #0
 298:	0e90      	lsrs	r0, r2, #26
 29a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 29c:	ea40 108c 	orr.w	r0, r0, ip, lsl #6
 2a0:	1880      	adds	r0, r0, r2
 2a2:	9a15      	ldr	r2, [sp, #84]	; 0x54
 2a4:	eb42 6cac 	adc.w	ip, r2, ip, asr #26
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 2a8:	9a05      	ldr	r2, [sp, #20]
 2aa:	f112 7a80 	adds.w	sl, r2, #16777216	; 0x1000000
 2ae:	f143 0200 	adc.w	r2, r3, #0
 2b2:	ea4f 635a 	mov.w	r3, sl, lsr #25
 2b6:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
 2ba:	191c      	adds	r4, r3, r4
 2bc:	eb41 6362 	adc.w	r3, r1, r2, asr #25
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 2c0:	f110 7980 	adds.w	r9, r0, #16777216	; 0x1000000
 2c4:	f14c 0c00 	adc.w	ip, ip, #0
 2c8:	ea4f 6159 	mov.w	r1, r9, lsr #25
 2cc:	4672      	mov	r2, lr
 2ce:	ea41 11cc 	orr.w	r1, r1, ip, lsl #7
 2d2:	1889      	adds	r1, r1, r2
 2d4:	9a09      	ldr	r2, [sp, #36]	; 0x24
 2d6:	eb42 6c6c 	adc.w	ip, r2, ip, asr #25
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 2da:	f114 7700 	adds.w	r7, r4, #33554432	; 0x2000000
 2de:	f143 0300 	adc.w	r3, r3, #0
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 2e2:	f111 7800 	adds.w	r8, r1, #33554432	; 0x2000000
 2e6:	f14c 0c00 	adc.w	ip, ip, #0
 2ea:	ea4f 6298 	mov.w	r2, r8, lsr #26
 2ee:	ea42 128c 	orr.w	r2, r2, ip, lsl #6
 2f2:	1952      	adds	r2, r2, r5
 2f4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 2f6:	9306      	str	r3, [sp, #24]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 2f8:	eb45 6cac 	adc.w	ip, r5, ip, asr #26

  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 2fc:	f112 7e80 	adds.w	lr, r2, #16777216	; 0x1000000
 300:	f14c 0c00 	adc.w	ip, ip, #0
 304:	ea4f 655e 	mov.w	r5, lr, lsr #25
 308:	2313      	movs	r3, #19
 30a:	ea45 15cc 	orr.w	r5, r5, ip, lsl #7
 30e:	fba5 6503 	umull	r6, r5, r5, r3
 312:	ea4f 6c6c 	mov.w	ip, ip, asr #25
 316:	fb03 550c 	mla	r5, r3, ip, r5
 31a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 31c:	eb16 060b 	adds.w	r6, r6, fp
 320:	eb45 0503 	adc.w	r5, r5, r3

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 324:	f116 7c00 	adds.w	ip, r6, #33554432	; 0x2000000

  h[0] = (sword32)h0;
 328:	9b00      	ldr	r3, [sp, #0]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 32a:	f00c 4b7c 	and.w	fp, ip, #4227858432	; 0xfc000000
 32e:	f145 0500 	adc.w	r5, r5, #0
 332:	ebb6 060b 	subs.w	r6, r6, fp
  h[0] = (sword32)h0;
 336:	601e      	str	r6, [r3, #0]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 338:	ea4f 6c9c 	mov.w	ip, ip, lsr #26
 33c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 33e:	ea4c 1c85 	orr.w	ip, ip, r5, lsl #6
 342:	eb1c 0503 	adds.w	r5, ip, r3
  h[1] = (sword32)h1;
 346:	9b00      	ldr	r3, [sp, #0]
 348:	605d      	str	r5, [r3, #4]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 34a:	9b01      	ldr	r3, [sp, #4]
 34c:	f003 457c 	and.w	r5, r3, #4227858432	; 0xfc000000
 350:	9b03      	ldr	r3, [sp, #12]
 352:	1b5d      	subs	r5, r3, r5
  h[2] = (sword32)h2;
 354:	9b00      	ldr	r3, [sp, #0]
 356:	609d      	str	r5, [r3, #8]
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 358:	9b05      	ldr	r3, [sp, #20]
 35a:	f00a 4a7e 	and.w	sl, sl, #4261412864	; 0xfe000000
 35e:	ebb3 050a 	subs.w	r5, r3, sl
  h[3] = (sword32)h3;
 362:	9b00      	ldr	r3, [sp, #0]
 364:	60dd      	str	r5, [r3, #12]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 366:	f007 457c 	and.w	r5, r7, #4227858432	; 0xfc000000
 36a:	1b64      	subs	r4, r4, r5
  h[4] = (sword32)h4;
 36c:	611c      	str	r4, [r3, #16]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 36e:	9b06      	ldr	r3, [sp, #24]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 370:	9c04      	ldr	r4, [sp, #16]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 372:	0ebf      	lsrs	r7, r7, #26
 374:	ea47 1783 	orr.w	r7, r7, r3, lsl #6
 378:	9b07      	ldr	r3, [sp, #28]
 37a:	18ff      	adds	r7, r7, r3
  h[5] = (sword32)h5;
 37c:	9b00      	ldr	r3, [sp, #0]
 37e:	615f      	str	r7, [r3, #20]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 380:	9b02      	ldr	r3, [sp, #8]
 382:	f003 437c 	and.w	r3, r3, #4227858432	; 0xfc000000
 386:	1ae3      	subs	r3, r4, r3
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 388:	f009 497e 	and.w	r9, r9, #4261412864	; 0xfe000000
  h[6] = (sword32)h6;
 38c:	9c00      	ldr	r4, [sp, #0]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 38e:	f008 487c 	and.w	r8, r8, #4227858432	; 0xfc000000
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 392:	f00e 4e7e 	and.w	lr, lr, #4261412864	; 0xfe000000
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 396:	ebb0 0009 	subs.w	r0, r0, r9
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 39a:	ebb1 0108 	subs.w	r1, r1, r8
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 39e:	ebb2 020e 	subs.w	r2, r2, lr
  h[6] = (sword32)h6;
 3a2:	61a3      	str	r3, [r4, #24]
  h[7] = (sword32)h7;
 3a4:	61e0      	str	r0, [r4, #28]
  h[8] = (sword32)h8;
 3a6:	6221      	str	r1, [r4, #32]
  h[9] = (sword32)h9;
 3a8:	6262      	str	r2, [r4, #36]	; 0x24
}
 3aa:	b017      	add	sp, #92	; 0x5c
 3ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.fe_add:

00000000 <fe_add>:
Postconditions:
   |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
*/

void fe_add(fe h,const fe f,const fe g)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  sword32 g6 = g[6];
  sword32 g7 = g[7];
  sword32 g8 = g[8];
  sword32 g9 = g[9];
  sword32 h0 = f0 + g0;
  sword32 h1 = f1 + g1;
   4:	6853      	ldr	r3, [r2, #4]
   6:	684e      	ldr	r6, [r1, #4]
  sword32 h2 = f2 + g2;
   8:	688d      	ldr	r5, [r1, #8]
  sword32 h3 = f3 + g3;
   a:	68cc      	ldr	r4, [r1, #12]
  sword32 h4 = f4 + g4;
   c:	690f      	ldr	r7, [r1, #16]
  sword32 h5 = f5 + g5;
  sword32 h6 = f6 + g6;
  sword32 h7 = f7 + g7;
  sword32 h8 = f8 + g8;
  sword32 h9 = f9 + g9;
   e:	f8d1 a024 	ldr.w	sl, [r1, #36]	; 0x24
  sword32 h1 = f1 + g1;
  12:	441e      	add	r6, r3
  sword32 h2 = f2 + g2;
  14:	6893      	ldr	r3, [r2, #8]
  16:	441d      	add	r5, r3
  sword32 h3 = f3 + g3;
  18:	68d3      	ldr	r3, [r2, #12]
  1a:	441c      	add	r4, r3
  sword32 h4 = f4 + g4;
  1c:	6913      	ldr	r3, [r2, #16]
  1e:	eb07 0c03 	add.w	ip, r7, r3
  sword32 h5 = f5 + g5;
  22:	694f      	ldr	r7, [r1, #20]
  24:	6953      	ldr	r3, [r2, #20]
  26:	eb07 0e03 	add.w	lr, r7, r3
  sword32 h6 = f6 + g6;
  2a:	698f      	ldr	r7, [r1, #24]
  2c:	6993      	ldr	r3, [r2, #24]
  2e:	eb07 0803 	add.w	r8, r7, r3
  sword32 h7 = f7 + g7;
  32:	69cf      	ldr	r7, [r1, #28]
  34:	69d3      	ldr	r3, [r2, #28]
  36:	eb07 0903 	add.w	r9, r7, r3
  sword32 h8 = f8 + g8;
  3a:	6a13      	ldr	r3, [r2, #32]
  3c:	6a0f      	ldr	r7, [r1, #32]
  sword32 h0 = f0 + g0;
  3e:	6809      	ldr	r1, [r1, #0]
  sword32 h8 = f8 + g8;
  40:	441f      	add	r7, r3
  sword32 h9 = f9 + g9;
  42:	6a53      	ldr	r3, [r2, #36]	; 0x24
  sword32 h0 = f0 + g0;
  44:	6812      	ldr	r2, [r2, #0]
  sword32 h9 = f9 + g9;
  46:	4453      	add	r3, sl
  sword32 h0 = f0 + g0;
  48:	440a      	add	r2, r1
  h[0] = h0;
  h[1] = h1;
  4a:	e9c0 2600 	strd	r2, r6, [r0]
  h[2] = h2;
  h[3] = h3;
  4e:	e9c0 5402 	strd	r5, r4, [r0, #8]
  h[4] = h4;
  h[5] = h5;
  52:	e9c0 ce04 	strd	ip, lr, [r0, #16]
  h[6] = h6;
  h[7] = h7;
  56:	e9c0 8906 	strd	r8, r9, [r0, #24]
  h[8] = h8;
  h[9] = h9;
  5a:	e9c0 7308 	strd	r7, r3, [r0, #32]
}
  5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

Disassembly of section .text.fe_tobytes:

00000000 <fe_tobytes>:
  Have q+2^(-255)x = 2^(-255)(h + 19 2^(-25) h9 + 2^(-1))
  so floor(2^(-255)(h + 19 2^(-25) h9 + 2^(-1))) = q.
*/

void fe_tobytes(unsigned char *s,const fe h)
{
   0:	460b      	mov	r3, r1
   2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  sword32 h4 = h[4];
  sword32 h5 = h[5];
  sword32 h6 = h[6];
  sword32 h7 = h[7];
  sword32 h8 = h[8];
  sword32 h9 = h[9];
   6:	e9d3 9208 	ldrd	r9, r2, [r3, #32]
  sword32 h1 = h[1];
   a:	e9d1 8e00 	ldrd	r8, lr, [r1]
  sword32 carry6;
  sword32 carry7;
  sword32 carry8;
  sword32 carry9;

  q = (19 * h9 + (((sword32) 1) << 24)) >> 25;
   e:	f04f 0a13 	mov.w	sl, #19
  sword32 h5 = h[5];
  12:	e9d3 7604 	ldrd	r7, r6, [r3, #16]
  sword32 h7 = h[7];
  16:	e9d3 5406 	ldrd	r5, r4, [r3, #24]
  q = (19 * h9 + (((sword32) 1) << 24)) >> 25;
  1a:	fb0a f302 	mul.w	r3, sl, r2
  sword32 h3 = h[3];
  1e:	e9d1 c102 	ldrd	ip, r1, [r1, #8]
  q = (19 * h9 + (((sword32) 1) << 24)) >> 25;
  22:	f103 7380 	add.w	r3, r3, #16777216	; 0x1000000
  q = (h0 + q) >> 26;
  26:	eb08 6363 	add.w	r3, r8, r3, asr #25
  q = (h1 + q) >> 25;
  2a:	eb0e 63a3 	add.w	r3, lr, r3, asr #26
  q = (h2 + q) >> 26;
  2e:	eb0c 6363 	add.w	r3, ip, r3, asr #25
  q = (h3 + q) >> 25;
  32:	eb01 63a3 	add.w	r3, r1, r3, asr #26
  q = (h4 + q) >> 26;
  36:	eb07 6363 	add.w	r3, r7, r3, asr #25
  q = (h5 + q) >> 25;
  3a:	eb06 63a3 	add.w	r3, r6, r3, asr #26
  q = (h6 + q) >> 26;
  3e:	eb05 6363 	add.w	r3, r5, r3, asr #25
  q = (h7 + q) >> 25;
  42:	eb04 63a3 	add.w	r3, r4, r3, asr #26
  q = (h8 + q) >> 26;
  46:	eb09 6363 	add.w	r3, r9, r3, asr #25
  q = (h9 + q) >> 25;
  4a:	eb02 63a3 	add.w	r3, r2, r3, asr #26
  4e:	165b      	asrs	r3, r3, #25

  /* Goal: Output h-(2^255-19)q, which is between 0 and 2^255-20. */
  h0 += 19 * q;
  50:	fb0a 8803 	mla	r8, sl, r3, r8
  /* Goal: Output h-2^255 q, which is between 0 and 2^255-20. */

  carry0 = h0 >> 26; h1 += carry0; h0 -= carry0 << 26;
  54:	eb0e 6ea8 	add.w	lr, lr, r8, asr #26
  58:	f028 487c 	bic.w	r8, r8, #4227858432	; 0xfc000000
  evidently 2^255 h10-2^255 q = 0.
  Goal: Output h0+...+2^230 h9.
  */

  s[0] = (byte)(h0 >> 0);
  s[1] = (byte)(h0 >> 8);
  5c:	ea4f 2328 	mov.w	r3, r8, asr #8
  carry1 = h1 >> 25; h2 += carry1; h1 -= carry1 << 25;
  60:	eb0c 6c6e 	add.w	ip, ip, lr, asr #25
  s[1] = (byte)(h0 >> 8);
  64:	7043      	strb	r3, [r0, #1]
  66:	f02e 4e7e 	bic.w	lr, lr, #4261412864	; 0xfe000000
  s[2] = (byte)(h0 >> 16);
  6a:	ea4f 4328 	mov.w	r3, r8, asr #16
  6e:	7083      	strb	r3, [r0, #2]
  s[3] = (byte)((h0 >> 24) | (h1 << 2));
  70:	ea4f 038e 	mov.w	r3, lr, lsl #2
  s[0] = (byte)(h0 >> 0);
  74:	f880 8000 	strb.w	r8, [r0]
  s[3] = (byte)((h0 >> 24) | (h1 << 2));
  78:	ea43 6818 	orr.w	r8, r3, r8, lsr #24
  s[4] = (byte)(h1 >> 6);
  7c:	ea4f 13ae 	mov.w	r3, lr, asr #6
  carry2 = h2 >> 26; h3 += carry2; h2 -= carry2 << 26;
  80:	eb01 61ac 	add.w	r1, r1, ip, asr #26
  s[4] = (byte)(h1 >> 6);
  84:	7103      	strb	r3, [r0, #4]
  86:	f02c 4c7c 	bic.w	ip, ip, #4227858432	; 0xfc000000
  s[5] = (byte)(h1 >> 14);
  8a:	ea4f 33ae 	mov.w	r3, lr, asr #14
  8e:	7143      	strb	r3, [r0, #5]
  s[6] = (byte)((h1 >> 22) | (h2 << 3));
  90:	ea4f 03cc 	mov.w	r3, ip, lsl #3
  94:	ea43 5e9e 	orr.w	lr, r3, lr, lsr #22
  s[7] = (byte)(h2 >> 5);
  98:	ea4f 136c 	mov.w	r3, ip, asr #5
  carry3 = h3 >> 25; h4 += carry3; h3 -= carry3 << 25;
  9c:	eb07 6761 	add.w	r7, r7, r1, asr #25
  s[7] = (byte)(h2 >> 5);
  a0:	71c3      	strb	r3, [r0, #7]
  a2:	f021 417e 	bic.w	r1, r1, #4261412864	; 0xfe000000
  s[8] = (byte)(h2 >> 13);
  a6:	ea4f 336c 	mov.w	r3, ip, asr #13
  aa:	7203      	strb	r3, [r0, #8]
  s[9] = (byte)((h2 >> 21) | (h3 << 5));
  ac:	014b      	lsls	r3, r1, #5
  ae:	ea43 5c5c 	orr.w	ip, r3, ip, lsr #21
  s[10] = (byte)(h3 >> 3);
  b2:	10cb      	asrs	r3, r1, #3
  b4:	7283      	strb	r3, [r0, #10]
  s[11] = (byte)(h3 >> 11);
  b6:	12cb      	asrs	r3, r1, #11
  b8:	72c3      	strb	r3, [r0, #11]
  s[12] = (byte)((h3 >> 19) | (h4 << 6));
  ba:	01bb      	lsls	r3, r7, #6
  carry4 = h4 >> 26; h5 += carry4; h4 -= carry4 << 26;
  bc:	eb06 66a7 	add.w	r6, r6, r7, asr #26
  s[12] = (byte)((h3 >> 19) | (h4 << 6));
  c0:	ea43 41d1 	orr.w	r1, r3, r1, lsr #19
  s[13] = (byte)(h4 >> 2);
  c4:	f3c7 0397 	ubfx	r3, r7, #2, #24
  carry5 = h5 >> 25; h6 += carry5; h5 -= carry5 << 25;
  c8:	eb05 6566 	add.w	r5, r5, r6, asr #25
  s[13] = (byte)(h4 >> 2);
  cc:	7343      	strb	r3, [r0, #13]
  ce:	f026 467e 	bic.w	r6, r6, #4261412864	; 0xfe000000
  s[14] = (byte)(h4 >> 10);
  d2:	f3c7 238f 	ubfx	r3, r7, #10, #16
  d6:	7383      	strb	r3, [r0, #14]
  s[15] = (byte)(h4 >> 18);
  s[16] = (byte)(h5 >> 0);
  s[17] = (byte)(h5 >> 8);
  d8:	1233      	asrs	r3, r6, #8
  carry6 = h6 >> 26; h7 += carry6; h6 -= carry6 << 26;
  da:	eb04 64a5 	add.w	r4, r4, r5, asr #26
  s[17] = (byte)(h5 >> 8);
  de:	7443      	strb	r3, [r0, #17]
  e0:	f025 457c 	bic.w	r5, r5, #4227858432	; 0xfc000000
  s[18] = (byte)(h5 >> 16);
  e4:	1433      	asrs	r3, r6, #16
  e6:	7483      	strb	r3, [r0, #18]
  s[19] = (byte)((h5 >> 24) | (h6 << 1));
  e8:	006b      	lsls	r3, r5, #1
  s[16] = (byte)(h5 >> 0);
  ea:	7406      	strb	r6, [r0, #16]
  s[19] = (byte)((h5 >> 24) | (h6 << 1));
  ec:	ea43 6616 	orr.w	r6, r3, r6, lsr #24
  s[20] = (byte)(h6 >> 7);
  f0:	11eb      	asrs	r3, r5, #7
  carry7 = h7 >> 25; h8 += carry7; h7 -= carry7 << 25;
  f2:	eb09 6964 	add.w	r9, r9, r4, asr #25
  s[20] = (byte)(h6 >> 7);
  f6:	7503      	strb	r3, [r0, #20]
  f8:	f024 447e 	bic.w	r4, r4, #4261412864	; 0xfe000000
  s[21] = (byte)(h6 >> 15);
  fc:	13eb      	asrs	r3, r5, #15
  s[15] = (byte)(h4 >> 18);
  fe:	f3c7 4787 	ubfx	r7, r7, #18, #8
  s[3] = (byte)((h0 >> 24) | (h1 << 2));
 102:	f880 8003 	strb.w	r8, [r0, #3]
  s[6] = (byte)((h1 >> 22) | (h2 << 3));
 106:	f880 e006 	strb.w	lr, [r0, #6]
  s[9] = (byte)((h2 >> 21) | (h3 << 5));
 10a:	f880 c009 	strb.w	ip, [r0, #9]
  s[12] = (byte)((h3 >> 19) | (h4 << 6));
 10e:	7301      	strb	r1, [r0, #12]
  s[15] = (byte)(h4 >> 18);
 110:	73c7      	strb	r7, [r0, #15]
  s[19] = (byte)((h5 >> 24) | (h6 << 1));
 112:	74c6      	strb	r6, [r0, #19]
  s[21] = (byte)(h6 >> 15);
 114:	7543      	strb	r3, [r0, #21]
  s[22] = (byte)((h6 >> 23) | (h7 << 3));
 116:	00e3      	lsls	r3, r4, #3
 118:	ea43 55d5 	orr.w	r5, r3, r5, lsr #23
  s[23] = (byte)(h7 >> 5);
 11c:	1163      	asrs	r3, r4, #5
 11e:	f029 4b7c 	bic.w	fp, r9, #4227858432	; 0xfc000000
 122:	75c3      	strb	r3, [r0, #23]
  s[24] = (byte)(h7 >> 13);
 124:	1363      	asrs	r3, r4, #13
 126:	7603      	strb	r3, [r0, #24]
  s[25] = (byte)((h7 >> 21) | (h8 << 4));
 128:	ea4f 130b 	mov.w	r3, fp, lsl #4
 12c:	ea43 5454 	orr.w	r4, r3, r4, lsr #21
  carry8 = h8 >> 26; h9 += carry8; h8 -= carry8 << 26;
 130:	eb02 62a9 	add.w	r2, r2, r9, asr #26
  s[26] = (byte)(h8 >> 4);
 134:	ea4f 132b 	mov.w	r3, fp, asr #4
 138:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
 13c:	7683      	strb	r3, [r0, #26]
  s[27] = (byte)(h8 >> 12);
 13e:	ea4f 332b 	mov.w	r3, fp, asr #12
 142:	76c3      	strb	r3, [r0, #27]
  s[28] = (byte)((h8 >> 20) | (h9 << 6));
 144:	0193      	lsls	r3, r2, #6
 146:	ea43 5b1b 	orr.w	fp, r3, fp, lsr #20
  s[29] = (byte)(h9 >> 2);
 14a:	1093      	asrs	r3, r2, #2
 14c:	7743      	strb	r3, [r0, #29]
  s[30] = (byte)(h9 >> 10);
 14e:	1293      	asrs	r3, r2, #10
  s[31] = (byte)(h9 >> 18);
 150:	1492      	asrs	r2, r2, #18
  s[22] = (byte)((h6 >> 23) | (h7 << 3));
 152:	7585      	strb	r5, [r0, #22]
  s[25] = (byte)((h7 >> 21) | (h8 << 4));
 154:	7644      	strb	r4, [r0, #25]
  s[28] = (byte)((h8 >> 20) | (h9 << 6));
 156:	f880 b01c 	strb.w	fp, [r0, #28]
  s[30] = (byte)(h9 >> 10);
 15a:	7783      	strb	r3, [r0, #30]
  s[31] = (byte)(h9 >> 18);
 15c:	77c2      	strb	r2, [r0, #31]
}
 15e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.fe_sub:

00000000 <fe_sub>:
Postconditions:
   |h| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
*/

void fe_sub(fe h,const fe f,const fe g)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  sword32 g6 = g[6];
  sword32 g7 = g[7];
  sword32 g8 = g[8];
  sword32 g9 = g[9];
  sword32 h0 = f0 - g0;
  sword32 h1 = f1 - g1;
   4:	6853      	ldr	r3, [r2, #4]
   6:	684e      	ldr	r6, [r1, #4]
  sword32 h2 = f2 - g2;
   8:	688d      	ldr	r5, [r1, #8]
  sword32 h3 = f3 - g3;
   a:	68cc      	ldr	r4, [r1, #12]
  sword32 h4 = f4 - g4;
   c:	690f      	ldr	r7, [r1, #16]
  sword32 h1 = f1 - g1;
   e:	1af6      	subs	r6, r6, r3
  sword32 h2 = f2 - g2;
  10:	6893      	ldr	r3, [r2, #8]
  12:	1aed      	subs	r5, r5, r3
  sword32 h3 = f3 - g3;
  14:	68d3      	ldr	r3, [r2, #12]
  16:	eba4 0a03 	sub.w	sl, r4, r3
  sword32 h4 = f4 - g4;
  1a:	6913      	ldr	r3, [r2, #16]
  sword32 h5 = f5 - g5;
  sword32 h6 = f6 - g6;
  sword32 h7 = f7 - g7;
  sword32 h8 = f8 - g8;
  sword32 h9 = f9 - g9;
  1c:	6a4c      	ldr	r4, [r1, #36]	; 0x24
  sword32 h4 = f4 - g4;
  1e:	eba7 0c03 	sub.w	ip, r7, r3
  sword32 h5 = f5 - g5;
  22:	694f      	ldr	r7, [r1, #20]
  24:	6953      	ldr	r3, [r2, #20]
  26:	eba7 0e03 	sub.w	lr, r7, r3
  sword32 h6 = f6 - g6;
  2a:	698f      	ldr	r7, [r1, #24]
  2c:	6993      	ldr	r3, [r2, #24]
  2e:	eba7 0803 	sub.w	r8, r7, r3
  sword32 h7 = f7 - g7;
  32:	69cf      	ldr	r7, [r1, #28]
  34:	69d3      	ldr	r3, [r2, #28]
  36:	eba7 0903 	sub.w	r9, r7, r3
  sword32 h8 = f8 - g8;
  3a:	6a13      	ldr	r3, [r2, #32]
  3c:	6a0f      	ldr	r7, [r1, #32]
  sword32 h0 = f0 - g0;
  3e:	6809      	ldr	r1, [r1, #0]
  sword32 h8 = f8 - g8;
  40:	1aff      	subs	r7, r7, r3
  sword32 h9 = f9 - g9;
  42:	6a53      	ldr	r3, [r2, #36]	; 0x24
  sword32 h0 = f0 - g0;
  44:	6812      	ldr	r2, [r2, #0]
  sword32 h9 = f9 - g9;
  46:	1ae3      	subs	r3, r4, r3
  sword32 h0 = f0 - g0;
  48:	1a8a      	subs	r2, r1, r2
  h[0] = h0;
  h[1] = h1;
  4a:	e9c0 2600 	strd	r2, r6, [r0]
  h[2] = h2;
  h[3] = h3;
  4e:	e9c0 5a02 	strd	r5, sl, [r0, #8]
  h[4] = h4;
  h[5] = h5;
  52:	e9c0 ce04 	strd	ip, lr, [r0, #16]
  h[6] = h6;
  h[7] = h7;
  56:	e9c0 8906 	strd	r8, r9, [r0, #24]
  h[8] = h8;
  h[9] = h9;
  5a:	e9c0 7308 	strd	r7, r3, [r0, #32]
}
  5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

Disassembly of section .text.fe_frombytes:

00000000 <fe_frombytes>:
/*
Ignores top bit of h.
*/

void fe_frombytes(fe h,const unsigned char *s)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4604      	mov	r4, r0
   6:	b08d      	sub	sp, #52	; 0x34
  sword64 h0 = load_4(s);
   8:	4608      	mov	r0, r1
{
   a:	460e      	mov	r6, r1
  sword64 h0 = load_4(s);
   c:	f7ff fffe 	bl	0 <fe_frombytes>
  10:	9004      	str	r0, [sp, #16]
  sword64 h1 = load_3(s + 4) << 6;
  12:	1d30      	adds	r0, r6, #4
  sword64 h0 = load_4(s);
  14:	9109      	str	r1, [sp, #36]	; 0x24
  sword64 h1 = load_3(s + 4) << 6;
  16:	f7ff fffe 	bl	0 <fe_frombytes>
  1a:	018b      	lsls	r3, r1, #6
  1c:	ea43 6390 	orr.w	r3, r3, r0, lsr #26
  20:	930a      	str	r3, [sp, #40]	; 0x28
  22:	0183      	lsls	r3, r0, #6
  sword64 h2 = load_3(s + 7) << 5;
  24:	1df0      	adds	r0, r6, #7
  sword64 h1 = load_3(s + 4) << 6;
  26:	9301      	str	r3, [sp, #4]
  sword64 h2 = load_3(s + 7) << 5;
  28:	f7ff fffe 	bl	0 <fe_frombytes>
  2c:	ea4f 1a41 	mov.w	sl, r1, lsl #5
  30:	0143      	lsls	r3, r0, #5
  32:	ea4a 6ad0 	orr.w	sl, sl, r0, lsr #27
  sword64 h3 = load_3(s + 10) << 3;
  36:	f106 000a 	add.w	r0, r6, #10
  sword64 h2 = load_3(s + 7) << 5;
  3a:	9305      	str	r3, [sp, #20]
  sword64 h3 = load_3(s + 10) << 3;
  3c:	f7ff fffe 	bl	0 <fe_frombytes>
  40:	ea4f 09c1 	mov.w	r9, r1, lsl #3
  44:	ea49 7950 	orr.w	r9, r9, r0, lsr #29
  48:	ea4f 0bc0 	mov.w	fp, r0, lsl #3
  sword64 h4 = load_3(s + 13) << 2;
  4c:	f106 000d 	add.w	r0, r6, #13
  50:	f7ff fffe 	bl	0 <fe_frombytes>
  54:	ea4f 0881 	mov.w	r8, r1, lsl #2
  58:	0083      	lsls	r3, r0, #2
  5a:	ea48 7890 	orr.w	r8, r8, r0, lsr #30
  sword64 h5 = load_4(s + 16);
  5e:	f106 0010 	add.w	r0, r6, #16
  sword64 h4 = load_3(s + 13) << 2;
  62:	9306      	str	r3, [sp, #24]
  sword64 h5 = load_4(s + 16);
  64:	f7ff fffe 	bl	0 <fe_frombytes>
  68:	9002      	str	r0, [sp, #8]
  sword64 h6 = load_3(s + 20) << 7;
  6a:	f106 0014 	add.w	r0, r6, #20
  sword64 h5 = load_4(s + 16);
  6e:	910b      	str	r1, [sp, #44]	; 0x2c
  sword64 h6 = load_3(s + 20) << 7;
  70:	f7ff fffe 	bl	0 <fe_frombytes>
  74:	01cb      	lsls	r3, r1, #7
  76:	ea43 6350 	orr.w	r3, r3, r0, lsr #25
  7a:	9300      	str	r3, [sp, #0]
  7c:	01c3      	lsls	r3, r0, #7
  sword64 h7 = load_3(s + 23) << 5;
  7e:	f106 0017 	add.w	r0, r6, #23
  sword64 h6 = load_3(s + 20) << 7;
  82:	9307      	str	r3, [sp, #28]
  sword64 h7 = load_3(s + 23) << 5;
  84:	f7ff fffe 	bl	0 <fe_frombytes>
  88:	014f      	lsls	r7, r1, #5
  8a:	0143      	lsls	r3, r0, #5
  8c:	ea47 67d0 	orr.w	r7, r7, r0, lsr #27
  sword64 h8 = load_3(s + 26) << 4;
  90:	f106 001a 	add.w	r0, r6, #26
  sword64 h7 = load_3(s + 23) << 5;
  94:	9303      	str	r3, [sp, #12]
  sword64 h8 = load_3(s + 26) << 4;
  96:	f7ff fffe 	bl	0 <fe_frombytes>
  9a:	010d      	lsls	r5, r1, #4
  9c:	0103      	lsls	r3, r0, #4
  9e:	ea45 7510 	orr.w	r5, r5, r0, lsr #28
  sword64 h9 = (load_3(s + 29) & 8388607) << 2;
  a2:	f106 001d 	add.w	r0, r6, #29
  sword64 h8 = load_3(s + 26) << 4;
  a6:	9308      	str	r3, [sp, #32]
  sword64 h9 = (load_3(s + 29) & 8388607) << 2;
  a8:	f7ff fffe 	bl	0 <fe_frombytes>
  ac:	0080      	lsls	r0, r0, #2
  ae:	f020 407e 	bic.w	r0, r0, #4261412864	; 0xfe000000
  b2:	f020 0003 	bic.w	r0, r0, #3
  sword64 carry6;
  sword64 carry7;
  sword64 carry8;
  sword64 carry9;

  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
  b6:	f100 7280 	add.w	r2, r0, #16777216	; 0x1000000
  ba:	9b04      	ldr	r3, [sp, #16]
  bc:	0e51      	lsrs	r1, r2, #25
  be:	2613      	movs	r6, #19
  c0:	fba1 1606 	umull	r1, r6, r1, r6
  c4:	18cb      	adds	r3, r1, r3
  c6:	9304      	str	r3, [sp, #16]
  c8:	9b09      	ldr	r3, [sp, #36]	; 0x24
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
  ca:	9908      	ldr	r1, [sp, #32]
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
  cc:	f002 427e 	and.w	r2, r2, #4261412864	; 0xfe000000
  d0:	f143 0600 	adc.w	r6, r3, #0
  d4:	1a83      	subs	r3, r0, r2
  d6:	9309      	str	r3, [sp, #36]	; 0x24
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
  d8:	9b01      	ldr	r3, [sp, #4]
  da:	f113 7280 	adds.w	r2, r3, #16777216	; 0x1000000
  de:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  e0:	ea4f 6052 	mov.w	r0, r2, lsr #25
  e4:	f143 0e00 	adc.w	lr, r3, #0
  e8:	9b05      	ldr	r3, [sp, #20]
  ea:	ea40 10ce 	orr.w	r0, r0, lr, lsl #7
  ee:	18c3      	adds	r3, r0, r3
  f0:	9305      	str	r3, [sp, #20]
  f2:	9b01      	ldr	r3, [sp, #4]
  f4:	f002 427e 	and.w	r2, r2, #4261412864	; 0xfe000000
  f8:	eb4a 6e6e 	adc.w	lr, sl, lr, asr #25
  fc:	1a9b      	subs	r3, r3, r2
  fe:	930a      	str	r3, [sp, #40]	; 0x28
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 100:	f11b 7380 	adds.w	r3, fp, #16777216	; 0x1000000
 104:	9a06      	ldr	r2, [sp, #24]
 106:	f149 0c00 	adc.w	ip, r9, #0
 10a:	0e58      	lsrs	r0, r3, #25
 10c:	ea40 10cc 	orr.w	r0, r0, ip, lsl #7
 110:	1882      	adds	r2, r0, r2
 112:	f003 437e 	and.w	r3, r3, #4261412864	; 0xfe000000
 116:	eb48 6c6c 	adc.w	ip, r8, ip, asr #25
 11a:	ebbb 0b03 	subs.w	fp, fp, r3
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 11e:	9b02      	ldr	r3, [sp, #8]
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 120:	9201      	str	r2, [sp, #4]
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 122:	f113 7080 	adds.w	r0, r3, #16777216	; 0x1000000
 126:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 128:	ea4f 6250 	mov.w	r2, r0, lsr #25
 12c:	f143 0900 	adc.w	r9, r3, #0
 130:	9b07      	ldr	r3, [sp, #28]
 132:	ea42 12c9 	orr.w	r2, r2, r9, lsl #7
 136:	18d2      	adds	r2, r2, r3
 138:	9b00      	ldr	r3, [sp, #0]
 13a:	eb43 6969 	adc.w	r9, r3, r9, asr #25
 13e:	9b02      	ldr	r3, [sp, #8]
 140:	f000 407e 	and.w	r0, r0, #4261412864	; 0xfe000000
 144:	1a1b      	subs	r3, r3, r0
 146:	9306      	str	r3, [sp, #24]
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 148:	9b03      	ldr	r3, [sp, #12]
 14a:	f113 7080 	adds.w	r0, r3, #16777216	; 0x1000000
 14e:	f147 0800 	adc.w	r8, r7, #0
 152:	0e43      	lsrs	r3, r0, #25
 154:	ea43 13c8 	orr.w	r3, r3, r8, lsl #7
 158:	185b      	adds	r3, r3, r1
 15a:	9300      	str	r3, [sp, #0]
 15c:	9b03      	ldr	r3, [sp, #12]
 15e:	f000 407e 	and.w	r0, r0, #4261412864	; 0xfe000000
 162:	eb45 6868 	adc.w	r8, r5, r8, asr #25
 166:	1a1b      	subs	r3, r3, r0
 168:	9303      	str	r3, [sp, #12]

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 16a:	9b04      	ldr	r3, [sp, #16]
 16c:	f113 7700 	adds.w	r7, r3, #33554432	; 0x2000000
 170:	f146 0300 	adc.w	r3, r6, #0
 174:	9302      	str	r3, [sp, #8]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 176:	9b05      	ldr	r3, [sp, #20]
 178:	f113 7600 	adds.w	r6, r3, #33554432	; 0x2000000
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 17c:	9b01      	ldr	r3, [sp, #4]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 17e:	f14e 0e00 	adc.w	lr, lr, #0
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 182:	f113 7000 	adds.w	r0, r3, #33554432	; 0x2000000
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 186:	9b00      	ldr	r3, [sp, #0]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 188:	f14c 0c00 	adc.w	ip, ip, #0
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 18c:	f112 7500 	adds.w	r5, r2, #33554432	; 0x2000000
 190:	f149 0900 	adc.w	r9, r9, #0
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 194:	f113 7100 	adds.w	r1, r3, #33554432	; 0x2000000
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 198:	9b04      	ldr	r3, [sp, #16]
 19a:	f007 4a7c 	and.w	sl, r7, #4227858432	; 0xfc000000
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 19e:	f148 0800 	adc.w	r8, r8, #0
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 1a2:	ebb3 0a0a 	subs.w	sl, r3, sl
 1a6:	9b02      	ldr	r3, [sp, #8]

  h[0] = (sword32)h0;
 1a8:	f8c4 a000 	str.w	sl, [r4]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 1ac:	0ebf      	lsrs	r7, r7, #26
 1ae:	ea47 1783 	orr.w	r7, r7, r3, lsl #6
 1b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 1b4:	18ff      	adds	r7, r7, r3
  h[1] = (sword32)h1;
 1b6:	6067      	str	r7, [r4, #4]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 1b8:	9b05      	ldr	r3, [sp, #20]
 1ba:	f006 477c 	and.w	r7, r6, #4227858432	; 0xfc000000
 1be:	0eb6      	lsrs	r6, r6, #26
 1c0:	ea46 168e 	orr.w	r6, r6, lr, lsl #6
 1c4:	1bdf      	subs	r7, r3, r7
 1c6:	eb16 060b 	adds.w	r6, r6, fp
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 1ca:	9b01      	ldr	r3, [sp, #4]
  h[2] = (sword32)h2;
  h[3] = (sword32)h3;
 1cc:	60e6      	str	r6, [r4, #12]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 1ce:	f000 467c 	and.w	r6, r0, #4227858432	; 0xfc000000
 1d2:	1b9e      	subs	r6, r3, r6
 1d4:	0e80      	lsrs	r0, r0, #26
 1d6:	9b06      	ldr	r3, [sp, #24]
  h[2] = (sword32)h2;
 1d8:	60a7      	str	r7, [r4, #8]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 1da:	ea40 108c 	orr.w	r0, r0, ip, lsl #6
 1de:	18c0      	adds	r0, r0, r3
  h[4] = (sword32)h4;
  h[5] = (sword32)h5;
 1e0:	6160      	str	r0, [r4, #20]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 1e2:	9b03      	ldr	r3, [sp, #12]
  h[4] = (sword32)h4;
 1e4:	6126      	str	r6, [r4, #16]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 1e6:	f005 407c 	and.w	r0, r5, #4227858432	; 0xfc000000
 1ea:	0ead      	lsrs	r5, r5, #26
 1ec:	ea45 1589 	orr.w	r5, r5, r9, lsl #6
 1f0:	1a12      	subs	r2, r2, r0
 1f2:	18ed      	adds	r5, r5, r3
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 1f4:	9b00      	ldr	r3, [sp, #0]
  h[6] = (sword32)h6;
 1f6:	61a2      	str	r2, [r4, #24]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 1f8:	f001 427c 	and.w	r2, r1, #4227858432	; 0xfc000000
 1fc:	1a9b      	subs	r3, r3, r2
  h[7] = (sword32)h7;
  h[8] = (sword32)h8;
 1fe:	6223      	str	r3, [r4, #32]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 200:	0e89      	lsrs	r1, r1, #26
 202:	9b09      	ldr	r3, [sp, #36]	; 0x24
  h[7] = (sword32)h7;
 204:	61e5      	str	r5, [r4, #28]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 206:	ea41 1188 	orr.w	r1, r1, r8, lsl #6
 20a:	18c9      	adds	r1, r1, r3
  h[9] = (sword32)h9;
 20c:	6261      	str	r1, [r4, #36]	; 0x24
}
 20e:	b00d      	add	sp, #52	; 0x34
 210:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.fe_copy:

00000000 <fe_copy>:
/*
h = f
*/

void fe_copy(fe h,const fe f)
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  sword32 f0 = f[0];
  sword32 f1 = f[1];
   4:	e9d1 9800 	ldrd	r9, r8, [r1]
  sword32 f2 = f[2];
  sword32 f3 = f[3];
   8:	e9d1 e302 	ldrd	lr, r3, [r1, #8]
  sword32 f4 = f[4];
  sword32 f5 = f[5];
   c:	e9d1 7604 	ldrd	r7, r6, [r1, #16]
  sword32 f6 = f[6];
  sword32 f7 = f[7];
  10:	e9d1 5406 	ldrd	r5, r4, [r1, #24]
  sword32 f8 = f[8];
  sword32 f9 = f[9];
  14:	e9d1 2108 	ldrd	r2, r1, [r1, #32]
  h[0] = f0;
  h[1] = f1;
  18:	e9c0 9800 	strd	r9, r8, [r0]
  h[2] = f2;
  h[3] = f3;
  1c:	e9c0 e302 	strd	lr, r3, [r0, #8]
  h[4] = f4;
  h[5] = f5;
  20:	e9c0 7604 	strd	r7, r6, [r0, #16]
  h[6] = f6;
  h[7] = f7;
  24:	e9c0 5406 	strd	r5, r4, [r0, #24]
  h[8] = f8;
  h[9] = f9;
  28:	e9c0 2108 	strd	r2, r1, [r0, #32]
}
  2c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.fe_mul:

00000000 <fe_mul>:

With tighter constraints on inputs can squeeze carries into int32.
*/

void fe_mul(fe h,const fe f,const fe g)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b0a5      	sub	sp, #148	; 0x94
  sword32 f0 = f[0];
   6:	680b      	ldr	r3, [r1, #0]
   8:	9301      	str	r3, [sp, #4]
  sword32 f1 = f[1];
   a:	684b      	ldr	r3, [r1, #4]
   c:	9308      	str	r3, [sp, #32]
  sword32 f2 = f[2];
  sword32 f3 = f[3];
   e:	e9d1 9302 	ldrd	r9, r3, [r1, #8]
  12:	9309      	str	r3, [sp, #36]	; 0x24
  sword32 f4 = f[4];
  sword32 f5 = f[5];
  14:	e9d1 7304 	ldrd	r7, r3, [r1, #16]
  18:	930a      	str	r3, [sp, #40]	; 0x28
  sword32 f6 = f[6];
  sword32 f7 = f[7];
  1a:	e9d1 a306 	ldrd	sl, r3, [r1, #24]
  1e:	930b      	str	r3, [sp, #44]	; 0x2c
  sword32 f8 = f[8];
  sword32 f9 = f[9];
  20:	e9d1 8308 	ldrd	r8, r3, [r1, #32]
  24:	930c      	str	r3, [sp, #48]	; 0x30
  sword32 g0 = g[0];
  sword32 g1 = g[1];
  sword32 g2 = g[2];
  26:	6893      	ldr	r3, [r2, #8]
  28:	9302      	str	r3, [sp, #8]
  sword32 g3 = g[3];
  2a:	68d3      	ldr	r3, [r2, #12]
  2c:	9304      	str	r3, [sp, #16]
  sword32 g4 = g[4];
  2e:	6913      	ldr	r3, [r2, #16]
  30:	9306      	str	r3, [sp, #24]
  sword32 g5 = g[5];
  32:	6953      	ldr	r3, [r2, #20]
  34:	930d      	str	r3, [sp, #52]	; 0x34
  sword32 g6 = g[6];
  36:	6993      	ldr	r3, [r2, #24]
  38:	930f      	str	r3, [sp, #60]	; 0x3c
  sword32 g7 = g[7];
  3a:	69d3      	ldr	r3, [r2, #28]
  3c:	9316      	str	r3, [sp, #88]	; 0x58
  sword32 g8 = g[8];
  3e:	6a13      	ldr	r3, [r2, #32]
  sword32 g1 = g[1];
  40:	e9d2 1400 	ldrd	r1, r4, [r2]
  sword32 g8 = g[8];
  44:	9317      	str	r3, [sp, #92]	; 0x5c
  sword32 g9 = g[9];
  46:	6a53      	ldr	r3, [r2, #36]	; 0x24
  sword32 g1_19 = 19 * g1; /* 1.959375*2^29 */
  sword32 g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
  sword32 g3_19 = 19 * g3;
  sword32 g4_19 = 19 * g4;
  sword32 g5_19 = 19 * g5;
  48:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  sword32 g9 = g[9];
  4a:	9319      	str	r3, [sp, #100]	; 0x64
  sword32 g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
  4c:	f04f 0b13 	mov.w	fp, #19
  sword32 g5_19 = 19 * g5;
  50:	fb0b f202 	mul.w	r2, fp, r2
  54:	9210      	str	r2, [sp, #64]	; 0x40
  sword32 g6_19 = 19 * g6;
  56:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  sword32 g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
  58:	9b02      	ldr	r3, [sp, #8]
  sword64 f9g5_38 = f9_2 * (sword64) g5_19;
  sword64 f9g6_19 = f9   * (sword64) g6_19;
  sword64 f9g7_38 = f9_2 * (sword64) g7_19;
  sword64 f9g8_19 = f9   * (sword64) g8_19;
  sword64 f9g9_38 = f9_2 * (sword64) g9_19;
  sword64 h0 = f0g0+f1g9_38+f2g8_19+f3g7_38+f4g6_19+f5g5_38+f6g4_19+f7g3_38+f8g2_19+f9g1_38;
  5a:	f8dd c004 	ldr.w	ip, [sp, #4]
  sword32 g6_19 = 19 * g6;
  5e:	fb0b f202 	mul.w	r2, fp, r2
  62:	920e      	str	r2, [sp, #56]	; 0x38
  sword32 g7_19 = 19 * g7;
  64:	9a16      	ldr	r2, [sp, #88]	; 0x58
  66:	fb0b f202 	mul.w	r2, fp, r2
  6a:	9207      	str	r2, [sp, #28]
  sword32 g8_19 = 19 * g8;
  6c:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  6e:	fb0b f202 	mul.w	r2, fp, r2
  72:	9205      	str	r2, [sp, #20]
  sword32 g9_19 = 19 * g9;
  74:	9a19      	ldr	r2, [sp, #100]	; 0x64
  76:	fb0b f202 	mul.w	r2, fp, r2
  7a:	9203      	str	r2, [sp, #12]
  sword32 f1_2 = 2 * f1;
  7c:	9a08      	ldr	r2, [sp, #32]
  7e:	0052      	lsls	r2, r2, #1
  80:	9211      	str	r2, [sp, #68]	; 0x44
  sword32 f3_2 = 2 * f3;
  82:	9a09      	ldr	r2, [sp, #36]	; 0x24
  sword64 f1g9_38 = f1_2 * (sword64) g9_19;
  84:	9d11      	ldr	r5, [sp, #68]	; 0x44
  sword32 f3_2 = 2 * f3;
  86:	0052      	lsls	r2, r2, #1
  88:	9212      	str	r2, [sp, #72]	; 0x48
  sword32 f5_2 = 2 * f5;
  8a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  8c:	0052      	lsls	r2, r2, #1
  8e:	9213      	str	r2, [sp, #76]	; 0x4c
  sword32 f7_2 = 2 * f7;
  90:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
{
  92:	4686      	mov	lr, r0
  sword64 f1g9_38 = f1_2 * (sword64) g9_19;
  94:	9803      	ldr	r0, [sp, #12]
  sword32 g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
  96:	fb0b f303 	mul.w	r3, fp, r3
  sword32 f7_2 = 2 * f7;
  9a:	0052      	lsls	r2, r2, #1
  sword32 g2_19 = 19 * g2; /* 1.959375*2^30; still ok */
  9c:	931a      	str	r3, [sp, #104]	; 0x68
  sword32 f7_2 = 2 * f7;
  9e:	9214      	str	r2, [sp, #80]	; 0x50
  sword32 g3_19 = 19 * g3;
  a0:	9b04      	ldr	r3, [sp, #16]
  sword32 f9_2 = 2 * f9;
  a2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  sword64 f1g9_38 = f1_2 * (sword64) g9_19;
  a4:	fb85 6500 	smull	r6, r5, r5, r0
  sword64 h0 = f0g0+f1g9_38+f2g8_19+f3g7_38+f4g6_19+f5g5_38+f6g4_19+f7g3_38+f8g2_19+f9g1_38;
  a8:	fbcc 6501 	smlal	r6, r5, ip, r1
  ac:	f8dd c014 	ldr.w	ip, [sp, #20]
  sword32 g3_19 = 19 * g3;
  b0:	fb0b f303 	mul.w	r3, fp, r3
  sword32 f9_2 = 2 * f9;
  b4:	0052      	lsls	r2, r2, #1
  sword32 g3_19 = 19 * g3;
  b6:	9318      	str	r3, [sp, #96]	; 0x60
  sword32 f9_2 = 2 * f9;
  b8:	9215      	str	r2, [sp, #84]	; 0x54
  sword32 g4_19 = 19 * g4;
  ba:	9b06      	ldr	r3, [sp, #24]
  sword64 h0 = f0g0+f1g9_38+f2g8_19+f3g7_38+f4g6_19+f5g5_38+f6g4_19+f7g3_38+f8g2_19+f9g1_38;
  bc:	fbc9 650c 	smlal	r6, r5, r9, ip
  c0:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
  c4:	9807      	ldr	r0, [sp, #28]
  c6:	fbcc 6500 	smlal	r6, r5, ip, r0
  ca:	980e      	ldr	r0, [sp, #56]	; 0x38
  cc:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
  d0:	fbc7 6500 	smlal	r6, r5, r7, r0
  d4:	9813      	ldr	r0, [sp, #76]	; 0x4c
  sword32 g4_19 = 19 * g4;
  d6:	fb0b f303 	mul.w	r3, fp, r3
  sword64 h0 = f0g0+f1g9_38+f2g8_19+f3g7_38+f4g6_19+f5g5_38+f6g4_19+f7g3_38+f8g2_19+f9g1_38;
  da:	fbc0 650c 	smlal	r6, r5, r0, ip
  de:	9814      	ldr	r0, [sp, #80]	; 0x50
  e0:	f8dd c060 	ldr.w	ip, [sp, #96]	; 0x60
  e4:	fbca 6503 	smlal	r6, r5, sl, r3
  e8:	fbc0 650c 	smlal	r6, r5, r0, ip
  ec:	981a      	ldr	r0, [sp, #104]	; 0x68
  ee:	fbc8 6500 	smlal	r6, r5, r8, r0
  f2:	9815      	ldr	r0, [sp, #84]	; 0x54
  sword32 g1_19 = 19 * g1; /* 1.959375*2^29 */
  f4:	fb0b f204 	mul.w	r2, fp, r4
  sword64 h0 = f0g0+f1g9_38+f2g8_19+f3g7_38+f4g6_19+f5g5_38+f6g4_19+f7g3_38+f8g2_19+f9g1_38;
  f8:	fbc0 6502 	smlal	r6, r5, r0, r2
  sword64 f1g0    = f1   * (sword64) g0;
  fc:	9a08      	ldr	r2, [sp, #32]
  sword64 h1 = f0g1+f1g0   +f2g9_19+f3g8_19+f4g7_19+f5g6_19+f6g5_19+f7g4_19+f8g3_19+f9g2_19;
  fe:	9801      	ldr	r0, [sp, #4]
  sword64 h0 = f0g0+f1g9_38+f2g8_19+f3g7_38+f4g6_19+f5g5_38+f6g4_19+f7g3_38+f8g2_19+f9g1_38;
 100:	961b      	str	r6, [sp, #108]	; 0x6c
  sword64 f1g0    = f1   * (sword64) g0;
 102:	fb81 c202 	smull	ip, r2, r1, r2
  sword64 h1 = f0g1+f1g0   +f2g9_19+f3g8_19+f4g7_19+f5g6_19+f6g5_19+f7g4_19+f8g3_19+f9g2_19;
 106:	fbc0 c204 	smlal	ip, r2, r0, r4
 10a:	9803      	ldr	r0, [sp, #12]
 10c:	9e09      	ldr	r6, [sp, #36]	; 0x24
 10e:	fbc0 c209 	smlal	ip, r2, r0, r9
 112:	9805      	ldr	r0, [sp, #20]
 114:	fbc0 c206 	smlal	ip, r2, r0, r6
 118:	9807      	ldr	r0, [sp, #28]
 11a:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 11c:	fbc0 c207 	smlal	ip, r2, r0, r7
 120:	980e      	ldr	r0, [sp, #56]	; 0x38
 122:	fbc0 c206 	smlal	ip, r2, r0, r6
 126:	9810      	ldr	r0, [sp, #64]	; 0x40
 128:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 12a:	fbc0 c20a 	smlal	ip, r2, r0, sl
 12e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 130:	fbc3 c200 	smlal	ip, r2, r3, r0
 134:	9818      	ldr	r0, [sp, #96]	; 0x60
 136:	fbc0 c208 	smlal	ip, r2, r0, r8
 13a:	981a      	ldr	r0, [sp, #104]	; 0x68
 13c:	fbc0 c206 	smlal	ip, r2, r0, r6
 140:	921c      	str	r2, [sp, #112]	; 0x70
 142:	f8cd c068 	str.w	ip, [sp, #104]	; 0x68
  sword64 f1g1_2  = f1_2 * (sword64) g1;
 146:	9a11      	ldr	r2, [sp, #68]	; 0x44
  sword64 h2 = f0g2+f1g1_2 +f2g0   +f3g9_38+f4g8_19+f5g7_38+f6g6_19+f7g5_38+f8g4_19+f9g3_38;
 148:	e9dd 0c01 	ldrd	r0, ip, [sp, #4]
  sword64 f1g1_2  = f1_2 * (sword64) g1;
 14c:	fb84 6202 	smull	r6, r2, r4, r2
  sword64 h2 = f0g2+f1g1_2 +f2g0   +f3g9_38+f4g8_19+f5g7_38+f6g6_19+f7g5_38+f8g4_19+f9g3_38;
 150:	fbc0 620c 	smlal	r6, r2, r0, ip
 154:	9812      	ldr	r0, [sp, #72]	; 0x48
 156:	f8dd c00c 	ldr.w	ip, [sp, #12]
 15a:	fbc1 6209 	smlal	r6, r2, r1, r9
 15e:	fbcc 6200 	smlal	r6, r2, ip, r0
 162:	9805      	ldr	r0, [sp, #20]
 164:	f8dd c04c 	ldr.w	ip, [sp, #76]	; 0x4c
 168:	fbc0 6207 	smlal	r6, r2, r0, r7
 16c:	9807      	ldr	r0, [sp, #28]
 16e:	fbc0 620c 	smlal	r6, r2, r0, ip
 172:	980e      	ldr	r0, [sp, #56]	; 0x38
 174:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
 178:	fbc0 620a 	smlal	r6, r2, r0, sl
 17c:	9810      	ldr	r0, [sp, #64]	; 0x40
 17e:	fbc0 620c 	smlal	r6, r2, r0, ip
 182:	9818      	ldr	r0, [sp, #96]	; 0x60
 184:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
 188:	fbc3 6208 	smlal	r6, r2, r3, r8
 18c:	fbc0 620c 	smlal	r6, r2, r0, ip
 190:	921d      	str	r2, [sp, #116]	; 0x74
  sword64 f1g2    = f1   * (sword64) g2;
 192:	9808      	ldr	r0, [sp, #32]
 194:	9a02      	ldr	r2, [sp, #8]
  sword64 h3 = f0g3+f1g2   +f2g1   +f3g0   +f4g9_19+f5g8_19+f6g7_19+f7g6_19+f8g5_19+f9g4_19;
 196:	f8dd c010 	ldr.w	ip, [sp, #16]
  sword64 h2 = f0g2+f1g1_2 +f2g0   +f3g9_38+f4g8_19+f5g7_38+f6g6_19+f7g5_38+f8g4_19+f9g3_38;
 19a:	9618      	str	r6, [sp, #96]	; 0x60
  sword64 f1g2    = f1   * (sword64) g2;
 19c:	fb82 6200 	smull	r6, r2, r2, r0
  sword64 h3 = f0g3+f1g2   +f2g1   +f3g0   +f4g9_19+f5g8_19+f6g7_19+f7g6_19+f8g5_19+f9g4_19;
 1a0:	9801      	ldr	r0, [sp, #4]
 1a2:	fbc0 620c 	smlal	r6, r2, r0, ip
 1a6:	9809      	ldr	r0, [sp, #36]	; 0x24
 1a8:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 1ac:	fbc4 6209 	smlal	r6, r2, r4, r9
 1b0:	fbc1 6200 	smlal	r6, r2, r1, r0
 1b4:	9803      	ldr	r0, [sp, #12]
 1b6:	fbc0 6207 	smlal	r6, r2, r0, r7
 1ba:	9805      	ldr	r0, [sp, #20]
 1bc:	fbc0 620c 	smlal	r6, r2, r0, ip
 1c0:	9807      	ldr	r0, [sp, #28]
 1c2:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 1c6:	fbc0 620a 	smlal	r6, r2, r0, sl
 1ca:	980e      	ldr	r0, [sp, #56]	; 0x38
 1cc:	fbc0 620c 	smlal	r6, r2, r0, ip
 1d0:	9810      	ldr	r0, [sp, #64]	; 0x40
  sword64 h4 = f0g4+f1g3_2 +f2g2   +f3g1_2 +f4g0   +f5g9_38+f6g8_19+f7g7_38+f8g6_19+f9g5_38;
 1d2:	f8dd c018 	ldr.w	ip, [sp, #24]
  sword64 h3 = f0g3+f1g2   +f2g1   +f3g0   +f4g9_19+f5g8_19+f6g7_19+f7g6_19+f8g5_19+f9g4_19;
 1d6:	fbc0 6208 	smlal	r6, r2, r0, r8
 1da:	980c      	ldr	r0, [sp, #48]	; 0x30
 1dc:	fbc3 6200 	smlal	r6, r2, r3, r0
 1e0:	e9cd 621e 	strd	r6, r2, [sp, #120]	; 0x78
  sword64 f1g3_2  = f1_2 * (sword64) g3;
 1e4:	9b04      	ldr	r3, [sp, #16]
 1e6:	9a11      	ldr	r2, [sp, #68]	; 0x44
  sword64 h4 = f0g4+f1g3_2 +f2g2   +f3g1_2 +f4g0   +f5g9_38+f6g8_19+f7g7_38+f8g6_19+f9g5_38;
 1e8:	9801      	ldr	r0, [sp, #4]
 1ea:	9e03      	ldr	r6, [sp, #12]
  sword64 f1g3_2  = f1_2 * (sword64) g3;
 1ec:	fb83 2302 	smull	r2, r3, r3, r2
  sword64 h4 = f0g4+f1g3_2 +f2g2   +f3g1_2 +f4g0   +f5g9_38+f6g8_19+f7g7_38+f8g6_19+f9g5_38;
 1f0:	fbc0 230c 	smlal	r2, r3, r0, ip
 1f4:	9802      	ldr	r0, [sp, #8]
 1f6:	fbc0 2309 	smlal	r2, r3, r0, r9
 1fa:	9812      	ldr	r0, [sp, #72]	; 0x48
 1fc:	fbc4 2300 	smlal	r2, r3, r4, r0
 200:	9813      	ldr	r0, [sp, #76]	; 0x4c
 202:	fbc1 2307 	smlal	r2, r3, r1, r7
 206:	fbc6 2300 	smlal	r2, r3, r6, r0
 20a:	9805      	ldr	r0, [sp, #20]
 20c:	fbc0 230a 	smlal	r2, r3, r0, sl
 210:	9807      	ldr	r0, [sp, #28]
 212:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
  sword64 h5 = f0g5+f1g4   +f2g3   +f3g2   +f4g1   +f5g0   +f6g9_19+f7g8_19+f8g7_19+f9g6_19;
 216:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  sword64 h4 = f0g4+f1g3_2 +f2g2   +f3g1_2 +f4g0   +f5g9_38+f6g8_19+f7g7_38+f8g6_19+f9g5_38;
 218:	fbc0 230c 	smlal	r2, r3, r0, ip
 21c:	980e      	ldr	r0, [sp, #56]	; 0x38
 21e:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
 222:	fbc0 2308 	smlal	r2, r3, r0, r8
 226:	9810      	ldr	r0, [sp, #64]	; 0x40
 228:	fbc0 230c 	smlal	r2, r3, r0, ip
 22c:	9210      	str	r2, [sp, #64]	; 0x40
  sword64 f1g4    = f1   * (sword64) g4;
 22e:	9808      	ldr	r0, [sp, #32]
 230:	9a06      	ldr	r2, [sp, #24]
 232:	fb82 2c00 	smull	r2, ip, r2, r0
  sword64 h5 = f0g5+f1g4   +f2g3   +f3g2   +f4g1   +f5g0   +f6g9_19+f7g8_19+f8g7_19+f9g6_19;
 236:	9801      	ldr	r0, [sp, #4]
 238:	fbc0 2c06 	smlal	r2, ip, r0, r6
 23c:	9804      	ldr	r0, [sp, #16]
 23e:	9e09      	ldr	r6, [sp, #36]	; 0x24
 240:	fbc0 2c09 	smlal	r2, ip, r0, r9
 244:	9802      	ldr	r0, [sp, #8]
 246:	fbc0 2c06 	smlal	r2, ip, r0, r6
 24a:	980a      	ldr	r0, [sp, #40]	; 0x28
 24c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 24e:	fbc4 2c07 	smlal	r2, ip, r4, r7
 252:	fbc1 2c00 	smlal	r2, ip, r1, r0
 256:	9803      	ldr	r0, [sp, #12]
 258:	fbc0 2c0a 	smlal	r2, ip, r0, sl
 25c:	9805      	ldr	r0, [sp, #20]
 25e:	fbc0 2c06 	smlal	r2, ip, r0, r6
 262:	9807      	ldr	r0, [sp, #28]
 264:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 266:	fbc0 2c08 	smlal	r2, ip, r0, r8
 26a:	980e      	ldr	r0, [sp, #56]	; 0x38
 26c:	fbc0 2c06 	smlal	r2, ip, r0, r6
 270:	920e      	str	r2, [sp, #56]	; 0x38
  sword64 f1g5_2  = f1_2 * (sword64) g5;
 272:	9811      	ldr	r0, [sp, #68]	; 0x44
 274:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  sword64 h6 = f0g6+f1g5_2 +f2g4   +f3g3_2 +f4g2   +f5g1_2 +f6g0   +f7g9_38+f8g8_19+f9g7_38;
 276:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
  sword64 h5 = f0g5+f1g4   +f2g3   +f3g2   +f4g1   +f5g0   +f6g9_19+f7g8_19+f8g7_19+f9g6_19;
 278:	f8cd c080 	str.w	ip, [sp, #128]	; 0x80
  sword64 f1g5_2  = f1_2 * (sword64) g5;
 27c:	fb82 2c00 	smull	r2, ip, r2, r0
  sword64 h6 = f0g6+f1g5_2 +f2g4   +f3g3_2 +f4g2   +f5g1_2 +f6g0   +f7g9_38+f8g8_19+f9g7_38;
 280:	9801      	ldr	r0, [sp, #4]
 282:	fbc0 2c06 	smlal	r2, ip, r0, r6
 286:	9806      	ldr	r0, [sp, #24]
 288:	9e12      	ldr	r6, [sp, #72]	; 0x48
 28a:	fbc0 2c09 	smlal	r2, ip, r0, r9
 28e:	9804      	ldr	r0, [sp, #16]
 290:	fbc0 2c06 	smlal	r2, ip, r0, r6
 294:	9802      	ldr	r0, [sp, #8]
 296:	9e03      	ldr	r6, [sp, #12]
 298:	fbc0 2c07 	smlal	r2, ip, r0, r7
 29c:	9813      	ldr	r0, [sp, #76]	; 0x4c
 29e:	fbc4 2c00 	smlal	r2, ip, r4, r0
 2a2:	9814      	ldr	r0, [sp, #80]	; 0x50
 2a4:	fbc1 2c0a 	smlal	r2, ip, r1, sl
 2a8:	fbc6 2c00 	smlal	r2, ip, r6, r0
 2ac:	9805      	ldr	r0, [sp, #20]
 2ae:	9e15      	ldr	r6, [sp, #84]	; 0x54
 2b0:	fbc0 2c08 	smlal	r2, ip, r0, r8
 2b4:	9807      	ldr	r0, [sp, #28]
 2b6:	fbc0 2c06 	smlal	r2, ip, r0, r6
 2ba:	9207      	str	r2, [sp, #28]
  sword64 f1g6    = f1   * (sword64) g6;
 2bc:	9808      	ldr	r0, [sp, #32]
 2be:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  sword64 h7 = f0g7+f1g6   +f2g5   +f3g4   +f4g3   +f5g2   +f6g1   +f7g0   +f8g9_19+f9g8_19;
 2c0:	9e16      	ldr	r6, [sp, #88]	; 0x58
  sword64 h6 = f0g6+f1g5_2 +f2g4   +f3g3_2 +f4g2   +f5g1_2 +f6g0   +f7g9_38+f8g8_19+f9g7_38;
 2c2:	f8cd c084 	str.w	ip, [sp, #132]	; 0x84
  sword64 f1g6    = f1   * (sword64) g6;
 2c6:	fb82 2c00 	smull	r2, ip, r2, r0
  sword64 h7 = f0g7+f1g6   +f2g5   +f3g4   +f4g3   +f5g2   +f6g1   +f7g0   +f8g9_19+f9g8_19;
 2ca:	9801      	ldr	r0, [sp, #4]
 2cc:	fbc0 2c06 	smlal	r2, ip, r0, r6
 2d0:	980d      	ldr	r0, [sp, #52]	; 0x34
 2d2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 2d4:	fbc0 2c09 	smlal	r2, ip, r0, r9
 2d8:	9806      	ldr	r0, [sp, #24]
 2da:	fbc0 2c06 	smlal	r2, ip, r0, r6
 2de:	9804      	ldr	r0, [sp, #16]
 2e0:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 2e2:	fbc0 2c07 	smlal	r2, ip, r0, r7
 2e6:	9802      	ldr	r0, [sp, #8]
 2e8:	fbc0 2c06 	smlal	r2, ip, r0, r6
 2ec:	980b      	ldr	r0, [sp, #44]	; 0x2c
 2ee:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 2f0:	fbc4 2c0a 	smlal	r2, ip, r4, sl
 2f4:	fbc1 2c00 	smlal	r2, ip, r1, r0
 2f8:	9803      	ldr	r0, [sp, #12]
 2fa:	fbc0 2c08 	smlal	r2, ip, r0, r8
 2fe:	9805      	ldr	r0, [sp, #20]
 300:	fbc0 2c06 	smlal	r2, ip, r0, r6
 304:	e9cd 2c22 	strd	r2, ip, [sp, #136]	; 0x88
  sword64 f1g7_2  = f1_2 * (sword64) g7;
 308:	9811      	ldr	r0, [sp, #68]	; 0x44
 30a:	9a16      	ldr	r2, [sp, #88]	; 0x58
  sword64 h8 = f0g8+f1g7_2 +f2g6   +f3g5_2 +f4g4   +f5g3_2 +f6g2   +f7g1_2 +f8g0   +f9g9_38;
 30c:	9e17      	ldr	r6, [sp, #92]	; 0x5c
  sword64 f1g7_2  = f1_2 * (sword64) g7;
 30e:	fb82 2c00 	smull	r2, ip, r2, r0
  sword64 h8 = f0g8+f1g7_2 +f2g6   +f3g5_2 +f4g4   +f5g3_2 +f6g2   +f7g1_2 +f8g0   +f9g9_38;
 312:	9801      	ldr	r0, [sp, #4]
 314:	fbc0 2c06 	smlal	r2, ip, r0, r6
 318:	980f      	ldr	r0, [sp, #60]	; 0x3c
 31a:	9e12      	ldr	r6, [sp, #72]	; 0x48
 31c:	fbc0 2c09 	smlal	r2, ip, r0, r9
 320:	980d      	ldr	r0, [sp, #52]	; 0x34
 322:	fbc0 2c06 	smlal	r2, ip, r0, r6
 326:	9806      	ldr	r0, [sp, #24]
 328:	9e13      	ldr	r6, [sp, #76]	; 0x4c
 32a:	fbc0 2c07 	smlal	r2, ip, r0, r7
 32e:	9804      	ldr	r0, [sp, #16]
 330:	fbc0 2c06 	smlal	r2, ip, r0, r6
 334:	9802      	ldr	r0, [sp, #8]
 336:	fbc0 2c0a 	smlal	r2, ip, r0, sl
 33a:	9814      	ldr	r0, [sp, #80]	; 0x50
 33c:	9e03      	ldr	r6, [sp, #12]
 33e:	fbc4 2c00 	smlal	r2, ip, r4, r0
 342:	9815      	ldr	r0, [sp, #84]	; 0x54
 344:	fbc1 2c08 	smlal	r2, ip, r1, r8
 348:	fbc6 2c00 	smlal	r2, ip, r6, r0
 34c:	9203      	str	r2, [sp, #12]
  sword64 f1g8    = f1   * (sword64) g8;
 34e:	9808      	ldr	r0, [sp, #32]
 350:	9a17      	ldr	r2, [sp, #92]	; 0x5c
  sword64 h9 = f0g9+f1g8   +f2g7   +f3g6   +f4g5   +f5g4   +f6g3   +f7g2   +f8g1   +f9g0   ;
 352:	9e01      	ldr	r6, [sp, #4]
  sword64 h8 = f0g8+f1g7_2 +f2g6   +f3g5_2 +f4g4   +f5g3_2 +f6g2   +f7g1_2 +f8g0   +f9g9_38;
 354:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
  sword64 h9 = f0g9+f1g8   +f2g7   +f3g6   +f4g5   +f5g4   +f6g3   +f7g2   +f8g1   +f9g0   ;
 358:	f8dd c064 	ldr.w	ip, [sp, #100]	; 0x64
  sword64 f1g8    = f1   * (sword64) g8;
 35c:	fb82 2000 	smull	r2, r0, r2, r0
  sword64 h9 = f0g9+f1g8   +f2g7   +f3g6   +f4g5   +f5g4   +f6g3   +f7g2   +f8g1   +f9g0   ;
 360:	fbc6 200c 	smlal	r2, r0, r6, ip
 364:	9e16      	ldr	r6, [sp, #88]	; 0x58
 366:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 36a:	fbc6 2009 	smlal	r2, r0, r6, r9
 36e:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 370:	fbc6 200c 	smlal	r2, r0, r6, ip
 374:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 376:	fbc6 2007 	smlal	r2, r0, r6, r7
 37a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 37c:	9e06      	ldr	r6, [sp, #24]
 37e:	fbc6 2007 	smlal	r2, r0, r6, r7
 382:	9e04      	ldr	r6, [sp, #16]
 384:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 386:	fbc6 200a 	smlal	r2, r0, r6, sl
 38a:	9e02      	ldr	r6, [sp, #8]
 38c:	fbc6 2007 	smlal	r2, r0, r6, r7
 390:	fbc4 2008 	smlal	r2, r0, r4, r8
 394:	4684      	mov	ip, r0
 396:	980c      	ldr	r0, [sp, #48]	; 0x30
    i.e. |h0| <= 1.4*2^60; narrower ranges for h2, h4, h6, h8
  |h1| <= (1.65*1.65*2^51*(1+1+19+19+19+19+19+19+19+19))
    i.e. |h1| <= 1.7*2^59; narrower ranges for h3, h5, h7, h9
  */

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 398:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
  /* |h0| <= 2^25 */
  /* |h4| <= 2^25 */
  /* |h1| <= 1.71*2^59 */
  /* |h5| <= 1.71*2^59 */

  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
 39a:	9f18      	ldr	r7, [sp, #96]	; 0x60
  sword64 h9 = f0g9+f1g8   +f2g7   +f3g6   +f4g5   +f5g4   +f6g3   +f7g2   +f8g1   +f9g0   ;
 39c:	fbc1 2c00 	smlal	r2, ip, r1, r0
 3a0:	4616      	mov	r6, r2
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 3a2:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
  sword64 h9 = f0g9+f1g8   +f2g7   +f3g6   +f4g5   +f5g4   +f6g3   +f7g2   +f8g1   +f9g0   ;
 3a4:	f8cd c020 	str.w	ip, [sp, #32]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 3a8:	f112 7000 	adds.w	r0, r2, #33554432	; 0x2000000
 3ac:	f145 0100 	adc.w	r1, r5, #0
 3b0:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 3b2:	ea4f 6890 	mov.w	r8, r0, lsr #26
 3b6:	ea48 1881 	orr.w	r8, r8, r1, lsl #6
 3ba:	eb18 0802 	adds.w	r8, r8, r2
 3be:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 3c0:	f000 407c 	and.w	r0, r0, #4227858432	; 0xfc000000
 3c4:	eb42 62a1 	adc.w	r2, r2, r1, asr #26
 3c8:	1a20      	subs	r0, r4, r0
 3ca:	eb65 0101 	sbc.w	r1, r5, r1
 3ce:	910a      	str	r1, [sp, #40]	; 0x28
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 3d0:	9910      	ldr	r1, [sp, #64]	; 0x40
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 3d2:	9009      	str	r0, [sp, #36]	; 0x24
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 3d4:	f111 7400 	adds.w	r4, r1, #33554432	; 0x2000000
 3d8:	f143 0500 	adc.w	r5, r3, #0
 3dc:	990e      	ldr	r1, [sp, #56]	; 0x38
 3de:	0ea0      	lsrs	r0, r4, #26
 3e0:	ea40 1085 	orr.w	r0, r0, r5, lsl #6
 3e4:	1840      	adds	r0, r0, r1
 3e6:	9920      	ldr	r1, [sp, #128]	; 0x80
 3e8:	eb41 6ca5 	adc.w	ip, r1, r5, asr #26
 3ec:	9910      	ldr	r1, [sp, #64]	; 0x40
 3ee:	f004 447c 	and.w	r4, r4, #4227858432	; 0xfc000000
 3f2:	1b09      	subs	r1, r1, r4
 3f4:	eb63 0305 	sbc.w	r3, r3, r5
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
 3f8:	f118 7580 	adds.w	r5, r8, #16777216	; 0x1000000
 3fc:	f142 0200 	adc.w	r2, r2, #0
 400:	0e6c      	lsrs	r4, r5, #25
 402:	ea44 14c2 	orr.w	r4, r4, r2, lsl #7
 406:	19e4      	adds	r4, r4, r7
 408:	9404      	str	r4, [sp, #16]
 40a:	9c1d      	ldr	r4, [sp, #116]	; 0x74
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 40c:	9f07      	ldr	r7, [sp, #28]
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
 40e:	f005 457e 	and.w	r5, r5, #4261412864	; 0xfe000000
 412:	eb44 6262 	adc.w	r2, r4, r2, asr #25
 416:	ebb8 0405 	subs.w	r4, r8, r5
 41a:	940b      	str	r4, [sp, #44]	; 0x2c
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 41c:	f110 7480 	adds.w	r4, r0, #16777216	; 0x1000000
 420:	f14c 0c00 	adc.w	ip, ip, #0
 424:	0e65      	lsrs	r5, r4, #25
 426:	ea45 15cc 	orr.w	r5, r5, ip, lsl #7
 42a:	19ed      	adds	r5, r5, r7
 42c:	9505      	str	r5, [sp, #20]
 42e:	9d21      	ldr	r5, [sp, #132]	; 0x84
 430:	f004 447e 	and.w	r4, r4, #4261412864	; 0xfe000000
 434:	eb45 6c6c 	adc.w	ip, r5, ip, asr #25
 438:	1b00      	subs	r0, r0, r4
 43a:	900c      	str	r0, [sp, #48]	; 0x30
  /* |h1| <= 2^24; from now on fits into int32 */
  /* |h5| <= 2^24; from now on fits into int32 */
  /* |h2| <= 1.41*2^60 */
  /* |h6| <= 1.41*2^60 */

  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 43c:	9804      	ldr	r0, [sp, #16]
 43e:	9c1e      	ldr	r4, [sp, #120]	; 0x78
 440:	f110 7000 	adds.w	r0, r0, #33554432	; 0x2000000
 444:	9001      	str	r0, [sp, #4]
 446:	f142 0200 	adc.w	r2, r2, #0
 44a:	0e80      	lsrs	r0, r0, #26
 44c:	ea40 1082 	orr.w	r0, r0, r2, lsl #6
 450:	1900      	adds	r0, r0, r4
 452:	9006      	str	r0, [sp, #24]
 454:	981f      	ldr	r0, [sp, #124]	; 0x7c
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 456:	9c22      	ldr	r4, [sp, #136]	; 0x88
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 458:	eb40 62a2 	adc.w	r2, r0, r2, asr #26
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 45c:	9805      	ldr	r0, [sp, #20]
 45e:	f110 7000 	adds.w	r0, r0, #33554432	; 0x2000000
 462:	9002      	str	r0, [sp, #8]
 464:	f14c 0c00 	adc.w	ip, ip, #0
 468:	0e80      	lsrs	r0, r0, #26
 46a:	ea40 108c 	orr.w	r0, r0, ip, lsl #6
 46e:	1900      	adds	r0, r0, r4
 470:	9c23      	ldr	r4, [sp, #140]	; 0x8c
 472:	eb44 6cac 	adc.w	ip, r4, ip, asr #26
  /* |h2| <= 2^25; from now on fits into int32 unchanged */
  /* |h6| <= 2^25; from now on fits into int32 unchanged */
  /* |h3| <= 1.71*2^59 */
  /* |h7| <= 1.71*2^59 */

  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 476:	9c06      	ldr	r4, [sp, #24]
 478:	f114 7a80 	adds.w	sl, r4, #16777216	; 0x1000000
 47c:	f142 0200 	adc.w	r2, r2, #0
 480:	ea4f 645a 	mov.w	r4, sl, lsr #25
 484:	ea44 14c2 	orr.w	r4, r4, r2, lsl #7
 488:	1864      	adds	r4, r4, r1
 48a:	eb43 6362 	adc.w	r3, r3, r2, asr #25
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 48e:	f110 7980 	adds.w	r9, r0, #16777216	; 0x1000000
 492:	9a03      	ldr	r2, [sp, #12]
 494:	f14c 0c00 	adc.w	ip, ip, #0
 498:	ea4f 6159 	mov.w	r1, r9, lsr #25
 49c:	ea41 11cc 	orr.w	r1, r1, ip, lsl #7
 4a0:	1889      	adds	r1, r1, r2
 4a2:	9a11      	ldr	r2, [sp, #68]	; 0x44
 4a4:	eb42 6c6c 	adc.w	ip, r2, ip, asr #25
  /* |h3| <= 2^24; from now on fits into int32 unchanged */
  /* |h7| <= 2^24; from now on fits into int32 unchanged */
  /* |h4| <= 1.72*2^34 */
  /* |h8| <= 1.41*2^60 */

  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 4a8:	f114 7700 	adds.w	r7, r4, #33554432	; 0x2000000
 4ac:	f143 0300 	adc.w	r3, r3, #0
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 4b0:	f111 7800 	adds.w	r8, r1, #33554432	; 0x2000000
 4b4:	f14c 0c00 	adc.w	ip, ip, #0
 4b8:	ea4f 6298 	mov.w	r2, r8, lsr #26
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 4bc:	9307      	str	r3, [sp, #28]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 4be:	ea42 128c 	orr.w	r2, r2, ip, lsl #6
 4c2:	9b08      	ldr	r3, [sp, #32]
 4c4:	1992      	adds	r2, r2, r6
 4c6:	eb43 6cac 	adc.w	ip, r3, ip, asr #26
  /* |h4| <= 2^25; from now on fits into int32 unchanged */
  /* |h8| <= 2^25; from now on fits into int32 unchanged */
  /* |h5| <= 1.01*2^24 */
  /* |h9| <= 1.71*2^59 */

  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 4ca:	f112 7380 	adds.w	r3, r2, #16777216	; 0x1000000
 4ce:	f14c 0c00 	adc.w	ip, ip, #0
 4d2:	0e5d      	lsrs	r5, r3, #25
 4d4:	9303      	str	r3, [sp, #12]
 4d6:	ea45 15cc 	orr.w	r5, r5, ip, lsl #7
 4da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 4dc:	fba5 650b 	umull	r6, r5, r5, fp
 4e0:	18f6      	adds	r6, r6, r3
 4e2:	ea4f 6c6c 	mov.w	ip, ip, asr #25
 4e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 4e8:	fb0b 550c 	mla	r5, fp, ip, r5
 4ec:	eb45 0503 	adc.w	r5, r5, r3
  /* |h9| <= 2^24; from now on fits into int32 unchanged */
  /* |h0| <= 1.1*2^39 */

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 4f0:	f116 7c00 	adds.w	ip, r6, #33554432	; 0x2000000
 4f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 4f6:	f145 0500 	adc.w	r5, r5, #0
 4fa:	f00c 4b7c 	and.w	fp, ip, #4227858432	; 0xfc000000
 4fe:	ea4f 6c9c 	mov.w	ip, ip, lsr #26
 502:	ea4c 1c85 	orr.w	ip, ip, r5, lsl #6
 506:	ebb6 060b 	subs.w	r6, r6, fp
 50a:	eb1c 0503 	adds.w	r5, ip, r3
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 50e:	9b01      	ldr	r3, [sp, #4]
  /* |h0| <= 2^25; from now on fits into int32 unchanged */
  /* |h1| <= 1.01*2^24 */

  h[0] = (sword32)h0;
  h[1] = (sword32)h1;
 510:	f8ce 5004 	str.w	r5, [lr, #4]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 514:	f003 457c 	and.w	r5, r3, #4227858432	; 0xfc000000
 518:	9b04      	ldr	r3, [sp, #16]
  h[0] = (sword32)h0;
 51a:	f8ce 6000 	str.w	r6, [lr]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 51e:	1b5d      	subs	r5, r3, r5
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 520:	9b06      	ldr	r3, [sp, #24]
  h[2] = (sword32)h2;
 522:	f8ce 5008 	str.w	r5, [lr, #8]
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 526:	f00a 4a7e 	and.w	sl, sl, #4261412864	; 0xfe000000
 52a:	ebb3 050a 	subs.w	r5, r3, sl
  h[3] = (sword32)h3;
 52e:	f8ce 500c 	str.w	r5, [lr, #12]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 532:	f007 457c 	and.w	r5, r7, #4227858432	; 0xfc000000
 536:	1b64      	subs	r4, r4, r5
  h[4] = (sword32)h4;
 538:	f8ce 4010 	str.w	r4, [lr, #16]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 53c:	9b07      	ldr	r3, [sp, #28]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 53e:	9c05      	ldr	r4, [sp, #20]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 540:	0ebf      	lsrs	r7, r7, #26
 542:	ea47 1783 	orr.w	r7, r7, r3, lsl #6
 546:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 548:	18ff      	adds	r7, r7, r3
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 54a:	9b02      	ldr	r3, [sp, #8]
  h[5] = (sword32)h5;
 54c:	f8ce 7014 	str.w	r7, [lr, #20]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 550:	f003 437c 	and.w	r3, r3, #4227858432	; 0xfc000000
 554:	1ae3      	subs	r3, r4, r3
  h[6] = (sword32)h6;
 556:	f8ce 3018 	str.w	r3, [lr, #24]
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 55a:	9b03      	ldr	r3, [sp, #12]
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 55c:	f009 497e 	and.w	r9, r9, #4261412864	; 0xfe000000
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 560:	f008 487c 	and.w	r8, r8, #4227858432	; 0xfc000000
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 564:	f003 437e 	and.w	r3, r3, #4261412864	; 0xfe000000
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 568:	ebb0 0009 	subs.w	r0, r0, r9
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 56c:	ebb1 0108 	subs.w	r1, r1, r8
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 570:	1ad2      	subs	r2, r2, r3
  h[7] = (sword32)h7;
 572:	f8ce 001c 	str.w	r0, [lr, #28]
  h[8] = (sword32)h8;
 576:	f8ce 1020 	str.w	r1, [lr, #32]
  h[9] = (sword32)h9;
 57a:	f8ce 2024 	str.w	r2, [lr, #36]	; 0x24
}
 57e:	b025      	add	sp, #148	; 0x94
 580:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.fe_invert:

00000000 <fe_invert>:
{
   0:	b530      	push	{r4, r5, lr}
   2:	b0a9      	sub	sp, #164	; 0xa4
   4:	460c      	mov	r4, r1
  fe t0 = {0};
   6:	2228      	movs	r2, #40	; 0x28
   8:	2100      	movs	r1, #0
{
   a:	4605      	mov	r5, r0
  fe t0 = {0};
   c:	4668      	mov	r0, sp
   e:	f7ff fffe 	bl	0 <memset>
  fe t1 = {0};
  12:	2228      	movs	r2, #40	; 0x28
  14:	2100      	movs	r1, #0
  16:	eb0d 0002 	add.w	r0, sp, r2
  1a:	f7ff fffe 	bl	0 <memset>
  fe t2 = {0};
  1e:	2228      	movs	r2, #40	; 0x28
  20:	2100      	movs	r1, #0
  22:	a814      	add	r0, sp, #80	; 0x50
  24:	f7ff fffe 	bl	0 <memset>
  fe t3 = {0};
  28:	2228      	movs	r2, #40	; 0x28
  2a:	2100      	movs	r1, #0
  2c:	a81e      	add	r0, sp, #120	; 0x78
  2e:	f7ff fffe 	bl	0 <memset>
  fe_sq(t0,z); for (i = 1;i < 1;++i) fe_sq(t0,t0);
  32:	4621      	mov	r1, r4
  34:	4668      	mov	r0, sp
  36:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t1,t0); for (i = 1;i < 2;++i) fe_sq(t1,t1);
  3a:	4669      	mov	r1, sp
  3c:	a80a      	add	r0, sp, #40	; 0x28
  3e:	f7ff fffe 	bl	0 <fe_invert>
  42:	a90a      	add	r1, sp, #40	; 0x28
  44:	4608      	mov	r0, r1
  46:	f7ff fffe 	bl	0 <fe_invert>
  fe_mul(t1,z,t1);
  4a:	aa0a      	add	r2, sp, #40	; 0x28
  4c:	4621      	mov	r1, r4
  4e:	4610      	mov	r0, r2
  50:	f7ff fffe 	bl	0 <fe_invert>
  fe_mul(t0,t0,t1);
  54:	aa0a      	add	r2, sp, #40	; 0x28
  56:	4669      	mov	r1, sp
  58:	4668      	mov	r0, sp
  5a:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t2,t0); for (i = 1;i < 1;++i) fe_sq(t2,t2);
  5e:	4669      	mov	r1, sp
  60:	a814      	add	r0, sp, #80	; 0x50
  62:	f7ff fffe 	bl	0 <fe_invert>
  fe_mul(t1,t1,t2);
  66:	a90a      	add	r1, sp, #40	; 0x28
  68:	4608      	mov	r0, r1
  6a:	aa14      	add	r2, sp, #80	; 0x50
  6c:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t2,t1); for (i = 1;i < 5;++i) fe_sq(t2,t2);
  70:	a90a      	add	r1, sp, #40	; 0x28
  72:	a814      	add	r0, sp, #80	; 0x50
  74:	f7ff fffe 	bl	0 <fe_invert>
  78:	2404      	movs	r4, #4
  7a:	a914      	add	r1, sp, #80	; 0x50
  7c:	4608      	mov	r0, r1
  7e:	f7ff fffe 	bl	0 <fe_invert>
  82:	3c01      	subs	r4, #1
  84:	d1f9      	bne.n	7a <fe_invert+0x7a>
  fe_mul(t1,t2,t1);
  86:	aa0a      	add	r2, sp, #40	; 0x28
  88:	4610      	mov	r0, r2
  8a:	a914      	add	r1, sp, #80	; 0x50
  8c:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t2,t1); for (i = 1;i < 10;++i) fe_sq(t2,t2);
  90:	a90a      	add	r1, sp, #40	; 0x28
  92:	a814      	add	r0, sp, #80	; 0x50
  94:	f7ff fffe 	bl	0 <fe_invert>
  98:	2409      	movs	r4, #9
  9a:	a914      	add	r1, sp, #80	; 0x50
  9c:	4608      	mov	r0, r1
  9e:	f7ff fffe 	bl	0 <fe_invert>
  a2:	3c01      	subs	r4, #1
  a4:	d1f9      	bne.n	9a <fe_invert+0x9a>
  fe_mul(t2,t2,t1);
  a6:	a914      	add	r1, sp, #80	; 0x50
  a8:	4608      	mov	r0, r1
  aa:	aa0a      	add	r2, sp, #40	; 0x28
  ac:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t3,t2); for (i = 1;i < 20;++i) fe_sq(t3,t3);
  b0:	a914      	add	r1, sp, #80	; 0x50
  b2:	a81e      	add	r0, sp, #120	; 0x78
  b4:	f7ff fffe 	bl	0 <fe_invert>
  b8:	2413      	movs	r4, #19
  ba:	a91e      	add	r1, sp, #120	; 0x78
  bc:	4608      	mov	r0, r1
  be:	f7ff fffe 	bl	0 <fe_invert>
  c2:	3c01      	subs	r4, #1
  c4:	d1f9      	bne.n	ba <fe_invert+0xba>
  fe_mul(t2,t3,t2);
  c6:	aa14      	add	r2, sp, #80	; 0x50
  c8:	4610      	mov	r0, r2
  ca:	a91e      	add	r1, sp, #120	; 0x78
  cc:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t2,t2); for (i = 1;i < 10;++i) fe_sq(t2,t2);
  d0:	a914      	add	r1, sp, #80	; 0x50
  d2:	4608      	mov	r0, r1
  d4:	f7ff fffe 	bl	0 <fe_invert>
  d8:	2409      	movs	r4, #9
  da:	a914      	add	r1, sp, #80	; 0x50
  dc:	4608      	mov	r0, r1
  de:	f7ff fffe 	bl	0 <fe_invert>
  e2:	3c01      	subs	r4, #1
  e4:	d1f9      	bne.n	da <fe_invert+0xda>
  fe_mul(t1,t2,t1);
  e6:	aa0a      	add	r2, sp, #40	; 0x28
  e8:	4610      	mov	r0, r2
  ea:	a914      	add	r1, sp, #80	; 0x50
  ec:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t2,t1); for (i = 1;i < 50;++i) fe_sq(t2,t2);
  f0:	a90a      	add	r1, sp, #40	; 0x28
  f2:	a814      	add	r0, sp, #80	; 0x50
  f4:	f7ff fffe 	bl	0 <fe_invert>
  f8:	2431      	movs	r4, #49	; 0x31
  fa:	a914      	add	r1, sp, #80	; 0x50
  fc:	4608      	mov	r0, r1
  fe:	f7ff fffe 	bl	0 <fe_invert>
 102:	3c01      	subs	r4, #1
 104:	d1f9      	bne.n	fa <fe_invert+0xfa>
  fe_mul(t2,t2,t1);
 106:	a914      	add	r1, sp, #80	; 0x50
 108:	4608      	mov	r0, r1
 10a:	aa0a      	add	r2, sp, #40	; 0x28
 10c:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t3,t2); for (i = 1;i < 100;++i) fe_sq(t3,t3);
 110:	a914      	add	r1, sp, #80	; 0x50
 112:	a81e      	add	r0, sp, #120	; 0x78
 114:	f7ff fffe 	bl	0 <fe_invert>
 118:	2463      	movs	r4, #99	; 0x63
 11a:	a91e      	add	r1, sp, #120	; 0x78
 11c:	4608      	mov	r0, r1
 11e:	f7ff fffe 	bl	0 <fe_invert>
 122:	3c01      	subs	r4, #1
 124:	d1f9      	bne.n	11a <fe_invert+0x11a>
  fe_mul(t2,t3,t2);
 126:	aa14      	add	r2, sp, #80	; 0x50
 128:	4610      	mov	r0, r2
 12a:	a91e      	add	r1, sp, #120	; 0x78
 12c:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t2,t2); for (i = 1;i < 50;++i) fe_sq(t2,t2);
 130:	a914      	add	r1, sp, #80	; 0x50
 132:	4608      	mov	r0, r1
 134:	f7ff fffe 	bl	0 <fe_invert>
 138:	2431      	movs	r4, #49	; 0x31
 13a:	a914      	add	r1, sp, #80	; 0x50
 13c:	4608      	mov	r0, r1
 13e:	f7ff fffe 	bl	0 <fe_invert>
 142:	3c01      	subs	r4, #1
 144:	d1f9      	bne.n	13a <fe_invert+0x13a>
  fe_mul(t1,t2,t1);
 146:	aa0a      	add	r2, sp, #40	; 0x28
 148:	4610      	mov	r0, r2
 14a:	a914      	add	r1, sp, #80	; 0x50
 14c:	f7ff fffe 	bl	0 <fe_invert>
  fe_sq(t1,t1); for (i = 1;i < 5;++i) fe_sq(t1,t1);
 150:	a90a      	add	r1, sp, #40	; 0x28
 152:	4608      	mov	r0, r1
 154:	f7ff fffe 	bl	0 <fe_invert>
 158:	2404      	movs	r4, #4
 15a:	a90a      	add	r1, sp, #40	; 0x28
 15c:	4608      	mov	r0, r1
 15e:	f7ff fffe 	bl	0 <fe_invert>
 162:	3c01      	subs	r4, #1
 164:	d1f9      	bne.n	15a <fe_invert+0x15a>
  fe_mul(out,t1,t0);
 166:	466a      	mov	r2, sp
 168:	a90a      	add	r1, sp, #40	; 0x28
 16a:	4628      	mov	r0, r5
 16c:	f7ff fffe 	bl	0 <fe_invert>
}
 170:	b029      	add	sp, #164	; 0xa4
 172:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.fe_cswap:

00000000 <fe_cswap>:

Preconditions: b in {0,1}.
*/

void fe_cswap(fe f, fe g, int b)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b08b      	sub	sp, #44	; 0x2c
  sword32 f5 = f[5];
  sword32 f6 = f[6];
  sword32 f7 = f[7];
  sword32 f8 = f[8];
  sword32 f9 = f[9];
  sword32 g0 = g[0];
   6:	680b      	ldr	r3, [r1, #0]
   8:	9301      	str	r3, [sp, #4]
  sword32 g5 = g[5];
  sword32 g6 = g[6];
  sword32 g7 = g[7];
  sword32 g8 = g[8];
  sword32 g9 = g[9];
  sword32 x0 = f0 ^ g0;
   a:	6804      	ldr	r4, [r0, #0]
  sword32 g1 = g[1];
   c:	684b      	ldr	r3, [r1, #4]
  sword32 x0 = f0 ^ g0;
   e:	9d01      	ldr	r5, [sp, #4]
  sword32 g1 = g[1];
  10:	9302      	str	r3, [sp, #8]
  sword32 x0 = f0 ^ g0;
  12:	ea84 0a05 	eor.w	sl, r4, r5
  sword32 g2 = g[2];
  16:	688b      	ldr	r3, [r1, #8]
  sword32 x1 = f1 ^ g1;
  18:	6844      	ldr	r4, [r0, #4]
  1a:	9d02      	ldr	r5, [sp, #8]
  sword32 g2 = g[2];
  1c:	9303      	str	r3, [sp, #12]
  sword32 x1 = f1 ^ g1;
  1e:	ea84 0905 	eor.w	r9, r4, r5
  sword32 g3 = g[3];
  22:	68cb      	ldr	r3, [r1, #12]
  sword32 x2 = f2 ^ g2;
  24:	6884      	ldr	r4, [r0, #8]
  26:	9d03      	ldr	r5, [sp, #12]
  sword32 g3 = g[3];
  28:	9304      	str	r3, [sp, #16]
  sword32 x2 = f2 ^ g2;
  2a:	ea84 0805 	eor.w	r8, r4, r5
  sword32 g4 = g[4];
  2e:	690b      	ldr	r3, [r1, #16]
  sword32 x3 = f3 ^ g3;
  30:	68c4      	ldr	r4, [r0, #12]
  32:	9d04      	ldr	r5, [sp, #16]
  sword32 g4 = g[4];
  34:	9305      	str	r3, [sp, #20]
  sword32 x3 = f3 ^ g3;
  36:	ea84 0e05 	eor.w	lr, r4, r5
  sword32 g5 = g[5];
  3a:	694b      	ldr	r3, [r1, #20]
  sword32 x4 = f4 ^ g4;
  3c:	6904      	ldr	r4, [r0, #16]
  3e:	9d05      	ldr	r5, [sp, #20]
  sword32 g5 = g[5];
  40:	9306      	str	r3, [sp, #24]
  sword32 g6 = g[6];
  42:	698b      	ldr	r3, [r1, #24]
  44:	9307      	str	r3, [sp, #28]
  sword32 x4 = f4 ^ g4;
  46:	ea84 0c05 	eor.w	ip, r4, r5
  sword32 g7 = g[7];
  4a:	69cb      	ldr	r3, [r1, #28]
  sword32 x5 = f5 ^ g5;
  4c:	9d06      	ldr	r5, [sp, #24]
  4e:	6944      	ldr	r4, [r0, #20]
  sword32 g7 = g[7];
  50:	9308      	str	r3, [sp, #32]
  sword32 g8 = g[8];
  52:	6a0b      	ldr	r3, [r1, #32]
  54:	9309      	str	r3, [sp, #36]	; 0x24
  sword32 x5 = f5 ^ g5;
  56:	ea84 0705 	eor.w	r7, r4, r5
  sword32 g9 = g[9];
  5a:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  sword32 x6 = f6 ^ g6;
  5c:	6984      	ldr	r4, [r0, #24]
  5e:	9d07      	ldr	r5, [sp, #28]
  sword32 x7 = f7 ^ g7;
  sword32 x8 = f8 ^ g8;
  60:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
  sword32 x6 = f6 ^ g6;
  64:	ea84 0605 	eor.w	r6, r4, r5
  sword32 x7 = f7 ^ g7;
  68:	69c4      	ldr	r4, [r0, #28]
  6a:	9d08      	ldr	r5, [sp, #32]
  6c:	4065      	eors	r5, r4
  sword32 x8 = f8 ^ g8;
  6e:	6a04      	ldr	r4, [r0, #32]
  70:	ea84 040b 	eor.w	r4, r4, fp
  sword32 x9 = f9 ^ g9;
  74:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
  b = -b;
  78:	4252      	negs	r2, r2
  sword32 x9 = f9 ^ g9;
  7a:	ea8b 0b03 	eor.w	fp, fp, r3
  x0 &= b;
  7e:	ea0a 0a02 	and.w	sl, sl, r2
  x1 &= b;
  82:	ea09 0902 	and.w	r9, r9, r2
  x2 &= b;
  86:	ea08 0802 	and.w	r8, r8, r2
  x3 &= b;
  8a:	ea0e 0e02 	and.w	lr, lr, r2
  x4 &= b;
  8e:	ea0c 0c02 	and.w	ip, ip, r2
  x5 &= b;
  92:	4017      	ands	r7, r2
  x6 &= b;
  94:	4016      	ands	r6, r2
  x7 &= b;
  96:	4015      	ands	r5, r2
  x8 &= b;
  98:	4014      	ands	r4, r2
  x9 &= b;
  9a:	ea0b 0202 	and.w	r2, fp, r2
  f[0] = f0 ^ x0;
  9e:	f8d0 b000 	ldr.w	fp, [r0]
  a2:	ea8b 0b0a 	eor.w	fp, fp, sl
  a6:	f8c0 b000 	str.w	fp, [r0]
  f[1] = f1 ^ x1;
  aa:	f8d0 b004 	ldr.w	fp, [r0, #4]
  ae:	ea8b 0b09 	eor.w	fp, fp, r9
  b2:	f8c0 b004 	str.w	fp, [r0, #4]
  f[2] = f2 ^ x2;
  b6:	f8d0 b008 	ldr.w	fp, [r0, #8]
  ba:	ea8b 0b08 	eor.w	fp, fp, r8
  be:	f8c0 b008 	str.w	fp, [r0, #8]
  f[3] = f3 ^ x3;
  c2:	f8d0 b00c 	ldr.w	fp, [r0, #12]
  c6:	ea8b 0b0e 	eor.w	fp, fp, lr
  ca:	f8c0 b00c 	str.w	fp, [r0, #12]
  f[4] = f4 ^ x4;
  ce:	f8d0 b010 	ldr.w	fp, [r0, #16]
  d2:	ea8b 0b0c 	eor.w	fp, fp, ip
  d6:	f8c0 b010 	str.w	fp, [r0, #16]
  f[5] = f5 ^ x5;
  da:	f8d0 b014 	ldr.w	fp, [r0, #20]
  de:	ea8b 0b07 	eor.w	fp, fp, r7
  e2:	f8c0 b014 	str.w	fp, [r0, #20]
  f[6] = f6 ^ x6;
  e6:	f8d0 b018 	ldr.w	fp, [r0, #24]
  ea:	ea8b 0b06 	eor.w	fp, fp, r6
  ee:	f8c0 b018 	str.w	fp, [r0, #24]
  f[7] = f7 ^ x7;
  f2:	f8d0 b01c 	ldr.w	fp, [r0, #28]
  f6:	ea8b 0b05 	eor.w	fp, fp, r5
  fa:	f8c0 b01c 	str.w	fp, [r0, #28]
  f[8] = f8 ^ x8;
  fe:	f8d0 b020 	ldr.w	fp, [r0, #32]
 102:	ea8b 0b04 	eor.w	fp, fp, r4
 106:	f8c0 b020 	str.w	fp, [r0, #32]
  f[9] = f9 ^ x9;
 10a:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 10e:	ea8b 0b02 	eor.w	fp, fp, r2
 112:	f8c0 b024 	str.w	fp, [r0, #36]	; 0x24
  g[0] = g0 ^ x0;
 116:	9801      	ldr	r0, [sp, #4]
 118:	ea80 000a 	eor.w	r0, r0, sl
 11c:	6008      	str	r0, [r1, #0]
  g[1] = g1 ^ x1;
 11e:	9802      	ldr	r0, [sp, #8]
 120:	ea80 0009 	eor.w	r0, r0, r9
 124:	6048      	str	r0, [r1, #4]
  g[2] = g2 ^ x2;
 126:	9803      	ldr	r0, [sp, #12]
 128:	ea80 0008 	eor.w	r0, r0, r8
 12c:	6088      	str	r0, [r1, #8]
  g[3] = g3 ^ x3;
 12e:	9804      	ldr	r0, [sp, #16]
 130:	ea80 000e 	eor.w	r0, r0, lr
 134:	60c8      	str	r0, [r1, #12]
  g[4] = g4 ^ x4;
 136:	9805      	ldr	r0, [sp, #20]
 138:	ea80 000c 	eor.w	r0, r0, ip
 13c:	6108      	str	r0, [r1, #16]
  g[5] = g5 ^ x5;
 13e:	9806      	ldr	r0, [sp, #24]
 140:	4047      	eors	r7, r0
  g[6] = g6 ^ x6;
 142:	9807      	ldr	r0, [sp, #28]
  g[5] = g5 ^ x5;
 144:	614f      	str	r7, [r1, #20]
  g[6] = g6 ^ x6;
 146:	4046      	eors	r6, r0
  g[7] = g7 ^ x7;
 148:	9808      	ldr	r0, [sp, #32]
  g[6] = g6 ^ x6;
 14a:	618e      	str	r6, [r1, #24]
  g[7] = g7 ^ x7;
 14c:	4045      	eors	r5, r0
  g[8] = g8 ^ x8;
 14e:	9809      	ldr	r0, [sp, #36]	; 0x24
  g[7] = g7 ^ x7;
 150:	61cd      	str	r5, [r1, #28]
  g[8] = g8 ^ x8;
 152:	4044      	eors	r4, r0
  g[9] = g9 ^ x9;
 154:	405a      	eors	r2, r3
  g[8] = g8 ^ x8;
 156:	620c      	str	r4, [r1, #32]
  g[9] = g9 ^ x9;
 158:	624a      	str	r2, [r1, #36]	; 0x24
}
 15a:	b00b      	add	sp, #44	; 0x2c
 15c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.fe_mul121666:

00000000 <fe_mul121666>:
Postconditions:
   |h| bounded by 1.1*2^25,1.1*2^24,1.1*2^25,1.1*2^24,etc.
*/

void fe_mul121666(fe h,fe f)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  sword32 f5 = f[5];
  sword32 f6 = f[6];
  sword32 f7 = f[7];
  sword32 f8 = f[8];
  sword32 f9 = f[9];
  sword64 h0 = f0 * (sword64) 121666;
   4:	4b68      	ldr	r3, [pc, #416]	; (1a8 <fe_mul121666+0x1a8>)
   6:	680a      	ldr	r2, [r1, #0]
  sword64 h1 = f1 * (sword64) 121666;
   8:	684e      	ldr	r6, [r1, #4]
  sword64 h2 = f2 * (sword64) 121666;
  sword64 h3 = f3 * (sword64) 121666;
   a:	68cd      	ldr	r5, [r1, #12]
{
   c:	b08b      	sub	sp, #44	; 0x2c
  sword64 h0 = f0 * (sword64) 121666;
   e:	fb82 9803 	smull	r9, r8, r2, r3
  sword64 h1 = f1 * (sword64) 121666;
  12:	fb86 6203 	smull	r6, r2, r6, r3
  16:	9202      	str	r2, [sp, #8]
  sword64 h3 = f3 * (sword64) 121666;
  18:	fb85 5203 	smull	r5, r2, r5, r3
  1c:	9203      	str	r2, [sp, #12]
  sword64 h4 = f4 * (sword64) 121666;
  sword64 h5 = f5 * (sword64) 121666;
  1e:	694a      	ldr	r2, [r1, #20]
  20:	fb82 c203 	smull	ip, r2, r2, r3
  24:	9204      	str	r2, [sp, #16]
  sword64 h6 = f6 * (sword64) 121666;
  sword64 h7 = f7 * (sword64) 121666;
  26:	69ca      	ldr	r2, [r1, #28]
  28:	fb82 2403 	smull	r2, r4, r2, r3
  2c:	9201      	str	r2, [sp, #4]
  sword64 h8 = f8 * (sword64) 121666;
  sword64 h9 = f9 * (sword64) 121666;
  2e:	6a4a      	ldr	r2, [r1, #36]	; 0x24
  sword64 h7 = f7 * (sword64) 121666;
  30:	9405      	str	r4, [sp, #20]
  sword64 h9 = f9 * (sword64) 121666;
  32:	fb82 a403 	smull	sl, r4, r2, r3
  sword64 carry6;
  sword64 carry7;
  sword64 carry8;
  sword64 carry9;

  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
  36:	f11a 7e80 	adds.w	lr, sl, #16777216	; 0x1000000
  3a:	f144 0400 	adc.w	r4, r4, #0
  3e:	ea4f 675e 	mov.w	r7, lr, lsr #25
  42:	f04f 0b13 	mov.w	fp, #19
  46:	ea47 17c4 	orr.w	r7, r7, r4, lsl #7
  4a:	fba7 720b 	umull	r7, r2, r7, fp
  4e:	1664      	asrs	r4, r4, #25
  50:	eb17 0909 	adds.w	r9, r7, r9
  54:	fb0b 2204 	mla	r2, fp, r4, r2
  58:	f00e 4e7e 	and.w	lr, lr, #4261412864	; 0xfe000000
  5c:	eb42 0808 	adc.w	r8, r2, r8
  60:	ebba 020e 	subs.w	r2, sl, lr
  64:	9206      	str	r2, [sp, #24]
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
  66:	9a02      	ldr	r2, [sp, #8]
  68:	f116 7480 	adds.w	r4, r6, #16777216	; 0x1000000
  6c:	f142 0b00 	adc.w	fp, r2, #0
  70:	0e67      	lsrs	r7, r4, #25
  72:	688a      	ldr	r2, [r1, #8]
  74:	ea47 17cb 	orr.w	r7, r7, fp, lsl #7
  78:	f004 447e 	and.w	r4, r4, #4261412864	; 0xfe000000
  7c:	ea4f 6b6b 	mov.w	fp, fp, asr #25
  80:	fbc2 7b03 	smlal	r7, fp, r2, r3
  84:	1b32      	subs	r2, r6, r4
  86:	9207      	str	r2, [sp, #28]
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
  88:	9a03      	ldr	r2, [sp, #12]
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
  8a:	9702      	str	r7, [sp, #8]
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
  8c:	f115 7480 	adds.w	r4, r5, #16777216	; 0x1000000
  90:	f142 0e00 	adc.w	lr, r2, #0
  94:	0e66      	lsrs	r6, r4, #25
  96:	690a      	ldr	r2, [r1, #16]
  98:	ea46 16ce 	orr.w	r6, r6, lr, lsl #7
  9c:	f004 447e 	and.w	r4, r4, #4261412864	; 0xfe000000
  a0:	ea4f 6e6e 	mov.w	lr, lr, asr #25
  a4:	fbc2 6e03 	smlal	r6, lr, r2, r3
  a8:	1b2a      	subs	r2, r5, r4
  aa:	9208      	str	r2, [sp, #32]
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
  ac:	9a04      	ldr	r2, [sp, #16]
  ae:	698c      	ldr	r4, [r1, #24]
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
  b0:	9603      	str	r6, [sp, #12]
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
  b2:	f11c 7580 	adds.w	r5, ip, #16777216	; 0x1000000
  b6:	f142 0700 	adc.w	r7, r2, #0
  ba:	f005 427e 	and.w	r2, r5, #4261412864	; 0xfe000000
  be:	ebbc 0202 	subs.w	r2, ip, r2
  c2:	9209      	str	r2, [sp, #36]	; 0x24
  c4:	0e6e      	lsrs	r6, r5, #25
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
  c6:	9a01      	ldr	r2, [sp, #4]
  c8:	f8d1 c020 	ldr.w	ip, [r1, #32]
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
  cc:	ea46 16c7 	orr.w	r6, r6, r7, lsl #7
  d0:	167f      	asrs	r7, r7, #25
  d2:	fbc4 6703 	smlal	r6, r7, r4, r3
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
  d6:	f112 7480 	adds.w	r4, r2, #16777216	; 0x1000000
  da:	9a05      	ldr	r2, [sp, #20]
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
  dc:	9604      	str	r6, [sp, #16]
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
  de:	f142 0500 	adc.w	r5, r2, #0
  e2:	0e66      	lsrs	r6, r4, #25
  e4:	ea46 16c5 	orr.w	r6, r6, r5, lsl #7
  e8:	166d      	asrs	r5, r5, #25
  ea:	4629      	mov	r1, r5
  ec:	fbcc 6103 	smlal	r6, r1, ip, r3
  f0:	9b01      	ldr	r3, [sp, #4]
  f2:	9605      	str	r6, [sp, #20]
  f4:	f004 447e 	and.w	r4, r4, #4261412864	; 0xfe000000
  f8:	1b1c      	subs	r4, r3, r4

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
  fa:	9b02      	ldr	r3, [sp, #8]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
  fc:	f119 7600 	adds.w	r6, r9, #33554432	; 0x2000000
 100:	f148 0800 	adc.w	r8, r8, #0
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 104:	f113 7500 	adds.w	r5, r3, #33554432	; 0x2000000
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 108:	9b03      	ldr	r3, [sp, #12]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 10a:	f14b 0b00 	adc.w	fp, fp, #0
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 10e:	f113 7c00 	adds.w	ip, r3, #33554432	; 0x2000000
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 112:	9b04      	ldr	r3, [sp, #16]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 114:	9a05      	ldr	r2, [sp, #20]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 116:	f14e 0e00 	adc.w	lr, lr, #0
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 11a:	f113 7300 	adds.w	r3, r3, #33554432	; 0x2000000
 11e:	f147 0700 	adc.w	r7, r7, #0
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 122:	f112 7a00 	adds.w	sl, r2, #33554432	; 0x2000000
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 126:	f006 427c 	and.w	r2, r6, #4227858432	; 0xfc000000
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 12a:	f141 0100 	adc.w	r1, r1, #0
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 12e:	0eb6      	lsrs	r6, r6, #26
 130:	ebb9 0902 	subs.w	r9, r9, r2
 134:	9a07      	ldr	r2, [sp, #28]

  h[0] = (sword32)h0;
 136:	f8c0 9000 	str.w	r9, [r0]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 13a:	ea46 1688 	orr.w	r6, r6, r8, lsl #6
 13e:	18b6      	adds	r6, r6, r2
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 140:	9a02      	ldr	r2, [sp, #8]
  h[1] = (sword32)h1;
 142:	6046      	str	r6, [r0, #4]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 144:	f005 467c 	and.w	r6, r5, #4227858432	; 0xfc000000
 148:	1b96      	subs	r6, r2, r6
 14a:	0ead      	lsrs	r5, r5, #26
 14c:	9a08      	ldr	r2, [sp, #32]
  h[2] = (sword32)h2;
 14e:	6086      	str	r6, [r0, #8]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 150:	ea45 158b 	orr.w	r5, r5, fp, lsl #6
 154:	18ad      	adds	r5, r5, r2
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 156:	9a03      	ldr	r2, [sp, #12]
  h[3] = (sword32)h3;
 158:	60c5      	str	r5, [r0, #12]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 15a:	f00c 467c 	and.w	r6, ip, #4227858432	; 0xfc000000
 15e:	1b96      	subs	r6, r2, r6
 160:	ea4f 6c9c 	mov.w	ip, ip, lsr #26
 164:	9a09      	ldr	r2, [sp, #36]	; 0x24
  h[4] = (sword32)h4;
 166:	6106      	str	r6, [r0, #16]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 168:	ea4c 1c8e 	orr.w	ip, ip, lr, lsl #6
 16c:	eb1c 0202 	adds.w	r2, ip, r2
  h[5] = (sword32)h5;
 170:	6142      	str	r2, [r0, #20]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 172:	f003 467c 	and.w	r6, r3, #4227858432	; 0xfc000000
 176:	9a04      	ldr	r2, [sp, #16]
 178:	0e9b      	lsrs	r3, r3, #26
 17a:	ea43 1387 	orr.w	r3, r3, r7, lsl #6
 17e:	1b96      	subs	r6, r2, r6
 180:	191b      	adds	r3, r3, r4
  h[6] = (sword32)h6;
  h[7] = (sword32)h7;
 182:	61c3      	str	r3, [r0, #28]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 184:	9b05      	ldr	r3, [sp, #20]
  h[6] = (sword32)h6;
 186:	6186      	str	r6, [r0, #24]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 188:	f00a 467c 	and.w	r6, sl, #4227858432	; 0xfc000000
 18c:	1b9e      	subs	r6, r3, r6
 18e:	ea4f 6a9a 	mov.w	sl, sl, lsr #26
 192:	9b06      	ldr	r3, [sp, #24]
  h[8] = (sword32)h8;
 194:	6206      	str	r6, [r0, #32]
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 196:	ea4a 1a81 	orr.w	sl, sl, r1, lsl #6
 19a:	eb1a 0203 	adds.w	r2, sl, r3
  h[9] = (sword32)h9;
 19e:	6242      	str	r2, [r0, #36]	; 0x24
}
 1a0:	b00b      	add	sp, #44	; 0x2c
 1a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1a6:	bf00      	nop
 1a8:	0001db42 	.word	0x0001db42

Disassembly of section .text.curve25519:

00000000 <curve25519>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b0c7      	sub	sp, #284	; 0x11c
   6:	4616      	mov	r6, r2
  fe x2 = {0};
   8:	ac0a      	add	r4, sp, #40	; 0x28
  fe x1 = {0};
   a:	2228      	movs	r2, #40	; 0x28
{
   c:	4682      	mov	sl, r0
   e:	468b      	mov	fp, r1
  fe x1 = {0};
  10:	4668      	mov	r0, sp
  12:	2100      	movs	r1, #0
  14:	f7ff fffe 	bl	0 <memset>
  fe x2 = {0};
  18:	2228      	movs	r2, #40	; 0x28
  1a:	2100      	movs	r1, #0
  1c:	4620      	mov	r0, r4
  1e:	f7ff fffe 	bl	0 <memset>
  fe x3 = {0};
  22:	ad1e      	add	r5, sp, #120	; 0x78
  fe z2 = {0};
  24:	2228      	movs	r2, #40	; 0x28
  26:	2100      	movs	r1, #0
  28:	a814      	add	r0, sp, #80	; 0x50
  2a:	f7ff fffe 	bl	0 <memset>
  fe x3 = {0};
  2e:	2228      	movs	r2, #40	; 0x28
  30:	2100      	movs	r1, #0
  32:	4628      	mov	r0, r5
  34:	f7ff fffe 	bl	0 <memset>
  fe z3 = {0};
  38:	2228      	movs	r2, #40	; 0x28
  3a:	2100      	movs	r1, #0
  3c:	a828      	add	r0, sp, #160	; 0xa0
  3e:	f7ff fffe 	bl	0 <memset>
  fe tmp0 = {0};
  42:	2228      	movs	r2, #40	; 0x28
  44:	2100      	movs	r1, #0
  46:	a832      	add	r0, sp, #200	; 0xc8
  48:	f7ff fffe 	bl	0 <memset>
  fe tmp1 = {0};
  4c:	2228      	movs	r2, #40	; 0x28
  4e:	2100      	movs	r1, #0
  50:	a83c      	add	r0, sp, #240	; 0xf0
  52:	f7ff fffe 	bl	0 <memset>
  fe_frombytes(x1,p);
  56:	4631      	mov	r1, r6
  58:	4668      	mov	r0, sp
  5a:	f7ff fffe 	bl	0 <curve25519>
  fe_1(x2);
  5e:	4620      	mov	r0, r4
  60:	f7ff fffe 	bl	0 <curve25519>
  fe_0(z2);
  64:	a814      	add	r0, sp, #80	; 0x50
  66:	f7ff fffe 	bl	0 <curve25519>
  fe_copy(x3,x1);
  6a:	4669      	mov	r1, sp
  6c:	4628      	mov	r0, r5
  6e:	f7ff fffe 	bl	0 <curve25519>
  fe_1(z3);
  72:	a828      	add	r0, sp, #160	; 0xa0
  74:	f7ff fffe 	bl	0 <curve25519>
  swap = 0;
  78:	2700      	movs	r7, #0
  for (pos = 254;pos >= 0;--pos) {
  7a:	f04f 08fe 	mov.w	r8, #254	; 0xfe
    fe_cswap(z2,z3,swap);
  7e:	4606      	mov	r6, r0
    b = n[pos / 8] >> (pos & 7);
  80:	ea4f 03e8 	mov.w	r3, r8, asr #3
  84:	f008 0207 	and.w	r2, r8, #7
  88:	f81b 3003 	ldrb.w	r3, [fp, r3]
  8c:	4113      	asrs	r3, r2
    b &= 1;
  8e:	46b9      	mov	r9, r7
  90:	f003 0701 	and.w	r7, r3, #1
    swap ^= b;
  94:	ea87 0909 	eor.w	r9, r7, r9
    fe_cswap(x2,x3,swap);
  98:	464a      	mov	r2, r9
  9a:	4629      	mov	r1, r5
  9c:	4620      	mov	r0, r4
  9e:	f7ff fffe 	bl	0 <curve25519>
    fe_cswap(z2,z3,swap);
  a2:	464a      	mov	r2, r9
  a4:	4631      	mov	r1, r6
  a6:	a814      	add	r0, sp, #80	; 0x50
  a8:	f7ff fffe 	bl	0 <curve25519>
    fe_sub(tmp0,x3,z3);
  ac:	4632      	mov	r2, r6
  ae:	4629      	mov	r1, r5
  b0:	a832      	add	r0, sp, #200	; 0xc8
  b2:	f7ff fffe 	bl	0 <curve25519>
    fe_sub(tmp1,x2,z2);
  b6:	aa14      	add	r2, sp, #80	; 0x50
  b8:	4621      	mov	r1, r4
  ba:	a83c      	add	r0, sp, #240	; 0xf0
  bc:	f7ff fffe 	bl	0 <curve25519>
    fe_add(x2,x2,z2);
  c0:	aa14      	add	r2, sp, #80	; 0x50
  c2:	4621      	mov	r1, r4
  c4:	4620      	mov	r0, r4
  c6:	f7ff fffe 	bl	0 <curve25519>
    fe_add(z2,x3,z3);
  ca:	4632      	mov	r2, r6
  cc:	4629      	mov	r1, r5
  ce:	a814      	add	r0, sp, #80	; 0x50
  d0:	f7ff fffe 	bl	0 <curve25519>
    fe_mul(z3,tmp0,x2);
  d4:	4622      	mov	r2, r4
  d6:	a932      	add	r1, sp, #200	; 0xc8
  d8:	4630      	mov	r0, r6
  da:	f7ff fffe 	bl	0 <curve25519>
    fe_mul(z2,z2,tmp1);
  de:	a914      	add	r1, sp, #80	; 0x50
  e0:	aa3c      	add	r2, sp, #240	; 0xf0
  e2:	4608      	mov	r0, r1
  e4:	f7ff fffe 	bl	0 <curve25519>
    fe_sq(tmp0,tmp1);
  e8:	a93c      	add	r1, sp, #240	; 0xf0
  ea:	a832      	add	r0, sp, #200	; 0xc8
  ec:	f7ff fffe 	bl	0 <curve25519>
    fe_sq(tmp1,x2);
  f0:	4621      	mov	r1, r4
  f2:	a83c      	add	r0, sp, #240	; 0xf0
  f4:	f7ff fffe 	bl	0 <curve25519>
    fe_add(x3,z3,z2);
  f8:	aa14      	add	r2, sp, #80	; 0x50
  fa:	4631      	mov	r1, r6
  fc:	4628      	mov	r0, r5
  fe:	f7ff fffe 	bl	0 <curve25519>
    fe_sub(z2,z3,z2);
 102:	aa14      	add	r2, sp, #80	; 0x50
 104:	4610      	mov	r0, r2
 106:	4631      	mov	r1, r6
 108:	f7ff fffe 	bl	0 <curve25519>
    fe_mul(x2,tmp1,tmp0);
 10c:	aa32      	add	r2, sp, #200	; 0xc8
 10e:	a93c      	add	r1, sp, #240	; 0xf0
 110:	4620      	mov	r0, r4
 112:	f7ff fffe 	bl	0 <curve25519>
    fe_sub(tmp1,tmp1,tmp0);
 116:	a93c      	add	r1, sp, #240	; 0xf0
 118:	aa32      	add	r2, sp, #200	; 0xc8
 11a:	4608      	mov	r0, r1
 11c:	f7ff fffe 	bl	0 <curve25519>
    fe_sq(z2,z2);
 120:	a914      	add	r1, sp, #80	; 0x50
 122:	4608      	mov	r0, r1
 124:	f7ff fffe 	bl	0 <curve25519>
    fe_mul121666(z3,tmp1);
 128:	a93c      	add	r1, sp, #240	; 0xf0
 12a:	4630      	mov	r0, r6
 12c:	f7ff fffe 	bl	0 <curve25519>
    fe_sq(x3,x3);
 130:	4629      	mov	r1, r5
 132:	4628      	mov	r0, r5
 134:	f7ff fffe 	bl	0 <curve25519>
    fe_add(tmp0,tmp0,z3);
 138:	a932      	add	r1, sp, #200	; 0xc8
 13a:	4608      	mov	r0, r1
 13c:	4632      	mov	r2, r6
 13e:	f7ff fffe 	bl	0 <curve25519>
    fe_mul(z3,x1,z2);
 142:	aa14      	add	r2, sp, #80	; 0x50
 144:	4669      	mov	r1, sp
 146:	4630      	mov	r0, r6
 148:	f7ff fffe 	bl	0 <curve25519>
    fe_mul(z2,tmp1,tmp0);
 14c:	aa32      	add	r2, sp, #200	; 0xc8
 14e:	a93c      	add	r1, sp, #240	; 0xf0
 150:	a814      	add	r0, sp, #80	; 0x50
 152:	f7ff fffe 	bl	0 <curve25519>
  for (pos = 254;pos >= 0;--pos) {
 156:	f1b8 0801 	subs.w	r8, r8, #1
 15a:	d291      	bcs.n	80 <curve25519+0x80>
  fe_cswap(x2,x3,swap);
 15c:	463a      	mov	r2, r7
 15e:	4629      	mov	r1, r5
 160:	4620      	mov	r0, r4
 162:	f7ff fffe 	bl	0 <curve25519>
  fe_cswap(z2,z3,swap);
 166:	463a      	mov	r2, r7
 168:	4631      	mov	r1, r6
 16a:	a814      	add	r0, sp, #80	; 0x50
 16c:	f7ff fffe 	bl	0 <curve25519>
  fe_invert(z2,z2);
 170:	a914      	add	r1, sp, #80	; 0x50
 172:	4608      	mov	r0, r1
 174:	f7ff fffe 	bl	0 <curve25519>
  fe_mul(x2,x2,z2);
 178:	aa14      	add	r2, sp, #80	; 0x50
 17a:	4621      	mov	r1, r4
 17c:	4620      	mov	r0, r4
 17e:	f7ff fffe 	bl	0 <curve25519>
  fe_tobytes(q,x2);
 182:	4650      	mov	r0, sl
 184:	4621      	mov	r1, r4
 186:	f7ff fffe 	bl	0 <curve25519>
}
 18a:	2000      	movs	r0, #0
 18c:	b047      	add	sp, #284	; 0x11c
 18e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.fe_sq2:

00000000 <fe_sq2>:
/*
See fe_mul.c for discussion of implementation strategy.
*/

void fe_sq2(fe h,const fe f)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  sword32 f0 = f[0];
  sword32 f1 = f[1];
  sword32 f2 = f[2];
  sword32 f3 = f[3];
   4:	e9d1 2402 	ldrd	r2, r4, [r1, #8]
{
   8:	b097      	sub	sp, #92	; 0x5c
   a:	4683      	mov	fp, r0
  sword32 f3 = f[3];
   c:	9409      	str	r4, [sp, #36]	; 0x24
  sword32 f4 = f[4];
   e:	690c      	ldr	r4, [r1, #16]
  10:	9402      	str	r4, [sp, #8]
  sword32 f5 = f[5];
  12:	694c      	ldr	r4, [r1, #20]
  14:	9404      	str	r4, [sp, #16]
  sword32 f6 = f[6];
  16:	698c      	ldr	r4, [r1, #24]
  18:	9401      	str	r4, [sp, #4]
  sword32 f7 = f[7];
  1a:	69cc      	ldr	r4, [r1, #28]
  1c:	9406      	str	r4, [sp, #24]
  sword32 f1 = f[1];
  1e:	e9d1 0300 	ldrd	r0, r3, [r1]
  sword32 f8 = f[8];
  22:	6a0c      	ldr	r4, [r1, #32]
  sword32 f9 = f[9];
  24:	6a49      	ldr	r1, [r1, #36]	; 0x24
  26:	910a      	str	r1, [sp, #40]	; 0x28
  sword32 f0_2 = 2 * f0;
  sword32 f1_2 = 2 * f1;
  sword32 f2_2 = 2 * f2;
  28:	0051      	lsls	r1, r2, #1
  2a:	9108      	str	r1, [sp, #32]
  sword32 f3_2 = 2 * f3;
  2c:	9909      	ldr	r1, [sp, #36]	; 0x24
  sword32 f5_2 = 2 * f5;
  sword32 f6_2 = 2 * f6;
  sword32 f7_2 = 2 * f7;
  sword32 f5_38 = 38 * f5; /* 1.959375*2^30 */
  sword32 f6_19 = 19 * f6; /* 1.959375*2^30 */
  sword32 f7_38 = 38 * f7; /* 1.959375*2^30 */
  2e:	9e06      	ldr	r6, [sp, #24]
  sword32 f8 = f[8];
  30:	9407      	str	r4, [sp, #28]
  sword32 f3_2 = 2 * f3;
  32:	0049      	lsls	r1, r1, #1
  34:	9103      	str	r1, [sp, #12]
  sword32 f4_2 = 2 * f4;
  36:	9902      	ldr	r1, [sp, #8]
  38:	0049      	lsls	r1, r1, #1
  3a:	910b      	str	r1, [sp, #44]	; 0x2c
  sword32 f5_2 = 2 * f5;
  3c:	9904      	ldr	r1, [sp, #16]
  3e:	0049      	lsls	r1, r1, #1
  40:	9105      	str	r1, [sp, #20]
  sword32 f7_2 = 2 * f7;
  42:	9906      	ldr	r1, [sp, #24]
  44:	0049      	lsls	r1, r1, #1
  46:	910c      	str	r1, [sp, #48]	; 0x30
  sword32 f6_19 = 19 * f6; /* 1.959375*2^30 */
  48:	9901      	ldr	r1, [sp, #4]
  4a:	2513      	movs	r5, #19
  4c:	fb05 f401 	mul.w	r4, r5, r1
  sword32 f7_38 = 38 * f7; /* 1.959375*2^30 */
  50:	2126      	movs	r1, #38	; 0x26
  52:	fb01 fe06 	mul.w	lr, r1, r6
  sword32 f8_19 = 19 * f8; /* 1.959375*2^30 */
  56:	9e07      	ldr	r6, [sp, #28]
  58:	fb05 f706 	mul.w	r7, r5, r6
  sword32 f9_38 = 38 * f9; /* 1.959375*2^30 */
  5c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
  sword32 f5_38 = 38 * f5; /* 1.959375*2^30 */
  5e:	9d04      	ldr	r5, [sp, #16]
  sword32 f9_38 = 38 * f9; /* 1.959375*2^30 */
  60:	fb01 f806 	mul.w	r8, r1, r6
  sword32 f1_2 = 2 * f1;
  64:	ea4f 0c43 	mov.w	ip, r3, lsl #1
  sword32 f5_38 = 38 * f5; /* 1.959375*2^30 */
  68:	4369      	muls	r1, r5
  sword64 f1f4_2  = f1_2 * (sword64) f4;
  sword64 f1f5_4  = f1_2 * (sword64) f5_2;
  sword64 f1f6_2  = f1_2 * (sword64) f6;
  sword64 f1f7_4  = f1_2 * (sword64) f7_2;
  sword64 f1f8_2  = f1_2 * (sword64) f8;
  sword64 f1f9_76 = f1_2 * (sword64) f9_38;
  6a:	fb8c 6508 	smull	r6, r5, ip, r8
  sword32 f0_2 = 2 * f0;
  6e:	ea4f 0940 	mov.w	r9, r0, lsl #1
  sword64 f7f8_38 = f7_2 * (sword64) f8_19;
  sword64 f7f9_76 = f7_2 * (sword64) f9_38;
  sword64 f8f8_19 = f8   * (sword64) f8_19;
  sword64 f8f9_38 = f8   * (sword64) f9_38;
  sword64 f9f9_38 = f9   * (sword64) f9_38;
  sword64 h0 = f0f0  +f1f9_76+f2f8_38+f3f7_76+f4f6_38+f5f5_38;
  72:	fbc0 6500 	smlal	r6, r5, r0, r0
  76:	0050      	lsls	r0, r2, #1
  78:	fbc0 6507 	smlal	r6, r5, r0, r7
  7c:	9803      	ldr	r0, [sp, #12]
  sword64 h1 = f0f1_2+f2f9_38+f3f8_38+f4f7_38+f5f6_38;
  sword64 h2 = f0f2_2+f1f1_2 +f3f9_76+f4f8_38+f5f7_76+f6f6_19;
  7e:	f8dd a00c 	ldr.w	sl, [sp, #12]
  sword64 h0 = f0f0  +f1f9_76+f2f8_38+f3f7_76+f4f6_38+f5f5_38;
  82:	fbc0 650e 	smlal	r6, r5, r0, lr
  86:	980b      	ldr	r0, [sp, #44]	; 0x2c
  88:	fbc0 6504 	smlal	r6, r5, r0, r4
  8c:	9804      	ldr	r0, [sp, #16]
  8e:	fbc0 6501 	smlal	r6, r5, r0, r1
  92:	960e      	str	r6, [sp, #56]	; 0x38
  sword64 f2f9_38 = f2   * (sword64) f9_38;
  94:	fb82 1008 	smull	r1, r0, r2, r8
  sword64 h1 = f0f1_2+f2f9_38+f3f8_38+f4f7_38+f5f6_38;
  98:	9e03      	ldr	r6, [sp, #12]
  9a:	fbc9 1003 	smlal	r1, r0, r9, r3
  9e:	fbc6 1007 	smlal	r1, r0, r6, r7
  a2:	9e02      	ldr	r6, [sp, #8]
  a4:	fbc6 100e 	smlal	r1, r0, r6, lr
  a8:	9e05      	ldr	r6, [sp, #20]
  aa:	fbc6 1004 	smlal	r1, r0, r6, r4
  ae:	910f      	str	r1, [sp, #60]	; 0x3c
  sword64 f1f1_2  = f1_2 * (sword64) f1;
  b0:	fb83 610c 	smull	r6, r1, r3, ip
  sword64 h2 = f0f2_2+f1f1_2 +f3f9_76+f4f8_38+f5f7_76+f6f6_19;
  b4:	fbc9 6102 	smlal	r6, r1, r9, r2
  b8:	fbca 6108 	smlal	r6, r1, sl, r8
  bc:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
  c0:	fbc7 610a 	smlal	r6, r1, r7, sl
  c4:	f8dd a014 	ldr.w	sl, [sp, #20]
  c8:	fbca 610e 	smlal	r6, r1, sl, lr
  cc:	f8dd a004 	ldr.w	sl, [sp, #4]
  d0:	fbca 6104 	smlal	r6, r1, sl, r4
  d4:	9610      	str	r6, [sp, #64]	; 0x40
  sword64 h3 = f0f3_2+f1f2_2 +f4f9_38+f5f8_38+f6f7_38;
  d6:	9e09      	ldr	r6, [sp, #36]	; 0x24
  sword64 h2 = f0f2_2+f1f1_2 +f3f9_76+f4f8_38+f5f7_76+f6f6_19;
  d8:	910d      	str	r1, [sp, #52]	; 0x34
  sword64 f1f2_2  = f1_2 * (sword64) f2;
  da:	fb82 4a0c 	smull	r4, sl, r2, ip
  sword64 h3 = f0f3_2+f1f2_2 +f4f9_38+f5f8_38+f6f7_38;
  de:	fbc9 4a06 	smlal	r4, sl, r9, r6
  e2:	9e02      	ldr	r6, [sp, #8]
  sword64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;
  e4:	9902      	ldr	r1, [sp, #8]
  sword64 h3 = f0f3_2+f1f2_2 +f4f9_38+f5f8_38+f6f7_38;
  e6:	fbc6 4a08 	smlal	r4, sl, r6, r8
  ea:	9e05      	ldr	r6, [sp, #20]
  ec:	fbc6 4a07 	smlal	r4, sl, r6, r7
  f0:	9e01      	ldr	r6, [sp, #4]
  f2:	fbc6 4a0e 	smlal	r4, sl, r6, lr
  f6:	9411      	str	r4, [sp, #68]	; 0x44
  sword64 f1f3_4  = f1_2 * (sword64) f3_2;
  f8:	9c03      	ldr	r4, [sp, #12]
  fa:	fb8c 4304 	smull	r4, r3, ip, r4
  sword64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;
  fe:	fbc9 4301 	smlal	r4, r3, r9, r1
 102:	fbc2 4302 	smlal	r4, r3, r2, r2
 106:	9a05      	ldr	r2, [sp, #20]
  sword32 f6_2 = 2 * f6;
 108:	0076      	lsls	r6, r6, #1
  sword64 h4 = f0f4_2+f1f3_4 +f2f2   +f5f9_76+f6f8_38+f7f7_38;
 10a:	fbc2 4308 	smlal	r4, r3, r2, r8
 10e:	9a06      	ldr	r2, [sp, #24]
 110:	fbc7 4306 	smlal	r4, r3, r7, r6
 114:	fbc2 430e 	smlal	r4, r3, r2, lr
 118:	9412      	str	r4, [sp, #72]	; 0x48
  sword64 f1f4_2  = f1_2 * (sword64) f4;
 11a:	fb81 420c 	smull	r4, r2, r1, ip
  sword64 h5 = f0f5_2+f1f4_2 +f2f3_2 +f6f9_38+f7f8_38;
 11e:	9904      	ldr	r1, [sp, #16]
 120:	fbc9 4201 	smlal	r4, r2, r9, r1
 124:	e9dd 6108 	ldrd	r6, r1, [sp, #32]
 128:	fbc1 4206 	smlal	r4, r2, r1, r6
 12c:	9901      	ldr	r1, [sp, #4]
 12e:	fbc1 4208 	smlal	r4, r2, r1, r8
 132:	990c      	ldr	r1, [sp, #48]	; 0x30
 134:	fbc1 4207 	smlal	r4, r2, r1, r7
  sword64 f1f5_4  = f1_2 * (sword64) f5_2;
 138:	9905      	ldr	r1, [sp, #20]
  sword64 h5 = f0f5_2+f1f4_2 +f2f3_2 +f6f9_38+f7f8_38;
 13a:	9413      	str	r4, [sp, #76]	; 0x4c
  sword64 f1f5_4  = f1_2 * (sword64) f5_2;
 13c:	fb8c 4e01 	smull	r4, lr, ip, r1
  sword64 h6 = f0f6_2+f1f5_4 +f2f4_2 +f3f3_2 +f7f9_76+f8f8_19;
 140:	9901      	ldr	r1, [sp, #4]
 142:	fbc9 4e01 	smlal	r4, lr, r9, r1
 146:	9902      	ldr	r1, [sp, #8]
 148:	fbc1 4e06 	smlal	r4, lr, r1, r6
 14c:	9909      	ldr	r1, [sp, #36]	; 0x24
 14e:	9e03      	ldr	r6, [sp, #12]
 150:	fbc1 4e06 	smlal	r4, lr, r1, r6
 154:	990c      	ldr	r1, [sp, #48]	; 0x30
 156:	fbc1 4e08 	smlal	r4, lr, r1, r8
 15a:	9907      	ldr	r1, [sp, #28]
 15c:	fbc1 4e07 	smlal	r4, lr, r1, r7
  sword64 f1f6_2  = f1_2 * (sword64) f6;
 160:	9901      	ldr	r1, [sp, #4]
  sword64 h6 = f0f6_2+f1f5_4 +f2f4_2 +f3f3_2 +f7f9_76+f8f8_19;
 162:	9414      	str	r4, [sp, #80]	; 0x50
  sword64 f1f6_2  = f1_2 * (sword64) f6;
 164:	fb81 640c 	smull	r6, r4, r1, ip
  sword64 h7 = f0f7_2+f1f6_2 +f2f5_2 +f3f4_2 +f8f9_38;
 168:	9906      	ldr	r1, [sp, #24]
 16a:	9f08      	ldr	r7, [sp, #32]
 16c:	fbc9 6401 	smlal	r6, r4, r9, r1
 170:	9904      	ldr	r1, [sp, #16]
 172:	fbc1 6407 	smlal	r6, r4, r1, r7
 176:	e9dd 1702 	ldrd	r1, r7, [sp, #8]
 17a:	fbc1 6407 	smlal	r6, r4, r1, r7
 17e:	9907      	ldr	r1, [sp, #28]
 180:	fbc1 6408 	smlal	r6, r4, r1, r8
  sword64 f1f7_4  = f1_2 * (sword64) f7_2;
 184:	990c      	ldr	r1, [sp, #48]	; 0x30
  sword64 h7 = f0f7_2+f1f6_2 +f2f5_2 +f3f4_2 +f8f9_38;
 186:	9615      	str	r6, [sp, #84]	; 0x54
  sword64 f1f7_4  = f1_2 * (sword64) f7_2;
 188:	fb8c 6701 	smull	r6, r7, ip, r1
  sword64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;
 18c:	9907      	ldr	r1, [sp, #28]
  sword64 h7 = f0f7_2+f1f6_2 +f2f5_2 +f3f4_2 +f8f9_38;
 18e:	9409      	str	r4, [sp, #36]	; 0x24
  sword64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;
 190:	fbc9 6701 	smlal	r6, r7, r9, r1
 194:	9c08      	ldr	r4, [sp, #32]
 196:	9901      	ldr	r1, [sp, #4]
 198:	fbc1 6704 	smlal	r6, r7, r1, r4
 19c:	9903      	ldr	r1, [sp, #12]
 19e:	9c05      	ldr	r4, [sp, #20]
 1a0:	fbc1 6704 	smlal	r6, r7, r1, r4
 1a4:	9902      	ldr	r1, [sp, #8]
  sword64 h9 = f0f9_2+f1f8_2 +f2f7_2 +f3f6_2 +f4f5_2;
 1a6:	9c08      	ldr	r4, [sp, #32]
  sword64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;
 1a8:	fbc1 6701 	smlal	r6, r7, r1, r1
 1ac:	990a      	ldr	r1, [sp, #40]	; 0x28
 1ae:	fbc1 6708 	smlal	r6, r7, r1, r8
  sword64 f1f8_2  = f1_2 * (sword64) f8;
 1b2:	9907      	ldr	r1, [sp, #28]
  sword64 h8 = f0f8_2+f1f7_4 +f2f6_2 +f3f5_4 +f4f4   +f9f9_38;
 1b4:	9602      	str	r6, [sp, #8]
  sword64 f1f8_2  = f1_2 * (sword64) f8;
 1b6:	fb81 6c0c 	smull	r6, ip, r1, ip
  sword64 h9 = f0f9_2+f1f8_2 +f2f7_2 +f3f6_2 +f4f5_2;
 1ba:	990a      	ldr	r1, [sp, #40]	; 0x28
 1bc:	fbc9 6c01 	smlal	r6, ip, r9, r1
 1c0:	9906      	ldr	r1, [sp, #24]
 1c2:	fbc1 6c04 	smlal	r6, ip, r1, r4
 1c6:	9901      	ldr	r1, [sp, #4]
 1c8:	9c03      	ldr	r4, [sp, #12]
 1ca:	fbc1 6c04 	smlal	r6, ip, r1, r4
 1ce:	9904      	ldr	r1, [sp, #16]
 1d0:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 1d2:	fbc1 6c04 	smlal	r6, ip, r1, r4
 1d6:	46b1      	mov	r9, r6
  sword64 carry6;
  sword64 carry7;
  sword64 carry8;
  sword64 carry9;

  h0 += h0;
 1d8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  h1 += h1;
 1da:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
  h2 += h2;
 1dc:	990d      	ldr	r1, [sp, #52]	; 0x34
  h0 += h0;
 1de:	19b6      	adds	r6, r6, r6
 1e0:	416d      	adcs	r5, r5
  h1 += h1;
 1e2:	1924      	adds	r4, r4, r4
 1e4:	9401      	str	r4, [sp, #4]
  h2 += h2;
 1e6:	9c10      	ldr	r4, [sp, #64]	; 0x40
  h1 += h1;
 1e8:	4140      	adcs	r0, r0
  h2 += h2;
 1ea:	1924      	adds	r4, r4, r4
 1ec:	9403      	str	r4, [sp, #12]
  h3 += h3;
 1ee:	9c11      	ldr	r4, [sp, #68]	; 0x44
  h2 += h2;
 1f0:	4149      	adcs	r1, r1
  h3 += h3;
 1f2:	1924      	adds	r4, r4, r4
 1f4:	9405      	str	r4, [sp, #20]
 1f6:	eb4a 040a 	adc.w	r4, sl, sl
 1fa:	9406      	str	r4, [sp, #24]
  h4 += h4;
 1fc:	9c12      	ldr	r4, [sp, #72]	; 0x48
 1fe:	eb14 0804 	adds.w	r8, r4, r4
  h5 += h5;
 202:	9c13      	ldr	r4, [sp, #76]	; 0x4c
  h4 += h4;
 204:	415b      	adcs	r3, r3
  h5 += h5;
 206:	eb14 0a04 	adds.w	sl, r4, r4
  h6 += h6;
 20a:	9c14      	ldr	r4, [sp, #80]	; 0x50
  h5 += h5;
 20c:	4152      	adcs	r2, r2
  h6 += h6;
 20e:	1924      	adds	r4, r4, r4
 210:	9404      	str	r4, [sp, #16]
  h7 += h7;
 212:	9c15      	ldr	r4, [sp, #84]	; 0x54
  h6 += h6;
 214:	eb4e 0e0e 	adc.w	lr, lr, lr
  h7 += h7;
 218:	1924      	adds	r4, r4, r4
 21a:	940b      	str	r4, [sp, #44]	; 0x2c
 21c:	9c09      	ldr	r4, [sp, #36]	; 0x24
 21e:	4164      	adcs	r4, r4
 220:	940c      	str	r4, [sp, #48]	; 0x30
  h8 += h8;
 222:	9c02      	ldr	r4, [sp, #8]
 224:	1924      	adds	r4, r4, r4
 226:	940d      	str	r4, [sp, #52]	; 0x34
 228:	eb47 0407 	adc.w	r4, r7, r7
 22c:	940e      	str	r4, [sp, #56]	; 0x38
  h9 += h9;
 22e:	eb19 0409 	adds.w	r4, r9, r9
 232:	940f      	str	r4, [sp, #60]	; 0x3c
 234:	eb4c 040c 	adc.w	r4, ip, ip

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 238:	f116 7700 	adds.w	r7, r6, #33554432	; 0x2000000
 23c:	f145 0c00 	adc.w	ip, r5, #0
 240:	f8dd 9004 	ldr.w	r9, [sp, #4]
  h9 += h9;
 244:	9410      	str	r4, [sp, #64]	; 0x40
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 246:	0ebc      	lsrs	r4, r7, #26
 248:	ea44 148c 	orr.w	r4, r4, ip, lsl #6
 24c:	eb14 0909 	adds.w	r9, r4, r9
 250:	f007 477c 	and.w	r7, r7, #4227858432	; 0xfc000000
 254:	eb40 60ac 	adc.w	r0, r0, ip, asr #26
 258:	1bf4      	subs	r4, r6, r7
 25a:	9407      	str	r4, [sp, #28]
 25c:	eb65 040c 	sbc.w	r4, r5, ip
 260:	9408      	str	r4, [sp, #32]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 262:	f118 7400 	adds.w	r4, r8, #33554432	; 0x2000000
 266:	f143 0500 	adc.w	r5, r3, #0
 26a:	0ea6      	lsrs	r6, r4, #26
 26c:	ea46 1685 	orr.w	r6, r6, r5, lsl #6
 270:	eb16 0a0a 	adds.w	sl, r6, sl
 274:	f004 447c 	and.w	r4, r4, #4227858432	; 0xfc000000
 278:	eb42 62a5 	adc.w	r2, r2, r5, asr #26
 27c:	ebb8 0804 	subs.w	r8, r8, r4
 280:	eb63 0305 	sbc.w	r3, r3, r5

  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
 284:	f119 7480 	adds.w	r4, r9, #16777216	; 0x1000000
 288:	9e03      	ldr	r6, [sp, #12]
 28a:	f140 0000 	adc.w	r0, r0, #0
 28e:	0e65      	lsrs	r5, r4, #25
 290:	ea45 15c0 	orr.w	r5, r5, r0, lsl #7
 294:	19ad      	adds	r5, r5, r6
 296:	f004 447e 	and.w	r4, r4, #4261412864	; 0xfe000000
 29a:	eb41 6160 	adc.w	r1, r1, r0, asr #25
 29e:	ebb9 0004 	subs.w	r0, r9, r4
 2a2:	9009      	str	r0, [sp, #36]	; 0x24
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 2a4:	f11a 7080 	adds.w	r0, sl, #16777216	; 0x1000000
  carry1 = (h1 + (sword64) (1UL<<24)) >> 25; h2 += carry1; h1 -= carry1 << 25;
 2a8:	9503      	str	r5, [sp, #12]
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 2aa:	f142 0200 	adc.w	r2, r2, #0
 2ae:	9d04      	ldr	r5, [sp, #16]
 2b0:	0e44      	lsrs	r4, r0, #25
 2b2:	ea44 14c2 	orr.w	r4, r4, r2, lsl #7
 2b6:	1964      	adds	r4, r4, r5
 2b8:	f000 407e 	and.w	r0, r0, #4261412864	; 0xfe000000
 2bc:	eb4e 6e62 	adc.w	lr, lr, r2, asr #25
 2c0:	ebba 0200 	subs.w	r2, sl, r0
 2c4:	920a      	str	r2, [sp, #40]	; 0x28

  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 2c6:	9a03      	ldr	r2, [sp, #12]
  carry5 = (h5 + (sword64) (1UL<<24)) >> 25; h6 += carry5; h5 -= carry5 << 25;
 2c8:	9404      	str	r4, [sp, #16]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 2ca:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 2ce:	9201      	str	r2, [sp, #4]
 2d0:	f141 0100 	adc.w	r1, r1, #0
 2d4:	9805      	ldr	r0, [sp, #20]

  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;

  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 2d6:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 2d8:	9e10      	ldr	r6, [sp, #64]	; 0x40
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 2da:	0e92      	lsrs	r2, r2, #26
 2dc:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
 2e0:	1812      	adds	r2, r2, r0
 2e2:	9205      	str	r2, [sp, #20]
 2e4:	9a06      	ldr	r2, [sp, #24]
 2e6:	eb42 61a1 	adc.w	r1, r2, r1, asr #26
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 2ea:	f114 7200 	adds.w	r2, r4, #33554432	; 0x2000000
 2ee:	f14e 0e00 	adc.w	lr, lr, #0
 2f2:	9202      	str	r2, [sp, #8]
 2f4:	0e90      	lsrs	r0, r2, #26
 2f6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 2f8:	ea40 108e 	orr.w	r0, r0, lr, lsl #6
 2fc:	1880      	adds	r0, r0, r2
 2fe:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 300:	eb42 6cae 	adc.w	ip, r2, lr, asr #26
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 304:	9a05      	ldr	r2, [sp, #20]
 306:	f112 7a80 	adds.w	sl, r2, #16777216	; 0x1000000
 30a:	f141 0100 	adc.w	r1, r1, #0
 30e:	ea4f 645a 	mov.w	r4, sl, lsr #25
 312:	ea44 14c1 	orr.w	r4, r4, r1, lsl #7
 316:	eb14 0408 	adds.w	r4, r4, r8
 31a:	eb43 6361 	adc.w	r3, r3, r1, asr #25
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 31e:	f110 7980 	adds.w	r9, r0, #16777216	; 0x1000000
 322:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 324:	f14c 0c00 	adc.w	ip, ip, #0
 328:	ea4f 6159 	mov.w	r1, r9, lsr #25
 32c:	ea41 11cc 	orr.w	r1, r1, ip, lsl #7
 330:	1889      	adds	r1, r1, r2
 332:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 334:	eb42 6c6c 	adc.w	ip, r2, ip, asr #25
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 338:	f114 7700 	adds.w	r7, r4, #33554432	; 0x2000000
 33c:	f143 0300 	adc.w	r3, r3, #0
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 340:	f111 7800 	adds.w	r8, r1, #33554432	; 0x2000000
 344:	f14c 0c00 	adc.w	ip, ip, #0
 348:	ea4f 6298 	mov.w	r2, r8, lsr #26
 34c:	ea42 128c 	orr.w	r2, r2, ip, lsl #6
 350:	1952      	adds	r2, r2, r5
 352:	eb46 6cac 	adc.w	ip, r6, ip, asr #26

  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 356:	f112 7e80 	adds.w	lr, r2, #16777216	; 0x1000000
 35a:	f14c 0c00 	adc.w	ip, ip, #0
 35e:	ea4f 655e 	mov.w	r5, lr, lsr #25
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 362:	9306      	str	r3, [sp, #24]
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 364:	ea45 15cc 	orr.w	r5, r5, ip, lsl #7
 368:	2313      	movs	r3, #19
 36a:	fba5 6503 	umull	r6, r5, r5, r3
 36e:	ea4f 6c6c 	mov.w	ip, ip, asr #25
 372:	fb03 550c 	mla	r5, r3, ip, r5
 376:	9b07      	ldr	r3, [sp, #28]
 378:	18f6      	adds	r6, r6, r3
 37a:	9b08      	ldr	r3, [sp, #32]
 37c:	eb45 0503 	adc.w	r5, r5, r3

  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 380:	f116 7c00 	adds.w	ip, r6, #33554432	; 0x2000000
 384:	f00c 437c 	and.w	r3, ip, #4227858432	; 0xfc000000
 388:	f145 0500 	adc.w	r5, r5, #0
 38c:	ea4f 6c9c 	mov.w	ip, ip, lsr #26
 390:	1af6      	subs	r6, r6, r3
 392:	9b09      	ldr	r3, [sp, #36]	; 0x24

  h[0] = (sword32)h0;
 394:	f8cb 6000 	str.w	r6, [fp]
  carry0 = (h0 + (sword64) (1UL<<25)) >> 26; h1 += carry0; h0 -= carry0 << 26;
 398:	ea4c 1c85 	orr.w	ip, ip, r5, lsl #6
 39c:	eb1c 0503 	adds.w	r5, ip, r3
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 3a0:	9b01      	ldr	r3, [sp, #4]
  h[1] = (sword32)h1;
 3a2:	f8cb 5004 	str.w	r5, [fp, #4]
  carry2 = (h2 + (sword64) (1UL<<25)) >> 26; h3 += carry2; h2 -= carry2 << 26;
 3a6:	f003 457c 	and.w	r5, r3, #4227858432	; 0xfc000000
 3aa:	9b03      	ldr	r3, [sp, #12]
 3ac:	1b5d      	subs	r5, r3, r5
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 3ae:	9b05      	ldr	r3, [sp, #20]
  h[2] = (sword32)h2;
 3b0:	f8cb 5008 	str.w	r5, [fp, #8]
  carry3 = (h3 + (sword64) (1UL<<24)) >> 25; h4 += carry3; h3 -= carry3 << 25;
 3b4:	f00a 4a7e 	and.w	sl, sl, #4261412864	; 0xfe000000
 3b8:	ebb3 050a 	subs.w	r5, r3, sl
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 3bc:	9b06      	ldr	r3, [sp, #24]
  h[3] = (sword32)h3;
 3be:	f8cb 500c 	str.w	r5, [fp, #12]
  carry4 = (h4 + (sword64) (1UL<<25)) >> 26; h5 += carry4; h4 -= carry4 << 26;
 3c2:	f007 457c 	and.w	r5, r7, #4227858432	; 0xfc000000
 3c6:	0ebf      	lsrs	r7, r7, #26
 3c8:	ea47 1783 	orr.w	r7, r7, r3, lsl #6
 3cc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 3ce:	1b64      	subs	r4, r4, r5
 3d0:	18ff      	adds	r7, r7, r3
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 3d2:	9b02      	ldr	r3, [sp, #8]
  h[4] = (sword32)h4;
 3d4:	f8cb 4010 	str.w	r4, [fp, #16]
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 3d8:	9c04      	ldr	r4, [sp, #16]
  h[5] = (sword32)h5;
 3da:	f8cb 7014 	str.w	r7, [fp, #20]
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 3de:	f009 497e 	and.w	r9, r9, #4261412864	; 0xfe000000
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 3e2:	f008 487c 	and.w	r8, r8, #4227858432	; 0xfc000000
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 3e6:	f00e 4e7e 	and.w	lr, lr, #4261412864	; 0xfe000000
  carry6 = (h6 + (sword64) (1UL<<25)) >> 26; h7 += carry6; h6 -= carry6 << 26;
 3ea:	f003 437c 	and.w	r3, r3, #4227858432	; 0xfc000000
 3ee:	1ae3      	subs	r3, r4, r3
  carry7 = (h7 + (sword64) (1UL<<24)) >> 25; h8 += carry7; h7 -= carry7 << 25;
 3f0:	ebb0 0009 	subs.w	r0, r0, r9
  carry8 = (h8 + (sword64) (1UL<<25)) >> 26; h9 += carry8; h8 -= carry8 << 26;
 3f4:	ebb1 0108 	subs.w	r1, r1, r8
  carry9 = (h9 + (sword64) (1UL<<24)) >> 25; h0 += carry9 * 19; h9 -= carry9 << 25;
 3f8:	ebb2 020e 	subs.w	r2, r2, lr
  h[6] = (sword32)h6;
 3fc:	f8cb 3018 	str.w	r3, [fp, #24]
  h[7] = (sword32)h7;
 400:	f8cb 001c 	str.w	r0, [fp, #28]
  h[8] = (sword32)h8;
 404:	f8cb 1020 	str.w	r1, [fp, #32]
  h[9] = (sword32)h9;
 408:	f8cb 2024 	str.w	r2, [fp, #36]	; 0x24
}
 40c:	b017      	add	sp, #92	; 0x5c
 40e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

Disassembly of section .text.fe_pow22523:

00000000 <fe_pow22523>:


void fe_pow22523(fe out,const fe z)
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	b09e      	sub	sp, #120	; 0x78
   4:	460c      	mov	r4, r1
  fe t0 = {0};
   6:	2228      	movs	r2, #40	; 0x28
   8:	2100      	movs	r1, #0
{
   a:	4605      	mov	r5, r0
  fe t0 = {0};
   c:	4668      	mov	r0, sp
   e:	f7ff fffe 	bl	0 <memset>
  fe t1 = {0};
  12:	2228      	movs	r2, #40	; 0x28
  14:	2100      	movs	r1, #0
  16:	eb0d 0002 	add.w	r0, sp, r2
  1a:	f7ff fffe 	bl	0 <memset>
  fe t2 = {0};
  1e:	2228      	movs	r2, #40	; 0x28
  20:	2100      	movs	r1, #0
  22:	a814      	add	r0, sp, #80	; 0x50
  24:	f7ff fffe 	bl	0 <memset>
  int i = 0;

  fe_sq(t0,z); for (i = 1;i < 1;++i) fe_sq(t0,t0);
  28:	4621      	mov	r1, r4
  2a:	4668      	mov	r0, sp
  2c:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t1,t0); for (i = 1;i < 2;++i) fe_sq(t1,t1);
  30:	4669      	mov	r1, sp
  32:	a80a      	add	r0, sp, #40	; 0x28
  34:	f7ff fffe 	bl	0 <fe_pow22523>
  38:	a90a      	add	r1, sp, #40	; 0x28
  3a:	4608      	mov	r0, r1
  3c:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_mul(t1,z,t1);
  40:	aa0a      	add	r2, sp, #40	; 0x28
  42:	4610      	mov	r0, r2
  44:	4621      	mov	r1, r4
  46:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_mul(t0,t0,t1);
  4a:	aa0a      	add	r2, sp, #40	; 0x28
  4c:	4669      	mov	r1, sp
  4e:	4668      	mov	r0, sp
  50:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t0,t0); for (i = 1;i < 1;++i) fe_sq(t0,t0);
  54:	4669      	mov	r1, sp
  56:	4668      	mov	r0, sp
  58:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_mul(t0,t1,t0);
  5c:	466a      	mov	r2, sp
  5e:	a90a      	add	r1, sp, #40	; 0x28
  60:	4668      	mov	r0, sp
  62:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t1,t0); for (i = 1;i < 5;++i) fe_sq(t1,t1);
  66:	4669      	mov	r1, sp
  68:	a80a      	add	r0, sp, #40	; 0x28
  6a:	f7ff fffe 	bl	0 <fe_pow22523>
  6e:	2604      	movs	r6, #4
  70:	a90a      	add	r1, sp, #40	; 0x28
  72:	4608      	mov	r0, r1
  74:	f7ff fffe 	bl	0 <fe_pow22523>
  78:	3e01      	subs	r6, #1
  7a:	d1f9      	bne.n	70 <fe_pow22523+0x70>
  fe_mul(t0,t1,t0);
  7c:	466a      	mov	r2, sp
  7e:	a90a      	add	r1, sp, #40	; 0x28
  80:	4668      	mov	r0, sp
  82:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t1,t0); for (i = 1;i < 10;++i) fe_sq(t1,t1);
  86:	4669      	mov	r1, sp
  88:	a80a      	add	r0, sp, #40	; 0x28
  8a:	f7ff fffe 	bl	0 <fe_pow22523>
  8e:	2609      	movs	r6, #9
  90:	a90a      	add	r1, sp, #40	; 0x28
  92:	4608      	mov	r0, r1
  94:	f7ff fffe 	bl	0 <fe_pow22523>
  98:	3e01      	subs	r6, #1
  9a:	d1f9      	bne.n	90 <fe_pow22523+0x90>
  fe_mul(t1,t1,t0);
  9c:	a90a      	add	r1, sp, #40	; 0x28
  9e:	4608      	mov	r0, r1
  a0:	466a      	mov	r2, sp
  a2:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t2,t1); for (i = 1;i < 20;++i) fe_sq(t2,t2);
  a6:	a90a      	add	r1, sp, #40	; 0x28
  a8:	a814      	add	r0, sp, #80	; 0x50
  aa:	f7ff fffe 	bl	0 <fe_pow22523>
  ae:	2613      	movs	r6, #19
  b0:	a914      	add	r1, sp, #80	; 0x50
  b2:	4608      	mov	r0, r1
  b4:	f7ff fffe 	bl	0 <fe_pow22523>
  b8:	3e01      	subs	r6, #1
  ba:	d1f9      	bne.n	b0 <fe_pow22523+0xb0>
  fe_mul(t1,t2,t1);
  bc:	aa0a      	add	r2, sp, #40	; 0x28
  be:	4610      	mov	r0, r2
  c0:	a914      	add	r1, sp, #80	; 0x50
  c2:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t1,t1); for (i = 1;i < 10;++i) fe_sq(t1,t1);
  c6:	a90a      	add	r1, sp, #40	; 0x28
  c8:	4608      	mov	r0, r1
  ca:	f7ff fffe 	bl	0 <fe_pow22523>
  ce:	2609      	movs	r6, #9
  d0:	a90a      	add	r1, sp, #40	; 0x28
  d2:	4608      	mov	r0, r1
  d4:	f7ff fffe 	bl	0 <fe_pow22523>
  d8:	3e01      	subs	r6, #1
  da:	d1f9      	bne.n	d0 <fe_pow22523+0xd0>
  fe_mul(t0,t1,t0);
  dc:	466a      	mov	r2, sp
  de:	a90a      	add	r1, sp, #40	; 0x28
  e0:	4668      	mov	r0, sp
  e2:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t1,t0); for (i = 1;i < 50;++i) fe_sq(t1,t1);
  e6:	4669      	mov	r1, sp
  e8:	a80a      	add	r0, sp, #40	; 0x28
  ea:	f7ff fffe 	bl	0 <fe_pow22523>
  ee:	2631      	movs	r6, #49	; 0x31
  f0:	a90a      	add	r1, sp, #40	; 0x28
  f2:	4608      	mov	r0, r1
  f4:	f7ff fffe 	bl	0 <fe_pow22523>
  f8:	3e01      	subs	r6, #1
  fa:	d1f9      	bne.n	f0 <fe_pow22523+0xf0>
  fe_mul(t1,t1,t0);
  fc:	a90a      	add	r1, sp, #40	; 0x28
  fe:	4608      	mov	r0, r1
 100:	466a      	mov	r2, sp
 102:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t2,t1); for (i = 1;i < 100;++i) fe_sq(t2,t2);
 106:	a90a      	add	r1, sp, #40	; 0x28
 108:	a814      	add	r0, sp, #80	; 0x50
 10a:	f7ff fffe 	bl	0 <fe_pow22523>
 10e:	2663      	movs	r6, #99	; 0x63
 110:	a914      	add	r1, sp, #80	; 0x50
 112:	4608      	mov	r0, r1
 114:	f7ff fffe 	bl	0 <fe_pow22523>
 118:	3e01      	subs	r6, #1
 11a:	d1f9      	bne.n	110 <fe_pow22523+0x110>
  fe_mul(t1,t2,t1);
 11c:	aa0a      	add	r2, sp, #40	; 0x28
 11e:	4610      	mov	r0, r2
 120:	a914      	add	r1, sp, #80	; 0x50
 122:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t1,t1); for (i = 1;i < 50;++i) fe_sq(t1,t1);
 126:	a90a      	add	r1, sp, #40	; 0x28
 128:	4608      	mov	r0, r1
 12a:	f7ff fffe 	bl	0 <fe_pow22523>
 12e:	2631      	movs	r6, #49	; 0x31
 130:	a90a      	add	r1, sp, #40	; 0x28
 132:	4608      	mov	r0, r1
 134:	f7ff fffe 	bl	0 <fe_pow22523>
 138:	3e01      	subs	r6, #1
 13a:	d1f9      	bne.n	130 <fe_pow22523+0x130>
  fe_mul(t0,t1,t0);
 13c:	466a      	mov	r2, sp
 13e:	a90a      	add	r1, sp, #40	; 0x28
 140:	4668      	mov	r0, sp
 142:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_sq(t0,t0); for (i = 1;i < 2;++i) fe_sq(t0,t0);
 146:	4669      	mov	r1, sp
 148:	4668      	mov	r0, sp
 14a:	f7ff fffe 	bl	0 <fe_pow22523>
 14e:	4669      	mov	r1, sp
 150:	4668      	mov	r0, sp
 152:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_mul(out,t0,z);
 156:	4622      	mov	r2, r4
 158:	4669      	mov	r1, sp
 15a:	4628      	mov	r0, r5
 15c:	f7ff fffe 	bl	0 <fe_pow22523>

  return;
}
 160:	b01e      	add	sp, #120	; 0x78
 162:	bd70      	pop	{r4, r5, r6, pc}

Disassembly of section .text.fe_neg:

00000000 <fe_neg>:
  sword32 f6 = f[6];
  sword32 f7 = f[7];
  sword32 f8 = f[8];
  sword32 f9 = f[9];
  sword32 h0 = -f0;
  sword32 h1 = -f1;
   0:	684b      	ldr	r3, [r1, #4]
{
   2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  sword32 h1 = -f1;
   6:	f1c3 0e00 	rsb	lr, r3, #0
  sword32 h2 = -f2;
   a:	688b      	ldr	r3, [r1, #8]
  sword32 h3 = -f3;
   c:	68cf      	ldr	r7, [r1, #12]
  sword32 h4 = -f4;
   e:	690e      	ldr	r6, [r1, #16]
  sword32 h5 = -f5;
  10:	694d      	ldr	r5, [r1, #20]
  sword32 h6 = -f6;
  12:	698c      	ldr	r4, [r1, #24]
  sword32 h2 = -f2;
  14:	f1c3 0c00 	rsb	ip, r3, #0
  sword32 h7 = -f7;
  18:	69cb      	ldr	r3, [r1, #28]
  1a:	f1c3 0800 	rsb	r8, r3, #0
  sword32 h8 = -f8;
  1e:	6a0b      	ldr	r3, [r1, #32]
  20:	425a      	negs	r2, r3
  sword32 h9 = -f9;
  22:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  sword32 h0 = -f0;
  24:	6809      	ldr	r1, [r1, #0]
  sword32 h3 = -f3;
  26:	427f      	negs	r7, r7
  sword32 h4 = -f4;
  28:	4276      	negs	r6, r6
  sword32 h5 = -f5;
  2a:	426d      	negs	r5, r5
  sword32 h6 = -f6;
  2c:	4264      	negs	r4, r4
  sword32 h9 = -f9;
  2e:	425b      	negs	r3, r3
  sword32 h0 = -f0;
  30:	4249      	negs	r1, r1
  h[0] = h0;
  h[1] = h1;
  32:	e9c0 1e00 	strd	r1, lr, [r0]
  h[2] = h2;
  h[3] = h3;
  36:	e9c0 c702 	strd	ip, r7, [r0, #8]
  h[4] = h4;
  h[5] = h5;
  3a:	e9c0 6504 	strd	r6, r5, [r0, #16]
  h[6] = h6;
  h[7] = h7;
  3e:	e9c0 4806 	strd	r4, r8, [r0, #24]
  h[8] = h8;
  h[9] = h9;
  42:	e9c0 2308 	strd	r2, r3, [r0, #32]
}
  46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.fe_isnonzero:

00000000 <fe_isnonzero>:
*/

static const unsigned char zero[32] = {0};

int fe_isnonzero(const fe f)
{
   0:	b530      	push	{r4, r5, lr}
   2:	b089      	sub	sp, #36	; 0x24
   4:	4601      	mov	r1, r0
  unsigned char s[32];
  fe_tobytes(s,f);
   6:	4668      	mov	r0, sp
   8:	f7ff fffe 	bl	0 <fe_isnonzero>
                                             int length)
{
    int i;
    int compareSum = 0;

    for (i = 0; i < length; i++) {
   c:	4c07      	ldr	r4, [pc, #28]	; (2c <fe_isnonzero+0x2c>)
    int compareSum = 0;
   e:	2300      	movs	r3, #0
    for (i = 0; i < length; i++) {
  10:	461a      	mov	r2, r3
        compareSum |= a[i] ^ b[i];
  12:	f810 1b01 	ldrb.w	r1, [r0], #1
  16:	f814 5b01 	ldrb.w	r5, [r4], #1
    for (i = 0; i < length; i++) {
  1a:	3201      	adds	r2, #1
        compareSum |= a[i] ^ b[i];
  1c:	4069      	eors	r1, r5
    for (i = 0; i < length; i++) {
  1e:	2a20      	cmp	r2, #32
        compareSum |= a[i] ^ b[i];
  20:	ea43 0301 	orr.w	r3, r3, r1
    for (i = 0; i < length; i++) {
  24:	d1f5      	bne.n	12 <fe_isnonzero+0x12>
  return ConstantCompare(s,zero,32);
}
  26:	4618      	mov	r0, r3
  28:	b009      	add	sp, #36	; 0x24
  2a:	bd30      	pop	{r4, r5, pc}
  2c:	00000000 	.word	0x00000000

Disassembly of section .text.fe_isnegative:

00000000 <fe_isnegative>:
Preconditions:
   |f| bounded by 1.1*2^26,1.1*2^25,1.1*2^26,1.1*2^25,etc.
*/

int fe_isnegative(const fe f)
{
   0:	b500      	push	{lr}
   2:	b089      	sub	sp, #36	; 0x24
   4:	4601      	mov	r1, r0
  unsigned char s[32];
  fe_tobytes(s,f);
   6:	4668      	mov	r0, sp
   8:	f7ff fffe 	bl	0 <fe_isnegative>
  return s[0] & 1;
   c:	f89d 0000 	ldrb.w	r0, [sp]
}
  10:	f000 0001 	and.w	r0, r0, #1
  14:	b009      	add	sp, #36	; 0x24
  16:	f85d fb04 	ldr.w	pc, [sp], #4

Disassembly of section .text.fe_cmov:

00000000 <fe_cmov>:

Preconditions: b in {0,1}.
*/

void fe_cmov(fe f, const fe g, int b)
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  sword32 g7 = g[7];
  sword32 g8 = g[8];
  sword32 g9 = g[9];
  sword32 x0 = f0 ^ g0;
  sword32 x1 = f1 ^ g1;
  sword32 x2 = f2 ^ g2;
   4:	6883      	ldr	r3, [r0, #8]
   6:	688c      	ldr	r4, [r1, #8]
{
   8:	9201      	str	r2, [sp, #4]
  sword32 x2 = f2 ^ g2;
   a:	405c      	eors	r4, r3
  sword32 x3 = f3 ^ g3;
   c:	68c2      	ldr	r2, [r0, #12]
   e:	68cb      	ldr	r3, [r1, #12]
  sword32 x0 = f0 ^ g0;
  10:	680e      	ldr	r6, [r1, #0]
  sword32 x1 = f1 ^ g1;
  12:	684d      	ldr	r5, [r1, #4]
  sword32 x3 = f3 ^ g3;
  14:	ea82 0e03 	eor.w	lr, r2, r3
  sword32 x4 = f4 ^ g4;
  18:	690b      	ldr	r3, [r1, #16]
  1a:	6902      	ldr	r2, [r0, #16]
  1c:	ea82 0803 	eor.w	r8, r2, r3
  sword32 x5 = f5 ^ g5;
  20:	694b      	ldr	r3, [r1, #20]
  22:	6942      	ldr	r2, [r0, #20]
  24:	ea82 0903 	eor.w	r9, r2, r3
  sword32 x6 = f6 ^ g6;
  28:	698b      	ldr	r3, [r1, #24]
  2a:	6982      	ldr	r2, [r0, #24]
  2c:	ea82 0a03 	eor.w	sl, r2, r3
  sword32 x7 = f7 ^ g7;
  30:	69cb      	ldr	r3, [r1, #28]
  32:	69c2      	ldr	r2, [r0, #28]
  34:	ea82 0b03 	eor.w	fp, r2, r3
  sword32 x8 = f8 ^ g8;
  38:	6a0b      	ldr	r3, [r1, #32]
  3a:	6a02      	ldr	r2, [r0, #32]
  sword32 x9 = f9 ^ g9;
  3c:	6a49      	ldr	r1, [r1, #36]	; 0x24
  sword32 x8 = f8 ^ g8;
  3e:	4053      	eors	r3, r2
  sword32 x9 = f9 ^ g9;
  40:	6a42      	ldr	r2, [r0, #36]	; 0x24
  sword32 f1 = f[1];
  42:	e9d0 c700 	ldrd	ip, r7, [r0]
  sword32 x9 = f9 ^ g9;
  46:	4051      	eors	r1, r2
  b = -b;
  48:	9a01      	ldr	r2, [sp, #4]
  sword32 x1 = f1 ^ g1;
  4a:	407d      	eors	r5, r7
  b = -b;
  4c:	4252      	negs	r2, r2
  x0 &= b;
  x1 &= b;
  4e:	4015      	ands	r5, r2
  x6 &= b;
  x7 &= b;
  x8 &= b;
  x9 &= b;
  f[0] = f0 ^ x0;
  f[1] = f1 ^ x1;
  50:	407d      	eors	r5, r7
  52:	6045      	str	r5, [r0, #4]
  f[2] = f2 ^ x2;
  54:	6885      	ldr	r5, [r0, #8]
  x2 &= b;
  56:	4014      	ands	r4, r2
  f[2] = f2 ^ x2;
  58:	406c      	eors	r4, r5
  5a:	6084      	str	r4, [r0, #8]
  f[3] = f3 ^ x3;
  5c:	68c4      	ldr	r4, [r0, #12]
  x3 &= b;
  5e:	ea0e 0e02 	and.w	lr, lr, r2
  f[3] = f3 ^ x3;
  62:	ea8e 0404 	eor.w	r4, lr, r4
  66:	60c4      	str	r4, [r0, #12]
  f[4] = f4 ^ x4;
  68:	6904      	ldr	r4, [r0, #16]
  x4 &= b;
  6a:	ea08 0802 	and.w	r8, r8, r2
  f[4] = f4 ^ x4;
  6e:	ea88 0404 	eor.w	r4, r8, r4
  72:	6104      	str	r4, [r0, #16]
  sword32 x0 = f0 ^ g0;
  74:	ea8c 0606 	eor.w	r6, ip, r6
  f[5] = f5 ^ x5;
  78:	6944      	ldr	r4, [r0, #20]
  x5 &= b;
  7a:	ea09 0902 	and.w	r9, r9, r2
  x0 &= b;
  7e:	4016      	ands	r6, r2
  f[5] = f5 ^ x5;
  80:	ea89 0404 	eor.w	r4, r9, r4
  f[0] = f0 ^ x0;
  84:	ea86 060c 	eor.w	r6, r6, ip
  88:	6006      	str	r6, [r0, #0]
  f[5] = f5 ^ x5;
  8a:	6144      	str	r4, [r0, #20]
  f[6] = f6 ^ x6;
  8c:	6984      	ldr	r4, [r0, #24]
  x6 &= b;
  8e:	ea0a 0a02 	and.w	sl, sl, r2
  f[6] = f6 ^ x6;
  92:	ea8a 0404 	eor.w	r4, sl, r4
  96:	6184      	str	r4, [r0, #24]
  f[7] = f7 ^ x7;
  98:	69c4      	ldr	r4, [r0, #28]
  x7 &= b;
  9a:	ea0b 0b02 	and.w	fp, fp, r2
  f[7] = f7 ^ x7;
  9e:	ea8b 0404 	eor.w	r4, fp, r4
  a2:	61c4      	str	r4, [r0, #28]
  f[8] = f8 ^ x8;
  a4:	6a04      	ldr	r4, [r0, #32]
  x8 &= b;
  a6:	4013      	ands	r3, r2
  f[8] = f8 ^ x8;
  a8:	4063      	eors	r3, r4
  aa:	6203      	str	r3, [r0, #32]
  f[9] = f9 ^ x9;
  ac:	6a43      	ldr	r3, [r0, #36]	; 0x24
  x9 &= b;
  ae:	400a      	ands	r2, r1
  f[9] = f9 ^ x9;
  b0:	405a      	eors	r2, r3
  b2:	6242      	str	r2, [r0, #36]	; 0x24
}
  b4:	b003      	add	sp, #12
  b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

ge_448.o:     file format elf32-littlearm


ge_low_mem.o:     file format elf32-littlearm


ge_operations.o:     file format elf32-littlearm


Disassembly of section .text.slide:

00000000 <slide>:

#define SLIDE_SIZE 256

/* ge double scalar mult */
static void slide(signed char *r,const unsigned char *a)
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  int i;
  int b;
  int k;

  for (i = 0;i < SLIDE_SIZE;++i)
   4:	2300      	movs	r3, #0
    r[i] = 1 & (a[i >> 3] >> (i & 7));
   6:	10da      	asrs	r2, r3, #3
   8:	f003 0407 	and.w	r4, r3, #7
   c:	5c8a      	ldrb	r2, [r1, r2]
   e:	4122      	asrs	r2, r4
  10:	f002 0201 	and.w	r2, r2, #1
  14:	54c2      	strb	r2, [r0, r3]
  for (i = 0;i < SLIDE_SIZE;++i)
  16:	3301      	adds	r3, #1
  18:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  1c:	d1f3      	bne.n	6 <slide+0x6>
  1e:	2201      	movs	r2, #1
  20:	1e41      	subs	r1, r0, #1
  22:	f500 7c80 	add.w	ip, r0, #256	; 0x100
            for (k = i + b;k < SLIDE_SIZE;++k) {
              if (!r[k]) {
                r[k] = 1;
                break;
              }
              r[k] = 0;
  26:	2700      	movs	r7, #0
                r[k] = 1;
  28:	4696      	mov	lr, r2
  for (i = 0;i < SLIDE_SIZE;++i)
  2a:	f240 1801 	movw	r8, #257	; 0x101
    if (r[i]) {
  2e:	f911 3f01 	ldrsb.w	r3, [r1, #1]!
  32:	bb73      	cbnz	r3, 92 <slide+0x92>
  for (i = 0;i < SLIDE_SIZE;++i)
  34:	3201      	adds	r2, #1
  36:	4542      	cmp	r2, r8
  38:	d1f9      	bne.n	2e <slide+0x2e>
          } else
            break;
        }
      }
    }
}
  3a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (r[i + b]) {
  3e:	56c5      	ldrsb	r5, [r0, r3]
  40:	b155      	cbz	r5, 58 <slide+0x58>
          if (r[i] + (r[i + b] << b) <= 15) {
  42:	f991 4000 	ldrsb.w	r4, [r1]
  46:	40b5      	lsls	r5, r6
  48:	eb04 0905 	add.w	r9, r4, r5
  4c:	f1b9 0f0f 	cmp.w	r9, #15
  50:	dc0a      	bgt.n	68 <slide+0x68>
            r[i] += (signed char)(r[i + b] << b); r[i + b] = 0;
  52:	f881 9000 	strb.w	r9, [r1]
  56:	54c7      	strb	r7, [r0, r3]
      for (b = 1;b <= 6 && i + b < SLIDE_SIZE;++b) {
  58:	3601      	adds	r6, #1
  5a:	2e07      	cmp	r6, #7
  5c:	f103 0301 	add.w	r3, r3, #1
  60:	d0e8      	beq.n	34 <slide+0x34>
  62:	2bff      	cmp	r3, #255	; 0xff
  64:	ddeb      	ble.n	3e <slide+0x3e>
  66:	e7e5      	b.n	34 <slide+0x34>
          } else if (r[i] - (r[i + b] << b) >= -15) {
  68:	1b64      	subs	r4, r4, r5
  6a:	f114 0f0f 	cmn.w	r4, #15
  6e:	dbe1      	blt.n	34 <slide+0x34>
            r[i] -= (signed char)(r[i + b] << b);
  70:	700c      	strb	r4, [r1, #0]
            for (k = i + b;k < SLIDE_SIZE;++k) {
  72:	181c      	adds	r4, r3, r0
              if (!r[k]) {
  74:	4625      	mov	r5, r4
  76:	3401      	adds	r4, #1
  78:	f995 9000 	ldrsb.w	r9, [r5]
  7c:	f1b9 0f00 	cmp.w	r9, #0
  80:	d102      	bne.n	88 <slide+0x88>
                r[k] = 1;
  82:	f885 e000 	strb.w	lr, [r5]
                break;
  86:	e7e7      	b.n	58 <slide+0x58>
            for (k = i + b;k < SLIDE_SIZE;++k) {
  88:	45a4      	cmp	ip, r4
              r[k] = 0;
  8a:	f804 7c01 	strb.w	r7, [r4, #-1]
            for (k = i + b;k < SLIDE_SIZE;++k) {
  8e:	d1f1      	bne.n	74 <slide+0x74>
  90:	e7e2      	b.n	58 <slide+0x58>
  92:	4613      	mov	r3, r2
      for (b = 1;b <= 6 && i + b < SLIDE_SIZE;++b) {
  94:	2601      	movs	r6, #1
  96:	e7e4      	b.n	62 <slide+0x62>

Disassembly of section .text.ge_p1p1_to_p2:

00000000 <ge_p1p1_to_p2>:
r = p
*/

#ifndef CURVED25519_ASM
static void ge_p1p1_to_p2(ge_p2 *r,const ge_p1p1 *p)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  fe_mul(r->X,p->X,p->T);
   2:	f101 0778 	add.w	r7, r1, #120	; 0x78
{
   6:	460c      	mov	r4, r1
   8:	4605      	mov	r5, r0
  fe_mul(r->X,p->X,p->T);
   a:	463a      	mov	r2, r7
  fe_mul(r->Y,p->Y,p->Z);
   c:	f104 0650 	add.w	r6, r4, #80	; 0x50
  fe_mul(r->X,p->X,p->T);
  10:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(r->Y,p->Y,p->Z);
  14:	4632      	mov	r2, r6
  16:	f104 0128 	add.w	r1, r4, #40	; 0x28
  1a:	f105 0028 	add.w	r0, r5, #40	; 0x28
  1e:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(r->Z,p->Z,p->T);
  22:	463a      	mov	r2, r7
  24:	4631      	mov	r1, r6
  26:	f105 0050 	add.w	r0, r5, #80	; 0x50
}
  2a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  fe_mul(r->Z,p->Z,p->T);
  2e:	f7ff bffe 	b.w	0 <fe_mul>

Disassembly of section .text.ge_madd:

00000000 <ge_madd>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	4605      	mov	r5, r0
    fe_add(r->X,p->Y,p->X);
   6:	f101 0828 	add.w	r8, r1, #40	; 0x28
{
   a:	b08b      	sub	sp, #44	; 0x2c
    fe_sub(r->Y,p->Y,p->X);
   c:	f105 0628 	add.w	r6, r5, #40	; 0x28
{
  10:	460c      	mov	r4, r1
  12:	4617      	mov	r7, r2
    fe_add(r->X,p->Y,p->X);
  14:	460a      	mov	r2, r1
  16:	4641      	mov	r1, r8
  18:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->Y,p->Y,p->X);
  1c:	4622      	mov	r2, r4
  1e:	4641      	mov	r1, r8
  20:	4630      	mov	r0, r6
    fe_mul(r->Z,r->X,q->yplusx);
  22:	f105 0850 	add.w	r8, r5, #80	; 0x50
    fe_sub(r->Y,p->Y,p->X);
  26:	f7ff fffe 	bl	0 <fe_sub>
    fe_mul(r->Z,r->X,q->yplusx);
  2a:	463a      	mov	r2, r7
  2c:	4629      	mov	r1, r5
  2e:	4640      	mov	r0, r8
  30:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->T,q->xy2d,p->T);
  34:	f105 0978 	add.w	r9, r5, #120	; 0x78
    fe_mul(r->Y,r->Y,q->yminusx);
  38:	f107 0228 	add.w	r2, r7, #40	; 0x28
  3c:	4631      	mov	r1, r6
  3e:	4630      	mov	r0, r6
  40:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->T,q->xy2d,p->T);
  44:	f104 0278 	add.w	r2, r4, #120	; 0x78
  48:	f107 0150 	add.w	r1, r7, #80	; 0x50
  4c:	4648      	mov	r0, r9
  4e:	f7ff fffe 	bl	0 <fe_mul>
    fe_add(t0,p->Z,p->Z);
  52:	f104 0250 	add.w	r2, r4, #80	; 0x50
  56:	4611      	mov	r1, r2
  58:	4668      	mov	r0, sp
  5a:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->X,r->Z,r->Y);
  5e:	4632      	mov	r2, r6
  60:	4641      	mov	r1, r8
  62:	4628      	mov	r0, r5
  64:	f7ff fffe 	bl	0 <fe_sub>
    fe_add(r->Y,r->Z,r->Y);
  68:	4632      	mov	r2, r6
  6a:	4641      	mov	r1, r8
  6c:	4630      	mov	r0, r6
  6e:	f7ff fffe 	bl	0 <fe_add>
    fe_add(r->Z,t0,r->T);
  72:	464a      	mov	r2, r9
  74:	4669      	mov	r1, sp
  76:	4640      	mov	r0, r8
  78:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->T,t0,r->T);
  7c:	464a      	mov	r2, r9
  7e:	4669      	mov	r1, sp
  80:	4648      	mov	r0, r9
  82:	f7ff fffe 	bl	0 <fe_sub>
}
  86:	b00b      	add	sp, #44	; 0x2c
  88:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.ge_p1p1_to_p3:

00000000 <ge_p1p1_to_p3>:
r = p
*/

#ifndef CURVED25519_ASM
static WC_INLINE void ge_p1p1_to_p3(ge_p3 *r,const ge_p1p1 *p)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460c      	mov	r4, r1
  fe_mul(r->X,p->X,p->T);
   6:	f101 0878 	add.w	r8, r1, #120	; 0x78
{
   a:	4605      	mov	r5, r0
  fe_mul(r->X,p->X,p->T);
   c:	4642      	mov	r2, r8
  fe_mul(r->Y,p->Y,p->Z);
   e:	f104 0628 	add.w	r6, r4, #40	; 0x28
  12:	f104 0750 	add.w	r7, r4, #80	; 0x50
  fe_mul(r->X,p->X,p->T);
  16:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(r->Y,p->Y,p->Z);
  1a:	463a      	mov	r2, r7
  1c:	4631      	mov	r1, r6
  1e:	f105 0028 	add.w	r0, r5, #40	; 0x28
  22:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(r->Z,p->Z,p->T);
  26:	4642      	mov	r2, r8
  28:	4639      	mov	r1, r7
  2a:	f105 0050 	add.w	r0, r5, #80	; 0x50
  2e:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(r->T,p->X,p->Y);
  32:	4632      	mov	r2, r6
  34:	4621      	mov	r1, r4
  36:	f105 0078 	add.w	r0, r5, #120	; 0x78
}
  3a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  fe_mul(r->T,p->X,p->Y);
  3e:	f7ff bffe 	b.w	0 <fe_mul>

Disassembly of section .text.ge_add:

00000000 <ge_add>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	4604      	mov	r4, r0
    fe_add(r->X,p->Y,p->X);
   6:	f101 0828 	add.w	r8, r1, #40	; 0x28
{
   a:	b08b      	sub	sp, #44	; 0x2c
    fe_sub(r->Y,p->Y,p->X);
   c:	f104 0728 	add.w	r7, r4, #40	; 0x28
{
  10:	4616      	mov	r6, r2
  12:	460d      	mov	r5, r1
    fe_add(r->X,p->Y,p->X);
  14:	460a      	mov	r2, r1
  16:	4641      	mov	r1, r8
  18:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->Y,p->Y,p->X);
  1c:	462a      	mov	r2, r5
  1e:	4641      	mov	r1, r8
  20:	4638      	mov	r0, r7
    fe_mul(r->Z,r->X,q->YplusX);
  22:	f104 0850 	add.w	r8, r4, #80	; 0x50
    fe_sub(r->Y,p->Y,p->X);
  26:	f7ff fffe 	bl	0 <fe_sub>
    fe_mul(r->Z,r->X,q->YplusX);
  2a:	4632      	mov	r2, r6
  2c:	4621      	mov	r1, r4
  2e:	4640      	mov	r0, r8
  30:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->T,q->T2d,p->T);
  34:	f104 0978 	add.w	r9, r4, #120	; 0x78
    fe_mul(r->Y,r->Y,q->YminusX);
  38:	f106 0228 	add.w	r2, r6, #40	; 0x28
  3c:	4639      	mov	r1, r7
  3e:	4638      	mov	r0, r7
  40:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->T,q->T2d,p->T);
  44:	f105 0278 	add.w	r2, r5, #120	; 0x78
  48:	f106 0178 	add.w	r1, r6, #120	; 0x78
  4c:	4648      	mov	r0, r9
  4e:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->X,p->Z,q->Z);
  52:	f106 0250 	add.w	r2, r6, #80	; 0x50
  56:	f105 0150 	add.w	r1, r5, #80	; 0x50
  5a:	4620      	mov	r0, r4
  5c:	f7ff fffe 	bl	0 <fe_mul>
    fe_add(t0,r->X,r->X);
  60:	4622      	mov	r2, r4
  62:	4621      	mov	r1, r4
  64:	4668      	mov	r0, sp
  66:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->X,r->Z,r->Y);
  6a:	463a      	mov	r2, r7
  6c:	4641      	mov	r1, r8
  6e:	4620      	mov	r0, r4
  70:	f7ff fffe 	bl	0 <fe_sub>
    fe_add(r->Y,r->Z,r->Y);
  74:	463a      	mov	r2, r7
  76:	4641      	mov	r1, r8
  78:	4638      	mov	r0, r7
  7a:	f7ff fffe 	bl	0 <fe_add>
    fe_add(r->Z,t0,r->T);
  7e:	464a      	mov	r2, r9
  80:	4669      	mov	r1, sp
  82:	4640      	mov	r0, r8
  84:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->T,t0,r->T);
  88:	464a      	mov	r2, r9
  8a:	4669      	mov	r1, sp
  8c:	4648      	mov	r0, r9
  8e:	f7ff fffe 	bl	0 <fe_sub>
}
  92:	b00b      	add	sp, #44	; 0x2c
  94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.ge_p3_to_cached:

00000000 <ge_p3_to_cached>:
} ;
#endif


static WC_INLINE void ge_p3_to_cached(ge_cached *r,const ge_p3 *p)
{
   0:	b570      	push	{r4, r5, r6, lr}
  fe_add(r->YplusX,p->Y,p->X);
   2:	f101 0628 	add.w	r6, r1, #40	; 0x28
{
   6:	4605      	mov	r5, r0
   8:	460c      	mov	r4, r1
  fe_add(r->YplusX,p->Y,p->X);
   a:	460a      	mov	r2, r1
   c:	4631      	mov	r1, r6
   e:	f7ff fffe 	bl	0 <fe_add>
  fe_sub(r->YminusX,p->Y,p->X);
  12:	4622      	mov	r2, r4
  14:	4631      	mov	r1, r6
  16:	f105 0028 	add.w	r0, r5, #40	; 0x28
  1a:	f7ff fffe 	bl	0 <fe_sub>
  fe_copy(r->Z,p->Z);
  1e:	f104 0150 	add.w	r1, r4, #80	; 0x50
  22:	f105 0050 	add.w	r0, r5, #80	; 0x50
  26:	f7ff fffe 	bl	0 <fe_copy>
  fe_mul(r->T2d,p->T,d2);
  2a:	f104 0178 	add.w	r1, r4, #120	; 0x78
  2e:	f105 0078 	add.w	r0, r5, #120	; 0x78
  32:	4a02      	ldr	r2, [pc, #8]	; (3c <ge_p3_to_cached+0x3c>)
}
  34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  fe_mul(r->T2d,p->T,d2);
  38:	f7ff bffe 	b.w	0 <fe_mul>
  3c:	00000000 	.word	0x00000000

Disassembly of section .text.ge_p2_dbl:

00000000 <ge_p2_dbl>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   4:	4604      	mov	r4, r0
   6:	460e      	mov	r6, r1
   8:	b08b      	sub	sp, #44	; 0x2c
    fe_sq(r->Z,p->Y);
   a:	f104 0550 	add.w	r5, r4, #80	; 0x50
   e:	f106 0928 	add.w	r9, r6, #40	; 0x28
    fe_sq(r->X,p->X);
  12:	f7ff fffe 	bl	0 <fe_sq>
    fe_sq2(r->T,p->Z);
  16:	f104 0878 	add.w	r8, r4, #120	; 0x78
    fe_sq(r->Z,p->Y);
  1a:	4649      	mov	r1, r9
  1c:	4628      	mov	r0, r5
  1e:	f7ff fffe 	bl	0 <fe_sq>
    fe_add(r->Y,p->X,p->Y);
  22:	f104 0728 	add.w	r7, r4, #40	; 0x28
    fe_sq2(r->T,p->Z);
  26:	f106 0150 	add.w	r1, r6, #80	; 0x50
  2a:	4640      	mov	r0, r8
  2c:	f7ff fffe 	bl	0 <fe_sq2>
    fe_add(r->Y,p->X,p->Y);
  30:	464a      	mov	r2, r9
  32:	4631      	mov	r1, r6
  34:	4638      	mov	r0, r7
  36:	f7ff fffe 	bl	0 <fe_add>
    fe_sq(t0,r->Y);
  3a:	4639      	mov	r1, r7
  3c:	4668      	mov	r0, sp
  3e:	f7ff fffe 	bl	0 <fe_sq>
    fe_add(r->Y,r->Z,r->X);
  42:	4622      	mov	r2, r4
  44:	4629      	mov	r1, r5
  46:	4638      	mov	r0, r7
  48:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->Z,r->Z,r->X);
  4c:	4622      	mov	r2, r4
  4e:	4629      	mov	r1, r5
  50:	4628      	mov	r0, r5
  52:	f7ff fffe 	bl	0 <fe_sub>
    fe_sub(r->X,t0,r->Y);
  56:	463a      	mov	r2, r7
  58:	4669      	mov	r1, sp
  5a:	4620      	mov	r0, r4
  5c:	f7ff fffe 	bl	0 <fe_sub>
    fe_sub(r->T,r->T,r->Z);
  60:	462a      	mov	r2, r5
  62:	4641      	mov	r1, r8
  64:	4640      	mov	r0, r8
  66:	f7ff fffe 	bl	0 <fe_sub>
}
  6a:	b00b      	add	sp, #44	; 0x2c
  6c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

Disassembly of section .text.ge_p3_dbl:

00000000 <ge_p3_dbl>:
{
   0:	b530      	push	{r4, r5, lr}
   2:	b09f      	sub	sp, #124	; 0x7c
   4:	460c      	mov	r4, r1
   6:	4605      	mov	r5, r0
*/

#ifndef CURVED25519_ASM
static void ge_p3_to_p2(ge_p2 *r,const ge_p3 *p)
{
  fe_copy(r->X,p->X);
   8:	4668      	mov	r0, sp
   a:	f7ff fffe 	bl	0 <fe_copy>
  fe_copy(r->Y,p->Y);
   e:	f104 0128 	add.w	r1, r4, #40	; 0x28
  12:	a80a      	add	r0, sp, #40	; 0x28
  14:	f7ff fffe 	bl	0 <fe_copy>
  fe_copy(r->Z,p->Z);
  18:	f104 0150 	add.w	r1, r4, #80	; 0x50
  1c:	a814      	add	r0, sp, #80	; 0x50
  1e:	f7ff fffe 	bl	0 <fe_copy>
    ge_p2_dbl(r,&q);
  22:	4669      	mov	r1, sp
  24:	4628      	mov	r0, r5
  26:	f7ff fffe 	bl	0 <ge_p3_dbl>
}
  2a:	b01f      	add	sp, #124	; 0x7c
  2c:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.cmov:

00000000 <cmov>:
{
   0:	b570      	push	{r4, r5, r6, lr}
  word32 y = x; /* 0: yes; 1..255: no */
   2:	ea82 0403 	eor.w	r4, r2, r3
  y -= 1; /* 4294967295: yes; 0..254: no */
   6:	3c01      	subs	r4, #1
  y >>= 31; /* 1: yes; 0: no */
   8:	0fe4      	lsrs	r4, r4, #31
{
   a:	4605      	mov	r5, r0
   c:	460e      	mov	r6, r1
  fe_cmov(t->yplusx,u->yplusx,b);
   e:	4622      	mov	r2, r4
  10:	f7ff fffe 	bl	0 <fe_cmov>
  fe_cmov(t->yminusx,u->yminusx,b);
  14:	4622      	mov	r2, r4
  16:	f106 0128 	add.w	r1, r6, #40	; 0x28
  1a:	f105 0028 	add.w	r0, r5, #40	; 0x28
  1e:	f7ff fffe 	bl	0 <fe_cmov>
  fe_cmov(t->xy2d,u->xy2d,b);
  22:	4622      	mov	r2, r4
  24:	f106 0150 	add.w	r1, r6, #80	; 0x50
  28:	f105 0050 	add.w	r0, r5, #80	; 0x50
}
  2c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  fe_cmov(t->xy2d,u->xy2d,b);
  30:	f7ff bffe 	b.w	0 <fe_cmov>

Disassembly of section .text.ge_select:

00000000 <ge_select>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	4606      	mov	r6, r0
  unsigned char babs = (unsigned char)(b - (((-bnegative) & b) << 1));
   6:	ea02 74e2 	and.w	r4, r2, r2, asr #31
{
   a:	b09e      	sub	sp, #120	; 0x78
  return ((unsigned char)b) >> 7;
   c:	0fd7      	lsrs	r7, r2, #31
#if defined(HAVE_ED25519_SIGN) || defined(HAVE_ED25519_MAKE_KEY)
/* ge_precomp_0 */
static void ge_precomp_0(ge_precomp *h)
{
  fe_1(h->yplusx);
  fe_1(h->yminusx);
   e:	f106 0928 	add.w	r9, r6, #40	; 0x28
  unsigned char babs = (unsigned char)(b - (((-bnegative) & b) << 1));
  12:	eba2 0244 	sub.w	r2, r2, r4, lsl #1
  16:	f002 04ff 	and.w	r4, r2, #255	; 0xff
{
  1a:	460d      	mov	r5, r1
  fe_0(h->xy2d);
  1c:	f106 0850 	add.w	r8, r6, #80	; 0x50
  fe_1(h->yplusx);
  20:	f7ff fffe 	bl	0 <fe_1>
  fe_1(h->yminusx);
  24:	4648      	mov	r0, r9
  26:	f7ff fffe 	bl	0 <fe_1>
  fe_0(h->xy2d);
  2a:	4640      	mov	r0, r8
  cmov(t,&base[pos][0],babs,1);
  2c:	f8df a0ac 	ldr.w	sl, [pc, #172]	; dc <ge_select+0xdc>
  fe_0(h->xy2d);
  30:	f7ff fffe 	bl	0 <fe_0>
  cmov(t,&base[pos][0],babs,1);
  34:	f44f 7170 	mov.w	r1, #960	; 0x3c0
  38:	434d      	muls	r5, r1
  3a:	4622      	mov	r2, r4
  3c:	eb0a 0105 	add.w	r1, sl, r5
  40:	4630      	mov	r0, r6
  42:	2301      	movs	r3, #1
  44:	f7ff fffe 	bl	0 <ge_select>
  cmov(t,&base[pos][1],babs,2);
  48:	f105 0178 	add.w	r1, r5, #120	; 0x78
  4c:	4622      	mov	r2, r4
  4e:	4451      	add	r1, sl
  50:	4630      	mov	r0, r6
  52:	2302      	movs	r3, #2
  54:	f7ff fffe 	bl	0 <ge_select>
  cmov(t,&base[pos][2],babs,3);
  58:	f105 01f0 	add.w	r1, r5, #240	; 0xf0
  5c:	4622      	mov	r2, r4
  5e:	4451      	add	r1, sl
  60:	4630      	mov	r0, r6
  62:	2303      	movs	r3, #3
  64:	f7ff fffe 	bl	0 <ge_select>
  cmov(t,&base[pos][3],babs,4);
  68:	f505 71b4 	add.w	r1, r5, #360	; 0x168
  6c:	4622      	mov	r2, r4
  6e:	4451      	add	r1, sl
  70:	4630      	mov	r0, r6
  72:	2304      	movs	r3, #4
  74:	f7ff fffe 	bl	0 <ge_select>
  cmov(t,&base[pos][4],babs,5);
  78:	f505 71f0 	add.w	r1, r5, #480	; 0x1e0
  7c:	4622      	mov	r2, r4
  7e:	4451      	add	r1, sl
  80:	4630      	mov	r0, r6
  82:	2305      	movs	r3, #5
  84:	f7ff fffe 	bl	0 <ge_select>
  cmov(t,&base[pos][5],babs,6);
  88:	f505 7116 	add.w	r1, r5, #600	; 0x258
  8c:	4622      	mov	r2, r4
  8e:	4451      	add	r1, sl
  90:	4630      	mov	r0, r6
  92:	2306      	movs	r3, #6
  94:	f7ff fffe 	bl	0 <ge_select>
  cmov(t,&base[pos][6],babs,7);
  98:	f505 7134 	add.w	r1, r5, #720	; 0x2d0
  9c:	4622      	mov	r2, r4
  9e:	4451      	add	r1, sl
  a0:	4630      	mov	r0, r6
  a2:	2307      	movs	r3, #7
  a4:	f7ff fffe 	bl	0 <ge_select>
  cmov(t,&base[pos][7],babs,8);
  a8:	f505 7152 	add.w	r1, r5, #840	; 0x348
  ac:	2308      	movs	r3, #8
  ae:	4622      	mov	r2, r4
  b0:	4451      	add	r1, sl
  b2:	4630      	mov	r0, r6
  b4:	f7ff fffe 	bl	0 <ge_select>
  fe_cswap(t->yminusx, t->yplusx, bnegative);
  b8:	463a      	mov	r2, r7
  ba:	4631      	mov	r1, r6
  bc:	4648      	mov	r0, r9
  be:	f7ff fffe 	bl	0 <fe_cswap>
  fe_neg(minust.xy2d,t->xy2d);
  c2:	4641      	mov	r1, r8
  c4:	a814      	add	r0, sp, #80	; 0x50
  c6:	f7ff fffe 	bl	0 <fe_neg>
  fe_cmov(t->xy2d,minust.xy2d,bnegative);
  ca:	463a      	mov	r2, r7
  cc:	a914      	add	r1, sp, #80	; 0x50
  ce:	4640      	mov	r0, r8
  d0:	f7ff fffe 	bl	0 <fe_cmov>
}
  d4:	b01e      	add	sp, #120	; 0x78
  d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  da:	bf00      	nop
  dc:	00000000 	.word	0x00000000

Disassembly of section .text.sc_reduce:

00000000 <sc_reduce>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b099      	sub	sp, #100	; 0x64
   6:	4604      	mov	r4, r0
    t[ 0] = MASK_21 & (load_3(s +  0) >> 0);
   8:	f7ff fffe 	bl	0 <load_3>
   c:	900f      	str	r0, [sp, #60]	; 0x3c
    t[ 1] = MASK_21 & (load_4(s +  2) >> 5);
   e:	1ca0      	adds	r0, r4, #2
  10:	f7ff fffe 	bl	0 <load_4>
  14:	9010      	str	r0, [sp, #64]	; 0x40
    t[ 2] = MASK_21 & (load_3(s +  5) >> 2);
  16:	1d60      	adds	r0, r4, #5
  18:	f7ff fffe 	bl	0 <load_3>
  1c:	9011      	str	r0, [sp, #68]	; 0x44
    t[ 3] = MASK_21 & (load_4(s +  7) >> 7);
  1e:	1de0      	adds	r0, r4, #7
  20:	f7ff fffe 	bl	0 <load_4>
  24:	9012      	str	r0, [sp, #72]	; 0x48
    t[ 4] = MASK_21 & (load_4(s + 10) >> 4);
  26:	f104 000a 	add.w	r0, r4, #10
  2a:	f7ff fffe 	bl	0 <load_4>
  2e:	9013      	str	r0, [sp, #76]	; 0x4c
    t[ 5] = MASK_21 & (load_3(s + 13) >> 1);
  30:	f104 000d 	add.w	r0, r4, #13
  34:	f7ff fffe 	bl	0 <load_3>
  38:	9014      	str	r0, [sp, #80]	; 0x50
    t[ 6] = MASK_21 & (load_4(s + 15) >> 6);
  3a:	f104 000f 	add.w	r0, r4, #15
  3e:	f7ff fffe 	bl	0 <load_4>
  42:	9007      	str	r0, [sp, #28]
    t[ 7] = MASK_21 & (load_3(s + 18) >> 3);
  44:	f104 0012 	add.w	r0, r4, #18
  48:	f7ff fffe 	bl	0 <load_3>
  4c:	900a      	str	r0, [sp, #40]	; 0x28
    t[ 8] = MASK_21 & (load_3(s + 21) >> 0);
  4e:	f104 0015 	add.w	r0, r4, #21
  52:	f7ff fffe 	bl	0 <load_3>
  56:	9008      	str	r0, [sp, #32]
    t[ 9] = MASK_21 & (load_4(s + 23) >> 5);
  58:	f104 0017 	add.w	r0, r4, #23
  5c:	f7ff fffe 	bl	0 <load_4>
  60:	900c      	str	r0, [sp, #48]	; 0x30
    t[10] = MASK_21 & (load_3(s + 26) >> 2);
  62:	f104 001a 	add.w	r0, r4, #26
  66:	f7ff fffe 	bl	0 <load_3>
  6a:	9009      	str	r0, [sp, #36]	; 0x24
    t[11] = MASK_21 & (load_4(s + 28) >> 7);
  6c:	f104 001c 	add.w	r0, r4, #28
  70:	f7ff fffe 	bl	0 <load_4>
  74:	900e      	str	r0, [sp, #56]	; 0x38
    t[12] = MASK_21 & (load_4(s + 31) >> 4);
  76:	f104 001f 	add.w	r0, r4, #31
  7a:	f7ff fffe 	bl	0 <load_4>
  7e:	9005      	str	r0, [sp, #20]
    t[13] = MASK_21 & (load_3(s + 34) >> 1);
  80:	f104 0022 	add.w	r0, r4, #34	; 0x22
  84:	f7ff fffe 	bl	0 <load_3>
  88:	9015      	str	r0, [sp, #84]	; 0x54
    t[14] = MASK_21 & (load_4(s + 36) >> 6);
  8a:	f104 0024 	add.w	r0, r4, #36	; 0x24
  8e:	f7ff fffe 	bl	0 <load_4>
  92:	4605      	mov	r5, r0
    t[15] = MASK_21 & (load_3(s + 39) >> 3);
  94:	f104 0027 	add.w	r0, r4, #39	; 0x27
  98:	f7ff fffe 	bl	0 <load_3>
  9c:	9016      	str	r0, [sp, #88]	; 0x58
    t[16] = MASK_21 & (load_3(s + 42) >> 0);
  9e:	f104 002a 	add.w	r0, r4, #42	; 0x2a
  a2:	f7ff fffe 	bl	0 <load_3>
  a6:	9001      	str	r0, [sp, #4]
    t[17] = MASK_21 & (load_4(s + 44) >> 5);
  a8:	f104 002c 	add.w	r0, r4, #44	; 0x2c
  ac:	f7ff fffe 	bl	0 <load_4>
  b0:	9017      	str	r0, [sp, #92]	; 0x5c
    t[18] = MASK_21 & (load_3(s + 47) >> 2);
  b2:	f104 002f 	add.w	r0, r4, #47	; 0x2f
  b6:	f7ff fffe 	bl	0 <load_3>
  ba:	f3c0 0994 	ubfx	r9, r0, #2, #21
    t[19] = MASK_21 & (load_4(s + 49) >> 7);
  be:	f104 0031 	add.w	r0, r4, #49	; 0x31
  c2:	f7ff fffe 	bl	0 <load_4>
  c6:	f3c0 1ad4 	ubfx	sl, r0, #7, #21
    t[20] = MASK_21 & (load_4(s + 52) >> 4);
  ca:	f104 0034 	add.w	r0, r4, #52	; 0x34
  ce:	f7ff fffe 	bl	0 <load_4>
  d2:	f3c0 1714 	ubfx	r7, r0, #4, #21
    t[21] = MASK_21 & (load_3(s + 55) >> 1);
  d6:	f104 0037 	add.w	r0, r4, #55	; 0x37
  da:	f7ff fffe 	bl	0 <load_3>
  de:	f3c0 0854 	ubfx	r8, r0, #1, #21
    t[22] = MASK_21 & (load_4(s + 57) >> 6);
  e2:	f104 0039 	add.w	r0, r4, #57	; 0x39
  e6:	f7ff fffe 	bl	0 <load_4>
  ea:	f3c0 1694 	ubfx	r6, r0, #6, #21
    t[23] =           (load_4(s + 60) >> 3);
  ee:	f104 003c 	add.w	r0, r4, #60	; 0x3c
  f2:	f7ff fffe 	bl	0 <load_4>
  f6:	08cb      	lsrs	r3, r1, #3
  f8:	9300      	str	r3, [sp, #0]
  fa:	ea4f 0bd0 	mov.w	fp, r0, lsr #3
    t[16] = MASK_21 & (load_3(s + 42) >> 0);
  fe:	9b01      	ldr	r3, [sp, #4]
    t[16] -= t[23] * ORDER_5;
 100:	f8df c378 	ldr.w	ip, [pc, #888]	; 47c <sc_reduce+0x47c>
 104:	9a00      	ldr	r2, [sp, #0]
    t[14] -= t[23] * ORDER_3;
 106:	f8df e378 	ldr.w	lr, [pc, #888]	; 480 <sc_reduce+0x480>
    t[23] =           (load_4(s + 60) >> 3);
 10a:	ea4b 7b41 	orr.w	fp, fp, r1, lsl #29
    t[16] = MASK_21 & (load_3(s + 42) >> 0);
 10e:	f3c3 0014 	ubfx	r0, r3, #0, #21
    t[16] -= t[23] * ORDER_5;
 112:	f1cb 0300 	rsb	r3, fp, #0
 116:	fb0c 3202 	mla	r2, ip, r2, r3
 11a:	fbab 310c 	umull	r3, r1, fp, ip
 11e:	18c3      	adds	r3, r0, r3
 120:	9302      	str	r3, [sp, #8]
 122:	eb42 0301 	adc.w	r3, r2, r1
    t[14] -= t[23] * ORDER_3;
 126:	9a00      	ldr	r2, [sp, #0]
    t[16] -= t[23] * ORDER_5;
 128:	9301      	str	r3, [sp, #4]
    t[14] -= t[23] * ORDER_3;
 12a:	f1cb 0300 	rsb	r3, fp, #0
 12e:	fb0e 3202 	mla	r2, lr, r2, r3
    t[14] = MASK_21 & (load_4(s + 36) >> 6);
 132:	f3c5 1194 	ubfx	r1, r5, #6, #21
    t[14] -= t[23] * ORDER_3;
 136:	fbab 030e 	umull	r0, r3, fp, lr
 13a:	1809      	adds	r1, r1, r0
 13c:	eb42 0203 	adc.w	r2, r2, r3
    t[14] -= t[22] * ORDER_4;
 140:	4bd0      	ldr	r3, [pc, #832]	; (484 <sc_reduce+0x484>)
    t[12] -= t[23] * ORDER_1;
 142:	9d00      	ldr	r5, [sp, #0]
    t[14] -= t[22] * ORDER_4;
 144:	fba6 0303 	umull	r0, r3, r6, r3
 148:	1809      	adds	r1, r1, r0
 14a:	eba3 0306 	sub.w	r3, r3, r6
 14e:	eb43 0302 	adc.w	r3, r3, r2
    t[14] -= t[21] * ORDER_5;
 152:	fba8 020c 	umull	r0, r2, r8, ip
 156:	1809      	adds	r1, r1, r0
 158:	eba2 0208 	sub.w	r2, r2, r8
 15c:	eb42 0303 	adc.w	r3, r2, r3
    t[12] = MASK_21 & (load_4(s + 31) >> 4);
 160:	9a05      	ldr	r2, [sp, #20]
    t[14] -= t[21] * ORDER_5;
 162:	9304      	str	r3, [sp, #16]
    t[12] = MASK_21 & (load_4(s + 31) >> 4);
 164:	f3c2 1314 	ubfx	r3, r2, #4, #21
    t[12] -= t[23] * ORDER_1;
 168:	4ac7      	ldr	r2, [pc, #796]	; (488 <sc_reduce+0x488>)
    t[14] -= t[21] * ORDER_5;
 16a:	9103      	str	r1, [sp, #12]
    t[12] -= t[23] * ORDER_1;
 16c:	f1cb 0000 	rsb	r0, fp, #0
 170:	fb02 0105 	mla	r1, r2, r5, r0
 174:	fbab 0202 	umull	r0, r2, fp, r2
    t[12] -= t[22] * ORDER_2;
 178:	4dc4      	ldr	r5, [pc, #784]	; (48c <sc_reduce+0x48c>)
    t[12] -= t[23] * ORDER_1;
 17a:	181b      	adds	r3, r3, r0
 17c:	eb41 0002 	adc.w	r0, r1, r2
    t[12] -= t[22] * ORDER_2;
 180:	fba6 5205 	umull	r5, r2, r6, r5
 184:	1b92      	subs	r2, r2, r6
 186:	195b      	adds	r3, r3, r5
 188:	eb42 0100 	adc.w	r1, r2, r0
    t[12] -= t[21] * ORDER_3;
 18c:	fba8 020e 	umull	r0, r2, r8, lr
 190:	181b      	adds	r3, r3, r0
 192:	eba2 0208 	sub.w	r2, r2, r8
 196:	eb42 0201 	adc.w	r2, r2, r1
    t[12] -= t[20] * ORDER_4;
 19a:	49ba      	ldr	r1, [pc, #744]	; (484 <sc_reduce+0x484>)
 19c:	fba7 0101 	umull	r0, r1, r7, r1
 1a0:	1bc9      	subs	r1, r1, r7
 1a2:	181b      	adds	r3, r3, r0
 1a4:	eb41 0202 	adc.w	r2, r1, r2
    t[12] -= t[19] * ORDER_5;
 1a8:	fbaa 010c 	umull	r0, r1, sl, ip
 1ac:	181b      	adds	r3, r3, r0
    t[ 6] = MASK_21 & (load_4(s + 15) >> 6);
 1ae:	9807      	ldr	r0, [sp, #28]
    t[12] -= t[19] * ORDER_5;
 1b0:	9305      	str	r3, [sp, #20]
    t[ 6] = MASK_21 & (load_4(s + 15) >> 6);
 1b2:	f3c0 1e94 	ubfx	lr, r0, #6, #21
    t[ 6] -= t[18] * ORDER_0;
 1b6:	48b6      	ldr	r0, [pc, #728]	; (490 <sc_reduce+0x490>)
    t[12] -= t[19] * ORDER_5;
 1b8:	eba1 010a 	sub.w	r1, r1, sl
 1bc:	eb41 0302 	adc.w	r3, r1, r2
    t[ 6] -= t[18] * ORDER_0;
 1c0:	fba9 c100 	umull	ip, r1, r9, r0
    t[12] -= t[19] * ORDER_5;
 1c4:	9306      	str	r3, [sp, #24]
    t[ 6] -= t[18] * ORDER_0;
 1c6:	eb1e 030c 	adds.w	r3, lr, ip
 1ca:	9307      	str	r3, [sp, #28]
    t[ 8] = MASK_21 & (load_3(s + 21) >> 0);
 1cc:	9b08      	ldr	r3, [sp, #32]
    t[ 8] -= t[19] * ORDER_1;
 1ce:	4aae      	ldr	r2, [pc, #696]	; (488 <sc_reduce+0x488>)
    t[ 8] -= t[20] * ORDER_0;
 1d0:	4684      	mov	ip, r0
    t[ 6] -= t[18] * ORDER_0;
 1d2:	eba1 0109 	sub.w	r1, r1, r9
    t[ 8] -= t[20] * ORDER_0;
 1d6:	fba7 5000 	umull	r5, r0, r7, r0
    t[ 8] = MASK_21 & (load_3(s + 21) >> 0);
 1da:	f3c3 0314 	ubfx	r3, r3, #0, #21
    t[ 6] -= t[18] * ORDER_0;
 1de:	f141 0100 	adc.w	r1, r1, #0
    t[ 8] -= t[20] * ORDER_0;
 1e2:	1bc0      	subs	r0, r0, r7
 1e4:	195b      	adds	r3, r3, r5
    t[ 8] -= t[19] * ORDER_1;
 1e6:	fbaa 5202 	umull	r5, r2, sl, r2
    t[ 8] -= t[20] * ORDER_0;
 1ea:	f140 0000 	adc.w	r0, r0, #0
    t[ 8] -= t[19] * ORDER_1;
 1ee:	195b      	adds	r3, r3, r5
    t[ 8] -= t[18] * ORDER_2;
 1f0:	4da6      	ldr	r5, [pc, #664]	; (48c <sc_reduce+0x48c>)
    t[ 8] -= t[19] * ORDER_1;
 1f2:	eba2 020a 	sub.w	r2, r2, sl
 1f6:	eb42 0000 	adc.w	r0, r2, r0
    t[ 8] -= t[18] * ORDER_2;
 1fa:	fba9 5205 	umull	r5, r2, r9, r5
 1fe:	195b      	adds	r3, r3, r5
 200:	eba2 0209 	sub.w	r2, r2, r9
 204:	eb42 0200 	adc.w	r2, r2, r0
    t[10] = MASK_21 & (load_3(s + 26) >> 2);
 208:	9809      	ldr	r0, [sp, #36]	; 0x24
    t[10] -= t[21] * ORDER_1;
 20a:	4d9f      	ldr	r5, [pc, #636]	; (488 <sc_reduce+0x488>)
    t[ 8] -= t[18] * ORDER_2;
 20c:	9308      	str	r3, [sp, #32]
    t[10] = MASK_21 & (load_3(s + 26) >> 2);
 20e:	f3c0 0094 	ubfx	r0, r0, #2, #21
    t[10] -= t[22] * ORDER_0;
 212:	fba6 3e0c 	umull	r3, lr, r6, ip
 216:	ebae 0e06 	sub.w	lr, lr, r6
 21a:	18c0      	adds	r0, r0, r3
    t[10] -= t[21] * ORDER_1;
 21c:	fba8 3505 	umull	r3, r5, r8, r5
    t[10] -= t[22] * ORDER_0;
 220:	f14e 0c00 	adc.w	ip, lr, #0
    t[10] -= t[21] * ORDER_1;
 224:	18c0      	adds	r0, r0, r3
    t[10] -= t[20] * ORDER_2;
 226:	4b99      	ldr	r3, [pc, #612]	; (48c <sc_reduce+0x48c>)
    t[10] -= t[21] * ORDER_1;
 228:	eba5 0508 	sub.w	r5, r5, r8
 22c:	eb45 0e0c 	adc.w	lr, r5, ip
    t[10] -= t[20] * ORDER_2;
 230:	fba7 3c03 	umull	r3, ip, r7, r3
 234:	ebac 0c07 	sub.w	ip, ip, r7
 238:	18c0      	adds	r0, r0, r3
 23a:	eb4c 050e 	adc.w	r5, ip, lr
    t[10] -= t[19] * ORDER_3;
 23e:	f8df e240 	ldr.w	lr, [pc, #576]	; 480 <sc_reduce+0x480>
 242:	fbaa e30e 	umull	lr, r3, sl, lr
 246:	eba3 030a 	sub.w	r3, r3, sl
 24a:	eb10 000e 	adds.w	r0, r0, lr
 24e:	eb43 0c05 	adc.w	ip, r3, r5
    t[10] -= t[18] * ORDER_4;
 252:	4b8c      	ldr	r3, [pc, #560]	; (484 <sc_reduce+0x484>)
 254:	fba9 e303 	umull	lr, r3, r9, r3
 258:	eb10 000e 	adds.w	r0, r0, lr
 25c:	eba3 0309 	sub.w	r3, r3, r9
 260:	eb43 030c 	adc.w	r3, r3, ip
 264:	9009      	str	r0, [sp, #36]	; 0x24
    t[ 7] -= t[19] * ORDER_0;
 266:	f8df c228 	ldr.w	ip, [pc, #552]	; 490 <sc_reduce+0x490>
    t[ 7] = MASK_21 & (load_3(s + 18) >> 3);
 26a:	980a      	ldr	r0, [sp, #40]	; 0x28
    t[ 7] -= t[19] * ORDER_0;
 26c:	fbaa 5e0c 	umull	r5, lr, sl, ip
    t[ 7] = MASK_21 & (load_3(s + 18) >> 3);
 270:	f3c0 00d4 	ubfx	r0, r0, #3, #21
    t[ 7] -= t[19] * ORDER_0;
 274:	1940      	adds	r0, r0, r5
    t[ 7] -= t[18] * ORDER_1;
 276:	4d84      	ldr	r5, [pc, #528]	; (488 <sc_reduce+0x488>)
    t[ 7] -= t[19] * ORDER_0;
 278:	ebae 0e0a 	sub.w	lr, lr, sl
    t[ 7] -= t[18] * ORDER_1;
 27c:	fba9 5c05 	umull	r5, ip, r9, r5
    t[ 7] -= t[19] * ORDER_0;
 280:	f14e 0e00 	adc.w	lr, lr, #0
    t[ 7] -= t[18] * ORDER_1;
 284:	1940      	adds	r0, r0, r5
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 286:	9d07      	ldr	r5, [sp, #28]
 288:	ea4f 5555 	mov.w	r5, r5, lsr #21
 28c:	ea45 25c1 	orr.w	r5, r5, r1, lsl #11
    t[ 7] -= t[18] * ORDER_1;
 290:	ebac 0c09 	sub.w	ip, ip, r9
 294:	eb4c 0c0e 	adc.w	ip, ip, lr
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 298:	1940      	adds	r0, r0, r5
 29a:	900a      	str	r0, [sp, #40]	; 0x28
 29c:	eb4c 5061 	adc.w	r0, ip, r1, asr #21
 2a0:	900b      	str	r0, [sp, #44]	; 0x2c
    t[ 9] -= t[21] * ORDER_0;
 2a2:	f8df c1ec 	ldr.w	ip, [pc, #492]	; 490 <sc_reduce+0x490>
    t[ 9] = MASK_21 & (load_4(s + 23) >> 5);
 2a6:	980c      	ldr	r0, [sp, #48]	; 0x30
 2a8:	f3c0 1154 	ubfx	r1, r0, #5, #21
    t[ 9] -= t[21] * ORDER_0;
 2ac:	fba8 e00c 	umull	lr, r0, r8, ip
 2b0:	eba0 0008 	sub.w	r0, r0, r8
 2b4:	eb11 010e 	adds.w	r1, r1, lr
 2b8:	f140 0500 	adc.w	r5, r0, #0
    t[ 9] -= t[20] * ORDER_1;
 2bc:	4872      	ldr	r0, [pc, #456]	; (488 <sc_reduce+0x488>)
 2be:	fba7 ec00 	umull	lr, ip, r7, r0
 2c2:	ebac 0c07 	sub.w	ip, ip, r7
 2c6:	eb11 010e 	adds.w	r1, r1, lr
 2ca:	eb4c 0005 	adc.w	r0, ip, r5
    t[ 9] -= t[19] * ORDER_2;
 2ce:	4d6f      	ldr	r5, [pc, #444]	; (48c <sc_reduce+0x48c>)
    t[ 9] -= t[18] * ORDER_3;
 2d0:	f8df e1ac 	ldr.w	lr, [pc, #428]	; 480 <sc_reduce+0x480>
    t[ 9] -= t[19] * ORDER_2;
 2d4:	fbaa 5c05 	umull	r5, ip, sl, r5
 2d8:	1949      	adds	r1, r1, r5
 2da:	ebac 0c0a 	sub.w	ip, ip, sl
 2de:	eb4c 0c00 	adc.w	ip, ip, r0
    t[ 9] -= t[18] * ORDER_3;
 2e2:	fba9 050e 	umull	r0, r5, r9, lr
 2e6:	1809      	adds	r1, r1, r0
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 2e8:	9808      	ldr	r0, [sp, #32]
 2ea:	ea4f 5050 	mov.w	r0, r0, lsr #21
 2ee:	ea40 20c2 	orr.w	r0, r0, r2, lsl #11
    t[ 9] -= t[18] * ORDER_3;
 2f2:	eba5 0509 	sub.w	r5, r5, r9
 2f6:	eb45 050c 	adc.w	r5, r5, ip
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 2fa:	1809      	adds	r1, r1, r0
 2fc:	eb45 5262 	adc.w	r2, r5, r2, asr #21
 300:	910c      	str	r1, [sp, #48]	; 0x30
    t[11] -= t[23] * ORDER_0;
 302:	9d00      	ldr	r5, [sp, #0]
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 304:	920d      	str	r2, [sp, #52]	; 0x34
    t[11] -= t[23] * ORDER_0;
 306:	4962      	ldr	r1, [pc, #392]	; (490 <sc_reduce+0x490>)
    t[11] = MASK_21 & (load_4(s + 28) >> 7);
 308:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    t[11] -= t[23] * ORDER_0;
 30a:	f1cb 0000 	rsb	r0, fp, #0
 30e:	fb01 0005 	mla	r0, r1, r5, r0
    t[11] = MASK_21 & (load_4(s + 28) >> 7);
 312:	f3c2 12d4 	ubfx	r2, r2, #7, #21
    t[11] -= t[23] * ORDER_0;
 316:	fbab 5101 	umull	r5, r1, fp, r1
 31a:	1952      	adds	r2, r2, r5
    t[11] -= t[22] * ORDER_1;
 31c:	4d5a      	ldr	r5, [pc, #360]	; (488 <sc_reduce+0x488>)
    t[11] -= t[23] * ORDER_0;
 31e:	eb40 0001 	adc.w	r0, r0, r1
    t[11] -= t[22] * ORDER_1;
 322:	fba6 5105 	umull	r5, r1, r6, r5
 326:	1952      	adds	r2, r2, r5
 328:	eba1 0106 	sub.w	r1, r1, r6
 32c:	eb41 0100 	adc.w	r1, r1, r0
    t[11] -= t[21] * ORDER_2;
 330:	4856      	ldr	r0, [pc, #344]	; (48c <sc_reduce+0x48c>)
 332:	fba8 0500 	umull	r0, r5, r8, r0
 336:	eba5 0508 	sub.w	r5, r5, r8
 33a:	1812      	adds	r2, r2, r0
 33c:	eb45 0101 	adc.w	r1, r5, r1
    t[11] -= t[20] * ORDER_3;
 340:	fba7 050e 	umull	r0, r5, r7, lr
 344:	1812      	adds	r2, r2, r0
 346:	eba5 0507 	sub.w	r5, r5, r7
 34a:	eb45 0501 	adc.w	r5, r5, r1
    t[11] -= t[19] * ORDER_4;
 34e:	494d      	ldr	r1, [pc, #308]	; (484 <sc_reduce+0x484>)
 350:	fbaa 1001 	umull	r1, r0, sl, r1
 354:	1852      	adds	r2, r2, r1
 356:	eba0 000a 	sub.w	r0, r0, sl
    t[11] -= t[18] * ORDER_5;
 35a:	f8df a120 	ldr.w	sl, [pc, #288]	; 47c <sc_reduce+0x47c>
    t[11] -= t[19] * ORDER_4;
 35e:	eb40 0005 	adc.w	r0, r0, r5
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 362:	9d09      	ldr	r5, [sp, #36]	; 0x24
    t[11] -= t[18] * ORDER_5;
 364:	fba9 ec0a 	umull	lr, ip, r9, sl
 368:	eb12 020e 	adds.w	r2, r2, lr
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 36c:	ea4f 5e55 	mov.w	lr, r5, lsr #21
    t[11] -= t[18] * ORDER_5;
 370:	ebac 0c09 	sub.w	ip, ip, r9
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 374:	ea4e 2ec3 	orr.w	lr, lr, r3, lsl #11
    t[11] -= t[18] * ORDER_5;
 378:	eb4c 0000 	adc.w	r0, ip, r0
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 37c:	eb12 020e 	adds.w	r2, r2, lr
 380:	eb40 5563 	adc.w	r5, r0, r3, asr #21
    t[13] -= t[23] * ORDER_2;
 384:	f8df c104 	ldr.w	ip, [pc, #260]	; 48c <sc_reduce+0x48c>
 388:	9800      	ldr	r0, [sp, #0]
    t[13] = MASK_21 & (load_3(s + 34) >> 1);
 38a:	9b15      	ldr	r3, [sp, #84]	; 0x54
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 38c:	920e      	str	r2, [sp, #56]	; 0x38
    t[13] -= t[23] * ORDER_2;
 38e:	f1cb 0200 	rsb	r2, fp, #0
 392:	fb0c 2100 	mla	r1, ip, r0, r2
    t[13] -= t[22] * ORDER_3;
 396:	f8df e0e8 	ldr.w	lr, [pc, #232]	; 480 <sc_reduce+0x480>
    t[13] -= t[21] * ORDER_4;
 39a:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 484 <sc_reduce+0x484>
    t[13] -= t[23] * ORDER_2;
 39e:	fbab 020c 	umull	r0, r2, fp, ip
    t[13] = MASK_21 & (load_3(s + 34) >> 1);
 3a2:	f3c3 0354 	ubfx	r3, r3, #1, #21
    t[13] -= t[23] * ORDER_2;
 3a6:	181b      	adds	r3, r3, r0
 3a8:	eb41 0002 	adc.w	r0, r1, r2
    t[13] -= t[22] * ORDER_3;
 3ac:	fba6 210e 	umull	r2, r1, r6, lr
 3b0:	189b      	adds	r3, r3, r2
 3b2:	eba1 0106 	sub.w	r1, r1, r6
 3b6:	eb41 0100 	adc.w	r1, r1, r0
    t[13] -= t[21] * ORDER_4;
 3ba:	fba8 2009 	umull	r2, r0, r8, r9
 3be:	189a      	adds	r2, r3, r2
 3c0:	eba0 0008 	sub.w	r0, r0, r8
    t[13] -= t[20] * ORDER_5;
 3c4:	fba7 c30a 	umull	ip, r3, r7, sl
    t[13] -= t[21] * ORDER_4;
 3c8:	eb40 0001 	adc.w	r0, r0, r1
    t[13] -= t[20] * ORDER_5;
 3cc:	1bdf      	subs	r7, r3, r7
 3ce:	eb12 020c 	adds.w	r2, r2, ip
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
 3d2:	9b05      	ldr	r3, [sp, #20]
    t[15] -= t[23] * ORDER_4;
 3d4:	f8dd 8000 	ldr.w	r8, [sp]
    t[13] -= t[20] * ORDER_5;
 3d8:	eb47 0700 	adc.w	r7, r7, r0
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
 3dc:	9806      	ldr	r0, [sp, #24]
 3de:	0d5b      	lsrs	r3, r3, #21
 3e0:	ea43 23c0 	orr.w	r3, r3, r0, lsl #11
 3e4:	18d2      	adds	r2, r2, r3
    t[15] = MASK_21 & (load_3(s + 39) >> 3);
 3e6:	9b16      	ldr	r3, [sp, #88]	; 0x58
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
 3e8:	eb47 5760 	adc.w	r7, r7, r0, asr #21
    t[15] = MASK_21 & (load_3(s + 39) >> 3);
 3ec:	f3c3 00d4 	ubfx	r0, r3, #3, #21
    t[15] -= t[23] * ORDER_4;
 3f0:	f1cb 0300 	rsb	r3, fp, #0
 3f4:	fb09 3108 	mla	r1, r9, r8, r3
 3f8:	fbab 3c09 	umull	r3, ip, fp, r9
 3fc:	18c3      	adds	r3, r0, r3
    t[15] -= t[22] * ORDER_5;
 3fe:	fba6 e00a 	umull	lr, r0, r6, sl
    t[15] -= t[23] * ORDER_4;
 402:	eb41 010c 	adc.w	r1, r1, ip
    t[15] -= t[22] * ORDER_5;
 406:	1b86      	subs	r6, r0, r6
 408:	eb13 030e 	adds.w	r3, r3, lr
 40c:	eb46 0601 	adc.w	r6, r6, r1
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
 410:	9903      	ldr	r1, [sp, #12]
 412:	9804      	ldr	r0, [sp, #16]
    t[ 0] -= t[12] * ORDER_0;
 414:	f8df e078 	ldr.w	lr, [pc, #120]	; 490 <sc_reduce+0x490>
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
 418:	0d49      	lsrs	r1, r1, #21
 41a:	ea41 21c0 	orr.w	r1, r1, r0, lsl #11
 41e:	185b      	adds	r3, r3, r1
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
 420:	9902      	ldr	r1, [sp, #8]
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
 422:	eb46 5660 	adc.w	r6, r6, r0, asr #21
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
 426:	ea4f 5c51 	mov.w	ip, r1, lsr #21
    t[17] = MASK_21 & (load_4(s + 44) >> 5);
 42a:	9817      	ldr	r0, [sp, #92]	; 0x5c
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
 42c:	9901      	ldr	r1, [sp, #4]
    t[17] = MASK_21 & (load_4(s + 44) >> 5);
 42e:	f3c0 1054 	ubfx	r0, r0, #5, #21
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
 432:	ea4c 2cc1 	orr.w	ip, ip, r1, lsl #11
 436:	eb10 000c 	adds.w	r0, r0, ip
 43a:	ea4f 5161 	mov.w	r1, r1, asr #21
 43e:	9000      	str	r0, [sp, #0]
 440:	f141 0000 	adc.w	r0, r1, #0
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 444:	990e      	ldr	r1, [sp, #56]	; 0x38
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
 446:	9004      	str	r0, [sp, #16]
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
 448:	9805      	ldr	r0, [sp, #20]
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 44a:	0d49      	lsrs	r1, r1, #21
 44c:	ea41 21c5 	orr.w	r1, r1, r5, lsl #11
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
 450:	f3c0 0014 	ubfx	r0, r0, #0, #21
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 454:	1840      	adds	r0, r0, r1
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
 456:	9903      	ldr	r1, [sp, #12]
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
 458:	ea4f 5c52 	mov.w	ip, r2, lsr #21
 45c:	ea4c 2cc7 	orr.w	ip, ip, r7, lsl #11
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 460:	ea4f 5565 	mov.w	r5, r5, asr #21
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
 464:	f3c1 0114 	ubfx	r1, r1, #0, #21
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 468:	f145 0500 	adc.w	r5, r5, #0
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
 46c:	157f      	asrs	r7, r7, #21
 46e:	eb11 010c 	adds.w	r1, r1, ip
 472:	f147 0700 	adc.w	r7, r7, #0
 476:	9705      	str	r7, [sp, #20]
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
 478:	9f02      	ldr	r7, [sp, #8]
 47a:	e00b      	b.n	494 <sc_reduce+0x494>
 47c:	fff59084 	.word	0xfff59084
 480:	fff0c654 	.word	0xfff0c654
 484:	ffe215d1 	.word	0xffe215d1
 488:	ffe72d19 	.word	0xffe72d19
 48c:	ffe9fb68 	.word	0xffe9fb68
 490:	ffea2c13 	.word	0xffea2c13
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
 494:	9101      	str	r1, [sp, #4]
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
 496:	0d59      	lsrs	r1, r3, #21
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
 498:	f3c7 0714 	ubfx	r7, r7, #0, #21
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
 49c:	ea41 21c6 	orr.w	r1, r1, r6, lsl #11
 4a0:	1879      	adds	r1, r7, r1
 4a2:	ea4f 5666 	mov.w	r6, r6, asr #21
 4a6:	f146 0700 	adc.w	r7, r6, #0
 4aa:	9706      	str	r7, [sp, #24]
    t[ 0] = MASK_21 & (load_3(s +  0) >> 0);
 4ac:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
 4ae:	9102      	str	r1, [sp, #8]
    t[ 0] -= t[12] * ORDER_0;
 4b0:	fba0 c60e 	umull	ip, r6, r0, lr
    t[ 0] = MASK_21 & (load_3(s +  0) >> 0);
 4b4:	f3c7 0114 	ubfx	r1, r7, #0, #21
    t[ 0] -= t[12] * ORDER_0;
 4b8:	eb11 010c 	adds.w	r1, r1, ip
 4bc:	f1c0 0700 	rsb	r7, r0, #0
 4c0:	fb0e 7b05 	mla	fp, lr, r5, r7
 4c4:	910f      	str	r1, [sp, #60]	; 0x3c
    t[ 1] = MASK_21 & (load_4(s +  2) >> 5);
 4c6:	9910      	ldr	r1, [sp, #64]	; 0x40
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 4c8:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
 4cc:	f3c2 0214 	ubfx	r2, r2, #0, #21
    t[ 0] -= t[12] * ORDER_0;
 4d0:	eb4b 0b06 	adc.w	fp, fp, r6
    t[ 1] -= t[12] * ORDER_1;
 4d4:	4eeb      	ldr	r6, [pc, #940]	; (884 <sc_reduce+0x884>)
    t[ 1] -= t[13] * ORDER_0;
 4d6:	fba2 ca0e 	umull	ip, sl, r2, lr
    t[ 1] = MASK_21 & (load_4(s +  2) >> 5);
 4da:	f3c1 1154 	ubfx	r1, r1, #5, #21
    t[ 1] -= t[12] * ORDER_1;
 4de:	fb06 7905 	mla	r9, r6, r5, r7
    t[ 1] -= t[13] * ORDER_0;
 4e2:	eb11 010c 	adds.w	r1, r1, ip
 4e6:	ebaa 0a02 	sub.w	sl, sl, r2
    t[ 1] -= t[12] * ORDER_1;
 4ea:	fba0 c606 	umull	ip, r6, r0, r6
    t[ 1] -= t[13] * ORDER_0;
 4ee:	f14a 0a00 	adc.w	sl, sl, #0
    t[ 1] -= t[12] * ORDER_1;
 4f2:	eb11 010c 	adds.w	r1, r1, ip
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 4f6:	ea4f 5c58 	mov.w	ip, r8, lsr #21
 4fa:	ea4c 2ccb 	orr.w	ip, ip, fp, lsl #11
    t[ 1] -= t[12] * ORDER_1;
 4fe:	444e      	add	r6, r9
 500:	eb46 060a 	adc.w	r6, r6, sl
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 504:	eb11 010c 	adds.w	r1, r1, ip
 508:	9110      	str	r1, [sp, #64]	; 0x40
    t[ 2] = MASK_21 & (load_3(s +  5) >> 2);
 50a:	9911      	ldr	r1, [sp, #68]	; 0x44
    t[ 2] -= t[14] * ORDER_0;
 50c:	f8dd 9014 	ldr.w	r9, [sp, #20]
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 510:	eb46 566b 	adc.w	r6, r6, fp, asr #21
    t[ 2] = MASK_21 & (load_3(s +  5) >> 2);
 514:	f3c1 0b94 	ubfx	fp, r1, #2, #21
    t[ 2] -= t[14] * ORDER_0;
 518:	9901      	ldr	r1, [sp, #4]
 51a:	4249      	negs	r1, r1
 51c:	4688      	mov	r8, r1
 51e:	9103      	str	r1, [sp, #12]
 520:	fb0e 8809 	mla	r8, lr, r9, r8
 524:	4671      	mov	r1, lr
 526:	f8dd e004 	ldr.w	lr, [sp, #4]
 52a:	fbae ec01 	umull	lr, ip, lr, r1
 52e:	468a      	mov	sl, r1
 530:	eb1b 010e 	adds.w	r1, fp, lr
    t[ 2] -= t[13] * ORDER_1;
 534:	f8df b34c 	ldr.w	fp, [pc, #844]	; 884 <sc_reduce+0x884>
    t[ 2] -= t[14] * ORDER_0;
 538:	eb48 0c0c 	adc.w	ip, r8, ip
    t[ 2] -= t[13] * ORDER_1;
 53c:	fba2 980b 	umull	r9, r8, r2, fp
 540:	eb11 0109 	adds.w	r1, r1, r9
 544:	eba8 0802 	sub.w	r8, r8, r2
 548:	eb48 080c 	adc.w	r8, r8, ip
    t[ 2] -= t[12] * ORDER_2;
 54c:	f8df c338 	ldr.w	ip, [pc, #824]	; 888 <sc_reduce+0x888>
 550:	fb0c 7905 	mla	r9, ip, r5, r7
 554:	fba0 ce0c 	umull	ip, lr, r0, ip
 558:	eb11 010c 	adds.w	r1, r1, ip
 55c:	44ce      	add	lr, r9
 55e:	eb4e 0e08 	adc.w	lr, lr, r8
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
 562:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
 566:	ea4f 5c58 	mov.w	ip, r8, lsr #21
 56a:	ea4c 2cc6 	orr.w	ip, ip, r6, lsl #11
 56e:	eb11 010c 	adds.w	r1, r1, ip
 572:	eb4e 5666 	adc.w	r6, lr, r6, asr #21
 576:	9111      	str	r1, [sp, #68]	; 0x44
    t[ 3] = MASK_21 & (load_4(s +  7) >> 7);
 578:	9912      	ldr	r1, [sp, #72]	; 0x48
    t[ 3] -= t[14] * ORDER_1;
 57a:	f8dd e00c 	ldr.w	lr, [sp, #12]
 57e:	f8dd 9014 	ldr.w	r9, [sp, #20]
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
 582:	f3c3 0314 	ubfx	r3, r3, #0, #21
    t[ 3] = MASK_21 & (load_4(s +  7) >> 7);
 586:	f3c1 1cd4 	ubfx	ip, r1, #7, #21
    t[ 3] -= t[15] * ORDER_0;
 58a:	fba3 180a 	umull	r1, r8, r3, sl
    t[ 3] -= t[14] * ORDER_1;
 58e:	fb0b ea09 	mla	sl, fp, r9, lr
 592:	f8dd e004 	ldr.w	lr, [sp, #4]
    t[ 3] -= t[15] * ORDER_0;
 596:	eb1c 0c01 	adds.w	ip, ip, r1
 59a:	eba8 0803 	sub.w	r8, r8, r3
    t[ 3] -= t[14] * ORDER_1;
 59e:	fbae 1e0b 	umull	r1, lr, lr, fp
    t[ 3] -= t[15] * ORDER_0;
 5a2:	f148 0800 	adc.w	r8, r8, #0
    t[ 3] -= t[14] * ORDER_1;
 5a6:	eb1c 0101 	adds.w	r1, ip, r1
    t[ 3] -= t[13] * ORDER_2;
 5aa:	f8df c2dc 	ldr.w	ip, [pc, #732]	; 888 <sc_reduce+0x888>
    t[ 3] -= t[12] * ORDER_3;
 5ae:	f8df b2dc 	ldr.w	fp, [pc, #732]	; 88c <sc_reduce+0x88c>
    t[ 3] -= t[13] * ORDER_2;
 5b2:	fba2 c90c 	umull	ip, r9, r2, ip
    t[ 3] -= t[14] * ORDER_1;
 5b6:	44f2      	add	sl, lr
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 5b8:	f8dd e044 	ldr.w	lr, [sp, #68]	; 0x44
    t[ 3] -= t[14] * ORDER_1;
 5bc:	eb4a 0a08 	adc.w	sl, sl, r8
    t[ 3] -= t[13] * ORDER_2;
 5c0:	eba9 0902 	sub.w	r9, r9, r2
 5c4:	eb11 010c 	adds.w	r1, r1, ip
    t[ 3] -= t[12] * ORDER_3;
 5c8:	fba0 c80b 	umull	ip, r8, r0, fp
    t[ 3] -= t[13] * ORDER_2;
 5cc:	eb49 0a0a 	adc.w	sl, r9, sl
    t[ 3] -= t[12] * ORDER_3;
 5d0:	fb0b 7905 	mla	r9, fp, r5, r7
 5d4:	eb11 010c 	adds.w	r1, r1, ip
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 5d8:	ea4f 5c5e 	mov.w	ip, lr, lsr #21
 5dc:	ea4c 2cc6 	orr.w	ip, ip, r6, lsl #11
    t[ 3] -= t[12] * ORDER_3;
 5e0:	44c8      	add	r8, r9
 5e2:	eb48 080a 	adc.w	r8, r8, sl
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 5e6:	eb11 0e0c 	adds.w	lr, r1, ip
 5ea:	f8cd e048 	str.w	lr, [sp, #72]	; 0x48
 5ee:	eb48 5e66 	adc.w	lr, r8, r6, asr #21
    t[ 4] = MASK_21 & (load_4(s + 10) >> 4);
 5f2:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    t[ 4] -= t[16] * ORDER_0;
 5f4:	f8dd 9018 	ldr.w	r9, [sp, #24]
 5f8:	f8dd c008 	ldr.w	ip, [sp, #8]
 5fc:	f8df 8290 	ldr.w	r8, [pc, #656]	; 890 <sc_reduce+0x890>
    t[ 4] -= t[14] * ORDER_2;
 600:	f8dd a014 	ldr.w	sl, [sp, #20]
    t[ 4] = MASK_21 & (load_4(s + 10) >> 4);
 604:	f3c6 1114 	ubfx	r1, r6, #4, #21
    t[ 4] -= t[16] * ORDER_0;
 608:	9e02      	ldr	r6, [sp, #8]
 60a:	4276      	negs	r6, r6
 60c:	fb08 6909 	mla	r9, r8, r9, r6
 610:	fbac 8c08 	umull	r8, ip, ip, r8
 614:	eb11 0108 	adds.w	r1, r1, r8
 618:	eb49 0c0c 	adc.w	ip, r9, ip
    t[ 4] -= t[15] * ORDER_1;
 61c:	f8df 9264 	ldr.w	r9, [pc, #612]	; 884 <sc_reduce+0x884>
 620:	fba3 8909 	umull	r8, r9, r3, r9
 624:	eb11 0108 	adds.w	r1, r1, r8
 628:	eba9 0903 	sub.w	r9, r9, r3
    t[ 4] -= t[14] * ORDER_2;
 62c:	f8dd 800c 	ldr.w	r8, [sp, #12]
    t[ 4] -= t[15] * ORDER_1;
 630:	eb49 090c 	adc.w	r9, r9, ip
    t[ 4] -= t[14] * ORDER_2;
 634:	f8df c250 	ldr.w	ip, [pc, #592]	; 888 <sc_reduce+0x888>
 638:	fb0c 8a0a 	mla	sl, ip, sl, r8
 63c:	f8dd 8004 	ldr.w	r8, [sp, #4]
 640:	fba8 c80c 	umull	ip, r8, r8, ip
 644:	eb11 010c 	adds.w	r1, r1, ip
 648:	44c2      	add	sl, r8
    t[ 4] -= t[13] * ORDER_3;
 64a:	fba2 cb0b 	umull	ip, fp, r2, fp
    t[ 4] -= t[14] * ORDER_2;
 64e:	eb4a 0a09 	adc.w	sl, sl, r9
    t[ 4] -= t[13] * ORDER_3;
 652:	ebab 0b02 	sub.w	fp, fp, r2
 656:	eb11 010c 	adds.w	r1, r1, ip
    t[ 4] -= t[12] * ORDER_4;
 65a:	f8df 8238 	ldr.w	r8, [pc, #568]	; 894 <sc_reduce+0x894>
    t[ 4] -= t[13] * ORDER_3;
 65e:	eb4b 0a0a 	adc.w	sl, fp, sl
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 662:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    t[ 4] -= t[12] * ORDER_4;
 666:	fb08 7905 	mla	r9, r8, r5, r7
 66a:	fba0 c808 	umull	ip, r8, r0, r8
 66e:	eb11 010c 	adds.w	r1, r1, ip
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 672:	ea4f 5c5b 	mov.w	ip, fp, lsr #21
 676:	ea4c 2cce 	orr.w	ip, ip, lr, lsl #11
    t[ 4] -= t[12] * ORDER_4;
 67a:	44c8      	add	r8, r9
 67c:	eb48 080a 	adc.w	r8, r8, sl
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 680:	eb11 010c 	adds.w	r1, r1, ip
 684:	9113      	str	r1, [sp, #76]	; 0x4c
    t[ 5] = MASK_21 & (load_3(s + 13) >> 1);
 686:	9914      	ldr	r1, [sp, #80]	; 0x50
    t[ 5] -= t[17] * ORDER_0;
 688:	f8dd b010 	ldr.w	fp, [sp, #16]
 68c:	f8dd 9000 	ldr.w	r9, [sp]
    t[ 5] = MASK_21 & (load_3(s + 13) >> 1);
 690:	f3c1 0c54 	ubfx	ip, r1, #1, #21
    t[ 5] -= t[17] * ORDER_0;
 694:	9900      	ldr	r1, [sp, #0]
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 696:	eb48 586e 	adc.w	r8, r8, lr, asr #21
    t[ 5] -= t[17] * ORDER_0;
 69a:	f8df e1f4 	ldr.w	lr, [pc, #500]	; 890 <sc_reduce+0x890>
 69e:	4249      	negs	r1, r1
 6a0:	fb0e 1b0b 	mla	fp, lr, fp, r1
 6a4:	fba9 e90e 	umull	lr, r9, r9, lr
 6a8:	eb1c 0c0e 	adds.w	ip, ip, lr
 6ac:	eb4b 0b09 	adc.w	fp, fp, r9
    t[ 5] -= t[16] * ORDER_1;
 6b0:	f8dd e018 	ldr.w	lr, [sp, #24]
 6b4:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 884 <sc_reduce+0x884>
 6b8:	fb09 6a0e 	mla	sl, r9, lr, r6
 6bc:	f8dd e008 	ldr.w	lr, [sp, #8]
 6c0:	fbae e909 	umull	lr, r9, lr, r9
 6c4:	eb1c 0e0e 	adds.w	lr, ip, lr
    t[ 5] -= t[15] * ORDER_2;
 6c8:	f8df c1bc 	ldr.w	ip, [pc, #444]	; 888 <sc_reduce+0x888>
    t[ 5] -= t[16] * ORDER_1;
 6cc:	44ca      	add	sl, r9
    t[ 5] -= t[15] * ORDER_2;
 6ce:	fba3 9c0c 	umull	r9, ip, r3, ip
    t[ 5] -= t[16] * ORDER_1;
 6d2:	eb4a 0a0b 	adc.w	sl, sl, fp
    t[ 5] -= t[15] * ORDER_2;
 6d6:	ebac 0c03 	sub.w	ip, ip, r3
 6da:	eb1e 0e09 	adds.w	lr, lr, r9
 6de:	eb4c 0a0a 	adc.w	sl, ip, sl
    t[ 5] -= t[14] * ORDER_3;
 6e2:	f8dd 900c 	ldr.w	r9, [sp, #12]
 6e6:	f8dd b014 	ldr.w	fp, [sp, #20]
 6ea:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 88c <sc_reduce+0x88c>
 6ee:	fb0c 9b0b 	mla	fp, ip, fp, r9
 6f2:	f8dd 9004 	ldr.w	r9, [sp, #4]
 6f6:	fba9 c90c 	umull	ip, r9, r9, ip
 6fa:	eb1e 0c0c 	adds.w	ip, lr, ip
    t[ 5] -= t[13] * ORDER_4;
 6fe:	f8df e194 	ldr.w	lr, [pc, #404]	; 894 <sc_reduce+0x894>
    t[ 5] -= t[14] * ORDER_3;
 702:	44d9      	add	r9, fp
 704:	eb49 090a 	adc.w	r9, r9, sl
    t[ 5] -= t[13] * ORDER_4;
 708:	fba2 ea0e 	umull	lr, sl, r2, lr
 70c:	ebaa 0a02 	sub.w	sl, sl, r2
 710:	eb1c 0c0e 	adds.w	ip, ip, lr
 714:	eb4a 0909 	adc.w	r9, sl, r9
    t[ 5] -= t[12] * ORDER_5;
 718:	f8df a17c 	ldr.w	sl, [pc, #380]	; 898 <sc_reduce+0x898>
    t[ 6] -= t[15] * ORDER_3;
 71c:	f8df b16c 	ldr.w	fp, [pc, #364]	; 88c <sc_reduce+0x88c>
    t[ 5] -= t[12] * ORDER_5;
 720:	fb0a 7505 	mla	r5, sl, r5, r7
 724:	fba0 070a 	umull	r0, r7, r0, sl
 728:	eb1c 0c00 	adds.w	ip, ip, r0
 72c:	443d      	add	r5, r7
 72e:	eb45 0909 	adc.w	r9, r5, r9
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 732:	9d13      	ldr	r5, [sp, #76]	; 0x4c
    t[ 6] -= t[17] * ORDER_1;
 734:	9f00      	ldr	r7, [sp, #0]
 736:	4853      	ldr	r0, [pc, #332]	; (884 <sc_reduce+0x884>)
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 738:	ea4f 5e55 	mov.w	lr, r5, lsr #21
 73c:	ea4e 2ec8 	orr.w	lr, lr, r8, lsl #11
 740:	eb1c 050e 	adds.w	r5, ip, lr
 744:	9514      	str	r5, [sp, #80]	; 0x50
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 746:	9d07      	ldr	r5, [sp, #28]
 748:	f3c5 0e14 	ubfx	lr, r5, #0, #21
    t[ 6] -= t[17] * ORDER_1;
 74c:	9d04      	ldr	r5, [sp, #16]
 74e:	fb00 1505 	mla	r5, r0, r5, r1
 752:	fba7 c000 	umull	ip, r0, r7, r0
    t[ 6] -= t[16] * ORDER_2;
 756:	4f4c      	ldr	r7, [pc, #304]	; (888 <sc_reduce+0x888>)
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 758:	eb49 5868 	adc.w	r8, r9, r8, asr #21
    t[ 6] -= t[16] * ORDER_2;
 75c:	f8dd 9018 	ldr.w	r9, [sp, #24]
    t[ 6] -= t[17] * ORDER_1;
 760:	eb1e 0e0c 	adds.w	lr, lr, ip
    t[ 6] -= t[16] * ORDER_2;
 764:	f8dd c008 	ldr.w	ip, [sp, #8]
    t[ 6] -= t[17] * ORDER_1;
 768:	eb45 0500 	adc.w	r5, r5, r0
    t[ 6] -= t[16] * ORDER_2;
 76c:	4638      	mov	r0, r7
 76e:	fbac c000 	umull	ip, r0, ip, r0
 772:	fb07 6709 	mla	r7, r7, r9, r6
 776:	eb1e 0c0c 	adds.w	ip, lr, ip
 77a:	4407      	add	r7, r0
    t[ 6] -= t[15] * ORDER_3;
 77c:	fba3 090b 	umull	r0, r9, r3, fp
    t[ 6] -= t[16] * ORDER_2;
 780:	eb47 0705 	adc.w	r7, r7, r5
    t[ 6] -= t[15] * ORDER_3;
 784:	eba9 0903 	sub.w	r9, r9, r3
 788:	eb1c 0c00 	adds.w	ip, ip, r0
 78c:	eb49 0707 	adc.w	r7, r9, r7
    t[ 6] -= t[14] * ORDER_4;
 790:	9d03      	ldr	r5, [sp, #12]
 792:	f8dd e014 	ldr.w	lr, [sp, #20]
 796:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 894 <sc_reduce+0x894>
 79a:	fb09 5e0e 	mla	lr, r9, lr, r5
 79e:	9d01      	ldr	r5, [sp, #4]
 7a0:	fba5 0509 	umull	r0, r5, r5, r9
 7a4:	eb1c 0000 	adds.w	r0, ip, r0
 7a8:	4475      	add	r5, lr
    t[ 6] -= t[13] * ORDER_5;
 7aa:	fba2 c90a 	umull	ip, r9, r2, sl
    t[ 6] -= t[14] * ORDER_4;
 7ae:	eb45 0507 	adc.w	r5, r5, r7
    t[ 6] -= t[13] * ORDER_5;
 7b2:	eba9 0202 	sub.w	r2, r9, r2
 7b6:	eb10 0c0c 	adds.w	ip, r0, ip
 7ba:	eb42 0505 	adc.w	r5, r2, r5
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 7be:	9a14      	ldr	r2, [sp, #80]	; 0x50
    t[ 7] -= t[17] * ORDER_2;
 7c0:	9f04      	ldr	r7, [sp, #16]
    t[ 7] -= t[15] * ORDER_4;
 7c2:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 894 <sc_reduce+0x894>
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 7c6:	0d50      	lsrs	r0, r2, #21
 7c8:	ea40 20c8 	orr.w	r0, r0, r8, lsl #11
 7cc:	eb1c 0200 	adds.w	r2, ip, r0
 7d0:	9207      	str	r2, [sp, #28]
    t[ 7] -= t[17] * ORDER_2;
 7d2:	f8dd c000 	ldr.w	ip, [sp]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 7d6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 7d8:	eb45 5868 	adc.w	r8, r5, r8, asr #21
    t[ 7] -= t[17] * ORDER_2;
 7dc:	4d2a      	ldr	r5, [pc, #168]	; (888 <sc_reduce+0x888>)
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 7de:	f3c2 0214 	ubfx	r2, r2, #0, #21
    t[ 7] -= t[17] * ORDER_2;
 7e2:	fb05 1707 	mla	r7, r5, r7, r1
 7e6:	fbac 5005 	umull	r5, r0, ip, r5
 7ea:	1952      	adds	r2, r2, r5
    t[ 7] -= t[16] * ORDER_3;
 7ec:	f8dd c018 	ldr.w	ip, [sp, #24]
 7f0:	9d02      	ldr	r5, [sp, #8]
    t[ 7] -= t[17] * ORDER_2;
 7f2:	eb47 0700 	adc.w	r7, r7, r0
    t[ 7] -= t[16] * ORDER_3;
 7f6:	fb0b 6c0c 	mla	ip, fp, ip, r6
 7fa:	fba5 050b 	umull	r0, r5, r5, fp
 7fe:	1812      	adds	r2, r2, r0
 800:	4465      	add	r5, ip
 802:	eb45 0507 	adc.w	r5, r5, r7
    t[ 7] -= t[14] * ORDER_5;
 806:	f8dd c014 	ldr.w	ip, [sp, #20]
 80a:	9f03      	ldr	r7, [sp, #12]
    t[ 7] -= t[15] * ORDER_4;
 80c:	fba3 e909 	umull	lr, r9, r3, r9
    t[ 7] -= t[14] * ORDER_5;
 810:	fb0a 770c 	mla	r7, sl, ip, r7
 814:	f8dd c004 	ldr.w	ip, [sp, #4]
    t[ 7] -= t[15] * ORDER_4;
 818:	eba9 0903 	sub.w	r9, r9, r3
 81c:	eb12 020e 	adds.w	r2, r2, lr
 820:	eb49 0505 	adc.w	r5, r9, r5
    t[ 7] -= t[14] * ORDER_5;
 824:	fbac 090a 	umull	r0, r9, ip, sl
 828:	1812      	adds	r2, r2, r0
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 82a:	9807      	ldr	r0, [sp, #28]
 82c:	ea4f 5050 	mov.w	r0, r0, lsr #21
    t[ 7] -= t[14] * ORDER_5;
 830:	444f      	add	r7, r9
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 832:	ea40 20c8 	orr.w	r0, r0, r8, lsl #11
    t[ 7] -= t[14] * ORDER_5;
 836:	eb47 0505 	adc.w	r5, r7, r5
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 83a:	1812      	adds	r2, r2, r0
 83c:	9201      	str	r2, [sp, #4]
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 83e:	9a08      	ldr	r2, [sp, #32]
    t[ 8] -= t[17] * ORDER_3;
 840:	9f00      	ldr	r7, [sp, #0]
    t[ 8] -= t[16] * ORDER_4;
 842:	f8df 9050 	ldr.w	r9, [pc, #80]	; 894 <sc_reduce+0x894>
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 846:	f3c2 0014 	ubfx	r0, r2, #0, #21
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 84a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 84c:	eb45 5868 	adc.w	r8, r5, r8, asr #21
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 850:	0d55      	lsrs	r5, r2, #21
 852:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 854:	ea45 25c2 	orr.w	r5, r5, r2, lsl #11
 858:	ea4f 5c62 	mov.w	ip, r2, asr #21
    t[ 8] -= t[17] * ORDER_3;
 85c:	9a04      	ldr	r2, [sp, #16]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 85e:	1940      	adds	r0, r0, r5
 860:	f14c 0e00 	adc.w	lr, ip, #0
    t[ 8] -= t[17] * ORDER_3;
 864:	fb0b 1202 	mla	r2, fp, r2, r1
 868:	fba7 5c0b 	umull	r5, ip, r7, fp
 86c:	4494      	add	ip, r2
    t[ 8] -= t[16] * ORDER_4;
 86e:	9f06      	ldr	r7, [sp, #24]
 870:	9a02      	ldr	r2, [sp, #8]
 872:	fb09 6707 	mla	r7, r9, r7, r6
    t[ 8] -= t[17] * ORDER_3;
 876:	1940      	adds	r0, r0, r5
    t[ 8] -= t[16] * ORDER_4;
 878:	fba2 2509 	umull	r2, r5, r2, r9
    t[ 8] -= t[17] * ORDER_3;
 87c:	eb4c 0c0e 	adc.w	ip, ip, lr
    t[ 8] -= t[16] * ORDER_4;
 880:	443d      	add	r5, r7
 882:	e00b      	b.n	89c <sc_reduce+0x89c>
 884:	ffe72d19 	.word	0xffe72d19
 888:	ffe9fb68 	.word	0xffe9fb68
 88c:	fff0c654 	.word	0xfff0c654
 890:	ffea2c13 	.word	0xffea2c13
 894:	ffe215d1 	.word	0xffe215d1
 898:	fff59084 	.word	0xfff59084
 89c:	1880      	adds	r0, r0, r2
    t[ 8] -= t[15] * ORDER_5;
 89e:	fba3 2e0a 	umull	r2, lr, r3, sl
    t[ 8] -= t[16] * ORDER_4;
 8a2:	eb45 050c 	adc.w	r5, r5, ip
    t[ 8] -= t[15] * ORDER_5;
 8a6:	ebae 0303 	sub.w	r3, lr, r3
 8aa:	1880      	adds	r0, r0, r2
 8ac:	eb43 0505 	adc.w	r5, r3, r5
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 8b0:	9b01      	ldr	r3, [sp, #4]
    t[ 9] -= t[17] * ORDER_4;
 8b2:	9f04      	ldr	r7, [sp, #16]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 8b4:	0d5a      	lsrs	r2, r3, #21
 8b6:	ea42 22c8 	orr.w	r2, r2, r8, lsl #11
 8ba:	1883      	adds	r3, r0, r2
 8bc:	eb45 5868 	adc.w	r8, r5, r8, asr #21
    t[ 9] -= t[17] * ORDER_4;
 8c0:	fb09 1507 	mla	r5, r9, r7, r1
 8c4:	9f00      	ldr	r7, [sp, #0]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 8c6:	9303      	str	r3, [sp, #12]
    t[ 9] -= t[17] * ORDER_4;
 8c8:	fba7 0209 	umull	r0, r2, r7, r9
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 8cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    t[ 9] -= t[16] * ORDER_5;
 8ce:	9f06      	ldr	r7, [sp, #24]
    t[ 8] -= t[15] * ORDER_5;
 8d0:	46d4      	mov	ip, sl
    t[ 9] -= t[16] * ORDER_5;
 8d2:	fb0c 6607 	mla	r6, ip, r7, r6
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 8d6:	f3c3 0314 	ubfx	r3, r3, #0, #21
    t[ 9] -= t[16] * ORDER_5;
 8da:	9f02      	ldr	r7, [sp, #8]
    t[ 9] -= t[17] * ORDER_4;
 8dc:	181b      	adds	r3, r3, r0
 8de:	eb45 0202 	adc.w	r2, r5, r2
    t[ 9] -= t[16] * ORDER_5;
 8e2:	fba7 750c 	umull	r7, r5, r7, ip
 8e6:	19db      	adds	r3, r3, r7
 8e8:	442e      	add	r6, r5
 8ea:	eb46 0602 	adc.w	r6, r6, r2
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 8ee:	9a03      	ldr	r2, [sp, #12]
 8f0:	0d50      	lsrs	r0, r2, #21
 8f2:	ea40 20c8 	orr.w	r0, r0, r8, lsl #11
 8f6:	181b      	adds	r3, r3, r0
 8f8:	9302      	str	r3, [sp, #8]
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 8fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
    t[ 9] -= t[17] * ORDER_4;
 8fc:	46ca      	mov	sl, r9
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 8fe:	f3c3 0914 	ubfx	r9, r3, #0, #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 902:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 904:	ea4f 5053 	mov.w	r0, r3, lsr #21
 908:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 90a:	ea40 20c3 	orr.w	r0, r0, r3, lsl #11
 90e:	ea4f 5563 	mov.w	r5, r3, asr #21
    t[10] -= t[17] * ORDER_5;
 912:	9b04      	ldr	r3, [sp, #16]
 914:	fb0c 1103 	mla	r1, ip, r3, r1
 918:	9b00      	ldr	r3, [sp, #0]
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 91a:	eb46 5868 	adc.w	r8, r6, r8, asr #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 91e:	eb19 0900 	adds.w	r9, r9, r0
    t[10] -= t[17] * ORDER_5;
 922:	fba3 0c0c 	umull	r0, ip, r3, ip
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 926:	9b02      	ldr	r3, [sp, #8]
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 928:	f145 0500 	adc.w	r5, r5, #0
    t[10] -= t[17] * ORDER_5;
 92c:	eb19 0900 	adds.w	r9, r9, r0
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 930:	ea4f 5053 	mov.w	r0, r3, lsr #21
 934:	ea40 20c8 	orr.w	r0, r0, r8, lsl #11
    t[10] -= t[17] * ORDER_5;
 938:	4461      	add	r1, ip
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 93a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    t[10] -= t[17] * ORDER_5;
 93c:	eb41 0105 	adc.w	r1, r1, r5
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 940:	eb19 0900 	adds.w	r9, r9, r0
 944:	eb41 5868 	adc.w	r8, r1, r8, asr #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 948:	ea4f 5759 	mov.w	r7, r9, lsr #21
 94c:	ea47 27c8 	orr.w	r7, r7, r8, lsl #11
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 950:	f3c3 0b14 	ubfx	fp, r3, #0, #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 954:	eb1b 0b07 	adds.w	fp, fp, r7
 958:	ea4f 5668 	mov.w	r6, r8, asr #21
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 95c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    t[ 0] -= t[12] * ORDER_0;
 95e:	f8df 8284 	ldr.w	r8, [pc, #644]	; be4 <sc_reduce+0xbe4>
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 962:	f146 0600 	adc.w	r6, r6, #0
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 966:	ea4f 535b 	mov.w	r3, fp, lsr #21
 96a:	ea43 23c6 	orr.w	r3, r3, r6, lsl #11
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 96e:	f3c7 0014 	ubfx	r0, r7, #0, #21
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 972:	1576      	asrs	r6, r6, #21
    t[ 0] -= t[12] * ORDER_0;
 974:	425f      	negs	r7, r3
 976:	fb08 7206 	mla	r2, r8, r6, r7
 97a:	fba3 1808 	umull	r1, r8, r3, r8
 97e:	1840      	adds	r0, r0, r1
 980:	eb42 0808 	adc.w	r8, r2, r8
    t[ 1] -= t[12] * ORDER_1;
 984:	4998      	ldr	r1, [pc, #608]	; (be8 <sc_reduce+0xbe8>)
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
 986:	9a10      	ldr	r2, [sp, #64]	; 0x40
 988:	f3c2 0c14 	ubfx	ip, r2, #0, #21
    t[ 1] -= t[12] * ORDER_1;
 98c:	fb01 7206 	mla	r2, r1, r6, r7
 990:	fba3 1e01 	umull	r1, lr, r3, r1
 994:	eb1c 0101 	adds.w	r1, ip, r1
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 998:	ea4f 5c50 	mov.w	ip, r0, lsr #21
 99c:	ea4c 2cc8 	orr.w	ip, ip, r8, lsl #11
    t[ 1] -= t[12] * ORDER_1;
 9a0:	eb42 020e 	adc.w	r2, r2, lr
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
 9a4:	eb11 010c 	adds.w	r1, r1, ip
 9a8:	eb42 5268 	adc.w	r2, r2, r8, asr #21
 9ac:	f3c0 0814 	ubfx	r8, r0, #0, #21
 9b0:	f8cd 8000 	str.w	r8, [sp]
    t[ 2] -= t[12] * ORDER_2;
 9b4:	488d      	ldr	r0, [pc, #564]	; (bec <sc_reduce+0xbec>)
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 9b6:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
    t[ 2] -= t[12] * ORDER_2;
 9ba:	fb00 7506 	mla	r5, r0, r6, r7
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 9be:	f3c8 0c14 	ubfx	ip, r8, #0, #21
    t[ 2] -= t[12] * ORDER_2;
 9c2:	fba3 0e00 	umull	r0, lr, r3, r0
 9c6:	eb1c 0000 	adds.w	r0, ip, r0
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
 9ca:	ea4f 5c51 	mov.w	ip, r1, lsr #21
 9ce:	ea4c 2cc2 	orr.w	ip, ip, r2, lsl #11
    t[ 2] -= t[12] * ORDER_2;
 9d2:	eb45 0e0e 	adc.w	lr, r5, lr
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
 9d6:	eb10 000c 	adds.w	r0, r0, ip
 9da:	eb4e 5e62 	adc.w	lr, lr, r2, asr #21
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 9de:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
    t[ 3] -= t[12] * ORDER_3;
 9e2:	4a83      	ldr	r2, [pc, #524]	; (bf0 <sc_reduce+0xbf0>)
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 9e4:	f3c8 0c14 	ubfx	ip, r8, #0, #21
    t[ 3] -= t[12] * ORDER_3;
 9e8:	fb02 7506 	mla	r5, r2, r6, r7
 9ec:	fba3 2802 	umull	r2, r8, r3, r2
 9f0:	eb1c 0202 	adds.w	r2, ip, r2
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 9f4:	ea4f 5c50 	mov.w	ip, r0, lsr #21
    t[ 3] -= t[12] * ORDER_3;
 9f8:	eb45 0508 	adc.w	r5, r5, r8
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 9fc:	ea4c 2cce 	orr.w	ip, ip, lr, lsl #11
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 a00:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 a04:	eb12 020c 	adds.w	r2, r2, ip
 a08:	eb45 556e 	adc.w	r5, r5, lr, asr #21
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 a0c:	f3c8 0c14 	ubfx	ip, r8, #0, #21
    t[ 4] -= t[12] * ORDER_4;
 a10:	fb0a 7806 	mla	r8, sl, r6, r7
 a14:	fba3 ea0a 	umull	lr, sl, r3, sl
 a18:	eb1c 0c0e 	adds.w	ip, ip, lr
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 a1c:	ea4f 5e52 	mov.w	lr, r2, lsr #21
 a20:	ea4e 2ec5 	orr.w	lr, lr, r5, lsl #11
    t[ 4] -= t[12] * ORDER_4;
 a24:	eb48 080a 	adc.w	r8, r8, sl
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 a28:	eb1c 0e0e 	adds.w	lr, ip, lr
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 a2c:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 a30:	eb48 5865 	adc.w	r8, r8, r5, asr #21
    t[ 5] -= t[12] * ORDER_5;
 a34:	4d6f      	ldr	r5, [pc, #444]	; (bf4 <sc_reduce+0xbf4>)
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 a36:	f3ca 0c14 	ubfx	ip, sl, #0, #21
    t[ 5] -= t[12] * ORDER_5;
 a3a:	fb05 7606 	mla	r6, r5, r6, r7
 a3e:	fba3 3705 	umull	r3, r7, r3, r5
 a42:	eb1c 0503 	adds.w	r5, ip, r3
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 a46:	ea4f 5c5e 	mov.w	ip, lr, lsr #21
 a4a:	ea4c 2cc8 	orr.w	ip, ip, r8, lsl #11
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 a4e:	9b07      	ldr	r3, [sp, #28]
    t[ 5] -= t[12] * ORDER_5;
 a50:	eb46 0607 	adc.w	r6, r6, r7
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 a54:	eb15 050c 	adds.w	r5, r5, ip
 a58:	eb46 5868 	adc.w	r8, r6, r8, asr #21
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 a5c:	ea4f 5c55 	mov.w	ip, r5, lsr #21
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 a60:	9f01      	ldr	r7, [sp, #4]
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 a62:	ea4c 2cc8 	orr.w	ip, ip, r8, lsl #11
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 a66:	f3c3 0614 	ubfx	r6, r3, #0, #21
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 a6a:	eb16 060c 	adds.w	r6, r6, ip
 a6e:	ea4f 5368 	mov.w	r3, r8, asr #21
 a72:	f143 0300 	adc.w	r3, r3, #0
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 a76:	f3c7 0c14 	ubfx	ip, r7, #0, #21
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 a7a:	0d77      	lsrs	r7, r6, #21
 a7c:	ea47 27c3 	orr.w	r7, r7, r3, lsl #11
 a80:	eb1c 0c07 	adds.w	ip, ip, r7
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 a84:	9f03      	ldr	r7, [sp, #12]
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 a86:	ea4f 5363 	mov.w	r3, r3, asr #21
 a8a:	f143 0300 	adc.w	r3, r3, #0
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 a8e:	f3c7 0a14 	ubfx	sl, r7, #0, #21
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 a92:	ea4f 575c 	mov.w	r7, ip, lsr #21
 a96:	ea47 27c3 	orr.w	r7, r7, r3, lsl #11
 a9a:	eb1a 0a07 	adds.w	sl, sl, r7
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 a9e:	9f02      	ldr	r7, [sp, #8]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 aa0:	ea4f 5363 	mov.w	r3, r3, asr #21
 aa4:	f143 0300 	adc.w	r3, r3, #0
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 aa8:	f3c7 0814 	ubfx	r8, r7, #0, #21
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 aac:	ea4f 575a 	mov.w	r7, sl, lsr #21
 ab0:	ea47 27c3 	orr.w	r7, r7, r3, lsl #11
 ab4:	eb18 0807 	adds.w	r8, r8, r7
 ab8:	ea4f 5363 	mov.w	r3, r3, asr #21
 abc:	f143 0300 	adc.w	r3, r3, #0
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 ac0:	ea4f 5758 	mov.w	r7, r8, lsr #21
 ac4:	ea47 27c3 	orr.w	r7, r7, r3, lsl #11
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 ac8:	f3c9 0914 	ubfx	r9, r9, #0, #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 acc:	eb19 0907 	adds.w	r9, r9, r7
 ad0:	ea4f 5363 	mov.w	r3, r3, asr #21
 ad4:	f143 0300 	adc.w	r3, r3, #0
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
 ad8:	f3cb 0714 	ubfx	r7, fp, #0, #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 adc:	ea4f 5b59 	mov.w	fp, r9, lsr #21
 ae0:	ea4b 2bc3 	orr.w	fp, fp, r3, lsl #11
    s[ 0] = (byte)(t[ 0] >>  0);
 ae4:	9b00      	ldr	r3, [sp, #0]
 ae6:	7023      	strb	r3, [r4, #0]
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 ae8:	eb17 070b 	adds.w	r7, r7, fp
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
 aec:	f3c1 0114 	ubfx	r1, r1, #0, #21
    s[ 2] = (byte)((t[ 0] >> 16) | (t[ 1] <<  5));
 af0:	f8dd b000 	ldr.w	fp, [sp]
    s[ 1] = (byte)(t[ 0] >>  8);
 af4:	0a1b      	lsrs	r3, r3, #8
 af6:	7063      	strb	r3, [r4, #1]
    s[ 2] = (byte)((t[ 0] >> 16) | (t[ 1] <<  5));
 af8:	014b      	lsls	r3, r1, #5
 afa:	ea43 431b 	orr.w	r3, r3, fp, lsr #16
 afe:	70a3      	strb	r3, [r4, #2]
    s[ 3] = (byte)(t[ 1] >>  3);
 b00:	08cb      	lsrs	r3, r1, #3
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
 b02:	f3c0 0014 	ubfx	r0, r0, #0, #21
    s[ 3] = (byte)(t[ 1] >>  3);
 b06:	70e3      	strb	r3, [r4, #3]
    s[ 4] = (byte)(t[ 1] >> 11);
 b08:	0acb      	lsrs	r3, r1, #11
 b0a:	7123      	strb	r3, [r4, #4]
    s[ 5] = (byte)((t[ 1] >> 19) | (t[ 2] <<  2));
 b0c:	0083      	lsls	r3, r0, #2
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
 b0e:	f3c2 0214 	ubfx	r2, r2, #0, #21
    s[ 5] = (byte)((t[ 1] >> 19) | (t[ 2] <<  2));
 b12:	ea43 41d1 	orr.w	r1, r3, r1, lsr #19
    s[ 6] = (byte)(t[ 2] >>  6);
 b16:	0983      	lsrs	r3, r0, #6
 b18:	71a3      	strb	r3, [r4, #6]
    s[ 7] = (byte)((t[ 2] >> 14) | (t[ 3] <<  7));
 b1a:	01d3      	lsls	r3, r2, #7
 b1c:	ea43 3090 	orr.w	r0, r3, r0, lsr #14
    s[ 8] = (byte)(t[ 3] >>  1);
 b20:	0853      	lsrs	r3, r2, #1
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
 b22:	f3ce 0e14 	ubfx	lr, lr, #0, #21
    s[ 8] = (byte)(t[ 3] >>  1);
 b26:	7223      	strb	r3, [r4, #8]
    s[ 9] = (byte)(t[ 3] >>  9);
 b28:	0a53      	lsrs	r3, r2, #9
 b2a:	7263      	strb	r3, [r4, #9]
    s[10] = (byte)((t[ 3] >> 17) | (t[ 4] <<  4));
 b2c:	ea4f 130e 	mov.w	r3, lr, lsl #4
 b30:	ea43 4252 	orr.w	r2, r3, r2, lsr #17
    s[11] = (byte)(t[ 4] >>  4);
 b34:	ea4f 131e 	mov.w	r3, lr, lsr #4
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
 b38:	f3c5 0514 	ubfx	r5, r5, #0, #21
    s[11] = (byte)(t[ 4] >>  4);
 b3c:	72e3      	strb	r3, [r4, #11]
    s[12] = (byte)(t[ 4] >> 12);
 b3e:	ea4f 331e 	mov.w	r3, lr, lsr #12
 b42:	7323      	strb	r3, [r4, #12]
    s[13] = (byte)((t[ 4] >> 20) | (t[ 5] <<  1));
 b44:	196b      	adds	r3, r5, r5
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
 b46:	f3c6 0614 	ubfx	r6, r6, #0, #21
    s[13] = (byte)((t[ 4] >> 20) | (t[ 5] <<  1));
 b4a:	ea43 5e1e 	orr.w	lr, r3, lr, lsr #20
    s[14] = (byte)(t[ 5] >>  7);
 b4e:	09eb      	lsrs	r3, r5, #7
 b50:	73a3      	strb	r3, [r4, #14]
    s[15] = (byte)((t[ 5] >> 15) | (t[ 6] <<  6));
 b52:	01b3      	lsls	r3, r6, #6
 b54:	ea43 35d5 	orr.w	r5, r3, r5, lsr #15
    s[16] = (byte)(t[ 6] >>  2);
 b58:	08b3      	lsrs	r3, r6, #2
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
 b5a:	f3cc 0c14 	ubfx	ip, ip, #0, #21
    s[ 5] = (byte)((t[ 1] >> 19) | (t[ 2] <<  2));
 b5e:	7161      	strb	r1, [r4, #5]
    s[ 7] = (byte)((t[ 2] >> 14) | (t[ 3] <<  7));
 b60:	71e0      	strb	r0, [r4, #7]
    s[10] = (byte)((t[ 3] >> 17) | (t[ 4] <<  4));
 b62:	72a2      	strb	r2, [r4, #10]
    s[13] = (byte)((t[ 4] >> 20) | (t[ 5] <<  1));
 b64:	f884 e00d 	strb.w	lr, [r4, #13]
    s[15] = (byte)((t[ 5] >> 15) | (t[ 6] <<  6));
 b68:	73e5      	strb	r5, [r4, #15]
    s[16] = (byte)(t[ 6] >>  2);
 b6a:	7423      	strb	r3, [r4, #16]
    s[17] = (byte)(t[ 6] >> 10);
 b6c:	0ab3      	lsrs	r3, r6, #10
 b6e:	7463      	strb	r3, [r4, #17]
    s[18] = (byte)((t[ 6] >> 18) | (t[ 7] <<  3));
 b70:	ea4f 03cc 	mov.w	r3, ip, lsl #3
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
 b74:	f3ca 0a14 	ubfx	sl, sl, #0, #21
    s[18] = (byte)((t[ 6] >> 18) | (t[ 7] <<  3));
 b78:	ea43 4696 	orr.w	r6, r3, r6, lsr #18
    s[19] = (byte)(t[ 7] >>  5);
 b7c:	ea4f 135c 	mov.w	r3, ip, lsr #5
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
 b80:	f3c8 0814 	ubfx	r8, r8, #0, #21
    s[19] = (byte)(t[ 7] >>  5);
 b84:	74e3      	strb	r3, [r4, #19]
    s[22] = (byte)(t[ 8] >>  8);
 b86:	ea4f 231a 	mov.w	r3, sl, lsr #8
 b8a:	75a3      	strb	r3, [r4, #22]
    s[23] = (byte)((t[ 8] >> 16) | (t[ 9] <<  5));
 b8c:	ea4f 1348 	mov.w	r3, r8, lsl #5
    s[21] = (byte)(t[ 8] >>  0);
 b90:	f884 a015 	strb.w	sl, [r4, #21]
    s[23] = (byte)((t[ 8] >> 16) | (t[ 9] <<  5));
 b94:	ea43 4a1a 	orr.w	sl, r3, sl, lsr #16
    s[24] = (byte)(t[ 9] >>  3);
 b98:	ea4f 03d8 	mov.w	r3, r8, lsr #3
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
 b9c:	f3c9 0914 	ubfx	r9, r9, #0, #21
    s[24] = (byte)(t[ 9] >>  3);
 ba0:	7623      	strb	r3, [r4, #24]
    s[25] = (byte)(t[ 9] >> 11);
 ba2:	ea4f 23d8 	mov.w	r3, r8, lsr #11
 ba6:	7663      	strb	r3, [r4, #25]
    s[26] = (byte)((t[ 9] >> 19) | (t[10] <<  2));
 ba8:	ea4f 0389 	mov.w	r3, r9, lsl #2
 bac:	ea43 48d8 	orr.w	r8, r3, r8, lsr #19
    s[27] = (byte)(t[10] >>  6);
 bb0:	ea4f 1399 	mov.w	r3, r9, lsr #6
 bb4:	76e3      	strb	r3, [r4, #27]
    s[28] = (byte)((t[10] >> 14) | (t[11] <<  7));
 bb6:	01fb      	lsls	r3, r7, #7
 bb8:	ea43 3999 	orr.w	r9, r3, r9, lsr #14
    s[29] = (byte)(t[11] >>  1);
 bbc:	087b      	lsrs	r3, r7, #1
    s[20] = (byte)(t[ 7] >> 13);
 bbe:	ea4f 3c5c 	mov.w	ip, ip, lsr #13
    s[29] = (byte)(t[11] >>  1);
 bc2:	7763      	strb	r3, [r4, #29]
    s[30] = (byte)(t[11] >>  9);
 bc4:	0a7b      	lsrs	r3, r7, #9
    s[31] = (byte)(t[11] >> 17);
 bc6:	0c7f      	lsrs	r7, r7, #17
    s[18] = (byte)((t[ 6] >> 18) | (t[ 7] <<  3));
 bc8:	74a6      	strb	r6, [r4, #18]
    s[20] = (byte)(t[ 7] >> 13);
 bca:	f884 c014 	strb.w	ip, [r4, #20]
    s[23] = (byte)((t[ 8] >> 16) | (t[ 9] <<  5));
 bce:	f884 a017 	strb.w	sl, [r4, #23]
    s[26] = (byte)((t[ 9] >> 19) | (t[10] <<  2));
 bd2:	f884 801a 	strb.w	r8, [r4, #26]
    s[28] = (byte)((t[10] >> 14) | (t[11] <<  7));
 bd6:	f884 901c 	strb.w	r9, [r4, #28]
    s[30] = (byte)(t[11] >>  9);
 bda:	77a3      	strb	r3, [r4, #30]
    s[31] = (byte)(t[11] >> 17);
 bdc:	77e7      	strb	r7, [r4, #31]
}
 bde:	b019      	add	sp, #100	; 0x64
 be0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 be4:	ffea2c13 	.word	0xffea2c13
 be8:	ffe72d19 	.word	0xffe72d19
 bec:	ffe9fb68 	.word	0xffe9fb68
 bf0:	fff0c654 	.word	0xfff0c654
 bf4:	fff59084 	.word	0xfff59084

Disassembly of section .text.sc_muladd:

00000000 <sc_muladd>:
{
       0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
       4:	b0b5      	sub	sp, #212	; 0xd4
       6:	4617      	mov	r7, r2
       8:	9000      	str	r0, [sp, #0]
    ad[ 0] = MASK_21 & (load_3(a +  0) >> 0);
       a:	4608      	mov	r0, r1
{
       c:	461e      	mov	r6, r3
       e:	460c      	mov	r4, r1
    ad[ 0] = MASK_21 & (load_3(a +  0) >> 0);
      10:	f7ff fffe 	bl	0 <load_3>
      14:	f3c0 0314 	ubfx	r3, r0, #0, #21
    ad[ 1] = MASK_21 & (load_4(a +  2) >> 5);
      18:	1ca0      	adds	r0, r4, #2
    ad[ 0] = MASK_21 & (load_3(a +  0) >> 0);
      1a:	9301      	str	r3, [sp, #4]
    ad[ 1] = MASK_21 & (load_4(a +  2) >> 5);
      1c:	f7ff fffe 	bl	0 <load_4>
      20:	f3c0 1354 	ubfx	r3, r0, #5, #21
    ad[ 2] = MASK_21 & (load_3(a +  5) >> 2);
      24:	1d60      	adds	r0, r4, #5
    ad[ 1] = MASK_21 & (load_4(a +  2) >> 5);
      26:	9302      	str	r3, [sp, #8]
    ad[ 2] = MASK_21 & (load_3(a +  5) >> 2);
      28:	f7ff fffe 	bl	0 <load_3>
      2c:	f3c0 0394 	ubfx	r3, r0, #2, #21
    ad[ 3] = MASK_21 & (load_4(a +  7) >> 7);
      30:	1de0      	adds	r0, r4, #7
    ad[ 2] = MASK_21 & (load_3(a +  5) >> 2);
      32:	9303      	str	r3, [sp, #12]
    ad[ 3] = MASK_21 & (load_4(a +  7) >> 7);
      34:	f7ff fffe 	bl	0 <load_4>
      38:	f3c0 13d4 	ubfx	r3, r0, #7, #21
    ad[ 4] = MASK_21 & (load_4(a + 10) >> 4);
      3c:	f104 000a 	add.w	r0, r4, #10
    ad[ 3] = MASK_21 & (load_4(a +  7) >> 7);
      40:	9304      	str	r3, [sp, #16]
    ad[ 4] = MASK_21 & (load_4(a + 10) >> 4);
      42:	f7ff fffe 	bl	0 <load_4>
      46:	f3c0 1314 	ubfx	r3, r0, #4, #21
    ad[ 5] = MASK_21 & (load_3(a + 13) >> 1);
      4a:	f104 000d 	add.w	r0, r4, #13
    ad[ 4] = MASK_21 & (load_4(a + 10) >> 4);
      4e:	9305      	str	r3, [sp, #20]
    ad[ 5] = MASK_21 & (load_3(a + 13) >> 1);
      50:	f7ff fffe 	bl	0 <load_3>
      54:	f3c0 0354 	ubfx	r3, r0, #1, #21
    ad[ 6] = MASK_21 & (load_4(a + 15) >> 6);
      58:	f104 000f 	add.w	r0, r4, #15
    ad[ 5] = MASK_21 & (load_3(a + 13) >> 1);
      5c:	9306      	str	r3, [sp, #24]
    ad[ 6] = MASK_21 & (load_4(a + 15) >> 6);
      5e:	f7ff fffe 	bl	0 <load_4>
      62:	f3c0 1394 	ubfx	r3, r0, #6, #21
    ad[ 7] = MASK_21 & (load_3(a + 18) >> 3);
      66:	f104 0012 	add.w	r0, r4, #18
    ad[ 6] = MASK_21 & (load_4(a + 15) >> 6);
      6a:	9307      	str	r3, [sp, #28]
    ad[ 7] = MASK_21 & (load_3(a + 18) >> 3);
      6c:	f7ff fffe 	bl	0 <load_3>
      70:	f3c0 03d4 	ubfx	r3, r0, #3, #21
    ad[ 8] = MASK_21 & (load_3(a + 21) >> 0);
      74:	f104 0015 	add.w	r0, r4, #21
    ad[ 7] = MASK_21 & (load_3(a + 18) >> 3);
      78:	9308      	str	r3, [sp, #32]
    ad[ 8] = MASK_21 & (load_3(a + 21) >> 0);
      7a:	f7ff fffe 	bl	0 <load_3>
      7e:	f3c0 0314 	ubfx	r3, r0, #0, #21
    ad[ 9] = MASK_21 & (load_4(a + 23) >> 5);
      82:	f104 0017 	add.w	r0, r4, #23
    ad[ 8] = MASK_21 & (load_3(a + 21) >> 0);
      86:	9309      	str	r3, [sp, #36]	; 0x24
    ad[ 9] = MASK_21 & (load_4(a + 23) >> 5);
      88:	f7ff fffe 	bl	0 <load_4>
      8c:	f3c0 1354 	ubfx	r3, r0, #5, #21
    ad[10] = MASK_21 & (load_3(a + 26) >> 2);
      90:	f104 001a 	add.w	r0, r4, #26
    ad[ 9] = MASK_21 & (load_4(a + 23) >> 5);
      94:	930a      	str	r3, [sp, #40]	; 0x28
    ad[10] = MASK_21 & (load_3(a + 26) >> 2);
      96:	f7ff fffe 	bl	0 <load_3>
      9a:	f3c0 0394 	ubfx	r3, r0, #2, #21
    ad[11] = (word32)(load_4(a + 28) >> 7);
      9e:	f104 001c 	add.w	r0, r4, #28
    ad[10] = MASK_21 & (load_3(a + 26) >> 2);
      a2:	930b      	str	r3, [sp, #44]	; 0x2c
    ad[11] = (word32)(load_4(a + 28) >> 7);
      a4:	f7ff fffe 	bl	0 <load_4>
      a8:	4680      	mov	r8, r0
    bd[ 0] = MASK_21 & (load_3(b +  0) >> 0);
      aa:	4638      	mov	r0, r7
    ad[11] = (word32)(load_4(a + 28) >> 7);
      ac:	911f      	str	r1, [sp, #124]	; 0x7c
    bd[ 0] = MASK_21 & (load_3(b +  0) >> 0);
      ae:	f7ff fffe 	bl	0 <load_3>
      b2:	f3c0 0314 	ubfx	r3, r0, #0, #21
    bd[ 1] = MASK_21 & (load_4(b +  2) >> 5);
      b6:	1cb8      	adds	r0, r7, #2
    bd[ 0] = MASK_21 & (load_3(b +  0) >> 0);
      b8:	930c      	str	r3, [sp, #48]	; 0x30
    bd[ 1] = MASK_21 & (load_4(b +  2) >> 5);
      ba:	f7ff fffe 	bl	0 <load_4>
      be:	f3c0 1354 	ubfx	r3, r0, #5, #21
    bd[ 2] = MASK_21 & (load_3(b +  5) >> 2);
      c2:	1d78      	adds	r0, r7, #5
    bd[ 1] = MASK_21 & (load_4(b +  2) >> 5);
      c4:	930d      	str	r3, [sp, #52]	; 0x34
    bd[ 2] = MASK_21 & (load_3(b +  5) >> 2);
      c6:	f7ff fffe 	bl	0 <load_3>
      ca:	f3c0 0394 	ubfx	r3, r0, #2, #21
    bd[ 3] = MASK_21 & (load_4(b +  7) >> 7);
      ce:	1df8      	adds	r0, r7, #7
    bd[ 2] = MASK_21 & (load_3(b +  5) >> 2);
      d0:	930e      	str	r3, [sp, #56]	; 0x38
    bd[ 3] = MASK_21 & (load_4(b +  7) >> 7);
      d2:	f7ff fffe 	bl	0 <load_4>
      d6:	f3c0 13d4 	ubfx	r3, r0, #7, #21
    bd[ 4] = MASK_21 & (load_4(b + 10) >> 4);
      da:	f107 000a 	add.w	r0, r7, #10
    bd[ 3] = MASK_21 & (load_4(b +  7) >> 7);
      de:	930f      	str	r3, [sp, #60]	; 0x3c
    bd[ 4] = MASK_21 & (load_4(b + 10) >> 4);
      e0:	f7ff fffe 	bl	0 <load_4>
      e4:	f3c0 1314 	ubfx	r3, r0, #4, #21
    bd[ 5] = MASK_21 & (load_3(b + 13) >> 1);
      e8:	f107 000d 	add.w	r0, r7, #13
    bd[ 4] = MASK_21 & (load_4(b + 10) >> 4);
      ec:	9310      	str	r3, [sp, #64]	; 0x40
    bd[ 5] = MASK_21 & (load_3(b + 13) >> 1);
      ee:	f7ff fffe 	bl	0 <load_3>
      f2:	f3c0 0354 	ubfx	r3, r0, #1, #21
    bd[ 6] = MASK_21 & (load_4(b + 15) >> 6);
      f6:	f107 000f 	add.w	r0, r7, #15
    bd[ 5] = MASK_21 & (load_3(b + 13) >> 1);
      fa:	9311      	str	r3, [sp, #68]	; 0x44
    bd[ 6] = MASK_21 & (load_4(b + 15) >> 6);
      fc:	f7ff fffe 	bl	0 <load_4>
     100:	f3c0 1394 	ubfx	r3, r0, #6, #21
    bd[ 7] = MASK_21 & (load_3(b + 18) >> 3);
     104:	f107 0012 	add.w	r0, r7, #18
    bd[ 6] = MASK_21 & (load_4(b + 15) >> 6);
     108:	9312      	str	r3, [sp, #72]	; 0x48
    bd[ 7] = MASK_21 & (load_3(b + 18) >> 3);
     10a:	f7ff fffe 	bl	0 <load_3>
     10e:	f3c0 03d4 	ubfx	r3, r0, #3, #21
    bd[ 8] = MASK_21 & (load_3(b + 21) >> 0);
     112:	f107 0015 	add.w	r0, r7, #21
    bd[ 7] = MASK_21 & (load_3(b + 18) >> 3);
     116:	9313      	str	r3, [sp, #76]	; 0x4c
    bd[ 8] = MASK_21 & (load_3(b + 21) >> 0);
     118:	f7ff fffe 	bl	0 <load_3>
     11c:	f3c0 0314 	ubfx	r3, r0, #0, #21
    bd[ 9] = MASK_21 & (load_4(b + 23) >> 5);
     120:	f107 0017 	add.w	r0, r7, #23
    bd[ 8] = MASK_21 & (load_3(b + 21) >> 0);
     124:	9314      	str	r3, [sp, #80]	; 0x50
    bd[ 9] = MASK_21 & (load_4(b + 23) >> 5);
     126:	f7ff fffe 	bl	0 <load_4>
     12a:	f3c0 1354 	ubfx	r3, r0, #5, #21
    bd[10] = MASK_21 & (load_3(b + 26) >> 2);
     12e:	f107 001a 	add.w	r0, r7, #26
    bd[ 9] = MASK_21 & (load_4(b + 23) >> 5);
     132:	9315      	str	r3, [sp, #84]	; 0x54
    bd[10] = MASK_21 & (load_3(b + 26) >> 2);
     134:	f7ff fffe 	bl	0 <load_3>
     138:	f3c0 0394 	ubfx	r3, r0, #2, #21
    bd[11] = (word32)(load_4(b + 28) >> 7);
     13c:	f107 001c 	add.w	r0, r7, #28
    bd[10] = MASK_21 & (load_3(b + 26) >> 2);
     140:	9316      	str	r3, [sp, #88]	; 0x58
    bd[11] = (word32)(load_4(b + 28) >> 7);
     142:	f7ff fffe 	bl	0 <load_4>
     146:	4681      	mov	r9, r0
    cd[ 0] = MASK_21 & (load_3(c +  0) >> 0);
     148:	4630      	mov	r0, r6
    bd[11] = (word32)(load_4(b + 28) >> 7);
     14a:	460c      	mov	r4, r1
    cd[ 0] = MASK_21 & (load_3(c +  0) >> 0);
     14c:	f7ff fffe 	bl	0 <load_3>
     150:	9017      	str	r0, [sp, #92]	; 0x5c
    cd[ 1] = MASK_21 & (load_4(c +  2) >> 5);
     152:	1cb0      	adds	r0, r6, #2
     154:	f7ff fffe 	bl	0 <load_4>
     158:	902a      	str	r0, [sp, #168]	; 0xa8
    cd[ 2] = MASK_21 & (load_3(c +  5) >> 2);
     15a:	1d70      	adds	r0, r6, #5
     15c:	f7ff fffe 	bl	0 <load_3>
     160:	4682      	mov	sl, r0
    cd[ 3] = MASK_21 & (load_4(c +  7) >> 7);
     162:	1df0      	adds	r0, r6, #7
     164:	f7ff fffe 	bl	0 <load_4>
     168:	902b      	str	r0, [sp, #172]	; 0xac
    cd[ 4] = MASK_21 & (load_4(c + 10) >> 4);
     16a:	f106 000a 	add.w	r0, r6, #10
     16e:	f7ff fffe 	bl	0 <load_4>
     172:	4683      	mov	fp, r0
    cd[ 5] = MASK_21 & (load_3(c + 13) >> 1);
     174:	f106 000d 	add.w	r0, r6, #13
     178:	f7ff fffe 	bl	0 <load_3>
     17c:	902d      	str	r0, [sp, #180]	; 0xb4
    cd[ 6] = MASK_21 & (load_4(c + 15) >> 6);
     17e:	f106 000f 	add.w	r0, r6, #15
     182:	f7ff fffe 	bl	0 <load_4>
     186:	4605      	mov	r5, r0
    cd[ 7] = MASK_21 & (load_3(c + 18) >> 3);
     188:	f106 0012 	add.w	r0, r6, #18
     18c:	f7ff fffe 	bl	0 <load_3>
     190:	902f      	str	r0, [sp, #188]	; 0xbc
    cd[ 8] = MASK_21 & (load_3(c + 21) >> 0);
     192:	f106 0015 	add.w	r0, r6, #21
     196:	f7ff fffe 	bl	0 <load_3>
     19a:	901c      	str	r0, [sp, #112]	; 0x70
    cd[ 9] = MASK_21 & (load_4(c + 23) >> 5);
     19c:	f106 0017 	add.w	r0, r6, #23
     1a0:	f7ff fffe 	bl	0 <load_4>
     1a4:	9031      	str	r0, [sp, #196]	; 0xc4
    cd[10] = MASK_21 & (load_3(c + 26) >> 2);
     1a6:	f106 001a 	add.w	r0, r6, #26
     1aa:	f7ff fffe 	bl	0 <load_3>
     1ae:	4607      	mov	r7, r0
    cd[11] = (word32)(load_4(c + 28) >> 7);
     1b0:	f106 001c 	add.w	r0, r6, #28
     1b4:	f7ff fffe 	bl	0 <load_4>
    cd[ 0] = MASK_21 & (load_3(c +  0) >> 0);
     1b8:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    t[ 0] = cd[ 0] + (sword64)ad[ 0] * bd[ 0];
     1ba:	9e01      	ldr	r6, [sp, #4]
     1bc:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
    cd[11] = (word32)(load_4(c + 28) >> 7);
     1c0:	9033      	str	r0, [sp, #204]	; 0xcc
    cd[ 0] = MASK_21 & (load_3(c +  0) >> 0);
     1c2:	f3c3 0014 	ubfx	r0, r3, #0, #21
    t[ 0] = cd[ 0] + (sword64)ad[ 0] * bd[ 0];
     1c6:	2300      	movs	r3, #0
     1c8:	461a      	mov	r2, r3
     1ca:	fbe6 020c 	umlal	r0, r2, r6, ip
     1ce:	e9cd 0217 	strd	r0, r2, [sp, #92]	; 0x5c
    t[ 2] = cd[ 2] + (sword64)ad[ 0] * bd[ 2] + (sword64)ad[ 1] * bd[ 1] +
     1d2:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
     1d6:	9a01      	ldr	r2, [sp, #4]
    cd[ 2] = MASK_21 & (load_3(c +  5) >> 2);
     1d8:	f3ca 0094 	ubfx	r0, sl, #2, #21
    t[ 2] = cd[ 2] + (sword64)ad[ 0] * bd[ 2] + (sword64)ad[ 1] * bd[ 1] +
     1dc:	461e      	mov	r6, r3
     1de:	fbe2 060c 	umlal	r0, r6, r2, ip
     1e2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     1e4:	f8dd c008 	ldr.w	ip, [sp, #8]
     1e8:	fbe2 060c 	umlal	r0, r6, r2, ip
     1ec:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     1ee:	f8dd c00c 	ldr.w	ip, [sp, #12]
     1f2:	fbe2 060c 	umlal	r0, r6, r2, ip
     1f6:	9019      	str	r0, [sp, #100]	; 0x64
    t[ 4] = cd[ 4] + (sword64)ad[ 0] * bd[ 4] + (sword64)ad[ 1] * bd[ 3] +
     1f8:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
     1fc:	9801      	ldr	r0, [sp, #4]
    cd[ 4] = MASK_21 & (load_4(c + 10) >> 4);
     1fe:	f3cb 1214 	ubfx	r2, fp, #4, #21
    t[ 4] = cd[ 4] + (sword64)ad[ 0] * bd[ 4] + (sword64)ad[ 1] * bd[ 3] +
     202:	469b      	mov	fp, r3
     204:	fbe0 2b0c 	umlal	r2, fp, r0, ip
     208:	9802      	ldr	r0, [sp, #8]
     20a:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
     20e:	fbe0 2b0c 	umlal	r2, fp, r0, ip
     212:	980e      	ldr	r0, [sp, #56]	; 0x38
     214:	f8dd c00c 	ldr.w	ip, [sp, #12]
     218:	fbe0 2b0c 	umlal	r2, fp, r0, ip
                     (sword64)ad[ 2] * bd[ 2] + (sword64)ad[ 3] * bd[ 1] +
     21c:	980d      	ldr	r0, [sp, #52]	; 0x34
     21e:	f8dd c010 	ldr.w	ip, [sp, #16]
     222:	fbe0 2b0c 	umlal	r2, fp, r0, ip
     226:	f8dd c014 	ldr.w	ip, [sp, #20]
     22a:	980c      	ldr	r0, [sp, #48]	; 0x30
     22c:	fbe0 2b0c 	umlal	r2, fp, r0, ip
     230:	921a      	str	r2, [sp, #104]	; 0x68
    t[ 6] = cd[ 6] + (sword64)ad[ 0] * bd[ 6] + (sword64)ad[ 1] * bd[ 5] +
     232:	9801      	ldr	r0, [sp, #4]
    cd[ 6] = MASK_21 & (load_4(c + 15) >> 6);
     234:	f3c5 1294 	ubfx	r2, r5, #6, #21
    t[ 6] = cd[ 6] + (sword64)ad[ 0] * bd[ 6] + (sword64)ad[ 1] * bd[ 5] +
     238:	9d12      	ldr	r5, [sp, #72]	; 0x48
     23a:	469e      	mov	lr, r3
     23c:	fbe0 2e05 	umlal	r2, lr, r0, r5
     240:	9802      	ldr	r0, [sp, #8]
     242:	9d11      	ldr	r5, [sp, #68]	; 0x44
     244:	fbe0 2e05 	umlal	r2, lr, r0, r5
     248:	9803      	ldr	r0, [sp, #12]
     24a:	9d10      	ldr	r5, [sp, #64]	; 0x40
     24c:	fbe0 2e05 	umlal	r2, lr, r0, r5
                     (sword64)ad[ 2] * bd[ 4] + (sword64)ad[ 3] * bd[ 3] +
     250:	9d04      	ldr	r5, [sp, #16]
     252:	980f      	ldr	r0, [sp, #60]	; 0x3c
     254:	fbe0 2e05 	umlal	r2, lr, r0, r5
     258:	980e      	ldr	r0, [sp, #56]	; 0x38
                     (sword64)ad[ 4] * bd[ 2] + (sword64)ad[ 5] * bd[ 1] +
     25a:	9d06      	ldr	r5, [sp, #24]
                     (sword64)ad[ 2] * bd[ 4] + (sword64)ad[ 3] * bd[ 3] +
     25c:	fbe0 2e0c 	umlal	r2, lr, r0, ip
                     (sword64)ad[ 4] * bd[ 2] + (sword64)ad[ 5] * bd[ 1] +
     260:	980d      	ldr	r0, [sp, #52]	; 0x34
    t[ 8] = cd[ 8] + (sword64)ad[ 0] * bd[ 8] + (sword64)ad[ 1] * bd[ 7] +
     262:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
                     (sword64)ad[ 4] * bd[ 2] + (sword64)ad[ 5] * bd[ 1] +
     266:	fbe0 2e05 	umlal	r2, lr, r0, r5
     26a:	980c      	ldr	r0, [sp, #48]	; 0x30
     26c:	9d07      	ldr	r5, [sp, #28]
     26e:	fbe0 2e05 	umlal	r2, lr, r0, r5
     272:	921b      	str	r2, [sp, #108]	; 0x6c
    cd[ 8] = MASK_21 & (load_3(c + 21) >> 0);
     274:	9a1c      	ldr	r2, [sp, #112]	; 0x70
     276:	f3c2 0014 	ubfx	r0, r2, #0, #21
    t[ 8] = cd[ 8] + (sword64)ad[ 0] * bd[ 8] + (sword64)ad[ 1] * bd[ 7] +
     27a:	9a01      	ldr	r2, [sp, #4]
     27c:	461d      	mov	r5, r3
     27e:	fbe2 050c 	umlal	r0, r5, r2, ip
     282:	9a02      	ldr	r2, [sp, #8]
     284:	f8dd c04c 	ldr.w	ip, [sp, #76]	; 0x4c
     288:	fbe2 050c 	umlal	r0, r5, r2, ip
     28c:	9a03      	ldr	r2, [sp, #12]
     28e:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
     292:	fbe2 050c 	umlal	r0, r5, r2, ip
                     (sword64)ad[ 2] * bd[ 6] + (sword64)ad[ 3] * bd[ 5] +
     296:	9a04      	ldr	r2, [sp, #16]
     298:	f8dd c044 	ldr.w	ip, [sp, #68]	; 0x44
     29c:	fbe2 050c 	umlal	r0, r5, r2, ip
     2a0:	9a10      	ldr	r2, [sp, #64]	; 0x40
     2a2:	f8dd c014 	ldr.w	ip, [sp, #20]
     2a6:	fbe2 050c 	umlal	r0, r5, r2, ip
                     (sword64)ad[ 4] * bd[ 4] + (sword64)ad[ 5] * bd[ 3] +
     2aa:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
     2ac:	f8dd c018 	ldr.w	ip, [sp, #24]
     2b0:	fbe2 050c 	umlal	r0, r5, r2, ip
     2b4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
     2b6:	f8dd c01c 	ldr.w	ip, [sp, #28]
     2ba:	fbe2 050c 	umlal	r0, r5, r2, ip
                     (sword64)ad[ 6] * bd[ 2] + (sword64)ad[ 7] * bd[ 1] +
     2be:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     2c0:	f8dd c020 	ldr.w	ip, [sp, #32]
     2c4:	fbe2 050c 	umlal	r0, r5, r2, ip
     2c8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     2ca:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
     2ce:	fbe2 050c 	umlal	r0, r5, r2, ip
     2d2:	901c      	str	r0, [sp, #112]	; 0x70
    t[10] = cd[10] + (sword64)ad[ 0] * bd[10] + (sword64)ad[ 1] * bd[ 9] +
     2d4:	9a01      	ldr	r2, [sp, #4]
    cd[10] = MASK_21 & (load_3(c + 26) >> 2);
     2d6:	f3c7 0094 	ubfx	r0, r7, #2, #21
    t[10] = cd[10] + (sword64)ad[ 0] * bd[10] + (sword64)ad[ 1] * bd[ 9] +
     2da:	9f16      	ldr	r7, [sp, #88]	; 0x58
     2dc:	469c      	mov	ip, r3
     2de:	fbe2 0c07 	umlal	r0, ip, r2, r7
     2e2:	9a02      	ldr	r2, [sp, #8]
     2e4:	9f15      	ldr	r7, [sp, #84]	; 0x54
     2e6:	fbe2 0c07 	umlal	r0, ip, r2, r7
     2ea:	9f14      	ldr	r7, [sp, #80]	; 0x50
     2ec:	9a03      	ldr	r2, [sp, #12]
     2ee:	fbe2 0c07 	umlal	r0, ip, r2, r7
                     (sword64)ad[ 2] * bd[ 8] + (sword64)ad[ 3] * bd[ 7] +
     2f2:	9a04      	ldr	r2, [sp, #16]
     2f4:	9f13      	ldr	r7, [sp, #76]	; 0x4c
     2f6:	fbe2 0c07 	umlal	r0, ip, r2, r7
     2fa:	9a05      	ldr	r2, [sp, #20]
     2fc:	9f12      	ldr	r7, [sp, #72]	; 0x48
     2fe:	fbe2 0c07 	umlal	r0, ip, r2, r7
                     (sword64)ad[ 4] * bd[ 6] + (sword64)ad[ 5] * bd[ 5] +
     302:	9a11      	ldr	r2, [sp, #68]	; 0x44
     304:	9f06      	ldr	r7, [sp, #24]
     306:	fbe2 0c07 	umlal	r0, ip, r2, r7
     30a:	9a10      	ldr	r2, [sp, #64]	; 0x40
     30c:	9f07      	ldr	r7, [sp, #28]
     30e:	fbe2 0c07 	umlal	r0, ip, r2, r7
                     (sword64)ad[ 6] * bd[ 4] + (sword64)ad[ 7] * bd[ 3] +
     312:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
     314:	9f08      	ldr	r7, [sp, #32]
     316:	fbe2 0c07 	umlal	r0, ip, r2, r7
     31a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
     31c:	9f09      	ldr	r7, [sp, #36]	; 0x24
     31e:	fbe2 0c07 	umlal	r0, ip, r2, r7
                     (sword64)ad[ 8] * bd[ 2] + (sword64)ad[ 9] * bd[ 1] +
     322:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     324:	9f0a      	ldr	r7, [sp, #40]	; 0x28
     326:	fbe2 0c07 	umlal	r0, ip, r2, r7
     32a:	e9dd 720b 	ldrd	r7, r2, [sp, #44]	; 0x2c
     32e:	fbe2 0c07 	umlal	r0, ip, r2, r7
    ad[11] = (word32)(load_4(a + 28) >> 7);
     332:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    t[12] =          (sword64)ad[ 1] * bd[11] + (sword64)ad[ 2] * bd[10] +
     334:	9f16      	ldr	r7, [sp, #88]	; 0x58
    bd[11] = (word32)(load_4(b + 28) >> 7);
     336:	ea4f 19d9 	mov.w	r9, r9, lsr #7
    ad[11] = (word32)(load_4(a + 28) >> 7);
     33a:	ea4f 18d8 	mov.w	r8, r8, lsr #7
     33e:	ea48 6842 	orr.w	r8, r8, r2, lsl #25
    bd[11] = (word32)(load_4(b + 28) >> 7);
     342:	ea49 6944 	orr.w	r9, r9, r4, lsl #25
    t[12] =          (sword64)ad[ 1] * bd[11] + (sword64)ad[ 2] * bd[10] +
     346:	9a02      	ldr	r2, [sp, #8]
     348:	9c03      	ldr	r4, [sp, #12]
                     (sword64)ad[ 8] * bd[ 2] + (sword64)ad[ 9] * bd[ 1] +
     34a:	e9cd 0c1d 	strd	r0, ip, [sp, #116]	; 0x74
    t[12] =          (sword64)ad[ 1] * bd[11] + (sword64)ad[ 2] * bd[10] +
     34e:	fba4 4707 	umull	r4, r7, r4, r7
     352:	fba2 2009 	umull	r2, r0, r2, r9
     356:	1912      	adds	r2, r2, r4
     358:	eb40 0707 	adc.w	r7, r0, r7
     35c:	9c15      	ldr	r4, [sp, #84]	; 0x54
     35e:	9804      	ldr	r0, [sp, #16]
     360:	fbe0 2704 	umlal	r2, r7, r0, r4
     364:	4610      	mov	r0, r2
                     (sword64)ad[ 3] * bd[ 9] + (sword64)ad[ 4] * bd[ 8] +
     366:	9c14      	ldr	r4, [sp, #80]	; 0x50
     368:	9a05      	ldr	r2, [sp, #20]
     36a:	fbe2 0704 	umlal	r0, r7, r2, r4
     36e:	9a06      	ldr	r2, [sp, #24]
     370:	9c13      	ldr	r4, [sp, #76]	; 0x4c
     372:	fbe2 0704 	umlal	r0, r7, r2, r4
                     (sword64)ad[ 5] * bd[ 7] + (sword64)ad[ 6] * bd[ 6] +
     376:	9a12      	ldr	r2, [sp, #72]	; 0x48
     378:	9c07      	ldr	r4, [sp, #28]
     37a:	fbe2 0704 	umlal	r0, r7, r2, r4
     37e:	9c08      	ldr	r4, [sp, #32]
     380:	9a11      	ldr	r2, [sp, #68]	; 0x44
     382:	fbe2 0704 	umlal	r0, r7, r2, r4
                     (sword64)ad[ 7] * bd[ 5] + (sword64)ad[ 8] * bd[ 4] +
     386:	9a10      	ldr	r2, [sp, #64]	; 0x40
     388:	9c09      	ldr	r4, [sp, #36]	; 0x24
    t[14] =          (sword64)ad[ 3] * bd[11] + (sword64)ad[ 4] * bd[10] +
     38a:	f8dd c058 	ldr.w	ip, [sp, #88]	; 0x58
                     (sword64)ad[ 7] * bd[ 5] + (sword64)ad[ 8] * bd[ 4] +
     38e:	fbe2 0704 	umlal	r0, r7, r2, r4
     392:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
     394:	9c0a      	ldr	r4, [sp, #40]	; 0x28
     396:	fbe2 0704 	umlal	r0, r7, r2, r4
                     (sword64)ad[ 9] * bd[ 3] + (sword64)ad[10] * bd[ 2] +
     39a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
     39c:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
     39e:	fbe2 0704 	umlal	r0, r7, r2, r4
                     (sword64)ad[11] * bd[ 1];
     3a2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     3a4:	fba2 2408 	umull	r2, r4, r2, r8
                     (sword64)ad[ 9] * bd[ 3] + (sword64)ad[10] * bd[ 2] +
     3a8:	1882      	adds	r2, r0, r2
     3aa:	eb47 0704 	adc.w	r7, r7, r4
     3ae:	921f      	str	r2, [sp, #124]	; 0x7c
    t[14] =          (sword64)ad[ 3] * bd[11] + (sword64)ad[ 4] * bd[10] +
     3b0:	9c05      	ldr	r4, [sp, #20]
     3b2:	9a04      	ldr	r2, [sp, #16]
     3b4:	fba4 4c0c 	umull	r4, ip, r4, ip
     3b8:	fba2 2009 	umull	r2, r0, r2, r9
     3bc:	1912      	adds	r2, r2, r4
     3be:	eb40 000c 	adc.w	r0, r0, ip
     3c2:	9c06      	ldr	r4, [sp, #24]
     3c4:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
     3c8:	fbe4 200c 	umlal	r2, r0, r4, ip
                     (sword64)ad[ 5] * bd[ 9] + (sword64)ad[ 6] * bd[ 8] +
     3cc:	9c07      	ldr	r4, [sp, #28]
     3ce:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
     3d2:	fbe4 200c 	umlal	r2, r0, r4, ip
     3d6:	9c13      	ldr	r4, [sp, #76]	; 0x4c
     3d8:	f8dd c020 	ldr.w	ip, [sp, #32]
     3dc:	fbe4 200c 	umlal	r2, r0, r4, ip
                     (sword64)ad[ 7] * bd[ 7] + (sword64)ad[ 8] * bd[ 6] +
     3e0:	9c12      	ldr	r4, [sp, #72]	; 0x48
     3e2:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
     3e6:	fbe4 200c 	umlal	r2, r0, r4, ip
     3ea:	9c11      	ldr	r4, [sp, #68]	; 0x44
     3ec:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
     3f0:	fbe4 200c 	umlal	r2, r0, r4, ip
                     (sword64)ad[ 9] * bd[ 5] + (sword64)ad[10] * bd[ 4] +
     3f4:	9c10      	ldr	r4, [sp, #64]	; 0x40
     3f6:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
     3fa:	fbe4 200c 	umlal	r2, r0, r4, ip
                     (sword64)ad[11] * bd[ 3];
     3fe:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
     400:	fba4 4c08 	umull	r4, ip, r4, r8
                     (sword64)ad[ 9] * bd[ 5] + (sword64)ad[10] * bd[ 4] +
     404:	1912      	adds	r2, r2, r4
     406:	9220      	str	r2, [sp, #128]	; 0x80
     408:	eb40 020c 	adc.w	r2, r0, ip
    t[16] =          (sword64)ad[ 5] * bd[11] + (sword64)ad[ 6] * bd[10] +
     40c:	9c07      	ldr	r4, [sp, #28]
     40e:	f8dd c058 	ldr.w	ip, [sp, #88]	; 0x58
                     (sword64)ad[ 9] * bd[ 5] + (sword64)ad[10] * bd[ 4] +
     412:	9221      	str	r2, [sp, #132]	; 0x84
    t[16] =          (sword64)ad[ 5] * bd[11] + (sword64)ad[ 6] * bd[10] +
     414:	9a06      	ldr	r2, [sp, #24]
     416:	fba4 c40c 	umull	ip, r4, r4, ip
     41a:	fba2 2009 	umull	r2, r0, r2, r9
     41e:	eb12 020c 	adds.w	r2, r2, ip
     422:	eb40 0404 	adc.w	r4, r0, r4
     426:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
     42a:	9808      	ldr	r0, [sp, #32]
     42c:	fbe0 240c 	umlal	r2, r4, r0, ip
                     (sword64)ad[ 7] * bd[ 9] + (sword64)ad[ 8] * bd[ 8] +
     430:	9814      	ldr	r0, [sp, #80]	; 0x50
     432:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
     436:	fbe0 240c 	umlal	r2, r4, r0, ip
     43a:	9813      	ldr	r0, [sp, #76]	; 0x4c
     43c:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
     440:	fbe0 240c 	umlal	r2, r4, r0, ip
                     (sword64)ad[ 9] * bd[ 7] + (sword64)ad[10] * bd[ 6] +
     444:	9812      	ldr	r0, [sp, #72]	; 0x48
     446:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
     44a:	fbe0 240c 	umlal	r2, r4, r0, ip
                     (sword64)ad[11] * bd[ 5];
     44e:	9811      	ldr	r0, [sp, #68]	; 0x44
     450:	fba0 0c08 	umull	r0, ip, r0, r8
                     (sword64)ad[ 9] * bd[ 7] + (sword64)ad[10] * bd[ 6] +
     454:	1812      	adds	r2, r2, r0
     456:	9222      	str	r2, [sp, #136]	; 0x88
     458:	eb44 020c 	adc.w	r2, r4, ip
    t[18] =          (sword64)ad[ 7] * bd[11] + (sword64)ad[ 8] * bd[10] +
     45c:	9809      	ldr	r0, [sp, #36]	; 0x24
     45e:	9c16      	ldr	r4, [sp, #88]	; 0x58
                     (sword64)ad[ 9] * bd[ 7] + (sword64)ad[10] * bd[ 6] +
     460:	9223      	str	r2, [sp, #140]	; 0x8c
    t[18] =          (sword64)ad[ 7] * bd[11] + (sword64)ad[ 8] * bd[10] +
     462:	9a08      	ldr	r2, [sp, #32]
    t[20] =          (sword64)ad[ 9] * bd[11] + (sword64)ad[10] * bd[10] +
     464:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    t[18] =          (sword64)ad[ 7] * bd[11] + (sword64)ad[ 8] * bd[10] +
     468:	fba0 0404 	umull	r0, r4, r0, r4
     46c:	fba2 2a09 	umull	r2, sl, r2, r9
     470:	1812      	adds	r2, r2, r0
     472:	eb4a 0a04 	adc.w	sl, sl, r4
     476:	9815      	ldr	r0, [sp, #84]	; 0x54
     478:	9c0a      	ldr	r4, [sp, #40]	; 0x28
     47a:	fbe0 2a04 	umlal	r2, sl, r0, r4
                     (sword64)ad[ 9] * bd[ 9] + (sword64)ad[10] * bd[ 8] +
     47e:	9814      	ldr	r0, [sp, #80]	; 0x50
     480:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
     482:	fbe0 2a04 	umlal	r2, sl, r0, r4
                     (sword64)ad[11] * bd[ 7];
     486:	9813      	ldr	r0, [sp, #76]	; 0x4c
     488:	fba0 0408 	umull	r0, r4, r0, r8
                     (sword64)ad[ 9] * bd[ 9] + (sword64)ad[10] * bd[ 8] +
     48c:	1812      	adds	r2, r2, r0
     48e:	9224      	str	r2, [sp, #144]	; 0x90
     490:	eb4a 0204 	adc.w	r2, sl, r4
    t[20] =          (sword64)ad[ 9] * bd[11] + (sword64)ad[10] * bd[10] +
     494:	9816      	ldr	r0, [sp, #88]	; 0x58
                     (sword64)ad[ 9] * bd[ 9] + (sword64)ad[10] * bd[ 8] +
     496:	9225      	str	r2, [sp, #148]	; 0x94
    t[20] =          (sword64)ad[ 9] * bd[11] + (sword64)ad[10] * bd[10] +
     498:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     49a:	fba0 c00c 	umull	ip, r0, r0, ip
     49e:	fba2 2409 	umull	r2, r4, r2, r9
     4a2:	eb12 020c 	adds.w	r2, r2, ip
     4a6:	eb44 0400 	adc.w	r4, r4, r0
                     (sword64)ad[11] * bd[ 9];
     4aa:	9815      	ldr	r0, [sp, #84]	; 0x54
     4ac:	fba0 0c08 	umull	r0, ip, r0, r8
    t[20] =          (sword64)ad[ 9] * bd[11] + (sword64)ad[10] * bd[10] +
     4b0:	1812      	adds	r2, r2, r0
     4b2:	9226      	str	r2, [sp, #152]	; 0x98
     4b4:	eb44 020c 	adc.w	r2, r4, ip
     4b8:	9227      	str	r2, [sp, #156]	; 0x9c
    t[22] =          (sword64)ad[11] * bd[11];
     4ba:	fba9 2008 	umull	r2, r0, r9, r8
     4be:	e9cd 2028 	strd	r2, r0, [sp, #160]	; 0xa0
    cd[ 1] = MASK_21 & (load_4(c +  2) >> 5);
     4c2:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
    t[ 1] = cd[ 1] + (sword64)ad[ 0] * bd[ 1] + (sword64)ad[ 1] * bd[ 0];
     4c4:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
    cd[ 1] = MASK_21 & (load_4(c +  2) >> 5);
     4c8:	f3c2 1454 	ubfx	r4, r2, #5, #21
    t[ 1] = cd[ 1] + (sword64)ad[ 0] * bd[ 1] + (sword64)ad[ 1] * bd[ 0];
     4cc:	9a01      	ldr	r2, [sp, #4]
     4ce:	4618      	mov	r0, r3
     4d0:	fbe2 400c 	umlal	r4, r0, r2, ip
     4d4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     4d6:	f8dd c008 	ldr.w	ip, [sp, #8]
     4da:	fbe2 400c 	umlal	r4, r0, r2, ip
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
     4de:	9a17      	ldr	r2, [sp, #92]	; 0x5c
     4e0:	f8dd c060 	ldr.w	ip, [sp, #96]	; 0x60
     4e4:	0d52      	lsrs	r2, r2, #21
     4e6:	ea42 22cc 	orr.w	r2, r2, ip, lsl #11
     4ea:	18a2      	adds	r2, r4, r2
     4ec:	922a      	str	r2, [sp, #168]	; 0xa8
     4ee:	eb40 526c 	adc.w	r2, r0, ip, asr #21
     4f2:	9218      	str	r2, [sp, #96]	; 0x60
    cd[ 3] = MASK_21 & (load_4(c +  7) >> 7);
     4f4:	9a2b      	ldr	r2, [sp, #172]	; 0xac
    t[ 3] = cd[ 3] + (sword64)ad[ 0] * bd[ 3] + (sword64)ad[ 1] * bd[ 2] +
     4f6:	980f      	ldr	r0, [sp, #60]	; 0x3c
    cd[ 3] = MASK_21 & (load_4(c +  7) >> 7);
     4f8:	f3c2 14d4 	ubfx	r4, r2, #7, #21
    t[ 3] = cd[ 3] + (sword64)ad[ 0] * bd[ 3] + (sword64)ad[ 1] * bd[ 2] +
     4fc:	9a01      	ldr	r2, [sp, #4]
     4fe:	469a      	mov	sl, r3
     500:	fbe2 4a00 	umlal	r4, sl, r2, r0
     504:	9a02      	ldr	r2, [sp, #8]
     506:	980e      	ldr	r0, [sp, #56]	; 0x38
     508:	fbe2 4a00 	umlal	r4, sl, r2, r0
     50c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     50e:	9803      	ldr	r0, [sp, #12]
     510:	fbe2 4a00 	umlal	r4, sl, r2, r0
                     (sword64)ad[ 2] * bd[ 1] + (sword64)ad[ 3] * bd[ 0];
     514:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     516:	9804      	ldr	r0, [sp, #16]
     518:	fbe2 4a00 	umlal	r4, sl, r2, r0
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
     51c:	9a19      	ldr	r2, [sp, #100]	; 0x64
     51e:	ea4f 5c52 	mov.w	ip, r2, lsr #21
     522:	ea4c 2cc6 	orr.w	ip, ip, r6, lsl #11
     526:	eb14 020c 	adds.w	r2, r4, ip
     52a:	922b      	str	r2, [sp, #172]	; 0xac
     52c:	eb4a 5266 	adc.w	r2, sl, r6, asr #21
     530:	922c      	str	r2, [sp, #176]	; 0xb0
    cd[ 5] = MASK_21 & (load_3(c + 13) >> 1);
     532:	9a2d      	ldr	r2, [sp, #180]	; 0xb4
    t[ 5] = cd[ 5] + (sword64)ad[ 0] * bd[ 5] + (sword64)ad[ 1] * bd[ 4] +
     534:	9c11      	ldr	r4, [sp, #68]	; 0x44
    cd[ 5] = MASK_21 & (load_3(c + 13) >> 1);
     536:	f3c2 0c54 	ubfx	ip, r2, #1, #21
    t[ 5] = cd[ 5] + (sword64)ad[ 0] * bd[ 5] + (sword64)ad[ 1] * bd[ 4] +
     53a:	9a01      	ldr	r2, [sp, #4]
     53c:	4618      	mov	r0, r3
     53e:	fbe2 c004 	umlal	ip, r0, r2, r4
     542:	9a02      	ldr	r2, [sp, #8]
     544:	9c10      	ldr	r4, [sp, #64]	; 0x40
     546:	fbe2 c004 	umlal	ip, r0, r2, r4
     54a:	9a03      	ldr	r2, [sp, #12]
     54c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
     54e:	fbe2 c004 	umlal	ip, r0, r2, r4
                     (sword64)ad[ 2] * bd[ 3] + (sword64)ad[ 3] * bd[ 2] +
     552:	9a0e      	ldr	r2, [sp, #56]	; 0x38
     554:	9c04      	ldr	r4, [sp, #16]
     556:	fbe2 c004 	umlal	ip, r0, r2, r4
     55a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
     55c:	9c05      	ldr	r4, [sp, #20]
     55e:	fbe2 c004 	umlal	ip, r0, r2, r4
                     (sword64)ad[ 4] * bd[ 1] + (sword64)ad[ 5] * bd[ 0];
     562:	9c06      	ldr	r4, [sp, #24]
     564:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     566:	fbe2 c004 	umlal	ip, r0, r2, r4
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
     56a:	9a1a      	ldr	r2, [sp, #104]	; 0x68
     56c:	0d52      	lsrs	r2, r2, #21
     56e:	ea42 22cb 	orr.w	r2, r2, fp, lsl #11
     572:	eb1c 0202 	adds.w	r2, ip, r2
     576:	922d      	str	r2, [sp, #180]	; 0xb4
     578:	eb40 526b 	adc.w	r2, r0, fp, asr #21
     57c:	922e      	str	r2, [sp, #184]	; 0xb8
    cd[ 7] = MASK_21 & (load_3(c + 18) >> 3);
     57e:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
     580:	f3c2 06d4 	ubfx	r6, r2, #3, #21
    t[ 7] = cd[ 7] + (sword64)ad[ 0] * bd[ 7] + (sword64)ad[ 1] * bd[ 6] +
     584:	9a01      	ldr	r2, [sp, #4]
     586:	9813      	ldr	r0, [sp, #76]	; 0x4c
     588:	469a      	mov	sl, r3
     58a:	fbe2 6a00 	umlal	r6, sl, r2, r0
     58e:	9a02      	ldr	r2, [sp, #8]
     590:	9812      	ldr	r0, [sp, #72]	; 0x48
     592:	fbe2 6a00 	umlal	r6, sl, r2, r0
     596:	9a03      	ldr	r2, [sp, #12]
     598:	9811      	ldr	r0, [sp, #68]	; 0x44
     59a:	fbe2 6a00 	umlal	r6, sl, r2, r0
                     (sword64)ad[ 2] * bd[ 5] + (sword64)ad[ 3] * bd[ 4] +
     59e:	9a04      	ldr	r2, [sp, #16]
     5a0:	9810      	ldr	r0, [sp, #64]	; 0x40
     5a2:	fbe2 6a00 	umlal	r6, sl, r2, r0
     5a6:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
     5a8:	9805      	ldr	r0, [sp, #20]
     5aa:	fbe2 6a00 	umlal	r6, sl, r2, r0
                     (sword64)ad[ 4] * bd[ 3] + (sword64)ad[ 5] * bd[ 2] +
     5ae:	9a0e      	ldr	r2, [sp, #56]	; 0x38
     5b0:	9807      	ldr	r0, [sp, #28]
     5b2:	fbe2 6a04 	umlal	r6, sl, r2, r4
     5b6:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    t[ 9] = cd[ 9] + (sword64)ad[ 0] * bd[ 9] + (sword64)ad[ 1] * bd[ 8] +
     5b8:	9c15      	ldr	r4, [sp, #84]	; 0x54
                     (sword64)ad[ 4] * bd[ 3] + (sword64)ad[ 5] * bd[ 2] +
     5ba:	fbe2 6a00 	umlal	r6, sl, r2, r0
                     (sword64)ad[ 6] * bd[ 1] + (sword64)ad[ 7] * bd[ 0];
     5be:	9a0c      	ldr	r2, [sp, #48]	; 0x30
     5c0:	9808      	ldr	r0, [sp, #32]
     5c2:	fbe2 6a00 	umlal	r6, sl, r2, r0
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
     5c6:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
     5c8:	0d50      	lsrs	r0, r2, #21
     5ca:	ea40 20ce 	orr.w	r0, r0, lr, lsl #11
     5ce:	1832      	adds	r2, r6, r0
     5d0:	922f      	str	r2, [sp, #188]	; 0xbc
     5d2:	eb4a 526e 	adc.w	r2, sl, lr, asr #21
     5d6:	9230      	str	r2, [sp, #192]	; 0xc0
    cd[ 9] = MASK_21 & (load_4(c + 23) >> 5);
     5d8:	9a31      	ldr	r2, [sp, #196]	; 0xc4
     5da:	f3c2 1054 	ubfx	r0, r2, #5, #21
    t[ 9] = cd[ 9] + (sword64)ad[ 0] * bd[ 9] + (sword64)ad[ 1] * bd[ 8] +
     5de:	9a01      	ldr	r2, [sp, #4]
     5e0:	fbe2 0304 	umlal	r0, r3, r2, r4
     5e4:	469b      	mov	fp, r3
     5e6:	9a14      	ldr	r2, [sp, #80]	; 0x50
     5e8:	9b02      	ldr	r3, [sp, #8]
     5ea:	fbe3 0b02 	umlal	r0, fp, r3, r2
     5ee:	9b03      	ldr	r3, [sp, #12]
     5f0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
     5f2:	fbe3 0b02 	umlal	r0, fp, r3, r2
                     (sword64)ad[ 2] * bd[ 7] + (sword64)ad[ 3] * bd[ 6] +
     5f6:	9b04      	ldr	r3, [sp, #16]
     5f8:	9a12      	ldr	r2, [sp, #72]	; 0x48
     5fa:	fbe3 0b02 	umlal	r0, fp, r3, r2
     5fe:	9b05      	ldr	r3, [sp, #20]
     600:	9a11      	ldr	r2, [sp, #68]	; 0x44
     602:	fbe3 0b02 	umlal	r0, fp, r3, r2
                     (sword64)ad[ 4] * bd[ 5] + (sword64)ad[ 5] * bd[ 4] +
     606:	9b10      	ldr	r3, [sp, #64]	; 0x40
     608:	9a06      	ldr	r2, [sp, #24]
     60a:	fbe3 0b02 	umlal	r0, fp, r3, r2
     60e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     610:	9a07      	ldr	r2, [sp, #28]
     612:	fbe3 0b02 	umlal	r0, fp, r3, r2
                     (sword64)ad[ 6] * bd[ 3] + (sword64)ad[ 7] * bd[ 2] +
     616:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     618:	9a08      	ldr	r2, [sp, #32]
     61a:	fbe3 0b02 	umlal	r0, fp, r3, r2
     61e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     620:	9a09      	ldr	r2, [sp, #36]	; 0x24
     622:	fbe3 0b02 	umlal	r0, fp, r3, r2
                     (sword64)ad[ 8] * bd[ 1] + (sword64)ad[ 9] * bd[ 0];
     626:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     628:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     62a:	fbe3 0b02 	umlal	r0, fp, r3, r2
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
     62e:	9b1c      	ldr	r3, [sp, #112]	; 0x70
     630:	0d5b      	lsrs	r3, r3, #21
     632:	ea43 23c5 	orr.w	r3, r3, r5, lsl #11
     636:	18c3      	adds	r3, r0, r3
     638:	9331      	str	r3, [sp, #196]	; 0xc4
     63a:	eb4b 5365 	adc.w	r3, fp, r5, asr #21
     63e:	9332      	str	r3, [sp, #200]	; 0xc8
    cd[11] = (word32)(load_4(c + 28) >> 7);
     640:	9b33      	ldr	r3, [sp, #204]	; 0xcc
    t[16] -= t[23] * ORDER_5;
     642:	f8df b304 	ldr.w	fp, [pc, #772]	; 948 <sc_muladd+0x948>
    cd[11] = (word32)(load_4(c + 28) >> 7);
     646:	09da      	lsrs	r2, r3, #7
    t[11] = cd[11] + (sword64)ad[ 0] * bd[11] + (sword64)ad[ 1] * bd[10] +
     648:	9b01      	ldr	r3, [sp, #4]
    cd[11] = (word32)(load_4(c + 28) >> 7);
     64a:	ea42 6241 	orr.w	r2, r2, r1, lsl #25
    t[11] = cd[11] + (sword64)ad[ 0] * bd[11] + (sword64)ad[ 1] * bd[10] +
     64e:	fba3 0309 	umull	r0, r3, r3, r9
     652:	1815      	adds	r5, r2, r0
     654:	f143 0c00 	adc.w	ip, r3, #0
     658:	9a16      	ldr	r2, [sp, #88]	; 0x58
     65a:	9b02      	ldr	r3, [sp, #8]
     65c:	fbe3 5c02 	umlal	r5, ip, r3, r2
     660:	9b03      	ldr	r3, [sp, #12]
                     (sword64)ad[ 2] * bd[ 9] + (sword64)ad[ 3] * bd[ 8] +
     662:	9a14      	ldr	r2, [sp, #80]	; 0x50
    t[11] = cd[11] + (sword64)ad[ 0] * bd[11] + (sword64)ad[ 1] * bd[10] +
     664:	fbe3 5c04 	umlal	r5, ip, r3, r4
                     (sword64)ad[ 2] * bd[ 9] + (sword64)ad[ 3] * bd[ 8] +
     668:	9b04      	ldr	r3, [sp, #16]
     66a:	fbe3 5c02 	umlal	r5, ip, r3, r2
     66e:	9b05      	ldr	r3, [sp, #20]
     670:	9a13      	ldr	r2, [sp, #76]	; 0x4c
     672:	fbe3 5c02 	umlal	r5, ip, r3, r2
                     (sword64)ad[ 4] * bd[ 7] + (sword64)ad[ 5] * bd[ 6] +
     676:	9b06      	ldr	r3, [sp, #24]
     678:	9a12      	ldr	r2, [sp, #72]	; 0x48
     67a:	fbe3 5c02 	umlal	r5, ip, r3, r2
     67e:	9b11      	ldr	r3, [sp, #68]	; 0x44
     680:	9a07      	ldr	r2, [sp, #28]
     682:	fbe3 5c02 	umlal	r5, ip, r3, r2
                     (sword64)ad[ 6] * bd[ 5] + (sword64)ad[ 7] * bd[ 4] +
     686:	9b10      	ldr	r3, [sp, #64]	; 0x40
     688:	9a08      	ldr	r2, [sp, #32]
     68a:	fbe3 5c02 	umlal	r5, ip, r3, r2
     68e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
     690:	9a09      	ldr	r2, [sp, #36]	; 0x24
     692:	fbe3 5c02 	umlal	r5, ip, r3, r2
                     (sword64)ad[ 8] * bd[ 3] + (sword64)ad[ 9] * bd[ 2] +
     696:	9b0e      	ldr	r3, [sp, #56]	; 0x38
     698:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     69a:	fbe3 5c02 	umlal	r5, ip, r3, r2
     69e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     6a0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
     6a2:	fbe3 5c02 	umlal	r5, ip, r3, r2
                     (sword64)ad[10] * bd[ 1] + (sword64)ad[11] * bd[ 0];
     6a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     6a8:	fba3 0e08 	umull	r0, lr, r3, r8
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     6ac:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    t[13] =          (sword64)ad[ 2] * bd[11] + (sword64)ad[ 3] * bd[10] +
     6ae:	9916      	ldr	r1, [sp, #88]	; 0x58
                     (sword64)ad[10] * bd[ 1] + (sword64)ad[11] * bd[ 0];
     6b0:	182d      	adds	r5, r5, r0
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     6b2:	ea4f 5053 	mov.w	r0, r3, lsr #21
     6b6:	9b1e      	ldr	r3, [sp, #120]	; 0x78
     6b8:	ea40 20c3 	orr.w	r0, r0, r3, lsl #11
                     (sword64)ad[10] * bd[ 1] + (sword64)ad[11] * bd[ 0];
     6bc:	eb4c 0c0e 	adc.w	ip, ip, lr
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     6c0:	182b      	adds	r3, r5, r0
     6c2:	9333      	str	r3, [sp, #204]	; 0xcc
     6c4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
     6c6:	eb4c 5e63 	adc.w	lr, ip, r3, asr #21
    t[13] =          (sword64)ad[ 2] * bd[11] + (sword64)ad[ 3] * bd[10] +
     6ca:	9b03      	ldr	r3, [sp, #12]
     6cc:	fba3 0209 	umull	r0, r2, r3, r9
     6d0:	9b04      	ldr	r3, [sp, #16]
     6d2:	fba3 3101 	umull	r3, r1, r3, r1
     6d6:	18c0      	adds	r0, r0, r3
     6d8:	eb42 0601 	adc.w	r6, r2, r1
     6dc:	9a05      	ldr	r2, [sp, #20]
                     (sword64)ad[ 4] * bd[ 9] + (sword64)ad[ 5] * bd[ 8] +
     6de:	9914      	ldr	r1, [sp, #80]	; 0x50
    t[13] =          (sword64)ad[ 2] * bd[11] + (sword64)ad[ 3] * bd[10] +
     6e0:	4603      	mov	r3, r0
     6e2:	fbe2 3604 	umlal	r3, r6, r2, r4
                     (sword64)ad[ 4] * bd[ 9] + (sword64)ad[ 5] * bd[ 8] +
     6e6:	9a06      	ldr	r2, [sp, #24]
     6e8:	fbe2 3601 	umlal	r3, r6, r2, r1
     6ec:	9a07      	ldr	r2, [sp, #28]
     6ee:	9913      	ldr	r1, [sp, #76]	; 0x4c
     6f0:	fbe2 3601 	umlal	r3, r6, r2, r1
                     (sword64)ad[ 6] * bd[ 7] + (sword64)ad[ 7] * bd[ 6] +
     6f4:	9a12      	ldr	r2, [sp, #72]	; 0x48
     6f6:	9908      	ldr	r1, [sp, #32]
     6f8:	fbe2 3601 	umlal	r3, r6, r2, r1
     6fc:	9a11      	ldr	r2, [sp, #68]	; 0x44
     6fe:	9909      	ldr	r1, [sp, #36]	; 0x24
     700:	fbe2 3601 	umlal	r3, r6, r2, r1
                     (sword64)ad[ 8] * bd[ 5] + (sword64)ad[ 9] * bd[ 4] +
     704:	9a10      	ldr	r2, [sp, #64]	; 0x40
     706:	990a      	ldr	r1, [sp, #40]	; 0x28
     708:	fbe2 3601 	umlal	r3, r6, r2, r1
     70c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
     70e:	990b      	ldr	r1, [sp, #44]	; 0x2c
     710:	fbe2 3601 	umlal	r3, r6, r2, r1
                     (sword64)ad[10] * bd[ 3] + (sword64)ad[11] * bd[ 2];
     714:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    t[15] =          (sword64)ad[ 4] * bd[11] + (sword64)ad[ 5] * bd[10] +
     716:	9916      	ldr	r1, [sp, #88]	; 0x58
                     (sword64)ad[10] * bd[ 3] + (sword64)ad[11] * bd[ 2];
     718:	fba2 0508 	umull	r0, r5, r2, r8
     71c:	1818      	adds	r0, r3, r0
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     71e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
     720:	ea4f 5353 	mov.w	r3, r3, lsr #21
     724:	ea43 23c7 	orr.w	r3, r3, r7, lsl #11
                     (sword64)ad[10] * bd[ 3] + (sword64)ad[11] * bd[ 2];
     728:	eb46 0605 	adc.w	r6, r6, r5
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     72c:	18c3      	adds	r3, r0, r3
     72e:	931e      	str	r3, [sp, #120]	; 0x78
    t[15] =          (sword64)ad[ 4] * bd[11] + (sword64)ad[ 5] * bd[10] +
     730:	9b05      	ldr	r3, [sp, #20]
     732:	fba3 0209 	umull	r0, r2, r3, r9
     736:	9b06      	ldr	r3, [sp, #24]
     738:	fba3 3101 	umull	r3, r1, r3, r1
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     73c:	eb46 5667 	adc.w	r6, r6, r7, asr #21
    t[15] =          (sword64)ad[ 4] * bd[11] + (sword64)ad[ 5] * bd[10] +
     740:	18c0      	adds	r0, r0, r3
     742:	9b07      	ldr	r3, [sp, #28]
     744:	eb42 0201 	adc.w	r2, r2, r1
     748:	fbe3 0204 	umlal	r0, r2, r3, r4
                     (sword64)ad[ 6] * bd[ 9] + (sword64)ad[ 7] * bd[ 8] +
     74c:	9914      	ldr	r1, [sp, #80]	; 0x50
     74e:	9b08      	ldr	r3, [sp, #32]
    t[15] =          (sword64)ad[ 4] * bd[11] + (sword64)ad[ 5] * bd[10] +
     750:	4605      	mov	r5, r0
                     (sword64)ad[ 6] * bd[ 9] + (sword64)ad[ 7] * bd[ 8] +
     752:	fbe3 5201 	umlal	r5, r2, r3, r1
     756:	9b13      	ldr	r3, [sp, #76]	; 0x4c
     758:	9909      	ldr	r1, [sp, #36]	; 0x24
     75a:	fbe3 5201 	umlal	r5, r2, r3, r1
                     (sword64)ad[ 8] * bd[ 7] + (sword64)ad[ 9] * bd[ 6] +
     75e:	9b12      	ldr	r3, [sp, #72]	; 0x48
     760:	990a      	ldr	r1, [sp, #40]	; 0x28
     762:	fbe3 5201 	umlal	r5, r2, r3, r1
     766:	9b11      	ldr	r3, [sp, #68]	; 0x44
     768:	990b      	ldr	r1, [sp, #44]	; 0x2c
     76a:	fbe3 5201 	umlal	r5, r2, r3, r1
                     (sword64)ad[10] * bd[ 5] + (sword64)ad[11] * bd[ 4];
     76e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    t[17] =          (sword64)ad[ 6] * bd[11] + (sword64)ad[ 7] * bd[10] +
     770:	9916      	ldr	r1, [sp, #88]	; 0x58
                     (sword64)ad[10] * bd[ 5] + (sword64)ad[11] * bd[ 4];
     772:	fba3 0308 	umull	r0, r3, r3, r8
     776:	182d      	adds	r5, r5, r0
     778:	eb42 0203 	adc.w	r2, r2, r3
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
     77c:	9b20      	ldr	r3, [sp, #128]	; 0x80
     77e:	0d58      	lsrs	r0, r3, #21
     780:	9b21      	ldr	r3, [sp, #132]	; 0x84
     782:	ea40 20c3 	orr.w	r0, r0, r3, lsl #11
     786:	182b      	adds	r3, r5, r0
     788:	9310      	str	r3, [sp, #64]	; 0x40
     78a:	9b21      	ldr	r3, [sp, #132]	; 0x84
     78c:	eb42 5263 	adc.w	r2, r2, r3, asr #21
    t[17] =          (sword64)ad[ 6] * bd[11] + (sword64)ad[ 7] * bd[10] +
     790:	9b07      	ldr	r3, [sp, #28]
     792:	fba3 0c09 	umull	r0, ip, r3, r9
     796:	9b08      	ldr	r3, [sp, #32]
     798:	fba3 3101 	umull	r3, r1, r3, r1
     79c:	18c3      	adds	r3, r0, r3
     79e:	eb4c 0c01 	adc.w	ip, ip, r1
     7a2:	9909      	ldr	r1, [sp, #36]	; 0x24
                     (sword64)ad[ 8] * bd[ 9] + (sword64)ad[ 9] * bd[ 8] +
     7a4:	980a      	ldr	r0, [sp, #40]	; 0x28
    t[17] =          (sword64)ad[ 6] * bd[11] + (sword64)ad[ 7] * bd[10] +
     7a6:	fbe1 3c04 	umlal	r3, ip, r1, r4
                     (sword64)ad[ 8] * bd[ 9] + (sword64)ad[ 9] * bd[ 8] +
     7aa:	9914      	ldr	r1, [sp, #80]	; 0x50
     7ac:	fbe1 3c00 	umlal	r3, ip, r1, r0
     7b0:	9913      	ldr	r1, [sp, #76]	; 0x4c
     7b2:	980b      	ldr	r0, [sp, #44]	; 0x2c
     7b4:	fbe1 3c00 	umlal	r3, ip, r1, r0
                     (sword64)ad[10] * bd[ 7] + (sword64)ad[11] * bd[ 6];
     7b8:	9912      	ldr	r1, [sp, #72]	; 0x48
     7ba:	fba1 0108 	umull	r0, r1, r1, r8
     7be:	1818      	adds	r0, r3, r0
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     7c0:	9b22      	ldr	r3, [sp, #136]	; 0x88
                     (sword64)ad[10] * bd[ 7] + (sword64)ad[11] * bd[ 6];
     7c2:	eb4c 0c01 	adc.w	ip, ip, r1
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     7c6:	9923      	ldr	r1, [sp, #140]	; 0x8c
     7c8:	0d5b      	lsrs	r3, r3, #21
     7ca:	ea43 23c1 	orr.w	r3, r3, r1, lsl #11
     7ce:	18c3      	adds	r3, r0, r3
     7d0:	eb4c 5c61 	adc.w	ip, ip, r1, asr #21
    t[19] =          (sword64)ad[ 8] * bd[11] + (sword64)ad[ 9] * bd[10] +
     7d4:	9816      	ldr	r0, [sp, #88]	; 0x58
     7d6:	990a      	ldr	r1, [sp, #40]	; 0x28
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     7d8:	9311      	str	r3, [sp, #68]	; 0x44
    t[19] =          (sword64)ad[ 8] * bd[11] + (sword64)ad[ 9] * bd[10] +
     7da:	9b09      	ldr	r3, [sp, #36]	; 0x24
     7dc:	fba1 0100 	umull	r0, r1, r1, r0
     7e0:	fba3 3a09 	umull	r3, sl, r3, r9
     7e4:	181b      	adds	r3, r3, r0
     7e6:	eb4a 0a01 	adc.w	sl, sl, r1
     7ea:	980b      	ldr	r0, [sp, #44]	; 0x2c
                     (sword64)ad[10] * bd[ 9] + (sword64)ad[11] * bd[ 8];
     7ec:	9914      	ldr	r1, [sp, #80]	; 0x50
    t[19] =          (sword64)ad[ 8] * bd[11] + (sword64)ad[ 9] * bd[10] +
     7ee:	fbe4 3a00 	umlal	r3, sl, r4, r0
                     (sword64)ad[10] * bd[ 9] + (sword64)ad[11] * bd[ 8];
     7f2:	fba1 0108 	umull	r0, r1, r1, r8
     7f6:	181b      	adds	r3, r3, r0
     7f8:	eb4a 0a01 	adc.w	sl, sl, r1
    carry = t[18] >> 21; t[19] += carry; t[18] &= MASK_21;
     7fc:	9924      	ldr	r1, [sp, #144]	; 0x90
     7fe:	9825      	ldr	r0, [sp, #148]	; 0x94
     800:	0d49      	lsrs	r1, r1, #21
     802:	ea41 21c0 	orr.w	r1, r1, r0, lsl #11
     806:	185b      	adds	r3, r3, r1
    t[21] =          (sword64)ad[10] * bd[11] + (sword64)ad[11] * bd[10];
     808:	990b      	ldr	r1, [sp, #44]	; 0x2c
     80a:	fba1 9509 	umull	r9, r5, r1, r9
     80e:	9916      	ldr	r1, [sp, #88]	; 0x58
     810:	fba1 1408 	umull	r1, r4, r1, r8
    carry = t[18] >> 21; t[19] += carry; t[18] &= MASK_21;
     814:	eb4a 5a60 	adc.w	sl, sl, r0, asr #21
    carry = t[20] >> 21; t[21] += carry; t[20] &= MASK_21;
     818:	9826      	ldr	r0, [sp, #152]	; 0x98
    t[21] =          (sword64)ad[10] * bd[11] + (sword64)ad[11] * bd[10];
     81a:	eb19 0101 	adds.w	r1, r9, r1
     81e:	eb45 0404 	adc.w	r4, r5, r4
    carry = t[20] >> 21; t[21] += carry; t[20] &= MASK_21;
     822:	9d27      	ldr	r5, [sp, #156]	; 0x9c
    t[12] -= t[22] * ORDER_2;
     824:	f8df 9124 	ldr.w	r9, [pc, #292]	; 94c <sc_muladd+0x94c>
    carry = t[20] >> 21; t[21] += carry; t[20] &= MASK_21;
     828:	0d40      	lsrs	r0, r0, #21
     82a:	ea40 20c5 	orr.w	r0, r0, r5, lsl #11
     82e:	1809      	adds	r1, r1, r0
    carry = t[22] >> 21; t[23] += carry; t[22] &= MASK_21;
     830:	9828      	ldr	r0, [sp, #160]	; 0xa0
    carry = t[20] >> 21; t[21] += carry; t[20] &= MASK_21;
     832:	eb44 5465 	adc.w	r4, r4, r5, asr #21
    carry = t[22] >> 21; t[23] += carry; t[22] &= MASK_21;
     836:	9d29      	ldr	r5, [sp, #164]	; 0xa4
     838:	0d40      	lsrs	r0, r0, #21
     83a:	ea40 20c5 	orr.w	r0, r0, r5, lsl #11
     83e:	9005      	str	r0, [sp, #20]
     840:	1568      	asrs	r0, r5, #21
    carry = t[17] >> 21; t[18] += carry; t[17] &= MASK_21;
     842:	9d11      	ldr	r5, [sp, #68]	; 0x44
    carry = t[22] >> 21; t[23] += carry; t[22] &= MASK_21;
     844:	900f      	str	r0, [sp, #60]	; 0x3c
    carry = t[18] >> 21; t[19] += carry; t[18] &= MASK_21;
     846:	9824      	ldr	r0, [sp, #144]	; 0x90
    carry = t[17] >> 21; t[18] += carry; t[17] &= MASK_21;
     848:	0d6d      	lsrs	r5, r5, #21
     84a:	ea45 25cc 	orr.w	r5, r5, ip, lsl #11
    carry = t[18] >> 21; t[19] += carry; t[18] &= MASK_21;
     84e:	f3c0 0014 	ubfx	r0, r0, #0, #21
    carry = t[17] >> 21; t[18] += carry; t[17] &= MASK_21;
     852:	1940      	adds	r0, r0, r5
     854:	ea4f 5c6c 	mov.w	ip, ip, asr #21
     858:	9006      	str	r0, [sp, #24]
     85a:	f14c 0000 	adc.w	r0, ip, #0
     85e:	900c      	str	r0, [sp, #48]	; 0x30
    carry = t[20] >> 21; t[21] += carry; t[20] &= MASK_21;
     860:	9826      	ldr	r0, [sp, #152]	; 0x98
     862:	f3c0 0514 	ubfx	r5, r0, #0, #21
    carry = t[19] >> 21; t[20] += carry; t[19] &= MASK_21;
     866:	0d58      	lsrs	r0, r3, #21
     868:	ea40 20ca 	orr.w	r0, r0, sl, lsl #11
     86c:	1828      	adds	r0, r5, r0
     86e:	ea4f 5a6a 	mov.w	sl, sl, asr #21
     872:	9007      	str	r0, [sp, #28]
     874:	f14a 0000 	adc.w	r0, sl, #0
     878:	900d      	str	r0, [sp, #52]	; 0x34
    carry = t[22] >> 21; t[23] += carry; t[22] &= MASK_21;
     87a:	9828      	ldr	r0, [sp, #160]	; 0xa0
     87c:	f3c0 0514 	ubfx	r5, r0, #0, #21
    carry = t[21] >> 21; t[22] += carry; t[21] &= MASK_21;
     880:	0d48      	lsrs	r0, r1, #21
     882:	ea40 20c4 	orr.w	r0, r0, r4, lsl #11
     886:	1828      	adds	r0, r5, r0
     888:	ea4f 5464 	mov.w	r4, r4, asr #21
     88c:	9008      	str	r0, [sp, #32]
     88e:	f144 0000 	adc.w	r0, r4, #0
     892:	900e      	str	r0, [sp, #56]	; 0x38
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     894:	9822      	ldr	r0, [sp, #136]	; 0x88
    t[16] -= t[23] * ORDER_5;
     896:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     898:	f3c0 0714 	ubfx	r7, r0, #0, #21
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     89c:	9810      	ldr	r0, [sp, #64]	; 0x40
     89e:	0d40      	lsrs	r0, r0, #21
     8a0:	ea40 20c2 	orr.w	r0, r0, r2, lsl #11
     8a4:	183f      	adds	r7, r7, r0
    t[16] -= t[23] * ORDER_5;
     8a6:	9805      	ldr	r0, [sp, #20]
     8a8:	f1c0 0000 	rsb	r0, r0, #0
     8ac:	9009      	str	r0, [sp, #36]	; 0x24
     8ae:	fb0b 0504 	mla	r5, fp, r4, r0
     8b2:	9805      	ldr	r0, [sp, #20]
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     8b4:	ea4f 5262 	mov.w	r2, r2, asr #21
    t[16] -= t[23] * ORDER_5;
     8b8:	fba0 040b 	umull	r0, r4, r0, fp
     8bc:	4425      	add	r5, r4
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     8be:	f142 0200 	adc.w	r2, r2, #0
    t[16] -= t[23] * ORDER_5;
     8c2:	1838      	adds	r0, r7, r0
     8c4:	eb45 0202 	adc.w	r2, r5, r2
     8c8:	9012      	str	r0, [sp, #72]	; 0x48
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     8ca:	981e      	ldr	r0, [sp, #120]	; 0x78
    t[16] -= t[23] * ORDER_5;
     8cc:	9213      	str	r2, [sp, #76]	; 0x4c
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
     8ce:	9a20      	ldr	r2, [sp, #128]	; 0x80
    t[14] -= t[23] * ORDER_3;
     8d0:	9c09      	ldr	r4, [sp, #36]	; 0x24
    t[14] -= t[22] * ORDER_4;
     8d2:	4f1f      	ldr	r7, [pc, #124]	; (950 <sc_muladd+0x950>)
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     8d4:	ea4f 5850 	mov.w	r8, r0, lsr #21
     8d8:	ea48 28c6 	orr.w	r8, r8, r6, lsl #11
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
     8dc:	f3c2 0214 	ubfx	r2, r2, #0, #21
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     8e0:	1575      	asrs	r5, r6, #21
     8e2:	eb12 0208 	adds.w	r2, r2, r8
     8e6:	f145 0000 	adc.w	r0, r5, #0
    t[14] -= t[23] * ORDER_3;
     8ea:	f8df 8068 	ldr.w	r8, [pc, #104]	; 954 <sc_muladd+0x954>
     8ee:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
     8f0:	fb08 4605 	mla	r6, r8, r5, r4
     8f4:	9c05      	ldr	r4, [sp, #20]
     8f6:	fba4 4508 	umull	r4, r5, r4, r8
     8fa:	1912      	adds	r2, r2, r4
     8fc:	4435      	add	r5, r6
     8fe:	eb45 0500 	adc.w	r5, r5, r0
    t[14] -= t[22] * ORDER_4;
     902:	9808      	ldr	r0, [sp, #32]
     904:	9c0e      	ldr	r4, [sp, #56]	; 0x38
     906:	4240      	negs	r0, r0
     908:	fb07 0604 	mla	r6, r7, r4, r0
     90c:	900a      	str	r0, [sp, #40]	; 0x28
     90e:	9808      	ldr	r0, [sp, #32]
    carry = t[21] >> 21; t[22] += carry; t[21] &= MASK_21;
     910:	f3c1 0114 	ubfx	r1, r1, #0, #21
    t[14] -= t[22] * ORDER_4;
     914:	fba0 0407 	umull	r0, r4, r0, r7
     918:	1810      	adds	r0, r2, r0
     91a:	4426      	add	r6, r4
    t[14] -= t[21] * ORDER_5;
     91c:	fba1 2c0b 	umull	r2, ip, r1, fp
    t[14] -= t[22] * ORDER_4;
     920:	eb46 0605 	adc.w	r6, r6, r5
    t[14] -= t[21] * ORDER_5;
     924:	ebac 0c01 	sub.w	ip, ip, r1
     928:	1882      	adds	r2, r0, r2
     92a:	9214      	str	r2, [sp, #80]	; 0x50
     92c:	eb4c 0206 	adc.w	r2, ip, r6
     930:	9215      	str	r2, [sp, #84]	; 0x54
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     932:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    t[12] -= t[23] * ORDER_1;
     934:	9d09      	ldr	r5, [sp, #36]	; 0x24
     936:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     938:	f3c2 0014 	ubfx	r0, r2, #0, #21
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
     93c:	9a33      	ldr	r2, [sp, #204]	; 0xcc
     93e:	0d52      	lsrs	r2, r2, #21
     940:	ea42 22ce 	orr.w	r2, r2, lr, lsl #11
     944:	1880      	adds	r0, r0, r2
     946:	e007      	b.n	958 <sc_muladd+0x958>
     948:	fff59084 	.word	0xfff59084
     94c:	ffe9fb68 	.word	0xffe9fb68
     950:	ffe215d1 	.word	0xffe215d1
     954:	fff0c654 	.word	0xfff0c654
    t[12] -= t[23] * ORDER_1;
     958:	4ad1      	ldr	r2, [pc, #836]	; (ca0 <sc_muladd+0xca0>)
     95a:	fb02 5606 	mla	r6, r2, r6, r5
     95e:	9d05      	ldr	r5, [sp, #20]
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
     960:	ea4f 5c6e 	mov.w	ip, lr, asr #21
     964:	f14c 0400 	adc.w	r4, ip, #0
    t[12] -= t[23] * ORDER_1;
     968:	fba5 5c02 	umull	r5, ip, r5, r2
     96c:	1940      	adds	r0, r0, r5
     96e:	44b4      	add	ip, r6
    t[12] -= t[22] * ORDER_2;
     970:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    t[12] -= t[23] * ORDER_1;
     972:	eb4c 0c04 	adc.w	ip, ip, r4
    t[12] -= t[22] * ORDER_2;
     976:	9c0a      	ldr	r4, [sp, #40]	; 0x28
     978:	fb09 4605 	mla	r6, r9, r5, r4
     97c:	9c08      	ldr	r4, [sp, #32]
     97e:	fba4 4509 	umull	r4, r5, r4, r9
     982:	1900      	adds	r0, r0, r4
     984:	442e      	add	r6, r5
    t[12] -= t[20] * ORDER_4;
     986:	9c07      	ldr	r4, [sp, #28]
    t[12] -= t[21] * ORDER_3;
     988:	fba1 5a08 	umull	r5, sl, r1, r8
    t[12] -= t[22] * ORDER_2;
     98c:	eb46 060c 	adc.w	r6, r6, ip
    t[12] -= t[21] * ORDER_3;
     990:	1940      	adds	r0, r0, r5
    t[12] -= t[20] * ORDER_4;
     992:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    t[12] -= t[21] * ORDER_3;
     994:	ebaa 0a01 	sub.w	sl, sl, r1
    t[12] -= t[20] * ORDER_4;
     998:	f1c4 0400 	rsb	r4, r4, #0
    t[12] -= t[21] * ORDER_3;
     99c:	eb4a 0606 	adc.w	r6, sl, r6
    t[12] -= t[20] * ORDER_4;
     9a0:	940b      	str	r4, [sp, #44]	; 0x2c
     9a2:	fb07 4a05 	mla	sl, r7, r5, r4
     9a6:	9c07      	ldr	r4, [sp, #28]
    carry = t[19] >> 21; t[20] += carry; t[19] &= MASK_21;
     9a8:	f3c3 0314 	ubfx	r3, r3, #0, #21
    t[12] -= t[20] * ORDER_4;
     9ac:	fba4 5407 	umull	r5, r4, r4, r7
     9b0:	1945      	adds	r5, r0, r5
     9b2:	44a2      	add	sl, r4
    t[12] -= t[19] * ORDER_5;
     9b4:	fba3 0c0b 	umull	r0, ip, r3, fp
    t[12] -= t[20] * ORDER_4;
     9b8:	eb4a 0a06 	adc.w	sl, sl, r6
    t[12] -= t[19] * ORDER_5;
     9bc:	ebac 0c03 	sub.w	ip, ip, r3
     9c0:	1828      	adds	r0, r5, r0
     9c2:	9016      	str	r0, [sp, #88]	; 0x58
     9c4:	eb4c 000a 	adc.w	r0, ip, sl
     9c8:	901f      	str	r0, [sp, #124]	; 0x7c
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
     9ca:	981b      	ldr	r0, [sp, #108]	; 0x6c
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
     9cc:	9c2e      	ldr	r4, [sp, #184]	; 0xb8
    t[ 6] -= t[18] * ORDER_0;
     9ce:	4eb5      	ldr	r6, [pc, #724]	; (ca4 <sc_muladd+0xca4>)
     9d0:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
     9d2:	f3c0 0e14 	ubfx	lr, r0, #0, #21
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
     9d6:	982d      	ldr	r0, [sp, #180]	; 0xb4
     9d8:	0d40      	lsrs	r0, r0, #21
     9da:	ea40 20c4 	orr.w	r0, r0, r4, lsl #11
     9de:	ea4f 5c64 	mov.w	ip, r4, asr #21
    t[ 6] -= t[18] * ORDER_0;
     9e2:	9c06      	ldr	r4, [sp, #24]
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
     9e4:	eb1e 0e00 	adds.w	lr, lr, r0
    t[ 6] -= t[18] * ORDER_0;
     9e8:	f1c4 0400 	rsb	r4, r4, #0
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
     9ec:	f14c 0000 	adc.w	r0, ip, #0
    t[ 6] -= t[18] * ORDER_0;
     9f0:	fb06 4c05 	mla	ip, r6, r5, r4
     9f4:	9d06      	ldr	r5, [sp, #24]
     9f6:	fba5 a506 	umull	sl, r5, r5, r6
     9fa:	44ac      	add	ip, r5
     9fc:	eb1e 050a 	adds.w	r5, lr, sl
     a00:	eb4c 0c00 	adc.w	ip, ip, r0
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
     a04:	981c      	ldr	r0, [sp, #112]	; 0x70
    t[ 6] -= t[18] * ORDER_0;
     a06:	951b      	str	r5, [sp, #108]	; 0x6c
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
     a08:	f3c0 0514 	ubfx	r5, r0, #0, #21
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
     a0c:	982f      	ldr	r0, [sp, #188]	; 0xbc
     a0e:	f8dd e0c0 	ldr.w	lr, [sp, #192]	; 0xc0
     a12:	0d40      	lsrs	r0, r0, #21
     a14:	ea40 20ce 	orr.w	r0, r0, lr, lsl #11
     a18:	182d      	adds	r5, r5, r0
     a1a:	ea4f 5a6e 	mov.w	sl, lr, asr #21
    t[ 8] -= t[20] * ORDER_0;
     a1e:	980b      	ldr	r0, [sp, #44]	; 0x2c
     a20:	f8dd e034 	ldr.w	lr, [sp, #52]	; 0x34
     a24:	fb06 0b0e 	mla	fp, r6, lr, r0
     a28:	9807      	ldr	r0, [sp, #28]
     a2a:	fba0 0e06 	umull	r0, lr, r0, r6
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
     a2e:	f14a 0a00 	adc.w	sl, sl, #0
    t[ 8] -= t[20] * ORDER_0;
     a32:	44de      	add	lr, fp
     a34:	1828      	adds	r0, r5, r0
     a36:	eb4e 0e0a 	adc.w	lr, lr, sl
    t[ 8] -= t[19] * ORDER_1;
     a3a:	fba3 a502 	umull	sl, r5, r3, r2
     a3e:	eb10 000a 	adds.w	r0, r0, sl
     a42:	eba5 0503 	sub.w	r5, r5, r3
     a46:	eb45 050e 	adc.w	r5, r5, lr
    t[ 8] -= t[18] * ORDER_2;
     a4a:	f8dd a018 	ldr.w	sl, [sp, #24]
     a4e:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
     a52:	fbaa ab09 	umull	sl, fp, sl, r9
     a56:	fb09 4e0e 	mla	lr, r9, lr, r4
     a5a:	eb10 000a 	adds.w	r0, r0, sl
     a5e:	44de      	add	lr, fp
     a60:	901c      	str	r0, [sp, #112]	; 0x70
     a62:	eb4e 0005 	adc.w	r0, lr, r5
     a66:	9020      	str	r0, [sp, #128]	; 0x80
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     a68:	981d      	ldr	r0, [sp, #116]	; 0x74
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
     a6a:	9d31      	ldr	r5, [sp, #196]	; 0xc4
     a6c:	f8dd e0c8 	ldr.w	lr, [sp, #200]	; 0xc8
    t[10] -= t[20] * ORDER_2;
     a70:	f8cd 900c 	str.w	r9, [sp, #12]
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
     a74:	0d6d      	lsrs	r5, r5, #21
     a76:	ea45 25ce 	orr.w	r5, r5, lr, lsl #11
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     a7a:	f3c0 0014 	ubfx	r0, r0, #0, #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
     a7e:	1940      	adds	r0, r0, r5
     a80:	ea4f 5b6e 	mov.w	fp, lr, asr #21
    t[10] -= t[22] * ORDER_0;
     a84:	9d0a      	ldr	r5, [sp, #40]	; 0x28
     a86:	f8dd e038 	ldr.w	lr, [sp, #56]	; 0x38
    t[10] -= t[18] * ORDER_4;
     a8a:	9702      	str	r7, [sp, #8]
    t[10] -= t[22] * ORDER_0;
     a8c:	fb06 5e0e 	mla	lr, r6, lr, r5
     a90:	9d08      	ldr	r5, [sp, #32]
    t[10] -= t[18] * ORDER_4;
     a92:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    t[10] -= t[19] * ORDER_3;
     a94:	f8cd 8004 	str.w	r8, [sp, #4]
    t[10] -= t[22] * ORDER_0;
     a98:	fba5 5a06 	umull	r5, sl, r5, r6
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
     a9c:	f14b 0b00 	adc.w	fp, fp, #0
    t[10] -= t[22] * ORDER_0;
     aa0:	44d6      	add	lr, sl
     aa2:	1940      	adds	r0, r0, r5
     aa4:	eb4e 0e0b 	adc.w	lr, lr, fp
    t[10] -= t[21] * ORDER_1;
     aa8:	fba1 ab02 	umull	sl, fp, r1, r2
    t[10] -= t[20] * ORDER_2;
     aac:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    t[ 7] -= t[19] * ORDER_0;
     aae:	9604      	str	r6, [sp, #16]
    t[10] -= t[21] * ORDER_1;
     ab0:	eb10 000a 	adds.w	r0, r0, sl
    t[10] -= t[20] * ORDER_2;
     ab4:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
     ab8:	fb09 5a0a 	mla	sl, r9, sl, r5
     abc:	9d07      	ldr	r5, [sp, #28]
    t[10] -= t[21] * ORDER_1;
     abe:	ebab 0b01 	sub.w	fp, fp, r1
    t[10] -= t[20] * ORDER_2;
     ac2:	fba5 5909 	umull	r5, r9, r5, r9
    t[10] -= t[21] * ORDER_1;
     ac6:	eb4b 0e0e 	adc.w	lr, fp, lr
    t[10] -= t[20] * ORDER_2;
     aca:	44d1      	add	r9, sl
     acc:	1940      	adds	r0, r0, r5
     ace:	eb49 090e 	adc.w	r9, r9, lr
    t[10] -= t[19] * ORDER_3;
     ad2:	fba3 e508 	umull	lr, r5, r3, r8
     ad6:	eb10 000e 	adds.w	r0, r0, lr
    t[10] -= t[18] * ORDER_4;
     ada:	f8df e1cc 	ldr.w	lr, [pc, #460]	; ca8 <sc_muladd+0xca8>
     ade:	f8df 81c8 	ldr.w	r8, [pc, #456]	; ca8 <sc_muladd+0xca8>
     ae2:	fb0e 4707 	mla	r7, lr, r7, r4
     ae6:	f8dd e018 	ldr.w	lr, [sp, #24]
    t[10] -= t[19] * ORDER_3;
     aea:	eba5 0503 	sub.w	r5, r5, r3
    t[10] -= t[18] * ORDER_4;
     aee:	fbae e808 	umull	lr, r8, lr, r8
    t[10] -= t[19] * ORDER_3;
     af2:	eb45 0509 	adc.w	r5, r5, r9
    t[10] -= t[18] * ORDER_4;
     af6:	eb10 000e 	adds.w	r0, r0, lr
     afa:	901d      	str	r0, [sp, #116]	; 0x74
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
     afc:	982f      	ldr	r0, [sp, #188]	; 0xbc
    t[10] -= t[18] * ORDER_4;
     afe:	4447      	add	r7, r8
     b00:	eb47 0805 	adc.w	r8, r7, r5
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
     b04:	f3c0 0014 	ubfx	r0, r0, #0, #21
    t[ 7] -= t[19] * ORDER_0;
     b08:	fba3 6706 	umull	r6, r7, r3, r6
     b0c:	1986      	adds	r6, r0, r6
    t[ 7] -= t[18] * ORDER_1;
     b0e:	980c      	ldr	r0, [sp, #48]	; 0x30
     b10:	fb02 4500 	mla	r5, r2, r0, r4
     b14:	9806      	ldr	r0, [sp, #24]
    t[ 7] -= t[19] * ORDER_0;
     b16:	eba7 0703 	sub.w	r7, r7, r3
    t[ 7] -= t[18] * ORDER_1;
     b1a:	fba0 0e02 	umull	r0, lr, r0, r2
    t[ 7] -= t[19] * ORDER_0;
     b1e:	f147 0700 	adc.w	r7, r7, #0
    t[ 7] -= t[18] * ORDER_1;
     b22:	1830      	adds	r0, r6, r0
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
     b24:	9e1b      	ldr	r6, [sp, #108]	; 0x6c
     b26:	ea4f 5656 	mov.w	r6, r6, lsr #21
     b2a:	ea46 26cc 	orr.w	r6, r6, ip, lsl #11
    t[ 7] -= t[18] * ORDER_1;
     b2e:	4475      	add	r5, lr
     b30:	eb45 0507 	adc.w	r5, r5, r7
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
     b34:	1980      	adds	r0, r0, r6
     b36:	9021      	str	r0, [sp, #132]	; 0x84
     b38:	eb45 506c 	adc.w	r0, r5, ip, asr #21
     b3c:	9022      	str	r0, [sp, #136]	; 0x88
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
     b3e:	9831      	ldr	r0, [sp, #196]	; 0xc4
    t[ 9] -= t[20] * ORDER_1;
     b40:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
     b42:	f3c0 0514 	ubfx	r5, r0, #0, #21
    t[ 9] -= t[21] * ORDER_0;
     b46:	9804      	ldr	r0, [sp, #16]
     b48:	fba1 0c00 	umull	r0, ip, r1, r0
     b4c:	182d      	adds	r5, r5, r0
    t[ 9] -= t[20] * ORDER_1;
     b4e:	980b      	ldr	r0, [sp, #44]	; 0x2c
     b50:	fb02 0706 	mla	r7, r2, r6, r0
     b54:	9807      	ldr	r0, [sp, #28]
    t[ 9] -= t[21] * ORDER_0;
     b56:	ebac 0c01 	sub.w	ip, ip, r1
    t[ 9] -= t[20] * ORDER_1;
     b5a:	fba0 0602 	umull	r0, r6, r0, r2
    t[ 9] -= t[21] * ORDER_0;
     b5e:	f14c 0c00 	adc.w	ip, ip, #0
    t[ 9] -= t[20] * ORDER_1;
     b62:	1828      	adds	r0, r5, r0
    t[ 9] -= t[19] * ORDER_2;
     b64:	4d51      	ldr	r5, [pc, #324]	; (cac <sc_muladd+0xcac>)
    t[ 9] -= t[20] * ORDER_1;
     b66:	4437      	add	r7, r6
    t[ 9] -= t[19] * ORDER_2;
     b68:	fba3 5e05 	umull	r5, lr, r3, r5
    t[ 9] -= t[20] * ORDER_1;
     b6c:	eb47 070c 	adc.w	r7, r7, ip
    t[ 9] -= t[18] * ORDER_3;
     b70:	4e4f      	ldr	r6, [pc, #316]	; (cb0 <sc_muladd+0xcb0>)
     b72:	f8df c13c 	ldr.w	ip, [pc, #316]	; cb0 <sc_muladd+0xcb0>
    t[ 9] -= t[19] * ORDER_2;
     b76:	1940      	adds	r0, r0, r5
    t[ 9] -= t[18] * ORDER_3;
     b78:	9d0c      	ldr	r5, [sp, #48]	; 0x30
     b7a:	fb06 4505 	mla	r5, r6, r5, r4
     b7e:	9e06      	ldr	r6, [sp, #24]
    t[ 9] -= t[19] * ORDER_2;
     b80:	ebae 0e03 	sub.w	lr, lr, r3
    t[ 9] -= t[18] * ORDER_3;
     b84:	fba6 6c0c 	umull	r6, ip, r6, ip
    t[ 9] -= t[19] * ORDER_2;
     b88:	eb4e 0707 	adc.w	r7, lr, r7
    t[ 9] -= t[18] * ORDER_3;
     b8c:	4465      	add	r5, ip
     b8e:	1980      	adds	r0, r0, r6
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
     b90:	9e1c      	ldr	r6, [sp, #112]	; 0x70
    t[ 9] -= t[18] * ORDER_3;
     b92:	eb45 0507 	adc.w	r5, r5, r7
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
     b96:	9f20      	ldr	r7, [sp, #128]	; 0x80
     b98:	0d76      	lsrs	r6, r6, #21
     b9a:	ea46 26c7 	orr.w	r6, r6, r7, lsl #11
     b9e:	1980      	adds	r0, r0, r6
     ba0:	9023      	str	r0, [sp, #140]	; 0x8c
     ba2:	eb45 5067 	adc.w	r0, r5, r7, asr #21
     ba6:	9020      	str	r0, [sp, #128]	; 0x80
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
     ba8:	9833      	ldr	r0, [sp, #204]	; 0xcc
    t[11] -= t[23] * ORDER_0;
     baa:	9f04      	ldr	r7, [sp, #16]
     bac:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
     bae:	f3c0 0514 	ubfx	r5, r0, #0, #21
    t[11] -= t[23] * ORDER_0;
     bb2:	9809      	ldr	r0, [sp, #36]	; 0x24
     bb4:	fb07 0c06 	mla	ip, r7, r6, r0
     bb8:	9805      	ldr	r0, [sp, #20]
     bba:	fba0 0607 	umull	r0, r6, r0, r7
     bbe:	182d      	adds	r5, r5, r0
     bc0:	eb4c 0c06 	adc.w	ip, ip, r6
    t[11] -= t[22] * ORDER_1;
     bc4:	980a      	ldr	r0, [sp, #40]	; 0x28
     bc6:	9e0e      	ldr	r6, [sp, #56]	; 0x38
     bc8:	fb02 0706 	mla	r7, r2, r6, r0
     bcc:	9808      	ldr	r0, [sp, #32]
     bce:	fba0 0602 	umull	r0, r6, r0, r2
     bd2:	1828      	adds	r0, r5, r0
    t[11] -= t[21] * ORDER_2;
     bd4:	4d35      	ldr	r5, [pc, #212]	; (cac <sc_muladd+0xcac>)
    t[11] -= t[22] * ORDER_1;
     bd6:	4437      	add	r7, r6
    t[11] -= t[21] * ORDER_2;
     bd8:	fba1 5e05 	umull	r5, lr, r1, r5
    t[11] -= t[20] * ORDER_3;
     bdc:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    t[11] -= t[22] * ORDER_1;
     bde:	eb47 070c 	adc.w	r7, r7, ip
    t[11] -= t[21] * ORDER_2;
     be2:	1940      	adds	r0, r0, r5
    t[11] -= t[20] * ORDER_3;
     be4:	f8df c0c8 	ldr.w	ip, [pc, #200]	; cb0 <sc_muladd+0xcb0>
     be8:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
     bea:	fb0c 5c06 	mla	ip, ip, r6, r5
     bee:	9d07      	ldr	r5, [sp, #28]
     bf0:	4e2f      	ldr	r6, [pc, #188]	; (cb0 <sc_muladd+0xcb0>)
    t[11] -= t[21] * ORDER_2;
     bf2:	ebae 0e01 	sub.w	lr, lr, r1
    t[11] -= t[20] * ORDER_3;
     bf6:	fba5 5606 	umull	r5, r6, r5, r6
    t[11] -= t[21] * ORDER_2;
     bfa:	eb4e 0707 	adc.w	r7, lr, r7
    t[11] -= t[20] * ORDER_3;
     bfe:	1940      	adds	r0, r0, r5
    t[11] -= t[19] * ORDER_4;
     c00:	4d29      	ldr	r5, [pc, #164]	; (ca8 <sc_muladd+0xca8>)
    t[11] -= t[20] * ORDER_3;
     c02:	4466      	add	r6, ip
    t[11] -= t[19] * ORDER_4;
     c04:	fba3 e505 	umull	lr, r5, r3, r5
    t[11] -= t[20] * ORDER_3;
     c08:	eb46 0607 	adc.w	r6, r6, r7
    t[11] -= t[19] * ORDER_4;
     c0c:	1aeb      	subs	r3, r5, r3
     c0e:	eb10 000e 	adds.w	r0, r0, lr
    t[11] -= t[18] * ORDER_5;
     c12:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    t[13] -= t[22] * ORDER_3;
     c14:	f8df c098 	ldr.w	ip, [pc, #152]	; cb0 <sc_muladd+0xcb0>
    t[11] -= t[19] * ORDER_4;
     c18:	eb43 0606 	adc.w	r6, r3, r6
    t[11] -= t[18] * ORDER_5;
     c1c:	4b25      	ldr	r3, [pc, #148]	; (cb4 <sc_muladd+0xcb4>)
     c1e:	fb03 4405 	mla	r4, r3, r5, r4
     c22:	9d06      	ldr	r5, [sp, #24]
     c24:	fba5 e703 	umull	lr, r7, r5, r3
     c28:	eb10 000e 	adds.w	r0, r0, lr
     c2c:	443c      	add	r4, r7
     c2e:	eb44 0706 	adc.w	r7, r4, r6
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     c32:	9c1d      	ldr	r4, [sp, #116]	; 0x74
    t[13] -= t[23] * ORDER_2;
     c34:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
     c36:	4e1d      	ldr	r6, [pc, #116]	; (cac <sc_muladd+0xcac>)
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     c38:	ea4f 5e54 	mov.w	lr, r4, lsr #21
     c3c:	ea4e 2ec8 	orr.w	lr, lr, r8, lsl #11
    t[13] -= t[23] * ORDER_2;
     c40:	9c09      	ldr	r4, [sp, #36]	; 0x24
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     c42:	eb10 000e 	adds.w	r0, r0, lr
     c46:	9024      	str	r0, [sp, #144]	; 0x90
    t[13] -= t[23] * ORDER_2;
     c48:	fb06 4605 	mla	r6, r6, r5, r4
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     c4c:	981e      	ldr	r0, [sp, #120]	; 0x78
    t[13] -= t[23] * ORDER_2;
     c4e:	9c05      	ldr	r4, [sp, #20]
     c50:	4d16      	ldr	r5, [pc, #88]	; (cac <sc_muladd+0xcac>)
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     c52:	f3c0 0014 	ubfx	r0, r0, #0, #21
    t[13] -= t[23] * ORDER_2;
     c56:	fba4 5405 	umull	r5, r4, r4, r5
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
     c5a:	eb47 5768 	adc.w	r7, r7, r8, asr #21
    t[13] -= t[23] * ORDER_2;
     c5e:	1940      	adds	r0, r0, r5
     c60:	eb46 0604 	adc.w	r6, r6, r4
    t[13] -= t[22] * ORDER_3;
     c64:	9d0e      	ldr	r5, [sp, #56]	; 0x38
     c66:	9c0a      	ldr	r4, [sp, #40]	; 0x28
     c68:	fb0c 4c05 	mla	ip, ip, r5, r4
     c6c:	9c08      	ldr	r4, [sp, #32]
     c6e:	4d10      	ldr	r5, [pc, #64]	; (cb0 <sc_muladd+0xcb0>)
     c70:	fba4 4505 	umull	r4, r5, r4, r5
     c74:	1900      	adds	r0, r0, r4
    t[13] -= t[21] * ORDER_4;
     c76:	4c0c      	ldr	r4, [pc, #48]	; (ca8 <sc_muladd+0xca8>)
    t[13] -= t[22] * ORDER_3;
     c78:	4465      	add	r5, ip
    t[13] -= t[21] * ORDER_4;
     c7a:	fba1 e404 	umull	lr, r4, r1, r4
    t[13] -= t[22] * ORDER_3;
     c7e:	eb45 0506 	adc.w	r5, r5, r6
    t[13] -= t[21] * ORDER_4;
     c82:	1a61      	subs	r1, r4, r1
     c84:	eb10 000e 	adds.w	r0, r0, lr
    t[13] -= t[20] * ORDER_5;
     c88:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    t[15] -= t[23] * ORDER_4;
     c8a:	4e07      	ldr	r6, [pc, #28]	; (ca8 <sc_muladd+0xca8>)
    t[13] -= t[21] * ORDER_4;
     c8c:	eb41 0505 	adc.w	r5, r1, r5
    t[13] -= t[20] * ORDER_5;
     c90:	990b      	ldr	r1, [sp, #44]	; 0x2c
     c92:	fb03 1a04 	mla	sl, r3, r4, r1
     c96:	9907      	ldr	r1, [sp, #28]
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     c98:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
    t[13] -= t[20] * ORDER_5;
     c9a:	fba1 e103 	umull	lr, r1, r1, r3
     c9e:	e00b      	b.n	cb8 <sc_muladd+0xcb8>
     ca0:	ffe72d19 	.word	0xffe72d19
     ca4:	ffea2c13 	.word	0xffea2c13
     ca8:	ffe215d1 	.word	0xffe215d1
     cac:	ffe9fb68 	.word	0xffe9fb68
     cb0:	fff0c654 	.word	0xfff0c654
     cb4:	fff59084 	.word	0xfff59084
     cb8:	448a      	add	sl, r1
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     cba:	9916      	ldr	r1, [sp, #88]	; 0x58
     cbc:	0d49      	lsrs	r1, r1, #21
    t[13] -= t[20] * ORDER_5;
     cbe:	eb10 000e 	adds.w	r0, r0, lr
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     cc2:	ea41 21c4 	orr.w	r1, r1, r4, lsl #11
    t[13] -= t[20] * ORDER_5;
     cc6:	eb4a 0a05 	adc.w	sl, sl, r5
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     cca:	1840      	adds	r0, r0, r1
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     ccc:	9910      	ldr	r1, [sp, #64]	; 0x40
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     cce:	eb4a 5a64 	adc.w	sl, sl, r4, asr #21
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     cd2:	f3c1 0514 	ubfx	r5, r1, #0, #21
    t[15] -= t[23] * ORDER_4;
     cd6:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
     cd8:	9909      	ldr	r1, [sp, #36]	; 0x24
     cda:	fb06 1404 	mla	r4, r6, r4, r1
     cde:	9905      	ldr	r1, [sp, #20]
     ce0:	fba1 1606 	umull	r1, r6, r1, r6
     ce4:	1869      	adds	r1, r5, r1
     ce6:	eb44 0606 	adc.w	r6, r4, r6
    t[15] -= t[22] * ORDER_5;
     cea:	9c0a      	ldr	r4, [sp, #40]	; 0x28
     cec:	9d0e      	ldr	r5, [sp, #56]	; 0x38
     cee:	fb03 4405 	mla	r4, r3, r5, r4
     cf2:	9d08      	ldr	r5, [sp, #32]
     cf4:	fba5 5c03 	umull	r5, ip, r5, r3
     cf8:	4464      	add	r4, ip
     cfa:	1949      	adds	r1, r1, r5
     cfc:	eb44 0606 	adc.w	r6, r4, r6
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
     d00:	9c14      	ldr	r4, [sp, #80]	; 0x50
     d02:	9d15      	ldr	r5, [sp, #84]	; 0x54
     d04:	0d64      	lsrs	r4, r4, #21
     d06:	ea44 24c5 	orr.w	r4, r4, r5, lsl #11
     d0a:	1909      	adds	r1, r1, r4
     d0c:	eb46 5665 	adc.w	r6, r6, r5, asr #21
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     d10:	9d12      	ldr	r5, [sp, #72]	; 0x48
    carry = t[17] >> 21; t[18] += carry; t[17] &= MASK_21;
     d12:	9c11      	ldr	r4, [sp, #68]	; 0x44
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     d14:	ea4f 5c55 	mov.w	ip, r5, lsr #21
     d18:	9d13      	ldr	r5, [sp, #76]	; 0x4c
    carry = t[17] >> 21; t[18] += carry; t[17] &= MASK_21;
     d1a:	f3c4 0414 	ubfx	r4, r4, #0, #21
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     d1e:	ea4c 2cc5 	orr.w	ip, ip, r5, lsl #11
     d22:	eb14 040c 	adds.w	r4, r4, ip
     d26:	ea4f 5565 	mov.w	r5, r5, asr #21
     d2a:	9405      	str	r4, [sp, #20]
     d2c:	f145 0400 	adc.w	r4, r5, #0
     d30:	9409      	str	r4, [sp, #36]	; 0x24
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     d32:	9c16      	ldr	r4, [sp, #88]	; 0x58
    t[ 0] -= t[12] * ORDER_0;
     d34:	f8dd c010 	ldr.w	ip, [sp, #16]
    carry = t[12] >> 21; t[13] += carry; t[12] &= MASK_21;
     d38:	f3c4 0514 	ubfx	r5, r4, #0, #21
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
     d3c:	9c24      	ldr	r4, [sp, #144]	; 0x90
     d3e:	0d64      	lsrs	r4, r4, #21
     d40:	ea44 24c7 	orr.w	r4, r4, r7, lsl #11
     d44:	192d      	adds	r5, r5, r4
     d46:	ea4f 5767 	mov.w	r7, r7, asr #21
     d4a:	f147 0400 	adc.w	r4, r7, #0
     d4e:	940a      	str	r4, [sp, #40]	; 0x28
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
     d50:	9c14      	ldr	r4, [sp, #80]	; 0x50
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     d52:	ea4f 5950 	mov.w	r9, r0, lsr #21
     d56:	ea49 29ca 	orr.w	r9, r9, sl, lsl #11
    carry = t[14] >> 21; t[15] += carry; t[14] &= MASK_21;
     d5a:	f3c4 0814 	ubfx	r8, r4, #0, #21
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     d5e:	eb18 0409 	adds.w	r4, r8, r9
     d62:	ea4f 5a6a 	mov.w	sl, sl, asr #21
     d66:	9406      	str	r4, [sp, #24]
     d68:	f14a 0400 	adc.w	r4, sl, #0
     d6c:	940b      	str	r4, [sp, #44]	; 0x2c
    carry = t[16] >> 21; t[17] += carry; t[16] &= MASK_21;
     d6e:	9c12      	ldr	r4, [sp, #72]	; 0x48
     d70:	f3c4 0714 	ubfx	r7, r4, #0, #21
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     d74:	0d4c      	lsrs	r4, r1, #21
     d76:	ea44 24c6 	orr.w	r4, r4, r6, lsl #11
     d7a:	193c      	adds	r4, r7, r4
     d7c:	ea4f 5666 	mov.w	r6, r6, asr #21
     d80:	9407      	str	r4, [sp, #28]
     d82:	f146 0400 	adc.w	r4, r6, #0
    t[ 0] -= t[12] * ORDER_0;
     d86:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     d88:	940c      	str	r4, [sp, #48]	; 0x30
    t[ 0] -= t[12] * ORDER_0;
     d8a:	426f      	negs	r7, r5
     d8c:	fb0c 7c06 	mla	ip, ip, r6, r7
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
     d90:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    t[ 0] -= t[12] * ORDER_0;
     d92:	9e04      	ldr	r6, [sp, #16]
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
     d94:	f3c4 0414 	ubfx	r4, r4, #0, #21
    t[ 0] -= t[12] * ORDER_0;
     d98:	fba5 9606 	umull	r9, r6, r5, r6
     d9c:	eb14 0409 	adds.w	r4, r4, r9
     da0:	eb4c 0806 	adc.w	r8, ip, r6
    t[ 1] -= t[13] * ORDER_0;
     da4:	9e04      	ldr	r6, [sp, #16]
    t[ 0] -= t[12] * ORDER_0;
     da6:	940d      	str	r4, [sp, #52]	; 0x34
    carry = t[13] >> 21; t[14] += carry; t[13] &= MASK_21;
     da8:	f3c0 0014 	ubfx	r0, r0, #0, #21
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     dac:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
     dae:	f8dd c034 	ldr.w	ip, [sp, #52]	; 0x34
    t[ 1] -= t[13] * ORDER_0;
     db2:	fba0 eb06 	umull	lr, fp, r0, r6
    t[ 1] -= t[12] * ORDER_1;
     db6:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     db8:	f3c4 0414 	ubfx	r4, r4, #0, #21
    t[ 1] -= t[12] * ORDER_1;
     dbc:	fb02 7a06 	mla	sl, r2, r6, r7
    t[ 1] -= t[13] * ORDER_0;
     dc0:	eb14 040e 	adds.w	r4, r4, lr
    t[ 1] -= t[12] * ORDER_1;
     dc4:	fba5 9602 	umull	r9, r6, r5, r2
    t[ 1] -= t[13] * ORDER_0;
     dc8:	ebab 0b00 	sub.w	fp, fp, r0
     dcc:	f14b 0b00 	adc.w	fp, fp, #0
    t[ 1] -= t[12] * ORDER_1;
     dd0:	eb14 0409 	adds.w	r4, r4, r9
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
     dd4:	ea4f 595c 	mov.w	r9, ip, lsr #21
     dd8:	ea49 29c8 	orr.w	r9, r9, r8, lsl #11
    t[ 1] -= t[12] * ORDER_1;
     ddc:	4456      	add	r6, sl
     dde:	eb46 060b 	adc.w	r6, r6, fp
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
     de2:	eb14 0409 	adds.w	r4, r4, r9
     de6:	940e      	str	r4, [sp, #56]	; 0x38
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
     de8:	9c19      	ldr	r4, [sp, #100]	; 0x64
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     dea:	f8dd e060 	ldr.w	lr, [sp, #96]	; 0x60
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
     dee:	eb46 5c68 	adc.w	ip, r6, r8, asr #21
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
     df2:	f3c4 0614 	ubfx	r6, r4, #0, #21
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     df6:	9c2a      	ldr	r4, [sp, #168]	; 0xa8
     df8:	0d64      	lsrs	r4, r4, #21
     dfa:	ea44 24ce 	orr.w	r4, r4, lr, lsl #11
     dfe:	1936      	adds	r6, r6, r4
    t[ 2] -= t[14] * ORDER_0;
     e00:	9c06      	ldr	r4, [sp, #24]
     e02:	f1c4 0400 	rsb	r4, r4, #0
     e06:	9408      	str	r4, [sp, #32]
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     e08:	ea4f 596e 	mov.w	r9, lr, asr #21
    t[ 2] -= t[14] * ORDER_0;
     e0c:	f8dd 8010 	ldr.w	r8, [sp, #16]
     e10:	f8dd e02c 	ldr.w	lr, [sp, #44]	; 0x2c
     e14:	fb08 480e 	mla	r8, r8, lr, r4
     e18:	9c06      	ldr	r4, [sp, #24]
     e1a:	f8dd e010 	ldr.w	lr, [sp, #16]
     e1e:	fba4 4e0e 	umull	r4, lr, r4, lr
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     e22:	f149 0900 	adc.w	r9, r9, #0
    t[ 2] -= t[14] * ORDER_0;
     e26:	44f0      	add	r8, lr
     e28:	1934      	adds	r4, r6, r4
     e2a:	eb48 0809 	adc.w	r8, r8, r9
    t[ 2] -= t[12] * ORDER_2;
     e2e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
     e30:	f8df e388 	ldr.w	lr, [pc, #904]	; 11bc <sc_muladd+0x11bc>
    t[ 2] -= t[13] * ORDER_1;
     e34:	fba0 9a02 	umull	r9, sl, r0, r2
     e38:	ebaa 0a00 	sub.w	sl, sl, r0
     e3c:	eb14 0409 	adds.w	r4, r4, r9
     e40:	eb4a 0808 	adc.w	r8, sl, r8
    t[ 2] -= t[12] * ORDER_2;
     e44:	fb0e 7a06 	mla	sl, lr, r6, r7
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     e48:	9e0e      	ldr	r6, [sp, #56]	; 0x38
    t[ 2] -= t[12] * ORDER_2;
     e4a:	fba5 9e0e 	umull	r9, lr, r5, lr
     e4e:	eb14 0409 	adds.w	r4, r4, r9
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     e52:	ea4f 5956 	mov.w	r9, r6, lsr #21
     e56:	ea49 29cc 	orr.w	r9, r9, ip, lsl #11
    t[ 2] -= t[12] * ORDER_2;
     e5a:	44d6      	add	lr, sl
     e5c:	eb4e 0e08 	adc.w	lr, lr, r8
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     e60:	eb14 0409 	adds.w	r4, r4, r9
     e64:	940f      	str	r4, [sp, #60]	; 0x3c
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     e66:	9c2b      	ldr	r4, [sp, #172]	; 0xac
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
     e68:	eb4e 566c 	adc.w	r6, lr, ip, asr #21
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     e6c:	f3c4 0c14 	ubfx	ip, r4, #0, #21
    t[ 3] -= t[15] * ORDER_0;
     e70:	9c04      	ldr	r4, [sp, #16]
    t[ 3] -= t[14] * ORDER_1;
     e72:	f8dd e02c 	ldr.w	lr, [sp, #44]	; 0x2c
    carry = t[15] >> 21; t[16] += carry; t[15] &= MASK_21;
     e76:	f3c1 0114 	ubfx	r1, r1, #0, #21
    t[ 3] -= t[15] * ORDER_0;
     e7a:	fba1 4804 	umull	r4, r8, r1, r4
     e7e:	eb1c 0c04 	adds.w	ip, ip, r4
    t[ 3] -= t[14] * ORDER_1;
     e82:	9c08      	ldr	r4, [sp, #32]
     e84:	fb02 4a0e 	mla	sl, r2, lr, r4
     e88:	9c06      	ldr	r4, [sp, #24]
    t[ 3] -= t[15] * ORDER_0;
     e8a:	eba8 0801 	sub.w	r8, r8, r1
    t[ 3] -= t[14] * ORDER_1;
     e8e:	fba4 4e02 	umull	r4, lr, r4, r2
    t[ 3] -= t[15] * ORDER_0;
     e92:	f148 0800 	adc.w	r8, r8, #0
    t[ 3] -= t[14] * ORDER_1;
     e96:	eb1c 0404 	adds.w	r4, ip, r4
    t[ 3] -= t[13] * ORDER_2;
     e9a:	f8df c320 	ldr.w	ip, [pc, #800]	; 11bc <sc_muladd+0x11bc>
    t[ 3] -= t[14] * ORDER_1;
     e9e:	44f2      	add	sl, lr
    t[ 3] -= t[13] * ORDER_2;
     ea0:	fba0 c90c 	umull	ip, r9, r0, ip
    t[ 3] -= t[12] * ORDER_3;
     ea4:	f8df e318 	ldr.w	lr, [pc, #792]	; 11c0 <sc_muladd+0x11c0>
    t[ 3] -= t[14] * ORDER_1;
     ea8:	eb4a 0a08 	adc.w	sl, sl, r8
    t[ 3] -= t[13] * ORDER_2;
     eac:	eb14 040c 	adds.w	r4, r4, ip
    t[ 3] -= t[12] * ORDER_3;
     eb0:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    t[ 3] -= t[13] * ORDER_2;
     eb4:	eba9 0900 	sub.w	r9, r9, r0
     eb8:	eb49 0a0a 	adc.w	sl, r9, sl
    t[ 3] -= t[12] * ORDER_3;
     ebc:	fb0e 790c 	mla	r9, lr, ip, r7
     ec0:	fba5 c80e 	umull	ip, r8, r5, lr
     ec4:	eb14 040c 	adds.w	r4, r4, ip
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
     ec8:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
     ecc:	ea4f 5c5c 	mov.w	ip, ip, lsr #21
     ed0:	ea4c 2cc6 	orr.w	ip, ip, r6, lsl #11
    t[ 3] -= t[12] * ORDER_3;
     ed4:	44c8      	add	r8, r9
     ed6:	eb48 080a 	adc.w	r8, r8, sl
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
     eda:	eb14 040c 	adds.w	r4, r4, ip
     ede:	9410      	str	r4, [sp, #64]	; 0x40
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
     ee0:	9c1a      	ldr	r4, [sp, #104]	; 0x68
     ee2:	f3c4 0c14 	ubfx	ip, r4, #0, #21
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     ee6:	9c2b      	ldr	r4, [sp, #172]	; 0xac
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
     ee8:	eb48 5e66 	adc.w	lr, r8, r6, asr #21
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     eec:	9e2c      	ldr	r6, [sp, #176]	; 0xb0
    t[ 4] -= t[16] * ORDER_0;
     eee:	f8dd 8010 	ldr.w	r8, [sp, #16]
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     ef2:	0d64      	lsrs	r4, r4, #21
     ef4:	ea44 24c6 	orr.w	r4, r4, r6, lsl #11
     ef8:	ea4f 5a66 	mov.w	sl, r6, asr #21
    t[ 4] -= t[16] * ORDER_0;
     efc:	9e07      	ldr	r6, [sp, #28]
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     efe:	eb1c 0404 	adds.w	r4, ip, r4
    t[ 4] -= t[16] * ORDER_0;
     f02:	f8dd c030 	ldr.w	ip, [sp, #48]	; 0x30
     f06:	f1c6 0600 	rsb	r6, r6, #0
     f0a:	fb08 690c 	mla	r9, r8, ip, r6
     f0e:	f8dd c01c 	ldr.w	ip, [sp, #28]
     f12:	fbac c808 	umull	ip, r8, ip, r8
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     f16:	f14a 0a00 	adc.w	sl, sl, #0
    t[ 4] -= t[16] * ORDER_0;
     f1a:	44c1      	add	r9, r8
     f1c:	eb14 0c0c 	adds.w	ip, r4, ip
    t[ 4] -= t[15] * ORDER_1;
     f20:	fba1 4b02 	umull	r4, fp, r1, r2
    t[ 4] -= t[14] * ORDER_2;
     f24:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
    t[ 4] -= t[16] * ORDER_0;
     f28:	eb49 090a 	adc.w	r9, r9, sl
    t[ 4] -= t[15] * ORDER_1;
     f2c:	eb1c 0c04 	adds.w	ip, ip, r4
    t[ 4] -= t[14] * ORDER_2;
     f30:	f8df a288 	ldr.w	sl, [pc, #648]	; 11bc <sc_muladd+0x11bc>
     f34:	9c08      	ldr	r4, [sp, #32]
     f36:	fb0a 4a08 	mla	sl, sl, r8, r4
     f3a:	9c06      	ldr	r4, [sp, #24]
     f3c:	f8df 827c 	ldr.w	r8, [pc, #636]	; 11bc <sc_muladd+0x11bc>
    t[ 4] -= t[15] * ORDER_1;
     f40:	ebab 0b01 	sub.w	fp, fp, r1
    t[ 4] -= t[14] * ORDER_2;
     f44:	fba4 4808 	umull	r4, r8, r4, r8
    t[ 4] -= t[15] * ORDER_1;
     f48:	eb4b 0909 	adc.w	r9, fp, r9
    t[ 4] -= t[14] * ORDER_2;
     f4c:	eb1c 0404 	adds.w	r4, ip, r4
    t[ 4] -= t[13] * ORDER_3;
     f50:	f8df c26c 	ldr.w	ip, [pc, #620]	; 11c0 <sc_muladd+0x11c0>
    t[ 4] -= t[14] * ORDER_2;
     f54:	44c2      	add	sl, r8
    t[ 4] -= t[13] * ORDER_3;
     f56:	fba0 cb0c 	umull	ip, fp, r0, ip
    t[ 4] -= t[14] * ORDER_2;
     f5a:	eb4a 0a09 	adc.w	sl, sl, r9
    t[ 4] -= t[12] * ORDER_4;
     f5e:	f8df 8264 	ldr.w	r8, [pc, #612]	; 11c4 <sc_muladd+0x11c4>
    t[ 4] -= t[13] * ORDER_3;
     f62:	eb14 040c 	adds.w	r4, r4, ip
    t[ 4] -= t[12] * ORDER_4;
     f66:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    t[ 4] -= t[13] * ORDER_3;
     f6a:	ebab 0b00 	sub.w	fp, fp, r0
    t[ 4] -= t[12] * ORDER_4;
     f6e:	fb08 790c 	mla	r9, r8, ip, r7
     f72:	fba5 c808 	umull	ip, r8, r5, r8
    t[ 4] -= t[13] * ORDER_3;
     f76:	eb4b 0a0a 	adc.w	sl, fp, sl
    t[ 4] -= t[12] * ORDER_4;
     f7a:	eb14 040c 	adds.w	r4, r4, ip
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     f7e:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
     f82:	ea4f 5c5c 	mov.w	ip, ip, lsr #21
     f86:	ea4c 2cce 	orr.w	ip, ip, lr, lsl #11
    t[ 4] -= t[12] * ORDER_4;
     f8a:	44c8      	add	r8, r9
     f8c:	eb48 080a 	adc.w	r8, r8, sl
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     f90:	eb14 040c 	adds.w	r4, r4, ip
     f94:	9411      	str	r4, [sp, #68]	; 0x44
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
     f96:	9c2d      	ldr	r4, [sp, #180]	; 0xb4
    t[ 5] -= t[17] * ORDER_0;
     f98:	f8dd 9010 	ldr.w	r9, [sp, #16]
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
     f9c:	f3c4 0c14 	ubfx	ip, r4, #0, #21
    t[ 5] -= t[17] * ORDER_0;
     fa0:	9c05      	ldr	r4, [sp, #20]
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
     fa2:	eb48 586e 	adc.w	r8, r8, lr, asr #21
    t[ 5] -= t[17] * ORDER_0;
     fa6:	f8dd e024 	ldr.w	lr, [sp, #36]	; 0x24
     faa:	4264      	negs	r4, r4
     fac:	fb09 4b0e 	mla	fp, r9, lr, r4
     fb0:	f8dd e014 	ldr.w	lr, [sp, #20]
     fb4:	fbae e909 	umull	lr, r9, lr, r9
     fb8:	eb1c 0c0e 	adds.w	ip, ip, lr
    t[ 5] -= t[16] * ORDER_1;
     fbc:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
     fc0:	fb02 6a0e 	mla	sl, r2, lr, r6
     fc4:	f8dd e01c 	ldr.w	lr, [sp, #28]
    t[ 5] -= t[17] * ORDER_0;
     fc8:	eb4b 0b09 	adc.w	fp, fp, r9
    t[ 5] -= t[16] * ORDER_1;
     fcc:	fbae e902 	umull	lr, r9, lr, r2
     fd0:	eb1c 0e0e 	adds.w	lr, ip, lr
    t[ 5] -= t[15] * ORDER_2;
     fd4:	f8df c1e4 	ldr.w	ip, [pc, #484]	; 11bc <sc_muladd+0x11bc>
    t[ 5] -= t[16] * ORDER_1;
     fd8:	44ca      	add	sl, r9
    t[ 5] -= t[15] * ORDER_2;
     fda:	fba1 9c0c 	umull	r9, ip, r1, ip
    t[ 5] -= t[16] * ORDER_1;
     fde:	eb4a 0a0b 	adc.w	sl, sl, fp
    t[ 5] -= t[15] * ORDER_2;
     fe2:	ebac 0c01 	sub.w	ip, ip, r1
     fe6:	eb1e 0e09 	adds.w	lr, lr, r9
     fea:	eb4c 0a0a 	adc.w	sl, ip, sl
    t[ 5] -= t[14] * ORDER_3;
     fee:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
     ff2:	f8dd c020 	ldr.w	ip, [sp, #32]
     ff6:	f8df b1c8 	ldr.w	fp, [pc, #456]	; 11c0 <sc_muladd+0x11c0>
     ffa:	fb0b cb09 	mla	fp, fp, r9, ip
     ffe:	f8dd c018 	ldr.w	ip, [sp, #24]
    1002:	f8df 91bc 	ldr.w	r9, [pc, #444]	; 11c0 <sc_muladd+0x11c0>
    1006:	fbac c909 	umull	ip, r9, ip, r9
    100a:	eb1e 0c0c 	adds.w	ip, lr, ip
    t[ 5] -= t[13] * ORDER_4;
    100e:	f8df e1b4 	ldr.w	lr, [pc, #436]	; 11c4 <sc_muladd+0x11c4>
    t[ 5] -= t[14] * ORDER_3;
    1012:	44d9      	add	r9, fp
    1014:	eb49 090a 	adc.w	r9, r9, sl
    t[ 5] -= t[13] * ORDER_4;
    1018:	fba0 ea0e 	umull	lr, sl, r0, lr
    101c:	ebaa 0a00 	sub.w	sl, sl, r0
    1020:	eb1c 0c0e 	adds.w	ip, ip, lr
    1024:	eb4a 0909 	adc.w	r9, sl, r9
    t[ 5] -= t[12] * ORDER_5;
    1028:	fba5 5a03 	umull	r5, sl, r5, r3
    102c:	f8dd e028 	ldr.w	lr, [sp, #40]	; 0x28
    1030:	eb1c 0c05 	adds.w	ip, ip, r5
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    1034:	9d11      	ldr	r5, [sp, #68]	; 0x44
    t[ 5] -= t[12] * ORDER_5;
    1036:	fb03 770e 	mla	r7, r3, lr, r7
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    103a:	ea4f 5e55 	mov.w	lr, r5, lsr #21
    t[ 5] -= t[12] * ORDER_5;
    103e:	4457      	add	r7, sl
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    1040:	ea4e 2ec8 	orr.w	lr, lr, r8, lsl #11
    t[ 5] -= t[12] * ORDER_5;
    1044:	eb47 0909 	adc.w	r9, r7, r9
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    1048:	eb1c 050e 	adds.w	r5, ip, lr
    104c:	950a      	str	r5, [sp, #40]	; 0x28
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    104e:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
    1050:	f3c5 0e14 	ubfx	lr, r5, #0, #21
    t[ 6] -= t[17] * ORDER_1;
    1054:	9d09      	ldr	r5, [sp, #36]	; 0x24
    1056:	fb02 4705 	mla	r7, r2, r5, r4
    105a:	9d05      	ldr	r5, [sp, #20]
    105c:	fba5 c502 	umull	ip, r5, r5, r2
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    1060:	eb49 5868 	adc.w	r8, r9, r8, asr #21
    t[ 6] -= t[17] * ORDER_1;
    1064:	eb1e 0e0c 	adds.w	lr, lr, ip
    1068:	eb47 0705 	adc.w	r7, r7, r5
    t[ 6] -= t[16] * ORDER_2;
    106c:	f8df c14c 	ldr.w	ip, [pc, #332]	; 11bc <sc_muladd+0x11bc>
    1070:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    1072:	fb0c 6905 	mla	r9, ip, r5, r6
    1076:	9d07      	ldr	r5, [sp, #28]
    1078:	fba5 c50c 	umull	ip, r5, r5, ip
    107c:	eb1e 0c0c 	adds.w	ip, lr, ip
    1080:	444d      	add	r5, r9
    1082:	eb45 0507 	adc.w	r5, r5, r7
    t[ 6] -= t[15] * ORDER_3;
    1086:	4f4e      	ldr	r7, [pc, #312]	; (11c0 <sc_muladd+0x11c0>)
    t[ 6] -= t[14] * ORDER_4;
    1088:	f8df 9138 	ldr.w	r9, [pc, #312]	; 11c4 <sc_muladd+0x11c4>
    t[ 6] -= t[15] * ORDER_3;
    108c:	fba1 7e07 	umull	r7, lr, r1, r7
    1090:	eb1c 0c07 	adds.w	ip, ip, r7
    1094:	ebae 0e01 	sub.w	lr, lr, r1
    t[ 6] -= t[14] * ORDER_4;
    1098:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    t[ 6] -= t[15] * ORDER_3;
    109a:	eb4e 0e05 	adc.w	lr, lr, r5
    t[ 6] -= t[14] * ORDER_4;
    109e:	9d08      	ldr	r5, [sp, #32]
    10a0:	fb09 5907 	mla	r9, r9, r7, r5
    10a4:	9d06      	ldr	r5, [sp, #24]
    10a6:	4f47      	ldr	r7, [pc, #284]	; (11c4 <sc_muladd+0x11c4>)
    10a8:	fba5 5707 	umull	r5, r7, r5, r7
    10ac:	eb1c 0505 	adds.w	r5, ip, r5
    10b0:	444f      	add	r7, r9
    t[ 6] -= t[13] * ORDER_5;
    10b2:	fba0 ca03 	umull	ip, sl, r0, r3
    t[ 6] -= t[14] * ORDER_4;
    10b6:	eb47 070e 	adc.w	r7, r7, lr
    t[ 6] -= t[13] * ORDER_5;
    10ba:	ebaa 0000 	sub.w	r0, sl, r0
    10be:	eb15 0c0c 	adds.w	ip, r5, ip
    10c2:	eb40 0707 	adc.w	r7, r0, r7
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    10c6:	980a      	ldr	r0, [sp, #40]	; 0x28
    10c8:	0d45      	lsrs	r5, r0, #21
    10ca:	ea45 25c8 	orr.w	r5, r5, r8, lsl #11
    10ce:	eb1c 0005 	adds.w	r0, ip, r5
    10d2:	eb47 5868 	adc.w	r8, r7, r8, asr #21
    t[ 7] -= t[17] * ORDER_2;
    10d6:	9d09      	ldr	r5, [sp, #36]	; 0x24
    10d8:	4f38      	ldr	r7, [pc, #224]	; (11bc <sc_muladd+0x11bc>)
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    10da:	9012      	str	r0, [sp, #72]	; 0x48
    t[ 7] -= t[17] * ORDER_2;
    10dc:	fb07 4c05 	mla	ip, r7, r5, r4
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    10e0:	9821      	ldr	r0, [sp, #132]	; 0x84
    t[ 7] -= t[17] * ORDER_2;
    10e2:	9d05      	ldr	r5, [sp, #20]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    10e4:	f3c0 0014 	ubfx	r0, r0, #0, #21
    t[ 7] -= t[17] * ORDER_2;
    10e8:	fba5 7507 	umull	r7, r5, r5, r7
    10ec:	19c0      	adds	r0, r0, r7
    10ee:	eb4c 0c05 	adc.w	ip, ip, r5
    t[ 7] -= t[16] * ORDER_3;
    10f2:	4f33      	ldr	r7, [pc, #204]	; (11c0 <sc_muladd+0x11c0>)
    10f4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    10f6:	fb07 6e05 	mla	lr, r7, r5, r6
    10fa:	9d07      	ldr	r5, [sp, #28]
    10fc:	fba5 5707 	umull	r5, r7, r5, r7
    1100:	1940      	adds	r0, r0, r5
    t[ 7] -= t[15] * ORDER_4;
    1102:	4d30      	ldr	r5, [pc, #192]	; (11c4 <sc_muladd+0x11c4>)
    t[ 7] -= t[16] * ORDER_3;
    1104:	4477      	add	r7, lr
    t[ 7] -= t[15] * ORDER_4;
    1106:	fba1 5905 	umull	r5, r9, r1, r5
    t[ 7] -= t[16] * ORDER_3;
    110a:	eb47 070c 	adc.w	r7, r7, ip
    t[ 7] -= t[14] * ORDER_5;
    110e:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    t[ 7] -= t[15] * ORDER_4;
    1112:	1945      	adds	r5, r0, r5
    t[ 7] -= t[14] * ORDER_5;
    1114:	9808      	ldr	r0, [sp, #32]
    1116:	fb03 0a0c 	mla	sl, r3, ip, r0
    111a:	9806      	ldr	r0, [sp, #24]
    t[ 8] -= t[17] * ORDER_3;
    111c:	f8df c0a0 	ldr.w	ip, [pc, #160]	; 11c0 <sc_muladd+0x11c0>
    t[ 7] -= t[15] * ORDER_4;
    1120:	eba9 0901 	sub.w	r9, r9, r1
    1124:	eb49 0707 	adc.w	r7, r9, r7
    t[ 7] -= t[14] * ORDER_5;
    1128:	fba0 9003 	umull	r9, r0, r0, r3
    112c:	4482      	add	sl, r0
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    112e:	9812      	ldr	r0, [sp, #72]	; 0x48
    1130:	ea4f 5b50 	mov.w	fp, r0, lsr #21
    t[ 7] -= t[14] * ORDER_5;
    1134:	eb15 0509 	adds.w	r5, r5, r9
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    1138:	ea4b 2bc8 	orr.w	fp, fp, r8, lsl #11
    t[ 7] -= t[14] * ORDER_5;
    113c:	eb4a 0707 	adc.w	r7, sl, r7
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    1140:	eb15 000b 	adds.w	r0, r5, fp
    1144:	9006      	str	r0, [sp, #24]
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    1146:	981c      	ldr	r0, [sp, #112]	; 0x70
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    1148:	9d22      	ldr	r5, [sp, #136]	; 0x88
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    114a:	eb47 5868 	adc.w	r8, r7, r8, asr #21
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    114e:	f3c0 0a14 	ubfx	sl, r0, #0, #21
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    1152:	9821      	ldr	r0, [sp, #132]	; 0x84
    t[ 8] -= t[17] * ORDER_3;
    1154:	9f09      	ldr	r7, [sp, #36]	; 0x24
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    1156:	0d40      	lsrs	r0, r0, #21
    t[ 8] -= t[17] * ORDER_3;
    1158:	fb0c 4e07 	mla	lr, ip, r7, r4
    115c:	9f05      	ldr	r7, [sp, #20]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    115e:	ea40 20c5 	orr.w	r0, r0, r5, lsl #11
    1162:	eb1a 0000 	adds.w	r0, sl, r0
    t[ 8] -= t[17] * ORDER_3;
    1166:	fba7 7c0c 	umull	r7, ip, r7, ip
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    116a:	ea4f 5565 	mov.w	r5, r5, asr #21
    116e:	f145 0500 	adc.w	r5, r5, #0
    t[ 8] -= t[17] * ORDER_3;
    1172:	44f4      	add	ip, lr
    1174:	19c0      	adds	r0, r0, r7
    1176:	eb4c 0c05 	adc.w	ip, ip, r5
    t[ 8] -= t[16] * ORDER_4;
    117a:	4f12      	ldr	r7, [pc, #72]	; (11c4 <sc_muladd+0x11c4>)
    117c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    117e:	fb07 6e05 	mla	lr, r7, r5, r6
    1182:	9d07      	ldr	r5, [sp, #28]
    1184:	fba5 5707 	umull	r5, r7, r5, r7
    1188:	1940      	adds	r0, r0, r5
    118a:	4477      	add	r7, lr
    t[ 8] -= t[15] * ORDER_5;
    118c:	fba1 5903 	umull	r5, r9, r1, r3
    t[ 8] -= t[16] * ORDER_4;
    1190:	eb47 070c 	adc.w	r7, r7, ip
    t[ 8] -= t[15] * ORDER_5;
    1194:	eba9 0101 	sub.w	r1, r9, r1
    1198:	1940      	adds	r0, r0, r5
    119a:	eb41 0707 	adc.w	r7, r1, r7
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    119e:	9906      	ldr	r1, [sp, #24]
    11a0:	0d4d      	lsrs	r5, r1, #21
    11a2:	ea45 25c8 	orr.w	r5, r5, r8, lsl #11
    11a6:	1941      	adds	r1, r0, r5
    t[ 9] -= t[17] * ORDER_4;
    11a8:	9809      	ldr	r0, [sp, #36]	; 0x24
    11aa:	4d06      	ldr	r5, [pc, #24]	; (11c4 <sc_muladd+0x11c4>)
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    11ac:	9108      	str	r1, [sp, #32]
    11ae:	eb47 5868 	adc.w	r8, r7, r8, asr #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    11b2:	9923      	ldr	r1, [sp, #140]	; 0x8c
    t[ 9] -= t[17] * ORDER_4;
    11b4:	fb05 4700 	mla	r7, r5, r0, r4
    11b8:	e006      	b.n	11c8 <sc_muladd+0x11c8>
    11ba:	bf00      	nop
    11bc:	ffe9fb68 	.word	0xffe9fb68
    11c0:	fff0c654 	.word	0xfff0c654
    11c4:	ffe215d1 	.word	0xffe215d1
    11c8:	9805      	ldr	r0, [sp, #20]
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    11ca:	f3c1 0114 	ubfx	r1, r1, #0, #21
    t[ 9] -= t[17] * ORDER_4;
    11ce:	fba0 5005 	umull	r5, r0, r0, r5
    11d2:	1949      	adds	r1, r1, r5
    t[ 9] -= t[16] * ORDER_5;
    11d4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    11d6:	fb03 6605 	mla	r6, r3, r5, r6
    11da:	9d07      	ldr	r5, [sp, #28]
    t[ 9] -= t[17] * ORDER_4;
    11dc:	eb47 0000 	adc.w	r0, r7, r0
    t[ 9] -= t[16] * ORDER_5;
    11e0:	fba5 7503 	umull	r7, r5, r5, r3
    11e4:	19c9      	adds	r1, r1, r7
    11e6:	442e      	add	r6, r5
    11e8:	eb46 0600 	adc.w	r6, r6, r0
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    11ec:	9808      	ldr	r0, [sp, #32]
    11ee:	0d47      	lsrs	r7, r0, #21
    11f0:	ea47 27c8 	orr.w	r7, r7, r8, lsl #11
    11f4:	19c9      	adds	r1, r1, r7
    11f6:	9107      	str	r1, [sp, #28]
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    11f8:	991d      	ldr	r1, [sp, #116]	; 0x74
    t[ 0] -= t[12] * ORDER_0;
    11fa:	9804      	ldr	r0, [sp, #16]
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    11fc:	f3c1 0e14 	ubfx	lr, r1, #0, #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1200:	9923      	ldr	r1, [sp, #140]	; 0x8c
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    1202:	eb46 5868 	adc.w	r8, r6, r8, asr #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1206:	0d4e      	lsrs	r6, r1, #21
    1208:	9920      	ldr	r1, [sp, #128]	; 0x80
    120a:	ea46 26c1 	orr.w	r6, r6, r1, lsl #11
    120e:	154d      	asrs	r5, r1, #21
    t[10] -= t[17] * ORDER_5;
    1210:	9909      	ldr	r1, [sp, #36]	; 0x24
    1212:	fb03 4401 	mla	r4, r3, r1, r4
    1216:	9905      	ldr	r1, [sp, #20]
    1218:	fba1 a103 	umull	sl, r1, r1, r3
    121c:	440c      	add	r4, r1
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    121e:	9907      	ldr	r1, [sp, #28]
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1220:	eb1e 0e06 	adds.w	lr, lr, r6
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1224:	ea4f 5151 	mov.w	r1, r1, lsr #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1228:	f145 0500 	adc.w	r5, r5, #0
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    122c:	ea41 21c8 	orr.w	r1, r1, r8, lsl #11
    t[10] -= t[17] * ORDER_5;
    1230:	eb1e 0e0a 	adds.w	lr, lr, sl
    1234:	eb44 0405 	adc.w	r4, r4, r5
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1238:	eb1e 0101 	adds.w	r1, lr, r1
    123c:	9105      	str	r1, [sp, #20]
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
    123e:	9924      	ldr	r1, [sp, #144]	; 0x90
    1240:	f3c1 0a14 	ubfx	sl, r1, #0, #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    1244:	9905      	ldr	r1, [sp, #20]
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1246:	eb44 5868 	adc.w	r8, r4, r8, asr #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    124a:	ea4f 5c51 	mov.w	ip, r1, lsr #21
    124e:	ea4c 2cc8 	orr.w	ip, ip, r8, lsl #11
    1252:	eb1a 0a0c 	adds.w	sl, sl, ip
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
    1256:	990d      	ldr	r1, [sp, #52]	; 0x34
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    1258:	ea4f 5768 	mov.w	r7, r8, asr #21
    125c:	f147 0700 	adc.w	r7, r7, #0
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
    1260:	ea4f 565a 	mov.w	r6, sl, lsr #21
    1264:	ea46 26c7 	orr.w	r6, r6, r7, lsl #11
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
    1268:	f3c1 0b14 	ubfx	fp, r1, #0, #21
    t[ 0] -= t[12] * ORDER_0;
    126c:	9904      	ldr	r1, [sp, #16]
    126e:	f1c6 0800 	rsb	r8, r6, #0
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
    1272:	157f      	asrs	r7, r7, #21
    t[ 0] -= t[12] * ORDER_0;
    1274:	fba6 4000 	umull	r4, r0, r6, r0
    1278:	fb01 8107 	mla	r1, r1, r7, r8
    127c:	eb1b 0b04 	adds.w	fp, fp, r4
    1280:	eb41 0000 	adc.w	r0, r1, r0
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
    1284:	990e      	ldr	r1, [sp, #56]	; 0x38
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
    1286:	ea4f 545b 	mov.w	r4, fp, lsr #21
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
    128a:	f3c1 0914 	ubfx	r9, r1, #0, #21
    t[ 1] -= t[12] * ORDER_1;
    128e:	fb02 8107 	mla	r1, r2, r7, r8
    1292:	fba6 2502 	umull	r2, r5, r6, r2
    1296:	eb19 0202 	adds.w	r2, r9, r2
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
    129a:	ea44 24c0 	orr.w	r4, r4, r0, lsl #11
    t[ 1] -= t[12] * ORDER_1;
    129e:	eb41 0105 	adc.w	r1, r1, r5
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
    12a2:	1912      	adds	r2, r2, r4
    12a4:	eb41 5160 	adc.w	r1, r1, r0, asr #21
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
    12a8:	980f      	ldr	r0, [sp, #60]	; 0x3c
    12aa:	f3c0 0414 	ubfx	r4, r0, #0, #21
    t[ 2] -= t[12] * ORDER_2;
    12ae:	4887      	ldr	r0, [pc, #540]	; (14cc <sc_muladd+0x14cc>)
    12b0:	fb00 8507 	mla	r5, r0, r7, r8
    12b4:	fba6 0900 	umull	r0, r9, r6, r0
    12b8:	1820      	adds	r0, r4, r0
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
    12ba:	ea4f 5452 	mov.w	r4, r2, lsr #21
    12be:	ea44 24c1 	orr.w	r4, r4, r1, lsl #11
    t[ 2] -= t[12] * ORDER_2;
    12c2:	eb45 0509 	adc.w	r5, r5, r9
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
    12c6:	1900      	adds	r0, r0, r4
    12c8:	eb45 5561 	adc.w	r5, r5, r1, asr #21
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
    12cc:	9910      	ldr	r1, [sp, #64]	; 0x40
    12ce:	f3c1 0c14 	ubfx	ip, r1, #0, #21
    t[ 3] -= t[12] * ORDER_3;
    12d2:	497f      	ldr	r1, [pc, #508]	; (14d0 <sc_muladd+0x14d0>)
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
    12d4:	0d44      	lsrs	r4, r0, #21
    t[ 3] -= t[12] * ORDER_3;
    12d6:	fb01 8e07 	mla	lr, r1, r7, r8
    12da:	fba6 1901 	umull	r1, r9, r6, r1
    12de:	eb1c 0101 	adds.w	r1, ip, r1
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
    12e2:	ea44 24c5 	orr.w	r4, r4, r5, lsl #11
    t[ 3] -= t[12] * ORDER_3;
    12e6:	eb4e 0909 	adc.w	r9, lr, r9
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
    12ea:	1909      	adds	r1, r1, r4
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    12ec:	9c11      	ldr	r4, [sp, #68]	; 0x44
    12ee:	f3c4 0c14 	ubfx	ip, r4, #0, #21
    t[ 4] -= t[12] * ORDER_4;
    12f2:	4c78      	ldr	r4, [pc, #480]	; (14d4 <sc_muladd+0x14d4>)
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
    12f4:	eb49 5965 	adc.w	r9, r9, r5, asr #21
    t[ 4] -= t[12] * ORDER_4;
    12f8:	fb04 8e07 	mla	lr, r4, r7, r8
    12fc:	fba6 5404 	umull	r5, r4, r6, r4
    1300:	eb1c 0c05 	adds.w	ip, ip, r5
    1304:	eb4e 0e04 	adc.w	lr, lr, r4
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
    1308:	0d4d      	lsrs	r5, r1, #21
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    130a:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
    130c:	ea45 25c9 	orr.w	r5, r5, r9, lsl #11
    1310:	eb1c 0c05 	adds.w	ip, ip, r5
    t[ 5] -= t[12] * ORDER_5;
    1314:	fb03 8707 	mla	r7, r3, r7, r8
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    1318:	f3c4 0514 	ubfx	r5, r4, #0, #21
    t[ 5] -= t[12] * ORDER_5;
    131c:	fba6 3803 	umull	r3, r8, r6, r3
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
    1320:	eb4e 5e69 	adc.w	lr, lr, r9, asr #21
    t[ 5] -= t[12] * ORDER_5;
    1324:	18eb      	adds	r3, r5, r3
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    1326:	ea4f 555c 	mov.w	r5, ip, lsr #21
    132a:	ea45 25ce 	orr.w	r5, r5, lr, lsl #11
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    132e:	9c12      	ldr	r4, [sp, #72]	; 0x48
    t[ 5] -= t[12] * ORDER_5;
    1330:	eb47 0708 	adc.w	r7, r7, r8
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    1334:	195b      	adds	r3, r3, r5
    1336:	eb47 5e6e 	adc.w	lr, r7, lr, asr #21
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    133a:	0d5d      	lsrs	r5, r3, #21
    133c:	ea45 25ce 	orr.w	r5, r5, lr, lsl #11
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    1340:	f3c4 0614 	ubfx	r6, r4, #0, #21
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    1344:	1976      	adds	r6, r6, r5
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    1346:	9c06      	ldr	r4, [sp, #24]
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    1348:	ea4f 576e 	mov.w	r7, lr, asr #21
    134c:	f147 0700 	adc.w	r7, r7, #0
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    1350:	ea4f 5856 	mov.w	r8, r6, lsr #21
    1354:	ea48 28c7 	orr.w	r8, r8, r7, lsl #11
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    1358:	f3c4 0914 	ubfx	r9, r4, #0, #21
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    135c:	9c08      	ldr	r4, [sp, #32]
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    135e:	eb19 0908 	adds.w	r9, r9, r8
    1362:	ea4f 5767 	mov.w	r7, r7, asr #21
    1366:	f147 0700 	adc.w	r7, r7, #0
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    136a:	f3c4 0514 	ubfx	r5, r4, #0, #21
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    136e:	ea4f 5459 	mov.w	r4, r9, lsr #21
    1372:	ea44 24c7 	orr.w	r4, r4, r7, lsl #11
    1376:	192d      	adds	r5, r5, r4
    1378:	ea4f 5767 	mov.w	r7, r7, asr #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    137c:	9c07      	ldr	r4, [sp, #28]
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    137e:	f147 0700 	adc.w	r7, r7, #0
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    1382:	ea4f 5e55 	mov.w	lr, r5, lsr #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1386:	f3c4 0414 	ubfx	r4, r4, #0, #21
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    138a:	ea4e 2ec7 	orr.w	lr, lr, r7, lsl #11
    138e:	eb14 0e0e 	adds.w	lr, r4, lr
    1392:	ea4f 5767 	mov.w	r7, r7, asr #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    1396:	9c05      	ldr	r4, [sp, #20]
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    1398:	f147 0700 	adc.w	r7, r7, #0
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    139c:	ea4f 585e 	mov.w	r8, lr, lsr #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    13a0:	f3c4 0414 	ubfx	r4, r4, #0, #21
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    13a4:	ea48 28c7 	orr.w	r8, r8, r7, lsl #11
    13a8:	eb14 0808 	adds.w	r8, r4, r8
    13ac:	ea4f 5767 	mov.w	r7, r7, asr #21
    13b0:	f147 0700 	adc.w	r7, r7, #0
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    13b4:	ea4f 5458 	mov.w	r4, r8, lsr #21
    13b8:	ea44 24c7 	orr.w	r4, r4, r7, lsl #11
    carry = t[11] >> 21; t[12] += carry; t[11] &= MASK_21;
    13bc:	f3ca 0a14 	ubfx	sl, sl, #0, #21
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    13c0:	eb1a 0a04 	adds.w	sl, sl, r4
    s[ 0] = (byte)(t[ 0] >>  0);
    13c4:	9c00      	ldr	r4, [sp, #0]
    s[ 1] = (byte)(t[ 0] >>  8);
    13c6:	9f00      	ldr	r7, [sp, #0]
    carry = t[ 0] >> 21; t[ 1] += carry; t[ 0] &= MASK_21;
    13c8:	f3cb 0b14 	ubfx	fp, fp, #0, #21
    s[ 0] = (byte)(t[ 0] >>  0);
    13cc:	f884 b000 	strb.w	fp, [r4]
    carry = t[ 1] >> 21; t[ 2] += carry; t[ 1] &= MASK_21;
    13d0:	f3c2 0214 	ubfx	r2, r2, #0, #21
    s[ 1] = (byte)(t[ 0] >>  8);
    13d4:	ea4f 241b 	mov.w	r4, fp, lsr #8
    13d8:	707c      	strb	r4, [r7, #1]
    s[ 2] = (byte)((t[ 0] >> 16) | (t[ 1] <<  5));
    13da:	0154      	lsls	r4, r2, #5
    13dc:	ea44 4b1b 	orr.w	fp, r4, fp, lsr #16
    s[ 3] = (byte)(t[ 1] >>  3);
    13e0:	08d4      	lsrs	r4, r2, #3
    carry = t[ 2] >> 21; t[ 3] += carry; t[ 2] &= MASK_21;
    13e2:	f3c0 0014 	ubfx	r0, r0, #0, #21
    s[ 3] = (byte)(t[ 1] >>  3);
    13e6:	70fc      	strb	r4, [r7, #3]
    s[ 4] = (byte)(t[ 1] >> 11);
    13e8:	0ad4      	lsrs	r4, r2, #11
    13ea:	713c      	strb	r4, [r7, #4]
    s[ 5] = (byte)((t[ 1] >> 19) | (t[ 2] <<  2));
    13ec:	0084      	lsls	r4, r0, #2
    13ee:	ea44 42d2 	orr.w	r2, r4, r2, lsr #19
    carry = t[ 3] >> 21; t[ 4] += carry; t[ 3] &= MASK_21;
    13f2:	f3c1 0114 	ubfx	r1, r1, #0, #21
    s[ 5] = (byte)((t[ 1] >> 19) | (t[ 2] <<  2));
    13f6:	717a      	strb	r2, [r7, #5]
    s[ 6] = (byte)(t[ 2] >>  6);
    13f8:	0982      	lsrs	r2, r0, #6
    13fa:	71ba      	strb	r2, [r7, #6]
    s[ 7] = (byte)((t[ 2] >> 14) | (t[ 3] <<  7));
    13fc:	01ca      	lsls	r2, r1, #7
    13fe:	ea42 3090 	orr.w	r0, r2, r0, lsr #14
    s[ 8] = (byte)(t[ 3] >>  1);
    1402:	084a      	lsrs	r2, r1, #1
    carry = t[ 4] >> 21; t[ 5] += carry; t[ 4] &= MASK_21;
    1404:	f3cc 0c14 	ubfx	ip, ip, #0, #21
    s[ 8] = (byte)(t[ 3] >>  1);
    1408:	723a      	strb	r2, [r7, #8]
    s[ 9] = (byte)(t[ 3] >>  9);
    140a:	0a4a      	lsrs	r2, r1, #9
    140c:	727a      	strb	r2, [r7, #9]
    s[10] = (byte)((t[ 3] >> 17) | (t[ 4] <<  4));
    140e:	ea4f 120c 	mov.w	r2, ip, lsl #4
    1412:	ea42 4151 	orr.w	r1, r2, r1, lsr #17
    s[11] = (byte)(t[ 4] >>  4);
    1416:	ea4f 121c 	mov.w	r2, ip, lsr #4
    carry = t[ 5] >> 21; t[ 6] += carry; t[ 5] &= MASK_21;
    141a:	f3c3 0314 	ubfx	r3, r3, #0, #21
    s[11] = (byte)(t[ 4] >>  4);
    141e:	72fa      	strb	r2, [r7, #11]
    s[12] = (byte)(t[ 4] >> 12);
    1420:	ea4f 321c 	mov.w	r2, ip, lsr #12
    1424:	733a      	strb	r2, [r7, #12]
    s[13] = (byte)((t[ 4] >> 20) | (t[ 5] <<  1));
    1426:	18da      	adds	r2, r3, r3
    carry = t[ 6] >> 21; t[ 7] += carry; t[ 6] &= MASK_21;
    1428:	f3c6 0614 	ubfx	r6, r6, #0, #21
    s[13] = (byte)((t[ 4] >> 20) | (t[ 5] <<  1));
    142c:	ea42 5c1c 	orr.w	ip, r2, ip, lsr #20
    s[14] = (byte)(t[ 5] >>  7);
    1430:	09da      	lsrs	r2, r3, #7
    1432:	73ba      	strb	r2, [r7, #14]
    s[15] = (byte)((t[ 5] >> 15) | (t[ 6] <<  6));
    1434:	01b2      	lsls	r2, r6, #6
    1436:	ea42 33d3 	orr.w	r3, r2, r3, lsr #15
    143a:	73fb      	strb	r3, [r7, #15]
    s[16] = (byte)(t[ 6] >>  2);
    143c:	08b3      	lsrs	r3, r6, #2
    carry = t[ 7] >> 21; t[ 8] += carry; t[ 7] &= MASK_21;
    143e:	f3c9 0914 	ubfx	r9, r9, #0, #21
    s[16] = (byte)(t[ 6] >>  2);
    1442:	743b      	strb	r3, [r7, #16]
    s[17] = (byte)(t[ 6] >> 10);
    1444:	0ab3      	lsrs	r3, r6, #10
    1446:	747b      	strb	r3, [r7, #17]
    s[18] = (byte)((t[ 6] >> 18) | (t[ 7] <<  3));
    1448:	ea4f 03c9 	mov.w	r3, r9, lsl #3
    carry = t[ 8] >> 21; t[ 9] += carry; t[ 8] &= MASK_21;
    144c:	f3c5 0514 	ubfx	r5, r5, #0, #21
    s[18] = (byte)((t[ 6] >> 18) | (t[ 7] <<  3));
    1450:	ea43 4696 	orr.w	r6, r3, r6, lsr #18
    s[19] = (byte)(t[ 7] >>  5);
    1454:	ea4f 1359 	mov.w	r3, r9, lsr #5
    carry = t[ 9] >> 21; t[10] += carry; t[ 9] &= MASK_21;
    1458:	f3ce 0e14 	ubfx	lr, lr, #0, #21
    s[19] = (byte)(t[ 7] >>  5);
    145c:	74fb      	strb	r3, [r7, #19]
    s[22] = (byte)(t[ 8] >>  8);
    145e:	0a2b      	lsrs	r3, r5, #8
    carry = t[10] >> 21; t[11] += carry; t[10] &= MASK_21;
    1460:	f3c8 0814 	ubfx	r8, r8, #0, #21
    s[22] = (byte)(t[ 8] >>  8);
    1464:	75bb      	strb	r3, [r7, #22]
    s[23] = (byte)((t[ 8] >> 16) | (t[ 9] <<  5));
    1466:	ea4f 144e 	mov.w	r4, lr, lsl #5
    s[24] = (byte)(t[ 9] >>  3);
    146a:	ea4f 03de 	mov.w	r3, lr, lsr #3
    s[21] = (byte)(t[ 8] >>  0);
    146e:	757d      	strb	r5, [r7, #21]
    s[24] = (byte)(t[ 9] >>  3);
    1470:	763b      	strb	r3, [r7, #24]
    s[23] = (byte)((t[ 8] >> 16) | (t[ 9] <<  5));
    1472:	ea44 4515 	orr.w	r5, r4, r5, lsr #16
    s[25] = (byte)(t[ 9] >> 11);
    1476:	ea4f 23de 	mov.w	r3, lr, lsr #11
    s[26] = (byte)((t[ 9] >> 19) | (t[10] <<  2));
    147a:	ea4f 0488 	mov.w	r4, r8, lsl #2
    s[25] = (byte)(t[ 9] >> 11);
    147e:	767b      	strb	r3, [r7, #25]
    s[26] = (byte)((t[ 9] >> 19) | (t[10] <<  2));
    1480:	ea44 4ede 	orr.w	lr, r4, lr, lsr #19
    s[27] = (byte)(t[10] >>  6);
    1484:	ea4f 1398 	mov.w	r3, r8, lsr #6
    s[20] = (byte)(t[ 7] >> 13);
    1488:	ea4f 3959 	mov.w	r9, r9, lsr #13
    s[28] = (byte)((t[10] >> 14) | (t[11] <<  7));
    148c:	ea4f 14ca 	mov.w	r4, sl, lsl #7
    s[ 2] = (byte)((t[ 0] >> 16) | (t[ 1] <<  5));
    1490:	f887 b002 	strb.w	fp, [r7, #2]
    s[ 7] = (byte)((t[ 2] >> 14) | (t[ 3] <<  7));
    1494:	71f8      	strb	r0, [r7, #7]
    s[10] = (byte)((t[ 3] >> 17) | (t[ 4] <<  4));
    1496:	72b9      	strb	r1, [r7, #10]
    s[13] = (byte)((t[ 4] >> 20) | (t[ 5] <<  1));
    1498:	f887 c00d 	strb.w	ip, [r7, #13]
    s[18] = (byte)((t[ 6] >> 18) | (t[ 7] <<  3));
    149c:	74be      	strb	r6, [r7, #18]
    s[20] = (byte)(t[ 7] >> 13);
    149e:	f887 9014 	strb.w	r9, [r7, #20]
    s[23] = (byte)((t[ 8] >> 16) | (t[ 9] <<  5));
    14a2:	75fd      	strb	r5, [r7, #23]
    s[26] = (byte)((t[ 9] >> 19) | (t[10] <<  2));
    14a4:	f887 e01a 	strb.w	lr, [r7, #26]
    s[27] = (byte)(t[10] >>  6);
    14a8:	76fb      	strb	r3, [r7, #27]
    s[29] = (byte)(t[11] >>  1);
    14aa:	ea4f 035a 	mov.w	r3, sl, lsr #1
    s[28] = (byte)((t[10] >> 14) | (t[11] <<  7));
    14ae:	ea44 3898 	orr.w	r8, r4, r8, lsr #14
    s[29] = (byte)(t[11] >>  1);
    14b2:	777b      	strb	r3, [r7, #29]
    s[30] = (byte)(t[11] >>  9);
    14b4:	ea4f 235a 	mov.w	r3, sl, lsr #9
    s[31] = (byte)(t[11] >> 17);
    14b8:	ea4f 4a5a 	mov.w	sl, sl, lsr #17
    s[28] = (byte)((t[10] >> 14) | (t[11] <<  7));
    14bc:	f887 801c 	strb.w	r8, [r7, #28]
    s[30] = (byte)(t[11] >>  9);
    14c0:	77bb      	strb	r3, [r7, #30]
    s[31] = (byte)(t[11] >> 17);
    14c2:	f887 a01f 	strb.w	sl, [r7, #31]
}
    14c6:	b035      	add	sp, #212	; 0xd4
    14c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    14cc:	ffe9fb68 	.word	0xffe9fb68
    14d0:	fff0c654 	.word	0xfff0c654
    14d4:	ffe215d1 	.word	0xffe215d1

Disassembly of section .text.ge_scalarmult_base:

00000000 <ge_scalarmult_base>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	b0f5      	sub	sp, #468	; 0x1d4
   4:	4604      	mov	r4, r0
  for (i = 0;i < 32;++i) {
   6:	4668      	mov	r0, sp
   8:	1e4e      	subs	r6, r1, #1
{
   a:	4603      	mov	r3, r0
   c:	311f      	adds	r1, #31
   e:	4605      	mov	r5, r0
    e[2 * i + 0] = (a[i] >> 0) & 15;
  10:	f816 2f01 	ldrb.w	r2, [r6, #1]!
  14:	f002 070f 	and.w	r7, r2, #15
  for (i = 0;i < 32;++i) {
  18:	42b1      	cmp	r1, r6
    e[2 * i + 1] = (a[i] >> 4) & 15;
  1a:	ea4f 1212 	mov.w	r2, r2, lsr #4
    e[2 * i + 0] = (a[i] >> 0) & 15;
  1e:	701f      	strb	r7, [r3, #0]
    e[2 * i + 1] = (a[i] >> 4) & 15;
  20:	705a      	strb	r2, [r3, #1]
  for (i = 0;i < 32;++i) {
  22:	f103 0302 	add.w	r3, r3, #2
  26:	d1f3      	bne.n	10 <ge_scalarmult_base+0x10>
  28:	213f      	movs	r1, #63	; 0x3f
  carry = 0;
  2a:	2200      	movs	r2, #0
    e[i] += carry;
  2c:	f990 3000 	ldrsb.w	r3, [r0]
  30:	4413      	add	r3, r2
  32:	b2db      	uxtb	r3, r3
    carry = e[i] + 8;
  34:	f103 0208 	add.w	r2, r3, #8
    carry >>= 4;
  38:	f342 1203 	sbfx	r2, r2, #4, #4
    e[i] -= (signed char)(carry << 4);
  3c:	eba3 1302 	sub.w	r3, r3, r2, lsl #4
  for (i = 0;i < 63;++i) {
  40:	3901      	subs	r1, #1
    e[i] -= (signed char)(carry << 4);
  42:	f800 3b01 	strb.w	r3, [r0], #1
  for (i = 0;i < 63;++i) {
  46:	d1f1      	bne.n	2c <ge_scalarmult_base+0x2c>
  e[63] += carry;
  48:	f895 303f 	ldrb.w	r3, [r5, #63]	; 0x3f
  4c:	4413      	add	r3, r2
  4e:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
  ge_select(&t,0,e[1]);
  52:	f995 2001 	ldrsb.w	r2, [r5, #1]
  56:	a82e      	add	r0, sp, #184	; 0xb8
  fe_add(h->Y, t.yplusx, t.yminusx);
  58:	f104 0628 	add.w	r6, r4, #40	; 0x28
  ge_select(&t,0,e[1]);
  5c:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  fe_sub(h->X, t.yplusx, t.yminusx);
  60:	aa38      	add	r2, sp, #224	; 0xe0
  62:	a92e      	add	r1, sp, #184	; 0xb8
  64:	4620      	mov	r0, r4
  66:	f7ff fffe 	bl	0 <fe_sub>
  fe_add(h->Y, t.yplusx, t.yminusx);
  6a:	aa38      	add	r2, sp, #224	; 0xe0
  6c:	a92e      	add	r1, sp, #184	; 0xb8
  6e:	4630      	mov	r0, r6
  70:	f7ff fffe 	bl	0 <fe_add>
  fe_0(h->Z);
  74:	f104 0050 	add.w	r0, r4, #80	; 0x50
  78:	f7ff fffe 	bl	0 <fe_0>
  h->Z[0] = 4;
  7c:	2304      	movs	r3, #4
  7e:	6523      	str	r3, [r4, #80]	; 0x50
  fe_mul(h->T,h->X,h->Y);
  80:	4632      	mov	r2, r6
  82:	4621      	mov	r1, r4
  84:	f104 0078 	add.w	r0, r4, #120	; 0x78
  88:	f7ff fffe 	bl	0 <fe_mul>
  fe_add(h->X, h->X, h->X);
  8c:	4622      	mov	r2, r4
  8e:	4621      	mov	r1, r4
  90:	4620      	mov	r0, r4
  92:	f7ff fffe 	bl	0 <fe_add>
  fe_add(h->Y, h->Y, h->Y);
  96:	4632      	mov	r2, r6
  98:	4631      	mov	r1, r6
  9a:	4630      	mov	r0, r6
  9c:	f7ff fffe 	bl	0 <fe_add>
  for (i = 3;i < 64;i += 2) {
  a0:	2603      	movs	r6, #3
    ge_select(&t,i / 2,e[i]);
  a2:	57aa      	ldrsb	r2, [r5, r6]
  a4:	1071      	asrs	r1, r6, #1
  a6:	a82e      	add	r0, sp, #184	; 0xb8
  a8:	f7ff fffe 	bl	0 <ge_scalarmult_base>
    ge_madd(&r,h,&t); ge_p1p1_to_p3(h,&r);
  ac:	aa2e      	add	r2, sp, #184	; 0xb8
  ae:	4621      	mov	r1, r4
  b0:	a84c      	add	r0, sp, #304	; 0x130
  b2:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  for (i = 3;i < 64;i += 2) {
  b6:	3602      	adds	r6, #2
    ge_madd(&r,h,&t); ge_p1p1_to_p3(h,&r);
  b8:	a94c      	add	r1, sp, #304	; 0x130
  ba:	4620      	mov	r0, r4
  bc:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  for (i = 3;i < 64;i += 2) {
  c0:	2e41      	cmp	r6, #65	; 0x41
  c2:	d1ee      	bne.n	a2 <ge_scalarmult_base+0xa2>
  ge_p3_dbl(&r,h);  ge_p1p1_to_p2(&s,&r);
  c4:	4621      	mov	r1, r4
  c6:	a84c      	add	r0, sp, #304	; 0x130
  c8:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  cc:	a94c      	add	r1, sp, #304	; 0x130
  ce:	a810      	add	r0, sp, #64	; 0x40
  d0:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  ge_p2_dbl(&r,&s); ge_p1p1_to_p2(&s,&r);
  d4:	a910      	add	r1, sp, #64	; 0x40
  d6:	a84c      	add	r0, sp, #304	; 0x130
  d8:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  dc:	a94c      	add	r1, sp, #304	; 0x130
  de:	a810      	add	r0, sp, #64	; 0x40
  e0:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  ge_p2_dbl(&r,&s); ge_p1p1_to_p2(&s,&r);
  e4:	a910      	add	r1, sp, #64	; 0x40
  e6:	a84c      	add	r0, sp, #304	; 0x130
  e8:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  ec:	a94c      	add	r1, sp, #304	; 0x130
  ee:	a810      	add	r0, sp, #64	; 0x40
  f0:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  ge_p2_dbl(&r,&s); ge_p1p1_to_p3(h,&r);
  f4:	a910      	add	r1, sp, #64	; 0x40
  f6:	a84c      	add	r0, sp, #304	; 0x130
  f8:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  fc:	a94c      	add	r1, sp, #304	; 0x130
  fe:	4620      	mov	r0, r4
 100:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  for (i = 0;i < 64;i += 2) {
 104:	2600      	movs	r6, #0
    ge_select(&t,i / 2,e[i]);
 106:	57aa      	ldrsb	r2, [r5, r6]
 108:	1071      	asrs	r1, r6, #1
 10a:	a82e      	add	r0, sp, #184	; 0xb8
 10c:	f7ff fffe 	bl	0 <ge_scalarmult_base>
    ge_madd(&r,h,&t); ge_p1p1_to_p3(h,&r);
 110:	aa2e      	add	r2, sp, #184	; 0xb8
 112:	4621      	mov	r1, r4
 114:	a84c      	add	r0, sp, #304	; 0x130
 116:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  for (i = 0;i < 64;i += 2) {
 11a:	3602      	adds	r6, #2
    ge_madd(&r,h,&t); ge_p1p1_to_p3(h,&r);
 11c:	a94c      	add	r1, sp, #304	; 0x130
 11e:	4620      	mov	r0, r4
 120:	f7ff fffe 	bl	0 <ge_scalarmult_base>
  for (i = 0;i < 64;i += 2) {
 124:	2e40      	cmp	r6, #64	; 0x40
 126:	d1ee      	bne.n	106 <ge_scalarmult_base+0x106>
}
 128:	b075      	add	sp, #468	; 0x1d4
 12a:	bdf0      	pop	{r4, r5, r6, r7, pc}

Disassembly of section .text.ge_double_scalarmult_vartime:

00000000 <ge_double_scalarmult_vartime>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b091      	sub	sp, #68	; 0x44
   6:	468b      	mov	fp, r1
   8:	9003      	str	r0, [sp, #12]
  if (((aslide = (signed char *)XMALLOC(SLIDE_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
   a:	f44f 7080 	mov.w	r0, #256	; 0x100
{
   e:	4691      	mov	r9, r2
  10:	469a      	mov	sl, r3
  if (((aslide = (signed char *)XMALLOC(SLIDE_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  12:	f7ff fffe 	bl	0 <malloc>
  16:	9001      	str	r0, [sp, #4]
  18:	2800      	cmp	r0, #0
  1a:	f000 81cd 	beq.w	3b8 <ge_double_scalarmult_vartime+0x3b8>
      ((bslide = (signed char *)XMALLOC(SLIDE_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  1e:	f44f 7080 	mov.w	r0, #256	; 0x100
  22:	f7ff fffe 	bl	0 <malloc>
  if (((aslide = (signed char *)XMALLOC(SLIDE_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  26:	4680      	mov	r8, r0
  28:	2800      	cmp	r0, #0
  2a:	f000 81cb 	beq.w	3c4 <ge_double_scalarmult_vartime+0x3c4>
      ((Ai = (ge_cached *)XMALLOC(8 * sizeof(*Ai), NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  2e:	f44f 60a0 	mov.w	r0, #1280	; 0x500
  32:	f7ff fffe 	bl	0 <malloc>
      ((bslide = (signed char *)XMALLOC(SLIDE_SIZE, NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  36:	4606      	mov	r6, r0
  38:	2800      	cmp	r0, #0
  3a:	f000 81ca 	beq.w	3d2 <ge_double_scalarmult_vartime+0x3d2>
      ((t = (ge_p1p1 *)XMALLOC(sizeof(*t), NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  3e:	20a0      	movs	r0, #160	; 0xa0
  40:	f7ff fffe 	bl	0 <malloc>
      ((Ai = (ge_cached *)XMALLOC(8 * sizeof(*Ai), NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  44:	4604      	mov	r4, r0
  46:	2800      	cmp	r0, #0
  48:	f000 81c7 	beq.w	3da <ge_double_scalarmult_vartime+0x3da>
      ((u = (ge_p3 *)XMALLOC(sizeof(*u), NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  4c:	20a0      	movs	r0, #160	; 0xa0
  4e:	f7ff fffe 	bl	0 <malloc>
      ((t = (ge_p1p1 *)XMALLOC(sizeof(*t), NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  52:	4605      	mov	r5, r0
  54:	2800      	cmp	r0, #0
  56:	f000 81c3 	beq.w	3e0 <ge_double_scalarmult_vartime+0x3e0>
      ((A2 = (ge_p3 *)XMALLOC(sizeof(*A2), NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL))
  5a:	20a0      	movs	r0, #160	; 0xa0
  5c:	f7ff fffe 	bl	0 <malloc>
      ((u = (ge_p3 *)XMALLOC(sizeof(*u), NULL, DYNAMIC_TYPE_TMP_BUFFER))== NULL) ||
  60:	4607      	mov	r7, r0
  62:	2800      	cmp	r0, #0
  64:	f000 81b2 	beq.w	3cc <ge_double_scalarmult_vartime+0x3cc>
  slide(aslide,a);
  68:	9801      	ldr	r0, [sp, #4]
  6a:	4659      	mov	r1, fp
  6c:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  slide(bslide,b);
  70:	4651      	mov	r1, sl
  72:	4640      	mov	r0, r8
  74:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_p3_to_cached(&Ai[0],A);
  78:	4649      	mov	r1, r9
  7a:	4630      	mov	r0, r6
  7c:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_p3_dbl(t,A); ge_p1p1_to_p3(A2,t);
  80:	4649      	mov	r1, r9
  82:	4620      	mov	r0, r4
  84:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  88:	4621      	mov	r1, r4
  8a:	4638      	mov	r0, r7
  8c:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_add(t,A2,&Ai[0]); ge_p1p1_to_p3(u,t); ge_p3_to_cached(&Ai[1],u);
  90:	4632      	mov	r2, r6
  92:	4639      	mov	r1, r7
  94:	4620      	mov	r0, r4
  96:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  9a:	f106 09a0 	add.w	r9, r6, #160	; 0xa0
  9e:	4621      	mov	r1, r4
  a0:	4628      	mov	r0, r5
  a2:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  a6:	4648      	mov	r0, r9
  a8:	4629      	mov	r1, r5
  aa:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_add(t,A2,&Ai[1]); ge_p1p1_to_p3(u,t); ge_p3_to_cached(&Ai[2],u);
  ae:	464a      	mov	r2, r9
  b0:	4639      	mov	r1, r7
  b2:	4620      	mov	r0, r4
  b4:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  b8:	f506 79a0 	add.w	r9, r6, #320	; 0x140
  bc:	4621      	mov	r1, r4
  be:	4628      	mov	r0, r5
  c0:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  c4:	4648      	mov	r0, r9
  c6:	4629      	mov	r1, r5
  c8:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_add(t,A2,&Ai[2]); ge_p1p1_to_p3(u,t); ge_p3_to_cached(&Ai[3],u);
  cc:	464a      	mov	r2, r9
  ce:	4639      	mov	r1, r7
  d0:	4620      	mov	r0, r4
  d2:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  d6:	f506 79f0 	add.w	r9, r6, #480	; 0x1e0
  da:	4621      	mov	r1, r4
  dc:	4628      	mov	r0, r5
  de:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  e2:	4648      	mov	r0, r9
  e4:	4629      	mov	r1, r5
  e6:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_add(t,A2,&Ai[3]); ge_p1p1_to_p3(u,t); ge_p3_to_cached(&Ai[4],u);
  ea:	464a      	mov	r2, r9
  ec:	4639      	mov	r1, r7
  ee:	4620      	mov	r0, r4
  f0:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  f4:	f506 7920 	add.w	r9, r6, #640	; 0x280
  f8:	4621      	mov	r1, r4
  fa:	4628      	mov	r0, r5
  fc:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
 100:	4648      	mov	r0, r9
 102:	4629      	mov	r1, r5
 104:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_add(t,A2,&Ai[4]); ge_p1p1_to_p3(u,t); ge_p3_to_cached(&Ai[5],u);
 108:	464a      	mov	r2, r9
 10a:	4639      	mov	r1, r7
 10c:	4620      	mov	r0, r4
 10e:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
 112:	f506 7948 	add.w	r9, r6, #800	; 0x320
 116:	4621      	mov	r1, r4
 118:	4628      	mov	r0, r5
 11a:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
 11e:	4648      	mov	r0, r9
 120:	4629      	mov	r1, r5
 122:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_add(t,A2,&Ai[5]); ge_p1p1_to_p3(u,t); ge_p3_to_cached(&Ai[6],u);
 126:	464a      	mov	r2, r9
 128:	4639      	mov	r1, r7
 12a:	4620      	mov	r0, r4
 12c:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
 130:	f506 7970 	add.w	r9, r6, #960	; 0x3c0
 134:	4621      	mov	r1, r4
 136:	4628      	mov	r0, r5
 138:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
 13c:	4629      	mov	r1, r5
 13e:	4648      	mov	r0, r9
 140:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  ge_add(t,A2,&Ai[6]); ge_p1p1_to_p3(u,t); ge_p3_to_cached(&Ai[7],u);
 144:	464a      	mov	r2, r9
 146:	4639      	mov	r1, r7
 148:	4620      	mov	r0, r4
 14a:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
 14e:	4621      	mov	r1, r4
 150:	4628      	mov	r0, r5
 152:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
 156:	4629      	mov	r1, r5
 158:	f506 608c 	add.w	r0, r6, #1120	; 0x460
 15c:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  fe_0(h->X);
 160:	9803      	ldr	r0, [sp, #12]
 162:	f7ff fffe 	bl	0 <fe_0>
  fe_1(h->Y);
 166:	9b03      	ldr	r3, [sp, #12]
 168:	f103 0028 	add.w	r0, r3, #40	; 0x28
 16c:	f7ff fffe 	bl	0 <fe_1>
  fe_1(h->Z);
 170:	9b03      	ldr	r3, [sp, #12]
 172:	f103 0050 	add.w	r0, r3, #80	; 0x50
 176:	f7ff fffe 	bl	0 <fe_1>
  for (i = 255;i >= 0;--i) {
 17a:	22ff      	movs	r2, #255	; 0xff
    if (aslide[i] || bslide[i]) break;
 17c:	9b01      	ldr	r3, [sp, #4]
 17e:	569b      	ldrsb	r3, [r3, r2]
 180:	b91b      	cbnz	r3, 18a <ge_double_scalarmult_vartime+0x18a>
 182:	f918 3002 	ldrsb.w	r3, [r8, r2]
 186:	2b00      	cmp	r3, #0
 188:	d04b      	beq.n	222 <ge_double_scalarmult_vartime+0x222>
 18a:	eb08 0302 	add.w	r3, r8, r2
 18e:	9300      	str	r3, [sp, #0]
 190:	9b01      	ldr	r3, [sp, #4]
 192:	4413      	add	r3, r2
 194:	9302      	str	r3, [sp, #8]

#ifndef CURVED25519_ASM
static WC_INLINE void ge_sub(ge_p1p1 *r,const ge_p3 *p,const ge_cached *q)
{
    ge t0;
    fe_add(r->X,p->Y,p->X);
 196:	f105 0328 	add.w	r3, r5, #40	; 0x28
 19a:	9304      	str	r3, [sp, #16]
  for (;i >= 0;--i) {
 19c:	9b00      	ldr	r3, [sp, #0]
 19e:	eba3 0308 	sub.w	r3, r3, r8
 1a2:	2b00      	cmp	r3, #0
 1a4:	db3f      	blt.n	226 <ge_double_scalarmult_vartime+0x226>
    ge_p2_dbl(t,r);
 1a6:	9903      	ldr	r1, [sp, #12]
 1a8:	4620      	mov	r0, r4
 1aa:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
    if (aslide[i] > 0) {
 1ae:	9b02      	ldr	r3, [sp, #8]
 1b0:	f993 3000 	ldrsb.w	r3, [r3]
 1b4:	2b00      	cmp	r3, #0
 1b6:	dd54      	ble.n	262 <ge_double_scalarmult_vartime+0x262>
      ge_p1p1_to_p3(u,t);
 1b8:	4621      	mov	r1, r4
 1ba:	4628      	mov	r0, r5
 1bc:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
      ge_add(t,u,&Ai[aslide[i]/2]);
 1c0:	9b02      	ldr	r3, [sp, #8]
 1c2:	f993 2000 	ldrsb.w	r2, [r3]
 1c6:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 1ca:	1052      	asrs	r2, r2, #1
 1cc:	23a0      	movs	r3, #160	; 0xa0
 1ce:	fb03 6202 	mla	r2, r3, r2, r6
 1d2:	4629      	mov	r1, r5
 1d4:	4620      	mov	r0, r4
 1d6:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
    if (bslide[i] > 0) {
 1da:	9b00      	ldr	r3, [sp, #0]
 1dc:	f993 3000 	ldrsb.w	r3, [r3]
 1e0:	2b00      	cmp	r3, #0
 1e2:	f340 8093 	ble.w	30c <ge_double_scalarmult_vartime+0x30c>
      ge_p1p1_to_p3(u,t);
 1e6:	4621      	mov	r1, r4
 1e8:	4628      	mov	r0, r5
 1ea:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
      ge_madd(t,u,&Bi[bslide[i]/2]);
 1ee:	9b00      	ldr	r3, [sp, #0]
 1f0:	f993 2000 	ldrsb.w	r2, [r3]
 1f4:	4b7b      	ldr	r3, [pc, #492]	; (3e4 <ge_double_scalarmult_vartime+0x3e4>)
 1f6:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 1fa:	1052      	asrs	r2, r2, #1
 1fc:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
 200:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 204:	4629      	mov	r1, r5
 206:	4620      	mov	r0, r4
 208:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
    ge_p1p1_to_p2(r,t);
 20c:	9803      	ldr	r0, [sp, #12]
 20e:	4621      	mov	r1, r4
 210:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
  for (;i >= 0;--i) {
 214:	9b00      	ldr	r3, [sp, #0]
 216:	3b01      	subs	r3, #1
 218:	9300      	str	r3, [sp, #0]
 21a:	9b02      	ldr	r3, [sp, #8]
 21c:	3b01      	subs	r3, #1
 21e:	9302      	str	r3, [sp, #8]
 220:	e7bc      	b.n	19c <ge_double_scalarmult_vartime+0x19c>
  for (i = 255;i >= 0;--i) {
 222:	3a01      	subs	r2, #1
 224:	d2aa      	bcs.n	17c <ge_double_scalarmult_vartime+0x17c>
      ret = 0;
 226:	f04f 0900 	mov.w	r9, #0
      XFREE(aslide, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 22a:	9801      	ldr	r0, [sp, #4]
 22c:	f7ff fffe 	bl	0 <free>
  if (bslide != NULL)
 230:	f1b8 0f00 	cmp.w	r8, #0
 234:	d002      	beq.n	23c <ge_double_scalarmult_vartime+0x23c>
      XFREE(bslide, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 236:	4640      	mov	r0, r8
 238:	f7ff fffe 	bl	0 <free>
  if (Ai != NULL)
 23c:	b116      	cbz	r6, 244 <ge_double_scalarmult_vartime+0x244>
      XFREE(Ai, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 23e:	4630      	mov	r0, r6
 240:	f7ff fffe 	bl	0 <free>
  if (t != NULL)
 244:	b114      	cbz	r4, 24c <ge_double_scalarmult_vartime+0x24c>
      XFREE(t, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 246:	4620      	mov	r0, r4
 248:	f7ff fffe 	bl	0 <free>
  if (u != NULL)
 24c:	b115      	cbz	r5, 254 <ge_double_scalarmult_vartime+0x254>
      XFREE(u, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 24e:	4628      	mov	r0, r5
 250:	f7ff fffe 	bl	0 <free>
  if (A2 != NULL)
 254:	2f00      	cmp	r7, #0
 256:	f000 80b1 	beq.w	3bc <ge_double_scalarmult_vartime+0x3bc>
      XFREE(A2, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 25a:	4638      	mov	r0, r7
 25c:	f7ff fffe 	bl	0 <free>
  return ret;
 260:	e0ac      	b.n	3bc <ge_double_scalarmult_vartime+0x3bc>
    } else if (aslide[i] < 0) {
 262:	d0ba      	beq.n	1da <ge_double_scalarmult_vartime+0x1da>
      ge_p1p1_to_p3(u,t);
 264:	4621      	mov	r1, r4
 266:	4628      	mov	r0, r5
 268:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
      ge_sub(t,u,&Ai[(-aslide[i])/2]);
 26c:	9b02      	ldr	r3, [sp, #8]
    fe_add(r->X,p->Y,p->X);
 26e:	9904      	ldr	r1, [sp, #16]
      ge_sub(t,u,&Ai[(-aslide[i])/2]);
 270:	f993 9000 	ldrsb.w	r9, [r3]
 274:	eb09 79d9 	add.w	r9, r9, r9, lsr #31
    fe_sub(r->Y,p->Y,p->X);
 278:	f104 0a28 	add.w	sl, r4, #40	; 0x28
      ge_sub(t,u,&Ai[(-aslide[i])/2]);
 27c:	23a0      	movs	r3, #160	; 0xa0
    fe_add(r->X,p->Y,p->X);
 27e:	462a      	mov	r2, r5
 280:	4620      	mov	r0, r4
      ge_sub(t,u,&Ai[(-aslide[i])/2]);
 282:	ea4f 0969 	mov.w	r9, r9, asr #1
 286:	fb09 6913 	mls	r9, r9, r3, r6
    fe_mul(r->Z,r->X,q->YminusX);
 28a:	f104 0b50 	add.w	fp, r4, #80	; 0x50
    fe_add(r->X,p->Y,p->X);
 28e:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->Y,p->Y,p->X);
 292:	9904      	ldr	r1, [sp, #16]
 294:	462a      	mov	r2, r5
 296:	4650      	mov	r0, sl
 298:	f7ff fffe 	bl	0 <fe_sub>
    fe_mul(r->Z,r->X,q->YminusX);
 29c:	f109 0228 	add.w	r2, r9, #40	; 0x28
 2a0:	4621      	mov	r1, r4
 2a2:	4658      	mov	r0, fp
 2a4:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->Y,r->Y,q->YplusX);
 2a8:	464a      	mov	r2, r9
 2aa:	4651      	mov	r1, sl
 2ac:	4650      	mov	r0, sl
 2ae:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->T,q->T2d,p->T);
 2b2:	f104 0378 	add.w	r3, r4, #120	; 0x78
 2b6:	4618      	mov	r0, r3
 2b8:	f105 0278 	add.w	r2, r5, #120	; 0x78
 2bc:	f109 0178 	add.w	r1, r9, #120	; 0x78
 2c0:	9305      	str	r3, [sp, #20]
 2c2:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->X,p->Z,q->Z);
 2c6:	f109 0250 	add.w	r2, r9, #80	; 0x50
 2ca:	f105 0150 	add.w	r1, r5, #80	; 0x50
 2ce:	4620      	mov	r0, r4
 2d0:	f7ff fffe 	bl	0 <fe_mul>
    fe_add(t0,r->X,r->X);
 2d4:	4622      	mov	r2, r4
 2d6:	4621      	mov	r1, r4
 2d8:	a806      	add	r0, sp, #24
 2da:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->X,r->Z,r->Y);
 2de:	4652      	mov	r2, sl
 2e0:	4659      	mov	r1, fp
 2e2:	4620      	mov	r0, r4
 2e4:	f7ff fffe 	bl	0 <fe_sub>
    fe_add(r->Y,r->Z,r->Y);
 2e8:	4652      	mov	r2, sl
 2ea:	4659      	mov	r1, fp
 2ec:	4650      	mov	r0, sl
 2ee:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->Z,t0,r->T);
 2f2:	9b05      	ldr	r3, [sp, #20]
 2f4:	a906      	add	r1, sp, #24
 2f6:	461a      	mov	r2, r3
 2f8:	4658      	mov	r0, fp
 2fa:	f7ff fffe 	bl	0 <fe_sub>
    fe_add(r->T,t0,r->T);
 2fe:	9b05      	ldr	r3, [sp, #20]
 300:	a906      	add	r1, sp, #24
 302:	461a      	mov	r2, r3
 304:	4618      	mov	r0, r3
 306:	f7ff fffe 	bl	0 <fe_add>
}
 30a:	e766      	b.n	1da <ge_double_scalarmult_vartime+0x1da>
    } else if (bslide[i] < 0) {
 30c:	f43f af7e 	beq.w	20c <ge_double_scalarmult_vartime+0x20c>
      ge_p1p1_to_p3(u,t);
 310:	4621      	mov	r1, r4
 312:	4628      	mov	r0, r5
 314:	f7ff fffe 	bl	0 <ge_double_scalarmult_vartime>
      ge_msub(t,u,&Bi[(-bslide[i])/2]);
 318:	9b00      	ldr	r3, [sp, #0]
    fe_add(r->X,p->Y,p->X);
 31a:	9904      	ldr	r1, [sp, #16]
      ge_msub(t,u,&Bi[(-bslide[i])/2]);
 31c:	f993 9000 	ldrsb.w	r9, [r3]
    fe_sub(r->Y,p->Y,p->X);
 320:	f104 0a28 	add.w	sl, r4, #40	; 0x28
    fe_add(r->X,p->Y,p->X);
 324:	462a      	mov	r2, r5
 326:	4620      	mov	r0, r4
      ge_msub(t,u,&Bi[(-bslide[i])/2]);
 328:	eb09 79d9 	add.w	r9, r9, r9, lsr #31
    fe_add(r->X,p->Y,p->X);
 32c:	f7ff fffe 	bl	0 <fe_add>
      ge_msub(t,u,&Bi[(-bslide[i])/2]);
 330:	ea4f 0969 	mov.w	r9, r9, asr #1
    fe_sub(r->Y,p->Y,p->X);
 334:	9904      	ldr	r1, [sp, #16]
 336:	462a      	mov	r2, r5
 338:	4650      	mov	r0, sl
 33a:	f7ff fffe 	bl	0 <fe_sub>
      ge_msub(t,u,&Bi[(-bslide[i])/2]);
 33e:	f1c9 0900 	rsb	r9, r9, #0
    fe_mul(r->Z,r->X,q->yminusx);
 342:	2178      	movs	r1, #120	; 0x78
 344:	fb01 f909 	mul.w	r9, r1, r9
 348:	4b26      	ldr	r3, [pc, #152]	; (3e4 <ge_double_scalarmult_vartime+0x3e4>)
 34a:	f104 0b50 	add.w	fp, r4, #80	; 0x50
 34e:	f109 0228 	add.w	r2, r9, #40	; 0x28
 352:	441a      	add	r2, r3
 354:	4621      	mov	r1, r4
 356:	4658      	mov	r0, fp
 358:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->Y,r->Y,q->yplusx);
 35c:	4b21      	ldr	r3, [pc, #132]	; (3e4 <ge_double_scalarmult_vartime+0x3e4>)
 35e:	4651      	mov	r1, sl
 360:	eb03 0209 	add.w	r2, r3, r9
 364:	4650      	mov	r0, sl
 366:	f7ff fffe 	bl	0 <fe_mul>
    fe_mul(r->T,q->xy2d,p->T);
 36a:	481e      	ldr	r0, [pc, #120]	; (3e4 <ge_double_scalarmult_vartime+0x3e4>)
 36c:	f104 0378 	add.w	r3, r4, #120	; 0x78
 370:	f109 0150 	add.w	r1, r9, #80	; 0x50
 374:	f105 0278 	add.w	r2, r5, #120	; 0x78
 378:	4401      	add	r1, r0
 37a:	4618      	mov	r0, r3
 37c:	4699      	mov	r9, r3
 37e:	f7ff fffe 	bl	0 <fe_mul>
    fe_add(t0,p->Z,p->Z);
 382:	f105 0250 	add.w	r2, r5, #80	; 0x50
 386:	4611      	mov	r1, r2
 388:	a806      	add	r0, sp, #24
 38a:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->X,r->Z,r->Y);
 38e:	4652      	mov	r2, sl
 390:	4659      	mov	r1, fp
 392:	4620      	mov	r0, r4
 394:	f7ff fffe 	bl	0 <fe_sub>
    fe_add(r->Y,r->Z,r->Y);
 398:	4652      	mov	r2, sl
 39a:	4659      	mov	r1, fp
 39c:	4650      	mov	r0, sl
 39e:	f7ff fffe 	bl	0 <fe_add>
    fe_sub(r->Z,t0,r->T);
 3a2:	464a      	mov	r2, r9
 3a4:	a906      	add	r1, sp, #24
 3a6:	4658      	mov	r0, fp
 3a8:	f7ff fffe 	bl	0 <fe_sub>
    fe_add(r->T,t0,r->T);
 3ac:	464a      	mov	r2, r9
 3ae:	a906      	add	r1, sp, #24
 3b0:	4648      	mov	r0, r9
 3b2:	f7ff fffe 	bl	0 <fe_add>
}
 3b6:	e729      	b.n	20c <ge_double_scalarmult_vartime+0x20c>
      ret = MEMORY_E;
 3b8:	f06f 097c 	mvn.w	r9, #124	; 0x7c
}
 3bc:	4648      	mov	r0, r9
 3be:	b011      	add	sp, #68	; 0x44
 3c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  ge_p3 *A2 = NULL;
 3c4:	4607      	mov	r7, r0
  ge_p3 *u = NULL;
 3c6:	4605      	mov	r5, r0
  ge_p1p1 *t = NULL;
 3c8:	4604      	mov	r4, r0
  ge_cached *Ai = NULL; /* A,3A,5A,7A,9A,11A,13A,15A */
 3ca:	4606      	mov	r6, r0
      ret = MEMORY_E;
 3cc:	f06f 097c 	mvn.w	r9, #124	; 0x7c
 3d0:	e72b      	b.n	22a <ge_double_scalarmult_vartime+0x22a>
  ge_p3 *A2 = NULL;
 3d2:	4607      	mov	r7, r0
  ge_p3 *u = NULL;
 3d4:	4605      	mov	r5, r0
  ge_p1p1 *t = NULL;
 3d6:	4604      	mov	r4, r0
 3d8:	e7f8      	b.n	3cc <ge_double_scalarmult_vartime+0x3cc>
  ge_p3 *A2 = NULL;
 3da:	4607      	mov	r7, r0
  ge_p3 *u = NULL;
 3dc:	4605      	mov	r5, r0
 3de:	e7f5      	b.n	3cc <ge_double_scalarmult_vartime+0x3cc>
  ge_p3 *A2 = NULL;
 3e0:	4607      	mov	r7, r0
 3e2:	e7f3      	b.n	3cc <ge_double_scalarmult_vartime+0x3cc>
 3e4:	00000000 	.word	0x00000000

Disassembly of section .text.ge_frombytes_negate_vartime:

00000000 <ge_frombytes_negate_vartime>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   2:	4604      	mov	r4, r0
  fe_frombytes(h->Y,s);
   4:	f100 0528 	add.w	r5, r0, #40	; 0x28
{
   8:	b0b3      	sub	sp, #204	; 0xcc
  fe_1(h->Z);
   a:	f104 0750 	add.w	r7, r4, #80	; 0x50
  fe_frombytes(h->Y,s);
   e:	4628      	mov	r0, r5
{
  10:	460e      	mov	r6, r1
  fe_frombytes(h->Y,s);
  12:	f7ff fffe 	bl	0 <fe_frombytes>
  fe_1(h->Z);
  16:	4638      	mov	r0, r7
  18:	f7ff fffe 	bl	0 <fe_1>
  fe_sq(u,h->Y);
  1c:	4629      	mov	r1, r5
  1e:	4668      	mov	r0, sp
  20:	f7ff fffe 	bl	0 <fe_sq>
  fe_mul(v,u,d);
  24:	4a35      	ldr	r2, [pc, #212]	; (fc <ge_frombytes_negate_vartime+0xfc>)
  26:	4669      	mov	r1, sp
  28:	a80a      	add	r0, sp, #40	; 0x28
  2a:	f7ff fffe 	bl	0 <fe_mul>
  fe_sub(u,u,h->Z);       /* u = y^2-1 */
  2e:	463a      	mov	r2, r7
  30:	4669      	mov	r1, sp
  32:	4668      	mov	r0, sp
  34:	f7ff fffe 	bl	0 <fe_sub>
  fe_add(v,v,h->Z);       /* v = dy^2+1 */
  38:	a90a      	add	r1, sp, #40	; 0x28
  3a:	463a      	mov	r2, r7
  3c:	4608      	mov	r0, r1
  3e:	f7ff fffe 	bl	0 <fe_add>
  fe_sq(v3,v);
  42:	a90a      	add	r1, sp, #40	; 0x28
  44:	a814      	add	r0, sp, #80	; 0x50
  46:	f7ff fffe 	bl	0 <fe_sq>
  fe_mul(v3,v3,v);        /* v3 = v^3 */
  4a:	a914      	add	r1, sp, #80	; 0x50
  4c:	aa0a      	add	r2, sp, #40	; 0x28
  4e:	4608      	mov	r0, r1
  50:	f7ff fffe 	bl	0 <fe_mul>
  fe_sq(h->X,v3);
  54:	a914      	add	r1, sp, #80	; 0x50
  56:	4620      	mov	r0, r4
  58:	f7ff fffe 	bl	0 <fe_sq>
  fe_mul(h->X,h->X,v);
  5c:	aa0a      	add	r2, sp, #40	; 0x28
  5e:	4621      	mov	r1, r4
  60:	4620      	mov	r0, r4
  62:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(h->X,h->X,u);    /* x = uv^7 */
  66:	466a      	mov	r2, sp
  68:	4621      	mov	r1, r4
  6a:	4620      	mov	r0, r4
  6c:	f7ff fffe 	bl	0 <fe_mul>
  fe_pow22523(h->X,h->X); /* x = (uv^7)^((q-5)/8) */
  70:	4621      	mov	r1, r4
  72:	4620      	mov	r0, r4
  74:	f7ff fffe 	bl	0 <fe_pow22523>
  fe_mul(h->X,h->X,v3);
  78:	aa14      	add	r2, sp, #80	; 0x50
  7a:	4621      	mov	r1, r4
  7c:	4620      	mov	r0, r4
  7e:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(h->X,h->X,u);    /* x = uv^3(uv^7)^((q-5)/8) */
  82:	466a      	mov	r2, sp
  84:	4621      	mov	r1, r4
  86:	4620      	mov	r0, r4
  88:	f7ff fffe 	bl	0 <fe_mul>
  fe_sq(vxx,h->X);
  8c:	4621      	mov	r1, r4
  8e:	a81e      	add	r0, sp, #120	; 0x78
  90:	f7ff fffe 	bl	0 <fe_sq>
  fe_mul(vxx,vxx,v);
  94:	a91e      	add	r1, sp, #120	; 0x78
  96:	4608      	mov	r0, r1
  98:	aa0a      	add	r2, sp, #40	; 0x28
  9a:	f7ff fffe 	bl	0 <fe_mul>
  fe_sub(check,vxx,u);    /* vx^2-u */
  9e:	a828      	add	r0, sp, #160	; 0xa0
  a0:	466a      	mov	r2, sp
  a2:	a91e      	add	r1, sp, #120	; 0x78
  a4:	f7ff fffe 	bl	0 <fe_sub>
  if (fe_isnonzero(check)) {
  a8:	a828      	add	r0, sp, #160	; 0xa0
  aa:	f7ff fffe 	bl	0 <fe_isnonzero>
  ae:	b168      	cbz	r0, cc <ge_frombytes_negate_vartime+0xcc>
    fe_add(check,vxx,u);  /* vx^2+u */
  b0:	a828      	add	r0, sp, #160	; 0xa0
  b2:	466a      	mov	r2, sp
  b4:	a91e      	add	r1, sp, #120	; 0x78
  b6:	f7ff fffe 	bl	0 <fe_add>
    if (fe_isnonzero(check)) return -1;
  ba:	a828      	add	r0, sp, #160	; 0xa0
  bc:	f7ff fffe 	bl	0 <fe_isnonzero>
  c0:	b9c0      	cbnz	r0, f4 <ge_frombytes_negate_vartime+0xf4>
    fe_mul(h->X,h->X,sqrtm1);
  c2:	4a0f      	ldr	r2, [pc, #60]	; (100 <ge_frombytes_negate_vartime+0x100>)
  c4:	4621      	mov	r1, r4
  c6:	4620      	mov	r0, r4
  c8:	f7ff fffe 	bl	0 <fe_mul>
  if (fe_isnegative(h->X) == (s[31] >> 7))
  cc:	4620      	mov	r0, r4
  ce:	f7ff fffe 	bl	0 <fe_isnegative>
  d2:	7ff3      	ldrb	r3, [r6, #31]
  d4:	ebb0 1fd3 	cmp.w	r0, r3, lsr #7
  d8:	d103      	bne.n	e2 <ge_frombytes_negate_vartime+0xe2>
    fe_neg(h->X,h->X);
  da:	4621      	mov	r1, r4
  dc:	4620      	mov	r0, r4
  de:	f7ff fffe 	bl	0 <fe_neg>
  fe_mul(h->T,h->X,h->Y);
  e2:	f104 0078 	add.w	r0, r4, #120	; 0x78
  e6:	462a      	mov	r2, r5
  e8:	4621      	mov	r1, r4
  ea:	f7ff fffe 	bl	0 <fe_mul>
  return 0;
  ee:	2000      	movs	r0, #0
}
  f0:	b033      	add	sp, #204	; 0xcc
  f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (fe_isnonzero(check)) return -1;
  f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  f8:	e7fa      	b.n	f0 <ge_frombytes_negate_vartime+0xf0>
  fa:	bf00      	nop
	...

Disassembly of section .text.ge_tobytes:

00000000 <ge_tobytes>:
#endif

/* ge tobytes */
void ge_tobytes(unsigned char *s,const ge_p2 *h)
{
   0:	b530      	push	{r4, r5, lr}
   2:	b09f      	sub	sp, #124	; 0x7c
   4:	4604      	mov	r4, r0
   6:	460d      	mov	r5, r1
  ge recip;
  ge x;
  ge y;

  fe_invert(recip,h->Z);
   8:	4668      	mov	r0, sp
   a:	3150      	adds	r1, #80	; 0x50
   c:	f7ff fffe 	bl	0 <fe_invert>
  fe_mul(x,h->X,recip);
  10:	466a      	mov	r2, sp
  12:	4629      	mov	r1, r5
  14:	a80a      	add	r0, sp, #40	; 0x28
  16:	f7ff fffe 	bl	0 <fe_mul>
  fe_mul(y,h->Y,recip);
  1a:	466a      	mov	r2, sp
  1c:	f105 0128 	add.w	r1, r5, #40	; 0x28
  20:	a814      	add	r0, sp, #80	; 0x50
  22:	f7ff fffe 	bl	0 <fe_mul>
  fe_tobytes(s,y);
  26:	a914      	add	r1, sp, #80	; 0x50
  28:	4620      	mov	r0, r4
  2a:	f7ff fffe 	bl	0 <fe_tobytes>
  s[31] ^= (unsigned char)(fe_isnegative(x) << 7);
  2e:	a80a      	add	r0, sp, #40	; 0x28
  30:	f7ff fffe 	bl	0 <fe_isnegative>
  34:	7fe3      	ldrb	r3, [r4, #31]
  36:	ea83 13c0 	eor.w	r3, r3, r0, lsl #7
  3a:	77e3      	strb	r3, [r4, #31]
}
  3c:	b01f      	add	sp, #124	; 0x7c
  3e:	bd30      	pop	{r4, r5, pc}

Disassembly of section .text.ge_compress_key:

00000000 <ge_compress_key>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4616      	mov	r6, r2
   4:	b0b6      	sub	sp, #216	; 0xd8
    XMEMCPY(x, xIn, ED25519_PUB_KEY_SIZE);
   6:	2220      	movs	r2, #32
{
   8:	4605      	mov	r5, r0
    XMEMCPY(x, xIn, ED25519_PUB_KEY_SIZE);
   a:	eb0d 0002 	add.w	r0, sp, r2
{
   e:	461c      	mov	r4, r3
    XMEMCPY(x, xIn, ED25519_PUB_KEY_SIZE);
  10:	f7ff fffe 	bl	0 <memcpy>
    XMEMCPY(y, yIn, ED25519_PUB_KEY_SIZE);
  14:	2220      	movs	r2, #32
  16:	4631      	mov	r1, r6
  18:	a810      	add	r0, sp, #64	; 0x40
  1a:	f7ff fffe 	bl	0 <memcpy>
    fe_frombytes(g.X, x);
  1e:	a908      	add	r1, sp, #32
  20:	a818      	add	r0, sp, #96	; 0x60
  22:	f7ff fffe 	bl	0 <fe_frombytes>
    fe_frombytes(g.Y, y);
  26:	a910      	add	r1, sp, #64	; 0x40
  28:	a822      	add	r0, sp, #136	; 0x88
  2a:	f7ff fffe 	bl	0 <fe_frombytes>
    fe_1(g.Z);
  2e:	a82c      	add	r0, sp, #176	; 0xb0
  30:	f7ff fffe 	bl	0 <fe_1>
    ge_tobytes(bArray, &g);
  34:	a918      	add	r1, sp, #96	; 0x60
  36:	4668      	mov	r0, sp
  38:	f7ff fffe 	bl	0 <ge_compress_key>
    for (i = 0; i < keySz; i++) {
  3c:	466a      	mov	r2, sp
  3e:	192b      	adds	r3, r5, r4
  40:	42ab      	cmp	r3, r5
  42:	d102      	bne.n	4a <ge_compress_key+0x4a>
}
  44:	2000      	movs	r0, #0
  46:	b036      	add	sp, #216	; 0xd8
  48:	bd70      	pop	{r4, r5, r6, pc}
        out[keySz - 1 - i] = bArray[i];
  4a:	f812 1b01 	ldrb.w	r1, [r2], #1
  4e:	f803 1d01 	strb.w	r1, [r3, #-1]!
    for (i = 0; i < keySz; i++) {
  52:	e7f5      	b.n	40 <ge_compress_key+0x40>

hash.o:     file format elf32-littlearm


Disassembly of section .text.wc_HashTypeConvert:

00000000 <wc_HashTypeConvert>:
            eHashType = WC_HASH_TYPE_NONE;
            break;
    }
#else
    /* current master uses same unique types as wc_HashType */
    if (hashType > 0 && hashType <= WC_HASH_TYPE_MAX) {
   0:	1e43      	subs	r3, r0, #1
   2:	2b11      	cmp	r3, #17
   4:	bf28      	it	cs
   6:	2000      	movcs	r0, #0
        eHashType = (enum wc_HashType)hashType;
    }
#endif
    return eHashType;
}
   8:	b2c0      	uxtb	r0, r0
   a:	4770      	bx	lr

Disassembly of section .text.wc_HashGetOID:

00000000 <wc_HashGetOID>:
#if !defined(NO_ASN) || !defined(NO_DH) || defined(HAVE_ECC)

int wc_HashGetOID(enum wc_HashType hash_type)
{
    int oid = HASH_TYPE_E; /* Default to hash type error */
    switch(hash_type)
   0:	3801      	subs	r0, #1
   2:	b2c0      	uxtb	r0, r0
   4:	2810      	cmp	r0, #16
   6:	bf9a      	itte	ls
   8:	4b02      	ldrls	r3, [pc, #8]	; (14 <wc_HashGetOID+0x14>)
   a:	f933 0010 	ldrshls.w	r0, [r3, r0, lsl #1]
{
   e:	f06f 00ac 	mvnhi.w	r0, #172	; 0xac
        default:
            oid = BAD_FUNC_ARG;
            break;
    }
    return oid;
}
  12:	4770      	bx	lr
  14:	00000000 	.word	0x00000000

Disassembly of section .text.wc_OidGetHash:

00000000 <wc_OidGetHash>:

enum wc_HashType wc_OidGetHash(int oid)
{
    enum wc_HashType hash_type = WC_HASH_TYPE_NONE;
    switch (oid)
   0:	f5b0 7fcf 	cmp.w	r0, #414	; 0x19e
   4:	d007      	beq.n	16 <wc_OidGetHash+0x16>
   6:	f5b0 7fd0 	cmp.w	r0, #416	; 0x1a0
   a:	d006      	beq.n	1a <wc_OidGetHash+0x1a>
   c:	2858      	cmp	r0, #88	; 0x58
   e:	bf14      	ite	ne
  10:	2000      	movne	r0, #0
  12:	2004      	moveq	r0, #4
  14:	4770      	bx	lr
            hash_type = WC_HASH_TYPE_SHA224;
        #endif
            break;
        case SHA256h:
        #ifndef NO_SHA256
            hash_type = WC_HASH_TYPE_SHA256;
  16:	2006      	movs	r0, #6
  18:	4770      	bx	lr
            hash_type = WC_HASH_TYPE_SHA384;
        #endif
            break;
        case SHA512h:
        #ifdef WOLFSSL_SHA512
            hash_type = WC_HASH_TYPE_SHA512;
  1a:	2008      	movs	r0, #8
    #endif
        default:
            break;
    }
    return hash_type;
}
  1c:	4770      	bx	lr

Disassembly of section .text.wc_HashGetDigestSize:

00000000 <wc_HashGetDigestSize>:

/* Get Hash digest size */
int wc_HashGetDigestSize(enum wc_HashType hash_type)
{
    int dig_size = HASH_TYPE_E; /* Default to hash type error */
    switch(hash_type)
   0:	3801      	subs	r0, #1
   2:	b2c0      	uxtb	r0, r0
   4:	2810      	cmp	r0, #16
   6:	bf9a      	itte	ls
   8:	4b02      	ldrls	r3, [pc, #8]	; (14 <wc_HashGetDigestSize+0x14>)
   a:	f933 0010 	ldrshls.w	r0, [r3, r0, lsl #1]
{
   e:	f06f 00ac 	mvnhi.w	r0, #172	; 0xac
        default:
            dig_size = BAD_FUNC_ARG;
            break;
    }
    return dig_size;
}
  12:	4770      	bx	lr
  14:	00000000 	.word	0x00000000

Disassembly of section .text.wc_HashGetBlockSize:

00000000 <wc_HashGetBlockSize>:

/* Get Hash block size */
int wc_HashGetBlockSize(enum wc_HashType hash_type)
{
    int block_size = HASH_TYPE_E; /* Default to hash type error */
    switch (hash_type)
   0:	3801      	subs	r0, #1
   2:	b2c0      	uxtb	r0, r0
   4:	2810      	cmp	r0, #16
   6:	bf9a      	itte	ls
   8:	4b02      	ldrls	r3, [pc, #8]	; (14 <wc_HashGetBlockSize+0x14>)
   a:	f933 0010 	ldrshls.w	r0, [r3, r0, lsl #1]
{
   e:	f06f 00ac 	mvnhi.w	r0, #172	; 0xac
        default:
            block_size = BAD_FUNC_ARG;
            break;
    }
    return block_size;
}
  12:	4770      	bx	lr
  14:	00000000 	.word	0x00000000

Disassembly of section .text.wc_HashInit_ex:

00000000 <wc_HashInit_ex>:
    return ret;
}

int wc_HashInit_ex(wc_HashAlg* hash, enum wc_HashType type, void* heap,
    int devId)
{
   0:	b410      	push	{r4}
   2:	460c      	mov	r4, r1
   4:	4611      	mov	r1, r2
   6:	461a      	mov	r2, r3
    int ret = HASH_TYPE_E; /* Default to hash type error */

    if (hash == NULL)
   8:	b1d8      	cbz	r0, 42 <wc_HashInit_ex+0x42>
        return BAD_FUNC_ARG;

    switch (type) {
   a:	1ee3      	subs	r3, r4, #3
   c:	2b0e      	cmp	r3, #14
   e:	d818      	bhi.n	42 <wc_HashInit_ex+0x42>
  10:	e8df f003 	tbb	[pc, r3]
  14:	0b1b081b 	.word	0x0b1b081b
  18:	1b170e1b 	.word	0x1b170e1b
  1c:	171b1b1b 	.word	0x171b1b1b
  20:	1117      	.short	0x1117
  22:	14          	.byte	0x14
  23:	00          	.byte	0x00

    (void)heap;
    (void)devId;

    return ret;
}
  24:	bc10      	pop	{r4}
            ret = wc_InitSha_ex(&hash->sha, heap, devId);
  26:	f7ff bffe 	b.w	0 <wc_InitSha_ex>
}
  2a:	bc10      	pop	{r4}
            ret = wc_InitSha256_ex(&hash->sha256, heap, devId);
  2c:	f7ff bffe 	b.w	0 <wc_InitSha256_ex>
}
  30:	bc10      	pop	{r4}
            ret = wc_InitSha512_ex(&hash->sha512, heap, devId);
  32:	f7ff bffe 	b.w	0 <wc_InitSha512_ex>
}
  36:	bc10      	pop	{r4}
            ret = wc_InitSha512_224_ex(&hash->sha512, heap, devId);
  38:	f7ff bffe 	b.w	0 <wc_InitSha512_224_ex>
}
  3c:	bc10      	pop	{r4}
            ret = wc_InitSha512_256_ex(&hash->sha512, heap, devId);
  3e:	f7ff bffe 	b.w	0 <wc_InitSha512_256_ex>
        return BAD_FUNC_ARG;
  42:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  46:	bc10      	pop	{r4}
  48:	4770      	bx	lr
    int ret = HASH_TYPE_E; /* Default to hash type error */
  4a:	f06f 00e7 	mvn.w	r0, #231	; 0xe7
  4e:	e7fa      	b.n	46 <wc_HashInit_ex+0x46>

Disassembly of section .text.wc_HashInit:

00000000 <wc_HashInit>:

int wc_HashInit(wc_HashAlg* hash, enum wc_HashType type)
{
    return wc_HashInit_ex(hash, type, NULL, INVALID_DEVID);
   0:	f06f 0301 	mvn.w	r3, #1
   4:	2200      	movs	r2, #0
   6:	f7ff bffe 	b.w	0 <wc_HashInit>

Disassembly of section .text.wc_HashUpdate:

00000000 <wc_HashUpdate>:
}

int wc_HashUpdate(wc_HashAlg* hash, enum wc_HashType type, const byte* data,
                  word32 dataSz)
{
   0:	b410      	push	{r4}
   2:	460c      	mov	r4, r1
   4:	4611      	mov	r1, r2
   6:	461a      	mov	r2, r3
    int ret = HASH_TYPE_E; /* Default to hash type error */

    if (hash == NULL || (data == NULL && dataSz > 0))
   8:	b1e8      	cbz	r0, 46 <wc_HashUpdate+0x46>
   a:	b901      	cbnz	r1, e <wc_HashUpdate+0xe>
   c:	b9db      	cbnz	r3, 46 <wc_HashUpdate+0x46>
        return BAD_FUNC_ARG;

    switch (type) {
   e:	1ee3      	subs	r3, r4, #3
  10:	2b0e      	cmp	r3, #14
  12:	d818      	bhi.n	46 <wc_HashUpdate+0x46>
  14:	e8df f003 	tbb	[pc, r3]
  18:	0b1b081b 	.word	0x0b1b081b
  1c:	1b170e1b 	.word	0x1b170e1b
  20:	171b1b1b 	.word	0x171b1b1b
  24:	1117      	.short	0x1117
  26:	14          	.byte	0x14
  27:	00          	.byte	0x00
        default:
            ret = BAD_FUNC_ARG;
    };

    return ret;
}
  28:	bc10      	pop	{r4}
            ret = wc_ShaUpdate(&hash->sha, data, dataSz);
  2a:	f7ff bffe 	b.w	0 <wc_ShaUpdate>
}
  2e:	bc10      	pop	{r4}
            ret = wc_Sha256Update(&hash->sha256, data, dataSz);
  30:	f7ff bffe 	b.w	0 <wc_Sha256Update>
}
  34:	bc10      	pop	{r4}
            ret = wc_Sha512Update(&hash->sha512, data, dataSz);
  36:	f7ff bffe 	b.w	0 <wc_Sha512Update>
}
  3a:	bc10      	pop	{r4}
            ret = wc_Sha512_224Update(&hash->sha512, data, dataSz);
  3c:	f7ff bffe 	b.w	0 <wc_Sha512_224Update>
}
  40:	bc10      	pop	{r4}
            ret = wc_Sha512_256Update(&hash->sha512, data, dataSz);
  42:	f7ff bffe 	b.w	0 <wc_Sha512_256Update>
        return BAD_FUNC_ARG;
  46:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  4a:	bc10      	pop	{r4}
  4c:	4770      	bx	lr
    int ret = HASH_TYPE_E; /* Default to hash type error */
  4e:	f06f 00e7 	mvn.w	r0, #231	; 0xe7
  52:	e7fa      	b.n	4a <wc_HashUpdate+0x4a>

Disassembly of section .text.wc_HashFinal:

00000000 <wc_HashFinal>:

int wc_HashFinal(wc_HashAlg* hash, enum wc_HashType type, byte* out)
{
   0:	460b      	mov	r3, r1
   2:	4611      	mov	r1, r2
    int ret = HASH_TYPE_E; /* Default to hash type error */

    if (hash == NULL || out == NULL)
   4:	b1b8      	cbz	r0, 36 <wc_HashFinal+0x36>
   6:	b1b2      	cbz	r2, 36 <wc_HashFinal+0x36>
        return BAD_FUNC_ARG;

    switch (type) {
   8:	3b03      	subs	r3, #3
   a:	2b0e      	cmp	r3, #14
   c:	d813      	bhi.n	36 <wc_HashFinal+0x36>
   e:	e8df f003 	tbb	[pc, r3]
  12:	0815      	.short	0x0815
  14:	0c150a15 	.word	0x0c150a15
  18:	15151512 	.word	0x15151512
  1c:	0e121215 	.word	0x0e121215
  20:	10          	.byte	0x10
  21:	00          	.byte	0x00
            ret = wc_Md5Final(&hash->md5, out);
#endif
            break;
        case WC_HASH_TYPE_SHA:
#ifndef NO_SHA
            ret = wc_ShaFinal(&hash->sha, out);
  22:	f7ff bffe 	b.w	0 <wc_ShaFinal>
            ret = wc_Sha224Final(&hash->sha224, out);
#endif
            break;
        case WC_HASH_TYPE_SHA256:
#ifndef NO_SHA256
            ret = wc_Sha256Final(&hash->sha256, out);
  26:	f7ff bffe 	b.w	0 <wc_Sha256Final>
            ret = wc_Sha384Final(&hash->sha384, out);
#endif
            break;
        case WC_HASH_TYPE_SHA512:
#ifdef WOLFSSL_SHA512
            ret = wc_Sha512Final(&hash->sha512, out);
  2a:	f7ff bffe 	b.w	0 <wc_Sha512Final>
            break;
    #ifndef WOLFSSL_NOSHA512_224
        case WC_HASH_TYPE_SHA512_224:
#if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
#if defined(WOLFSSL_SHA512) && !defined(WOLFSSL_NOSHA512_224)
            ret = wc_Sha512_224Final(&hash->sha512, out);
  2e:	f7ff bffe 	b.w	0 <wc_Sha512_224Final>
    #endif
    #ifndef WOLFSSL_NOSHA512_256
        case WC_HASH_TYPE_SHA512_256:
#if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
#if defined(WOLFSSL_SHA512) && !defined(WOLFSSL_NOSHA512_256)
            ret = wc_Sha512_256Final(&hash->sha512, out);
  32:	f7ff bffe 	b.w	0 <wc_Sha512_256Final>
        return BAD_FUNC_ARG;
  36:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  3a:	4770      	bx	lr
    int ret = HASH_TYPE_E; /* Default to hash type error */
  3c:	f06f 00e7 	mvn.w	r0, #231	; 0xe7
        default:
            ret = BAD_FUNC_ARG;
    };

    return ret;
}
  40:	4770      	bx	lr

Disassembly of section .text.wc_HashFree:

00000000 <wc_HashFree>:

int wc_HashFree(wc_HashAlg* hash, enum wc_HashType type)
{
   0:	b508      	push	{r3, lr}
    int ret = HASH_TYPE_E; /* Default to hash type error */

    if (hash == NULL)
   2:	b1e0      	cbz	r0, 3e <wc_HashFree+0x3e>
        return BAD_FUNC_ARG;

    switch (type) {
   4:	3903      	subs	r1, #3
   6:	290e      	cmp	r1, #14
   8:	d819      	bhi.n	3e <wc_HashFree+0x3e>
   a:	e8df f001 	tbb	[pc, r1]
   e:	081b      	.short	0x081b
  10:	0f1b0c1b 	.word	0x0f1b0c1b
  14:	1b1b1b18 	.word	0x1b1b1b18
  18:	1218181b 	.word	0x1218181b
  1c:	15          	.byte	0x15
  1d:	00          	.byte	0x00
            ret = 0;
#endif
            break;
        case WC_HASH_TYPE_SHA:
#ifndef NO_SHA
            wc_ShaFree(&hash->sha);
  1e:	f7ff fffe 	bl	0 <wc_ShaFree>
    #ifndef WOLFSSL_NOSHA512_256
        case WC_HASH_TYPE_SHA512_256:
#if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
#if defined(WOLFSSL_SHA512) && !defined(WOLFSSL_NOSHA512_256)
            wc_Sha512_256Free(&hash->sha512);
            ret = 0;
  22:	2000      	movs	r0, #0
        default:
            ret = BAD_FUNC_ARG;
    };

    return ret;
}
  24:	bd08      	pop	{r3, pc}
            wc_Sha256Free(&hash->sha256);
  26:	f7ff fffe 	bl	0 <wc_Sha256Free>
            break;
  2a:	e7fa      	b.n	22 <wc_HashFree+0x22>
            wc_Sha512Free(&hash->sha512);
  2c:	f7ff fffe 	bl	0 <wc_Sha512Free>
            break;
  30:	e7f7      	b.n	22 <wc_HashFree+0x22>
            wc_Sha512_224Free(&hash->sha512);
  32:	f7ff fffe 	bl	0 <wc_Sha512_224Free>
            break;
  36:	e7f4      	b.n	22 <wc_HashFree+0x22>
            wc_Sha512_256Free(&hash->sha512);
  38:	f7ff fffe 	bl	0 <wc_Sha512_256Free>
  3c:	e7f1      	b.n	22 <wc_HashFree+0x22>
        return BAD_FUNC_ARG;
  3e:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  42:	e7ef      	b.n	24 <wc_HashFree+0x24>
    int ret = HASH_TYPE_E; /* Default to hash type error */
  44:	f06f 00e7 	mvn.w	r0, #231	; 0xe7
  48:	e7ec      	b.n	24 <wc_HashFree+0x24>

Disassembly of section .text.wc_ShaHash:

00000000 <wc_ShaHash>:
    }
#endif /* !NO_MD5 */

#if !defined(NO_SHA)
    int wc_ShaHash(const byte* data, word32 len, byte* hash)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4607      	mov	r7, r0
        wc_Sha sha[1];
    #endif
        int devId = INVALID_DEVID;

    #ifdef WOLFSSL_SMALL_STACK
        sha = (wc_Sha*)XMALLOC(sizeof(wc_Sha), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   6:	2064      	movs	r0, #100	; 0x64
    {
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
        sha = (wc_Sha*)XMALLOC(sizeof(wc_Sha), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   c:	f7ff fffe 	bl	0 <malloc>
        if (sha == NULL)
  10:	4605      	mov	r5, r0
  12:	b1d8      	cbz	r0, 4c <wc_ShaHash+0x4c>
        /* only use devId if its not an empty hash */
        if (data != NULL && len > 0)
            devId = wc_CryptoCb_GetDevIdAtIndex(0);
    #endif

        if ((ret = wc_InitSha_ex(sha, NULL, devId)) != 0) {
  14:	f06f 0201 	mvn.w	r2, #1
  18:	2100      	movs	r1, #0
  1a:	f7ff fffe 	bl	0 <wc_InitSha_ex>
  1e:	4604      	mov	r4, r0
  20:	b970      	cbnz	r0, 40 <wc_ShaHash+0x40>
            WOLFSSL_MSG("InitSha failed");
        }
        else {
            if ((ret = wc_ShaUpdate(sha, data, len)) != 0) {
  22:	4642      	mov	r2, r8
  24:	4639      	mov	r1, r7
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <wc_ShaUpdate>
  2c:	4604      	mov	r4, r0
  2e:	b920      	cbnz	r0, 3a <wc_ShaHash+0x3a>
                WOLFSSL_MSG("ShaUpdate failed");
            }
            else if ((ret = wc_ShaFinal(sha, hash)) != 0) {
  30:	4631      	mov	r1, r6
  32:	4628      	mov	r0, r5
  34:	f7ff fffe 	bl	0 <wc_ShaFinal>
  38:	4604      	mov	r4, r0
                WOLFSSL_MSG("ShaFinal failed");
            }
            wc_ShaFree(sha);
  3a:	4628      	mov	r0, r5
  3c:	f7ff fffe 	bl	0 <wc_ShaFree>
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  40:	4628      	mov	r0, r5
  42:	f7ff fffe 	bl	0 <free>
    #endif

        return ret;
    }
  46:	4620      	mov	r0, r4
  48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return MEMORY_E;
  4c:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  50:	e7f9      	b.n	46 <wc_ShaHash+0x46>

Disassembly of section .text.wc_Sha256Hash:

00000000 <wc_Sha256Hash>:
}
#endif /* WOLFSSL_SHA224 */

#if !defined(NO_SHA256)
    int wc_Sha256Hash(const byte* data, word32 len, byte* hash)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4607      	mov	r7, r0
        wc_Sha256 sha256[1];
    #endif
        int devId = INVALID_DEVID;

    #ifdef WOLFSSL_SMALL_STACK
        sha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
   6:	2070      	movs	r0, #112	; 0x70
    {
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
        sha256 = (wc_Sha256*)XMALLOC(sizeof(wc_Sha256), NULL,
   c:	f7ff fffe 	bl	0 <malloc>
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha256 == NULL)
  10:	4605      	mov	r5, r0
  12:	b1d8      	cbz	r0, 4c <wc_Sha256Hash+0x4c>
        /* only use devId if its not an empty hash */
        if (data != NULL && len > 0)
            devId = wc_CryptoCb_GetDevIdAtIndex(0);
    #endif

        if ((ret = wc_InitSha256_ex(sha256, NULL, devId)) != 0) {
  14:	f06f 0201 	mvn.w	r2, #1
  18:	2100      	movs	r1, #0
  1a:	f7ff fffe 	bl	0 <wc_InitSha256_ex>
  1e:	4604      	mov	r4, r0
  20:	b970      	cbnz	r0, 40 <wc_Sha256Hash+0x40>
            WOLFSSL_MSG("InitSha256 failed");
        }
        else {
            if ((ret = wc_Sha256Update(sha256, data, len)) != 0) {
  22:	4642      	mov	r2, r8
  24:	4639      	mov	r1, r7
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <wc_Sha256Update>
  2c:	4604      	mov	r4, r0
  2e:	b920      	cbnz	r0, 3a <wc_Sha256Hash+0x3a>
                WOLFSSL_MSG("Sha256Update failed");
            }
            else if ((ret = wc_Sha256Final(sha256, hash)) != 0) {
  30:	4631      	mov	r1, r6
  32:	4628      	mov	r0, r5
  34:	f7ff fffe 	bl	0 <wc_Sha256Final>
  38:	4604      	mov	r4, r0
                WOLFSSL_MSG("Sha256Final failed");
            }
            wc_Sha256Free(sha256);
  3a:	4628      	mov	r0, r5
  3c:	f7ff fffe 	bl	0 <wc_Sha256Free>
        }


    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha256, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  40:	4628      	mov	r0, r5
  42:	f7ff fffe 	bl	0 <free>
    #endif

        return ret;
    }
  46:	4620      	mov	r0, r4
  48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return MEMORY_E;
  4c:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  50:	e7f9      	b.n	46 <wc_Sha256Hash+0x46>

Disassembly of section .text.wc_Sha512Hash:

00000000 <wc_Sha512Hash>:
#endif /* !defined(WOLFSSL_TI_HASH) */


#if defined(WOLFSSL_SHA512)
    int wc_Sha512Hash(const byte* data, word32 len, byte* hash)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4607      	mov	r7, r0
    #else
        wc_Sha512 sha512[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha512 = (wc_Sha512*)XMALLOC(sizeof(wc_Sha512), NULL,
   6:	20e0      	movs	r0, #224	; 0xe0
    {
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
        sha512 = (wc_Sha512*)XMALLOC(sizeof(wc_Sha512), NULL,
   c:	f7ff fffe 	bl	0 <malloc>
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha512 == NULL)
  10:	4605      	mov	r5, r0
  12:	b1c0      	cbz	r0, 46 <wc_Sha512Hash+0x46>
            return MEMORY_E;
    #endif

        if ((ret = wc_InitSha512(sha512)) != 0) {
  14:	f7ff fffe 	bl	0 <wc_InitSha512>
  18:	4604      	mov	r4, r0
  1a:	b970      	cbnz	r0, 3a <wc_Sha512Hash+0x3a>
            WOLFSSL_MSG("InitSha512 failed");
        }
        else {
            if ((ret = wc_Sha512Update(sha512, data, len)) != 0) {
  1c:	4642      	mov	r2, r8
  1e:	4639      	mov	r1, r7
  20:	4628      	mov	r0, r5
  22:	f7ff fffe 	bl	0 <wc_Sha512Update>
  26:	4604      	mov	r4, r0
  28:	b920      	cbnz	r0, 34 <wc_Sha512Hash+0x34>
                WOLFSSL_MSG("Sha512Update failed");
            }
            else if ((ret = wc_Sha512Final(sha512, hash)) != 0) {
  2a:	4631      	mov	r1, r6
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <wc_Sha512Final>
  32:	4604      	mov	r4, r0
                WOLFSSL_MSG("Sha512Final failed");
            }
            wc_Sha512Free(sha512);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <wc_Sha512Free>
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha512, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  3a:	4628      	mov	r0, r5
  3c:	f7ff fffe 	bl	0 <free>
    #endif

        return ret;
    }
  40:	4620      	mov	r0, r4
  42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return MEMORY_E;
  46:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  4a:	e7f9      	b.n	40 <wc_Sha512Hash+0x40>

Disassembly of section .text.wc_Sha512_224Hash:

00000000 <wc_Sha512_224Hash>:
#if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
#ifndef WOLFSSL_NOSHA512_224
    int wc_Sha512_224Hash(const byte* data, word32 len, byte* hash)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4607      	mov	r7, r0
    #else
        wc_Sha512 sha512[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha512 = (wc_Sha512*)XMALLOC(sizeof(wc_Sha512), NULL,
   6:	20e0      	movs	r0, #224	; 0xe0
    {
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
        sha512 = (wc_Sha512*)XMALLOC(sizeof(wc_Sha512), NULL,
   c:	f7ff fffe 	bl	0 <malloc>
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha512 == NULL)
  10:	4605      	mov	r5, r0
  12:	b1c0      	cbz	r0, 46 <wc_Sha512_224Hash+0x46>
            return MEMORY_E;
    #endif

        if ((ret = wc_InitSha512_224(sha512)) != 0) {
  14:	f7ff fffe 	bl	0 <wc_InitSha512_224>
  18:	4604      	mov	r4, r0
  1a:	b970      	cbnz	r0, 3a <wc_Sha512_224Hash+0x3a>
            WOLFSSL_MSG("wc_InitSha512_224 failed");
        }
        else {
            if ((ret = wc_Sha512_224Update(sha512, data, len)) != 0) {
  1c:	4642      	mov	r2, r8
  1e:	4639      	mov	r1, r7
  20:	4628      	mov	r0, r5
  22:	f7ff fffe 	bl	0 <wc_Sha512_224Update>
  26:	4604      	mov	r4, r0
  28:	b920      	cbnz	r0, 34 <wc_Sha512_224Hash+0x34>
                WOLFSSL_MSG("wc_Sha512_224_Update failed");
            }
            else if ((ret = wc_Sha512_224Final(sha512, hash)) != 0) {
  2a:	4631      	mov	r1, r6
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <wc_Sha512_224Final>
  32:	4604      	mov	r4, r0
                WOLFSSL_MSG("wc_Sha512_224_Final failed");
            }
            wc_Sha512_224Free(sha512);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <wc_Sha512_224Free>
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha512, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  3a:	4628      	mov	r0, r5
  3c:	f7ff fffe 	bl	0 <free>
    #endif

        return ret;
    }
  40:	4620      	mov	r0, r4
  42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return MEMORY_E;
  46:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  4a:	e7f9      	b.n	40 <wc_Sha512_224Hash+0x40>

Disassembly of section .text.wc_Sha512_256Hash:

00000000 <wc_Sha512_256Hash>:
#endif /* !HAVE_FIPS && !HAVE_SELFTEST */

#if !defined(HAVE_FIPS) && !defined(HAVE_SELFTEST)
#ifndef WOLFSSL_NOSHA512_256
    int wc_Sha512_256Hash(const byte* data, word32 len, byte* hash)
    {
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4607      	mov	r7, r0
    #else
        wc_Sha512 sha512[1];
    #endif

    #ifdef WOLFSSL_SMALL_STACK
        sha512 = (wc_Sha512*)XMALLOC(sizeof(wc_Sha512), NULL,
   6:	20e0      	movs	r0, #224	; 0xe0
    {
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
        sha512 = (wc_Sha512*)XMALLOC(sizeof(wc_Sha512), NULL,
   c:	f7ff fffe 	bl	0 <malloc>
            DYNAMIC_TYPE_TMP_BUFFER);
        if (sha512 == NULL)
  10:	4605      	mov	r5, r0
  12:	b1c0      	cbz	r0, 46 <wc_Sha512_256Hash+0x46>
            return MEMORY_E;
    #endif

        if ((ret = wc_InitSha512_256(sha512)) != 0) {
  14:	f7ff fffe 	bl	0 <wc_InitSha512_256>
  18:	4604      	mov	r4, r0
  1a:	b970      	cbnz	r0, 3a <wc_Sha512_256Hash+0x3a>
            WOLFSSL_MSG("wc_InitSha512_256 failed");
        }
        else {
            if ((ret = wc_Sha512_256Update(sha512, data, len)) != 0) {
  1c:	4642      	mov	r2, r8
  1e:	4639      	mov	r1, r7
  20:	4628      	mov	r0, r5
  22:	f7ff fffe 	bl	0 <wc_Sha512_256Update>
  26:	4604      	mov	r4, r0
  28:	b920      	cbnz	r0, 34 <wc_Sha512_256Hash+0x34>
                WOLFSSL_MSG("wc_Sha512_256_Update failed");
            }
            else if ((ret = wc_Sha512_256Final(sha512, hash)) != 0) {
  2a:	4631      	mov	r1, r6
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <wc_Sha512_256Final>
  32:	4604      	mov	r4, r0
                WOLFSSL_MSG("wc_Sha512_256_Final failed");
            }
            wc_Sha512_256Free(sha512);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <wc_Sha512_256Free>
        }

    #ifdef WOLFSSL_SMALL_STACK
        XFREE(sha512, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  3a:	4628      	mov	r0, r5
  3c:	f7ff fffe 	bl	0 <free>
    #endif

        return ret;
    }
  40:	4620      	mov	r0, r4
  42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            return MEMORY_E;
  46:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  4a:	e7f9      	b.n	40 <wc_Sha512_256Hash+0x40>

Disassembly of section .text.wc_Hash:

00000000 <wc_Hash>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4605      	mov	r5, r0
   4:	460c      	mov	r4, r1
   6:	4611      	mov	r1, r2
   8:	461a      	mov	r2, r3
    dig_size = wc_HashGetDigestSize(hash_type);
   a:	f7ff fffe 	bl	0 <wc_Hash>
    if (dig_size < 0) {
   e:	2800      	cmp	r0, #0
{
  10:	9e04      	ldr	r6, [sp, #16]
    if (dig_size < 0) {
  12:	db10      	blt.n	36 <wc_Hash+0x36>
    if (hash_len < (word32)dig_size) {
  14:	42b0      	cmp	r0, r6
  16:	d828      	bhi.n	6a <wc_Hash+0x6a>
    switch(hash_type)
  18:	1ee8      	subs	r0, r5, #3
  1a:	280e      	cmp	r0, #14
  1c:	d809      	bhi.n	32 <wc_Hash+0x32>
  1e:	e8df f000 	tbb	[pc, r0]
  22:	0b27      	.short	0x0b27
  24:	15271027 	.word	0x15271027
  28:	27272727 	.word	0x27272727
  2c:	1a080827 	.word	0x1a080827
  30:	1f          	.byte	0x1f
  31:	00          	.byte	0x00
  32:	f06f 00ac 	mvn.w	r0, #172	; 0xac
}
  36:	bd70      	pop	{r4, r5, r6, pc}
            ret = wc_ShaHash(data, data_len, hash);
  38:	4620      	mov	r0, r4
}
  3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_ShaHash(data, data_len, hash);
  3e:	f7ff bffe 	b.w	0 <wc_Hash>
            ret = wc_Sha256Hash(data, data_len, hash);
  42:	4620      	mov	r0, r4
}
  44:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_Sha256Hash(data, data_len, hash);
  48:	f7ff bffe 	b.w	0 <wc_Hash>
            ret = wc_Sha512Hash(data, data_len, hash);
  4c:	4620      	mov	r0, r4
}
  4e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_Sha512Hash(data, data_len, hash);
  52:	f7ff bffe 	b.w	0 <wc_Hash>
            ret = wc_Sha512_224Hash(data, data_len, hash);
  56:	4620      	mov	r0, r4
}
  58:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_Sha512_224Hash(data, data_len, hash);
  5c:	f7ff bffe 	b.w	0 <wc_Hash>
            ret = wc_Sha512_256Hash(data, data_len, hash);
  60:	4620      	mov	r0, r4
}
  62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            ret = wc_Sha512_256Hash(data, data_len, hash);
  66:	f7ff bffe 	b.w	0 <wc_Hash>
        return BUFFER_E;
  6a:	f06f 0083 	mvn.w	r0, #131	; 0x83
  6e:	e7e2      	b.n	36 <wc_Hash+0x36>
    int ret = HASH_TYPE_E; /* Default to hash type error */
  70:	f06f 00e7 	mvn.w	r0, #231	; 0xe7
  74:	e7df      	b.n	36 <wc_Hash+0x36>

integer.o:     file format elf32-littlearm


logging.o:     file format elf32-littlearm


Disassembly of section .text.wolfSSL_SetLoggingCb:

00000000 <wolfSSL_SetLoggingCb>:
    return 0;
#else
    (void)f;
    return NOT_COMPILED_IN;
#endif
}
   0:	f06f 00ad 	mvn.w	r0, #173	; 0xad
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_GetLoggingCb:

00000000 <wolfSSL_GetLoggingCb>:
#ifdef DEBUG_WOLFSSL
    return log_function;
#else
    return NULL;
#endif
}
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wolfSSL_Debugging_ON:

00000000 <wolfSSL_Debugging_ON>:
#endif /* WOLFSSL_APACHE_MYNEWT */
    return 0;
#else
    return NOT_COMPILED_IN;
#endif
}
   0:	f06f 00ad 	mvn.w	r0, #173	; 0xad
   4:	4770      	bx	lr

Disassembly of section .text.wolfSSL_Debugging_OFF:

00000000 <wolfSSL_Debugging_OFF>:
void wolfSSL_Debugging_OFF(void)
{
#ifdef DEBUG_WOLFSSL
    loggingEnabled = 0;
#endif
}
   0:	4770      	bx	lr

Disassembly of section .text.wolfSSL_SetLoggingPrefix:

00000000 <wolfSSL_SetLoggingPrefix>:
#ifdef DEBUG_WOLFSSL
    log_prefix = prefix;
#else
    (void)prefix;
#endif
}
   0:	4770      	bx	lr

md5.o:     file format elf32-littlearm


memory.o:     file format elf32-littlearm


misc.o:     file format elf32-littlearm


pkcs12.o:     file format elf32-littlearm


pkcs7.o:     file format elf32-littlearm


poly1305.o:     file format elf32-littlearm


pwdbased.o:     file format elf32-littlearm


rc2.o:     file format elf32-littlearm


sakke.o:     file format elf32-littlearm


signature.o:     file format elf32-littlearm


Disassembly of section .text.wc_SignatureGetSize:

00000000 <wc_SignatureGetSize>:
}
#endif /* !NO_RSA && !NO_ASN */

int wc_SignatureGetSize(enum wc_SignatureType sig_type,
    const void* key, word32 key_len)
{
   0:	4603      	mov	r3, r0

    /* Suppress possible unused args if all signature types are disabled */
    (void)key;
    (void)key_len;

    switch(sig_type) {
   2:	2b01      	cmp	r3, #1
{
   4:	4608      	mov	r0, r1
    switch(sig_type) {
   6:	d007      	beq.n	18 <wc_SignatureGetSize+0x18>
   8:	3b02      	subs	r3, #2
   a:	2b01      	cmp	r3, #1
   c:	bf94      	ite	ls
   e:	f06f 00e6 	mvnls.w	r0, #230	; 0xe6
  12:	f06f 00ac 	mvnhi.w	r0, #172	; 0xac
  16:	4770      	bx	lr
        case WC_SIGNATURE_TYPE_ECC:
#ifdef HAVE_ECC
            /* Sanity check that void* key is at least ecc_key in size */
            if (key_len >= sizeof(ecc_key)) {
  18:	f5b2 7fde 	cmp.w	r2, #444	; 0x1bc
  1c:	d301      	bcc.n	22 <wc_SignatureGetSize+0x22>
                sig_len = wc_ecc_sig_size((ecc_key*)key);
  1e:	f7ff bffe 	b.w	0 <wc_ecc_sig_size>
    int sig_len = BAD_FUNC_ARG;
  22:	f06f 00ac 	mvn.w	r0, #172	; 0xac
        default:
            sig_len = BAD_FUNC_ARG;
            break;
    }
    return sig_len;
}
  26:	4770      	bx	lr

Disassembly of section .text.wc_SignatureVerifyHash:

00000000 <wc_SignatureVerifyHash>:
int wc_SignatureVerifyHash(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* hash_data, word32 hash_len,
    const byte* sig, word32 sig_len,
    const void* key, word32 key_len)
{
   0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	461e      	mov	r6, r3
   6:	e9dd 970c 	ldrd	r9, r7, [sp, #48]	; 0x30
   a:	e9dd 830e 	ldrd	r8, r3, [sp, #56]	; 0x38
   e:	4682      	mov	sl, r0
  10:	460c      	mov	r4, r1
    int ret;

    /* Check arguments */
    if (hash_data == NULL || hash_len == 0 ||
  12:	4615      	mov	r5, r2
  14:	b922      	cbnz	r2, 20 <wc_SignatureVerifyHash+0x20>
        sig == NULL || sig_len == 0 ||
        key == NULL || key_len == 0) {
        return BAD_FUNC_ARG;
  16:	f06f 00ac 	mvn.w	r0, #172	; 0xac
            ret = BAD_FUNC_ARG;
            break;
    }

    return ret;
}
  1a:	b004      	add	sp, #16
  1c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (hash_data == NULL || hash_len == 0 ||
  20:	2e00      	cmp	r6, #0
  22:	d0f8      	beq.n	16 <wc_SignatureVerifyHash+0x16>
  24:	f1b9 0f00 	cmp.w	r9, #0
  28:	d0f5      	beq.n	16 <wc_SignatureVerifyHash+0x16>
        sig == NULL || sig_len == 0 ||
  2a:	2f00      	cmp	r7, #0
  2c:	d0f3      	beq.n	16 <wc_SignatureVerifyHash+0x16>
  2e:	f1b8 0f00 	cmp.w	r8, #0
  32:	d0f0      	beq.n	16 <wc_SignatureVerifyHash+0x16>
        key == NULL || key_len == 0) {
  34:	2b00      	cmp	r3, #0
  36:	d0ee      	beq.n	16 <wc_SignatureVerifyHash+0x16>
    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {
  38:	461a      	mov	r2, r3
  3a:	4641      	mov	r1, r8
  3c:	4620      	mov	r0, r4
  3e:	f7ff fffe 	bl	0 <wc_SignatureVerifyHash>
  42:	42b8      	cmp	r0, r7
  44:	dbe7      	blt.n	16 <wc_SignatureVerifyHash+0x16>
    ret = wc_HashGetDigestSize(hash_type);
  46:	4650      	mov	r0, sl
  48:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret < 0) {
  4c:	2800      	cmp	r0, #0
  4e:	dbe4      	blt.n	1a <wc_SignatureVerifyHash+0x1a>
    switch (sig_type) {
  50:	2c01      	cmp	r4, #1
  52:	d007      	beq.n	64 <wc_SignatureVerifyHash+0x64>
  54:	3c02      	subs	r4, #2
  56:	2c01      	cmp	r4, #1
  58:	bf94      	ite	ls
  5a:	f06f 00e6 	mvnls.w	r0, #230	; 0xe6
  5e:	f06f 00ac 	mvnhi.w	r0, #172	; 0xac
  62:	e7da      	b.n	1a <wc_SignatureVerifyHash+0x1a>
            int is_valid_sig = 0;
  64:	2300      	movs	r3, #0
  66:	9303      	str	r3, [sp, #12]
                ret = wc_ecc_verify_hash(sig, sig_len, hash_data, hash_len,
  68:	ab03      	add	r3, sp, #12
  6a:	9300      	str	r3, [sp, #0]
  6c:	f8cd 8004 	str.w	r8, [sp, #4]
  70:	4633      	mov	r3, r6
  72:	462a      	mov	r2, r5
  74:	4639      	mov	r1, r7
  76:	4648      	mov	r0, r9
  78:	f7ff fffe 	bl	0 <wc_ecc_verify_hash>
            } while (ret == WC_PENDING_E);
  7c:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
  80:	d100      	bne.n	84 <wc_SignatureVerifyHash+0x84>
  82:	e7fe      	b.n	82 <wc_SignatureVerifyHash+0x82>
            if (ret != 0 || is_valid_sig != 1) {
  84:	b928      	cbnz	r0, 92 <wc_SignatureVerifyHash+0x92>
  86:	9b03      	ldr	r3, [sp, #12]
                ret = SIG_VERIFY_E;
  88:	2b01      	cmp	r3, #1
  8a:	bf18      	it	ne
  8c:	f06f 00e4 	mvnne.w	r0, #228	; 0xe4
  90:	e7c3      	b.n	1a <wc_SignatureVerifyHash+0x1a>
  92:	f06f 00e4 	mvn.w	r0, #228	; 0xe4
  96:	e7c0      	b.n	1a <wc_SignatureVerifyHash+0x1a>

Disassembly of section .text.wc_SignatureVerify:

00000000 <wc_SignatureVerify>:
int wc_SignatureVerify(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* data, word32 data_len,
    const byte* sig, word32 sig_len,
    const void* key, word32 key_len)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b085      	sub	sp, #20
   6:	4605      	mov	r5, r0
   8:	f8dd a044 	ldr.w	sl, [sp, #68]	; 0x44
   c:	460e      	mov	r6, r1
   e:	4698      	mov	r8, r3
#else
    byte hash_data[MAX_DER_DIGEST_SZ];
#endif

    /* Check arguments */
    if (data == NULL || data_len == 0 ||
  10:	4617      	mov	r7, r2
  12:	b92a      	cbnz	r2, 20 <wc_SignatureVerify+0x20>
        sig == NULL || sig_len == 0 ||
        key == NULL || key_len == 0) {
        return BAD_FUNC_ARG;
  14:	f06f 09ac 	mvn.w	r9, #172	; 0xac
#if defined(WOLFSSL_SMALL_STACK) || defined(NO_ASN)
    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
#endif

    return ret;
}
  18:	4648      	mov	r0, r9
  1a:	b005      	add	sp, #20
  1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (data == NULL || data_len == 0 ||
  20:	2b00      	cmp	r3, #0
  22:	d0f7      	beq.n	14 <wc_SignatureVerify+0x14>
  24:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  26:	2b00      	cmp	r3, #0
  28:	d0f4      	beq.n	14 <wc_SignatureVerify+0x14>
        sig == NULL || sig_len == 0 ||
  2a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  2c:	2b00      	cmp	r3, #0
  2e:	d0f1      	beq.n	14 <wc_SignatureVerify+0x14>
  30:	9b10      	ldr	r3, [sp, #64]	; 0x40
  32:	2b00      	cmp	r3, #0
  34:	d0ee      	beq.n	14 <wc_SignatureVerify+0x14>
        key == NULL || key_len == 0) {
  36:	f1ba 0f00 	cmp.w	sl, #0
  3a:	d0eb      	beq.n	14 <wc_SignatureVerify+0x14>
    if ((int)sig_len > wc_SignatureGetSize(sig_type, key, key_len)) {
  3c:	4619      	mov	r1, r3
  3e:	4652      	mov	r2, sl
  40:	4630      	mov	r0, r6
  42:	f7ff fffe 	bl	0 <wc_SignatureVerify>
  46:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  48:	4298      	cmp	r0, r3
  4a:	dbe3      	blt.n	14 <wc_SignatureVerify+0x14>
    ret = wc_HashGetDigestSize(hash_type);
  4c:	4628      	mov	r0, r5
  4e:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret < 0) {
  52:	f1b0 0900 	subs.w	r9, r0, #0
  56:	dbdf      	blt.n	18 <wc_SignatureVerify+0x18>
    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  58:	f7ff fffe 	bl	0 <malloc>
    hash_enc_len = hash_len = (word32)ret;
  5c:	46cb      	mov	fp, r9
    if (hash_data == NULL) {
  5e:	4604      	mov	r4, r0
  60:	b308      	cbz	r0, a6 <wc_SignatureVerify+0xa6>
    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);
  62:	f8cd 9000 	str.w	r9, [sp]
  66:	4603      	mov	r3, r0
  68:	4642      	mov	r2, r8
  6a:	4639      	mov	r1, r7
  6c:	4628      	mov	r0, r5
  6e:	f7ff fffe 	bl	0 <wc_Hash>
    if (ret == 0) {
  72:	4681      	mov	r9, r0
  74:	b980      	cbnz	r0, 98 <wc_SignatureVerify+0x98>
        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {
  76:	2e03      	cmp	r6, #3
  78:	d012      	beq.n	a0 <wc_SignatureVerify+0xa0>
            ret = wc_SignatureVerifyHash(hash_type, sig_type,
  7a:	9b10      	ldr	r3, [sp, #64]	; 0x40
  7c:	9302      	str	r3, [sp, #8]
  7e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  80:	9301      	str	r3, [sp, #4]
  82:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  84:	9300      	str	r3, [sp, #0]
  86:	f8cd a00c 	str.w	sl, [sp, #12]
  8a:	465b      	mov	r3, fp
  8c:	4622      	mov	r2, r4
  8e:	4631      	mov	r1, r6
  90:	4628      	mov	r0, r5
  92:	f7ff fffe 	bl	0 <wc_SignatureVerify>
  96:	4681      	mov	r9, r0
    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  98:	4620      	mov	r0, r4
  9a:	f7ff fffe 	bl	0 <free>
    return ret;
  9e:	e7bb      	b.n	18 <wc_SignatureVerify+0x18>
            ret = SIG_TYPE_E;
  a0:	f06f 09e6 	mvn.w	r9, #230	; 0xe6
  a4:	e7f8      	b.n	98 <wc_SignatureVerify+0x98>
        return MEMORY_E;
  a6:	f06f 097c 	mvn.w	r9, #124	; 0x7c
  aa:	e7b5      	b.n	18 <wc_SignatureVerify+0x18>

Disassembly of section .text.wc_SignatureGenerateHash_ex:

00000000 <wc_SignatureGenerateHash_ex>:
int wc_SignatureGenerateHash_ex(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* hash_data, word32 hash_len,
    byte* sig, word32 *sig_len,
    const void* key, word32 key_len, WC_RNG* rng, int verify)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b087      	sub	sp, #28
   6:	461e      	mov	r6, r3
   8:	9b14      	ldr	r3, [sp, #80]	; 0x50
   a:	9303      	str	r3, [sp, #12]
   c:	9b15      	ldr	r3, [sp, #84]	; 0x54
   e:	9304      	str	r3, [sp, #16]
  10:	e9dd a810 	ldrd	sl, r8, [sp, #64]	; 0x40
  14:	e9dd 9b12 	ldrd	r9, fp, [sp, #72]	; 0x48
  18:	4607      	mov	r7, r0
  1a:	460c      	mov	r4, r1

    /* Suppress possible unused arg if all signature types are disabled */
    (void)rng;

    /* Check arguments */
    if (hash_data == NULL || hash_len == 0 ||
  1c:	4615      	mov	r5, r2
  1e:	b922      	cbnz	r2, 2a <wc_SignatureGenerateHash_ex+0x2a>
        sig == NULL || sig_len == NULL || *sig_len == 0 ||
        key == NULL || key_len == 0) {
        return BAD_FUNC_ARG;
  20:	f06f 00ac 	mvn.w	r0, #172	; 0xac
        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data, hash_len,
            sig, *sig_len, key, key_len);
    }

    return ret;
}
  24:	b007      	add	sp, #28
  26:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (hash_data == NULL || hash_len == 0 ||
  2a:	2e00      	cmp	r6, #0
  2c:	d0f8      	beq.n	20 <wc_SignatureGenerateHash_ex+0x20>
  2e:	f1ba 0f00 	cmp.w	sl, #0
  32:	d0f5      	beq.n	20 <wc_SignatureGenerateHash_ex+0x20>
        sig == NULL || sig_len == NULL || *sig_len == 0 ||
  34:	f1b8 0f00 	cmp.w	r8, #0
  38:	d0f2      	beq.n	20 <wc_SignatureGenerateHash_ex+0x20>
  3a:	f8d8 3000 	ldr.w	r3, [r8]
  3e:	9305      	str	r3, [sp, #20]
  40:	2b00      	cmp	r3, #0
  42:	d0ed      	beq.n	20 <wc_SignatureGenerateHash_ex+0x20>
  44:	f1b9 0f00 	cmp.w	r9, #0
  48:	d0ea      	beq.n	20 <wc_SignatureGenerateHash_ex+0x20>
        key == NULL || key_len == 0) {
  4a:	f1bb 0f00 	cmp.w	fp, #0
  4e:	d0e7      	beq.n	20 <wc_SignatureGenerateHash_ex+0x20>
    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {
  50:	465a      	mov	r2, fp
  52:	4649      	mov	r1, r9
  54:	4620      	mov	r0, r4
  56:	f7ff fffe 	bl	0 <wc_SignatureGenerateHash_ex>
  5a:	9b05      	ldr	r3, [sp, #20]
  5c:	4283      	cmp	r3, r0
  5e:	dbdf      	blt.n	20 <wc_SignatureGenerateHash_ex+0x20>
    ret = wc_HashGetDigestSize(hash_type);
  60:	4638      	mov	r0, r7
  62:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret < 0) {
  66:	2800      	cmp	r0, #0
  68:	dbdc      	blt.n	24 <wc_SignatureGenerateHash_ex+0x24>
    switch (sig_type) {
  6a:	2c01      	cmp	r4, #1
  6c:	d007      	beq.n	7e <wc_SignatureGenerateHash_ex+0x7e>
  6e:	3c02      	subs	r4, #2
            ret = BAD_FUNC_ARG;
  70:	2c01      	cmp	r4, #1
  72:	bf94      	ite	ls
  74:	f06f 00e6 	mvnls.w	r0, #230	; 0xe6
  78:	f06f 00ac 	mvnhi.w	r0, #172	; 0xac
  7c:	e7d2      	b.n	24 <wc_SignatureGenerateHash_ex+0x24>
                ret = wc_ecc_sign_hash(hash_data, hash_len, sig, sig_len,
  7e:	9b03      	ldr	r3, [sp, #12]
  80:	9300      	str	r3, [sp, #0]
  82:	f8cd 9004 	str.w	r9, [sp, #4]
  86:	4643      	mov	r3, r8
  88:	4652      	mov	r2, sl
  8a:	4631      	mov	r1, r6
  8c:	4628      	mov	r0, r5
  8e:	f7ff fffe 	bl	0 <wc_ecc_sign_hash>
            } while (ret == WC_PENDING_E);
  92:	f110 0f6c 	cmn.w	r0, #108	; 0x6c
  96:	d100      	bne.n	9a <wc_SignatureGenerateHash_ex+0x9a>
  98:	e7fe      	b.n	98 <wc_SignatureGenerateHash_ex+0x98>
    if (ret == 0 && verify) {
  9a:	2800      	cmp	r0, #0
  9c:	d1c2      	bne.n	24 <wc_SignatureGenerateHash_ex+0x24>
  9e:	9b04      	ldr	r3, [sp, #16]
  a0:	2b00      	cmp	r3, #0
  a2:	d0bf      	beq.n	24 <wc_SignatureGenerateHash_ex+0x24>
        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data, hash_len,
  a4:	e9cd 9b12 	strd	r9, fp, [sp, #72]	; 0x48
  a8:	f8d8 3000 	ldr.w	r3, [r8]
  ac:	462a      	mov	r2, r5
  ae:	e9cd a310 	strd	sl, r3, [sp, #64]	; 0x40
  b2:	2101      	movs	r1, #1
  b4:	4633      	mov	r3, r6
  b6:	4638      	mov	r0, r7
}
  b8:	b007      	add	sp, #28
  ba:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        ret = wc_SignatureVerifyHash(hash_type, sig_type, hash_data, hash_len,
  be:	f7ff bffe 	b.w	0 <wc_SignatureGenerateHash_ex>

Disassembly of section .text.wc_SignatureGenerateHash:

00000000 <wc_SignatureGenerateHash>:
{
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
    return wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data, hash_len,
   4:	2401      	movs	r4, #1
   6:	9405      	str	r4, [sp, #20]
   8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   a:	9404      	str	r4, [sp, #16]
   c:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   e:	9403      	str	r4, [sp, #12]
  10:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  12:	9402      	str	r4, [sp, #8]
  14:	9c09      	ldr	r4, [sp, #36]	; 0x24
  16:	9401      	str	r4, [sp, #4]
  18:	9c08      	ldr	r4, [sp, #32]
  1a:	9400      	str	r4, [sp, #0]
  1c:	f7ff fffe 	bl	0 <wc_SignatureGenerateHash>
}
  20:	b006      	add	sp, #24
  22:	bd10      	pop	{r4, pc}

Disassembly of section .text.wc_SignatureGenerate_ex:

00000000 <wc_SignatureGenerate_ex>:
int wc_SignatureGenerate_ex(
    enum wc_HashType hash_type, enum wc_SignatureType sig_type,
    const byte* data, word32 data_len,
    byte* sig, word32 *sig_len,
    const void* key, word32 key_len, WC_RNG* rng, int verify)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b087      	sub	sp, #28
   6:	4605      	mov	r5, r0
   8:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
   c:	460e      	mov	r6, r1
   e:	4698      	mov	r8, r3
#else
    byte hash_data[MAX_DER_DIGEST_SZ];
#endif

    /* Check arguments */
    if (data == NULL || data_len == 0 ||
  10:	4617      	mov	r7, r2
  12:	b92a      	cbnz	r2, 20 <wc_SignatureGenerate_ex+0x20>
        sig == NULL || sig_len == NULL || *sig_len == 0 ||
        key == NULL || key_len == 0) {
        return BAD_FUNC_ARG;
  14:	f06f 09ac 	mvn.w	r9, #172	; 0xac
#if defined(WOLFSSL_SMALL_STACK) || defined(NO_ASN)
    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
#endif

    return ret;
}
  18:	4648      	mov	r0, r9
  1a:	b007      	add	sp, #28
  1c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (data == NULL || data_len == 0 ||
  20:	2b00      	cmp	r3, #0
  22:	d0f7      	beq.n	14 <wc_SignatureGenerate_ex+0x14>
  24:	9b10      	ldr	r3, [sp, #64]	; 0x40
  26:	2b00      	cmp	r3, #0
  28:	d0f4      	beq.n	14 <wc_SignatureGenerate_ex+0x14>
        sig == NULL || sig_len == NULL || *sig_len == 0 ||
  2a:	9b11      	ldr	r3, [sp, #68]	; 0x44
  2c:	2b00      	cmp	r3, #0
  2e:	d0f1      	beq.n	14 <wc_SignatureGenerate_ex+0x14>
  30:	681c      	ldr	r4, [r3, #0]
  32:	2c00      	cmp	r4, #0
  34:	d0ee      	beq.n	14 <wc_SignatureGenerate_ex+0x14>
  36:	9b12      	ldr	r3, [sp, #72]	; 0x48
  38:	2b00      	cmp	r3, #0
  3a:	d0eb      	beq.n	14 <wc_SignatureGenerate_ex+0x14>
        key == NULL || key_len == 0) {
  3c:	f1ba 0f00 	cmp.w	sl, #0
  40:	d0e8      	beq.n	14 <wc_SignatureGenerate_ex+0x14>
    if ((int)*sig_len < wc_SignatureGetSize(sig_type, key, key_len)) {
  42:	4652      	mov	r2, sl
  44:	4619      	mov	r1, r3
  46:	4630      	mov	r0, r6
  48:	f7ff fffe 	bl	0 <wc_SignatureGenerate_ex>
  4c:	4284      	cmp	r4, r0
  4e:	dbe1      	blt.n	14 <wc_SignatureGenerate_ex+0x14>
    ret = wc_HashGetDigestSize(hash_type);
  50:	4628      	mov	r0, r5
  52:	f7ff fffe 	bl	0 <wc_HashGetDigestSize>
    if (ret < 0) {
  56:	f1b0 0900 	subs.w	r9, r0, #0
  5a:	dbdd      	blt.n	18 <wc_SignatureGenerate_ex+0x18>
    hash_data = (byte*)XMALLOC(hash_enc_len, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  5c:	f7ff fffe 	bl	0 <malloc>
    hash_enc_len = hash_len = (word32)ret;
  60:	46cb      	mov	fp, r9
    if (hash_data == NULL) {
  62:	4604      	mov	r4, r0
  64:	b320      	cbz	r0, b0 <wc_SignatureGenerate_ex+0xb0>
    ret = wc_Hash(hash_type, data, data_len, hash_data, hash_len);
  66:	f8cd 9000 	str.w	r9, [sp]
  6a:	4603      	mov	r3, r0
  6c:	4642      	mov	r2, r8
  6e:	4639      	mov	r1, r7
  70:	4628      	mov	r0, r5
  72:	f7ff fffe 	bl	0 <wc_Hash>
    if (ret == 0) {
  76:	4681      	mov	r9, r0
  78:	b998      	cbnz	r0, a2 <wc_SignatureGenerate_ex+0xa2>
        if (sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC) {
  7a:	2e03      	cmp	r6, #3
  7c:	d015      	beq.n	aa <wc_SignatureGenerate_ex+0xaa>
            ret = wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data,
  7e:	9b15      	ldr	r3, [sp, #84]	; 0x54
  80:	9305      	str	r3, [sp, #20]
  82:	9b14      	ldr	r3, [sp, #80]	; 0x50
  84:	e9cd a303 	strd	sl, r3, [sp, #12]
  88:	9b12      	ldr	r3, [sp, #72]	; 0x48
  8a:	9302      	str	r3, [sp, #8]
  8c:	9b11      	ldr	r3, [sp, #68]	; 0x44
  8e:	9301      	str	r3, [sp, #4]
  90:	9b10      	ldr	r3, [sp, #64]	; 0x40
  92:	9300      	str	r3, [sp, #0]
  94:	4622      	mov	r2, r4
  96:	465b      	mov	r3, fp
  98:	4631      	mov	r1, r6
  9a:	4628      	mov	r0, r5
  9c:	f7ff fffe 	bl	0 <wc_SignatureGenerate_ex>
  a0:	4681      	mov	r9, r0
    XFREE(hash_data, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  a2:	4620      	mov	r0, r4
  a4:	f7ff fffe 	bl	0 <free>
    return ret;
  a8:	e7b6      	b.n	18 <wc_SignatureGenerate_ex+0x18>
            ret = SIG_TYPE_E;
  aa:	f06f 09e6 	mvn.w	r9, #230	; 0xe6
  ae:	e7f8      	b.n	a2 <wc_SignatureGenerate_ex+0xa2>
        return MEMORY_E;
  b0:	f06f 097c 	mvn.w	r9, #124	; 0x7c
  b4:	e7b0      	b.n	18 <wc_SignatureGenerate_ex+0x18>

Disassembly of section .text.wc_SignatureGenerate:

00000000 <wc_SignatureGenerate>:
{
   0:	b510      	push	{r4, lr}
   2:	b086      	sub	sp, #24
    return wc_SignatureGenerate_ex(hash_type, sig_type, data, data_len, sig,
   4:	2401      	movs	r4, #1
   6:	9405      	str	r4, [sp, #20]
   8:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   a:	9404      	str	r4, [sp, #16]
   c:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
   e:	9403      	str	r4, [sp, #12]
  10:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  12:	9402      	str	r4, [sp, #8]
  14:	9c09      	ldr	r4, [sp, #36]	; 0x24
  16:	9401      	str	r4, [sp, #4]
  18:	9c08      	ldr	r4, [sp, #32]
  1a:	9400      	str	r4, [sp, #0]
  1c:	f7ff fffe 	bl	0 <wc_SignatureGenerate>
}
  20:	b006      	add	sp, #24
  22:	bd10      	pop	{r4, pc}

srp.o:     file format elf32-littlearm


sp_arm32.o:     file format elf32-littlearm


sp_arm64.o:     file format elf32-littlearm


sp_armthumb.o:     file format elf32-littlearm


sp_c32.o:     file format elf32-littlearm


sp_c64.o:     file format elf32-littlearm


sp_cortexm.o:     file format elf32-littlearm


sp_dsp32.o:     file format elf32-littlearm


sp_int.o:     file format elf32-littlearm


sp_x86_64.o:     file format elf32-littlearm


tfm.o:     file format elf32-littlearm


Disassembly of section .text.fp_cond_swap_ct_ex:

00000000 <fp_cond_swap_ct_ex>:
}

#endif /* WOLFSSL_KEY_GEN || HAVE_ECC */

static int fp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    int i;
    mp_digit mask = (mp_digit)0 - m;

    t->used = (a->used ^ b->used) & mask;
   2:	680d      	ldr	r5, [r1, #0]
   4:	6804      	ldr	r4, [r0, #0]
{
   6:	9e05      	ldr	r6, [sp, #20]
    t->used = (a->used ^ b->used) & mask;
   8:	406c      	eors	r4, r5
    mp_digit mask = (mp_digit)0 - m;
   a:	425b      	negs	r3, r3
    t->used = (a->used ^ b->used) & mask;
   c:	401c      	ands	r4, r3
   e:	6034      	str	r4, [r6, #0]
    for (i = 0; i < c; i++) {
  10:	2501      	movs	r5, #1
  12:	f105 0c01 	add.w	ip, r5, #1
  16:	3d01      	subs	r5, #1
  18:	42aa      	cmp	r2, r5
  1a:	dc13      	bgt.n	44 <fp_cond_swap_ct_ex+0x44>
        t->dp[i] = (a->dp[i] ^ b->dp[i]) & mask;
    }
    a->used ^= t->used;
  1c:	6803      	ldr	r3, [r0, #0]
  1e:	4063      	eors	r3, r4
  20:	f106 0408 	add.w	r4, r6, #8
  24:	f840 3b08 	str.w	r3, [r0], #8
    for (i = 0; i < c; i++) {
  28:	46a4      	mov	ip, r4
  2a:	2300      	movs	r3, #0
  2c:	4293      	cmp	r3, r2
  2e:	db13      	blt.n	58 <fp_cond_swap_ct_ex+0x58>
        a->dp[i] ^= t->dp[i];
    }
    b->used ^= t->used;
  30:	680b      	ldr	r3, [r1, #0]
  32:	6830      	ldr	r0, [r6, #0]
  34:	4043      	eors	r3, r0
  36:	f841 3b08 	str.w	r3, [r1], #8
    for (i = 0; i < c; i++) {
  3a:	2300      	movs	r3, #0
  3c:	4293      	cmp	r3, r2
  3e:	db13      	blt.n	68 <fp_cond_swap_ct_ex+0x68>
        b->dp[i] ^= t->dp[i];
    }

    return FP_OKAY;
}
  40:	2000      	movs	r0, #0
  42:	bdf0      	pop	{r4, r5, r6, r7, pc}
        t->dp[i] = (a->dp[i] ^ b->dp[i]) & mask;
  44:	f850 502c 	ldr.w	r5, [r0, ip, lsl #2]
  48:	f851 702c 	ldr.w	r7, [r1, ip, lsl #2]
  4c:	407d      	eors	r5, r7
  4e:	401d      	ands	r5, r3
  50:	f846 502c 	str.w	r5, [r6, ip, lsl #2]
  54:	4665      	mov	r5, ip
  56:	e7dc      	b.n	12 <fp_cond_swap_ct_ex+0x12>
        a->dp[i] ^= t->dp[i];
  58:	f85c 5b04 	ldr.w	r5, [ip], #4
  5c:	6807      	ldr	r7, [r0, #0]
  5e:	407d      	eors	r5, r7
  60:	f840 5b04 	str.w	r5, [r0], #4
    for (i = 0; i < c; i++) {
  64:	3301      	adds	r3, #1
  66:	e7e1      	b.n	2c <fp_cond_swap_ct_ex+0x2c>
        b->dp[i] ^= t->dp[i];
  68:	6808      	ldr	r0, [r1, #0]
  6a:	f854 5b04 	ldr.w	r5, [r4], #4
  6e:	4068      	eors	r0, r5
  70:	f841 0b04 	str.w	r0, [r1], #4
    for (i = 0; i < c; i++) {
  74:	3301      	adds	r3, #1
  76:	e7e1      	b.n	3c <fp_cond_swap_ct_ex+0x3c>

Disassembly of section .text.fp_sqr_comba8:

00000000 <fp_sqr_comba8>:



#ifdef TFM_SQR8
int fp_sqr_comba8(fp_int *A, fp_int *B)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36	; 0x24
   6:	4607      	mov	r7, r0
#else
   fp_digit *b;
#endif

#ifdef WOLFSSL_SMALL_STACK
   b = (fp_digit*)XMALLOC(sizeof(fp_digit) * 16, NULL, DYNAMIC_TYPE_TMP_BUFFER);
   8:	2040      	movs	r0, #64	; 0x40
{
   a:	9102      	str	r1, [sp, #8]
   b = (fp_digit*)XMALLOC(sizeof(fp_digit) * 16, NULL, DYNAMIC_TYPE_TMP_BUFFER);
   c:	f7ff fffe 	bl	0 <malloc>
   if (b == NULL)
  10:	4606      	mov	r6, r0
  12:	2800      	cmp	r0, #0
  14:	f000 821d 	beq.w	452 <fp_sqr_comba8+0x452>

   /* clear carries */
   CLEAR_CARRY;

   /* output 0 */
   SQRADD(a[0],a[0]);
  18:	68b8      	ldr	r0, [r7, #8]
   COMBA_STORE(b[0]);

   /* output 1 */
   CARRY_FORWARD;
   SQRADD2(a[0], a[1]); 
  1a:	68f9      	ldr	r1, [r7, #12]
   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]); 
   COMBA_STORE(b[3]);

   /* output 4 */
   CARRY_FORWARD;
   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]); 
  1c:	f8d7 8018 	ldr.w	r8, [r7, #24]
   SQRADD2(a[0], a[1]); 
  20:	fba0 c501 	umull	ip, r5, r0, r1
   SQRADD(a[0],a[0]);
  24:	fba0 3400 	umull	r3, r4, r0, r0
   SQRADD2(a[0], a[1]); 
  28:	eb14 040c 	adds.w	r4, r4, ip
  2c:	f145 0200 	adc.w	r2, r5, #0
  30:	eb14 040c 	adds.w	r4, r4, ip
  34:	6074      	str	r4, [r6, #4]
   SQRADD2(a[0], a[2]); SQRADD(a[1], a[1]); 
  36:	693c      	ldr	r4, [r7, #16]
   SQRADD(a[0],a[0]);
  38:	6033      	str	r3, [r6, #0]
   SQRADD2(a[0], a[1]); 
  3a:	f145 0500 	adc.w	r5, r5, #0
   SQRADD(a[0],a[0]);
  3e:	2300      	movs	r3, #0
   SQRADD2(a[0], a[2]); SQRADD(a[1], a[1]); 
  40:	fba0 ec04 	umull	lr, ip, r0, r4
   SQRADD2(a[0], a[1]); 
  44:	1952      	adds	r2, r2, r5
  46:	eb43 0503 	adc.w	r5, r3, r3
   SQRADD2(a[0], a[2]); SQRADD(a[1], a[1]); 
  4a:	eb12 020e 	adds.w	r2, r2, lr
  4e:	9400      	str	r4, [sp, #0]
  50:	f14c 0400 	adc.w	r4, ip, #0
  54:	192d      	adds	r5, r5, r4
  56:	eb43 0403 	adc.w	r4, r3, r3
  5a:	eb12 020e 	adds.w	r2, r2, lr
  5e:	f14c 0c00 	adc.w	ip, ip, #0
  62:	eb1c 0c05 	adds.w	ip, ip, r5
  66:	461d      	mov	r5, r3
  68:	fbe1 2501 	umlal	r2, r5, r1, r1
  6c:	60b2      	str	r2, [r6, #8]
   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]); 
  6e:	697a      	ldr	r2, [r7, #20]
  70:	9201      	str	r2, [sp, #4]
  72:	fba0 a902 	umull	sl, r9, r0, r2
   SQRADD2(a[0], a[2]); SQRADD(a[1], a[1]); 
  76:	f144 0400 	adc.w	r4, r4, #0
  7a:	eb1c 0c05 	adds.w	ip, ip, r5
  7e:	eb43 0503 	adc.w	r5, r3, r3
   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]); 
  82:	eb1c 0c0a 	adds.w	ip, ip, sl
  86:	f149 0200 	adc.w	r2, r9, #0
   SQRADD2(a[0], a[2]); SQRADD(a[1], a[1]); 
  8a:	eb04 0e05 	add.w	lr, r4, r5
   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]); 
  8e:	eb1e 0e02 	adds.w	lr, lr, r2
  92:	eb43 0503 	adc.w	r5, r3, r3
  96:	9a00      	ldr	r2, [sp, #0]
  98:	eb1c 0c0a 	adds.w	ip, ip, sl
  9c:	f149 0900 	adc.w	r9, r9, #0
  a0:	eb1e 0e09 	adds.w	lr, lr, r9
  a4:	fba1 a902 	umull	sl, r9, r1, r2
  a8:	f145 0500 	adc.w	r5, r5, #0
  ac:	eb1c 0c0a 	adds.w	ip, ip, sl
  b0:	f149 0200 	adc.w	r2, r9, #0
  b4:	eb1e 0e02 	adds.w	lr, lr, r2
  b8:	f145 0500 	adc.w	r5, r5, #0
  bc:	eb1c 0c0a 	adds.w	ip, ip, sl
  c0:	f149 0200 	adc.w	r2, r9, #0
  c4:	eb12 020e 	adds.w	r2, r2, lr
  c8:	f8c6 c00c 	str.w	ip, [r6, #12]
   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]); 
  cc:	fba0 ec08 	umull	lr, ip, r0, r8
   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]); 
  d0:	eb43 0403 	adc.w	r4, r3, r3
   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]); 
  d4:	eb12 020e 	adds.w	r2, r2, lr
  d8:	f14c 0900 	adc.w	r9, ip, #0
   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]); 
  dc:	442c      	add	r4, r5
   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]); 
  de:	eb14 0409 	adds.w	r4, r4, r9
  e2:	eb43 0b03 	adc.w	fp, r3, r3
  e6:	9d01      	ldr	r5, [sp, #4]
   COMBA_STORE(b[4]);

   /* output 5 */
   CARRY_FORWARD;
   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB; 
  e8:	f8d7 901c 	ldr.w	r9, [r7, #28]
   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]); 
  ec:	eb12 020e 	adds.w	r2, r2, lr
  f0:	f14c 0c00 	adc.w	ip, ip, #0
  f4:	fba1 e505 	umull	lr, r5, r1, r5
  f8:	eb14 040c 	adds.w	r4, r4, ip
  fc:	f14b 0b00 	adc.w	fp, fp, #0
 100:	eb12 020e 	adds.w	r2, r2, lr
 104:	f145 0c00 	adc.w	ip, r5, #0
 108:	eb14 040c 	adds.w	r4, r4, ip
 10c:	f14b 0b00 	adc.w	fp, fp, #0
 110:	eb12 020e 	adds.w	r2, r2, lr
 114:	f8dd c000 	ldr.w	ip, [sp]
 118:	f145 0500 	adc.w	r5, r5, #0
 11c:	192c      	adds	r4, r5, r4
 11e:	461d      	mov	r5, r3
 120:	fbec 250c 	umlal	r2, r5, ip, ip
 124:	f14b 0b00 	adc.w	fp, fp, #0
 128:	6132      	str	r2, [r6, #16]
 12a:	1964      	adds	r4, r4, r5
   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB; 
 12c:	fba0 2e09 	umull	r2, lr, r0, r9
 130:	461d      	mov	r5, r3
 132:	fbe1 2508 	umlal	r2, r5, r1, r8
   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]); 
 136:	9403      	str	r4, [sp, #12]
 138:	eb43 0c03 	adc.w	ip, r3, r3
   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB; 
 13c:	e9dd a400 	ldrd	sl, r4, [sp]
 140:	eb1e 0e05 	adds.w	lr, lr, r5
 144:	eb43 0503 	adc.w	r5, r3, r3
 148:	9504      	str	r5, [sp, #16]
 14a:	461d      	mov	r5, r3
 14c:	fbea 2504 	umlal	r2, r5, sl, r4
 150:	eb1e 0e05 	adds.w	lr, lr, r5
 154:	eb43 0403 	adc.w	r4, r3, r3
 158:	9405      	str	r4, [sp, #20]
 15a:	9c03      	ldr	r4, [sp, #12]
 15c:	1892      	adds	r2, r2, r2
 15e:	eb43 0503 	adc.w	r5, r3, r3
 162:	1914      	adds	r4, r2, r4
 164:	f145 0500 	adc.w	r5, r5, #0
 168:	6174      	str	r4, [r6, #20]
 16a:	eb1e 0e0e 	adds.w	lr, lr, lr
   COMBA_STORE(b[5]);

   /* output 6 */
   CARRY_FORWARD;
   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]); 
 16e:	6a3c      	ldr	r4, [r7, #32]
   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB; 
 170:	eb43 0a03 	adc.w	sl, r3, r3
   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]); 
 174:	44dc      	add	ip, fp
 176:	eb1e 0e05 	adds.w	lr, lr, r5
 17a:	f14a 0a00 	adc.w	sl, sl, #0
   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]); 
 17e:	461a      	mov	r2, r3
   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB; 
 180:	eb1c 0c0e 	adds.w	ip, ip, lr
   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]); 
 184:	fba0 5e04 	umull	r5, lr, r0, r4
 188:	fbe1 5209 	umlal	r5, r2, r1, r9
   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB; 
 18c:	f14a 0a00 	adc.w	sl, sl, #0
   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]); 
 190:	eb1e 0e02 	adds.w	lr, lr, r2
 194:	eb43 0203 	adc.w	r2, r3, r3
 198:	f8dd b000 	ldr.w	fp, [sp]
 19c:	9206      	str	r2, [sp, #24]
 19e:	461a      	mov	r2, r3
 1a0:	fbeb 5208 	umlal	r5, r2, fp, r8
 1a4:	eb1e 0e02 	adds.w	lr, lr, r2
 1a8:	eb43 0203 	adc.w	r2, r3, r3
 1ac:	196d      	adds	r5, r5, r5
 1ae:	9207      	str	r2, [sp, #28]
 1b0:	eb43 0203 	adc.w	r2, r3, r3
 1b4:	eb15 0c0c 	adds.w	ip, r5, ip
 1b8:	f142 0200 	adc.w	r2, r2, #0
 1bc:	eb1e 0e0e 	adds.w	lr, lr, lr
 1c0:	eb43 0503 	adc.w	r5, r3, r3
 1c4:	eb1e 0e02 	adds.w	lr, lr, r2
 1c8:	f145 0b00 	adc.w	fp, r5, #0
   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB; 
 1cc:	e9dd 2504 	ldrd	r2, r5, [sp, #16]
 1d0:	442a      	add	r2, r5
 1d2:	eb0a 0a42 	add.w	sl, sl, r2, lsl #1
   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]); 
 1d6:	eb1a 020e 	adds.w	r2, sl, lr
 1da:	f8dd e004 	ldr.w	lr, [sp, #4]
 1de:	469a      	mov	sl, r3
 1e0:	fbee ca0e 	umlal	ip, sl, lr, lr
 1e4:	f14b 0500 	adc.w	r5, fp, #0
 1e8:	eb12 0a0a 	adds.w	sl, r2, sl
 1ec:	eb43 0203 	adc.w	r2, r3, r3
 1f0:	9204      	str	r2, [sp, #16]
 1f2:	f8c6 c018 	str.w	ip, [r6, #24]
   COMBA_STORE(b[6]);

   /* output 7 */
   CARRY_FORWARD;
   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB; 
 1f6:	6a7f      	ldr	r7, [r7, #36]	; 0x24
 1f8:	f8dd e000 	ldr.w	lr, [sp]
 1fc:	fba0 2c07 	umull	r2, ip, r0, r7
 200:	4618      	mov	r0, r3
 202:	fbe1 2004 	umlal	r2, r0, r1, r4
 206:	eb1c 0c00 	adds.w	ip, ip, r0
 20a:	4618      	mov	r0, r3
 20c:	fbee 2009 	umlal	r2, r0, lr, r9
 210:	eb43 0b03 	adc.w	fp, r3, r3
 214:	eb1c 0000 	adds.w	r0, ip, r0
 218:	f14b 0c00 	adc.w	ip, fp, #0
 21c:	f8dd e004 	ldr.w	lr, [sp, #4]
 220:	f8cd c00c 	str.w	ip, [sp, #12]
 224:	469c      	mov	ip, r3
 226:	fbee 2c08 	umlal	r2, ip, lr, r8
 22a:	eb10 000c 	adds.w	r0, r0, ip
 22e:	eb43 0e03 	adc.w	lr, r3, r3
 232:	1892      	adds	r2, r2, r2
 234:	eb43 0c03 	adc.w	ip, r3, r3
 238:	eb12 020a 	adds.w	r2, r2, sl
 23c:	f14c 0c00 	adc.w	ip, ip, #0
 240:	1800      	adds	r0, r0, r0
 242:	eb43 0b03 	adc.w	fp, r3, r3
 246:	eb10 000c 	adds.w	r0, r0, ip
   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]); 
 24a:	e9dd ca06 	ldrd	ip, sl, [sp, #24]
 24e:	44d4      	add	ip, sl
 250:	eb05 0c4c 	add.w	ip, r5, ip, lsl #1
 254:	9d04      	ldr	r5, [sp, #16]
   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB; 
 256:	61f2      	str	r2, [r6, #28]
   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]); 
 258:	44ac      	add	ip, r5
 25a:	f14b 0b00 	adc.w	fp, fp, #0
   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB; 
 25e:	eb1c 0000 	adds.w	r0, ip, r0
   COMBA_STORE(b[7]);

   /* output 8 */
   CARRY_FORWARD;
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 262:	f8dd c000 	ldr.w	ip, [sp]
 266:	fba1 1207 	umull	r1, r2, r1, r7
 26a:	461d      	mov	r5, r3
 26c:	fbec 1504 	umlal	r1, r5, ip, r4
   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB; 
 270:	f14b 0b00 	adc.w	fp, fp, #0
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 274:	1952      	adds	r2, r2, r5
 276:	eb43 0503 	adc.w	r5, r3, r3
 27a:	f8dd c004 	ldr.w	ip, [sp, #4]
 27e:	9504      	str	r5, [sp, #16]
 280:	461d      	mov	r5, r3
 282:	fbec 1509 	umlal	r1, r5, ip, r9
 286:	1952      	adds	r2, r2, r5
 288:	eb43 0a03 	adc.w	sl, r3, r3
 28c:	1849      	adds	r1, r1, r1
 28e:	eb43 0503 	adc.w	r5, r3, r3
 292:	1808      	adds	r0, r1, r0
   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB; 
 294:	9903      	ldr	r1, [sp, #12]
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 296:	f145 0500 	adc.w	r5, r5, #0
   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB; 
 29a:	448e      	add	lr, r1
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 29c:	1892      	adds	r2, r2, r2
 29e:	eb43 0c03 	adc.w	ip, r3, r3
   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB; 
 2a2:	eb0b 0b4e 	add.w	fp, fp, lr, lsl #1
 2a6:	1952      	adds	r2, r2, r5
 2a8:	f14c 0c00 	adc.w	ip, ip, #0
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 2ac:	eb1b 0202 	adds.w	r2, fp, r2
 2b0:	469b      	mov	fp, r3
 2b2:	fbe8 0b08 	umlal	r0, fp, r8, r8
 2b6:	f14c 0500 	adc.w	r5, ip, #0
 2ba:	eb12 0b0b 	adds.w	fp, r2, fp
 2be:	eb43 0203 	adc.w	r2, r3, r3
 2c2:	9203      	str	r2, [sp, #12]
   COMBA_STORE(b[8]);

   /* output 9 */
   CARRY_FORWARD;
   SQRADDSC(a[2], a[7]); SQRADDAC(a[3], a[6]); SQRADDAC(a[4], a[5]); SQRADDDB; 
 2c4:	9a00      	ldr	r2, [sp, #0]
 2c6:	f8dd c004 	ldr.w	ip, [sp, #4]
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 2ca:	6230      	str	r0, [r6, #32]
   SQRADDSC(a[2], a[7]); SQRADDAC(a[3], a[6]); SQRADDAC(a[4], a[5]); SQRADDDB; 
 2cc:	4619      	mov	r1, r3
 2ce:	fba2 2007 	umull	r2, r0, r2, r7
 2d2:	fbec 2104 	umlal	r2, r1, ip, r4
 2d6:	1840      	adds	r0, r0, r1
 2d8:	4619      	mov	r1, r3
 2da:	fbe8 2109 	umlal	r2, r1, r8, r9
 2de:	eb43 0c03 	adc.w	ip, r3, r3
 2e2:	1840      	adds	r0, r0, r1
 2e4:	eb43 0e03 	adc.w	lr, r3, r3
 2e8:	1892      	adds	r2, r2, r2
 2ea:	eb43 0103 	adc.w	r1, r3, r3
 2ee:	eb12 020b 	adds.w	r2, r2, fp
 2f2:	f141 0100 	adc.w	r1, r1, #0
 2f6:	1800      	adds	r0, r0, r0
 2f8:	eb43 0b03 	adc.w	fp, r3, r3
 2fc:	1840      	adds	r0, r0, r1
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 2fe:	9904      	ldr	r1, [sp, #16]
   SQRADDSC(a[2], a[7]); SQRADDAC(a[3], a[6]); SQRADDAC(a[4], a[5]); SQRADDDB; 
 300:	6272      	str	r2, [r6, #36]	; 0x24
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 302:	448a      	add	sl, r1
 304:	9903      	ldr	r1, [sp, #12]
   COMBA_STORE(b[9]);

   /* output 10 */
   CARRY_FORWARD;
   SQRADD2(a[3], a[7]); SQRADD2(a[4], a[6]); SQRADD(a[5], a[5]); 
 306:	9a01      	ldr	r2, [sp, #4]
   SQRADDSC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]); 
 308:	eb05 0a4a 	add.w	sl, r5, sl, lsl #1
 30c:	448a      	add	sl, r1
   SQRADD2(a[3], a[7]); SQRADD2(a[4], a[6]); SQRADD(a[5], a[5]); 
 30e:	fba2 5207 	umull	r5, r2, r2, r7
 312:	f14b 0b00 	adc.w	fp, fp, #0
   SQRADDSC(a[2], a[7]); SQRADDAC(a[3], a[6]); SQRADDAC(a[4], a[5]); SQRADDDB; 
 316:	eb1a 0000 	adds.w	r0, sl, r0
 31a:	44f4      	add	ip, lr
 31c:	f14b 0b00 	adc.w	fp, fp, #0
   SQRADD2(a[3], a[7]); SQRADD2(a[4], a[6]); SQRADD(a[5], a[5]); 
 320:	1940      	adds	r0, r0, r5
 322:	f142 0100 	adc.w	r1, r2, #0
   SQRADDSC(a[2], a[7]); SQRADDAC(a[3], a[6]); SQRADDAC(a[4], a[5]); SQRADDDB; 
 326:	eb0b 0b4c 	add.w	fp, fp, ip, lsl #1
   SQRADD2(a[3], a[7]); SQRADD2(a[4], a[6]); SQRADD(a[5], a[5]); 
 32a:	eb1b 0b01 	adds.w	fp, fp, r1
 32e:	eb43 0c03 	adc.w	ip, r3, r3
 332:	1828      	adds	r0, r5, r0
 334:	f142 0200 	adc.w	r2, r2, #0
 338:	eb12 0b0b 	adds.w	fp, r2, fp
 33c:	fba8 5204 	umull	r5, r2, r8, r4
 340:	f14c 0c00 	adc.w	ip, ip, #0
 344:	1828      	adds	r0, r5, r0
 346:	f142 0100 	adc.w	r1, r2, #0
 34a:	eb11 0b0b 	adds.w	fp, r1, fp
 34e:	f14c 0c00 	adc.w	ip, ip, #0
 352:	182d      	adds	r5, r5, r0
 354:	4619      	mov	r1, r3
 356:	f142 0200 	adc.w	r2, r2, #0
 35a:	fbe9 5109 	umlal	r5, r1, r9, r9
 35e:	eb12 020b 	adds.w	r2, r2, fp
 362:	f14c 0000 	adc.w	r0, ip, #0
 366:	1852      	adds	r2, r2, r1
   COMBA_STORE(b[10]);

   /* output 11 */
   CARRY_FORWARD;
   SQRADD2(a[4], a[7]); SQRADD2(a[5], a[6]); 
 368:	fba8 c107 	umull	ip, r1, r8, r7
   SQRADD2(a[3], a[7]); SQRADD2(a[4], a[6]); SQRADD(a[5], a[5]); 
 36c:	eb43 0e03 	adc.w	lr, r3, r3
   SQRADD2(a[4], a[7]); SQRADD2(a[5], a[6]); 
 370:	eb12 020c 	adds.w	r2, r2, ip
   SQRADD2(a[3], a[7]); SQRADD2(a[4], a[6]); SQRADD(a[5], a[5]); 
 374:	4470      	add	r0, lr
 376:	62b5      	str	r5, [r6, #40]	; 0x28
   SQRADD2(a[4], a[7]); SQRADD2(a[5], a[6]); 
 378:	f141 0500 	adc.w	r5, r1, #0
 37c:	1940      	adds	r0, r0, r5
 37e:	eb43 0503 	adc.w	r5, r3, r3
 382:	eb1c 0202 	adds.w	r2, ip, r2
 386:	f141 0100 	adc.w	r1, r1, #0
 38a:	1809      	adds	r1, r1, r0
 38c:	fba9 e004 	umull	lr, r0, r9, r4
 390:	f145 0500 	adc.w	r5, r5, #0
 394:	eb1e 0202 	adds.w	r2, lr, r2
 398:	f140 0c00 	adc.w	ip, r0, #0
 39c:	eb1c 0c01 	adds.w	ip, ip, r1
 3a0:	f145 0500 	adc.w	r5, r5, #0
 3a4:	eb1e 0202 	adds.w	r2, lr, r2
 3a8:	f140 0100 	adc.w	r1, r0, #0
 3ac:	eb11 010c 	adds.w	r1, r1, ip
 3b0:	62f2      	str	r2, [r6, #44]	; 0x2c
   COMBA_STORE(b[11]);

   /* output 12 */
   CARRY_FORWARD;
   SQRADD2(a[5], a[7]); SQRADD(a[6], a[6]); 
 3b2:	fba9 0207 	umull	r0, r2, r9, r7
   SQRADD2(a[4], a[7]); SQRADD2(a[5], a[6]); 
 3b6:	eb43 0e03 	adc.w	lr, r3, r3
   SQRADD2(a[5], a[7]); SQRADD(a[6], a[6]); 
 3ba:	1841      	adds	r1, r0, r1
 3bc:	f142 0c00 	adc.w	ip, r2, #0
   SQRADD2(a[4], a[7]); SQRADD2(a[5], a[6]); 
 3c0:	4475      	add	r5, lr
   SQRADD2(a[5], a[7]); SQRADD(a[6], a[6]); 
 3c2:	eb15 050c 	adds.w	r5, r5, ip
 3c6:	eb43 0c03 	adc.w	ip, r3, r3
 3ca:	1841      	adds	r1, r0, r1
 3cc:	f142 0200 	adc.w	r2, r2, #0
 3d0:	1952      	adds	r2, r2, r5
 3d2:	461d      	mov	r5, r3
 3d4:	fbe4 1504 	umlal	r1, r5, r4, r4
 3d8:	f14c 0000 	adc.w	r0, ip, #0
 3dc:	6331      	str	r1, [r6, #48]	; 0x30
 3de:	1952      	adds	r2, r2, r5
   COMBA_STORE(b[12]);

   /* output 13 */
   CARRY_FORWARD;
   SQRADD2(a[6], a[7]); 
 3e0:	fba4 4107 	umull	r4, r1, r4, r7
   SQRADD2(a[5], a[7]); SQRADD(a[6], a[6]); 
 3e4:	eb43 0c03 	adc.w	ip, r3, r3
   SQRADD2(a[6], a[7]); 
 3e8:	1912      	adds	r2, r2, r4
 3ea:	f141 0500 	adc.w	r5, r1, #0
   SQRADD2(a[5], a[7]); SQRADD(a[6], a[6]); 
 3ee:	4460      	add	r0, ip
   SQRADD2(a[6], a[7]); 
 3f0:	1940      	adds	r0, r0, r5
 3f2:	eb43 0503 	adc.w	r5, r3, r3
 3f6:	18a4      	adds	r4, r4, r2
 3f8:	f141 0200 	adc.w	r2, r1, #0
 3fc:	1812      	adds	r2, r2, r0
   COMBA_STORE(b[13]);

   /* output 14 */
   CARRY_FORWARD;
   SQRADD(a[7], a[7]); 
 3fe:	4619      	mov	r1, r3
 400:	fbe7 2107 	umlal	r2, r1, r7, r7
 404:	eb45 0101 	adc.w	r1, r5, r1
 408:	63f1      	str	r1, [r6, #60]	; 0x3c
   COMBA_STORE(b[14]);
   COMBA_STORE2(b[15]);
   COMBA_FINI;

   B->used = 16;
 40a:	9902      	ldr	r1, [sp, #8]
   SQRADD(a[7], a[7]); 
 40c:	63b2      	str	r2, [r6, #56]	; 0x38
   B->sign = FP_ZPOS;
 40e:	604b      	str	r3, [r1, #4]
   XMEMCPY(B->dp, b, 16 * sizeof(fp_digit));
 410:	9b02      	ldr	r3, [sp, #8]
   SQRADD2(a[6], a[7]); 
 412:	6374      	str	r4, [r6, #52]	; 0x34
   B->used = 16;
 414:	2210      	movs	r2, #16
 416:	600a      	str	r2, [r1, #0]
   XMEMCPY(B->dp, b, 16 * sizeof(fp_digit));
 418:	f103 0008 	add.w	r0, r3, #8
 41c:	2240      	movs	r2, #64	; 0x40
 41e:	4631      	mov	r1, r6
 420:	f7ff fffe 	bl	0 <memcpy>
   fp_clamp(B);
 424:	9b02      	ldr	r3, [sp, #8]
 426:	681b      	ldr	r3, [r3, #0]
 428:	b13b      	cbz	r3, 43a <fp_sqr_comba8+0x43a>
 42a:	9902      	ldr	r1, [sp, #8]
 42c:	1e5a      	subs	r2, r3, #1
 42e:	3301      	adds	r3, #1
 430:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 434:	b153      	cbz	r3, 44c <fp_sqr_comba8+0x44c>
 436:	9b02      	ldr	r3, [sp, #8]
 438:	685b      	ldr	r3, [r3, #4]
 43a:	9a02      	ldr	r2, [sp, #8]

#ifdef WOLFSSL_SMALL_STACK
   XFREE(b, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 43c:	4630      	mov	r0, r6
   fp_clamp(B);
 43e:	6053      	str	r3, [r2, #4]
   XFREE(b, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 440:	f7ff fffe 	bl	0 <free>
#endif
   return FP_OKAY;
 444:	2000      	movs	r0, #0
}
 446:	b009      	add	sp, #36	; 0x24
 448:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   fp_clamp(B);
 44c:	9b02      	ldr	r3, [sp, #8]
 44e:	601a      	str	r2, [r3, #0]
 450:	e7e8      	b.n	424 <fp_sqr_comba8+0x424>
      return FP_MEM;
 452:	f06f 0001 	mvn.w	r0, #1
 456:	e7f6      	b.n	446 <fp_sqr_comba8+0x446>

Disassembly of section .text.fp_mul_comba8:

00000000 <fp_mul_comba8>:



#ifdef TFM_MUL8
int fp_mul_comba8(fp_int *A, fp_int *B, fp_int *C)
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b085      	sub	sp, #20
   6:	e9cd 0101 	strd	r0, r1, [sp, #4]
#else
   fp_digit *at;
#endif

#ifdef WOLFSSL_SMALL_STACK
   at = (fp_digit*)XMALLOC(sizeof(fp_digit) * 16, NULL, DYNAMIC_TYPE_TMP_BUFFER);
   a:	2040      	movs	r0, #64	; 0x40
{
   c:	4617      	mov	r7, r2
   at = (fp_digit*)XMALLOC(sizeof(fp_digit) * 16, NULL, DYNAMIC_TYPE_TMP_BUFFER);
   e:	f7ff fffe 	bl	0 <malloc>
   if (at == NULL)
  12:	4680      	mov	r8, r0
  14:	2800      	cmp	r0, #0
  16:	f000 824f 	beq.w	4b8 <fp_mul_comba8+0x4b8>
       return FP_MEM;
#endif

   XMEMCPY(at, A->dp, 8 * sizeof(fp_digit));
  1a:	9b01      	ldr	r3, [sp, #4]
  1c:	2220      	movs	r2, #32
  1e:	f103 0108 	add.w	r1, r3, #8
  22:	f7ff fffe 	bl	0 <memcpy>
   XMEMCPY(at+8, B->dp, 8 * sizeof(fp_digit));
  26:	9b02      	ldr	r3, [sp, #8]
  28:	2220      	movs	r2, #32
  2a:	f103 0108 	add.w	r1, r3, #8
  2e:	eb08 0002 	add.w	r0, r8, r2
  32:	f7ff fffe 	bl	0 <memcpy>
   COMBA_START;

   COMBA_CLEAR;
   /* 0 */
   MULADD(at[0], at[8]); 
  36:	f8d8 4000 	ldr.w	r4, [r8]
  3a:	f8d8 e020 	ldr.w	lr, [r8, #32]
   COMBA_STORE(C->dp[0]);
   /* 1 */
   COMBA_FORWARD;
   MULADD(at[0], at[9]);    MULADD(at[1], at[8]); 
  3e:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
   COMBA_STORE(C->dp[1]);
   /* 2 */
   COMBA_FORWARD;
   MULADD(at[0], at[10]);    MULADD(at[1], at[9]);    MULADD(at[2], at[8]); 
  42:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
   COMBA_STORE(C->dp[2]);
   /* 3 */
   COMBA_FORWARD;
   MULADD(at[0], at[11]);    MULADD(at[1], at[10]);    MULADD(at[2], at[9]);    MULADD(at[3], at[8]); 
  46:	f8d8 9008 	ldr.w	r9, [r8, #8]
   COMBA_FORWARD;
   MULADD(at[0], at[12]);    MULADD(at[1], at[11]);    MULADD(at[2], at[10]);    MULADD(at[3], at[9]);    MULADD(at[4], at[8]); 
   COMBA_STORE(C->dp[4]);
   /* 5 */
   COMBA_FORWARD;
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
  4a:	f8d8 a02c 	ldr.w	sl, [r8, #44]	; 0x2c
   MULADD(at[0], at[8]); 
  4e:	fba4 320e 	umull	r3, r2, r4, lr
  52:	60bb      	str	r3, [r7, #8]
  54:	2300      	movs	r3, #0
   MULADD(at[0], at[9]);    MULADD(at[1], at[8]); 
  56:	4619      	mov	r1, r3
  58:	fbe4 2100 	umlal	r2, r1, r4, r0
  5c:	f8d8 0004 	ldr.w	r0, [r8, #4]
  60:	9000      	str	r0, [sp, #0]
  62:	9d00      	ldr	r5, [sp, #0]
   MULADD(at[0], at[10]);    MULADD(at[1], at[9]);    MULADD(at[2], at[8]); 
  64:	f8dd c000 	ldr.w	ip, [sp]
   MULADD(at[0], at[9]);    MULADD(at[1], at[8]); 
  68:	4618      	mov	r0, r3
  6a:	fbee 2005 	umlal	r2, r0, lr, r5
   MULADD(at[0], at[10]);    MULADD(at[1], at[9]);    MULADD(at[2], at[8]); 
  6e:	f8d8 5028 	ldr.w	r5, [r8, #40]	; 0x28
   MULADD(at[0], at[9]);    MULADD(at[1], at[8]); 
  72:	60fa      	str	r2, [r7, #12]
  74:	1809      	adds	r1, r1, r0
   MULADD(at[0], at[10]);    MULADD(at[1], at[9]);    MULADD(at[2], at[8]); 
  76:	461a      	mov	r2, r3
  78:	fbe4 1205 	umlal	r1, r2, r4, r5
   MULADD(at[0], at[9]);    MULADD(at[1], at[8]); 
  7c:	eb43 0003 	adc.w	r0, r3, r3
   MULADD(at[0], at[10]);    MULADD(at[1], at[9]);    MULADD(at[2], at[8]); 
  80:	461d      	mov	r5, r3
  82:	fbe6 150c 	umlal	r1, r5, r6, ip
  86:	1882      	adds	r2, r0, r2
  88:	f8d8 6008 	ldr.w	r6, [r8, #8]
  8c:	eb43 0003 	adc.w	r0, r3, r3
  90:	1952      	adds	r2, r2, r5
  92:	461d      	mov	r5, r3
  94:	fbee 1506 	umlal	r1, r5, lr, r6
  98:	6139      	str	r1, [r7, #16]
   MULADD(at[0], at[11]);    MULADD(at[1], at[10]);    MULADD(at[2], at[9]);    MULADD(at[3], at[8]); 
  9a:	f8d8 102c 	ldr.w	r1, [r8, #44]	; 0x2c
  9e:	f8d8 6028 	ldr.w	r6, [r8, #40]	; 0x28
   MULADD(at[0], at[10]);    MULADD(at[1], at[9]);    MULADD(at[2], at[8]); 
  a2:	f140 0000 	adc.w	r0, r0, #0
  a6:	1952      	adds	r2, r2, r5
   MULADD(at[0], at[11]);    MULADD(at[1], at[10]);    MULADD(at[2], at[9]);    MULADD(at[3], at[8]); 
  a8:	461d      	mov	r5, r3
  aa:	fbe4 2501 	umlal	r2, r5, r4, r1
   MULADD(at[0], at[10]);    MULADD(at[1], at[9]);    MULADD(at[2], at[8]); 
  ae:	f140 0100 	adc.w	r1, r0, #0
   MULADD(at[0], at[11]);    MULADD(at[1], at[10]);    MULADD(at[2], at[9]);    MULADD(at[3], at[8]); 
  b2:	1949      	adds	r1, r1, r5
  b4:	461d      	mov	r5, r3
  b6:	fbec 2506 	umlal	r2, r5, ip, r6
  ba:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
  be:	eb43 0003 	adc.w	r0, r3, r3
  c2:	1949      	adds	r1, r1, r5
  c4:	461d      	mov	r5, r3
  c6:	fbe6 2509 	umlal	r2, r5, r6, r9
  ca:	f8d8 600c 	ldr.w	r6, [r8, #12]
  ce:	f140 0000 	adc.w	r0, r0, #0
  d2:	1949      	adds	r1, r1, r5
  d4:	461d      	mov	r5, r3
  d6:	fbee 2506 	umlal	r2, r5, lr, r6
  da:	f140 0000 	adc.w	r0, r0, #0
  de:	1949      	adds	r1, r1, r5
   MULADD(at[0], at[12]);    MULADD(at[1], at[11]);    MULADD(at[2], at[10]);    MULADD(at[3], at[9]);    MULADD(at[4], at[8]); 
  e0:	f8d8 5030 	ldr.w	r5, [r8, #48]	; 0x30
  e4:	f8d8 602c 	ldr.w	r6, [r8, #44]	; 0x2c
   MULADD(at[0], at[11]);    MULADD(at[1], at[10]);    MULADD(at[2], at[9]);    MULADD(at[3], at[8]); 
  e8:	617a      	str	r2, [r7, #20]
   MULADD(at[0], at[12]);    MULADD(at[1], at[11]);    MULADD(at[2], at[10]);    MULADD(at[3], at[9]);    MULADD(at[4], at[8]); 
  ea:	461a      	mov	r2, r3
  ec:	fbe4 1205 	umlal	r1, r2, r4, r5
   MULADD(at[0], at[11]);    MULADD(at[1], at[10]);    MULADD(at[2], at[9]);    MULADD(at[3], at[8]); 
  f0:	f140 0000 	adc.w	r0, r0, #0
   MULADD(at[0], at[12]);    MULADD(at[1], at[11]);    MULADD(at[2], at[10]);    MULADD(at[3], at[9]);    MULADD(at[4], at[8]); 
  f4:	461d      	mov	r5, r3
  f6:	fbec 1506 	umlal	r1, r5, ip, r6
  fa:	1880      	adds	r0, r0, r2
  fc:	f8d8 6028 	ldr.w	r6, [r8, #40]	; 0x28
 100:	eb43 0203 	adc.w	r2, r3, r3
 104:	1940      	adds	r0, r0, r5
 106:	461d      	mov	r5, r3
 108:	fbe6 1509 	umlal	r1, r5, r6, r9
 10c:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
 110:	f8d8 900c 	ldr.w	r9, [r8, #12]
 114:	f142 0200 	adc.w	r2, r2, #0
 118:	1940      	adds	r0, r0, r5
 11a:	460d      	mov	r5, r1
 11c:	4619      	mov	r1, r3
 11e:	fbe6 5109 	umlal	r5, r1, r6, r9
 122:	f8d8 6010 	ldr.w	r6, [r8, #16]
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 126:	f8d8 9034 	ldr.w	r9, [r8, #52]	; 0x34
   MULADD(at[0], at[12]);    MULADD(at[1], at[11]);    MULADD(at[2], at[10]);    MULADD(at[3], at[9]);    MULADD(at[4], at[8]); 
 12a:	f142 0200 	adc.w	r2, r2, #0
 12e:	1841      	adds	r1, r0, r1
 130:	4618      	mov	r0, r3
 132:	fbee 5006 	umlal	r5, r0, lr, r6
 136:	f142 0200 	adc.w	r2, r2, #0
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 13a:	f8d8 6030 	ldr.w	r6, [r8, #48]	; 0x30
   MULADD(at[0], at[12]);    MULADD(at[1], at[11]);    MULADD(at[2], at[10]);    MULADD(at[3], at[9]);    MULADD(at[4], at[8]); 
 13e:	61bd      	str	r5, [r7, #24]
 140:	1809      	adds	r1, r1, r0
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 142:	4618      	mov	r0, r3
 144:	fbe4 1009 	umlal	r1, r0, r4, r9
 148:	461d      	mov	r5, r3
   MULADD(at[0], at[12]);    MULADD(at[1], at[11]);    MULADD(at[2], at[10]);    MULADD(at[3], at[9]);    MULADD(at[4], at[8]); 
 14a:	f142 0200 	adc.w	r2, r2, #0
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 14e:	fbec 1506 	umlal	r1, r5, ip, r6
 152:	1812      	adds	r2, r2, r0
 154:	f8d8 6008 	ldr.w	r6, [r8, #8]
 158:	eb43 0003 	adc.w	r0, r3, r3
 15c:	1952      	adds	r2, r2, r5
 15e:	461d      	mov	r5, r3
 160:	fbe6 150a 	umlal	r1, r5, r6, sl
 164:	f8d8 a00c 	ldr.w	sl, [r8, #12]
 168:	f8d8 6028 	ldr.w	r6, [r8, #40]	; 0x28
 16c:	f140 0000 	adc.w	r0, r0, #0
 170:	1952      	adds	r2, r2, r5
 172:	461d      	mov	r5, r3
 174:	fbe6 150a 	umlal	r1, r5, r6, sl
 178:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
 17c:	f8d8 a010 	ldr.w	sl, [r8, #16]
   COMBA_STORE(C->dp[5]);
   /* 6 */
   COMBA_FORWARD;
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 180:	f8d8 b038 	ldr.w	fp, [r8, #56]	; 0x38
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 184:	f140 0000 	adc.w	r0, r0, #0
 188:	1952      	adds	r2, r2, r5
 18a:	461d      	mov	r5, r3
 18c:	fbe6 150a 	umlal	r1, r5, r6, sl
 190:	f8d8 a014 	ldr.w	sl, [r8, #20]
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 194:	f8d8 6008 	ldr.w	r6, [r8, #8]
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 198:	f140 0000 	adc.w	r0, r0, #0
 19c:	1952      	adds	r2, r2, r5
 19e:	461d      	mov	r5, r3
 1a0:	fbee 150a 	umlal	r1, r5, lr, sl
 1a4:	f140 0000 	adc.w	r0, r0, #0
 1a8:	1952      	adds	r2, r2, r5
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 1aa:	461d      	mov	r5, r3
 1ac:	fbe4 250b 	umlal	r2, r5, r4, fp
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 1b0:	61f9      	str	r1, [r7, #28]
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 1b2:	4611      	mov	r1, r2
   MULADD(at[0], at[13]);    MULADD(at[1], at[12]);    MULADD(at[2], at[11]);    MULADD(at[3], at[10]);    MULADD(at[4], at[9]);    MULADD(at[5], at[8]); 
 1b4:	f140 0200 	adc.w	r2, r0, #0
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 1b8:	4618      	mov	r0, r3
 1ba:	fbec 1009 	umlal	r1, r0, ip, r9
 1be:	1952      	adds	r2, r2, r5
 1c0:	f8d8 c030 	ldr.w	ip, [r8, #48]	; 0x30
 1c4:	eb43 0503 	adc.w	r5, r3, r3
 1c8:	1812      	adds	r2, r2, r0
 1ca:	4618      	mov	r0, r3
 1cc:	fbe6 100c 	umlal	r1, r0, r6, ip
 1d0:	f8d8 602c 	ldr.w	r6, [r8, #44]	; 0x2c
 1d4:	f8d8 c00c 	ldr.w	ip, [r8, #12]
 1d8:	f145 0500 	adc.w	r5, r5, #0
 1dc:	1812      	adds	r2, r2, r0
 1de:	4618      	mov	r0, r3
 1e0:	fbe6 100c 	umlal	r1, r0, r6, ip
 1e4:	f8d8 6028 	ldr.w	r6, [r8, #40]	; 0x28
 1e8:	f8d8 c010 	ldr.w	ip, [r8, #16]
 1ec:	f145 0500 	adc.w	r5, r5, #0
 1f0:	1812      	adds	r2, r2, r0
 1f2:	4618      	mov	r0, r3
 1f4:	fbe6 100c 	umlal	r1, r0, r6, ip
 1f8:	f8d8 6024 	ldr.w	r6, [r8, #36]	; 0x24
   COMBA_STORE(C->dp[6]);
   /* 7 */
   COMBA_FORWARD;
   MULADD(at[0], at[15]);    MULADD(at[1], at[14]);    MULADD(at[2], at[13]);    MULADD(at[3], at[12]);    MULADD(at[4], at[11]);    MULADD(at[5], at[10]);    MULADD(at[6], at[9]);    MULADD(at[7], at[8]); 
 1fc:	f8dd c000 	ldr.w	ip, [sp]
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 200:	f145 0500 	adc.w	r5, r5, #0
 204:	1812      	adds	r2, r2, r0
 206:	4618      	mov	r0, r3
 208:	fbe6 100a 	umlal	r1, r0, r6, sl
 20c:	f145 0500 	adc.w	r5, r5, #0
 210:	1812      	adds	r2, r2, r0
 212:	f8d8 0018 	ldr.w	r0, [r8, #24]
 216:	461e      	mov	r6, r3
 218:	fbee 1600 	umlal	r1, r6, lr, r0
 21c:	6239      	str	r1, [r7, #32]
   MULADD(at[0], at[15]);    MULADD(at[1], at[14]);    MULADD(at[2], at[13]);    MULADD(at[3], at[12]);    MULADD(at[4], at[11]);    MULADD(at[5], at[10]);    MULADD(at[6], at[9]);    MULADD(at[7], at[8]); 
 21e:	f8d8 103c 	ldr.w	r1, [r8, #60]	; 0x3c
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 222:	f145 0500 	adc.w	r5, r5, #0
 226:	1996      	adds	r6, r2, r6
   MULADD(at[0], at[15]);    MULADD(at[1], at[14]);    MULADD(at[2], at[13]);    MULADD(at[3], at[12]);    MULADD(at[4], at[11]);    MULADD(at[5], at[10]);    MULADD(at[6], at[9]);    MULADD(at[7], at[8]); 
 228:	461a      	mov	r2, r3
 22a:	fbe4 6201 	umlal	r6, r2, r4, r1
   MULADD(at[0], at[14]);    MULADD(at[1], at[13]);    MULADD(at[2], at[12]);    MULADD(at[3], at[11]);    MULADD(at[4], at[10]);    MULADD(at[5], at[9]);    MULADD(at[6], at[8]); 
 22e:	f145 0400 	adc.w	r4, r5, #0
   MULADD(at[0], at[15]);    MULADD(at[1], at[14]);    MULADD(at[2], at[13]);    MULADD(at[3], at[12]);    MULADD(at[4], at[11]);    MULADD(at[5], at[10]);    MULADD(at[6], at[9]);    MULADD(at[7], at[8]); 
 232:	18a4      	adds	r4, r4, r2
 234:	461a      	mov	r2, r3
 236:	fbec 620b 	umlal	r6, r2, ip, fp
 23a:	f8d8 c008 	ldr.w	ip, [r8, #8]
 23e:	eb43 0503 	adc.w	r5, r3, r3
 242:	18a4      	adds	r4, r4, r2
 244:	461a      	mov	r2, r3
 246:	fbec 6209 	umlal	r6, r2, ip, r9
 24a:	f145 0500 	adc.w	r5, r5, #0
 24e:	f8d8 c00c 	ldr.w	ip, [r8, #12]
 252:	18a2      	adds	r2, r4, r2
 254:	f8d8 4030 	ldr.w	r4, [r8, #48]	; 0x30
 258:	9203      	str	r2, [sp, #12]
 25a:	461a      	mov	r2, r3
 25c:	fbec 6204 	umlal	r6, r2, ip, r4
 260:	9c03      	ldr	r4, [sp, #12]
 262:	f8d8 c02c 	ldr.w	ip, [r8, #44]	; 0x2c
 266:	f145 0500 	adc.w	r5, r5, #0
 26a:	18a2      	adds	r2, r4, r2
 26c:	f8d8 4010 	ldr.w	r4, [r8, #16]
 270:	9203      	str	r2, [sp, #12]
 272:	461a      	mov	r2, r3
 274:	fbec 6204 	umlal	r6, r2, ip, r4
 278:	9c03      	ldr	r4, [sp, #12]
 27a:	f8d8 c028 	ldr.w	ip, [r8, #40]	; 0x28
 27e:	f145 0500 	adc.w	r5, r5, #0
 282:	18a4      	adds	r4, r4, r2
 284:	461a      	mov	r2, r3
 286:	fbec 620a 	umlal	r6, r2, ip, sl
 28a:	f8d8 c024 	ldr.w	ip, [r8, #36]	; 0x24
 28e:	f145 0500 	adc.w	r5, r5, #0
 292:	18a4      	adds	r4, r4, r2
 294:	461a      	mov	r2, r3
 296:	fbec 6200 	umlal	r6, r2, ip, r0
 29a:	f145 0500 	adc.w	r5, r5, #0
 29e:	18a4      	adds	r4, r4, r2
 2a0:	f8d8 201c 	ldr.w	r2, [r8, #28]
 2a4:	f145 0c00 	adc.w	ip, r5, #0
 2a8:	461d      	mov	r5, r3
 2aa:	fbee 6502 	umlal	r6, r5, lr, r2
 2ae:	1964      	adds	r4, r4, r5
   COMBA_STORE(C->dp[7]);
   /* 8 */
   COMBA_FORWARD;
   MULADD(at[1], at[15]);    MULADD(at[2], at[14]);    MULADD(at[3], at[13]);    MULADD(at[4], at[12]);    MULADD(at[5], at[11]);    MULADD(at[6], at[10]);    MULADD(at[7], at[9]); 
 2b0:	9d00      	ldr	r5, [sp, #0]
   MULADD(at[0], at[15]);    MULADD(at[1], at[14]);    MULADD(at[2], at[13]);    MULADD(at[3], at[12]);    MULADD(at[4], at[11]);    MULADD(at[5], at[10]);    MULADD(at[6], at[9]);    MULADD(at[7], at[8]); 
 2b2:	627e      	str	r6, [r7, #36]	; 0x24
   MULADD(at[1], at[15]);    MULADD(at[2], at[14]);    MULADD(at[3], at[13]);    MULADD(at[4], at[12]);    MULADD(at[5], at[11]);    MULADD(at[6], at[10]);    MULADD(at[7], at[9]); 
 2b4:	4626      	mov	r6, r4
 2b6:	461c      	mov	r4, r3
 2b8:	fbe5 6401 	umlal	r6, r4, r5, r1
 2bc:	f8d8 e008 	ldr.w	lr, [r8, #8]
   MULADD(at[0], at[15]);    MULADD(at[1], at[14]);    MULADD(at[2], at[13]);    MULADD(at[3], at[12]);    MULADD(at[4], at[11]);    MULADD(at[5], at[10]);    MULADD(at[6], at[9]);    MULADD(at[7], at[8]); 
 2c0:	f14c 0c00 	adc.w	ip, ip, #0
   MULADD(at[1], at[15]);    MULADD(at[2], at[14]);    MULADD(at[3], at[13]);    MULADD(at[4], at[12]);    MULADD(at[5], at[11]);    MULADD(at[6], at[10]);    MULADD(at[7], at[9]); 
 2c4:	eb1c 0c04 	adds.w	ip, ip, r4
 2c8:	461c      	mov	r4, r3
 2ca:	fbee 640b 	umlal	r6, r4, lr, fp
 2ce:	f8d8 e00c 	ldr.w	lr, [r8, #12]
 2d2:	eb43 0503 	adc.w	r5, r3, r3
 2d6:	eb1c 0c04 	adds.w	ip, ip, r4
 2da:	461c      	mov	r4, r3
 2dc:	fbee 6409 	umlal	r6, r4, lr, r9
 2e0:	f145 0500 	adc.w	r5, r5, #0
 2e4:	eb1c 0c04 	adds.w	ip, ip, r4
 2e8:	f145 0400 	adc.w	r4, r5, #0
 2ec:	9400      	str	r4, [sp, #0]
 2ee:	f8d8 e030 	ldr.w	lr, [r8, #48]	; 0x30
 2f2:	f8d8 5010 	ldr.w	r5, [r8, #16]
 2f6:	461c      	mov	r4, r3
 2f8:	fbee 6405 	umlal	r6, r4, lr, r5
 2fc:	f8d8 e02c 	ldr.w	lr, [r8, #44]	; 0x2c
 300:	9d00      	ldr	r5, [sp, #0]
 302:	eb1c 0404 	adds.w	r4, ip, r4
 306:	469c      	mov	ip, r3
 308:	fbee 6c0a 	umlal	r6, ip, lr, sl
 30c:	f8d8 e028 	ldr.w	lr, [r8, #40]	; 0x28
 310:	f145 0500 	adc.w	r5, r5, #0
 314:	eb14 0c0c 	adds.w	ip, r4, ip
 318:	461c      	mov	r4, r3
 31a:	fbee 6400 	umlal	r6, r4, lr, r0
 31e:	f8d8 e024 	ldr.w	lr, [r8, #36]	; 0x24
 322:	f145 0500 	adc.w	r5, r5, #0
 326:	eb1c 0404 	adds.w	r4, ip, r4
 32a:	469c      	mov	ip, r3
 32c:	fbee 6c02 	umlal	r6, ip, lr, r2
 330:	f145 0500 	adc.w	r5, r5, #0
 334:	eb14 040c 	adds.w	r4, r4, ip
   COMBA_STORE(C->dp[8]);
   /* 9 */
   COMBA_FORWARD;
   MULADD(at[2], at[15]);    MULADD(at[3], at[14]);    MULADD(at[4], at[13]);    MULADD(at[5], at[12]);    MULADD(at[6], at[11]);    MULADD(at[7], at[10]); 
 338:	f8d8 c008 	ldr.w	ip, [r8, #8]
 33c:	f8d8 e00c 	ldr.w	lr, [r8, #12]
   MULADD(at[1], at[15]);    MULADD(at[2], at[14]);    MULADD(at[3], at[13]);    MULADD(at[4], at[12]);    MULADD(at[5], at[11]);    MULADD(at[6], at[10]);    MULADD(at[7], at[9]); 
 340:	62be      	str	r6, [r7, #40]	; 0x28
   MULADD(at[2], at[15]);    MULADD(at[3], at[14]);    MULADD(at[4], at[13]);    MULADD(at[5], at[12]);    MULADD(at[6], at[11]);    MULADD(at[7], at[10]); 
 342:	461e      	mov	r6, r3
 344:	fbec 4601 	umlal	r4, r6, ip, r1
   MULADD(at[1], at[15]);    MULADD(at[2], at[14]);    MULADD(at[3], at[13]);    MULADD(at[4], at[12]);    MULADD(at[5], at[11]);    MULADD(at[6], at[10]);    MULADD(at[7], at[9]); 
 348:	f145 0500 	adc.w	r5, r5, #0
   MULADD(at[2], at[15]);    MULADD(at[3], at[14]);    MULADD(at[4], at[13]);    MULADD(at[5], at[12]);    MULADD(at[6], at[11]);    MULADD(at[7], at[10]); 
 34c:	469c      	mov	ip, r3
 34e:	fbee 4c0b 	umlal	r4, ip, lr, fp
 352:	19ad      	adds	r5, r5, r6
 354:	f8d8 e010 	ldr.w	lr, [r8, #16]
 358:	eb43 0603 	adc.w	r6, r3, r3
 35c:	eb15 050c 	adds.w	r5, r5, ip
 360:	469c      	mov	ip, r3
 362:	fbee 4c09 	umlal	r4, ip, lr, r9
 366:	f8d8 e030 	ldr.w	lr, [r8, #48]	; 0x30
 36a:	f146 0600 	adc.w	r6, r6, #0
 36e:	eb15 050c 	adds.w	r5, r5, ip
 372:	469c      	mov	ip, r3
 374:	fbee 4c0a 	umlal	r4, ip, lr, sl
 378:	f8d8 e02c 	ldr.w	lr, [r8, #44]	; 0x2c
 37c:	f146 0600 	adc.w	r6, r6, #0
 380:	eb15 050c 	adds.w	r5, r5, ip
 384:	469c      	mov	ip, r3
 386:	fbee 4c00 	umlal	r4, ip, lr, r0
 38a:	f8d8 e028 	ldr.w	lr, [r8, #40]	; 0x28
 38e:	f146 0600 	adc.w	r6, r6, #0
 392:	eb15 050c 	adds.w	r5, r5, ip
 396:	469c      	mov	ip, r3
 398:	fbee 4c02 	umlal	r4, ip, lr, r2
 39c:	f146 0600 	adc.w	r6, r6, #0
 3a0:	eb15 050c 	adds.w	r5, r5, ip
   COMBA_STORE(C->dp[9]);
   /* 10 */
   COMBA_FORWARD;
   MULADD(at[3], at[15]);    MULADD(at[4], at[14]);    MULADD(at[5], at[13]);    MULADD(at[6], at[12]);    MULADD(at[7], at[11]); 
 3a4:	f8d8 c00c 	ldr.w	ip, [r8, #12]
   MULADD(at[2], at[15]);    MULADD(at[3], at[14]);    MULADD(at[4], at[13]);    MULADD(at[5], at[12]);    MULADD(at[6], at[11]);    MULADD(at[7], at[10]); 
 3a8:	62fc      	str	r4, [r7, #44]	; 0x2c
   MULADD(at[3], at[15]);    MULADD(at[4], at[14]);    MULADD(at[5], at[13]);    MULADD(at[6], at[12]);    MULADD(at[7], at[11]); 
 3aa:	461c      	mov	r4, r3
 3ac:	fbec 5401 	umlal	r5, r4, ip, r1
   MULADD(at[2], at[15]);    MULADD(at[3], at[14]);    MULADD(at[4], at[13]);    MULADD(at[5], at[12]);    MULADD(at[6], at[11]);    MULADD(at[7], at[10]); 
 3b0:	f146 0600 	adc.w	r6, r6, #0
   MULADD(at[3], at[15]);    MULADD(at[4], at[14]);    MULADD(at[5], at[13]);    MULADD(at[6], at[12]);    MULADD(at[7], at[11]); 
 3b4:	f8d8 c010 	ldr.w	ip, [r8, #16]
 3b8:	1934      	adds	r4, r6, r4
 3ba:	461e      	mov	r6, r3
 3bc:	fbec 560b 	umlal	r5, r6, ip, fp
 3c0:	eb43 0e03 	adc.w	lr, r3, r3
 3c4:	19a4      	adds	r4, r4, r6
 3c6:	461e      	mov	r6, r3
 3c8:	f8d8 c030 	ldr.w	ip, [r8, #48]	; 0x30
 3cc:	fbe9 560a 	umlal	r5, r6, r9, sl
 3d0:	f14e 0e00 	adc.w	lr, lr, #0
 3d4:	19a6      	adds	r6, r4, r6
 3d6:	461c      	mov	r4, r3
 3d8:	fbec 5400 	umlal	r5, r4, ip, r0
 3dc:	f14e 0e00 	adc.w	lr, lr, #0
 3e0:	1934      	adds	r4, r6, r4
 3e2:	f14e 0600 	adc.w	r6, lr, #0
 3e6:	f8d8 e02c 	ldr.w	lr, [r8, #44]	; 0x2c
 3ea:	469c      	mov	ip, r3
 3ec:	fbee 5c02 	umlal	r5, ip, lr, r2
 3f0:	eb14 040c 	adds.w	r4, r4, ip
   COMBA_STORE(C->dp[10]);
   /* 11 */
   COMBA_FORWARD;
   MULADD(at[4], at[15]);    MULADD(at[5], at[14]);    MULADD(at[6], at[13]);    MULADD(at[7], at[12]); 
 3f4:	f8d8 c010 	ldr.w	ip, [r8, #16]
   MULADD(at[3], at[15]);    MULADD(at[4], at[14]);    MULADD(at[5], at[13]);    MULADD(at[6], at[12]);    MULADD(at[7], at[11]); 
 3f8:	633d      	str	r5, [r7, #48]	; 0x30
   MULADD(at[4], at[15]);    MULADD(at[5], at[14]);    MULADD(at[6], at[13]);    MULADD(at[7], at[12]); 
 3fa:	461d      	mov	r5, r3
 3fc:	fbec 4501 	umlal	r4, r5, ip, r1
   MULADD(at[3], at[15]);    MULADD(at[4], at[14]);    MULADD(at[5], at[13]);    MULADD(at[6], at[12]);    MULADD(at[7], at[11]); 
 400:	f146 0600 	adc.w	r6, r6, #0
   MULADD(at[4], at[15]);    MULADD(at[5], at[14]);    MULADD(at[6], at[13]);    MULADD(at[7], at[12]); 
 404:	469c      	mov	ip, r3
 406:	fbea 4c0b 	umlal	r4, ip, sl, fp
 40a:	1976      	adds	r6, r6, r5
 40c:	eb43 0503 	adc.w	r5, r3, r3
 410:	eb16 060c 	adds.w	r6, r6, ip
 414:	469c      	mov	ip, r3
 416:	fbe9 4c00 	umlal	r4, ip, r9, r0
 41a:	f8d8 e030 	ldr.w	lr, [r8, #48]	; 0x30
 41e:	f145 0500 	adc.w	r5, r5, #0
 422:	eb16 060c 	adds.w	r6, r6, ip
 426:	469c      	mov	ip, r3
 428:	fbee 4c02 	umlal	r4, ip, lr, r2
 42c:	f145 0500 	adc.w	r5, r5, #0
 430:	637c      	str	r4, [r7, #52]	; 0x34
 432:	eb16 060c 	adds.w	r6, r6, ip
   COMBA_STORE(C->dp[11]);
   /* 12 */
   COMBA_FORWARD;
   MULADD(at[5], at[15]);    MULADD(at[6], at[14]);    MULADD(at[7], at[13]); 
 436:	461c      	mov	r4, r3
 438:	fbea 6401 	umlal	r6, r4, sl, r1
 43c:	469c      	mov	ip, r3
   MULADD(at[4], at[15]);    MULADD(at[5], at[14]);    MULADD(at[6], at[13]);    MULADD(at[7], at[12]); 
 43e:	f145 0500 	adc.w	r5, r5, #0
   MULADD(at[5], at[15]);    MULADD(at[6], at[14]);    MULADD(at[7], at[13]); 
 442:	fbeb 6c00 	umlal	r6, ip, fp, r0
 446:	192d      	adds	r5, r5, r4
 448:	eb43 0403 	adc.w	r4, r3, r3
 44c:	eb15 050c 	adds.w	r5, r5, ip
 450:	469c      	mov	ip, r3
 452:	fbe9 6c02 	umlal	r6, ip, r9, r2
 456:	f144 0400 	adc.w	r4, r4, #0
 45a:	63be      	str	r6, [r7, #56]	; 0x38
 45c:	eb15 050c 	adds.w	r5, r5, ip
   COMBA_STORE(C->dp[12]);
   /* 13 */
   COMBA_FORWARD;
   MULADD(at[6], at[15]);    MULADD(at[7], at[14]); 
 460:	461e      	mov	r6, r3
 462:	fbe0 5601 	umlal	r5, r6, r0, r1
   MULADD(at[5], at[15]);    MULADD(at[6], at[14]);    MULADD(at[7], at[13]); 
 466:	f144 0000 	adc.w	r0, r4, #0
   MULADD(at[6], at[15]);    MULADD(at[7], at[14]); 
 46a:	1980      	adds	r0, r0, r6
 46c:	461e      	mov	r6, r3
 46e:	fbeb 5602 	umlal	r5, r6, fp, r2
 472:	eb43 0403 	adc.w	r4, r3, r3
 476:	1980      	adds	r0, r0, r6
   COMBA_STORE(C->dp[13]);
   /* 14 */
   COMBA_FORWARD;
   MULADD(at[7], at[15]); 
 478:	fbe1 0302 	umlal	r0, r3, r1, r2
 47c:	eb44 0303 	adc.w	r3, r4, r3
 480:	647b      	str	r3, [r7, #68]	; 0x44
   COMBA_STORE(C->dp[14]);
   COMBA_STORE2(C->dp[15]);
   C->used = 16;
 482:	2310      	movs	r3, #16
 484:	603b      	str	r3, [r7, #0]
   C->sign = A->sign ^ B->sign;
 486:	9b01      	ldr	r3, [sp, #4]
   MULADD(at[6], at[15]);    MULADD(at[7], at[14]); 
 488:	63fd      	str	r5, [r7, #60]	; 0x3c
   C->sign = A->sign ^ B->sign;
 48a:	6859      	ldr	r1, [r3, #4]
 48c:	9b02      	ldr	r3, [sp, #8]
   MULADD(at[7], at[15]); 
 48e:	6438      	str	r0, [r7, #64]	; 0x40
   C->sign = A->sign ^ B->sign;
 490:	685a      	ldr	r2, [r3, #4]
   fp_clamp(C);
 492:	683b      	ldr	r3, [r7, #0]
 494:	b133      	cbz	r3, 4a4 <fp_mul_comba8+0x4a4>
 496:	1e58      	subs	r0, r3, #1
 498:	3301      	adds	r3, #1
 49a:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
 49e:	b14b      	cbz	r3, 4b4 <fp_mul_comba8+0x4b4>
   C->sign = A->sign ^ B->sign;
 4a0:	ea81 0302 	eor.w	r3, r1, r2
   COMBA_FINI;

#ifdef WOLFSSL_SMALL_STACK
   XFREE(at, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 4a4:	4640      	mov	r0, r8
   fp_clamp(C);
 4a6:	607b      	str	r3, [r7, #4]
   XFREE(at, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 4a8:	f7ff fffe 	bl	0 <free>
#endif
   return FP_OKAY;
 4ac:	2000      	movs	r0, #0
}
 4ae:	b005      	add	sp, #20
 4b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   fp_clamp(C);
 4b4:	6038      	str	r0, [r7, #0]
 4b6:	e7ec      	b.n	492 <fp_mul_comba8+0x492>
       return FP_MEM;
 4b8:	f06f 0001 	mvn.w	r0, #1
 4bc:	e7f7      	b.n	4ae <fp_mul_comba8+0x4ae>

Disassembly of section .text.CheckRunTimeSettings:

00000000 <CheckRunTimeSettings>:
}
   0:	2020      	movs	r0, #32
   2:	4770      	bx	lr

Disassembly of section .text.CheckRunTimeFastMath:

00000000 <CheckRunTimeFastMath>:
}
   0:	2018      	movs	r0, #24
   2:	4770      	bx	lr

Disassembly of section .text.s_fp_add:

00000000 <s_fp_add>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  y       = MAX(a->used, b->used);
   4:	6803      	ldr	r3, [r0, #0]
   6:	680c      	ldr	r4, [r1, #0]
  oldused = MIN(c->used, FP_SIZE);   /* help static analysis w/ largest size */
   8:	6817      	ldr	r7, [r2, #0]
  y       = MAX(a->used, b->used);
   a:	42a3      	cmp	r3, r4
   c:	bfb8      	it	lt
   e:	4623      	movlt	r3, r4
  oldused = MIN(c->used, FP_SIZE);   /* help static analysis w/ largest size */
  10:	2f18      	cmp	r7, #24
  12:	bfa8      	it	ge
  14:	2718      	movge	r7, #24
  t = 0;
  16:	2500      	movs	r5, #0
  oldused = MIN(c->used, FP_SIZE);   /* help static analysis w/ largest size */
  18:	46b8      	mov	r8, r7
  c->used = y;
  1a:	6013      	str	r3, [r2, #0]
  for (x = 0; x < y; x++) {
  1c:	2401      	movs	r4, #1
      t         += ((fp_word)a->dp[x]) + ((fp_word)b->dp[x]);
  1e:	46ac      	mov	ip, r5
  for (x = 0; x < y; x++) {
  20:	1c66      	adds	r6, r4, #1
  22:	3c01      	subs	r4, #1
  24:	42a3      	cmp	r3, r4
  26:	dc1b      	bgt.n	60 <s_fp_add+0x60>
  28:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
  if (t != 0) {
  2c:	b135      	cbz	r5, 3c <s_fp_add+0x3c>
     if (x == FP_SIZE)
  2e:	2b18      	cmp	r3, #24
  30:	d02a      	beq.n	88 <s_fp_add+0x88>
     c->dp[c->used++] = (fp_digit)t;
  32:	3302      	adds	r3, #2
  34:	2001      	movs	r0, #1
  36:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
     ++x;
  3a:	4401      	add	r1, r0
  c->used = x;
  3c:	4613      	mov	r3, r2
     c->dp[x] = 0;
  3e:	2000      	movs	r0, #0
  c->used = x;
  40:	f843 1b08 	str.w	r1, [r3], #8
  for (; x < oldused; x++) {
  44:	4541      	cmp	r1, r8
  46:	db19      	blt.n	7c <s_fp_add+0x7c>
  fp_clamp(c);
  48:	6813      	ldr	r3, [r2, #0]
  4a:	b12b      	cbz	r3, 58 <s_fp_add+0x58>
  4c:	1e59      	subs	r1, r3, #1
  4e:	3301      	adds	r3, #1
  50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  54:	b1b3      	cbz	r3, 84 <s_fp_add+0x84>
  56:	6853      	ldr	r3, [r2, #4]
  58:	6053      	str	r3, [r2, #4]
  return FP_OKAY;
  5a:	2000      	movs	r0, #0
}
  5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      t         += ((fp_word)a->dp[x]) + ((fp_word)b->dp[x]);
  60:	f850 4026 	ldr.w	r4, [r0, r6, lsl #2]
  64:	f851 7026 	ldr.w	r7, [r1, r6, lsl #2]
  68:	19e4      	adds	r4, r4, r7
  6a:	eb4c 0e0c 	adc.w	lr, ip, ip
  6e:	1964      	adds	r4, r4, r5
      c->dp[x]   = (fp_digit)t;
  70:	f842 4026 	str.w	r4, [r2, r6, lsl #2]
      t        >>= DIGIT_BIT;
  74:	f14e 0500 	adc.w	r5, lr, #0
  78:	4634      	mov	r4, r6
  7a:	e7d1      	b.n	20 <s_fp_add+0x20>
     c->dp[x] = 0;
  7c:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
  for (; x < oldused; x++) {
  80:	3101      	adds	r1, #1
  82:	e7df      	b.n	44 <s_fp_add+0x44>
  fp_clamp(c);
  84:	6011      	str	r1, [r2, #0]
  86:	e7df      	b.n	48 <s_fp_add+0x48>
         return FP_VAL;
  88:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  8c:	e7e6      	b.n	5c <s_fp_add+0x5c>

Disassembly of section .text.s_fp_sub:

00000000 <s_fp_sub>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
  c->used  = a->used;
   2:	6807      	ldr	r7, [r0, #0]
  oldused  = c->used;
   4:	6816      	ldr	r6, [r2, #0]
  oldbused = b->used;
   6:	680b      	ldr	r3, [r1, #0]
  c->used  = a->used;
   8:	6017      	str	r7, [r2, #0]
  for (x = 0; x < oldbused; x++) {
   a:	2401      	movs	r4, #1
  t       = 0;
   c:	2500      	movs	r5, #0
  for (x = 0; x < oldbused; x++) {
   e:	f104 0c01 	add.w	ip, r4, #1
  12:	3c01      	subs	r4, #1
  14:	42a3      	cmp	r3, r4
  16:	dc1b      	bgt.n	50 <s_fp_sub+0x50>
  18:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
  1c:	1c59      	adds	r1, r3, #1
  for (; x < a->used; x++) {
  1e:	f101 0c01 	add.w	ip, r1, #1
  22:	3901      	subs	r1, #1
  24:	428f      	cmp	r7, r1
  26:	dc24      	bgt.n	72 <s_fp_sub+0x72>
  28:	1af9      	subs	r1, r7, r3
  2a:	429f      	cmp	r7, r3
  2c:	bfb8      	it	lt
  2e:	2100      	movlt	r1, #0
  30:	440b      	add	r3, r1
     c->dp[x] = 0;
  32:	2000      	movs	r0, #0
  34:	f102 0108 	add.w	r1, r2, #8
  for (; x < oldused; x++) {
  38:	42b3      	cmp	r3, r6
  3a:	db24      	blt.n	86 <s_fp_sub+0x86>
  fp_clamp(c);
  3c:	6813      	ldr	r3, [r2, #0]
  3e:	b12b      	cbz	r3, 4c <s_fp_sub+0x4c>
  40:	1e59      	subs	r1, r3, #1
  42:	3301      	adds	r3, #1
  44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  48:	b30b      	cbz	r3, 8e <s_fp_sub+0x8e>
  4a:	6853      	ldr	r3, [r2, #4]
  4c:	6053      	str	r3, [r2, #4]
}
  4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
     t         = ((fp_word)a->dp[x]) - (((fp_word)b->dp[x]) + t);
  50:	f851 e02c 	ldr.w	lr, [r1, ip, lsl #2]
  54:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
  58:	ebb4 040e 	subs.w	r4, r4, lr
  5c:	eb6e 0e0e 	sbc.w	lr, lr, lr
  60:	1b64      	subs	r4, r4, r5
  62:	f16e 0500 	sbc.w	r5, lr, #0
     c->dp[x]  = (fp_digit)t;
  66:	f842 402c 	str.w	r4, [r2, ip, lsl #2]
     t         = (t >> DIGIT_BIT)&1;
  6a:	f005 0501 	and.w	r5, r5, #1
  6e:	4664      	mov	r4, ip
  70:	e7cd      	b.n	e <s_fp_sub+0xe>
     t         = ((fp_word)a->dp[x]) - t;
  72:	f850 402c 	ldr.w	r4, [r0, ip, lsl #2]
  76:	1b64      	subs	r4, r4, r5
     c->dp[x]  = (fp_digit)t;
  78:	f842 402c 	str.w	r4, [r2, ip, lsl #2]
     t         = (t >> DIGIT_BIT)&1;
  7c:	bf34      	ite	cc
  7e:	2501      	movcc	r5, #1
  80:	2500      	movcs	r5, #0
  82:	4661      	mov	r1, ip
  84:	e7cb      	b.n	1e <s_fp_sub+0x1e>
     c->dp[x] = 0;
  86:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  for (; x < oldused; x++) {
  8a:	3301      	adds	r3, #1
  8c:	e7d4      	b.n	38 <s_fp_sub+0x38>
  fp_clamp(c);
  8e:	6011      	str	r1, [r2, #0]
  90:	e7d4      	b.n	3c <s_fp_sub+0x3c>

Disassembly of section .text.fp_mul_2:

00000000 <fp_mul_2>:
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
   0:	6802      	ldr	r2, [r0, #0]
   2:	2a17      	cmp	r2, #23
{
   4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if ((a->used > (FP_SIZE-1)) || ((a->used == (FP_SIZE - 1)) &&
   6:	dc2d      	bgt.n	64 <fp_mul_2+0x64>
   8:	d102      	bne.n	10 <fp_mul_2+0x10>
   a:	6e43      	ldr	r3, [r0, #100]	; 0x64
   c:	2b00      	cmp	r3, #0
   e:	db29      	blt.n	64 <fp_mul_2+0x64>
  b->used = a->used;
  10:	460b      	mov	r3, r1
  oldused = b->used;
  12:	f8d1 c000 	ldr.w	ip, [r1]
  b->used = a->used;
  16:	f843 2b08 	str.w	r2, [r3], #8
    r = 0;
  1a:	2200      	movs	r2, #0
    tmpa = a->dp;
  1c:	f100 0608 	add.w	r6, r0, #8
    tmpb = b->dp;
  20:	461c      	mov	r4, r3
    for (x = 0; x < a->used; x++) {
  22:	4615      	mov	r5, r2
  24:	6807      	ldr	r7, [r0, #0]
  26:	42af      	cmp	r7, r5
  28:	dc0f      	bgt.n	4a <fp_mul_2+0x4a>
    if (r != 0) {
  2a:	b122      	cbz	r2, 36 <fp_mul_2+0x36>
      *tmpb = 1;
  2c:	2201      	movs	r2, #1
  2e:	6022      	str	r2, [r4, #0]
      ++(b->used);
  30:	680a      	ldr	r2, [r1, #0]
  32:	3201      	adds	r2, #1
  34:	600a      	str	r2, [r1, #0]
    tmpb = b->dp + b->used;
  36:	680a      	ldr	r2, [r1, #0]
  38:	2400      	movs	r4, #0
  3a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    for (x = b->used; x < oldused; x++) {
  3e:	4562      	cmp	r2, ip
  40:	db0c      	blt.n	5c <fp_mul_2+0x5c>
  b->sign = a->sign;
  42:	6843      	ldr	r3, [r0, #4]
  44:	604b      	str	r3, [r1, #4]
  return FP_OKAY;
  46:	2000      	movs	r0, #0
}
  48:	bdf0      	pop	{r4, r5, r6, r7, pc}
      rr = *tmpa >> ((fp_digit)(DIGIT_BIT - 1));
  4a:	f856 7b04 	ldr.w	r7, [r6], #4
      *tmpb++ = ((*tmpa++ << ((fp_digit)1)) | r);
  4e:	ea42 0247 	orr.w	r2, r2, r7, lsl #1
  52:	f844 2b04 	str.w	r2, [r4], #4
    for (x = 0; x < a->used; x++) {
  56:	3501      	adds	r5, #1
      r = rr;
  58:	0ffa      	lsrs	r2, r7, #31
  5a:	e7e3      	b.n	24 <fp_mul_2+0x24>
      *tmpb++ = 0;
  5c:	f843 4b04 	str.w	r4, [r3], #4
    for (x = b->used; x < oldused; x++) {
  60:	3201      	adds	r2, #1
  62:	e7ec      	b.n	3e <fp_mul_2+0x3e>
    return FP_VAL;
  64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  68:	e7ee      	b.n	48 <fp_mul_2+0x48>

Disassembly of section .text.fp_mul_d:

00000000 <fp_mul_d>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   c->used = a->used;
   2:	6803      	ldr	r3, [r0, #0]
   c->sign = a->sign;
   4:	6847      	ldr	r7, [r0, #4]
   oldused = c->used;
   6:	f8d2 c000 	ldr.w	ip, [r2]
   c->sign = a->sign;
   a:	6057      	str	r7, [r2, #4]
   w       = 0;
   c:	2400      	movs	r4, #0
   c->used = a->used;
   e:	6013      	str	r3, [r2, #0]
   for (x = 0; x < a->used; x++) {
  10:	2501      	movs	r5, #1
   w       = 0;
  12:	4626      	mov	r6, r4
   for (x = 0; x < a->used; x++) {
  14:	f105 0e01 	add.w	lr, r5, #1
  18:	3d01      	subs	r5, #1
  1a:	42ab      	cmp	r3, r5
  1c:	dc1c      	bgt.n	58 <fp_mul_d+0x58>
  1e:	ea23 71e3 	bic.w	r1, r3, r3, asr #31
   if (w != 0) {
  22:	b13c      	cbz	r4, 34 <fp_mul_d+0x34>
      if (a->used == FP_SIZE)
  24:	2b18      	cmp	r3, #24
  26:	d027      	beq.n	78 <fp_mul_d+0x78>
      c->dp[c->used++] = (fp_digit) w;
  28:	1c58      	adds	r0, r3, #1
  2a:	3302      	adds	r3, #2
  2c:	6010      	str	r0, [r2, #0]
  2e:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
      ++x;
  32:	3101      	adds	r1, #1
      c->dp[x] = 0;
  34:	f102 0308 	add.w	r3, r2, #8
  38:	2000      	movs	r0, #0
   for (; x < oldused && x < FP_SIZE; x++) {
  3a:	4561      	cmp	r1, ip
  3c:	da01      	bge.n	42 <fp_mul_d+0x42>
  3e:	2917      	cmp	r1, #23
  40:	dd14      	ble.n	6c <fp_mul_d+0x6c>
   fp_clamp(c);
  42:	6813      	ldr	r3, [r2, #0]
  44:	b12b      	cbz	r3, 52 <fp_mul_d+0x52>
  46:	1e59      	subs	r1, r3, #1
  48:	3301      	adds	r3, #1
  4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4e:	b18b      	cbz	r3, 74 <fp_mul_d+0x74>
  50:	463b      	mov	r3, r7
  52:	6053      	str	r3, [r2, #4]
   return FP_OKAY;
  54:	2000      	movs	r0, #0
}
  56:	bdf0      	pop	{r4, r5, r6, r7, pc}
       w         = ((fp_word)a->dp[x]) * ((fp_word)b) + w;
  58:	f850 502e 	ldr.w	r5, [r0, lr, lsl #2]
  5c:	fbe5 4601 	umlal	r4, r6, r5, r1
       c->dp[x]  = (fp_digit)w;
  60:	f842 402e 	str.w	r4, [r2, lr, lsl #2]
       w         = w >> DIGIT_BIT;
  64:	4675      	mov	r5, lr
  66:	4634      	mov	r4, r6
  68:	2600      	movs	r6, #0
   for (x = 0; x < a->used; x++) {
  6a:	e7d3      	b.n	14 <fp_mul_d+0x14>
      c->dp[x] = 0;
  6c:	f843 0021 	str.w	r0, [r3, r1, lsl #2]
   for (; x < oldused && x < FP_SIZE; x++) {
  70:	3101      	adds	r1, #1
  72:	e7e2      	b.n	3a <fp_mul_d+0x3a>
   fp_clamp(c);
  74:	6011      	str	r1, [r2, #0]
  76:	e7e4      	b.n	42 <fp_mul_d+0x42>
          return FP_VAL;
  78:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  7c:	e7eb      	b.n	56 <fp_mul_d+0x56>

Disassembly of section .text.fp_div_2:

00000000 <fp_div_2>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
  b->used = a->used;
   2:	4605      	mov	r5, r0
   4:	460b      	mov	r3, r1
   6:	f855 2b08 	ldr.w	r2, [r5], #8
  oldused = b->used;
   a:	680f      	ldr	r7, [r1, #0]
  b->used = a->used;
   c:	f843 2b08 	str.w	r2, [r3], #8
    tmpa = a->dp + b->used - 1;
  10:	f102 4480 	add.w	r4, r2, #1073741824	; 0x40000000
  14:	3c01      	subs	r4, #1
  16:	eb05 0584 	add.w	r5, r5, r4, lsl #2
    for (x = b->used - 1; x >= 0; x--) {
  1a:	3a01      	subs	r2, #1
    tmpb = b->dp + b->used - 1;
  1c:	eb03 0484 	add.w	r4, r3, r4, lsl #2
    r = 0;
  20:	2600      	movs	r6, #0
    for (x = b->used - 1; x >= 0; x--) {
  22:	2a00      	cmp	r2, #0
  24:	da10      	bge.n	48 <fp_div_2+0x48>
    tmpb = b->dp + b->used;
  26:	680a      	ldr	r2, [r1, #0]
      *tmpb++ = 0;
  28:	2400      	movs	r4, #0
    tmpb = b->dp + b->used;
  2a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    for (x = b->used; x < oldused; x++) {
  2e:	42ba      	cmp	r2, r7
  30:	db15      	blt.n	5e <fp_div_2+0x5e>
  b->sign = a->sign;
  32:	6842      	ldr	r2, [r0, #4]
  fp_clamp (b);
  34:	680b      	ldr	r3, [r1, #0]
  36:	b12b      	cbz	r3, 44 <fp_div_2+0x44>
  38:	1e58      	subs	r0, r3, #1
  3a:	3301      	adds	r3, #1
  3c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  40:	b18b      	cbz	r3, 66 <fp_div_2+0x66>
  42:	4613      	mov	r3, r2
  44:	604b      	str	r3, [r1, #4]
}
  46:	bdf0      	pop	{r4, r5, r6, r7, pc}
      rr = *tmpa & 1;
  48:	f855 c904 	ldr.w	ip, [r5], #-4
      *tmpb-- = (*tmpa-- >> 1) | (r << (DIGIT_BIT - 1));
  4c:	07f6      	lsls	r6, r6, #31
  4e:	ea46 065c 	orr.w	r6, r6, ip, lsr #1
  52:	f844 6904 	str.w	r6, [r4], #-4
    for (x = b->used - 1; x >= 0; x--) {
  56:	3a01      	subs	r2, #1
      r = rr;
  58:	f00c 0601 	and.w	r6, ip, #1
  5c:	e7e1      	b.n	22 <fp_div_2+0x22>
      *tmpb++ = 0;
  5e:	f843 4b04 	str.w	r4, [r3], #4
    for (x = b->used; x < oldused; x++) {
  62:	3201      	adds	r2, #1
  64:	e7e3      	b.n	2e <fp_div_2+0x2e>
  fp_clamp (b);
  66:	6008      	str	r0, [r1, #0]
  68:	e7e4      	b.n	34 <fp_div_2+0x34>

Disassembly of section .text.fp_div_2_mod_ct:

00000000 <fp_div_2_mod_ct>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
  mask = 0 - (a->dp[0] & 1);
   2:	6887      	ldr	r7, [r0, #8]
  for (i = 0; i < b->used; i++) {
   4:	680c      	ldr	r4, [r1, #0]
  fp_word  w = 0;
   6:	f04f 0e00 	mov.w	lr, #0
  mask = 0 - (a->dp[0] & 1);
   a:	f347 0700 	sbfx	r7, r7, #0, #1
  for (i = 0; i < b->used; i++) {
   e:	2301      	movs	r3, #1
      w         += a->dp[i] & mask_a;
  10:	46f4      	mov	ip, lr
  for (i = 0; i < b->used; i++) {
  12:	1e5e      	subs	r6, r3, #1
  14:	42b4      	cmp	r4, r6
  16:	f103 0501 	add.w	r5, r3, #1
  1a:	dc1d      	bgt.n	58 <fp_div_2_mod_ct+0x58>
  1c:	f102 0108 	add.w	r1, r2, #8
  20:	2000      	movs	r0, #0
  for (i = 0; i < b->used-1; i++) {
  22:	1e65      	subs	r5, r4, #1
      c->dp[i] = (c->dp[i] >> 1) | (c->dp[i+1] << (DIGIT_BIT - 1));
  24:	f851 3b04 	ldr.w	r3, [r1], #4
  for (i = 0; i < b->used-1; i++) {
  28:	42a8      	cmp	r0, r5
      c->dp[i] = (c->dp[i] >> 1) | (c->dp[i+1] << (DIGIT_BIT - 1));
  2a:	ea4f 0353 	mov.w	r3, r3, lsr #1
  for (i = 0; i < b->used-1; i++) {
  2e:	db2a      	blt.n	86 <fp_div_2_mod_ct+0x86>
  30:	2c01      	cmp	r4, #1
  32:	bfb8      	it	lt
  34:	2401      	movlt	r4, #1
  c->dp[i] = (c->dp[i] >> 1) | ((fp_digit)w << (DIGIT_BIT - 1));
  36:	1c61      	adds	r1, r4, #1
  38:	ea43 73ce 	orr.w	r3, r3, lr, lsl #31
  3c:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  c->sign = FP_ZPOS;
  40:	2300      	movs	r3, #0
  c->used = i + 1;
  42:	6014      	str	r4, [r2, #0]
  c->sign = FP_ZPOS;
  44:	6053      	str	r3, [r2, #4]
  fp_clamp(c);
  46:	6813      	ldr	r3, [r2, #0]
  48:	b123      	cbz	r3, 54 <fp_div_2_mod_ct+0x54>
  4a:	1e59      	subs	r1, r3, #1
  4c:	3301      	adds	r3, #1
  4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  52:	b1fb      	cbz	r3, 94 <fp_div_2_mod_ct+0x94>
}
  54:	2000      	movs	r0, #0
  56:	bdf0      	pop	{r4, r5, r6, r7, pc}
      fp_digit mask_a = 0 - (i < a->used);
  58:	6803      	ldr	r3, [r0, #0]
  5a:	42b3      	cmp	r3, r6
      w         += a->dp[i] & mask_a;
  5c:	f850 6025 	ldr.w	r6, [r0, r5, lsl #2]
      fp_digit mask_a = 0 - (i < a->used);
  60:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  64:	bfd8      	it	le
  66:	2300      	movle	r3, #0
      w         += a->dp[i] & mask_a;
  68:	4033      	ands	r3, r6
      w         += b->dp[i] & mask;
  6a:	f851 6025 	ldr.w	r6, [r1, r5, lsl #2]
  6e:	403e      	ands	r6, r7
      w         += a->dp[i] & mask_a;
  70:	199b      	adds	r3, r3, r6
  72:	eb4c 060c 	adc.w	r6, ip, ip
  76:	eb13 030e 	adds.w	r3, r3, lr
      c->dp[i]   = (fp_digit)w;
  7a:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
      w        >>= DIGIT_BIT;
  7e:	f146 0e00 	adc.w	lr, r6, #0
  82:	462b      	mov	r3, r5
  84:	e7c5      	b.n	12 <fp_div_2_mod_ct+0x12>
      c->dp[i] = (c->dp[i] >> 1) | (c->dp[i+1] << (DIGIT_BIT - 1));
  86:	680e      	ldr	r6, [r1, #0]
  88:	ea43 73c6 	orr.w	r3, r3, r6, lsl #31
  8c:	f841 3c04 	str.w	r3, [r1, #-4]
  for (i = 0; i < b->used-1; i++) {
  90:	3001      	adds	r0, #1
  92:	e7c7      	b.n	24 <fp_div_2_mod_ct+0x24>
  fp_clamp(c);
  94:	6011      	str	r1, [r2, #0]
  96:	e7d6      	b.n	46 <fp_div_2_mod_ct+0x46>

Disassembly of section .text.fp_submod_ct:

00000000 <fp_submod_ct>:
{
   0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (c->used + 1 > FP_SIZE) {
   4:	6814      	ldr	r4, [r2, #0]
   6:	2c17      	cmp	r4, #23
   8:	dc48      	bgt.n	9c <fp_submod_ct+0x9c>
  if (c == d) {
   a:	429a      	cmp	r2, r3
   c:	d046      	beq.n	9c <fp_submod_ct+0x9c>
  for (i = 0; i < c->used; i++) {
   e:	2700      	movs	r7, #0
  10:	f103 0608 	add.w	r6, r3, #8
  14:	f100 0e08 	add.w	lr, r0, #8
  if (c == d) {
  18:	46b0      	mov	r8, r6
  1a:	f101 0008 	add.w	r0, r1, #8
  w = 0;
  1e:	46bc      	mov	ip, r7
  20:	463d      	mov	r5, r7
    w         += a->dp[i];
  22:	f85e 1b04 	ldr.w	r1, [lr], #4
    w         -= b->dp[i];
  26:	f850 9b04 	ldr.w	r9, [r0], #4
    w         += a->dp[i];
  2a:	eb11 010c 	adds.w	r1, r1, ip
  2e:	f145 0500 	adc.w	r5, r5, #0
    w         -= b->dp[i];
  32:	ebb1 0109 	subs.w	r1, r1, r9
  36:	f165 0c00 	sbc.w	ip, r5, #0
  for (i = 0; i < c->used; i++) {
  3a:	42bc      	cmp	r4, r7
    w        >>= DIGIT_BIT;
  3c:	ea4f 75ec 	mov.w	r5, ip, asr #31
  for (i = 0; i < c->used; i++) {
  40:	dc15      	bgt.n	6e <fp_submod_ct+0x6e>
  mask = (fp_digit)0 - (w < 0);
  42:	462f      	mov	r7, r5
  for (i = 0; i < c->used; i++) {
  44:	2500      	movs	r5, #0
  46:	3208      	adds	r2, #8
  w = 0;
  48:	4628      	mov	r0, r5
  4a:	46ac      	mov	ip, r5
  for (i = 0; i < c->used; i++) {
  4c:	42ac      	cmp	r4, r5
  4e:	dc12      	bgt.n	76 <fp_submod_ct+0x76>
  d->used = i;
  50:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
  d->sign = FP_ZPOS;
  54:	2200      	movs	r2, #0
  d->used = i;
  56:	601c      	str	r4, [r3, #0]
  d->sign = FP_ZPOS;
  58:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
  5a:	6818      	ldr	r0, [r3, #0]
  5c:	b128      	cbz	r0, 6a <fp_submod_ct+0x6a>
  5e:	1e41      	subs	r1, r0, #1
  60:	3001      	adds	r0, #1
  62:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  66:	b1ba      	cbz	r2, 98 <fp_submod_ct+0x98>
  return FP_OKAY;
  68:	2000      	movs	r0, #0
}
  6a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    d->dp[i]   = (fp_digit)w;
  6e:	f848 1b04 	str.w	r1, [r8], #4
  for (i = 0; i < c->used; i++) {
  72:	3701      	adds	r7, #1
  74:	e7d5      	b.n	22 <fp_submod_ct+0x22>
    w         += d->dp[i];
  76:	6831      	ldr	r1, [r6, #0]
  78:	1808      	adds	r0, r1, r0
    w         += c->dp[i] & mask;
  7a:	f852 1b04 	ldr.w	r1, [r2], #4
  7e:	ea01 0107 	and.w	r1, r1, r7
    w         += d->dp[i];
  82:	f14c 0c00 	adc.w	ip, ip, #0
    w         += c->dp[i] & mask;
  86:	1809      	adds	r1, r1, r0
    w        >>= DIGIT_BIT;
  88:	f14c 0000 	adc.w	r0, ip, #0
    d->dp[i]   = (fp_digit)w;
  8c:	f846 1b04 	str.w	r1, [r6], #4
    w        >>= DIGIT_BIT;
  90:	ea4f 7ce0 	mov.w	ip, r0, asr #31
  for (i = 0; i < c->used; i++) {
  94:	3501      	adds	r5, #1
  96:	e7d9      	b.n	4c <fp_submod_ct+0x4c>
  fp_clamp(d);
  98:	6019      	str	r1, [r3, #0]
  9a:	e7de      	b.n	5a <fp_submod_ct+0x5a>
    return FP_VAL;
  9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  a0:	e7e3      	b.n	6a <fp_submod_ct+0x6a>

Disassembly of section .text.fp_addmod_ct:

00000000 <fp_addmod_ct>:
  if (c == d) {
   0:	429a      	cmp	r2, r3
{
   2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (c == d) {
   6:	d057      	beq.n	b8 <fp_addmod_ct+0xb8>
  s = 0;
   8:	f04f 0e00 	mov.w	lr, #0
  for (i = 0; i < c->used; i++) {
   c:	6816      	ldr	r6, [r2, #0]
   e:	2401      	movs	r4, #1
  s = 0;
  10:	46f0      	mov	r8, lr
  w = 0;
  12:	46f1      	mov	r9, lr
    w         += a->dp[i];
  14:	46f4      	mov	ip, lr
  for (i = 0; i < c->used; i++) {
  16:	1c67      	adds	r7, r4, #1
  18:	3c01      	subs	r4, #1
  1a:	42a6      	cmp	r6, r4
  1c:	dc1f      	bgt.n	5e <fp_addmod_ct+0x5e>
  s += (fp_digit)w;
  1e:	eb19 040e 	adds.w	r4, r9, lr
  22:	f148 0800 	adc.w	r8, r8, #0
  mask = (fp_digit)0 - (s >= 0);
  26:	ea6f 0808 	mvn.w	r8, r8
  2a:	ea4f 78d8 	mov.w	r8, r8, lsr #31
  for (i = 0; i < c->used; i++) {
  2e:	2400      	movs	r4, #0
  mask = (fp_digit)0 - (s >= 0);
  30:	f1c8 0800 	rsb	r8, r8, #0
  for (i = 0; i < c->used; i++) {
  34:	3208      	adds	r2, #8
  36:	f103 0708 	add.w	r7, r3, #8
  w = 0;
  3a:	4621      	mov	r1, r4
  for (i = 0; i < c->used; i++) {
  3c:	42a6      	cmp	r6, r4
  3e:	dc28      	bgt.n	92 <fp_addmod_ct+0x92>
  d->used = i;
  40:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
  d->sign = FP_ZPOS;
  44:	2200      	movs	r2, #0
  d->used = i;
  46:	601e      	str	r6, [r3, #0]
  d->sign = FP_ZPOS;
  48:	605a      	str	r2, [r3, #4]
  fp_clamp(d);
  4a:	6818      	ldr	r0, [r3, #0]
  4c:	b128      	cbz	r0, 5a <fp_addmod_ct+0x5a>
  4e:	1e41      	subs	r1, r0, #1
  50:	3001      	adds	r0, #1
  52:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
  56:	b36a      	cbz	r2, b4 <fp_addmod_ct+0xb4>
  58:	2000      	movs	r0, #0
}
  5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    w         += b->dp[i];
  5e:	f851 4027 	ldr.w	r4, [r1, r7, lsl #2]
    w         += a->dp[i];
  62:	f850 5027 	ldr.w	r5, [r0, r7, lsl #2]
    w         += b->dp[i];
  66:	192d      	adds	r5, r5, r4
  68:	eb4c 0a0c 	adc.w	sl, ip, ip
  6c:	eb15 0409 	adds.w	r4, r5, r9
    d->dp[i]   = (fp_digit)w;
  70:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
    s         -= c->dp[i];
  74:	f852 5027 	ldr.w	r5, [r2, r7, lsl #2]
    w         += b->dp[i];
  78:	f14a 0900 	adc.w	r9, sl, #0
    s         += (fp_digit)w;
  7c:	eb14 040e 	adds.w	r4, r4, lr
  80:	f148 0e00 	adc.w	lr, r8, #0
    s         -= c->dp[i];
  84:	1b64      	subs	r4, r4, r5
    s        >>= DIGIT_BIT;
  86:	f16e 0e00 	sbc.w	lr, lr, #0
  8a:	ea4f 78ee 	mov.w	r8, lr, asr #31
  8e:	463c      	mov	r4, r7
  90:	e7c1      	b.n	16 <fp_addmod_ct+0x16>
    w        += c->dp[i] & mask;
  92:	f852 5b04 	ldr.w	r5, [r2], #4
    w         = d->dp[i] - w;
  96:	6838      	ldr	r0, [r7, #0]
    w        += c->dp[i] & mask;
  98:	ea08 0505 	and.w	r5, r8, r5
  9c:	1a40      	subs	r0, r0, r1
  9e:	eb61 0101 	sbc.w	r1, r1, r1
    w         = d->dp[i] - w;
  a2:	1b40      	subs	r0, r0, r5
  a4:	f161 0100 	sbc.w	r1, r1, #0
    d->dp[i]  = (fp_digit)w;
  a8:	f847 0b04 	str.w	r0, [r7], #4
    w         = (w >> DIGIT_BIT)&1;
  ac:	f001 0101 	and.w	r1, r1, #1
  for (i = 0; i < c->used; i++) {
  b0:	3401      	adds	r4, #1
  b2:	e7c3      	b.n	3c <fp_addmod_ct+0x3c>
  fp_clamp(d);
  b4:	6019      	str	r1, [r3, #0]
  b6:	e7c8      	b.n	4a <fp_addmod_ct+0x4a>
    return FP_VAL;
  b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  bc:	e7cd      	b.n	5a <fp_addmod_ct+0x5a>

Disassembly of section .text.fp_cmp_d:

00000000 <fp_cmp_d>:
  if (a->used == 0 && b == 0)
   0:	6803      	ldr	r3, [r0, #0]
   2:	b923      	cbnz	r3, e <fp_cmp_d+0xe>
   4:	1e08      	subs	r0, r1, #0
   6:	bf18      	it	ne
   8:	2001      	movne	r0, #1
   a:	4240      	negs	r0, r0
   c:	4770      	bx	lr
  if ((b && a->used == 0) || a->sign == FP_NEG) {
   e:	6842      	ldr	r2, [r0, #4]
  10:	2a01      	cmp	r2, #1
  12:	d009      	beq.n	28 <fp_cmp_d+0x28>
  if (a->used > 1) {
  14:	2b01      	cmp	r3, #1
  16:	dc0a      	bgt.n	2e <fp_cmp_d+0x2e>
  18:	6883      	ldr	r3, [r0, #8]
  if (a->dp[0] > b) {
  1a:	4299      	cmp	r1, r3
  1c:	d307      	bcc.n	2e <fp_cmp_d+0x2e>
  } else if (a->dp[0] < b) {
  1e:	bf8c      	ite	hi
  20:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
  24:	2000      	movls	r0, #0
  26:	4770      	bx	lr
    return FP_LT;
  28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  2c:	4770      	bx	lr
    return FP_GT;
  2e:	2001      	movs	r0, #1
}
  30:	4770      	bx	lr

Disassembly of section .text.fp_cmp_mag:

00000000 <fp_cmp_mag>:
   if (a->used > b->used) {
   0:	6803      	ldr	r3, [r0, #0]
   2:	680a      	ldr	r2, [r1, #0]
   4:	4293      	cmp	r3, r2
{
   6:	b510      	push	{r4, lr}
   if (a->used > b->used) {
   8:	dc10      	bgt.n	2c <fp_cmp_mag+0x2c>
   } else if (a->used < b->used) {
   a:	db11      	blt.n	30 <fp_cmp_mag+0x30>
      for (x = a->used - 1; x >= 0; x--) {
   c:	3b01      	subs	r3, #1
          if (a->dp[x] > b->dp[x]) {
   e:	3008      	adds	r0, #8
  10:	3108      	adds	r1, #8
      for (x = a->used - 1; x >= 0; x--) {
  12:	2b00      	cmp	r3, #0
  14:	da01      	bge.n	1a <fp_cmp_mag+0x1a>
   return FP_EQ;
  16:	2000      	movs	r0, #0
}
  18:	bd10      	pop	{r4, pc}
          if (a->dp[x] > b->dp[x]) {
  1a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
  1e:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
  22:	4294      	cmp	r4, r2
  24:	d802      	bhi.n	2c <fp_cmp_mag+0x2c>
          } else if (a->dp[x] < b->dp[x]) {
  26:	d303      	bcc.n	30 <fp_cmp_mag+0x30>
      for (x = a->used - 1; x >= 0; x--) {
  28:	3b01      	subs	r3, #1
  2a:	e7f2      	b.n	12 <fp_cmp_mag+0x12>
      return FP_GT;
  2c:	2001      	movs	r0, #1
  2e:	e7f3      	b.n	18 <fp_cmp_mag+0x18>
      return FP_LT;
  30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  34:	e7f0      	b.n	18 <fp_cmp_mag+0x18>

Disassembly of section .text.fp_add:

00000000 <fp_add>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  sa = a->sign;
   4:	6847      	ldr	r7, [r0, #4]
  sb = b->sign;
   6:	f8d1 8004 	ldr.w	r8, [r1, #4]
  if (sa == sb) {
   a:	4547      	cmp	r7, r8
{
   c:	4605      	mov	r5, r0
   e:	460e      	mov	r6, r1
  10:	4614      	mov	r4, r2
  if (sa == sb) {
  12:	d104      	bne.n	1e <fp_add+0x1e>
    c->sign = sa;
  14:	6057      	str	r7, [r2, #4]
}
  16:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ret = s_fp_add (a, b, c);
  1a:	f7ff bffe 	b.w	0 <fp_add>
    if (fp_cmp_mag (a, b) == FP_LT) {
  1e:	f7ff fffe 	bl	0 <fp_add>
  22:	3001      	adds	r0, #1
      s_fp_sub (b, a, c);
  24:	bf09      	itett	eq
  26:	4630      	moveq	r0, r6
      s_fp_sub (a, b, c);
  28:	4628      	movne	r0, r5
      c->sign = sb;
  2a:	f8c4 8004 	streq.w	r8, [r4, #4]
      s_fp_sub (b, a, c);
  2e:	4622      	moveq	r2, r4
  30:	bf0f      	iteee	eq
  32:	4629      	moveq	r1, r5
      c->sign = sa;
  34:	6067      	strne	r7, [r4, #4]
      s_fp_sub (a, b, c);
  36:	4622      	movne	r2, r4
  38:	4631      	movne	r1, r6
  3a:	f7ff fffe 	bl	0 <fp_add>
}
  3e:	2000      	movs	r0, #0
  40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.fp_sub:

00000000 <fp_sub>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  sa = a->sign;
   2:	6844      	ldr	r4, [r0, #4]
  if (sa != sb) {
   4:	684b      	ldr	r3, [r1, #4]
   6:	429c      	cmp	r4, r3
{
   8:	4607      	mov	r7, r0
   a:	460e      	mov	r6, r1
   c:	4615      	mov	r5, r2
  if (sa != sb) {
   e:	d004      	beq.n	1a <fp_sub+0x1a>
    c->sign = sa;
  10:	6054      	str	r4, [r2, #4]
}
  12:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    ret = s_fp_add (a, b, c);
  16:	f7ff bffe 	b.w	0 <fp_sub>
    if (fp_cmp_mag (a, b) != FP_LT) {
  1a:	f7ff fffe 	bl	0 <fp_sub>
  1e:	3001      	adds	r0, #1
  20:	d007      	beq.n	32 <fp_sub+0x32>
      c->sign = sa;
  22:	606c      	str	r4, [r5, #4]
      s_fp_sub (a, b, c);
  24:	462a      	mov	r2, r5
  26:	4631      	mov	r1, r6
  28:	4638      	mov	r0, r7
      s_fp_sub (b, a, c);
  2a:	f7ff fffe 	bl	0 <fp_sub>
}
  2e:	2000      	movs	r0, #0
  30:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      c->sign = (sa == FP_ZPOS) ? FP_NEG : FP_ZPOS;
  32:	fab4 f484 	clz	r4, r4
  36:	0964      	lsrs	r4, r4, #5
  38:	606c      	str	r4, [r5, #4]
      s_fp_sub (b, a, c);
  3a:	462a      	mov	r2, r5
  3c:	4639      	mov	r1, r7
  3e:	4630      	mov	r0, r6
  40:	e7f3      	b.n	2a <fp_sub+0x2a>

Disassembly of section .text.fp_cmp:

00000000 <fp_cmp>:
   if (a->sign == FP_NEG && b->sign == FP_ZPOS) {
   0:	6842      	ldr	r2, [r0, #4]
   2:	2a01      	cmp	r2, #1
{
   4:	460b      	mov	r3, r1
   if (a->sign == FP_NEG && b->sign == FP_ZPOS) {
   6:	d104      	bne.n	12 <fp_cmp+0x12>
   8:	684a      	ldr	r2, [r1, #4]
   a:	b942      	cbnz	r2, 1e <fp_cmp+0x1e>
      return FP_LT;
   c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  10:	e003      	b.n	1a <fp_cmp+0x1a>
   } else if (a->sign == FP_ZPOS && b->sign == FP_NEG) {
  12:	b942      	cbnz	r2, 26 <fp_cmp+0x26>
  14:	684a      	ldr	r2, [r1, #4]
  16:	2a01      	cmp	r2, #1
  18:	d105      	bne.n	26 <fp_cmp+0x26>
}
  1a:	4610      	mov	r0, r2
  1c:	4770      	bx	lr
         return fp_cmp_mag(b, a);
  1e:	4601      	mov	r1, r0
  20:	4618      	mov	r0, r3
         return fp_cmp_mag(a, b);
  22:	f7ff bffe 	b.w	0 <fp_cmp>
  26:	4619      	mov	r1, r3
  28:	e7fb      	b.n	22 <fp_cmp+0x22>

Disassembly of section .text.fp_montgomery_setup:

00000000 <fp_montgomery_setup>:
  b = a->dp[0];
   0:	6883      	ldr	r3, [r0, #8]
  if ((b & 1) == 0) {
   2:	07da      	lsls	r2, r3, #31
   4:	d514      	bpl.n	30 <fp_montgomery_setup+0x30>
  x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
   6:	1c98      	adds	r0, r3, #2
   8:	0040      	lsls	r0, r0, #1
   a:	f000 0008 	and.w	r0, r0, #8
   e:	4418      	add	r0, r3
  x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
  10:	fb00 f203 	mul.w	r2, r0, r3
  14:	f1c2 0202 	rsb	r2, r2, #2
  18:	4350      	muls	r0, r2
  x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
  1a:	fb00 f203 	mul.w	r2, r0, r3
  1e:	f1c2 0202 	rsb	r2, r2, #2
  22:	4342      	muls	r2, r0
  x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
  24:	4353      	muls	r3, r2
  26:	3b02      	subs	r3, #2
  *rho = (fp_digit) (((fp_word) 1 << ((fp_word) DIGIT_BIT)) - ((fp_word)x));
  28:	4353      	muls	r3, r2
  2a:	600b      	str	r3, [r1, #0]
  return FP_OKAY;
  2c:	2000      	movs	r0, #0
  2e:	4770      	bx	lr
    return FP_VAL;
  30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  34:	4770      	bx	lr

Disassembly of section .text.fp_montgomery_reduce_ex:

00000000 <fp_montgomery_reduce_ex>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   if (m->used > (FP_SIZE/2)) {
   4:	680b      	ldr	r3, [r1, #0]
{
   6:	b085      	sub	sp, #20
   if (m->used > (FP_SIZE/2)) {
   8:	2b0c      	cmp	r3, #12
{
   a:	4604      	mov	r4, r0
   c:	460e      	mov	r6, r1
   e:	9203      	str	r2, [sp, #12]
   if (m->used > (FP_SIZE/2)) {
  10:	f300 8095 	bgt.w	13e <fp_montgomery_reduce_ex+0x13e>
   c = (fp_digit*)XMALLOC(sizeof(fp_digit)*(FP_SIZE + 1), NULL, DYNAMIC_TYPE_BIGINT);
  14:	2064      	movs	r0, #100	; 0x64
  16:	f7ff fffe 	bl	0 <malloc>
   if (c == NULL) {
  1a:	4605      	mov	r5, r0
  1c:	2800      	cmp	r0, #0
  1e:	f000 8091 	beq.w	144 <fp_montgomery_reduce_ex+0x144>
   XMEMSET(c, 0, sizeof(fp_digit)*(FP_SIZE + 1));
  22:	2264      	movs	r2, #100	; 0x64
  24:	2100      	movs	r1, #0
  26:	f7ff fffe 	bl	0 <memset>
   pa = m->used;
  2a:	6833      	ldr	r3, [r6, #0]
   if (a->used <= m->used) {
  2c:	6822      	ldr	r2, [r4, #0]
  2e:	429a      	cmp	r2, r3
      oldused = m->used * 2;
  30:	bfcc      	ite	gt
  32:	ea4f 0843 	movgt.w	r8, r3, lsl #1
  36:	4698      	movle	r8, r3
   for (x = 0; x < oldused; x++) {
  38:	f104 0108 	add.w	r1, r4, #8
  3c:	2200      	movs	r2, #0
  3e:	4590      	cmp	r8, r2
  40:	dc39      	bgt.n	b6 <fp_montgomery_reduce_ex+0xb6>
  42:	46ae      	mov	lr, r5
  44:	0099      	lsls	r1, r3, #2
   for (x = 0; x < pa; x++) {
  46:	f04f 0c00 	mov.w	ip, #0
  4a:	459c      	cmp	ip, r3
  4c:	db39      	blt.n	c2 <fp_montgomery_reduce_ex+0xc2>
  _c   = c + pa;
  4e:	eb05 0e01 	add.w	lr, r5, r1
  tmpm = a->dp;
  52:	f104 0208 	add.w	r2, r4, #8
  for (x = 0; x < pa+1; x++) {
  56:	f104 0c04 	add.w	ip, r4, #4
  5a:	2700      	movs	r7, #0
  5c:	429f      	cmp	r7, r3
  5e:	dd62      	ble.n	126 <fp_montgomery_reduce_ex+0x126>
  60:	1c5f      	adds	r7, r3, #1
  62:	f101 0104 	add.w	r1, r1, #4
  66:	f103 0001 	add.w	r0, r3, #1
  6a:	bfb8      	it	lt
  6c:	2100      	movlt	r1, #0
  6e:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
  72:	4411      	add	r1, r2
  74:	3301      	adds	r3, #1
     *tmpm++ = 0;
  76:	2200      	movs	r2, #0
  for (; x < oldused; x++) {
  78:	4598      	cmp	r8, r3
  7a:	dc5a      	bgt.n	132 <fp_montgomery_reduce_ex+0x132>
  a->used = pa+1;
  7c:	6020      	str	r0, [r4, #0]
  fp_clamp(a);
  7e:	6823      	ldr	r3, [r4, #0]
  80:	b133      	cbz	r3, 90 <fp_montgomery_reduce_ex+0x90>
  82:	1e5a      	subs	r2, r3, #1
  84:	3301      	adds	r3, #1
  86:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  8a:	2b00      	cmp	r3, #0
  8c:	d055      	beq.n	13a <fp_montgomery_reduce_ex+0x13a>
  8e:	6863      	ldr	r3, [r4, #4]
  90:	6063      	str	r3, [r4, #4]
  if (fp_cmp_mag (a, m) != FP_LT) {
  92:	4631      	mov	r1, r6
  94:	4620      	mov	r0, r4
  96:	f7ff fffe 	bl	0 <fp_montgomery_reduce_ex>
  9a:	3001      	adds	r0, #1
  9c:	d004      	beq.n	a8 <fp_montgomery_reduce_ex+0xa8>
    s_fp_sub (a, m, a);
  9e:	4622      	mov	r2, r4
  a0:	4631      	mov	r1, r6
  a2:	4620      	mov	r0, r4
  a4:	f7ff fffe 	bl	0 <fp_montgomery_reduce_ex>
  XFREE(c, NULL, DYNAMIC_TYPE_BIGINT);
  a8:	4628      	mov	r0, r5
  aa:	f7ff fffe 	bl	0 <free>
  return FP_OKAY;
  ae:	2000      	movs	r0, #0
}
  b0:	b005      	add	sp, #20
  b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
       c[x] = a->dp[x];
  b6:	f851 0b04 	ldr.w	r0, [r1], #4
  ba:	f845 0022 	str.w	r0, [r5, r2, lsl #2]
   for (x = 0; x < oldused; x++) {
  be:	3201      	adds	r2, #1
  c0:	e7bd      	b.n	3e <fp_montgomery_reduce_ex+0x3e>
       LOOP_START;
  c2:	4677      	mov	r7, lr
  c4:	9803      	ldr	r0, [sp, #12]
  c6:	f857 2904 	ldr.w	r2, [r7], #-4
  ca:	4342      	muls	r2, r0
  cc:	9202      	str	r2, [sp, #8]
       tmpm = m->dp;
  ce:	f106 0208 	add.w	r2, r6, #8
  d2:	9201      	str	r2, [sp, #4]
       fp_digit cy = 0;
  d4:	2200      	movs	r2, #0
       y = 0;
  d6:	4691      	mov	r9, r2
          INNERMUL;
  d8:	f857 0f04 	ldr.w	r0, [r7, #4]!
  dc:	f8dd a004 	ldr.w	sl, [sp, #4]
  e0:	eb10 0b02 	adds.w	fp, r0, r2
  e4:	f85a 0b04 	ldr.w	r0, [sl], #4
  e8:	f8cd a004 	str.w	sl, [sp, #4]
  ec:	f04f 0200 	mov.w	r2, #0
  f0:	f8dd a008 	ldr.w	sl, [sp, #8]
  f4:	4152      	adcs	r2, r2
       for (; y < pa; y++) {
  f6:	f109 0901 	add.w	r9, r9, #1
          INNERMUL;
  fa:	fbea b200 	umlal	fp, r2, sl, r0
       for (; y < pa; y++) {
  fe:	454b      	cmp	r3, r9
          INNERMUL;
 100:	f8c7 b000 	str.w	fp, [r7]
       for (; y < pa; y++) {
 104:	d1e8      	bne.n	d8 <fp_montgomery_reduce_ex+0xd8>
 106:	eb01 070e 	add.w	r7, r1, lr
       while (cy) { /* //NOLINT(bugprone-infinite-loop) */ /* PROPCARRY is an asm macro */
 10a:	b922      	cbnz	r2, 116 <fp_montgomery_reduce_ex+0x116>
   for (x = 0; x < pa; x++) {
 10c:	f10c 0c01 	add.w	ip, ip, #1
 110:	f10e 0e04 	add.w	lr, lr, #4
 114:	e799      	b.n	4a <fp_montgomery_reduce_ex+0x4a>
           PROPCARRY;
 116:	6838      	ldr	r0, [r7, #0]
 118:	1882      	adds	r2, r0, r2
 11a:	f847 2b04 	str.w	r2, [r7], #4
 11e:	bf2c      	ite	cs
 120:	2201      	movcs	r2, #1
 122:	2200      	movcc	r2, #0
           ++_c;
 124:	e7f1      	b.n	10a <fp_montgomery_reduce_ex+0x10a>
     *tmpm++ = *_c++;
 126:	f85e 0027 	ldr.w	r0, [lr, r7, lsl #2]
 12a:	f84c 0f04 	str.w	r0, [ip, #4]!
  for (x = 0; x < pa+1; x++) {
 12e:	3701      	adds	r7, #1
 130:	e794      	b.n	5c <fp_montgomery_reduce_ex+0x5c>
     *tmpm++ = 0;
 132:	f841 2b04 	str.w	r2, [r1], #4
  for (; x < oldused; x++) {
 136:	3301      	adds	r3, #1
 138:	e79e      	b.n	78 <fp_montgomery_reduce_ex+0x78>
  fp_clamp(a);
 13a:	6022      	str	r2, [r4, #0]
 13c:	e79f      	b.n	7e <fp_montgomery_reduce_ex+0x7e>
      return FP_VAL;
 13e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 142:	e7b5      	b.n	b0 <fp_montgomery_reduce_ex+0xb0>
      return FP_MEM;
 144:	f06f 0001 	mvn.w	r0, #1
 148:	e7b2      	b.n	b0 <fp_montgomery_reduce_ex+0xb0>

Disassembly of section .text.fp_montgomery_reduce:

00000000 <fp_montgomery_reduce>:
  return fp_montgomery_reduce_ex(a, m, mp, 1);
   0:	2301      	movs	r3, #1
   2:	f7ff bffe 	b.w	0 <fp_montgomery_reduce>

Disassembly of section .text.fp_to_unsigned_bin_at_pos:

00000000 <fp_to_unsigned_bin_at_pos>:
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
   int j = 0;
   2:	2500      	movs	r5, #0
   4:	4410      	add	r0, r2
   for (i = 0; i < t->used-1; ) {
   6:	462e      	mov	r6, r5
   8:	680f      	ldr	r7, [r1, #0]
       b[x++] = (unsigned char)(t->dp[i] >> j);
   a:	1cb3      	adds	r3, r6, #2
   for (i = 0; i < t->used-1; ) {
   c:	3f01      	subs	r7, #1
   e:	42b7      	cmp	r7, r6
       b[x++] = (unsigned char)(t->dp[i] >> j);
  10:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  14:	eba0 0402 	sub.w	r4, r0, r2
   for (i = 0; i < t->used-1; ) {
  18:	dc03      	bgt.n	22 <fp_to_unsigned_bin_at_pos+0x22>
  1a:	1911      	adds	r1, r2, r4
  1c:	1a88      	subs	r0, r1, r2
   while (n != 0) {
  1e:	b95b      	cbnz	r3, 38 <fp_to_unsigned_bin_at_pos+0x38>
}
  20:	bdf0      	pop	{r4, r5, r6, r7, pc}
       b[x++] = (unsigned char)(t->dp[i] >> j);
  22:	40eb      	lsrs	r3, r5
  24:	f800 3b01 	strb.w	r3, [r0], #1
       j += 8;
  28:	f105 0308 	add.w	r3, r5, #8
       i += j == DIGIT_BIT;
  2c:	2d18      	cmp	r5, #24
  2e:	bf08      	it	eq
  30:	3601      	addeq	r6, #1
       j &= DIGIT_BIT - 1;
  32:	f003 051f 	and.w	r5, r3, #31
  36:	e7e7      	b.n	8 <fp_to_unsigned_bin_at_pos+0x8>
       b[x++] = (unsigned char)n;
  38:	f801 3b01 	strb.w	r3, [r1], #1
       n >>= 8;
  3c:	0a1b      	lsrs	r3, r3, #8
  3e:	e7ed      	b.n	1c <fp_to_unsigned_bin_at_pos+0x1c>

Disassembly of section .text.fp_to_unsigned_bin_len:

00000000 <fp_to_unsigned_bin_len>:
  int j = 0;
   0:	2300      	movs	r3, #0
{
   2:	b570      	push	{r4, r5, r6, lr}
  for (x=c-1; x >= 0 && i < a->used; x--) {
   4:	3a01      	subs	r2, #1
  int i = 0;
   6:	461c      	mov	r4, r3
  for (x=c-1; x >= 0 && i < a->used; x--) {
   8:	1e15      	subs	r5, r2, #0
   a:	6806      	ldr	r6, [r0, #0]
   c:	da14      	bge.n	38 <fp_to_unsigned_bin_len+0x38>
  if (i < a->used - 1) {
   e:	6802      	ldr	r2, [r0, #0]
  10:	1e51      	subs	r1, r2, #1
  12:	42a1      	cmp	r1, r4
  14:	dd17      	ble.n	46 <fp_to_unsigned_bin_len+0x46>
      return FP_VAL;
  16:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1a:	e01e      	b.n	5a <fp_to_unsigned_bin_len+0x5a>
     b[x] = (unsigned char)(a->dp[i] >> j);
  1c:	1ca5      	adds	r5, r4, #2
     i += j == DIGIT_BIT;
  1e:	2b18      	cmp	r3, #24
  20:	bf08      	it	eq
  22:	3401      	addeq	r4, #1
     b[x] = (unsigned char)(a->dp[i] >> j);
  24:	f850 5025 	ldr.w	r5, [r0, r5, lsl #2]
  28:	40dd      	lsrs	r5, r3
  2a:	548d      	strb	r5, [r1, r2]
     j += 8;
  2c:	f103 0508 	add.w	r5, r3, #8
     j &= DIGIT_BIT - 1;
  30:	f005 031f 	and.w	r3, r5, #31
  for (x=c-1; x >= 0 && i < a->used; x--) {
  34:	3a01      	subs	r2, #1
  36:	e7e7      	b.n	8 <fp_to_unsigned_bin_len+0x8>
  38:	42b4      	cmp	r4, r6
  3a:	dbef      	blt.n	1c <fp_to_unsigned_bin_len+0x1c>
     b[x] = 0;
  3c:	2200      	movs	r2, #0
  3e:	554a      	strb	r2, [r1, r5]
  for (; x >= 0; x--) {
  40:	3d01      	subs	r5, #1
  42:	d2fc      	bcs.n	3e <fp_to_unsigned_bin_len+0x3e>
  44:	e7e3      	b.n	e <fp_to_unsigned_bin_len+0xe>
  if ((i == a->used - 1) && ((a->dp[i] >> j) != 0)) {
  46:	d109      	bne.n	5c <fp_to_unsigned_bin_len+0x5c>
  48:	3201      	adds	r2, #1
  4a:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
  4e:	fa32 f303 	lsrs.w	r3, r2, r3
  52:	bf14      	ite	ne
  54:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  58:	2000      	moveq	r0, #0
}
  5a:	bd70      	pop	{r4, r5, r6, pc}
  return FP_OKAY;
  5c:	2000      	movs	r0, #0
  5e:	e7fc      	b.n	5a <fp_to_unsigned_bin_len+0x5a>

Disassembly of section .text.fp_is_bit_set:

00000000 <fp_is_bit_set>:
    if (b > FP_MAX_BITS)
   0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   4:	d80f      	bhi.n	26 <fp_is_bit_set+0x26>
    if ((fp_digit)a->used < i)
   6:	6802      	ldr	r2, [r0, #0]
   8:	ebb2 1f51 	cmp.w	r2, r1, lsr #5
    i = b/DIGIT_BIT;
   c:	ea4f 1351 	mov.w	r3, r1, lsr #5
    if ((fp_digit)a->used < i)
  10:	d30c      	bcc.n	2c <fp_is_bit_set+0x2c>
    return (int)((a->dp[i] >> b%DIGIT_BIT) & (fp_digit)1);
  12:	3302      	adds	r3, #2
  14:	f001 011f 	and.w	r1, r1, #31
  18:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
  1c:	fa20 f101 	lsr.w	r1, r0, r1
  20:	f001 0001 	and.w	r0, r1, #1
  24:	4770      	bx	lr
        return FP_VAL;
  26:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  2a:	4770      	bx	lr
        return 0;
  2c:	2000      	movs	r0, #0
}
  2e:	4770      	bx	lr

Disassembly of section .text.fp_set_bit:

00000000 <fp_set_bit>:
    if (b > FP_MAX_BITS)
   0:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
{
   4:	b510      	push	{r4, lr}
    if (b > FP_MAX_BITS)
   6:	d811      	bhi.n	2c <fp_set_bit+0x2c>
    i = b/DIGIT_BIT;
   8:	094b      	lsrs	r3, r1, #5
    if (a->used < (int)(i+1))
   a:	6804      	ldr	r4, [r0, #0]
   c:	1c5a      	adds	r2, r3, #1
   e:	4294      	cmp	r4, r2
        a->used = (int)(i+1);
  10:	bfb8      	it	lt
  12:	6002      	strlt	r2, [r0, #0]
    a->dp[i] |= ((fp_digit)1) << (b % DIGIT_BIT);
  14:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  18:	f001 011f 	and.w	r1, r1, #31
  1c:	2301      	movs	r3, #1
  1e:	fa03 f101 	lsl.w	r1, r3, r1
  22:	6883      	ldr	r3, [r0, #8]
  24:	430b      	orrs	r3, r1
  26:	6083      	str	r3, [r0, #8]
    return MP_OKAY;
  28:	2000      	movs	r0, #0
}
  2a:	bd10      	pop	{r4, pc}
        return FP_VAL;
  2c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  30:	e7fb      	b.n	2a <fp_set_bit+0x2a>

Disassembly of section .text.fp_count_bits:

00000000 <fp_count_bits>:
{
   0:	4603      	mov	r3, r0
  if (a->used == 0) {
   2:	6800      	ldr	r0, [r0, #0]
   4:	b128      	cbz	r0, 12 <fp_count_bits+0x12>
  r = (a->used - 1) * DIGIT_BIT;
   6:	1e42      	subs	r2, r0, #1
   8:	0150      	lsls	r0, r2, #5
  q = a->dp[a->used - 1];
   a:	3202      	adds	r2, #2
   c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  while (q > ((fp_digit) 0)) {
  10:	b903      	cbnz	r3, 14 <fp_count_bits+0x14>
}
  12:	4770      	bx	lr
    ++r;
  14:	3001      	adds	r0, #1
    q >>= ((fp_digit) 1);
  16:	085b      	lsrs	r3, r3, #1
  18:	e7fa      	b.n	10 <fp_count_bits+0x10>

Disassembly of section .text.fp_unsigned_bin_size:

00000000 <fp_unsigned_bin_size>:
{
   0:	b508      	push	{r3, lr}
  int     size = fp_count_bits (a);
   2:	f7ff fffe 	bl	0 <fp_unsigned_bin_size>
  return (size / 8 + ((size & 7) != 0 ? 1 : 0));
   6:	f010 0307 	ands.w	r3, r0, #7
   a:	bf18      	it	ne
   c:	2301      	movne	r3, #1
   e:	2800      	cmp	r0, #0
  10:	bfb8      	it	lt
  12:	3007      	addlt	r0, #7
}
  14:	eb03 00e0 	add.w	r0, r3, r0, asr #3
  18:	bd08      	pop	{r3, pc}

Disassembly of section .text.fp_leading_bit:

00000000 <fp_leading_bit>:
{
   0:	4602      	mov	r2, r0
    if (a->used != 0) {
   2:	6800      	ldr	r0, [r0, #0]
   4:	b160      	cbz	r0, 20 <fp_leading_bit+0x20>
        fp_digit q = a->dp[a->used - 1];
   6:	1c43      	adds	r3, r0, #1
    int bit = 0;
   8:	2000      	movs	r0, #0
        fp_digit q = a->dp[a->used - 1];
   a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   e:	2204      	movs	r2, #4
            if ((unsigned char)q != 0)
  10:	b2d9      	uxtb	r1, r3
  12:	b109      	cbz	r1, 18 <fp_leading_bit+0x18>
                bit = (q & 0x80) != 0;
  14:	f3c3 10c0 	ubfx	r0, r3, #7, #1
        while (qSz > 0) {
  18:	3a01      	subs	r2, #1
            q >>= 8;
  1a:	ea4f 2313 	mov.w	r3, r3, lsr #8
        while (qSz > 0) {
  1e:	d1f7      	bne.n	10 <fp_leading_bit+0x10>
}
  20:	4770      	bx	lr

Disassembly of section .text.fp_lshd:

00000000 <fp_lshd>:
    if (a->used + x > FP_SIZE) return FP_VAL;
   0:	6803      	ldr	r3, [r0, #0]
   2:	185a      	adds	r2, r3, r1
   4:	2a18      	cmp	r2, #24
{
   6:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (a->used + x > FP_SIZE) return FP_VAL;
   8:	dc2b      	bgt.n	62 <fp_lshd+0x62>
    y = a->used + x - 1;
   a:	f102 3cff 	add.w	ip, r2, #4294967295	; 0xffffffff
    a->used = y + 1;
   e:	1c54      	adds	r4, r2, #1
  10:	f06f 0603 	mvn.w	r6, #3
  14:	6002      	str	r2, [r0, #0]
    for (; y >= x; y--) {
  16:	eb00 0484 	add.w	r4, r0, r4, lsl #2
  1a:	434e      	muls	r6, r1
    y = a->used + x - 1;
  1c:	4665      	mov	r5, ip
    for (; y >= x; y--) {
  1e:	428d      	cmp	r5, r1
  20:	da14      	bge.n	4c <fp_lshd+0x4c>
  22:	425b      	negs	r3, r3
  24:	428a      	cmp	r2, r1
  26:	bfb8      	it	lt
  28:	2300      	movlt	r3, #0
  2a:	4463      	add	r3, ip
        a->dp[y] = 0;
  2c:	f100 0208 	add.w	r2, r0, #8
  30:	2100      	movs	r1, #0
    for (; y >= 0; y--) {
  32:	2b00      	cmp	r3, #0
  34:	da0f      	bge.n	56 <fp_lshd+0x56>
    fp_clamp(a);
  36:	6803      	ldr	r3, [r0, #0]
  38:	b12b      	cbz	r3, 46 <fp_lshd+0x46>
  3a:	1e5a      	subs	r2, r3, #1
  3c:	3301      	adds	r3, #1
  3e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
  42:	b163      	cbz	r3, 5e <fp_lshd+0x5e>
  44:	6843      	ldr	r3, [r0, #4]
  46:	6043      	str	r3, [r0, #4]
  48:	2000      	movs	r0, #0
}
  4a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        a->dp[y] = a->dp[y-x];
  4c:	59a7      	ldr	r7, [r4, r6]
  4e:	f844 7904 	str.w	r7, [r4], #-4
    for (; y >= x; y--) {
  52:	3d01      	subs	r5, #1
  54:	e7e3      	b.n	1e <fp_lshd+0x1e>
        a->dp[y] = 0;
  56:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (; y >= 0; y--) {
  5a:	3b01      	subs	r3, #1
  5c:	e7e9      	b.n	32 <fp_lshd+0x32>
    fp_clamp(a);
  5e:	6002      	str	r2, [r0, #0]
  60:	e7e9      	b.n	36 <fp_lshd+0x36>
    if (a->used + x > FP_SIZE) return FP_VAL;
  62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  66:	e7f0      	b.n	4a <fp_lshd+0x4a>

Disassembly of section .text.fp_zero:

00000000 <fp_zero>:
    a->used = 0;
   0:	2100      	movs	r1, #0
    a->sign = FP_ZPOS;
   2:	e9c0 1100 	strd	r1, r1, [r0]
    XMEMSET(a->dp, 0, size * sizeof(fp_digit));
   6:	2260      	movs	r2, #96	; 0x60
   8:	3008      	adds	r0, #8
   a:	f7ff bffe 	b.w	0 <memset>

Disassembly of section .text.fp_2expt:

00000000 <fp_2expt>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	460c      	mov	r4, r1
   4:	4605      	mov	r5, r0
   fp_zero (a);
   6:	f7ff fffe 	bl	0 <fp_2expt>
   if (z >= FP_SIZE) {
   a:	f5b4 7f40 	cmp.w	r4, #768	; 0x300
   e:	d20a      	bcs.n	26 <fp_2expt+0x26>
   z = b / DIGIT_BIT;
  10:	1163      	asrs	r3, r4, #5
  a->used = z + 1;
  12:	1c5a      	adds	r2, r3, #1
  a->dp[z] = ((fp_digit)1) << (b % DIGIT_BIT);
  14:	f004 041f 	and.w	r4, r4, #31
  18:	3302      	adds	r3, #2
  1a:	2101      	movs	r1, #1
  1c:	fa01 f404 	lsl.w	r4, r1, r4
  a->used = z + 1;
  20:	602a      	str	r2, [r5, #0]
  a->dp[z] = ((fp_digit)1) << (b % DIGIT_BIT);
  22:	f845 4023 	str.w	r4, [r5, r3, lsl #2]
}
  26:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.fp_read_unsigned_bin:

00000000 <fp_read_unsigned_bin>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4614      	mov	r4, r2
   4:	4605      	mov	r5, r0
   6:	460e      	mov	r6, r1
  fp_zero (a);
   8:	f7ff fffe 	bl	0 <fp_read_unsigned_bin>
  if (c == 0) {
   c:	b1ac      	cbz	r4, 3a <fp_read_unsigned_bin+0x3a>
  if (c > 0 && (word32)c > maxC) {
   e:	2c60      	cmp	r4, #96	; 0x60
     int excess = (c - maxC);
  10:	bfc2      	ittt	gt
  12:	3c60      	subgt	r4, #96	; 0x60
     b += excess;
  14:	1936      	addgt	r6, r6, r4
     c -= excess;
  16:	2460      	movgt	r4, #96	; 0x60
     a->used = (c + sizeof(fp_digit) - 1)/sizeof(fp_digit);
  18:	1ce2      	adds	r2, r4, #3
  1a:	462b      	mov	r3, r5
  1c:	0892      	lsrs	r2, r2, #2
  1e:	f843 2b08 	str.w	r2, [r3], #8
     for (c -= 1; c >= 0; c -= 1) {
  22:	3c01      	subs	r4, #1
  24:	2c00      	cmp	r4, #0
  26:	da0a      	bge.n	3e <fp_read_unsigned_bin+0x3e>
  fp_clamp (a);
  28:	682b      	ldr	r3, [r5, #0]
  2a:	b12b      	cbz	r3, 38 <fp_read_unsigned_bin+0x38>
  2c:	1e5a      	subs	r2, r3, #1
  2e:	3301      	adds	r3, #1
  30:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
  34:	b13b      	cbz	r3, 46 <fp_read_unsigned_bin+0x46>
  36:	686b      	ldr	r3, [r5, #4]
  38:	606b      	str	r3, [r5, #4]
}
  3a:	2000      	movs	r0, #0
  3c:	bd70      	pop	{r4, r5, r6, pc}
       pd[c] = *b++;
  3e:	f816 2b01 	ldrb.w	r2, [r6], #1
  42:	551a      	strb	r2, [r3, r4]
  44:	e7ed      	b.n	22 <fp_read_unsigned_bin+0x22>
  fp_clamp (a);
  46:	602a      	str	r2, [r5, #0]
  48:	e7ee      	b.n	28 <fp_read_unsigned_bin+0x28>

Disassembly of section .text.fp_set:

00000000 <fp_set>:
{
   0:	b538      	push	{r3, r4, r5, lr}
   2:	4605      	mov	r5, r0
   4:	460c      	mov	r4, r1
   fp_zero(a);
   6:	f7ff fffe 	bl	0 <fp_set>
   a->dp[0] = b;
   a:	60ac      	str	r4, [r5, #8]
   a->used  = a->dp[0] ? 1 : 0;
   c:	3c00      	subs	r4, #0
   e:	bf18      	it	ne
  10:	2401      	movne	r4, #1
  12:	602c      	str	r4, [r5, #0]
}
  14:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.fp_montgomery_calc_normalization:

00000000 <fp_montgomery_calc_normalization>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
  bits = fp_count_bits (b) % DIGIT_BIT;
   4:	4608      	mov	r0, r1
   6:	f7ff fffe 	bl	0 <fp_montgomery_calc_normalization>
  if (!bits) bits = DIGIT_BIT;
   a:	f010 041f 	ands.w	r4, r0, #31
{
   e:	460e      	mov	r6, r1
  if (!bits) bits = DIGIT_BIT;
  10:	d024      	beq.n	5c <fp_montgomery_calc_normalization+0x5c>
  bits = fp_count_bits (b) % DIGIT_BIT;
  12:	4240      	negs	r0, r0
  14:	f000 001f 	and.w	r0, r0, #31
  18:	bf58      	it	pl
  1a:	4244      	negpl	r4, r0
  if (b->used > 1) {
  1c:	6831      	ldr	r1, [r6, #0]
  1e:	2901      	cmp	r1, #1
  20:	dd1e      	ble.n	60 <fp_montgomery_calc_normalization+0x60>
     fp_2expt (a, (b->used - 1) * DIGIT_BIT + bits - 1);
  22:	eb04 1141 	add.w	r1, r4, r1, lsl #5
  26:	3921      	subs	r1, #33	; 0x21
  28:	4628      	mov	r0, r5
  2a:	f7ff fffe 	bl	0 <fp_montgomery_calc_normalization>
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
  2e:	3c01      	subs	r4, #1
    int err = fp_mul_2 (a, a);
  30:	4629      	mov	r1, r5
  32:	4628      	mov	r0, r5
  34:	f7ff fffe 	bl	0 <fp_montgomery_calc_normalization>
    if (err != FP_OKAY) {
  38:	4607      	mov	r7, r0
  3a:	b968      	cbnz	r0, 58 <fp_montgomery_calc_normalization+0x58>
    if (fp_cmp_mag (a, b) != FP_LT) {
  3c:	4631      	mov	r1, r6
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <fp_montgomery_calc_normalization>
  44:	3001      	adds	r0, #1
  46:	d004      	beq.n	52 <fp_montgomery_calc_normalization+0x52>
      s_fp_sub (a, b, a);
  48:	462a      	mov	r2, r5
  4a:	4631      	mov	r1, r6
  4c:	4628      	mov	r0, r5
  4e:	f7ff fffe 	bl	0 <fp_montgomery_calc_normalization>
  for (x = bits - 1; x < (int)DIGIT_BIT; x++) {
  52:	3401      	adds	r4, #1
  54:	2c20      	cmp	r4, #32
  56:	d1eb      	bne.n	30 <fp_montgomery_calc_normalization+0x30>
}
  58:	4638      	mov	r0, r7
  5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (!bits) bits = DIGIT_BIT;
  5c:	2420      	movs	r4, #32
  5e:	e7dd      	b.n	1c <fp_montgomery_calc_normalization+0x1c>
   a->dp[0] = b;
  60:	2401      	movs	r4, #1
   fp_zero(a);
  62:	4628      	mov	r0, r5
  64:	f7ff fffe 	bl	0 <fp_montgomery_calc_normalization>
   a->dp[0] = b;
  68:	60ac      	str	r4, [r5, #8]
   a->used  = a->dp[0] ? 1 : 0;
  6a:	602c      	str	r4, [r5, #0]
     bits = 1;
  6c:	e7df      	b.n	2e <fp_montgomery_calc_normalization+0x2e>

Disassembly of section .text.fp_rshd:

00000000 <fp_rshd>:
{
   0:	b4f0      	push	{r4, r5, r6, r7}
  if (x >= a->used) {
   2:	6804      	ldr	r4, [r0, #0]
   4:	428c      	cmp	r4, r1
{
   6:	4603      	mov	r3, r0
  if (x >= a->used) {
   8:	dd16      	ble.n	38 <fp_rshd+0x38>
   a:	f100 0608 	add.w	r6, r0, #8
   e:	4635      	mov	r5, r6
   for (y = 0; y < a->used - x; y++) {
  10:	2200      	movs	r2, #0
  12:	1a60      	subs	r0, r4, r1
  14:	4290      	cmp	r0, r2
  16:	dc12      	bgt.n	3e <fp_rshd+0x3e>
  18:	4602      	mov	r2, r0
      a->dp[y] = 0;
  1a:	2100      	movs	r1, #0
   for (; y < a->used; y++) {
  1c:	4294      	cmp	r4, r2
  1e:	dc14      	bgt.n	4a <fp_rshd+0x4a>
   a->used -= x;
  20:	6018      	str	r0, [r3, #0]
   fp_clamp(a);
  22:	681a      	ldr	r2, [r3, #0]
  24:	b12a      	cbz	r2, 32 <fp_rshd+0x32>
  26:	1e51      	subs	r1, r2, #1
  28:	3201      	adds	r2, #1
  2a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  2e:	b182      	cbz	r2, 52 <fp_rshd+0x52>
  30:	685a      	ldr	r2, [r3, #4]
  32:	605a      	str	r2, [r3, #4]
}
  34:	bcf0      	pop	{r4, r5, r6, r7}
  36:	4770      	bx	lr
  38:	bcf0      	pop	{r4, r5, r6, r7}
     fp_zero(a);
  3a:	f7ff bffe 	b.w	0 <fp_rshd>
      a->dp[y] = a->dp[y+x];
  3e:	f855 7021 	ldr.w	r7, [r5, r1, lsl #2]
  42:	f845 7b04 	str.w	r7, [r5], #4
   for (y = 0; y < a->used - x; y++) {
  46:	3201      	adds	r2, #1
  48:	e7e4      	b.n	14 <fp_rshd+0x14>
      a->dp[y] = 0;
  4a:	f846 1022 	str.w	r1, [r6, r2, lsl #2]
   for (; y < a->used; y++) {
  4e:	3201      	adds	r2, #1
  50:	e7e4      	b.n	1c <fp_rshd+0x1c>
   fp_clamp(a);
  52:	6019      	str	r1, [r3, #0]
  54:	e7e5      	b.n	22 <fp_rshd+0x22>

Disassembly of section .text.fp_rshb:

00000000 <fp_rshb>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (x <= 0) return;
   2:	1e0c      	subs	r4, r1, #0
{
   4:	4605      	mov	r5, r0
    if (x <= 0) return;
   6:	dd1f      	ble.n	48 <fp_rshb+0x48>
    if (x >= DIGIT_BIT) {
   8:	2c1f      	cmp	r4, #31
   a:	dd05      	ble.n	18 <fp_rshb+0x18>
        fp_rshd(c, x / DIGIT_BIT);
   c:	1161      	asrs	r1, r4, #5
   e:	f7ff fffe 	bl	0 <fp_rshb>
        if (D == 0) return;
  12:	f014 041f 	ands.w	r4, r4, #31
  16:	d017      	beq.n	48 <fp_rshb+0x48>
    if (fp_iszero(c)) return;
  18:	682b      	ldr	r3, [r5, #0]
  1a:	b1ab      	cbz	r3, 48 <fp_rshb+0x48>
    shift = DIGIT_BIT - D;
  1c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    tmpc = c->dp + (c->used - 1);
  20:	eb05 0283 	add.w	r2, r5, r3, lsl #2
  24:	40a1      	lsls	r1, r4
    shift = DIGIT_BIT - D;
  26:	f1c4 0720 	rsb	r7, r4, #32
    tmpc = c->dp + (c->used - 1);
  2a:	3204      	adds	r2, #4
    for (x = c->used - 1; x >= 0; x--) {
  2c:	3b01      	subs	r3, #1
  2e:	43c9      	mvns	r1, r1
    r = 0;
  30:	2000      	movs	r0, #0
    for (x = c->used - 1; x >= 0; x--) {
  32:	2b00      	cmp	r3, #0
  34:	da09      	bge.n	4a <fp_rshb+0x4a>
    fp_clamp(c);
  36:	682b      	ldr	r3, [r5, #0]
  38:	b12b      	cbz	r3, 46 <fp_rshb+0x46>
  3a:	1e5a      	subs	r2, r3, #1
  3c:	3301      	adds	r3, #1
  3e:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
  42:	b173      	cbz	r3, 62 <fp_rshb+0x62>
  44:	686b      	ldr	r3, [r5, #4]
  46:	606b      	str	r3, [r5, #4]
}
  48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      rr = *tmpc & mask;
  4a:	f8d2 c000 	ldr.w	ip, [r2]
      *tmpc = (*tmpc >> D) | (r << shift);
  4e:	40b8      	lsls	r0, r7
  50:	fa2c f604 	lsr.w	r6, ip, r4
  54:	4330      	orrs	r0, r6
  56:	f842 0904 	str.w	r0, [r2], #-4
    for (x = c->used - 1; x >= 0; x--) {
  5a:	3b01      	subs	r3, #1
      r = rr;
  5c:	ea0c 0001 	and.w	r0, ip, r1
  60:	e7e7      	b.n	32 <fp_rshb+0x32>
    fp_clamp(c);
  62:	602a      	str	r2, [r5, #0]
  64:	e7e7      	b.n	36 <fp_rshb+0x36>

Disassembly of section .text.fp_init:

00000000 <fp_init>:
    fp_zero(a);
   0:	f7ff bffe 	b.w	0 <fp_init>

Disassembly of section .text.fp_sub_d:

00000000 <fp_sub_d>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   4:	2068      	movs	r0, #104	; 0x68
{
   6:	460f      	mov	r7, r1
   8:	4616      	mov	r6, r2
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   a:	f7ff fffe 	bl	0 <malloc>
   e:	4604      	mov	r4, r0
   if (tmp == NULL)
  10:	b180      	cbz	r0, 34 <fp_sub_d+0x34>
    fp_zero(a);
  12:	f7ff fffe 	bl	0 <fp_sub_d>
   fp_set(tmp, b);
  16:	4639      	mov	r1, r7
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <fp_sub_d>
     err = fp_sub(a, tmp, c);
  1e:	4628      	mov	r0, r5
  20:	4632      	mov	r2, r6
  22:	4621      	mov	r1, r4
  24:	f7ff fffe 	bl	0 <fp_sub_d>
  28:	4605      	mov	r5, r0
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
  2a:	4620      	mov	r0, r4
  2c:	f7ff fffe 	bl	0 <free>
}
  30:	4628      	mov	r0, r5
  32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       return FP_MEM;
  34:	f06f 0501 	mvn.w	r5, #1
  38:	e7fa      	b.n	30 <fp_sub_d+0x30>

Disassembly of section .text.mp_init:

00000000 <mp_init>:
{
   0:	b508      	push	{r3, lr}
  if (a)
   2:	b108      	cbz	r0, 8 <mp_init+0x8>
    fp_zero(a);
   4:	f7ff fffe 	bl	0 <mp_init>
}
   8:	2000      	movs	r0, #0
   a:	bd08      	pop	{r3, pc}

Disassembly of section .text.fp_clear:

00000000 <fp_clear>:
   0:	f7ff bffe 	b.w	0 <fp_clear>

Disassembly of section .text.fp_forcezero:

00000000 <fp_forcezero>:
    if (a == NULL)
   0:	b138      	cbz	r0, 12 <fp_forcezero+0x12>
    a->used = 0;
   2:	2200      	movs	r2, #0
    a->sign = FP_ZPOS;
   4:	e9c0 2200 	strd	r2, r2, [r0]
    ForceZero(a->dp, size * sizeof(fp_digit));
   8:	f100 0308 	add.w	r3, r0, #8
#endif

#ifndef WOLFSSL_NO_FORCE_ZERO
/* This routine fills the first len bytes of the memory area pointed by mem
   with zeros. It ensures compiler optimizations doesn't skip it  */
WC_MISC_STATIC WC_INLINE void ForceZero(void* mem, word32 len)
   c:	3068      	adds	r0, #104	; 0x68
            *w++ = 0;
        }
    z = (volatile byte*)w;
#endif

    while (len--) *z++ = 0;
   e:	4283      	cmp	r3, r0
  10:	d100      	bne.n	14 <fp_forcezero+0x14>
}
  12:	4770      	bx	lr
  14:	f803 2b01 	strb.w	r2, [r3], #1
  18:	e7f9      	b.n	e <fp_forcezero+0xe>

Disassembly of section .text.mp_forcezero:

00000000 <mp_forcezero>:
    fp_forcezero(a);
   0:	f7ff bffe 	b.w	0 <mp_forcezero>

Disassembly of section .text.fp_free:

00000000 <fp_free>:
}
   0:	4770      	bx	lr

Disassembly of section .text.mp_clear:

00000000 <mp_clear>:
    if (a == NULL)
   0:	b108      	cbz	r0, 6 <mp_clear+0x6>
    fp_clear(a);
   2:	f7ff bffe 	b.w	0 <mp_clear>
}
   6:	4770      	bx	lr

Disassembly of section .text.mp_free:

00000000 <mp_free>:
   0:	4770      	bx	lr

Disassembly of section .text.mp_init_multi:

00000000 <mp_init_multi>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	460e      	mov	r6, r1
   6:	e9dd 8706 	ldrd	r8, r7, [sp, #24]
   a:	4615      	mov	r5, r2
   c:	461c      	mov	r4, r3
    if (a)
   e:	b108      	cbz	r0, 14 <mp_init_multi+0x14>
    fp_zero(a);
  10:	f7ff fffe 	bl	0 <mp_init_multi>
    if (b)
  14:	b116      	cbz	r6, 1c <mp_init_multi+0x1c>
    fp_zero(a);
  16:	4630      	mov	r0, r6
  18:	f7ff fffe 	bl	0 <mp_init_multi>
    if (c)
  1c:	b115      	cbz	r5, 24 <mp_init_multi+0x24>
    fp_zero(a);
  1e:	4628      	mov	r0, r5
  20:	f7ff fffe 	bl	0 <mp_init_multi>
    if (d)
  24:	b114      	cbz	r4, 2c <mp_init_multi+0x2c>
    fp_zero(a);
  26:	4620      	mov	r0, r4
  28:	f7ff fffe 	bl	0 <mp_init_multi>
    if (e)
  2c:	f1b8 0f00 	cmp.w	r8, #0
  30:	d002      	beq.n	38 <mp_init_multi+0x38>
    fp_zero(a);
  32:	4640      	mov	r0, r8
  34:	f7ff fffe 	bl	0 <mp_init_multi>
    if (f)
  38:	b117      	cbz	r7, 40 <mp_init_multi+0x40>
    fp_zero(a);
  3a:	4638      	mov	r0, r7
  3c:	f7ff fffe 	bl	0 <mp_init_multi>
}
  40:	2000      	movs	r0, #0
  42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

Disassembly of section .text.mp_add:

00000000 <mp_add>:
  return fp_add(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_add>

Disassembly of section .text.mp_sub:

00000000 <mp_sub>:
  return fp_sub(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_sub>

Disassembly of section .text.mp_mul_d:

00000000 <mp_mul_d>:
  return fp_mul_d(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_mul_d>

Disassembly of section .text.mp_submod_ct:

00000000 <mp_submod_ct>:
  return fp_submod_ct(a, b, c, d);
   0:	f7ff bffe 	b.w	0 <mp_submod_ct>

Disassembly of section .text.mp_addmod_ct:

00000000 <mp_addmod_ct>:
  return fp_addmod_ct(a, b, c, d);
   0:	f7ff bffe 	b.w	0 <mp_addmod_ct>

Disassembly of section .text.mp_cmp:

00000000 <mp_cmp>:
  return fp_cmp(a, b);
   0:	f7ff bffe 	b.w	0 <mp_cmp>

Disassembly of section .text.mp_cmp_d:

00000000 <mp_cmp_d>:
  return fp_cmp_d(a, b);
   0:	f7ff bffe 	b.w	0 <mp_cmp_d>

Disassembly of section .text.mp_unsigned_bin_size:

00000000 <mp_unsigned_bin_size>:
  return fp_unsigned_bin_size(a);
   0:	f7ff bffe 	b.w	0 <mp_unsigned_bin_size>

Disassembly of section .text.mp_to_unsigned_bin_at_pos:

00000000 <mp_to_unsigned_bin_at_pos>:
  return fp_to_unsigned_bin_at_pos(x, t, b);
   0:	f7ff bffe 	b.w	0 <mp_to_unsigned_bin_at_pos>

Disassembly of section .text.mp_to_unsigned_bin_len:

00000000 <mp_to_unsigned_bin_len>:
  return fp_to_unsigned_bin_len(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_to_unsigned_bin_len>

Disassembly of section .text.mp_read_unsigned_bin:

00000000 <mp_read_unsigned_bin>:
  return fp_read_unsigned_bin(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_read_unsigned_bin>

Disassembly of section .text.mp_sub_d:

00000000 <mp_sub_d>:
  return fp_sub_d(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_sub_d>

Disassembly of section .text.mp_2expt:

00000000 <mp_2expt>:
{
   0:	b508      	push	{r3, lr}
  fp_2expt(a, b);
   2:	f7ff fffe 	bl	0 <mp_2expt>
}
   6:	2000      	movs	r0, #0
   8:	bd08      	pop	{r3, pc}

Disassembly of section .text.fp_copy:

00000000 <fp_copy>:
    if (a != b) {
   0:	4288      	cmp	r0, r1
{
   2:	460b      	mov	r3, r1
    if (a != b) {
   4:	d00a      	beq.n	1c <fp_copy+0x1c>
        b->used = a->used;
   6:	6802      	ldr	r2, [r0, #0]
   8:	600a      	str	r2, [r1, #0]
        b->sign = a->sign;
   a:	6842      	ldr	r2, [r0, #4]
   c:	604a      	str	r2, [r1, #4]
        XMEMCPY(b->dp, a->dp, FP_SIZE * sizeof(fp_digit));
   e:	f100 0108 	add.w	r1, r0, #8
  12:	2260      	movs	r2, #96	; 0x60
  14:	f103 0008 	add.w	r0, r3, #8
  18:	f7ff bffe 	b.w	0 <memcpy>
}
  1c:	4770      	bx	lr

Disassembly of section .text.fp_mul_2d:

00000000 <fp_mul_2d>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	460d      	mov	r5, r1
   fp_copy(a, c);
   4:	4611      	mov	r1, r2
{
   6:	4614      	mov	r4, r2
   fp_copy(a, c);
   8:	f7ff fffe 	bl	0 <fp_mul_2d>
   if (b >= DIGIT_BIT) {
   c:	2d1f      	cmp	r5, #31
   e:	dc0d      	bgt.n	2c <fp_mul_2d+0x2c>
   if (b != 0) {
  10:	f015 061f 	ands.w	r6, r5, #31
  14:	d111      	bne.n	3a <fp_mul_2d+0x3a>
   fp_clamp(c);
  16:	6823      	ldr	r3, [r4, #0]
  18:	b12b      	cbz	r3, 26 <fp_mul_2d+0x26>
  1a:	1e5a      	subs	r2, r3, #1
  1c:	3301      	adds	r3, #1
  1e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  22:	b383      	cbz	r3, 86 <fp_mul_2d+0x86>
  24:	6863      	ldr	r3, [r4, #4]
  26:	6063      	str	r3, [r4, #4]
   return FP_OKAY;
  28:	2000      	movs	r0, #0
  2a:	e005      	b.n	38 <fp_mul_2d+0x38>
      int ret = fp_lshd(c, b/DIGIT_BIT);
  2c:	1169      	asrs	r1, r5, #5
  2e:	4620      	mov	r0, r4
  30:	f7ff fffe 	bl	0 <fp_mul_2d>
      if (ret != FP_OKAY)
  34:	2800      	cmp	r0, #0
  36:	d0eb      	beq.n	10 <fp_mul_2d+0x10>
}
  38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   b %= DIGIT_BIT;
  3a:	426d      	negs	r5, r5
      for (x = 0; x < c->used; x++) {
  3c:	4622      	mov	r2, r4
   b %= DIGIT_BIT;
  3e:	f005 051f 	and.w	r5, r5, #31
  42:	bf58      	it	pl
  44:	426e      	negpl	r6, r5
      for (x = 0; x < c->used; x++) {
  46:	2000      	movs	r0, #0
  48:	f852 3b08 	ldr.w	r3, [r2], #8
      shift = DIGIT_BIT - b;
  4c:	f1c6 0c20 	rsb	ip, r6, #32
      carry = 0;
  50:	4601      	mov	r1, r0
      for (x = 0; x < c->used; x++) {
  52:	4283      	cmp	r3, r0
  54:	dc08      	bgt.n	68 <fp_mul_2d+0x68>
      if (carry && x < FP_SIZE) {
  56:	b189      	cbz	r1, 7c <fp_mul_2d+0x7c>
  58:	2b17      	cmp	r3, #23
  5a:	dc0f      	bgt.n	7c <fp_mul_2d+0x7c>
         c->dp[c->used++] = carry;
  5c:	1c5a      	adds	r2, r3, #1
  5e:	3302      	adds	r3, #2
  60:	6022      	str	r2, [r4, #0]
  62:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
      if (x == FP_SIZE)
  66:	e7d6      	b.n	16 <fp_mul_2d+0x16>
          carrytmp = c->dp[x] >> shift;
  68:	6817      	ldr	r7, [r2, #0]
          c->dp[x] = (c->dp[x] << b) + carry;
  6a:	fa07 f506 	lsl.w	r5, r7, r6
  6e:	4429      	add	r1, r5
  70:	f842 1b04 	str.w	r1, [r2], #4
      for (x = 0; x < c->used; x++) {
  74:	3001      	adds	r0, #1
          carry = carrytmp;
  76:	fa27 f10c 	lsr.w	r1, r7, ip
  7a:	e7ea      	b.n	52 <fp_mul_2d+0x52>
      if (x == FP_SIZE)
  7c:	2b18      	cmp	r3, #24
  7e:	d1ca      	bne.n	16 <fp_mul_2d+0x16>
         return FP_VAL;
  80:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  84:	e7d8      	b.n	38 <fp_mul_2d+0x38>
   fp_clamp(c);
  86:	6022      	str	r2, [r4, #0]
  88:	e7c5      	b.n	16 <fp_mul_2d+0x16>

Disassembly of section .text.fp_set_int:

00000000 <fp_set_int>:
  if (b < FP_DIGIT_MAX)
   0:	1c4b      	adds	r3, r1, #1
{
   2:	b570      	push	{r4, r5, r6, lr}
   4:	4604      	mov	r4, r0
   6:	460d      	mov	r5, r1
  if (b < FP_DIGIT_MAX)
   8:	d003      	beq.n	12 <fp_set_int+0x12>
    fp_set (a, (fp_digit)b);
   a:	f7ff fffe 	bl	0 <fp_set_int>
    return FP_OKAY;
   e:	2000      	movs	r0, #0
}
  10:	bd70      	pop	{r4, r5, r6, pc}
  fp_zero (a);
  12:	f7ff fffe 	bl	0 <fp_set_int>
  16:	2608      	movs	r6, #8
    int err = fp_mul_2d (a, MP_SET_CHUNK_BITS, a);
  18:	4622      	mov	r2, r4
  1a:	2104      	movs	r1, #4
  1c:	4620      	mov	r0, r4
  1e:	f7ff fffe 	bl	0 <fp_set_int>
    if (err != FP_OKAY)
  22:	2800      	cmp	r0, #0
  24:	d1f4      	bne.n	10 <fp_set_int+0x10>
    a->dp[0] |= (b >> ((sizeof(b) * 8) - MP_SET_CHUNK_BITS)) &
  26:	68a3      	ldr	r3, [r4, #8]
  28:	ea43 7315 	orr.w	r3, r3, r5, lsr #28
  2c:	60a3      	str	r3, [r4, #8]
    a->used += 1;
  2e:	6823      	ldr	r3, [r4, #0]
  for (x = 0; x < (int)(sizeof(b) * 8) / MP_SET_CHUNK_BITS; x++) {
  30:	3e01      	subs	r6, #1
    a->used += 1;
  32:	f103 0301 	add.w	r3, r3, #1
    b <<= MP_SET_CHUNK_BITS;
  36:	ea4f 1505 	mov.w	r5, r5, lsl #4
    a->used += 1;
  3a:	6023      	str	r3, [r4, #0]
  for (x = 0; x < (int)(sizeof(b) * 8) / MP_SET_CHUNK_BITS; x++) {
  3c:	d1ec      	bne.n	18 <fp_set_int+0x18>
  fp_clamp(a);
  3e:	6823      	ldr	r3, [r4, #0]
  40:	b12b      	cbz	r3, 4e <fp_set_int+0x4e>
  42:	1e5a      	subs	r2, r3, #1
  44:	3301      	adds	r3, #1
  46:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  4a:	b113      	cbz	r3, 52 <fp_set_int+0x52>
  4c:	6863      	ldr	r3, [r4, #4]
  4e:	6063      	str	r3, [r4, #4]
  return FP_OKAY;
  50:	e7de      	b.n	10 <fp_set_int+0x10>
  fp_clamp(a);
  52:	6022      	str	r2, [r4, #0]
  54:	e7f3      	b.n	3e <fp_set_int+0x3e>

Disassembly of section .text.mp_mul_2d:

00000000 <mp_mul_2d>:
  return fp_mul_2d(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_mul_2d>

Disassembly of section .text.fp_mul_comba:

00000000 <fp_mul_comba>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b087      	sub	sp, #28
   if (A->used + B->used >= FP_SIZE) return FP_VAL;
   6:	6803      	ldr	r3, [r0, #0]
{
   8:	9205      	str	r2, [sp, #20]
   if (A->used + B->used >= FP_SIZE) return FP_VAL;
   a:	680a      	ldr	r2, [r1, #0]
   c:	4413      	add	r3, r2
   e:	2b17      	cmp	r3, #23
{
  10:	4606      	mov	r6, r0
  12:	460d      	mov	r5, r1
   if (A->used + B->used >= FP_SIZE) return FP_VAL;
  14:	dc6e      	bgt.n	f4 <fp_mul_comba+0xf4>
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
  16:	2068      	movs	r0, #104	; 0x68
  18:	f7ff fffe 	bl	0 <malloc>
   if (tmp == NULL)
  1c:	4604      	mov	r4, r0
  1e:	2800      	cmp	r0, #0
  20:	d06b      	beq.n	fa <fp_mul_comba+0xfa>
   pa = A->used + B->used;
  22:	4637      	mov	r7, r6
  24:	46a8      	mov	r8, r5
  26:	f857 3b08 	ldr.w	r3, [r7], #8
  2a:	f858 2b08 	ldr.w	r2, [r8], #8
  2e:	4413      	add	r3, r2
   if (pa >= FP_SIZE) {
  30:	2b17      	cmp	r3, #23
  32:	bfa8      	it	ge
  34:	2317      	movge	r3, #23
  36:	9302      	str	r3, [sp, #8]
    fp_zero(a);
  38:	f7ff fffe 	bl	0 <fp_mul_comba>
   COMBA_CLEAR;
  3c:	2200      	movs	r2, #0
  3e:	f104 0308 	add.w	r3, r4, #8
  42:	9303      	str	r3, [sp, #12]
  44:	4611      	mov	r1, r2
   for (ix = 0; ix < pa; ix++) {
  46:	4694      	mov	ip, r2
  48:	9b02      	ldr	r3, [sp, #8]
  4a:	459c      	cmp	ip, r3
  4c:	db18      	blt.n	80 <fp_mul_comba+0x80>
  dst->sign = A->sign ^ B->sign;
  4e:	6871      	ldr	r1, [r6, #4]
  50:	686a      	ldr	r2, [r5, #4]
  dst->used = pa;
  52:	6023      	str	r3, [r4, #0]
  fp_clamp(dst);
  54:	6823      	ldr	r3, [r4, #0]
  56:	b13b      	cbz	r3, 68 <fp_mul_comba+0x68>
  58:	1e58      	subs	r0, r3, #1
  5a:	3301      	adds	r3, #1
  5c:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  60:	2b00      	cmp	r3, #0
  62:	d045      	beq.n	f0 <fp_mul_comba+0xf0>
  dst->sign = A->sign ^ B->sign;
  64:	ea81 0302 	eor.w	r3, r1, r2
  fp_copy(dst, C);
  68:	9905      	ldr	r1, [sp, #20]
  fp_clamp(dst);
  6a:	6063      	str	r3, [r4, #4]
  fp_copy(dst, C);
  6c:	4620      	mov	r0, r4
  6e:	f7ff fffe 	bl	0 <fp_mul_comba>
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
  72:	4620      	mov	r0, r4
  74:	f7ff fffe 	bl	0 <free>
  return ret;
  78:	2000      	movs	r0, #0
}
  7a:	b007      	add	sp, #28
  7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      ty = MIN(ix, (B->used > 0 ? B->used - 1 : 0));
  80:	682b      	ldr	r3, [r5, #0]
  82:	2b01      	cmp	r3, #1
  84:	bfb8      	it	lt
  86:	2301      	movlt	r3, #1
  88:	3b01      	subs	r3, #1
  8a:	4563      	cmp	r3, ip
  8c:	bfa8      	it	ge
  8e:	4663      	movge	r3, ip
      tx = ix - ty;
  90:	ebac 0e03 	sub.w	lr, ip, r3
      tmpx = A->dp + tx;
  94:	eb07 008e 	add.w	r0, r7, lr, lsl #2
  98:	9004      	str	r0, [sp, #16]
      tmpy = B->dp + ty;
  9a:	eb08 0083 	add.w	r0, r8, r3, lsl #2
  9e:	9001      	str	r0, [sp, #4]
      iy = MIN(A->used-tx, ty+1);
  a0:	6830      	ldr	r0, [r6, #0]
  a2:	eba0 000e 	sub.w	r0, r0, lr
  a6:	4298      	cmp	r0, r3
      COMBA_FORWARD;
  a8:	468b      	mov	fp, r1
  aa:	4611      	mov	r1, r2
  ac:	f04f 0200 	mov.w	r2, #0
      iy = MIN(A->used-tx, ty+1);
  b0:	bfc8      	it	gt
  b2:	1c58      	addgt	r0, r3, #1
      for (iz = 0; iz < iy; ++iz) {
  b4:	4696      	mov	lr, r2
  b6:	4586      	cmp	lr, r0
  b8:	db06      	blt.n	c8 <fp_mul_comba+0xc8>
      COMBA_STORE(dst->dp[ix]);
  ba:	9b03      	ldr	r3, [sp, #12]
  bc:	f843 bb04 	str.w	fp, [r3], #4
   for (ix = 0; ix < pa; ix++) {
  c0:	f10c 0c01 	add.w	ip, ip, #1
      COMBA_STORE(dst->dp[ix]);
  c4:	9303      	str	r3, [sp, #12]
   for (ix = 0; ix < pa; ix++) {
  c6:	e7bf      	b.n	48 <fp_mul_comba+0x48>
          MULADD(_tmpx, _tmpy);
  c8:	f8dd 9004 	ldr.w	r9, [sp, #4]
  cc:	f859 3904 	ldr.w	r3, [r9], #-4
  d0:	f8cd 9004 	str.w	r9, [sp, #4]
  d4:	f8dd 9010 	ldr.w	r9, [sp, #16]
  d8:	f859 902e 	ldr.w	r9, [r9, lr, lsl #2]
  dc:	469a      	mov	sl, r3
  de:	2300      	movs	r3, #0
  e0:	fbe9 b30a 	umlal	fp, r3, r9, sl
  e4:	18c9      	adds	r1, r1, r3
  e6:	f142 0200 	adc.w	r2, r2, #0
      for (iz = 0; iz < iy; ++iz) {
  ea:	f10e 0e01 	add.w	lr, lr, #1
  ee:	e7e2      	b.n	b6 <fp_mul_comba+0xb6>
  fp_clamp(dst);
  f0:	6020      	str	r0, [r4, #0]
  f2:	e7af      	b.n	54 <fp_mul_comba+0x54>
   if (A->used + B->used >= FP_SIZE) return FP_VAL;
  f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  f8:	e7bf      	b.n	7a <fp_mul_comba+0x7a>
       return FP_MEM;
  fa:	f06f 0001 	mvn.w	r0, #1
  fe:	e7bc      	b.n	7a <fp_mul_comba+0x7a>

Disassembly of section .text.fp_mul:

00000000 <fp_mul>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    y  = MAX(A->used, B->used);
   2:	680f      	ldr	r7, [r1, #0]
   4:	6806      	ldr	r6, [r0, #0]
    oldused = C->used;
   6:	6815      	ldr	r5, [r2, #0]
    y  = MAX(A->used, B->used);
   8:	42b7      	cmp	r7, r6
   a:	463b      	mov	r3, r7
   c:	bfb8      	it	lt
   e:	4633      	movlt	r3, r6
    if (y + yy >= FP_SIZE) {
  10:	42b7      	cmp	r7, r6
  12:	bfd4      	ite	le
  14:	eb03 0c07 	addle.w	ip, r3, r7
  18:	eb03 0c06 	addgt.w	ip, r3, r6
  1c:	f1bc 0f17 	cmp.w	ip, #23
{
  20:	4614      	mov	r4, r2
    if (y + yy >= FP_SIZE) {
  22:	dc0f      	bgt.n	44 <fp_mul+0x44>
        if (y == 8) {
  24:	2b08      	cmp	r3, #8
  26:	d10a      	bne.n	3e <fp_mul+0x3e>
           ret = fp_mul_comba8(A,B,C);
  28:	f7ff fffe 	bl	0 <fp_mul>
    for (y = C->used; y >= 0 && y < oldused; y++) {
  2c:	4622      	mov	r2, r4
        C->dp[y] = 0;
  2e:	2100      	movs	r1, #0
    for (y = C->used; y >= 0 && y < oldused; y++) {
  30:	f852 3b08 	ldr.w	r3, [r2], #8
  34:	2b00      	cmp	r3, #0
  36:	db01      	blt.n	3c <fp_mul+0x3c>
  38:	42ab      	cmp	r3, r5
  3a:	db06      	blt.n	4a <fp_mul+0x4a>
}
  3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        ret = fp_mul_comba(A,B,C);
  3e:	f7ff fffe 	bl	0 <fp_mul>
  42:	e7f3      	b.n	2c <fp_mul+0x2c>
       ret = FP_VAL;
  44:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  48:	e7f0      	b.n	2c <fp_mul+0x2c>
        C->dp[y] = 0;
  4a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for (y = C->used; y >= 0 && y < oldused; y++) {
  4e:	3301      	adds	r3, #1
  50:	e7f0      	b.n	34 <fp_mul+0x34>

Disassembly of section .text.mp_mul:

00000000 <mp_mul>:
  return fp_mul(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_mul>

Disassembly of section .text.fp_mod_2d:

00000000 <fp_mod_2d>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   if (b <= 0) {
   2:	1e0d      	subs	r5, r1, #0
{
   4:	4607      	mov	r7, r0
   6:	4614      	mov	r4, r2
   if (b <= 0) {
   8:	dc04      	bgt.n	14 <fp_mod_2d+0x14>
}
   a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      fp_zero(c);
   e:	4610      	mov	r0, r2
  10:	f7ff bffe 	b.w	0 <fp_mod_2d>
   fp_copy(a, c);
  14:	4611      	mov	r1, r2
  16:	f7ff fffe 	bl	0 <fp_mod_2d>
   if (c->sign == FP_ZPOS && b >= (DIGIT_BIT * a->used)) {
  1a:	6866      	ldr	r6, [r4, #4]
  1c:	b91e      	cbnz	r6, 26 <fp_mod_2d+0x26>
  1e:	683b      	ldr	r3, [r7, #0]
  20:	ebb5 1f43 	cmp.w	r5, r3, lsl #5
  24:	da36      	bge.n	94 <fp_mod_2d+0x94>
   bmax = ((unsigned int)b + DIGIT_BIT - 1) / DIGIT_BIT;
  26:	f105 021f 	add.w	r2, r5, #31
   if (c->sign == FP_NEG && bmax > FP_SIZE) {
  2a:	2e01      	cmp	r6, #1
   bmax = ((unsigned int)b + DIGIT_BIT - 1) / DIGIT_BIT;
  2c:	ea4f 1352 	mov.w	r3, r2, lsr #5
   if (c->sign == FP_NEG && bmax > FP_SIZE) {
  30:	d02d      	beq.n	8e <fp_mod_2d+0x8e>
   for (x = bmax; x < (unsigned int)c->used; x++) {
  32:	4620      	mov	r0, r4
   bmax = ((unsigned int)b + DIGIT_BIT - 1) / DIGIT_BIT;
  34:	461a      	mov	r2, r3
   for (x = bmax; x < (unsigned int)c->used; x++) {
  36:	f850 1b08 	ldr.w	r1, [r0], #8
    c->dp[x] = 0;
  3a:	2700      	movs	r7, #0
   for (x = bmax; x < (unsigned int)c->used; x++) {
  3c:	4291      	cmp	r1, r2
  3e:	d82a      	bhi.n	96 <fp_mod_2d+0x96>
  if (c->sign == FP_NEG) {
  40:	2e01      	cmp	r6, #1
  42:	d10c      	bne.n	5e <fp_mod_2d+0x5e>
  44:	f104 0c08 	add.w	ip, r4, #8
     fp_digit carry = 0;
  48:	2200      	movs	r2, #0
  4a:	4666      	mov	r6, ip
     for (x = 0; x < (unsigned int)c->used; x++) {
  4c:	4610      	mov	r0, r2
  4e:	4281      	cmp	r1, r0
  50:	d125      	bne.n	9e <fp_mod_2d+0x9e>
         c->dp[x] = (fp_digit)0 - carry;
  52:	4252      	negs	r2, r2
     for (; x < bmax; x++) {
  54:	4299      	cmp	r1, r3
  56:	d330      	bcc.n	ba <fp_mod_2d+0xba>
     c->sign = FP_ZPOS;
  58:	2200      	movs	r2, #0
     c->used = (int)bmax;
  5a:	6023      	str	r3, [r4, #0]
     c->sign = FP_ZPOS;
  5c:	6062      	str	r2, [r4, #4]
  x = DIGIT_BIT - (b % DIGIT_BIT);
  5e:	f005 051f 	and.w	r5, r5, #31
  62:	f1c5 0120 	rsb	r1, r5, #32
  if (x != DIGIT_BIT) {
  66:	b145      	cbz	r5, 7a <fp_mod_2d+0x7a>
     c->dp[bmax - 1] &= ~((fp_digit)0) >> x;
  68:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  6c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  70:	fa22 f101 	lsr.w	r1, r2, r1
  74:	685a      	ldr	r2, [r3, #4]
  76:	400a      	ands	r2, r1
  78:	605a      	str	r2, [r3, #4]
  fp_clamp (c);
  7a:	6823      	ldr	r3, [r4, #0]
  7c:	b12b      	cbz	r3, 8a <fp_mod_2d+0x8a>
  7e:	1e5a      	subs	r2, r3, #1
  80:	3301      	adds	r3, #1
  82:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  86:	b1e3      	cbz	r3, c2 <fp_mod_2d+0xc2>
  88:	6863      	ldr	r3, [r4, #4]
  8a:	6063      	str	r3, [r4, #4]
  8c:	e002      	b.n	94 <fp_mod_2d+0x94>
   if (c->sign == FP_NEG && bmax > FP_SIZE) {
  8e:	f5b2 7f48 	cmp.w	r2, #800	; 0x320
  92:	d3ce      	bcc.n	32 <fp_mod_2d+0x32>
}
  94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c->dp[x] = 0;
  96:	f840 7022 	str.w	r7, [r0, r2, lsl #2]
   for (x = bmax; x < (unsigned int)c->used; x++) {
  9a:	3201      	adds	r2, #1
  9c:	e7ce      	b.n	3c <fp_mod_2d+0x3c>
         fp_digit next = c->dp[x] > 0;
  9e:	f8d6 e000 	ldr.w	lr, [r6]
         c->dp[x] = (fp_digit)0 - c->dp[x] - carry;
  a2:	eb0e 0702 	add.w	r7, lr, r2
  a6:	427f      	negs	r7, r7
  a8:	f846 7b04 	str.w	r7, [r6], #4
         carry |= next;
  ac:	f1be 0f00 	cmp.w	lr, #0
  b0:	bf18      	it	ne
  b2:	f042 0201 	orrne.w	r2, r2, #1
     for (x = 0; x < (unsigned int)c->used; x++) {
  b6:	3001      	adds	r0, #1
  b8:	e7c9      	b.n	4e <fp_mod_2d+0x4e>
         c->dp[x] = (fp_digit)0 - carry;
  ba:	f84c 2021 	str.w	r2, [ip, r1, lsl #2]
     for (; x < bmax; x++) {
  be:	3101      	adds	r1, #1
  c0:	e7c8      	b.n	54 <fp_mod_2d+0x54>
  fp_clamp (c);
  c2:	6022      	str	r2, [r4, #0]
  c4:	e7d9      	b.n	7a <fp_mod_2d+0x7a>

Disassembly of section .text.fp_div_2d:

00000000 <fp_div_2d>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (b <= 0) {
   2:	1e0d      	subs	r5, r1, #0
{
   4:	4607      	mov	r7, r0
   6:	4614      	mov	r4, r2
   8:	461e      	mov	r6, r3
  if (b <= 0) {
   a:	dc08      	bgt.n	1e <fp_div_2d+0x1e>
    fp_copy (a, c);
   c:	4611      	mov	r1, r2
   e:	f7ff fffe 	bl	0 <fp_div_2d>
    if (d != NULL) {
  12:	b35e      	cbz	r6, 6c <fp_div_2d+0x6c>
      fp_zero (d);
  14:	4630      	mov	r0, r6
}
  16:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      fp_zero (d);
  1a:	f7ff bffe 	b.w	0 <fp_div_2d>
  if (a == c && d != NULL) {
  1e:	4290      	cmp	r0, r2
  20:	d103      	bne.n	2a <fp_div_2d+0x2a>
  22:	b113      	cbz	r3, 2a <fp_div_2d+0x2a>
    fp_mod_2d (a, b, d);
  24:	461a      	mov	r2, r3
  26:	f7ff fffe 	bl	0 <fp_div_2d>
  fp_copy(a, c);
  2a:	4621      	mov	r1, r4
  2c:	4638      	mov	r0, r7
  2e:	f7ff fffe 	bl	0 <fp_div_2d>
  if (b >= (int)DIGIT_BIT) {
  32:	2d1f      	cmp	r5, #31
  34:	dd03      	ble.n	3e <fp_div_2d+0x3e>
    fp_rshd (c, b / DIGIT_BIT);
  36:	1169      	asrs	r1, r5, #5
  38:	4620      	mov	r0, r4
  3a:	f7ff fffe 	bl	0 <fp_div_2d>
  if (D != 0) {
  3e:	f015 011f 	ands.w	r1, r5, #31
  42:	d002      	beq.n	4a <fp_div_2d+0x4a>
    fp_rshb(c, D);
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <fp_div_2d>
  if (a != c && d != NULL) {
  4a:	42a7      	cmp	r7, r4
  4c:	d005      	beq.n	5a <fp_div_2d+0x5a>
  4e:	b126      	cbz	r6, 5a <fp_div_2d+0x5a>
    fp_mod_2d (a, b, d);
  50:	4632      	mov	r2, r6
  52:	4629      	mov	r1, r5
  54:	4638      	mov	r0, r7
  56:	f7ff fffe 	bl	0 <fp_div_2d>
  fp_clamp (c);
  5a:	6823      	ldr	r3, [r4, #0]
  5c:	b12b      	cbz	r3, 6a <fp_div_2d+0x6a>
  5e:	1e5a      	subs	r2, r3, #1
  60:	3301      	adds	r3, #1
  62:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  66:	b113      	cbz	r3, 6e <fp_div_2d+0x6e>
  68:	6863      	ldr	r3, [r4, #4]
  6a:	6063      	str	r3, [r4, #4]
}
  6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  fp_clamp (c);
  6e:	6022      	str	r2, [r4, #0]
  70:	e7f3      	b.n	5a <fp_div_2d+0x5a>

Disassembly of section .text.mp_div_2d:

00000000 <mp_div_2d>:
{
   0:	b508      	push	{r3, lr}
  fp_div_2d(a, b, c, d);
   2:	f7ff fffe 	bl	0 <mp_div_2d>
}
   6:	2000      	movs	r0, #0
   8:	bd08      	pop	{r3, pc}

Disassembly of section .text.fp_div:

00000000 <fp_div>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b08d      	sub	sp, #52	; 0x34
   6:	9305      	str	r3, [sp, #20]
  if (fp_iszero (b) == FP_YES) {
   8:	680b      	ldr	r3, [r1, #0]
{
   a:	9002      	str	r0, [sp, #8]
   c:	9104      	str	r1, [sp, #16]
   e:	9200      	str	r2, [sp, #0]
  if (fp_iszero (b) == FP_YES) {
  10:	2b00      	cmp	r3, #0
  12:	f000 8183 	beq.w	31c <fp_div+0x31c>
  if (fp_cmp_mag (a, b) == FP_LT)
  16:	f7ff fffe 	bl	0 <fp_div>
  1a:	3001      	adds	r0, #1
  1c:	d10f      	bne.n	3e <fp_div+0x3e>
    if (d != NULL) {
  1e:	9b05      	ldr	r3, [sp, #20]
  20:	b11b      	cbz	r3, 2a <fp_div+0x2a>
      fp_copy (a, d);
  22:	9802      	ldr	r0, [sp, #8]
  24:	4619      	mov	r1, r3
  26:	f7ff fffe 	bl	0 <fp_div>
    if (c != NULL) {
  2a:	9b00      	ldr	r3, [sp, #0]
  2c:	b113      	cbz	r3, 34 <fp_div+0x34>
      fp_zero (c);
  2e:	4618      	mov	r0, r3
  30:	f7ff fffe 	bl	0 <fp_div>
    return FP_OKAY;
  34:	2500      	movs	r5, #0
}
  36:	4628      	mov	r0, r5
  38:	b00d      	add	sp, #52	; 0x34
  3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  q = (fp_int*)XMALLOC(sizeof(fp_int) * 5, NULL, DYNAMIC_TYPE_BIGINT);
  3e:	f44f 7002 	mov.w	r0, #520	; 0x208
  42:	f7ff fffe 	bl	0 <malloc>
  if (q == NULL) {
  46:	4604      	mov	r4, r0
  48:	2800      	cmp	r0, #0
  4a:	f000 816a 	beq.w	322 <fp_div+0x322>
  x = &q[1]; y = &q[2]; t1 = &q[3]; t2 = &q[4];
  4e:	f500 73d0 	add.w	r3, r0, #416	; 0x1a0
  52:	f100 09d0 	add.w	r9, r0, #208	; 0xd0
  56:	f100 0768 	add.w	r7, r0, #104	; 0x68
  5a:	f500 7a9c 	add.w	sl, r0, #312	; 0x138
  5e:	930b      	str	r3, [sp, #44]	; 0x2c
    fp_zero(a);
  60:	f7ff fffe 	bl	0 <fp_div>
  q->used = a->used;
  64:	9b02      	ldr	r3, [sp, #8]
  66:	681b      	ldr	r3, [r3, #0]
  68:	6023      	str	r3, [r4, #0]
    fp_zero(a);
  6a:	4650      	mov	r0, sl
  6c:	f7ff fffe 	bl	0 <fp_div>
  70:	f504 70d0 	add.w	r0, r4, #416	; 0x1a0
  74:	f7ff fffe 	bl	0 <fp_div>
  78:	4638      	mov	r0, r7
  7a:	f7ff fffe 	bl	0 <fp_div>
  fp_copy(a, x); /* copy (src = a) to (dst = x) */
  7e:	4639      	mov	r1, r7
  80:	9802      	ldr	r0, [sp, #8]
  82:	f7ff fffe 	bl	0 <fp_div>
    fp_zero(a);
  86:	4648      	mov	r0, r9
  88:	f7ff fffe 	bl	0 <fp_div>
  fp_copy(b, y); /* copy (src = b) to (dst = y) */
  8c:	9804      	ldr	r0, [sp, #16]
  8e:	4649      	mov	r1, r9
  90:	f7ff fffe 	bl	0 <fp_div>
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
  94:	9b02      	ldr	r3, [sp, #8]
  96:	685b      	ldr	r3, [r3, #4]
  98:	9309      	str	r3, [sp, #36]	; 0x24
  9a:	9b04      	ldr	r3, [sp, #16]
  x->sign = y->sign = FP_ZPOS;
  9c:	2100      	movs	r1, #0
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
  9e:	685b      	ldr	r3, [r3, #4]
  x->sign = y->sign = FP_ZPOS;
  a0:	f8c4 10d4 	str.w	r1, [r4, #212]	; 0xd4
  a4:	66e1      	str	r1, [r4, #108]	; 0x6c
  norm = fp_count_bits(y) % DIGIT_BIT;
  a6:	4648      	mov	r0, r9
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
  a8:	930a      	str	r3, [sp, #40]	; 0x28
  norm = fp_count_bits(y) % DIGIT_BIT;
  aa:	f7ff fffe 	bl	0 <fp_div>
  ae:	1a0b      	subs	r3, r1, r0
  b0:	f003 031f 	and.w	r3, r3, #31
  b4:	f000 001f 	and.w	r0, r0, #31
  b8:	bf58      	it	pl
  ba:	4258      	negpl	r0, r3
  if (norm < (int)(DIGIT_BIT-1)) {
  bc:	281f      	cmp	r0, #31
  be:	d06d      	beq.n	19c <fp_div+0x19c>
    norm = (DIGIT_BIT-1) - norm;
  c0:	f1c0 031f 	rsb	r3, r0, #31
    ret = fp_mul_2d (x, norm, x);
  c4:	463a      	mov	r2, r7
  c6:	4619      	mov	r1, r3
  c8:	4638      	mov	r0, r7
    norm = (DIGIT_BIT-1) - norm;
  ca:	9303      	str	r3, [sp, #12]
    ret = fp_mul_2d (x, norm, x);
  cc:	f7ff fffe 	bl	0 <fp_div>
    if (ret != FP_OKAY) {
  d0:	4605      	mov	r5, r0
  d2:	b118      	cbz	r0, dc <fp_div+0xdc>
  XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
  d4:	4620      	mov	r0, r4
  d6:	f7ff fffe 	bl	0 <free>
  return FP_OKAY;
  da:	e7ac      	b.n	36 <fp_div+0x36>
    ret = fp_mul_2d (y, norm, y);
  dc:	9903      	ldr	r1, [sp, #12]
  de:	464a      	mov	r2, r9
  e0:	4648      	mov	r0, r9
  e2:	f7ff fffe 	bl	0 <fp_div>
    if (ret != FP_OKAY) {
  e6:	4605      	mov	r5, r0
  e8:	2800      	cmp	r0, #0
  ea:	d1f3      	bne.n	d4 <fp_div+0xd4>
  t = y->used - 1;
  ec:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
  n = x->used - 1;
  f0:	f8d4 8068 	ldr.w	r8, [r4, #104]	; 0x68
  t = y->used - 1;
  f4:	9301      	str	r3, [sp, #4]
  ret = fp_lshd (y, n - t); /* y = y*b**{n-t} */
  f6:	eba8 0603 	sub.w	r6, r8, r3
  fa:	4631      	mov	r1, r6
  fc:	4648      	mov	r0, r9
  fe:	f7ff fffe 	bl	0 <fp_div>
  if (ret != FP_OKAY) {
 102:	4605      	mov	r5, r0
 104:	2800      	cmp	r0, #0
 106:	d1e5      	bne.n	d4 <fp_div+0xd4>
 108:	eb04 0b86 	add.w	fp, r4, r6, lsl #2
  while (fp_cmp (x, y) != FP_LT) {
 10c:	4649      	mov	r1, r9
 10e:	4638      	mov	r0, r7
 110:	f7ff fffe 	bl	0 <fp_div>
 114:	3001      	adds	r0, #1
 116:	d143      	bne.n	1a0 <fp_div+0x1a0>
  t = y->used - 1;
 118:	9b01      	ldr	r3, [sp, #4]
  fp_rshd (y, n - t);
 11a:	4631      	mov	r1, r6
  t = y->used - 1;
 11c:	3b01      	subs	r3, #1
  fp_rshd (y, n - t);
 11e:	4648      	mov	r0, r9
  t = y->used - 1;
 120:	9307      	str	r3, [sp, #28]
  fp_rshd (y, n - t);
 122:	f7ff fffe 	bl	0 <fp_div>
  for (i = n; i >= (t + 1); i--) {
 126:	9b01      	ldr	r3, [sp, #4]
 128:	f108 0601 	add.w	r6, r8, #1
 12c:	1af6      	subs	r6, r6, r3
 12e:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  n = x->used - 1;
 132:	f108 3bff 	add.w	fp, r8, #4294967295	; 0xffffffff
 136:	eb04 0686 	add.w	r6, r4, r6, lsl #2
 13a:	eb04 0888 	add.w	r8, r4, r8, lsl #2
 13e:	9306      	str	r3, [sp, #24]
  for (i = n; i >= (t + 1); i--) {
 140:	9a07      	ldr	r2, [sp, #28]
    if (i > x->used) {
 142:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  for (i = n; i >= (t + 1); i--) {
 144:	4593      	cmp	fp, r2
 146:	dc3f      	bgt.n	1c8 <fp_div+0x1c8>
  x->sign = x->used == 0 ? FP_ZPOS : a->sign;
 148:	b10b      	cbz	r3, 14e <fp_div+0x14e>
 14a:	9b02      	ldr	r3, [sp, #8]
 14c:	685b      	ldr	r3, [r3, #4]
 14e:	66e3      	str	r3, [r4, #108]	; 0x6c
  if (c != NULL) {
 150:	9b00      	ldr	r3, [sp, #0]
 152:	2b00      	cmp	r3, #0
 154:	f040 80c6 	bne.w	2e4 <fp_div+0x2e4>
  if (d != NULL) {
 158:	9b05      	ldr	r3, [sp, #20]
 15a:	2b00      	cmp	r3, #0
 15c:	d0ba      	beq.n	d4 <fp_div+0xd4>
    fp_div_2d (x, norm, x, NULL);
 15e:	9903      	ldr	r1, [sp, #12]
 160:	2300      	movs	r3, #0
 162:	463a      	mov	r2, r7
 164:	4638      	mov	r0, r7
 166:	f7ff fffe 	bl	0 <fp_div>
    for (i = b->used; i < x->used; i++) {
 16a:	9b04      	ldr	r3, [sp, #16]
 16c:	6ea2      	ldr	r2, [r4, #104]	; 0x68
 16e:	681b      	ldr	r3, [r3, #0]
        x->dp[i] = 0;
 170:	f104 0170 	add.w	r1, r4, #112	; 0x70
 174:	2000      	movs	r0, #0
    for (i = b->used; i < x->used; i++) {
 176:	429a      	cmp	r2, r3
 178:	f300 80ca 	bgt.w	310 <fp_div+0x310>
    fp_clamp(x);
 17c:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 17e:	b13b      	cbz	r3, 190 <fp_div+0x190>
 180:	1e5a      	subs	r2, r3, #1
 182:	eb04 0383 	add.w	r3, r4, r3, lsl #2
 186:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 188:	2b00      	cmp	r3, #0
 18a:	f000 80c5 	beq.w	318 <fp_div+0x318>
 18e:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
    fp_copy (x, d);
 190:	9905      	ldr	r1, [sp, #20]
    fp_clamp(x);
 192:	66e3      	str	r3, [r4, #108]	; 0x6c
    fp_copy (x, d);
 194:	4638      	mov	r0, r7
 196:	f7ff fffe 	bl	0 <fp_div>
 19a:	e79b      	b.n	d4 <fp_div+0xd4>
    norm = 0;
 19c:	9103      	str	r1, [sp, #12]
 19e:	e7a5      	b.n	ec <fp_div+0xec>
    ++(q->dp[n - t]);
 1a0:	f8db 3008 	ldr.w	r3, [fp, #8]
 1a4:	3301      	adds	r3, #1
 1a6:	f8cb 3008 	str.w	r3, [fp, #8]
    ret = fp_sub (x, y, x);
 1aa:	463a      	mov	r2, r7
 1ac:	4649      	mov	r1, r9
 1ae:	4638      	mov	r0, r7
 1b0:	f7ff fffe 	bl	0 <fp_div>
    if (ret != FP_OKAY) {
 1b4:	4603      	mov	r3, r0
 1b6:	2800      	cmp	r0, #0
 1b8:	d0a8      	beq.n	10c <fp_div+0x10c>
        XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
 1ba:	4620      	mov	r0, r4
 1bc:	9300      	str	r3, [sp, #0]
 1be:	f7ff fffe 	bl	0 <free>
      ret = fp_add (x, t1, x);
 1c2:	9b00      	ldr	r3, [sp, #0]
 1c4:	461d      	mov	r5, r3
        return ret;
 1c6:	e736      	b.n	36 <fp_div+0x36>
    if (i > x->used) {
 1c8:	459b      	cmp	fp, r3
 1ca:	dc7d      	bgt.n	2c8 <fp_div+0x2c8>
    if (x->dp[i] == y->dp[t]) {
 1cc:	9b06      	ldr	r3, [sp, #24]
 1ce:	f8d8 106c 	ldr.w	r1, [r8, #108]	; 0x6c
 1d2:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 1d6:	9b01      	ldr	r3, [sp, #4]
 1d8:	4291      	cmp	r1, r2
 1da:	ebab 0303 	sub.w	r3, fp, r3
 1de:	9308      	str	r3, [sp, #32]
 1e0:	d178      	bne.n	2d4 <fp_div+0x2d4>
      q->dp[i - t - 1] = (fp_digit) ((((fp_word)1) << DIGIT_BIT) - 1);
 1e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 1e6:	6033      	str	r3, [r6, #0]
    q->dp[i - t - 1] = (q->dp[i - t - 1] + 1);
 1e8:	6833      	ldr	r3, [r6, #0]
 1ea:	3301      	adds	r3, #1
 1ec:	6033      	str	r3, [r6, #0]
      q->dp[i - t - 1] = (q->dp[i - t - 1] - 1);
 1ee:	6833      	ldr	r3, [r6, #0]
 1f0:	3b01      	subs	r3, #1
 1f2:	6033      	str	r3, [r6, #0]
      fp_zero (t1);
 1f4:	4650      	mov	r0, sl
 1f6:	f7ff fffe 	bl	0 <fp_div>
      t1->dp[0] = (t - 1 < 0) ? 0 : y->dp[t - 1];
 1fa:	9b07      	ldr	r3, [sp, #28]
 1fc:	2b00      	cmp	r3, #0
 1fe:	bfca      	itet	gt
 200:	9b06      	ldrgt	r3, [sp, #24]
 202:	2300      	movle	r3, #0
 204:	f8d3 30d0 	ldrgt.w	r3, [r3, #208]	; 0xd0
 208:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
      t1->dp[1] = y->dp[t];
 20c:	9b06      	ldr	r3, [sp, #24]
 20e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 212:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144
      t1->used = 2;
 216:	2302      	movs	r3, #2
 218:	f8c4 3138 	str.w	r3, [r4, #312]	; 0x138
      ret = fp_mul_d (t1, q->dp[i - t - 1], t1);
 21c:	6831      	ldr	r1, [r6, #0]
 21e:	4652      	mov	r2, sl
 220:	4650      	mov	r0, sl
 222:	f7ff fffe 	bl	0 <fp_div>
      if (ret != FP_OKAY) {
 226:	4603      	mov	r3, r0
 228:	2800      	cmp	r0, #0
 22a:	d1c6      	bne.n	1ba <fp_div+0x1ba>
      t2->dp[0] = (i - 2 < 0) ? 0 : x->dp[i - 2];
 22c:	f1bb 0f01 	cmp.w	fp, #1
 230:	bfc8      	it	gt
 232:	f8d8 3064 	ldrgt.w	r3, [r8, #100]	; 0x64
 236:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
      t2->dp[1] = (i - 1 < 0) ? 0 : x->dp[i - 1];
 23a:	f1bb 0f00 	cmp.w	fp, #0
 23e:	bfc8      	it	gt
 240:	f8d8 3068 	ldrgt.w	r3, [r8, #104]	; 0x68
    } while (fp_cmp_mag(t1, t2) == FP_GT);
 244:	990b      	ldr	r1, [sp, #44]	; 0x2c
      t2->dp[1] = (i - 1 < 0) ? 0 : x->dp[i - 1];
 246:	bfd8      	it	le
 248:	2300      	movle	r3, #0
 24a:	f8c4 31ac 	str.w	r3, [r4, #428]	; 0x1ac
      t2->dp[2] = x->dp[i];
 24e:	f8d8 306c 	ldr.w	r3, [r8, #108]	; 0x6c
 252:	f8c4 31b0 	str.w	r3, [r4, #432]	; 0x1b0
      t2->used = 3;
 256:	2303      	movs	r3, #3
 258:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    } while (fp_cmp_mag(t1, t2) == FP_GT);
 25c:	4650      	mov	r0, sl
 25e:	f7ff fffe 	bl	0 <fp_div>
 262:	2801      	cmp	r0, #1
 264:	d0c3      	beq.n	1ee <fp_div+0x1ee>
    ret = fp_mul_d (y, q->dp[i - t - 1], t1);
 266:	6831      	ldr	r1, [r6, #0]
 268:	4652      	mov	r2, sl
 26a:	4648      	mov	r0, r9
 26c:	f7ff fffe 	bl	0 <fp_div>
    if (ret != FP_OKAY) {
 270:	4603      	mov	r3, r0
 272:	2800      	cmp	r0, #0
 274:	d1a1      	bne.n	1ba <fp_div+0x1ba>
    ret = fp_lshd  (t1, i - t - 1);
 276:	9908      	ldr	r1, [sp, #32]
 278:	4650      	mov	r0, sl
 27a:	f7ff fffe 	bl	0 <fp_div>
    if (ret != FP_OKAY) {
 27e:	4603      	mov	r3, r0
 280:	2800      	cmp	r0, #0
 282:	d19a      	bne.n	1ba <fp_div+0x1ba>
    ret = fp_sub   (x, t1, x);
 284:	463a      	mov	r2, r7
 286:	4651      	mov	r1, sl
 288:	4638      	mov	r0, r7
 28a:	f7ff fffe 	bl	0 <fp_div>
    if (ret != FP_OKAY) {
 28e:	4603      	mov	r3, r0
 290:	2800      	cmp	r0, #0
 292:	d192      	bne.n	1ba <fp_div+0x1ba>
    if (x->sign == FP_NEG) {
 294:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 296:	2b01      	cmp	r3, #1
 298:	d116      	bne.n	2c8 <fp_div+0x2c8>
      fp_copy (y, t1);
 29a:	4651      	mov	r1, sl
 29c:	4648      	mov	r0, r9
 29e:	f7ff fffe 	bl	0 <fp_div>
      ret = fp_lshd (t1, i - t - 1);
 2a2:	9908      	ldr	r1, [sp, #32]
 2a4:	4650      	mov	r0, sl
 2a6:	f7ff fffe 	bl	0 <fp_div>
      if (ret != FP_OKAY) {
 2aa:	4603      	mov	r3, r0
 2ac:	2800      	cmp	r0, #0
 2ae:	d184      	bne.n	1ba <fp_div+0x1ba>
      ret = fp_add (x, t1, x);
 2b0:	463a      	mov	r2, r7
 2b2:	4651      	mov	r1, sl
 2b4:	4638      	mov	r0, r7
 2b6:	f7ff fffe 	bl	0 <fp_div>
      if (ret != FP_OKAY) {
 2ba:	4603      	mov	r3, r0
 2bc:	2800      	cmp	r0, #0
 2be:	f47f af7c 	bne.w	1ba <fp_div+0x1ba>
      q->dp[i - t - 1] = q->dp[i - t - 1] - 1;
 2c2:	6833      	ldr	r3, [r6, #0]
 2c4:	3b01      	subs	r3, #1
 2c6:	6033      	str	r3, [r6, #0]
  for (i = n; i >= (t + 1); i--) {
 2c8:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 2cc:	3e04      	subs	r6, #4
 2ce:	f1a8 0804 	sub.w	r8, r8, #4
 2d2:	e735      	b.n	140 <fp_div+0x140>
      tmp /= ((fp_word)y->dp[t]);
 2d4:	f8d8 0068 	ldr.w	r0, [r8, #104]	; 0x68
 2d8:	2300      	movs	r3, #0
 2da:	f7ff fffe 	bl	0 <__aeabi_uldivmod>
      q->dp[i - t - 1] = (fp_digit) (tmp);
 2de:	6030      	str	r0, [r6, #0]
 2e0:	e782      	b.n	1e8 <fp_div+0x1e8>
    fp_clamp (q);
 2e2:	6022      	str	r2, [r4, #0]
 2e4:	6823      	ldr	r3, [r4, #0]
 2e6:	b133      	cbz	r3, 2f6 <fp_div+0x2f6>
 2e8:	1e5a      	subs	r2, r3, #1
 2ea:	3301      	adds	r3, #1
 2ec:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
 2f0:	2b00      	cmp	r3, #0
 2f2:	d0f6      	beq.n	2e2 <fp_div+0x2e2>
 2f4:	6863      	ldr	r3, [r4, #4]
 2f6:	6063      	str	r3, [r4, #4]
    fp_copy (q, c);
 2f8:	9900      	ldr	r1, [sp, #0]
 2fa:	4620      	mov	r0, r4
 2fc:	f7ff fffe 	bl	0 <fp_div>
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
 300:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
 304:	1a9b      	subs	r3, r3, r2
    c->sign = neg;
 306:	9a00      	ldr	r2, [sp, #0]
  neg = (a->sign == b->sign) ? FP_ZPOS : FP_NEG;
 308:	bf18      	it	ne
 30a:	2301      	movne	r3, #1
    c->sign = neg;
 30c:	6053      	str	r3, [r2, #4]
 30e:	e723      	b.n	158 <fp_div+0x158>
        x->dp[i] = 0;
 310:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
    for (i = b->used; i < x->used; i++) {
 314:	3301      	adds	r3, #1
 316:	e72e      	b.n	176 <fp_div+0x176>
    fp_clamp(x);
 318:	66a2      	str	r2, [r4, #104]	; 0x68
 31a:	e72f      	b.n	17c <fp_div+0x17c>
    return FP_VAL;
 31c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 320:	e689      	b.n	36 <fp_div+0x36>
      return FP_MEM;
 322:	f06f 0501 	mvn.w	r5, #1
 326:	e686      	b.n	36 <fp_div+0x36>

Disassembly of section .text.mp_div:

00000000 <mp_div>:
  return fp_div(a, b, c, d);
   0:	f7ff bffe 	b.w	0 <mp_div>

Disassembly of section .text.fp_mod:

00000000 <fp_mod>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   4:	2068      	movs	r0, #104	; 0x68
{
   6:	460e      	mov	r6, r1
   8:	4617      	mov	r7, r2
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   a:	f7ff fffe 	bl	0 <malloc>
   if (t == NULL)
   e:	4604      	mov	r4, r0
  10:	b1f8      	cbz	r0, 52 <fp_mod+0x52>
    fp_zero(a);
  12:	f7ff fffe 	bl	0 <fp_mod>
   err = fp_div(a, b, NULL, t);
  16:	4628      	mov	r0, r5
  18:	4623      	mov	r3, r4
  1a:	2200      	movs	r2, #0
  1c:	4631      	mov	r1, r6
  1e:	f7ff fffe 	bl	0 <fp_mod>
   if (err == FP_OKAY) {
  22:	4605      	mov	r5, r0
  24:	b958      	cbnz	r0, 3e <fp_mod+0x3e>
      if (!fp_iszero(t) && (t->sign != b->sign)) {
  26:	6823      	ldr	r3, [r4, #0]
  28:	b173      	cbz	r3, 48 <fp_mod+0x48>
  2a:	6862      	ldr	r2, [r4, #4]
  2c:	6873      	ldr	r3, [r6, #4]
  2e:	429a      	cmp	r2, r3
  30:	d00a      	beq.n	48 <fp_mod+0x48>
         err = fp_add(t, b, c);
  32:	463a      	mov	r2, r7
  34:	4631      	mov	r1, r6
  36:	4620      	mov	r0, r4
  38:	f7ff fffe 	bl	0 <fp_mod>
  3c:	4605      	mov	r5, r0
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  3e:	4620      	mov	r0, r4
  40:	f7ff fffe 	bl	0 <free>
}
  44:	4628      	mov	r0, r5
  46:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
         fp_copy(t, c);
  48:	4639      	mov	r1, r7
  4a:	4620      	mov	r0, r4
  4c:	f7ff fffe 	bl	0 <fp_mod>
  50:	e7f5      	b.n	3e <fp_mod+0x3e>
       return FP_MEM;
  52:	f06f 0501 	mvn.w	r5, #1
  56:	e7f5      	b.n	44 <fp_mod+0x44>

Disassembly of section .text.fp_mulmod:

00000000 <fp_mulmod>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   6:	2068      	movs	r0, #104	; 0x68
{
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
   c:	461f      	mov	r7, r3
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   e:	f7ff fffe 	bl	0 <malloc>
  12:	4605      	mov	r5, r0
   if (t == NULL)
  14:	b1a0      	cbz	r0, 40 <fp_mulmod+0x40>
    fp_zero(a);
  16:	f7ff fffe 	bl	0 <fp_mulmod>
  err = fp_mul(a, b, t);
  1a:	4620      	mov	r0, r4
  1c:	462a      	mov	r2, r5
  1e:	4641      	mov	r1, r8
  20:	f7ff fffe 	bl	0 <fp_mulmod>
  if (err == FP_OKAY) {
  24:	4604      	mov	r4, r0
  26:	b928      	cbnz	r0, 34 <fp_mulmod+0x34>
      err = fp_mod(t, c, d);
  28:	463a      	mov	r2, r7
  2a:	4631      	mov	r1, r6
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <fp_mulmod>
  32:	4604      	mov	r4, r0
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <free>
}
  3a:	4620      	mov	r0, r4
  3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       return FP_MEM;
  40:	f06f 0401 	mvn.w	r4, #1
  44:	e7f9      	b.n	3a <fp_mulmod+0x3a>

Disassembly of section .text.mp_mulmod:

00000000 <mp_mulmod>:
   ret = fp_mulmod(a, b, c, d);
   0:	f7ff bffe 	b.w	0 <mp_mulmod>

Disassembly of section .text.fp_submod:

00000000 <fp_submod>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   6:	2068      	movs	r0, #104	; 0x68
{
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
   c:	461f      	mov	r7, r3
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   e:	f7ff fffe 	bl	0 <malloc>
  12:	4605      	mov	r5, r0
   if (t == NULL)
  14:	b1a0      	cbz	r0, 40 <fp_submod+0x40>
    fp_zero(a);
  16:	f7ff fffe 	bl	0 <fp_submod>
  err = fp_sub(a, b, t);
  1a:	4620      	mov	r0, r4
  1c:	462a      	mov	r2, r5
  1e:	4641      	mov	r1, r8
  20:	f7ff fffe 	bl	0 <fp_submod>
  if (err == FP_OKAY) {
  24:	4604      	mov	r4, r0
  26:	b928      	cbnz	r0, 34 <fp_submod+0x34>
      err = fp_mod(t, c, d);
  28:	463a      	mov	r2, r7
  2a:	4631      	mov	r1, r6
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <fp_submod>
  32:	4604      	mov	r4, r0
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <free>
}
  3a:	4620      	mov	r0, r4
  3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       return FP_MEM;
  40:	f06f 0401 	mvn.w	r4, #1
  44:	e7f9      	b.n	3a <fp_submod+0x3a>

Disassembly of section .text.mp_submod:

00000000 <mp_submod>:
  return fp_submod(a, b, c, d);
   0:	f7ff bffe 	b.w	0 <mp_submod>

Disassembly of section .text.fp_addmod:

00000000 <fp_addmod>:
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   6:	2068      	movs	r0, #104	; 0x68
{
   8:	4688      	mov	r8, r1
   a:	4616      	mov	r6, r2
   c:	461f      	mov	r7, r3
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   e:	f7ff fffe 	bl	0 <malloc>
  12:	4605      	mov	r5, r0
   if (t == NULL)
  14:	b1a0      	cbz	r0, 40 <fp_addmod+0x40>
    fp_zero(a);
  16:	f7ff fffe 	bl	0 <fp_addmod>
  err = fp_add(a, b, t);
  1a:	4620      	mov	r0, r4
  1c:	462a      	mov	r2, r5
  1e:	4641      	mov	r1, r8
  20:	f7ff fffe 	bl	0 <fp_addmod>
  if (err == FP_OKAY) {
  24:	4604      	mov	r4, r0
  26:	b928      	cbnz	r0, 34 <fp_addmod+0x34>
      err = fp_mod(t, c, d);
  28:	463a      	mov	r2, r7
  2a:	4631      	mov	r1, r6
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <fp_addmod>
  32:	4604      	mov	r4, r0
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  34:	4628      	mov	r0, r5
  36:	f7ff fffe 	bl	0 <free>
}
  3a:	4620      	mov	r0, r4
  3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       return FP_MEM;
  40:	f06f 0401 	mvn.w	r4, #1
  44:	e7f9      	b.n	3a <fp_addmod+0x3a>

Disassembly of section .text.mp_addmod:

00000000 <mp_addmod>:
  return fp_addmod(a, b, c, d);
   0:	f7ff bffe 	b.w	0 <mp_addmod>

Disassembly of section .text.mp_mod:

00000000 <mp_mod>:
  return fp_mod (a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_mod>

Disassembly of section .text.fp_invmod:

00000000 <fp_invmod>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
   4:	684b      	ldr	r3, [r1, #4]
{
   6:	b085      	sub	sp, #20
  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
   8:	2b01      	cmp	r3, #1
{
   a:	4683      	mov	fp, r0
   c:	460c      	mov	r4, r1
   e:	9203      	str	r2, [sp, #12]
  if (b->sign == FP_NEG || fp_iszero(b) == FP_YES) {
  10:	d057      	beq.n	c2 <fp_invmod+0xc2>
  12:	680b      	ldr	r3, [r1, #0]
  14:	2b00      	cmp	r3, #0
  16:	d054      	beq.n	c2 <fp_invmod+0xc2>
  if (fp_iszero(a) == FP_YES) {
  18:	6802      	ldr	r2, [r0, #0]
  1a:	2a00      	cmp	r2, #0
  1c:	d051      	beq.n	c2 <fp_invmod+0xc2>
  if (fp_iseven(b) == FP_YES) {
  1e:	2b00      	cmp	r3, #0
  20:	f340 814b 	ble.w	2ba <fp_invmod+0x2ba>
  24:	688b      	ldr	r3, [r1, #8]
  26:	07dd      	lsls	r5, r3, #31
  28:	f100 8147 	bmi.w	2ba <fp_invmod+0x2ba>
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 8, NULL, DYNAMIC_TYPE_BIGINT);
  2c:	f44f 7050 	mov.w	r0, #832	; 0x340
  30:	f7ff fffe 	bl	0 <malloc>
  if (x == NULL) {
  34:	4606      	mov	r6, r0
  36:	b928      	cbnz	r0, 44 <fp_invmod+0x44>
      return FP_MEM;
  38:	f06f 0b01 	mvn.w	fp, #1
}
  3c:	4658      	mov	r0, fp
  3e:	b005      	add	sp, #20
  40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  y = &x[1]; u = &x[2]; v = &x[3]; A = &x[4]; B = &x[5]; C = &x[6]; D = &x[7];
  44:	f100 0368 	add.w	r3, r0, #104	; 0x68
  48:	9302      	str	r3, [sp, #8]
  4a:	f100 03d0 	add.w	r3, r0, #208	; 0xd0
  4e:	9301      	str	r3, [sp, #4]
  50:	f500 799c 	add.w	r9, r0, #312	; 0x138
  54:	f500 77d0 	add.w	r7, r0, #416	; 0x1a0
  58:	f500 7a02 	add.w	sl, r0, #520	; 0x208
  5c:	f500 751c 	add.w	r5, r0, #624	; 0x270
  60:	f500 7836 	add.w	r8, r0, #728	; 0x2d8
    fp_zero(a);
  64:	f7ff fffe 	bl	0 <fp_invmod>
  68:	f106 0068 	add.w	r0, r6, #104	; 0x68
  6c:	f7ff fffe 	bl	0 <fp_invmod>
  70:	f106 00d0 	add.w	r0, r6, #208	; 0xd0
  74:	f7ff fffe 	bl	0 <fp_invmod>
  78:	4648      	mov	r0, r9
  7a:	f7ff fffe 	bl	0 <fp_invmod>
  7e:	4638      	mov	r0, r7
  80:	f7ff fffe 	bl	0 <fp_invmod>
  84:	4650      	mov	r0, sl
  86:	f7ff fffe 	bl	0 <fp_invmod>
  8a:	4628      	mov	r0, r5
  8c:	f7ff fffe 	bl	0 <fp_invmod>
  90:	4640      	mov	r0, r8
  92:	f7ff fffe 	bl	0 <fp_invmod>
  if ((err = fp_mod(a, b, x)) != FP_OKAY) {
  96:	4658      	mov	r0, fp
  98:	4632      	mov	r2, r6
  9a:	4621      	mov	r1, r4
  9c:	f7ff fffe 	bl	0 <fp_invmod>
  a0:	4683      	mov	fp, r0
  a2:	b118      	cbz	r0, ac <fp_invmod+0xac>
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
  a4:	4630      	mov	r0, r6
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
  a6:	f7ff fffe 	bl	0 <free>
  return FP_OKAY;
  aa:	e7c7      	b.n	3c <fp_invmod+0x3c>
  fp_copy(b, y);
  ac:	f106 0168 	add.w	r1, r6, #104	; 0x68
  b0:	4620      	mov	r0, r4
  b2:	f7ff fffe 	bl	0 <fp_invmod>
  if (fp_iszero(x) == FP_YES) {
  b6:	6832      	ldr	r2, [r6, #0]
  b8:	2a00      	cmp	r2, #0
  ba:	d105      	bne.n	c8 <fp_invmod+0xc8>
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
  bc:	4630      	mov	r0, r6
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
  be:	f7ff fffe 	bl	0 <free>
    return FP_VAL;
  c2:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
  c6:	e7b9      	b.n	3c <fp_invmod+0x3c>
  if (fp_iseven(x) == FP_YES && fp_iseven(y) == FP_YES) {
  c8:	dd08      	ble.n	dc <fp_invmod+0xdc>
  ca:	68b2      	ldr	r2, [r6, #8]
  cc:	07d0      	lsls	r0, r2, #31
  ce:	d405      	bmi.n	dc <fp_invmod+0xdc>
  d0:	6eb2      	ldr	r2, [r6, #104]	; 0x68
  d2:	2a00      	cmp	r2, #0
  d4:	dd02      	ble.n	dc <fp_invmod+0xdc>
  d6:	6f32      	ldr	r2, [r6, #112]	; 0x70
  d8:	07d1      	lsls	r1, r2, #31
  da:	d5ef      	bpl.n	bc <fp_invmod+0xbc>
  fp_copy (x, u);
  dc:	f106 01d0 	add.w	r1, r6, #208	; 0xd0
  e0:	4630      	mov	r0, r6
  e2:	f7ff fffe 	bl	0 <fp_invmod>
  fp_copy (y, v);
  e6:	4649      	mov	r1, r9
  e8:	f106 0068 	add.w	r0, r6, #104	; 0x68
   a->dp[0] = b;
  ec:	f04f 0b01 	mov.w	fp, #1
  fp_copy (y, v);
  f0:	f7ff fffe 	bl	0 <fp_invmod>
   fp_zero(a);
  f4:	4638      	mov	r0, r7
  f6:	f7ff fffe 	bl	0 <fp_invmod>
   a->dp[0] = b;
  fa:	f8c6 b1a8 	str.w	fp, [r6, #424]	; 0x1a8
   a->used  = a->dp[0] ? 1 : 0;
  fe:	f8c6 b1a0 	str.w	fp, [r6, #416]	; 0x1a0
   fp_zero(a);
 102:	4640      	mov	r0, r8
 104:	f7ff fffe 	bl	0 <fp_invmod>
   a->dp[0] = b;
 108:	f8c6 b2e0 	str.w	fp, [r6, #736]	; 0x2e0
   a->used  = a->dp[0] ? 1 : 0;
 10c:	f8c6 b2d8 	str.w	fp, [r6, #728]	; 0x2d8
  while (fp_iseven (u) == FP_YES) {
 110:	f8d6 20d0 	ldr.w	r2, [r6, #208]	; 0xd0
 114:	2a00      	cmp	r2, #0
 116:	dd5d      	ble.n	1d4 <fp_invmod+0x1d4>
 118:	f8d6 20d8 	ldr.w	r2, [r6, #216]	; 0xd8
 11c:	07d0      	lsls	r0, r2, #31
 11e:	d459      	bmi.n	1d4 <fp_invmod+0x1d4>
    fp_div_2 (u, u);
 120:	9901      	ldr	r1, [sp, #4]
 122:	4608      	mov	r0, r1
 124:	f7ff fffe 	bl	0 <fp_invmod>
    if (fp_isodd (A) == FP_YES || fp_isodd (B) == FP_YES) {
 128:	f8d6 21a0 	ldr.w	r2, [r6, #416]	; 0x1a0
 12c:	2a00      	cmp	r2, #0
 12e:	dd03      	ble.n	138 <fp_invmod+0x138>
 130:	f8d6 21a8 	ldr.w	r2, [r6, #424]	; 0x1a8
 134:	07d2      	lsls	r2, r2, #31
 136:	d407      	bmi.n	148 <fp_invmod+0x148>
 138:	f8d6 2208 	ldr.w	r2, [r6, #520]	; 0x208
 13c:	2a00      	cmp	r2, #0
 13e:	dd13      	ble.n	168 <fp_invmod+0x168>
 140:	f8d6 2210 	ldr.w	r2, [r6, #528]	; 0x210
 144:	07d3      	lsls	r3, r2, #31
 146:	d50f      	bpl.n	168 <fp_invmod+0x168>
      err = fp_add (A, y, A);
 148:	9902      	ldr	r1, [sp, #8]
 14a:	463a      	mov	r2, r7
 14c:	4638      	mov	r0, r7
 14e:	f7ff fffe 	bl	0 <fp_invmod>
      if (err != FP_OKAY) {
 152:	4683      	mov	fp, r0
 154:	2800      	cmp	r0, #0
 156:	d1a5      	bne.n	a4 <fp_invmod+0xa4>
      err = fp_sub (B, x, B);
 158:	4652      	mov	r2, sl
 15a:	4631      	mov	r1, r6
 15c:	4650      	mov	r0, sl
 15e:	f7ff fffe 	bl	0 <fp_invmod>
      if (err != FP_OKAY) {
 162:	4683      	mov	fp, r0
 164:	2800      	cmp	r0, #0
 166:	d19d      	bne.n	a4 <fp_invmod+0xa4>
    fp_div_2 (A, A);
 168:	4639      	mov	r1, r7
 16a:	4638      	mov	r0, r7
 16c:	f7ff fffe 	bl	0 <fp_invmod>
    fp_div_2 (B, B);
 170:	4651      	mov	r1, sl
 172:	4650      	mov	r0, sl
 174:	f7ff fffe 	bl	0 <fp_invmod>
 178:	e7ca      	b.n	110 <fp_invmod+0x110>
    fp_div_2 (v, v);
 17a:	4648      	mov	r0, r9
 17c:	f7ff fffe 	bl	0 <fp_invmod>
    if (fp_isodd (C) == FP_YES || fp_isodd (D) == FP_YES) {
 180:	f8d6 2270 	ldr.w	r2, [r6, #624]	; 0x270
 184:	2a00      	cmp	r2, #0
 186:	dd03      	ble.n	190 <fp_invmod+0x190>
 188:	f8d6 2278 	ldr.w	r2, [r6, #632]	; 0x278
 18c:	07d1      	lsls	r1, r2, #31
 18e:	d407      	bmi.n	1a0 <fp_invmod+0x1a0>
 190:	f8d6 22d8 	ldr.w	r2, [r6, #728]	; 0x2d8
 194:	2a00      	cmp	r2, #0
 196:	dd15      	ble.n	1c4 <fp_invmod+0x1c4>
 198:	f8d6 22e0 	ldr.w	r2, [r6, #736]	; 0x2e0
 19c:	07d2      	lsls	r2, r2, #31
 19e:	d511      	bpl.n	1c4 <fp_invmod+0x1c4>
      err = fp_add (C, y, C);
 1a0:	9902      	ldr	r1, [sp, #8]
 1a2:	462a      	mov	r2, r5
 1a4:	4628      	mov	r0, r5
 1a6:	f7ff fffe 	bl	0 <fp_invmod>
      if (err != FP_OKAY) {
 1aa:	4683      	mov	fp, r0
 1ac:	2800      	cmp	r0, #0
 1ae:	f47f af79 	bne.w	a4 <fp_invmod+0xa4>
      err = fp_sub (D, x, D);
 1b2:	4642      	mov	r2, r8
 1b4:	4631      	mov	r1, r6
 1b6:	4640      	mov	r0, r8
 1b8:	f7ff fffe 	bl	0 <fp_invmod>
      if (err != FP_OKAY) {
 1bc:	4683      	mov	fp, r0
 1be:	2800      	cmp	r0, #0
 1c0:	f47f af70 	bne.w	a4 <fp_invmod+0xa4>
    fp_div_2 (C, C);
 1c4:	4629      	mov	r1, r5
 1c6:	4628      	mov	r0, r5
 1c8:	f7ff fffe 	bl	0 <fp_invmod>
    fp_div_2 (D, D);
 1cc:	4641      	mov	r1, r8
 1ce:	4640      	mov	r0, r8
 1d0:	f7ff fffe 	bl	0 <fp_invmod>
  while (fp_iseven (v) == FP_YES) {
 1d4:	f8d6 2138 	ldr.w	r2, [r6, #312]	; 0x138
 1d8:	2a00      	cmp	r2, #0
    fp_div_2 (v, v);
 1da:	4649      	mov	r1, r9
  while (fp_iseven (v) == FP_YES) {
 1dc:	dd03      	ble.n	1e6 <fp_invmod+0x1e6>
 1de:	f8d6 2140 	ldr.w	r2, [r6, #320]	; 0x140
 1e2:	07d3      	lsls	r3, r2, #31
 1e4:	d5c9      	bpl.n	17a <fp_invmod+0x17a>
  if (fp_cmp (u, v) != FP_LT) {
 1e6:	9801      	ldr	r0, [sp, #4]
 1e8:	f7ff fffe 	bl	0 <fp_invmod>
 1ec:	3001      	adds	r0, #1
 1ee:	d115      	bne.n	21c <fp_invmod+0x21c>
    err = fp_sub (v, u, v);
 1f0:	9901      	ldr	r1, [sp, #4]
 1f2:	464a      	mov	r2, r9
 1f4:	4648      	mov	r0, r9
 1f6:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 1fa:	4683      	mov	fp, r0
 1fc:	2800      	cmp	r0, #0
 1fe:	f47f af51 	bne.w	a4 <fp_invmod+0xa4>
    err = fp_sub (C, A, C);
 202:	462a      	mov	r2, r5
 204:	4639      	mov	r1, r7
 206:	4628      	mov	r0, r5
 208:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 20c:	4683      	mov	fp, r0
 20e:	2800      	cmp	r0, #0
 210:	f47f af48 	bne.w	a4 <fp_invmod+0xa4>
    err = fp_sub (D, B, D);
 214:	4642      	mov	r2, r8
 216:	4651      	mov	r1, sl
 218:	4640      	mov	r0, r8
 21a:	e014      	b.n	246 <fp_invmod+0x246>
    err = fp_sub (u, v, u);
 21c:	9a01      	ldr	r2, [sp, #4]
 21e:	4649      	mov	r1, r9
 220:	4610      	mov	r0, r2
 222:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 226:	4683      	mov	fp, r0
 228:	2800      	cmp	r0, #0
 22a:	f47f af3b 	bne.w	a4 <fp_invmod+0xa4>
    err = fp_sub (A, C, A);
 22e:	463a      	mov	r2, r7
 230:	4629      	mov	r1, r5
 232:	4638      	mov	r0, r7
 234:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 238:	4683      	mov	fp, r0
 23a:	2800      	cmp	r0, #0
 23c:	f47f af32 	bne.w	a4 <fp_invmod+0xa4>
    err = fp_sub (B, D, B);
 240:	4652      	mov	r2, sl
 242:	4641      	mov	r1, r8
 244:	4650      	mov	r0, sl
    err = fp_sub (D, B, D);
 246:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 24a:	4683      	mov	fp, r0
 24c:	2800      	cmp	r0, #0
 24e:	f47f af29 	bne.w	a4 <fp_invmod+0xa4>
  if (fp_iszero (u) == FP_NO)
 252:	f8d6 20d0 	ldr.w	r2, [r6, #208]	; 0xd0
 256:	2a00      	cmp	r2, #0
 258:	f47f af5a 	bne.w	110 <fp_invmod+0x110>
  if (fp_cmp_d (v, 1) != FP_EQ) {
 25c:	2101      	movs	r1, #1
 25e:	4648      	mov	r0, r9
 260:	f7ff fffe 	bl	0 <fp_invmod>
 264:	2800      	cmp	r0, #0
 266:	f47f af29 	bne.w	bc <fp_invmod+0xbc>
  while (fp_cmp_d(C, 0) == FP_LT) {
 26a:	2100      	movs	r1, #0
 26c:	4628      	mov	r0, r5
 26e:	f7ff fffe 	bl	0 <fp_invmod>
 272:	3001      	adds	r0, #1
 274:	d00f      	beq.n	296 <fp_invmod+0x296>
  while (fp_cmp_mag(C, b) != FP_LT) {
 276:	4621      	mov	r1, r4
 278:	4628      	mov	r0, r5
 27a:	f7ff fffe 	bl	0 <fp_invmod>
 27e:	3001      	adds	r0, #1
 280:	d112      	bne.n	2a8 <fp_invmod+0x2a8>
  fp_copy(C, c);
 282:	9903      	ldr	r1, [sp, #12]
 284:	4628      	mov	r0, r5
 286:	f7ff fffe 	bl	0 <fp_invmod>
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 28a:	4630      	mov	r0, r6
 28c:	f7ff fffe 	bl	0 <free>
  return FP_OKAY;
 290:	f04f 0b00 	mov.w	fp, #0
 294:	e6d2      	b.n	3c <fp_invmod+0x3c>
    err = fp_add(C, b, C);
 296:	462a      	mov	r2, r5
 298:	4621      	mov	r1, r4
 29a:	4628      	mov	r0, r5
 29c:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 2a0:	4683      	mov	fp, r0
 2a2:	2800      	cmp	r0, #0
 2a4:	d0e1      	beq.n	26a <fp_invmod+0x26a>
 2a6:	e6fd      	b.n	a4 <fp_invmod+0xa4>
    err = fp_sub(C, b, C);
 2a8:	462a      	mov	r2, r5
 2aa:	4621      	mov	r1, r4
 2ac:	4628      	mov	r0, r5
 2ae:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 2b2:	4683      	mov	fp, r0
 2b4:	2800      	cmp	r0, #0
 2b6:	d0de      	beq.n	276 <fp_invmod+0x276>
 2b8:	e6f4      	b.n	a4 <fp_invmod+0xa4>
  x = (fp_int*)XMALLOC(sizeof(fp_int) * 6, NULL, DYNAMIC_TYPE_BIGINT);
 2ba:	f44f 701c 	mov.w	r0, #624	; 0x270
 2be:	f7ff fffe 	bl	0 <malloc>
  if (x == NULL) {
 2c2:	4682      	mov	sl, r0
 2c4:	2800      	cmp	r0, #0
 2c6:	f43f aeb7 	beq.w	38 <fp_invmod+0x38>
  y = &x[1]; u = &x[2]; v = &x[3]; B = &x[4]; D = &x[5];
 2ca:	f100 0968 	add.w	r9, r0, #104	; 0x68
 2ce:	f100 07d0 	add.w	r7, r0, #208	; 0xd0
 2d2:	f500 769c 	add.w	r6, r0, #312	; 0x138
 2d6:	f500 78d0 	add.w	r8, r0, #416	; 0x1a0
 2da:	f500 7502 	add.w	r5, r0, #520	; 0x208
    fp_zero(a);
 2de:	f7ff fffe 	bl	0 <fp_invmod>
 2e2:	4648      	mov	r0, r9
 2e4:	f7ff fffe 	bl	0 <fp_invmod>
 2e8:	4638      	mov	r0, r7
 2ea:	f7ff fffe 	bl	0 <fp_invmod>
 2ee:	4630      	mov	r0, r6
 2f0:	f7ff fffe 	bl	0 <fp_invmod>
 2f4:	4640      	mov	r0, r8
 2f6:	f7ff fffe 	bl	0 <fp_invmod>
 2fa:	4628      	mov	r0, r5
 2fc:	f7ff fffe 	bl	0 <fp_invmod>
  if (fp_iszero(a) == FP_YES) {
 300:	f8db 3000 	ldr.w	r3, [fp]
 304:	b90b      	cbnz	r3, 30a <fp_invmod+0x30a>
    XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 306:	4650      	mov	r0, sl
 308:	e6d9      	b.n	be <fp_invmod+0xbe>
  fp_copy(b, x);
 30a:	4651      	mov	r1, sl
 30c:	4620      	mov	r0, r4
 30e:	f7ff fffe 	bl	0 <fp_invmod>
  return fp_mod (a, b, c);
 312:	4658      	mov	r0, fp
 314:	464a      	mov	r2, r9
 316:	4621      	mov	r1, r4
 318:	f7ff fffe 	bl	0 <fp_invmod>
  if ((err = mp_mod(a, b, y)) != FP_OKAY) {
 31c:	4683      	mov	fp, r0
 31e:	b108      	cbz	r0, 324 <fp_invmod+0x324>
  XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 320:	4650      	mov	r0, sl
 322:	e6c0      	b.n	a6 <fp_invmod+0xa6>
  if (fp_iszero(y) == FP_YES) {
 324:	f8da 3068 	ldr.w	r3, [sl, #104]	; 0x68
 328:	2b00      	cmp	r3, #0
 32a:	d0ec      	beq.n	306 <fp_invmod+0x306>
  fp_copy(x, u);
 32c:	4639      	mov	r1, r7
 32e:	4650      	mov	r0, sl
 330:	f7ff fffe 	bl	0 <fp_invmod>
  fp_copy(y, v);
 334:	4631      	mov	r1, r6
 336:	4648      	mov	r0, r9
 338:	f7ff fffe 	bl	0 <fp_invmod>
   fp_zero(a);
 33c:	4628      	mov	r0, r5
 33e:	f7ff fffe 	bl	0 <fp_invmod>
   a->dp[0] = b;
 342:	2301      	movs	r3, #1
 344:	f8ca 3210 	str.w	r3, [sl, #528]	; 0x210
   a->used  = a->dp[0] ? 1 : 0;
 348:	f8ca 3208 	str.w	r3, [sl, #520]	; 0x208
  while (fp_iseven (u) == FP_YES) {
 34c:	f8da 30d0 	ldr.w	r3, [sl, #208]	; 0xd0
 350:	2b00      	cmp	r3, #0
 352:	dd33      	ble.n	3bc <fp_invmod+0x3bc>
 354:	f8da 30d8 	ldr.w	r3, [sl, #216]	; 0xd8
 358:	07d9      	lsls	r1, r3, #31
 35a:	d42f      	bmi.n	3bc <fp_invmod+0x3bc>
    fp_div_2 (u, u);
 35c:	4639      	mov	r1, r7
 35e:	4638      	mov	r0, r7
 360:	f7ff fffe 	bl	0 <fp_invmod>
    if (fp_isodd (B) == FP_YES) {
 364:	f8da 31a0 	ldr.w	r3, [sl, #416]	; 0x1a0
 368:	2b00      	cmp	r3, #0
 36a:	dd0b      	ble.n	384 <fp_invmod+0x384>
 36c:	f8da 31a8 	ldr.w	r3, [sl, #424]	; 0x1a8
 370:	07d8      	lsls	r0, r3, #31
 372:	d507      	bpl.n	384 <fp_invmod+0x384>
      err = fp_sub (B, x, B);
 374:	4642      	mov	r2, r8
 376:	4651      	mov	r1, sl
 378:	4640      	mov	r0, r8
 37a:	f7ff fffe 	bl	0 <fp_invmod>
      if (err != FP_OKAY) {
 37e:	4683      	mov	fp, r0
 380:	2800      	cmp	r0, #0
 382:	d1cd      	bne.n	320 <fp_invmod+0x320>
    fp_div_2 (B, B);
 384:	4641      	mov	r1, r8
 386:	4640      	mov	r0, r8
 388:	f7ff fffe 	bl	0 <fp_invmod>
 38c:	e7de      	b.n	34c <fp_invmod+0x34c>
    fp_div_2 (v, v);
 38e:	4630      	mov	r0, r6
 390:	f7ff fffe 	bl	0 <fp_invmod>
    if (fp_isodd (D) == FP_YES) {
 394:	f8da 3208 	ldr.w	r3, [sl, #520]	; 0x208
 398:	2b00      	cmp	r3, #0
 39a:	dd0b      	ble.n	3b4 <fp_invmod+0x3b4>
 39c:	f8da 3210 	ldr.w	r3, [sl, #528]	; 0x210
 3a0:	07da      	lsls	r2, r3, #31
 3a2:	d507      	bpl.n	3b4 <fp_invmod+0x3b4>
      err = fp_sub (D, x, D);
 3a4:	462a      	mov	r2, r5
 3a6:	4651      	mov	r1, sl
 3a8:	4628      	mov	r0, r5
 3aa:	f7ff fffe 	bl	0 <fp_invmod>
      if (err != FP_OKAY) {
 3ae:	4683      	mov	fp, r0
 3b0:	2800      	cmp	r0, #0
 3b2:	d1b5      	bne.n	320 <fp_invmod+0x320>
    fp_div_2 (D, D);
 3b4:	4629      	mov	r1, r5
 3b6:	4628      	mov	r0, r5
 3b8:	f7ff fffe 	bl	0 <fp_invmod>
  while (fp_iseven (v) == FP_YES) {
 3bc:	f8da 3138 	ldr.w	r3, [sl, #312]	; 0x138
 3c0:	2b00      	cmp	r3, #0
    fp_div_2 (v, v);
 3c2:	4631      	mov	r1, r6
  while (fp_iseven (v) == FP_YES) {
 3c4:	dd03      	ble.n	3ce <fp_invmod+0x3ce>
 3c6:	f8da 3140 	ldr.w	r3, [sl, #320]	; 0x140
 3ca:	07db      	lsls	r3, r3, #31
 3cc:	d5df      	bpl.n	38e <fp_invmod+0x38e>
  if (fp_cmp (u, v) != FP_LT) {
 3ce:	4638      	mov	r0, r7
 3d0:	f7ff fffe 	bl	0 <fp_invmod>
 3d4:	3001      	adds	r0, #1
 3d6:	d10b      	bne.n	3f0 <fp_invmod+0x3f0>
    err = fp_sub (v, u, v);
 3d8:	4632      	mov	r2, r6
 3da:	4639      	mov	r1, r7
 3dc:	4630      	mov	r0, r6
 3de:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 3e2:	4683      	mov	fp, r0
 3e4:	2800      	cmp	r0, #0
 3e6:	d19b      	bne.n	320 <fp_invmod+0x320>
    err = fp_sub (D, B, D);
 3e8:	462a      	mov	r2, r5
 3ea:	4641      	mov	r1, r8
 3ec:	4628      	mov	r0, r5
 3ee:	e00a      	b.n	406 <fp_invmod+0x406>
    err = fp_sub (u, v, u);
 3f0:	463a      	mov	r2, r7
 3f2:	4631      	mov	r1, r6
 3f4:	4638      	mov	r0, r7
 3f6:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 3fa:	4683      	mov	fp, r0
 3fc:	2800      	cmp	r0, #0
 3fe:	d18f      	bne.n	320 <fp_invmod+0x320>
    err = fp_sub (B, D, B);
 400:	4642      	mov	r2, r8
 402:	4629      	mov	r1, r5
 404:	4640      	mov	r0, r8
    err = fp_sub (D, B, D);
 406:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 40a:	4683      	mov	fp, r0
 40c:	2800      	cmp	r0, #0
 40e:	d187      	bne.n	320 <fp_invmod+0x320>
  if (fp_iszero (u) == FP_NO) {
 410:	f8da 30d0 	ldr.w	r3, [sl, #208]	; 0xd0
 414:	2b00      	cmp	r3, #0
 416:	d199      	bne.n	34c <fp_invmod+0x34c>
  if (fp_cmp_d (v, 1) != FP_EQ) {
 418:	2101      	movs	r1, #1
 41a:	4630      	mov	r0, r6
 41c:	f7ff fffe 	bl	0 <fp_invmod>
 420:	4683      	mov	fp, r0
 422:	2800      	cmp	r0, #0
 424:	f47f af6f 	bne.w	306 <fp_invmod+0x306>
  while (D->sign == FP_NEG) {
 428:	f8da 320c 	ldr.w	r3, [sl, #524]	; 0x20c
 42c:	2b01      	cmp	r3, #1
 42e:	d00a      	beq.n	446 <fp_invmod+0x446>
  while (fp_cmp_mag(D, b) != FP_LT) {
 430:	4621      	mov	r1, r4
 432:	4628      	mov	r0, r5
 434:	f7ff fffe 	bl	0 <fp_invmod>
 438:	3001      	adds	r0, #1
 43a:	d10c      	bne.n	456 <fp_invmod+0x456>
  fp_copy (D, c);
 43c:	9903      	ldr	r1, [sp, #12]
 43e:	4628      	mov	r0, r5
 440:	f7ff fffe 	bl	0 <fp_invmod>
 444:	e76c      	b.n	320 <fp_invmod+0x320>
    err = fp_add (D, b, D);
 446:	462a      	mov	r2, r5
 448:	4621      	mov	r1, r4
 44a:	4628      	mov	r0, r5
 44c:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 450:	2800      	cmp	r0, #0
 452:	d0e9      	beq.n	428 <fp_invmod+0x428>
 454:	e764      	b.n	320 <fp_invmod+0x320>
    err = fp_sub(D, b, D);
 456:	462a      	mov	r2, r5
 458:	4621      	mov	r1, r4
 45a:	4628      	mov	r0, r5
 45c:	f7ff fffe 	bl	0 <fp_invmod>
    if (err != FP_OKAY) {
 460:	4606      	mov	r6, r0
 462:	2800      	cmp	r0, #0
 464:	d0e4      	beq.n	430 <fp_invmod+0x430>
      XFREE(x, NULL, DYNAMIC_TYPE_BIGINT);
 466:	4650      	mov	r0, sl
 468:	f7ff fffe 	bl	0 <free>
    err = fp_sub(D, b, D);
 46c:	46b3      	mov	fp, r6
      return err;
 46e:	e5e5      	b.n	3c <fp_invmod+0x3c>

Disassembly of section .text.mp_invmod:

00000000 <mp_invmod>:
  return fp_invmod(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_invmod>

Disassembly of section .text.fp_sqr_comba:

00000000 <fp_sqr_comba>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4681      	mov	r9, r0
   6:	b087      	sub	sp, #28
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   8:	2068      	movs	r0, #104	; 0x68
{
   a:	460f      	mov	r7, r1
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   c:	f7ff fffe 	bl	0 <malloc>
   if (tmp == NULL)
  10:	4680      	mov	r8, r0
  12:	2800      	cmp	r0, #0
  14:	f000 8087 	beq.w	126 <fp_sqr_comba+0x126>
  pa = A->used + A->used;
  18:	f8d9 3000 	ldr.w	r3, [r9]
  1c:	005b      	lsls	r3, r3, #1
  if (pa >= FP_SIZE) {
  1e:	2b17      	cmp	r3, #23
  20:	bfa8      	it	ge
  22:	2317      	movge	r3, #23
  if (A == B) {
  24:	45b9      	cmp	r9, r7
  26:	9302      	str	r3, [sp, #8]
  28:	d126      	bne.n	78 <fp_sqr_comba+0x78>
    fp_zero(a);
  2a:	f7ff fffe 	bl	0 <fp_sqr_comba>
     dst = tmp;
  2e:	4640      	mov	r0, r8
  for (ix = 0; ix < pa; ix++) {
  30:	f100 0308 	add.w	r3, r0, #8
  COMBA_CLEAR;
  34:	2500      	movs	r5, #0
  36:	9303      	str	r3, [sp, #12]
      tmpx = A->dp + tx;
  38:	f109 0308 	add.w	r3, r9, #8
  COMBA_CLEAR;
  3c:	462c      	mov	r4, r5
  for (ix = 0; ix < pa; ix++) {
  3e:	462e      	mov	r6, r5
      tmpx = A->dp + tx;
  40:	9304      	str	r3, [sp, #16]
          SQRADD2(*tmpx++, *tmpy--);
  42:	46ab      	mov	fp, r5
  for (ix = 0; ix < pa; ix++) {
  44:	9b02      	ldr	r3, [sp, #8]
  46:	429e      	cmp	r6, r3
  48:	db1b      	blt.n	82 <fp_sqr_comba+0x82>
  dst->used = pa;
  4a:	6003      	str	r3, [r0, #0]
  fp_clamp (dst);
  4c:	6803      	ldr	r3, [r0, #0]
  4e:	b133      	cbz	r3, 5e <fp_sqr_comba+0x5e>
  50:	1e5a      	subs	r2, r3, #1
  52:	3301      	adds	r3, #1
  54:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
  58:	2b00      	cmp	r3, #0
  5a:	d062      	beq.n	122 <fp_sqr_comba+0x122>
  5c:	6843      	ldr	r3, [r0, #4]
  5e:	6043      	str	r3, [r0, #4]
  if (dst != B) {
  60:	42b8      	cmp	r0, r7
  62:	d002      	beq.n	6a <fp_sqr_comba+0x6a>
     fp_copy(dst, B);
  64:	4639      	mov	r1, r7
  66:	f7ff fffe 	bl	0 <fp_sqr_comba>
  XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
  6a:	4640      	mov	r0, r8
  6c:	f7ff fffe 	bl	0 <free>
  return FP_OKAY;
  70:	2000      	movs	r0, #0
}
  72:	b007      	add	sp, #28
  74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     fp_zero(B);
  78:	4638      	mov	r0, r7
  7a:	f7ff fffe 	bl	0 <fp_sqr_comba>
  7e:	4638      	mov	r0, r7
  80:	e7d6      	b.n	30 <fp_sqr_comba+0x30>
      ty = MIN(A->used-1, ix);
  82:	f8d9 2000 	ldr.w	r2, [r9]
      tmpx = A->dp + tx;
  86:	f8dd c010 	ldr.w	ip, [sp, #16]
      ty = MIN(A->used-1, ix);
  8a:	42b2      	cmp	r2, r6
  8c:	bfd4      	ite	le
  8e:	f102 33ff 	addle.w	r3, r2, #4294967295	; 0xffffffff
  92:	4633      	movgt	r3, r6
      tx = ix - ty;
  94:	1af1      	subs	r1, r6, r3
      iy = MIN(A->used-tx, ty+1);
  96:	1a52      	subs	r2, r2, r1
  98:	429a      	cmp	r2, r3
  9a:	bfc8      	it	gt
  9c:	1c5a      	addgt	r2, r3, #1
      tmpx = A->dp + tx;
  9e:	eb0c 0e81 	add.w	lr, ip, r1, lsl #2
      tmpy = A->dp + ty;
  a2:	eb0c 0c83 	add.w	ip, ip, r3, lsl #2
      iy = MIN(iy, (ty-tx+1)>>1);
  a6:	1a5b      	subs	r3, r3, r1
  a8:	3301      	adds	r3, #1
  aa:	105b      	asrs	r3, r3, #1
  ac:	4293      	cmp	r3, r2
  ae:	bfa8      	it	ge
  b0:	4613      	movge	r3, r2
  b2:	9305      	str	r3, [sp, #20]
      COMBA_FORWARD;
  b4:	4623      	mov	r3, r4
  b6:	462c      	mov	r4, r5
  b8:	2500      	movs	r5, #0
      tmpy = A->dp + ty;
  ba:	f8cd c004 	str.w	ip, [sp, #4]
      for (iz = 0; iz < iy; iz++) {
  be:	4629      	mov	r1, r5
  c0:	9a05      	ldr	r2, [sp, #20]
  c2:	4291      	cmp	r1, r2
  c4:	db12      	blt.n	ec <fp_sqr_comba+0xec>
      if ((ix&1) == 0) {
  c6:	f016 0c01 	ands.w	ip, r6, #1
  ca:	d109      	bne.n	e0 <fp_sqr_comba+0xe0>
          SQRADD(A->dp[ix>>1], A->dp[ix>>1]);
  cc:	1072      	asrs	r2, r6, #1
  ce:	3202      	adds	r2, #2
  d0:	f859 1022 	ldr.w	r1, [r9, r2, lsl #2]
  d4:	4662      	mov	r2, ip
  d6:	fbe1 3201 	umlal	r3, r2, r1, r1
  da:	18a4      	adds	r4, r4, r2
  dc:	eb45 054c 	adc.w	r5, r5, ip, lsl #1
      COMBA_STORE(dst->dp[ix]);
  e0:	9a03      	ldr	r2, [sp, #12]
  e2:	f842 3b04 	str.w	r3, [r2], #4
  for (ix = 0; ix < pa; ix++) {
  e6:	3601      	adds	r6, #1
      COMBA_STORE(dst->dp[ix]);
  e8:	9203      	str	r2, [sp, #12]
  for (ix = 0; ix < pa; ix++) {
  ea:	e7ab      	b.n	44 <fp_sqr_comba+0x44>
          SQRADD2(*tmpx++, *tmpy--);
  ec:	f8dd c004 	ldr.w	ip, [sp, #4]
  f0:	f85c 2904 	ldr.w	r2, [ip], #-4
  f4:	f8cd c004 	str.w	ip, [sp, #4]
  f8:	f85e c021 	ldr.w	ip, [lr, r1, lsl #2]
  fc:	fbac c202 	umull	ip, r2, ip, r2
 100:	eb13 030c 	adds.w	r3, r3, ip
 104:	f142 0a00 	adc.w	sl, r2, #0
 108:	eb14 040a 	adds.w	r4, r4, sl
 10c:	eb4b 0a0b 	adc.w	sl, fp, fp
 110:	eb13 030c 	adds.w	r3, r3, ip
 114:	f142 0200 	adc.w	r2, r2, #0
 118:	1914      	adds	r4, r2, r4
 11a:	eb45 050a 	adc.w	r5, r5, sl
      for (iz = 0; iz < iy; iz++) {
 11e:	3101      	adds	r1, #1
 120:	e7ce      	b.n	c0 <fp_sqr_comba+0xc0>
  fp_clamp (dst);
 122:	6002      	str	r2, [r0, #0]
 124:	e792      	b.n	4c <fp_sqr_comba+0x4c>
       return FP_MEM;
 126:	f06f 0001 	mvn.w	r0, #1
 12a:	e7a2      	b.n	72 <fp_sqr_comba+0x72>

Disassembly of section .text.fp_sqr:

00000000 <fp_sqr>:
{
   0:	b538      	push	{r3, r4, r5, lr}
    y = A->used;
   2:	6803      	ldr	r3, [r0, #0]
    oldused = B->used;
   4:	680d      	ldr	r5, [r1, #0]
    if (y + y >= FP_SIZE) {
   6:	005a      	lsls	r2, r3, #1
   8:	2a17      	cmp	r2, #23
{
   a:	460c      	mov	r4, r1
    if (y + y >= FP_SIZE) {
   c:	dc0f      	bgt.n	2e <fp_sqr+0x2e>
        if (y == 8) {
   e:	2b08      	cmp	r3, #8
  10:	d10a      	bne.n	28 <fp_sqr+0x28>
           err = fp_sqr_comba8(A,B);
  12:	f7ff fffe 	bl	0 <fp_sqr>
  for (y = B->used; y >= 0 && y < oldused; y++) {
  16:	4621      	mov	r1, r4
    B->dp[y] = 0;
  18:	2200      	movs	r2, #0
  for (y = B->used; y >= 0 && y < oldused; y++) {
  1a:	f851 3b08 	ldr.w	r3, [r1], #8
  1e:	2b00      	cmp	r3, #0
  20:	db01      	blt.n	26 <fp_sqr+0x26>
  22:	42ab      	cmp	r3, r5
  24:	db06      	blt.n	34 <fp_sqr+0x34>
}
  26:	bd38      	pop	{r3, r4, r5, pc}
       err = fp_sqr_comba(A, B);
  28:	f7ff fffe 	bl	0 <fp_sqr>
  2c:	e7f3      	b.n	16 <fp_sqr+0x16>
       err = FP_VAL;
  2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  32:	e7f0      	b.n	16 <fp_sqr+0x16>
    B->dp[y] = 0;
  34:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  for (y = B->used; y >= 0 && y < oldused; y++) {
  38:	3301      	adds	r3, #1
  3a:	e7f0      	b.n	1e <fp_sqr+0x1e>

Disassembly of section .text.fp_invmod_mont_ct:

00000000 <fp_invmod_mont_ct>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	461f      	mov	r7, r3
  if ((a->used * 2 > FP_SIZE) || (b->used * 2 > FP_SIZE)) {
   6:	6803      	ldr	r3, [r0, #0]
{
   8:	b085      	sub	sp, #20
  if ((a->used * 2 > FP_SIZE) || (b->used * 2 > FP_SIZE)) {
   a:	005b      	lsls	r3, r3, #1
   c:	2b18      	cmp	r3, #24
{
   e:	4683      	mov	fp, r0
  10:	460e      	mov	r6, r1
  12:	9201      	str	r2, [sp, #4]
  if ((a->used * 2 > FP_SIZE) || (b->used * 2 > FP_SIZE)) {
  14:	f300 80c7 	bgt.w	1a6 <fp_invmod_mont_ct+0x1a6>
  18:	680b      	ldr	r3, [r1, #0]
  1a:	005b      	lsls	r3, r3, #1
  1c:	2b18      	cmp	r3, #24
  1e:	f300 80c2 	bgt.w	1a6 <fp_invmod_mont_ct+0x1a6>
  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,
  22:	f44f 6082 	mov.w	r0, #1040	; 0x410
  26:	f7ff fffe 	bl	0 <malloc>
  if (t == NULL)
  2a:	4604      	mov	r4, r0
  2c:	2800      	cmp	r0, #0
  2e:	f000 80bd 	beq.w	1ac <fp_invmod_mont_ct+0x1ac>
  e = t + 1;
  32:	f100 0968 	add.w	r9, r0, #104	; 0x68
  pre = t + 2;
  36:	f100 08d0 	add.w	r8, r0, #208	; 0xd0
    fp_zero(a);
  3a:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  3e:	4648      	mov	r0, r9
  40:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  44:	4640      	mov	r0, r8
  46:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  fp_copy(a, &pre[0]);
  4a:	4641      	mov	r1, r8
  4c:	4658      	mov	r0, fp
  4e:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
  52:	f504 6382 	add.w	r3, r4, #1040	; 0x410
  56:	9302      	str	r3, [sp, #8]
  58:	f504 759c 	add.w	r5, r4, #312	; 0x138
  int i, j, err = FP_OKAY;
  5c:	2300      	movs	r3, #0
    fp_zero(a);
  5e:	4628      	mov	r0, r5
  60:	9303      	str	r3, [sp, #12]
  62:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    err |= fp_sqr(&pre[i-1], &pre[i]);
  66:	4629      	mov	r1, r5
  68:	f1a5 0068 	sub.w	r0, r5, #104	; 0x68
  6c:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    err |= fp_montgomery_reduce(&pre[i], b, mp);
  70:	463a      	mov	r2, r7
    err |= fp_sqr(&pre[i-1], &pre[i]);
  72:	4682      	mov	sl, r0
    err |= fp_montgomery_reduce(&pre[i], b, mp);
  74:	4631      	mov	r1, r6
  76:	4628      	mov	r0, r5
  78:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    err |= fp_mul(&pre[i], a, &pre[i]);
  7c:	462a      	mov	r2, r5
  7e:	ea4a 0a00 	orr.w	sl, sl, r0
  82:	4659      	mov	r1, fp
  84:	4628      	mov	r0, r5
  86:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    err |= fp_montgomery_reduce(&pre[i], b, mp);
  8a:	463a      	mov	r2, r7
  8c:	ea4a 0a00 	orr.w	sl, sl, r0
  90:	4631      	mov	r1, r6
  92:	4628      	mov	r0, r5
  94:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
  98:	9a02      	ldr	r2, [sp, #8]
    err |= fp_montgomery_reduce(&pre[i], b, mp);
  9a:	9b03      	ldr	r3, [sp, #12]
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
  9c:	3568      	adds	r5, #104	; 0x68
    err |= fp_montgomery_reduce(&pre[i], b, mp);
  9e:	ea4a 0a00 	orr.w	sl, sl, r0
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
  a2:	42aa      	cmp	r2, r5
    err |= fp_montgomery_reduce(&pre[i], b, mp);
  a4:	ea43 030a 	orr.w	r3, r3, sl
  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {
  a8:	d1d9      	bne.n	5e <fp_invmod_mont_ct+0x5e>
  err |= fp_sub_d(b, 2, e);
  aa:	464a      	mov	r2, r9
  ac:	2102      	movs	r1, #2
  ae:	4630      	mov	r0, r6
  b0:	9302      	str	r3, [sp, #8]
  b2:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  b6:	9b02      	ldr	r3, [sp, #8]
  b8:	ea40 0503 	orr.w	r5, r0, r3
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
  bc:	4648      	mov	r0, r9
  be:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  j = 1;
  c2:	f04f 0a01 	mov.w	sl, #1
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
  c6:	f1a0 0b02 	sub.w	fp, r0, #2
  ca:	f1bb 0f00 	cmp.w	fp, #0
  ce:	da27      	bge.n	120 <fp_invmod_mont_ct+0x120>
  fp_copy(&pre[j-1], t);
  d0:	2368      	movs	r3, #104	; 0x68
  d2:	fb03 800a 	mla	r0, r3, sl, r8
  d6:	4621      	mov	r1, r4
  d8:	3868      	subs	r0, #104	; 0x68
  da:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
  j = 0;
  de:	f04f 0a00 	mov.w	sl, #0
  for (; i >= 0; i--) {
  e2:	f1bb 0f00 	cmp.w	fp, #0
  e6:	da29      	bge.n	13c <fp_invmod_mont_ct+0x13c>
  if (j > 0) {
  e8:	f1ba 0f00 	cmp.w	sl, #0
  ec:	dd56      	ble.n	19c <fp_invmod_mont_ct+0x19c>
    err |= fp_mul(t, &pre[j-1], c);
  ee:	2168      	movs	r1, #104	; 0x68
  f0:	fb01 810a 	mla	r1, r1, sl, r8
  f4:	9a01      	ldr	r2, [sp, #4]
  f6:	3968      	subs	r1, #104	; 0x68
  f8:	4620      	mov	r0, r4
  fa:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    err |= fp_montgomery_reduce(c, b, mp);
  fe:	463a      	mov	r2, r7
    err |= fp_mul(t, &pre[j-1], c);
 100:	4680      	mov	r8, r0
    err |= fp_montgomery_reduce(c, b, mp);
 102:	4631      	mov	r1, r6
 104:	9801      	ldr	r0, [sp, #4]
 106:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
 10a:	ea48 0800 	orr.w	r8, r8, r0
 10e:	ea45 0508 	orr.w	r5, r5, r8
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
 112:	4620      	mov	r0, r4
 114:	f7ff fffe 	bl	0 <free>
}
 118:	4628      	mov	r0, r5
 11a:	b005      	add	sp, #20
 11c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)
 120:	4659      	mov	r1, fp
 122:	4648      	mov	r0, r9
 124:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
 128:	2800      	cmp	r0, #0
 12a:	d0d1      	beq.n	d0 <fp_invmod_mont_ct+0xd0>
 12c:	f1ba 0f08 	cmp.w	sl, #8
 130:	d0ce      	beq.n	d0 <fp_invmod_mont_ct+0xd0>
      j++;
 132:	f10a 0a01 	add.w	sl, sl, #1
  for (i = fp_count_bits(e)-2; i >= 0; i--) {
 136:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 13a:	e7c6      	b.n	ca <fp_invmod_mont_ct+0xca>
    int set = fp_is_bit_set(e, i);
 13c:	4659      	mov	r1, fp
 13e:	4648      	mov	r0, r9
 140:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {
 144:	f1ba 0f08 	cmp.w	sl, #8
    int set = fp_is_bit_set(e, i);
 148:	9002      	str	r0, [sp, #8]
    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {
 14a:	d003      	beq.n	154 <fp_invmod_mont_ct+0x154>
 14c:	b9b0      	cbnz	r0, 17c <fp_invmod_mont_ct+0x17c>
 14e:	f1ba 0f00 	cmp.w	sl, #0
 152:	dd13      	ble.n	17c <fp_invmod_mont_ct+0x17c>
      err |= fp_mul(t, &pre[j-1], t);
 154:	2368      	movs	r3, #104	; 0x68
 156:	fb03 810a 	mla	r1, r3, sl, r8
 15a:	4622      	mov	r2, r4
 15c:	3968      	subs	r1, #104	; 0x68
 15e:	4620      	mov	r0, r4
 160:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
      err |= fp_montgomery_reduce(t, b, mp);
 164:	463a      	mov	r2, r7
      err |= fp_mul(t, &pre[j-1], t);
 166:	4682      	mov	sl, r0
      err |= fp_montgomery_reduce(t, b, mp);
 168:	4631      	mov	r1, r6
 16a:	4620      	mov	r0, r4
 16c:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
 170:	ea4a 0a00 	orr.w	sl, sl, r0
 174:	ea45 050a 	orr.w	r5, r5, sl
      j = 0;
 178:	f04f 0a00 	mov.w	sl, #0
    err |= fp_sqr(t, t);
 17c:	4621      	mov	r1, r4
 17e:	4620      	mov	r0, r4
 180:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    err |= fp_montgomery_reduce(t, b, mp);
 184:	463a      	mov	r2, r7
    err |= fp_sqr(t, t);
 186:	4305      	orrs	r5, r0
    err |= fp_montgomery_reduce(t, b, mp);
 188:	4631      	mov	r1, r6
 18a:	4620      	mov	r0, r4
 18c:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
    j += set;
 190:	9b02      	ldr	r3, [sp, #8]
    err |= fp_montgomery_reduce(t, b, mp);
 192:	4305      	orrs	r5, r0
    j += set;
 194:	449a      	add	sl, r3
  for (; i >= 0; i--) {
 196:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 19a:	e7a2      	b.n	e2 <fp_invmod_mont_ct+0xe2>
    fp_copy(t, c);
 19c:	9901      	ldr	r1, [sp, #4]
 19e:	4620      	mov	r0, r4
 1a0:	f7ff fffe 	bl	0 <fp_invmod_mont_ct>
 1a4:	e7b5      	b.n	112 <fp_invmod_mont_ct+0x112>
    return FP_VAL;
 1a6:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 1aa:	e7b5      	b.n	118 <fp_invmod_mont_ct+0x118>
    return FP_MEM;
 1ac:	f06f 0501 	mvn.w	r5, #1
 1b0:	e7b2      	b.n	118 <fp_invmod_mont_ct+0x118>

Disassembly of section .text.mp_invmod_mont_ct:

00000000 <mp_invmod_mont_ct>:
  return fp_invmod_mont_ct(a, b, c, mp);
   0:	f7ff bffe 	b.w	0 <mp_invmod_mont_ct>

Disassembly of section .text._fp_exptmod_ct:

00000000 <_fp_exptmod_ct>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b085      	sub	sp, #20
   6:	4681      	mov	r9, r0
   8:	9101      	str	r1, [sp, #4]
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
   a:	4618      	mov	r0, r3
   c:	a903      	add	r1, sp, #12
{
   e:	4690      	mov	r8, r2
  10:	461d      	mov	r5, r3
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
  12:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
  16:	4682      	mov	sl, r0
  18:	b9e0      	cbnz	r0, 54 <_fp_exptmod_ct+0x54>
   R = (fp_int*)XMALLOC(sizeof(fp_int) * 3, NULL, DYNAMIC_TYPE_BIGINT);
  1a:	f44f 709c 	mov.w	r0, #312	; 0x138
  1e:	f7ff fffe 	bl	0 <malloc>
   if (R == NULL)
  22:	4604      	mov	r4, r0
  24:	2800      	cmp	r0, #0
  26:	f000 8095 	beq.w	154 <_fp_exptmod_ct+0x154>
  fp_init(&R[1]);
  2a:	f104 0768 	add.w	r7, r4, #104	; 0x68
    fp_zero(a);
  2e:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
  fp_init(&R[2]);
  32:	f104 06d0 	add.w	r6, r4, #208	; 0xd0
    fp_zero(a);
  36:	4638      	mov	r0, r7
  38:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
  3c:	4630      	mov	r0, r6
  3e:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
  err = fp_montgomery_calc_normalization (&R[0], P);
  42:	4629      	mov	r1, r5
  44:	4620      	mov	r0, r4
  46:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
  if (err != FP_OKAY) {
  4a:	4682      	mov	sl, r0
  4c:	b130      	cbz	r0, 5c <_fp_exptmod_ct+0x5c>
   XFREE(R, NULL, DYNAMIC_TYPE_BIGINT);
  4e:	4620      	mov	r0, r4
  50:	f7ff fffe 	bl	0 <free>
}
  54:	4650      	mov	r0, sl
  56:	b005      	add	sp, #20
  58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (fp_cmp_mag(P, G) != FP_GT) {
  5c:	4649      	mov	r1, r9
  5e:	4628      	mov	r0, r5
  60:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
  64:	2801      	cmp	r0, #1
  66:	d065      	beq.n	134 <_fp_exptmod_ct+0x134>
     err = fp_mod(G, P, &R[1]);
  68:	463a      	mov	r2, r7
  6a:	4629      	mov	r1, r5
  6c:	4648      	mov	r0, r9
  6e:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
     if (err != FP_OKAY) {
  72:	4682      	mov	sl, r0
  74:	2800      	cmp	r0, #0
  76:	d1ea      	bne.n	4e <_fp_exptmod_ct+0x4e>
  err = fp_mulmod (&R[1], &R[0], P, &R[1]);
  78:	463b      	mov	r3, r7
  7a:	462a      	mov	r2, r5
  7c:	4621      	mov	r1, r4
  7e:	4638      	mov	r0, r7
  80:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
  if (err != FP_OKAY) {
  84:	4682      	mov	sl, r0
  86:	2800      	cmp	r0, #0
  88:	d1e1      	bne.n	4e <_fp_exptmod_ct+0x4e>
  bitcnt = 1;
  8a:	2301      	movs	r3, #1
  digidx = digits - 1;
  8c:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
  bitcnt = 1;
  90:	9300      	str	r3, [sp, #0]
  buf    = 0;
  92:	4681      	mov	r9, r0
    if (--bitcnt == 0) {
  94:	9b00      	ldr	r3, [sp, #0]
  96:	3b01      	subs	r3, #1
  98:	9300      	str	r3, [sp, #0]
  9a:	d10b      	bne.n	b4 <_fp_exptmod_ct+0xb4>
      if (digidx == -1) {
  9c:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
  a0:	d04d      	beq.n	13e <_fp_exptmod_ct+0x13e>
      buf    = X->dp[digidx--];
  a2:	f108 0302 	add.w	r3, r8, #2
  a6:	9a01      	ldr	r2, [sp, #4]
  a8:	f852 9023 	ldr.w	r9, [r2, r3, lsl #2]
      bitcnt = (int)DIGIT_BIT;
  ac:	2320      	movs	r3, #32
      buf    = X->dp[digidx--];
  ae:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
      bitcnt = (int)DIGIT_BIT;
  b2:	9300      	str	r3, [sp, #0]
    err = fp_mul(&R[0], &R[1], &R[2]);
  b4:	4632      	mov	r2, r6
  b6:	4639      	mov	r1, r7
  b8:	4620      	mov	r0, r4
  ba:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
  be:	ea4f 7bd9 	mov.w	fp, r9, lsr #31
    if (err != FP_OKAY) {
  c2:	4682      	mov	sl, r0
    buf <<= (fp_digit)1;
  c4:	ea4f 0949 	mov.w	r9, r9, lsl #1
    if (err != FP_OKAY) {
  c8:	2800      	cmp	r0, #0
  ca:	d1c0      	bne.n	4e <_fp_exptmod_ct+0x4e>
    err = fp_montgomery_reduce(&R[2], P, mp);
  cc:	9a03      	ldr	r2, [sp, #12]
  ce:	4629      	mov	r1, r5
  d0:	4630      	mov	r0, r6
  d2:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
    if (err != FP_OKAY) {
  d6:	4682      	mov	sl, r0
  d8:	2800      	cmp	r0, #0
  da:	d1b8      	bne.n	4e <_fp_exptmod_ct+0x4e>
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
  dc:	4b1f      	ldr	r3, [pc, #124]	; (15c <_fp_exptmod_ct+0x15c>)
  de:	f853 a02b 	ldr.w	sl, [r3, fp, lsl #2]
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y^1]) ) );
  e2:	f08b 0b01 	eor.w	fp, fp, #1
            (fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y]) +
  e6:	ea0a 0104 	and.w	r1, sl, r4
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y^1]) ) );
  ea:	f853 b02b 	ldr.w	fp, [r3, fp, lsl #2]
  ee:	ea07 020b 	and.w	r2, r7, fp
    fp_copy(&R[2],
  f2:	4411      	add	r1, r2
  f4:	4630      	mov	r0, r6
  f6:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
  fa:	ea04 0b0b 	and.w	fp, r4, fp
                        ((wc_ptr_t)&R[1] & wc_off_on_addr[y]) ),
  fe:	ea0a 0307 	and.w	r3, sl, r7
    fp_copy((fp_int*) ( ((wc_ptr_t)&R[0] & wc_off_on_addr[y^1]) +
 102:	449b      	add	fp, r3
 104:	4631      	mov	r1, r6
 106:	4658      	mov	r0, fp
 108:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
    err = fp_sqr(&R[2], &R[2]);
 10c:	4631      	mov	r1, r6
 10e:	4630      	mov	r0, r6
 110:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
    if (err != FP_OKAY) {
 114:	4682      	mov	sl, r0
 116:	2800      	cmp	r0, #0
 118:	d199      	bne.n	4e <_fp_exptmod_ct+0x4e>
    err = fp_montgomery_reduce(&R[2], P, mp);
 11a:	9a03      	ldr	r2, [sp, #12]
 11c:	4629      	mov	r1, r5
 11e:	4630      	mov	r0, r6
 120:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
    if (err != FP_OKAY) {
 124:	4682      	mov	sl, r0
 126:	2800      	cmp	r0, #0
 128:	d191      	bne.n	4e <_fp_exptmod_ct+0x4e>
    fp_copy(&R[2],
 12a:	4659      	mov	r1, fp
 12c:	4630      	mov	r0, r6
 12e:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
    if (--bitcnt == 0) {
 132:	e7af      	b.n	94 <_fp_exptmod_ct+0x94>
     fp_copy(G, &R[1]);
 134:	4639      	mov	r1, r7
 136:	4648      	mov	r0, r9
 138:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
 13c:	e79c      	b.n	78 <_fp_exptmod_ct+0x78>
   err = fp_montgomery_reduce(&R[0], P, mp);
 13e:	4629      	mov	r1, r5
 140:	9a03      	ldr	r2, [sp, #12]
 142:	4620      	mov	r0, r4
 144:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
   fp_copy(&R[0], Y);
 148:	990e      	ldr	r1, [sp, #56]	; 0x38
   err = fp_montgomery_reduce(&R[0], P, mp);
 14a:	4682      	mov	sl, r0
   fp_copy(&R[0], Y);
 14c:	4620      	mov	r0, r4
 14e:	f7ff fffe 	bl	0 <_fp_exptmod_ct>
 152:	e77c      	b.n	4e <_fp_exptmod_ct+0x4e>
       return FP_MEM;
 154:	f06f 0a01 	mvn.w	sl, #1
 158:	e77c      	b.n	54 <_fp_exptmod_ct+0x54>
 15a:	bf00      	nop
 15c:	00000000 	.word	0x00000000

Disassembly of section .text._fp_exptmod_nct:

00000000 <_fp_exptmod_nct>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	b089      	sub	sp, #36	; 0x24
   6:	4680      	mov	r8, r0
  x = fp_count_bits (X);
   8:	4608      	mov	r0, r1
{
   a:	9104      	str	r1, [sp, #16]
   c:	4617      	mov	r7, r2
   e:	9305      	str	r3, [sp, #20]
  x = fp_count_bits (X);
  10:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  if (x <= 21) {
  14:	2815      	cmp	r0, #21
  16:	dd38      	ble.n	8a <_fp_exptmod_nct+0x8a>
  } else if (x <= 36) {
  18:	2824      	cmp	r0, #36	; 0x24
  1a:	dd38      	ble.n	8e <_fp_exptmod_nct+0x8e>
  } else if (x <= 140) {
  1c:	288c      	cmp	r0, #140	; 0x8c
  1e:	dd38      	ble.n	92 <_fp_exptmod_nct+0x92>
    winsize = 6;
  20:	f5b0 7fe1 	cmp.w	r0, #450	; 0x1c2
  24:	bfd4      	ite	le
  26:	2305      	movle	r3, #5
  28:	2306      	movgt	r3, #6
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
  2a:	a907      	add	r1, sp, #28
  2c:	4638      	mov	r0, r7
    winsize = 4;
  2e:	9300      	str	r3, [sp, #0]
  if ((err = fp_montgomery_setup (P, &mp)) != FP_OKAY) {
  30:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  34:	4604      	mov	r4, r0
  36:	2800      	cmp	r0, #0
  38:	f040 8105 	bne.w	246 <_fp_exptmod_nct+0x246>
  M = (fp_int*)XMALLOC(sizeof(fp_int)*((1 << winsize) + 1), NULL,
  3c:	9a00      	ldr	r2, [sp, #0]
  3e:	2301      	movs	r3, #1
  40:	4093      	lsls	r3, r2
  42:	f04f 0968 	mov.w	r9, #104	; 0x68
  46:	fb03 9009 	mla	r0, r3, r9, r9
  4a:	9301      	str	r3, [sp, #4]
  4c:	f7ff fffe 	bl	0 <malloc>
  if (M == NULL) {
  50:	4605      	mov	r5, r0
  52:	2800      	cmp	r0, #0
  54:	f000 8147 	beq.w	2e6 <_fp_exptmod_nct+0x2e6>
  res = &M[(word32)(1 << winsize)];
  58:	9b00      	ldr	r3, [sp, #0]
  5a:	fa09 f603 	lsl.w	r6, r9, r3
  5e:	4406      	add	r6, r0
    fp_zero(a);
  60:	fb09 5004 	mla	r0, r9, r4, r5
  64:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  for(x = 0; x < (1 << winsize); x++)
  68:	9b01      	ldr	r3, [sp, #4]
  6a:	3401      	adds	r4, #1
  6c:	42a3      	cmp	r3, r4
  6e:	d1f7      	bne.n	60 <_fp_exptmod_nct+0x60>
    fp_zero(a);
  70:	4630      	mov	r0, r6
  72:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  err = fp_montgomery_calc_normalization (res, P);
  76:	4639      	mov	r1, r7
  78:	4630      	mov	r0, r6
  7a:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  if (err != FP_OKAY) {
  7e:	4604      	mov	r4, r0
  80:	b148      	cbz	r0, 96 <_fp_exptmod_nct+0x96>
  XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
  82:	4628      	mov	r0, r5
  84:	f7ff fffe 	bl	0 <free>
  return err;
  88:	e0dd      	b.n	246 <_fp_exptmod_nct+0x246>
    winsize = 1;
  8a:	2301      	movs	r3, #1
  8c:	e7cd      	b.n	2a <_fp_exptmod_nct+0x2a>
    winsize = 3;
  8e:	2303      	movs	r3, #3
  90:	e7cb      	b.n	2a <_fp_exptmod_nct+0x2a>
    winsize = 4;
  92:	2304      	movs	r3, #4
  94:	e7c9      	b.n	2a <_fp_exptmod_nct+0x2a>
  if (fp_cmp_mag(P, G) != FP_GT) {
  96:	4641      	mov	r1, r8
  98:	4638      	mov	r0, r7
  9a:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  9e:	2801      	cmp	r0, #1
     err = fp_mod(G, P, &M[1]);
  a0:	f105 0968 	add.w	r9, r5, #104	; 0x68
  if (fp_cmp_mag(P, G) != FP_GT) {
  a4:	f000 8088 	beq.w	1b8 <_fp_exptmod_nct+0x1b8>
     err = fp_mod(G, P, &M[1]);
  a8:	464a      	mov	r2, r9
  aa:	4639      	mov	r1, r7
  ac:	4640      	mov	r0, r8
  ae:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
     if (err != FP_OKAY) {
  b2:	4604      	mov	r4, r0
  b4:	2800      	cmp	r0, #0
  b6:	d1e4      	bne.n	82 <_fp_exptmod_nct+0x82>
  err = fp_mulmod (&M[1], res, P, &M[1]);
  b8:	464b      	mov	r3, r9
  ba:	463a      	mov	r2, r7
  bc:	4631      	mov	r1, r6
  be:	4648      	mov	r0, r9
  c0:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  if (err != FP_OKAY) {
  c4:	4604      	mov	r4, r0
  c6:	2800      	cmp	r0, #0
  c8:	d1db      	bne.n	82 <_fp_exptmod_nct+0x82>
  fp_copy (&M[1], &M[(word32)(1 << (winsize - 1))]);
  ca:	9b00      	ldr	r3, [sp, #0]
  cc:	f04f 0868 	mov.w	r8, #104	; 0x68
  d0:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
  d4:	fa08 f80a 	lsl.w	r8, r8, sl
  d8:	44a8      	add	r8, r5
  da:	4641      	mov	r1, r8
  dc:	4648      	mov	r0, r9
  de:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  for (x = 0; x < (winsize - 1); x++) {
  e2:	46a3      	mov	fp, r4
  e4:	45da      	cmp	sl, fp
  e6:	dc6c      	bgt.n	1c2 <_fp_exptmod_nct+0x1c2>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
  e8:	f04f 0b01 	mov.w	fp, #1
  ec:	fa0b fa0a 	lsl.w	sl, fp, sl
  f0:	44da      	add	sl, fp
  f2:	9b01      	ldr	r3, [sp, #4]
  f4:	4553      	cmp	r3, sl
  f6:	dc79      	bgt.n	1ec <_fp_exptmod_nct+0x1ec>
  digidx = X->used - 1;
  f8:	9b04      	ldr	r3, [sp, #16]
  fa:	681b      	ldr	r3, [r3, #0]
  mode   = 0;
  fc:	f04f 0800 	mov.w	r8, #0
  bitcnt = (x % DIGIT_BIT) + 1;
 100:	f00a 0a1f 	and.w	sl, sl, #31
  digidx = X->used - 1;
 104:	3b01      	subs	r3, #1
  bitcnt = (x % DIGIT_BIT) + 1;
 106:	f10a 0b01 	add.w	fp, sl, #1
  digidx = X->used - 1;
 10a:	9303      	str	r3, [sp, #12]
  bitcpy = 0;
 10c:	46c2      	mov	sl, r8
  bitbuf = 0;
 10e:	4644      	mov	r4, r8
  buf    = 0;
 110:	f8cd 8008 	str.w	r8, [sp, #8]
    if (--bitcnt == 0) {
 114:	f1bb 0b01 	subs.w	fp, fp, #1
 118:	d10d      	bne.n	136 <_fp_exptmod_nct+0x136>
      if (digidx == -1) {
 11a:	9b03      	ldr	r3, [sp, #12]
 11c:	1c5a      	adds	r2, r3, #1
 11e:	f000 80a2 	beq.w	266 <_fp_exptmod_nct+0x266>
      buf    = X->dp[digidx--];
 122:	9a04      	ldr	r2, [sp, #16]
 124:	3302      	adds	r3, #2
      bitcnt = (int)DIGIT_BIT;
 126:	f04f 0b20 	mov.w	fp, #32
      buf    = X->dp[digidx--];
 12a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 12e:	9302      	str	r3, [sp, #8]
 130:	9b03      	ldr	r3, [sp, #12]
 132:	3b01      	subs	r3, #1
 134:	9303      	str	r3, [sp, #12]
    buf <<= (fp_digit)1;
 136:	9a02      	ldr	r2, [sp, #8]
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 138:	9b02      	ldr	r3, [sp, #8]
    buf <<= (fp_digit)1;
 13a:	0052      	lsls	r2, r2, #1
    y     = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 13c:	0fdb      	lsrs	r3, r3, #31
    buf <<= (fp_digit)1;
 13e:	9202      	str	r2, [sp, #8]
    if (mode == 0 && y == 0) {
 140:	f1b8 0f00 	cmp.w	r8, #0
 144:	d16e      	bne.n	224 <_fp_exptmod_nct+0x224>
 146:	2b00      	cmp	r3, #0
 148:	d0e4      	beq.n	114 <_fp_exptmod_nct+0x114>
    bitbuf |= (y << (winsize - ++bitcpy));
 14a:	9900      	ldr	r1, [sp, #0]
 14c:	f10a 0201 	add.w	r2, sl, #1
 150:	1a89      	subs	r1, r1, r2
 152:	408b      	lsls	r3, r1
 154:	431c      	orrs	r4, r3
    if (bitcpy == winsize) {
 156:	9b00      	ldr	r3, [sp, #0]
 158:	4293      	cmp	r3, r2
 15a:	d15f      	bne.n	21c <_fp_exptmod_nct+0x21c>
      for (x = 0; x < winsize; x++) {
 15c:	f04f 0800 	mov.w	r8, #0
        err = fp_sqr(res, res);
 160:	4631      	mov	r1, r6
 162:	4630      	mov	r0, r6
 164:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
        if (err != FP_OKAY) {
 168:	4603      	mov	r3, r0
 16a:	2800      	cmp	r0, #0
 16c:	d165      	bne.n	23a <_fp_exptmod_nct+0x23a>
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 16e:	9a07      	ldr	r2, [sp, #28]
 170:	4639      	mov	r1, r7
 172:	4630      	mov	r0, r6
 174:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
        if (err != FP_OKAY) {
 178:	4603      	mov	r3, r0
 17a:	2800      	cmp	r0, #0
 17c:	d15d      	bne.n	23a <_fp_exptmod_nct+0x23a>
      for (x = 0; x < winsize; x++) {
 17e:	45c2      	cmp	sl, r8
 180:	f108 0301 	add.w	r3, r8, #1
 184:	dc6d      	bgt.n	262 <_fp_exptmod_nct+0x262>
      err = fp_mul(res, &M[bitbuf], res);
 186:	2368      	movs	r3, #104	; 0x68
 188:	fb03 5104 	mla	r1, r3, r4, r5
 18c:	4632      	mov	r2, r6
 18e:	4630      	mov	r0, r6
 190:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
      if (err != FP_OKAY) {
 194:	4604      	mov	r4, r0
 196:	2800      	cmp	r0, #0
 198:	f47f af73 	bne.w	82 <_fp_exptmod_nct+0x82>
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 19c:	4603      	mov	r3, r0
 19e:	9a07      	ldr	r2, [sp, #28]
 1a0:	4639      	mov	r1, r7
 1a2:	4630      	mov	r0, r6
 1a4:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
      if (err != FP_OKAY) {
 1a8:	4604      	mov	r4, r0
 1aa:	2800      	cmp	r0, #0
 1ac:	f47f af69 	bne.w	82 <_fp_exptmod_nct+0x82>
      bitcpy = 0;
 1b0:	46a2      	mov	sl, r4
      mode   = 1;
 1b2:	f04f 0801 	mov.w	r8, #1
 1b6:	e7ad      	b.n	114 <_fp_exptmod_nct+0x114>
     fp_copy(G, &M[1]);
 1b8:	4649      	mov	r1, r9
 1ba:	4640      	mov	r0, r8
 1bc:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
 1c0:	e77a      	b.n	b8 <_fp_exptmod_nct+0xb8>
    err = fp_sqr (&M[(word32)(1 << (winsize - 1))],
 1c2:	4641      	mov	r1, r8
 1c4:	4640      	mov	r0, r8
 1c6:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
    if (err != FP_OKAY) {
 1ca:	4604      	mov	r4, r0
 1cc:	2800      	cmp	r0, #0
 1ce:	f47f af58 	bne.w	82 <_fp_exptmod_nct+0x82>
    err = fp_montgomery_reduce_ex(&M[(word32)(1 << (winsize - 1))], P, mp, 0);
 1d2:	4603      	mov	r3, r0
 1d4:	9a07      	ldr	r2, [sp, #28]
 1d6:	4639      	mov	r1, r7
 1d8:	4640      	mov	r0, r8
 1da:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
    if (err != FP_OKAY) {
 1de:	4604      	mov	r4, r0
 1e0:	2800      	cmp	r0, #0
 1e2:	f47f af4e 	bne.w	82 <_fp_exptmod_nct+0x82>
  for (x = 0; x < (winsize - 1); x++) {
 1e6:	f10b 0b01 	add.w	fp, fp, #1
 1ea:	e77b      	b.n	e4 <_fp_exptmod_nct+0xe4>
    err = fp_mul(&M[x - 1], &M[1], &M[x]);
 1ec:	4640      	mov	r0, r8
 1ee:	f108 0868 	add.w	r8, r8, #104	; 0x68
 1f2:	4642      	mov	r2, r8
 1f4:	4649      	mov	r1, r9
 1f6:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
    if (err != FP_OKAY) {
 1fa:	4604      	mov	r4, r0
 1fc:	2800      	cmp	r0, #0
 1fe:	f47f af40 	bne.w	82 <_fp_exptmod_nct+0x82>
    err = fp_montgomery_reduce_ex(&M[x], P, mp, 0);
 202:	4603      	mov	r3, r0
 204:	9a07      	ldr	r2, [sp, #28]
 206:	4639      	mov	r1, r7
 208:	4640      	mov	r0, r8
 20a:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
    if (err != FP_OKAY) {
 20e:	4604      	mov	r4, r0
 210:	2800      	cmp	r0, #0
 212:	f47f af36 	bne.w	82 <_fp_exptmod_nct+0x82>
  for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
 216:	f10a 0a01 	add.w	sl, sl, #1
 21a:	e76a      	b.n	f2 <_fp_exptmod_nct+0xf2>
 21c:	4692      	mov	sl, r2
    mode    = 2;
 21e:	f04f 0802 	mov.w	r8, #2
 222:	e777      	b.n	114 <_fp_exptmod_nct+0x114>
    if (mode == 1 && y == 0) {
 224:	f1b8 0f01 	cmp.w	r8, #1
 228:	d18f      	bne.n	14a <_fp_exptmod_nct+0x14a>
 22a:	2b00      	cmp	r3, #0
 22c:	d18d      	bne.n	14a <_fp_exptmod_nct+0x14a>
      err = fp_sqr(res, res);
 22e:	4631      	mov	r1, r6
 230:	4630      	mov	r0, r6
 232:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
      if (err != FP_OKAY) {
 236:	4603      	mov	r3, r0
 238:	b148      	cbz	r0, 24e <_fp_exptmod_nct+0x24e>
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 23a:	4628      	mov	r0, r5
 23c:	9300      	str	r3, [sp, #0]
 23e:	f7ff fffe 	bl	0 <free>
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 242:	9b00      	ldr	r3, [sp, #0]
 244:	461c      	mov	r4, r3
}
 246:	4620      	mov	r0, r4
 248:	b009      	add	sp, #36	; 0x24
 24a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 24e:	9a07      	ldr	r2, [sp, #28]
 250:	4639      	mov	r1, r7
 252:	4630      	mov	r0, r6
 254:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
      if (err != FP_OKAY) {
 258:	4603      	mov	r3, r0
 25a:	2800      	cmp	r0, #0
 25c:	f43f af5a 	beq.w	114 <_fp_exptmod_nct+0x114>
 260:	e7eb      	b.n	23a <_fp_exptmod_nct+0x23a>
      for (x = 0; x < winsize; x++) {
 262:	4698      	mov	r8, r3
 264:	e77c      	b.n	160 <_fp_exptmod_nct+0x160>
  if (mode == 2 && bitcpy > 0) {
 266:	f1b8 0f02 	cmp.w	r8, #2
 26a:	d00b      	beq.n	284 <_fp_exptmod_nct+0x284>
  err = fp_montgomery_reduce_ex(res, P, mp, 0);
 26c:	4639      	mov	r1, r7
 26e:	9a07      	ldr	r2, [sp, #28]
 270:	2300      	movs	r3, #0
 272:	4630      	mov	r0, r6
 274:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
  fp_copy (res, Y);
 278:	9905      	ldr	r1, [sp, #20]
  err = fp_montgomery_reduce_ex(res, P, mp, 0);
 27a:	4604      	mov	r4, r0
  fp_copy (res, Y);
 27c:	4630      	mov	r0, r6
 27e:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
 282:	e6fe      	b.n	82 <_fp_exptmod_nct+0x82>
  if (mode == 2 && bitcpy > 0) {
 284:	f1ba 0f00 	cmp.w	sl, #0
 288:	ddf0      	ble.n	26c <_fp_exptmod_nct+0x26c>
      err = fp_sqr(res, res);
 28a:	4631      	mov	r1, r6
 28c:	4630      	mov	r0, r6
 28e:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
      if (err != FP_OKAY) {
 292:	4680      	mov	r8, r0
 294:	b120      	cbz	r0, 2a0 <_fp_exptmod_nct+0x2a0>
          XFREE(M, NULL, DYNAMIC_TYPE_BIGINT);
 296:	4628      	mov	r0, r5
 298:	f7ff fffe 	bl	0 <free>
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 29c:	4644      	mov	r4, r8
          return err;
 29e:	e7d2      	b.n	246 <_fp_exptmod_nct+0x246>
      err = fp_montgomery_reduce_ex(res, P, mp, 0);
 2a0:	4603      	mov	r3, r0
 2a2:	9a07      	ldr	r2, [sp, #28]
 2a4:	4639      	mov	r1, r7
 2a6:	4630      	mov	r0, r6
 2a8:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
      if (err != FP_OKAY) {
 2ac:	4680      	mov	r8, r0
 2ae:	2800      	cmp	r0, #0
 2b0:	d1f1      	bne.n	296 <_fp_exptmod_nct+0x296>
      if ((bitbuf & (1 << winsize)) != 0) {
 2b2:	9b01      	ldr	r3, [sp, #4]
      bitbuf <<= 1;
 2b4:	0064      	lsls	r4, r4, #1
      if ((bitbuf & (1 << winsize)) != 0) {
 2b6:	4223      	tst	r3, r4
 2b8:	d010      	beq.n	2dc <_fp_exptmod_nct+0x2dc>
        err = fp_mul(res, &M[1], res);
 2ba:	4632      	mov	r2, r6
 2bc:	4649      	mov	r1, r9
 2be:	4630      	mov	r0, r6
 2c0:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
        if (err != FP_OKAY) {
 2c4:	4680      	mov	r8, r0
 2c6:	2800      	cmp	r0, #0
 2c8:	d1e5      	bne.n	296 <_fp_exptmod_nct+0x296>
        err = fp_montgomery_reduce_ex(res, P, mp, 0);
 2ca:	4603      	mov	r3, r0
 2cc:	9a07      	ldr	r2, [sp, #28]
 2ce:	4639      	mov	r1, r7
 2d0:	4630      	mov	r0, r6
 2d2:	f7ff fffe 	bl	0 <_fp_exptmod_nct>
        if (err != FP_OKAY) {
 2d6:	4680      	mov	r8, r0
 2d8:	2800      	cmp	r0, #0
 2da:	d1dc      	bne.n	296 <_fp_exptmod_nct+0x296>
    for (x = 0; x < bitcpy; x++) {
 2dc:	f10b 0b01 	add.w	fp, fp, #1
 2e0:	45da      	cmp	sl, fp
 2e2:	d1d2      	bne.n	28a <_fp_exptmod_nct+0x28a>
 2e4:	e7c2      	b.n	26c <_fp_exptmod_nct+0x26c>
     return FP_MEM;
 2e6:	f06f 0401 	mvn.w	r4, #1
 2ea:	e7ac      	b.n	246 <_fp_exptmod_nct+0x246>

Disassembly of section .text.fp_div_d:

00000000 <fp_div_d>:
   return FP_NO;
}

/* a/b => cb + d == a */
static int fp_div_d(fp_int *a, fp_digit b, fp_int *c, fp_digit *d)
{
   0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4606      	mov	r6, r0
   6:	4617      	mov	r7, r2
   8:	4698      	mov	r8, r3
  fp_word  w;
  fp_digit t;
  int      ix;

  /* cannot divide by zero */
  if (b == 0) {
   a:	460d      	mov	r5, r1
   c:	2900      	cmp	r1, #0
   e:	d07a      	beq.n	106 <fp_div_d+0x106>
     return FP_VAL;
  }

  /* quick outs */
  if (b == 1 || fp_iszero(a) == FP_YES) {
  10:	2901      	cmp	r1, #1
  12:	d001      	beq.n	18 <fp_div_d+0x18>
  14:	6803      	ldr	r3, [r0, #0]
  16:	b973      	cbnz	r3, 36 <fp_div_d+0x36>
     if (d != NULL) {
  18:	f1b8 0f00 	cmp.w	r8, #0
  1c:	d002      	beq.n	24 <fp_div_d+0x24>
        *d = 0;
  1e:	2300      	movs	r3, #0
  20:	f8c8 3000 	str.w	r3, [r8]
     }
     if (c != NULL) {
  24:	b917      	cbnz	r7, 2c <fp_div_d+0x2c>
  }

#ifdef WOLFSSL_SMALL_STACK
  XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
#endif
  return FP_OKAY;
  26:	2000      	movs	r0, #0
}
  28:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        fp_copy(a, c);
  2c:	4639      	mov	r1, r7
  2e:	4630      	mov	r0, r6
  30:	f7ff fffe 	bl	0 <fp_div_d>
  34:	e7f7      	b.n	26 <fp_div_d+0x26>
   if ((b==0) || (b & (b-1))) {
  36:	3901      	subs	r1, #1
  38:	4029      	ands	r1, r5
  3a:	d103      	bne.n	44 <fp_div_d+0x44>
      if (b == (((fp_digit)1)<<x)) {
  3c:	2301      	movs	r3, #1
   for (x = 0; x < DIGIT_BIT; x++) {
  3e:	3101      	adds	r1, #1
  40:	2920      	cmp	r1, #32
  42:	d120      	bne.n	86 <fp_div_d+0x86>
  q = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
  44:	2068      	movs	r0, #104	; 0x68
  46:	f7ff fffe 	bl	0 <malloc>
  if (q == NULL)
  4a:	4604      	mov	r4, r0
  4c:	2800      	cmp	r0, #0
  4e:	d05d      	beq.n	10c <fp_div_d+0x10c>
    fp_zero(a);
  50:	f7ff fffe 	bl	0 <fp_div_d>
  if (c != NULL) {
  54:	6833      	ldr	r3, [r6, #0]
  56:	b117      	cbz	r7, 5e <fp_div_d+0x5e>
    q->sign = a->sign;
  58:	6872      	ldr	r2, [r6, #4]
    q->used = a->used;
  5a:	6023      	str	r3, [r4, #0]
    q->sign = a->sign;
  5c:	6062      	str	r2, [r4, #4]
  for (ix = a->used - 1; ix >= 0; ix--) {
  5e:	f103 3aff 	add.w	sl, r3, #4294967295	; 0xffffffff
  w = 0;
  62:	f04f 0900 	mov.w	r9, #0
     w = (w << ((fp_word)DIGIT_BIT)) | ((fp_word)a->dp[ix]);
  66:	3608      	adds	r6, #8
        q->dp[ix] = (fp_digit)t;
  68:	f104 0b08 	add.w	fp, r4, #8
  for (ix = a->used - 1; ix >= 0; ix--) {
  6c:	f1ba 0f00 	cmp.w	sl, #0
  70:	da21      	bge.n	b6 <fp_div_d+0xb6>
  if (d != NULL) {
  72:	f1b8 0f00 	cmp.w	r8, #0
  76:	d001      	beq.n	7c <fp_div_d+0x7c>
     *d = (fp_digit)w;
  78:	f8c8 9000 	str.w	r9, [r8]
  if (c != NULL) {
  7c:	bba7      	cbnz	r7, e8 <fp_div_d+0xe8>
  XFREE(q, NULL, DYNAMIC_TYPE_BIGINT);
  7e:	4620      	mov	r0, r4
  80:	f7ff fffe 	bl	0 <free>
  84:	e7cf      	b.n	26 <fp_div_d+0x26>
      if (b == (((fp_digit)1)<<x)) {
  86:	fa03 f201 	lsl.w	r2, r3, r1
  8a:	4295      	cmp	r5, r2
  8c:	d1d7      	bne.n	3e <fp_div_d+0x3e>
     if (d != NULL) {
  8e:	f1b8 0f00 	cmp.w	r8, #0
  92:	d008      	beq.n	a6 <fp_div_d+0xa6>
        *d = a->dp[0] & ((((fp_digit)1)<<ix) - 1);
  94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  98:	fa03 f201 	lsl.w	r2, r3, r1
  9c:	68b3      	ldr	r3, [r6, #8]
  9e:	ea23 0302 	bic.w	r3, r3, r2
  a2:	f8c8 3000 	str.w	r3, [r8]
     if (c != NULL) {
  a6:	2f00      	cmp	r7, #0
  a8:	d0bd      	beq.n	26 <fp_div_d+0x26>
        fp_div_2d(a, ix, c, NULL);
  aa:	2300      	movs	r3, #0
  ac:	463a      	mov	r2, r7
  ae:	4630      	mov	r0, r6
  b0:	f7ff fffe 	bl	0 <fp_div_d>
  b4:	e7b7      	b.n	26 <fp_div_d+0x26>
     w = (w << ((fp_word)DIGIT_BIT)) | ((fp_word)a->dp[ix]);
  b6:	4649      	mov	r1, r9
  b8:	f856 902a 	ldr.w	r9, [r6, sl, lsl #2]
     if (w >= b) {
  bc:	45a9      	cmp	r9, r5
  be:	f171 0300 	sbcs.w	r3, r1, #0
  c2:	d30e      	bcc.n	e2 <fp_div_d+0xe2>
        t = (fp_digit)(w / b);
  c4:	462a      	mov	r2, r5
  c6:	2300      	movs	r3, #0
  c8:	4648      	mov	r0, r9
  ca:	f7ff fffe 	bl	0 <__aeabi_uldivmod>
        w -= ((fp_word)t) * ((fp_word)b);
  ce:	fba0 3205 	umull	r3, r2, r0, r5
  d2:	ebb9 0903 	subs.w	r9, r9, r3
      if (c != NULL)
  d6:	b10f      	cbz	r7, dc <fp_div_d+0xdc>
        q->dp[ix] = (fp_digit)t;
  d8:	f84b 002a 	str.w	r0, [fp, sl, lsl #2]
  for (ix = a->used - 1; ix >= 0; ix--) {
  dc:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
  e0:	e7c4      	b.n	6c <fp_div_d+0x6c>
        t = 0;
  e2:	2000      	movs	r0, #0
  e4:	e7f7      	b.n	d6 <fp_div_d+0xd6>
     fp_clamp(q);
  e6:	6022      	str	r2, [r4, #0]
  e8:	6823      	ldr	r3, [r4, #0]
  ea:	b133      	cbz	r3, fa <fp_div_d+0xfa>
  ec:	1e5a      	subs	r2, r3, #1
  ee:	3301      	adds	r3, #1
  f0:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  f4:	2b00      	cmp	r3, #0
  f6:	d0f6      	beq.n	e6 <fp_div_d+0xe6>
  f8:	6863      	ldr	r3, [r4, #4]
  fa:	6063      	str	r3, [r4, #4]
     fp_copy(q, c);
  fc:	4639      	mov	r1, r7
  fe:	4620      	mov	r0, r4
 100:	f7ff fffe 	bl	0 <fp_div_d>
 104:	e7bb      	b.n	7e <fp_div_d+0x7e>
     return FP_VAL;
 106:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 10a:	e78d      	b.n	28 <fp_div_d+0x28>
      return FP_MEM;
 10c:	f06f 0001 	mvn.w	r0, #1
 110:	e78a      	b.n	28 <fp_div_d+0x28>

Disassembly of section .text.fp_init_copy:

00000000 <fp_init_copy>:
    if (a != b) {
   0:	4288      	cmp	r0, r1
{
   2:	b538      	push	{r3, r4, r5, lr}
   4:	4605      	mov	r5, r0
   6:	460c      	mov	r4, r1
    if (a != b) {
   8:	d007      	beq.n	1a <fp_init_copy+0x1a>
    fp_zero(a);
   a:	f7ff fffe 	bl	0 <fp_init_copy>
        fp_copy(b, a); /* copy (src = b) to (dst = a) */
   e:	4629      	mov	r1, r5
  10:	4620      	mov	r0, r4
}
  12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        fp_copy(b, a); /* copy (src = b) to (dst = a) */
  16:	f7ff bffe 	b.w	0 <fp_init_copy>
}
  1a:	bd38      	pop	{r3, r4, r5, pc}

Disassembly of section .text.fp_exptmod:

00000000 <fp_exptmod>:
{
   0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	4698      	mov	r8, r3
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
   6:	6813      	ldr	r3, [r2, #0]
{
   8:	b087      	sub	sp, #28
   a:	4605      	mov	r5, r0
   c:	4689      	mov	r9, r1
   e:	4617      	mov	r7, r2
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
  10:	2b00      	cmp	r3, #0
  12:	f000 8136 	beq.w	282 <fp_exptmod+0x282>
  16:	2b0c      	cmp	r3, #12
  18:	f300 8133 	bgt.w	282 <fp_exptmod+0x282>
   if (fp_isone(P)) {
  1c:	2b01      	cmp	r3, #1
  1e:	d110      	bne.n	42 <fp_exptmod+0x42>
  20:	6893      	ldr	r3, [r2, #8]
  22:	2b01      	cmp	r3, #1
  24:	d10d      	bne.n	42 <fp_exptmod+0x42>
  26:	6853      	ldr	r3, [r2, #4]
  28:	b95b      	cbnz	r3, 42 <fp_exptmod+0x42>
   a->dp[0] = b;
  2a:	2600      	movs	r6, #0
   fp_zero(a);
  2c:	4640      	mov	r0, r8
  2e:	f7ff fffe 	bl	0 <fp_exptmod>
   a->dp[0] = b;
  32:	f8c8 6008 	str.w	r6, [r8, #8]
   a->used  = a->dp[0] ? 1 : 0;
  36:	f8c8 6000 	str.w	r6, [r8]
}
  3a:	4630      	mov	r0, r6
  3c:	b007      	add	sp, #28
  3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (fp_iszero(X)) {
  42:	f8d9 6000 	ldr.w	r6, [r9]
  46:	b946      	cbnz	r6, 5a <fp_exptmod+0x5a>
   fp_zero(a);
  48:	4640      	mov	r0, r8
  4a:	f7ff fffe 	bl	0 <fp_exptmod>
   a->dp[0] = b;
  4e:	2301      	movs	r3, #1
  50:	f8c8 3008 	str.w	r3, [r8, #8]
   a->used  = a->dp[0] ? 1 : 0;
  54:	f8c8 3000 	str.w	r3, [r8]
      return FP_OKAY;
  58:	e7ef      	b.n	3a <fp_exptmod+0x3a>
   if (fp_iszero(G)) {
  5a:	682b      	ldr	r3, [r5, #0]
  5c:	9302      	str	r3, [sp, #8]
  5e:	2b00      	cmp	r3, #0
  60:	d0e3      	beq.n	2a <fp_exptmod+0x2a>
   if (X->sign == FP_NEG) {
  62:	f8d9 3004 	ldr.w	r3, [r9, #4]
  66:	2b01      	cmp	r3, #1
  68:	d134      	bne.n	d4 <fp_exptmod+0xd4>
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_BIGINT);
  6a:	20d0      	movs	r0, #208	; 0xd0
  6c:	f7ff fffe 	bl	0 <malloc>
      if (tmp == NULL)
  70:	4604      	mov	r4, r0
  72:	2800      	cmp	r0, #0
  74:	f000 8108 	beq.w	288 <fp_exptmod+0x288>
      fp_init_copy(&tmp[0], G);
  78:	4629      	mov	r1, r5
      fp_init_copy(&tmp[1], P);
  7a:	f104 0568 	add.w	r5, r4, #104	; 0x68
      fp_init_copy(&tmp[0], G);
  7e:	f7ff fffe 	bl	0 <fp_exptmod>
      fp_init_copy(&tmp[1], P);
  82:	4639      	mov	r1, r7
  84:	4628      	mov	r0, r5
  86:	f7ff fffe 	bl	0 <fp_exptmod>
      tmp[1].sign = FP_ZPOS;
  8a:	2300      	movs	r3, #0
  8c:	66e3      	str	r3, [r4, #108]	; 0x6c
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
  8e:	4622      	mov	r2, r4
  90:	4629      	mov	r1, r5
  92:	4620      	mov	r0, r4
  94:	f7ff fffe 	bl	0 <fp_exptmod>
      if (err == FP_OKAY) {
  98:	4606      	mov	r6, r0
  9a:	b9b8      	cbnz	r0, cc <fp_exptmod+0xcc>
         fp_copy(X, &tmp[1]);
  9c:	4629      	mov	r1, r5
  9e:	4648      	mov	r0, r9
  a0:	f7ff fffe 	bl	0 <fp_exptmod>
         tmp[1].sign = FP_ZPOS;
  a4:	66e6      	str	r6, [r4, #108]	; 0x6c
         err =  _fp_exptmod_ct(&tmp[0], &tmp[1], tmp[1].used, P, Y);
  a6:	f8cd 8000 	str.w	r8, [sp]
  aa:	6ea2      	ldr	r2, [r4, #104]	; 0x68
  ac:	463b      	mov	r3, r7
  ae:	4629      	mov	r1, r5
  b0:	4620      	mov	r0, r4
  b2:	f7ff fffe 	bl	0 <fp_exptmod>
         if ((err == 0) && (P->sign == FP_NEG)) {
  b6:	4606      	mov	r6, r0
  b8:	b940      	cbnz	r0, cc <fp_exptmod+0xcc>
  ba:	687b      	ldr	r3, [r7, #4]
  bc:	2b01      	cmp	r3, #1
  be:	d105      	bne.n	cc <fp_exptmod+0xcc>
            err = fp_add(Y, P, Y);
  c0:	4642      	mov	r2, r8
  c2:	4639      	mov	r1, r7
  c4:	4640      	mov	r0, r8
  c6:	f7ff fffe 	bl	0 <fp_exptmod>
  ca:	4606      	mov	r6, r0
      XFREE(tmp, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  cc:	4620      	mov	r0, r4
  ce:	f7ff fffe 	bl	0 <free>
      return err;
  d2:	e7b2      	b.n	3a <fp_exptmod+0x3a>
   else if (G->used == 1 && G->dp[0] == 2) {
  d4:	9b02      	ldr	r3, [sp, #8]
  d6:	2b01      	cmp	r3, #1
  d8:	f040 80c9 	bne.w	26e <fp_exptmod+0x26e>
  dc:	68ab      	ldr	r3, [r5, #8]
  de:	2b02      	cmp	r3, #2
  e0:	f040 80c5 	bne.w	26e <fp_exptmod+0x26e>
  res = (fp_int*)XMALLOC(2*sizeof(fp_int), NULL, DYNAMIC_TYPE_TMP_BUFFER);
  e4:	20d0      	movs	r0, #208	; 0xd0
  e6:	f7ff fffe 	bl	0 <malloc>
  if (res == NULL) {
  ea:	4605      	mov	r5, r0
  ec:	2800      	cmp	r0, #0
  ee:	f000 80bb 	beq.w	268 <fp_exptmod+0x268>
  if ((err = fp_montgomery_setup(P, &mp)) != FP_OKAY) {
  f2:	a905      	add	r1, sp, #20
  f4:	4638      	mov	r0, r7
  f6:	f7ff fffe 	bl	0 <fp_exptmod>
  fa:	4604      	mov	r4, r0
  fc:	b118      	cbz	r0, 106 <fp_exptmod+0x106>
  XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  fe:	4628      	mov	r0, r5
 100:	f7ff fffe 	bl	0 <free>
  return err;
 104:	e01b      	b.n	13e <fp_exptmod+0x13e>
  tmp = &res[1];
 106:	f105 0b68 	add.w	fp, r5, #104	; 0x68
    fp_zero(a);
 10a:	4628      	mov	r0, r5
 10c:	f7ff fffe 	bl	0 <fp_exptmod>
 110:	4658      	mov	r0, fp
 112:	f7ff fffe 	bl	0 <fp_exptmod>
  err = fp_mul_2d(P, 1 << WINSIZE, tmp);
 116:	465a      	mov	r2, fp
 118:	2108      	movs	r1, #8
 11a:	4638      	mov	r0, r7
 11c:	f7ff fffe 	bl	0 <fp_exptmod>
  if (err != FP_OKAY) {
 120:	4604      	mov	r4, r0
 122:	2800      	cmp	r0, #0
 124:	d1eb      	bne.n	fe <fp_exptmod+0xfe>
  err = fp_montgomery_calc_normalization(res, P);
 126:	4639      	mov	r1, r7
 128:	4628      	mov	r0, r5
 12a:	f7ff fffe 	bl	0 <fp_exptmod>
  if (err != FP_OKAY) {
 12e:	4603      	mov	r3, r0
 130:	b138      	cbz	r0, 142 <fp_exptmod+0x142>
          XFREE(res, NULL, DYNAMIC_TYPE_TMP_BUFFER);
 132:	4628      	mov	r0, r5
 134:	9302      	str	r3, [sp, #8]
 136:	f7ff fffe 	bl	0 <free>
        err = fp_montgomery_reduce(res, P, mp);
 13a:	9b02      	ldr	r3, [sp, #8]
 13c:	461c      	mov	r4, r3
      return _fp_exptmod_base_2(X, X->used, P, Y);
 13e:	4626      	mov	r6, r4
 140:	e77b      	b.n	3a <fp_exptmod+0x3a>
  digidx = digits - 1;
 142:	1e72      	subs	r2, r6, #1
  bitcpy = (digits * DIGIT_BIT) % WINSIZE;
 144:	ea4f 1a46 	mov.w	sl, r6, lsl #5
  digidx = digits - 1;
 148:	9203      	str	r2, [sp, #12]
  bitcpy = (digits * DIGIT_BIT) % WINSIZE;
 14a:	2203      	movs	r2, #3
 14c:	fb9a f2f2 	sdiv	r2, sl, r2
 150:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 154:	ebaa 0a02 	sub.w	sl, sl, r2
  if (bitcpy > 0) {
 158:	f1ba 0f00 	cmp.w	sl, #0
 15c:	dd77      	ble.n	24e <fp_exptmod+0x24e>
      buf    = X->dp[digidx--];
 15e:	1c72      	adds	r2, r6, #1
      bitcnt = (int)DIGIT_BIT - bitcpy;
 160:	f1ca 0120 	rsb	r1, sl, #32
      buf    = X->dp[digidx--];
 164:	f859 3022 	ldr.w	r3, [r9, r2, lsl #2]
 168:	9003      	str	r0, [sp, #12]
      err = fp_mul_2d(res, bitbuf, res);
 16a:	fa23 f101 	lsr.w	r1, r3, r1
 16e:	462a      	mov	r2, r5
 170:	4628      	mov	r0, r5
      buf    = X->dp[digidx--];
 172:	9302      	str	r3, [sp, #8]
      err = fp_mul_2d(res, bitbuf, res);
 174:	f7ff fffe 	bl	0 <fp_exptmod>
      if (err != FP_OKAY) {
 178:	9b03      	ldr	r3, [sp, #12]
 17a:	4604      	mov	r4, r0
 17c:	2800      	cmp	r0, #0
 17e:	d1be      	bne.n	fe <fp_exptmod+0xfe>
      err = fp_add(res, tmp, res);
 180:	462a      	mov	r2, r5
 182:	4659      	mov	r1, fp
 184:	4628      	mov	r0, r5
 186:	9303      	str	r3, [sp, #12]
 188:	f7ff fffe 	bl	0 <fp_exptmod>
      if (err != FP_OKAY) {
 18c:	9b03      	ldr	r3, [sp, #12]
 18e:	4604      	mov	r4, r0
 190:	2800      	cmp	r0, #0
 192:	d1b4      	bne.n	fe <fp_exptmod+0xfe>
      err = fp_mod(res, P, res);
 194:	462a      	mov	r2, r5
 196:	4639      	mov	r1, r7
 198:	4628      	mov	r0, r5
 19a:	9303      	str	r3, [sp, #12]
 19c:	f7ff fffe 	bl	0 <fp_exptmod>
      if (err != FP_OKAY) {
 1a0:	9b03      	ldr	r3, [sp, #12]
 1a2:	4604      	mov	r4, r0
 1a4:	2800      	cmp	r0, #0
 1a6:	d1aa      	bne.n	fe <fp_exptmod+0xfe>
      buf    = X->dp[digidx--];
 1a8:	1eb2      	subs	r2, r6, #2
 1aa:	9203      	str	r2, [sp, #12]
      buf  <<= bitcpy;
 1ac:	9a02      	ldr	r2, [sp, #8]
 1ae:	fa02 f60a 	lsl.w	r6, r2, sl
      bitcnt++;
 1b2:	f1ca 0221 	rsb	r2, sl, #33	; 0x21
 1b6:	9202      	str	r2, [sp, #8]
      bitcpy = 0;
 1b8:	2400      	movs	r4, #0
    if (--bitcnt == 0) {
 1ba:	9a02      	ldr	r2, [sp, #8]
 1bc:	3a01      	subs	r2, #1
 1be:	9202      	str	r2, [sp, #8]
 1c0:	d10a      	bne.n	1d8 <fp_exptmod+0x1d8>
      if (digidx == -1) {
 1c2:	9a03      	ldr	r2, [sp, #12]
 1c4:	1c51      	adds	r1, r2, #1
 1c6:	d044      	beq.n	252 <fp_exptmod+0x252>
      buf    = X->dp[digidx--];
 1c8:	3202      	adds	r2, #2
 1ca:	f859 6022 	ldr.w	r6, [r9, r2, lsl #2]
 1ce:	9a03      	ldr	r2, [sp, #12]
 1d0:	3a01      	subs	r2, #1
 1d2:	9203      	str	r2, [sp, #12]
      bitcnt = (int)DIGIT_BIT;
 1d4:	2220      	movs	r2, #32
 1d6:	9202      	str	r2, [sp, #8]
    bitbuf |= (y << (WINSIZE - ++bitcpy));
 1d8:	3301      	adds	r3, #1
    y       = (int)(buf >> (DIGIT_BIT - 1)) & 1;
 1da:	0ff2      	lsrs	r2, r6, #31
    bitbuf |= (y << (WINSIZE - ++bitcpy));
 1dc:	f1c3 0103 	rsb	r1, r3, #3
 1e0:	408a      	lsls	r2, r1
    if (bitcpy == WINSIZE) {
 1e2:	2b03      	cmp	r3, #3
    bitbuf |= (y << (WINSIZE - ++bitcpy));
 1e4:	ea4f 0646 	mov.w	r6, r6, lsl #1
 1e8:	ea44 0402 	orr.w	r4, r4, r2
    if (bitcpy == WINSIZE) {
 1ec:	d1e5      	bne.n	1ba <fp_exptmod+0x1ba>
 1ee:	469a      	mov	sl, r3
        err = fp_sqr(res, res);
 1f0:	4629      	mov	r1, r5
 1f2:	4628      	mov	r0, r5
 1f4:	f7ff fffe 	bl	0 <fp_exptmod>
        if (err != FP_OKAY) {
 1f8:	4603      	mov	r3, r0
 1fa:	2800      	cmp	r0, #0
 1fc:	d199      	bne.n	132 <fp_exptmod+0x132>
        err = fp_montgomery_reduce(res, P, mp);
 1fe:	9a05      	ldr	r2, [sp, #20]
 200:	4639      	mov	r1, r7
 202:	4628      	mov	r0, r5
 204:	f7ff fffe 	bl	0 <fp_exptmod>
        if (err != FP_OKAY) {
 208:	4603      	mov	r3, r0
 20a:	2800      	cmp	r0, #0
 20c:	d191      	bne.n	132 <fp_exptmod+0x132>
      for (x = 0; x < WINSIZE; x++) {
 20e:	f1ba 0a01 	subs.w	sl, sl, #1
 212:	d1ed      	bne.n	1f0 <fp_exptmod+0x1f0>
      err = fp_mul_2d(res, bitbuf, res);
 214:	4621      	mov	r1, r4
 216:	462a      	mov	r2, r5
 218:	4628      	mov	r0, r5
 21a:	f7ff fffe 	bl	0 <fp_exptmod>
      if (err != FP_OKAY) {
 21e:	4604      	mov	r4, r0
 220:	2800      	cmp	r0, #0
 222:	f47f af6c 	bne.w	fe <fp_exptmod+0xfe>
      err = fp_add(res, tmp, res);
 226:	462a      	mov	r2, r5
 228:	4659      	mov	r1, fp
 22a:	4628      	mov	r0, r5
 22c:	f7ff fffe 	bl	0 <fp_exptmod>
      if (err != FP_OKAY) {
 230:	4604      	mov	r4, r0
 232:	2800      	cmp	r0, #0
 234:	f47f af63 	bne.w	fe <fp_exptmod+0xfe>
      err = fp_mod(res, P, res);
 238:	462a      	mov	r2, r5
 23a:	4639      	mov	r1, r7
 23c:	4628      	mov	r0, r5
 23e:	f7ff fffe 	bl	0 <fp_exptmod>
      if (err != FP_OKAY) {
 242:	4604      	mov	r4, r0
 244:	2800      	cmp	r0, #0
 246:	f47f af5a 	bne.w	fe <fp_exptmod+0xfe>
      bitcpy = 0;
 24a:	4623      	mov	r3, r4
 24c:	e7b5      	b.n	1ba <fp_exptmod+0x1ba>
      buf    = 0;
 24e:	2600      	movs	r6, #0
 250:	e7b2      	b.n	1b8 <fp_exptmod+0x1b8>
  err = fp_montgomery_reduce(res, P, mp);
 252:	4639      	mov	r1, r7
 254:	9a05      	ldr	r2, [sp, #20]
 256:	4628      	mov	r0, r5
 258:	f7ff fffe 	bl	0 <fp_exptmod>
  fp_copy(res, Y);
 25c:	4641      	mov	r1, r8
  err = fp_montgomery_reduce(res, P, mp);
 25e:	4604      	mov	r4, r0
  fp_copy(res, Y);
 260:	4628      	mov	r0, r5
 262:	f7ff fffe 	bl	0 <fp_exptmod>
 266:	e74a      	b.n	fe <fp_exptmod+0xfe>
     return FP_MEM;
 268:	f06f 0401 	mvn.w	r4, #1
 26c:	e767      	b.n	13e <fp_exptmod+0x13e>
      return _fp_exptmod_ct(G, X, X->used, P, Y);
 26e:	4632      	mov	r2, r6
 270:	f8cd 8000 	str.w	r8, [sp]
 274:	463b      	mov	r3, r7
 276:	4649      	mov	r1, r9
 278:	4628      	mov	r0, r5
 27a:	f7ff fffe 	bl	0 <fp_exptmod>
 27e:	4606      	mov	r6, r0
 280:	e6db      	b.n	3a <fp_exptmod+0x3a>
      return FP_VAL;
 282:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 286:	e6d8      	b.n	3a <fp_exptmod+0x3a>
          return FP_MEM;
 288:	f06f 0601 	mvn.w	r6, #1
 28c:	e6d5      	b.n	3a <fp_exptmod+0x3a>

Disassembly of section .text.mp_exptmod:

00000000 <mp_exptmod>:
  return fp_exptmod(G, X, P, Y);
   0:	f7ff bffe 	b.w	0 <mp_exptmod>

Disassembly of section .text.fp_exptmod_ex:

00000000 <fp_exptmod_ex>:
{
   0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   4:	461d      	mov	r5, r3
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
   6:	681b      	ldr	r3, [r3, #0]
{
   8:	9e0c      	ldr	r6, [sp, #48]	; 0x30
   a:	4683      	mov	fp, r0
   c:	460f      	mov	r7, r1
   e:	4692      	mov	sl, r2
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
  10:	2b00      	cmp	r3, #0
  12:	d061      	beq.n	d8 <fp_exptmod_ex+0xd8>
  14:	2b0c      	cmp	r3, #12
  16:	dc5f      	bgt.n	d8 <fp_exptmod_ex+0xd8>
   if (fp_isone(P)) {
  18:	2b01      	cmp	r3, #1
  1a:	d10e      	bne.n	3a <fp_exptmod_ex+0x3a>
  1c:	68ab      	ldr	r3, [r5, #8]
  1e:	2b01      	cmp	r3, #1
  20:	d10b      	bne.n	3a <fp_exptmod_ex+0x3a>
  22:	686b      	ldr	r3, [r5, #4]
  24:	b94b      	cbnz	r3, 3a <fp_exptmod_ex+0x3a>
   a->dp[0] = b;
  26:	2400      	movs	r4, #0
   fp_zero(a);
  28:	4630      	mov	r0, r6
  2a:	f7ff fffe 	bl	0 <fp_exptmod_ex>
   a->dp[0] = b;
  2e:	60b4      	str	r4, [r6, #8]
   a->used  = a->dp[0] ? 1 : 0;
  30:	6034      	str	r4, [r6, #0]
}
  32:	4620      	mov	r0, r4
  34:	b003      	add	sp, #12
  36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   if (fp_iszero(X)) {
  3a:	683c      	ldr	r4, [r7, #0]
  3c:	b934      	cbnz	r4, 4c <fp_exptmod_ex+0x4c>
   fp_zero(a);
  3e:	4630      	mov	r0, r6
  40:	f7ff fffe 	bl	0 <fp_exptmod_ex>
   a->dp[0] = b;
  44:	2301      	movs	r3, #1
  46:	60b3      	str	r3, [r6, #8]
   a->used  = a->dp[0] ? 1 : 0;
  48:	6033      	str	r3, [r6, #0]
      return FP_OKAY;
  4a:	e7f2      	b.n	32 <fp_exptmod_ex+0x32>
   if (fp_iszero(G)) {
  4c:	f8db 3000 	ldr.w	r3, [fp]
  50:	2b00      	cmp	r3, #0
  52:	d0e8      	beq.n	26 <fp_exptmod_ex+0x26>
   if (X->sign == FP_NEG) {
  54:	f8d7 9004 	ldr.w	r9, [r7, #4]
  58:	f1b9 0f01 	cmp.w	r9, #1
  5c:	d132      	bne.n	c4 <fp_exptmod_ex+0xc4>
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  5e:	20d0      	movs	r0, #208	; 0xd0
  60:	f7ff fffe 	bl	0 <malloc>
      if (tmp == NULL)
  64:	4680      	mov	r8, r0
  66:	b3d0      	cbz	r0, de <fp_exptmod_ex+0xde>
      fp_init_copy(&tmp[1], P);
  68:	f108 0468 	add.w	r4, r8, #104	; 0x68
      fp_init_copy(&tmp[0], G);
  6c:	4659      	mov	r1, fp
  6e:	f7ff fffe 	bl	0 <fp_exptmod_ex>
      fp_init_copy(&tmp[1], P);
  72:	4620      	mov	r0, r4
  74:	4629      	mov	r1, r5
  76:	f7ff fffe 	bl	0 <fp_exptmod_ex>
      tmp[1].sign = FP_ZPOS;
  7a:	2300      	movs	r3, #0
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
  7c:	4621      	mov	r1, r4
      tmp[1].sign = FP_ZPOS;
  7e:	f8c8 306c 	str.w	r3, [r8, #108]	; 0x6c
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
  82:	4642      	mov	r2, r8
  84:	4640      	mov	r0, r8
  86:	f7ff fffe 	bl	0 <fp_exptmod_ex>
      if (err == FP_OKAY) {
  8a:	4604      	mov	r4, r0
  8c:	b9b0      	cbnz	r0, bc <fp_exptmod_ex+0xbc>
         X->sign = FP_ZPOS;
  8e:	6078      	str	r0, [r7, #4]
         err =  _fp_exptmod_ct(&tmp[0], X, digits, P, Y);
  90:	9600      	str	r6, [sp, #0]
  92:	462b      	mov	r3, r5
  94:	4652      	mov	r2, sl
  96:	4639      	mov	r1, r7
  98:	4640      	mov	r0, r8
  9a:	f7ff fffe 	bl	0 <fp_exptmod_ex>
         if (X != Y) {
  9e:	42be      	cmp	r6, r7
         err =  _fp_exptmod_ct(&tmp[0], X, digits, P, Y);
  a0:	4604      	mov	r4, r0
            X->sign = FP_NEG;
  a2:	bf18      	it	ne
  a4:	f8c7 9004 	strne.w	r9, [r7, #4]
         if ((err == 0) && (P->sign == FP_NEG)) {
  a8:	b940      	cbnz	r0, bc <fp_exptmod_ex+0xbc>
  aa:	686b      	ldr	r3, [r5, #4]
  ac:	2b01      	cmp	r3, #1
  ae:	d105      	bne.n	bc <fp_exptmod_ex+0xbc>
            err = fp_add(Y, P, Y);
  b0:	4632      	mov	r2, r6
  b2:	4629      	mov	r1, r5
  b4:	4630      	mov	r0, r6
  b6:	f7ff fffe 	bl	0 <fp_exptmod_ex>
  ba:	4604      	mov	r4, r0
      XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
  bc:	4640      	mov	r0, r8
  be:	f7ff fffe 	bl	0 <free>
      return err;
  c2:	e7b6      	b.n	32 <fp_exptmod_ex+0x32>
      return _fp_exptmod_ct(G, X, digits, P, Y);
  c4:	462b      	mov	r3, r5
  c6:	4652      	mov	r2, sl
  c8:	4639      	mov	r1, r7
  ca:	4658      	mov	r0, fp
  cc:	960c      	str	r6, [sp, #48]	; 0x30
}
  ce:	b003      	add	sp, #12
  d0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      return _fp_exptmod_ct(G, X, digits, P, Y);
  d4:	f7ff bffe 	b.w	0 <fp_exptmod_ex>
      return FP_VAL;
  d8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  dc:	e7a9      	b.n	32 <fp_exptmod_ex+0x32>
          return FP_MEM;
  de:	f06f 0401 	mvn.w	r4, #1
  e2:	e7a6      	b.n	32 <fp_exptmod_ex+0x32>

Disassembly of section .text.mp_exptmod_ex:

00000000 <mp_exptmod_ex>:
  return fp_exptmod_ex(G, X, digits, P, Y);
   0:	f7ff bffe 	b.w	0 <mp_exptmod_ex>

Disassembly of section .text.fp_exptmod_nct:

00000000 <fp_exptmod_nct>:
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   4:	461d      	mov	r5, r3
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
   6:	6813      	ldr	r3, [r2, #0]
{
   8:	4682      	mov	sl, r0
   a:	460f      	mov	r7, r1
   c:	4616      	mov	r6, r2
   if (fp_iszero(P) || (P->used > (FP_SIZE/2))) {
   e:	2b00      	cmp	r3, #0
  10:	d05d      	beq.n	ce <fp_exptmod_nct+0xce>
  12:	2b0c      	cmp	r3, #12
  14:	dc5b      	bgt.n	ce <fp_exptmod_nct+0xce>
   if (fp_isone(P)) {
  16:	2b01      	cmp	r3, #1
  18:	d10d      	bne.n	36 <fp_exptmod_nct+0x36>
  1a:	6893      	ldr	r3, [r2, #8]
  1c:	2b01      	cmp	r3, #1
  1e:	d10a      	bne.n	36 <fp_exptmod_nct+0x36>
  20:	6853      	ldr	r3, [r2, #4]
  22:	b943      	cbnz	r3, 36 <fp_exptmod_nct+0x36>
   a->dp[0] = b;
  24:	2400      	movs	r4, #0
   fp_zero(a);
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <fp_exptmod_nct>
   a->dp[0] = b;
  2c:	60ac      	str	r4, [r5, #8]
   a->used  = a->dp[0] ? 1 : 0;
  2e:	602c      	str	r4, [r5, #0]
}
  30:	4620      	mov	r0, r4
  32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   if (fp_iszero(X)) {
  36:	683c      	ldr	r4, [r7, #0]
  38:	b934      	cbnz	r4, 48 <fp_exptmod_nct+0x48>
   fp_zero(a);
  3a:	4628      	mov	r0, r5
  3c:	f7ff fffe 	bl	0 <fp_exptmod_nct>
   a->dp[0] = b;
  40:	2301      	movs	r3, #1
  42:	60ab      	str	r3, [r5, #8]
   a->used  = a->dp[0] ? 1 : 0;
  44:	602b      	str	r3, [r5, #0]
      return FP_OKAY;
  46:	e7f3      	b.n	30 <fp_exptmod_nct+0x30>
   if (fp_iszero(G)) {
  48:	f8da 3000 	ldr.w	r3, [sl]
  4c:	2b00      	cmp	r3, #0
  4e:	d0e9      	beq.n	24 <fp_exptmod_nct+0x24>
   if (X->sign == FP_NEG) {
  50:	f8d7 9004 	ldr.w	r9, [r7, #4]
  54:	f1b9 0f01 	cmp.w	r9, #1
  58:	d131      	bne.n	be <fp_exptmod_nct+0xbe>
      tmp = (fp_int*)XMALLOC(sizeof(fp_int) * 2, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  5a:	20d0      	movs	r0, #208	; 0xd0
  5c:	f7ff fffe 	bl	0 <malloc>
      if (tmp == NULL)
  60:	4680      	mov	r8, r0
  62:	b3b8      	cbz	r0, d4 <fp_exptmod_nct+0xd4>
      fp_init_copy(&tmp[1], P);
  64:	f108 0468 	add.w	r4, r8, #104	; 0x68
      fp_init_copy(&tmp[0], G);
  68:	4651      	mov	r1, sl
  6a:	f7ff fffe 	bl	0 <fp_exptmod_nct>
      fp_init_copy(&tmp[1], P);
  6e:	4620      	mov	r0, r4
  70:	4631      	mov	r1, r6
  72:	f7ff fffe 	bl	0 <fp_exptmod_nct>
      tmp[1].sign = FP_ZPOS;
  76:	2300      	movs	r3, #0
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
  78:	4621      	mov	r1, r4
      tmp[1].sign = FP_ZPOS;
  7a:	f8c8 306c 	str.w	r3, [r8, #108]	; 0x6c
      err = fp_invmod(&tmp[0], &tmp[1], &tmp[0]);
  7e:	4642      	mov	r2, r8
  80:	4640      	mov	r0, r8
  82:	f7ff fffe 	bl	0 <fp_exptmod_nct>
      if (err == FP_OKAY) {
  86:	4604      	mov	r4, r0
  88:	b9a8      	cbnz	r0, b6 <fp_exptmod_nct+0xb6>
         X->sign = FP_ZPOS;
  8a:	6078      	str	r0, [r7, #4]
         err =  _fp_exptmod_nct(&tmp[0], X, P, Y);
  8c:	462b      	mov	r3, r5
  8e:	4632      	mov	r2, r6
  90:	4639      	mov	r1, r7
  92:	4640      	mov	r0, r8
  94:	f7ff fffe 	bl	0 <fp_exptmod_nct>
         if (X != Y) {
  98:	42bd      	cmp	r5, r7
         err =  _fp_exptmod_nct(&tmp[0], X, P, Y);
  9a:	4604      	mov	r4, r0
            X->sign = FP_NEG;
  9c:	bf18      	it	ne
  9e:	f8c7 9004 	strne.w	r9, [r7, #4]
         if ((err == 0) && (P->sign == FP_NEG)) {
  a2:	b940      	cbnz	r0, b6 <fp_exptmod_nct+0xb6>
  a4:	6873      	ldr	r3, [r6, #4]
  a6:	2b01      	cmp	r3, #1
  a8:	d105      	bne.n	b6 <fp_exptmod_nct+0xb6>
            err = fp_add(Y, P, Y);
  aa:	462a      	mov	r2, r5
  ac:	4631      	mov	r1, r6
  ae:	4628      	mov	r0, r5
  b0:	f7ff fffe 	bl	0 <fp_exptmod_nct>
  b4:	4604      	mov	r4, r0
      XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
  b6:	4640      	mov	r0, r8
  b8:	f7ff fffe 	bl	0 <free>
      return err;
  bc:	e7b8      	b.n	30 <fp_exptmod_nct+0x30>
      return  _fp_exptmod_nct(G, X, P, Y);
  be:	462b      	mov	r3, r5
  c0:	4632      	mov	r2, r6
  c2:	4639      	mov	r1, r7
  c4:	4650      	mov	r0, sl
}
  c6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
      return  _fp_exptmod_nct(G, X, P, Y);
  ca:	f7ff bffe 	b.w	0 <fp_exptmod_nct>
      return FP_VAL;
  ce:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  d2:	e7ad      	b.n	30 <fp_exptmod_nct+0x30>
          return FP_MEM;
  d4:	f06f 0401 	mvn.w	r4, #1
  d8:	e7aa      	b.n	30 <fp_exptmod_nct+0x30>

Disassembly of section .text.mp_exptmod_nct:

00000000 <mp_exptmod_nct>:
  return fp_exptmod_nct(G, X, P, Y);
   0:	f7ff bffe 	b.w	0 <mp_exptmod_nct>

Disassembly of section .text.fp_to_unsigned_bin:

00000000 <fp_to_unsigned_bin>:
{
   0:	b570      	push	{r4, r5, r6, lr}
   2:	4606      	mov	r6, r0
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   4:	2068      	movs	r0, #104	; 0x68
{
   6:	460d      	mov	r5, r1
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   8:	f7ff fffe 	bl	0 <malloc>
   if (t == NULL)
   c:	4604      	mov	r4, r0
   e:	b180      	cbz	r0, 32 <fp_to_unsigned_bin+0x32>
  fp_init_copy(t, a);
  10:	4631      	mov	r1, r6
  12:	f7ff fffe 	bl	0 <fp_to_unsigned_bin>
  x = fp_to_unsigned_bin_at_pos(0, t, b);
  16:	462a      	mov	r2, r5
  18:	4621      	mov	r1, r4
  1a:	2000      	movs	r0, #0
  1c:	f7ff fffe 	bl	0 <fp_to_unsigned_bin>
  20:	4601      	mov	r1, r0
  mp_reverse (b, x);
  22:	4628      	mov	r0, r5
  24:	f7ff fffe 	bl	0 <mp_reverse>
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  28:	4620      	mov	r0, r4
  2a:	f7ff fffe 	bl	0 <free>
  return FP_OKAY;
  2e:	2000      	movs	r0, #0
}
  30:	bd70      	pop	{r4, r5, r6, pc}
       return FP_MEM;
  32:	f06f 0001 	mvn.w	r0, #1
  36:	e7fb      	b.n	30 <fp_to_unsigned_bin+0x30>

Disassembly of section .text.mp_to_unsigned_bin:

00000000 <mp_to_unsigned_bin>:
  return fp_to_unsigned_bin(a,b);
   0:	f7ff bffe 	b.w	0 <mp_to_unsigned_bin>

Disassembly of section .text.mp_init_copy:

00000000 <mp_init_copy>:
{
   0:	b508      	push	{r3, lr}
    fp_init_copy(a, b);
   2:	f7ff fffe 	bl	0 <mp_init_copy>
}
   6:	2000      	movs	r0, #0
   8:	bd08      	pop	{r3, pc}

Disassembly of section .text.mp_copy:

00000000 <mp_copy>:
{
   0:	b508      	push	{r3, lr}
    fp_copy(a, b);
   2:	f7ff fffe 	bl	0 <mp_copy>
}
   6:	2000      	movs	r0, #0
   8:	bd08      	pop	{r3, pc}

Disassembly of section .text.mp_isodd:

00000000 <mp_isodd>:
    return fp_isodd(a);
   0:	6803      	ldr	r3, [r0, #0]
   2:	2b00      	cmp	r3, #0
   4:	bfc6      	itte	gt
   6:	6880      	ldrgt	r0, [r0, #8]
   8:	f000 0001 	andgt.w	r0, r0, #1
   c:	2000      	movle	r0, #0
}
   e:	4770      	bx	lr

Disassembly of section .text.mp_iszero:

00000000 <mp_iszero>:
    return fp_iszero(a);
   0:	6800      	ldr	r0, [r0, #0]
}
   2:	fab0 f080 	clz	r0, r0
   6:	0940      	lsrs	r0, r0, #5
   8:	4770      	bx	lr

Disassembly of section .text.mp_count_bits:

00000000 <mp_count_bits>:
    return fp_count_bits(a);
   0:	f7ff bffe 	b.w	0 <mp_count_bits>

Disassembly of section .text.mp_leading_bit:

00000000 <mp_leading_bit>:
    return fp_leading_bit(a);
   0:	f7ff bffe 	b.w	0 <mp_leading_bit>

Disassembly of section .text.mp_rshb:

00000000 <mp_rshb>:
    fp_rshb(a, x);
   0:	f7ff bffe 	b.w	0 <mp_rshb>

Disassembly of section .text.mp_rshd:

00000000 <mp_rshd>:
    fp_rshd(a, x);
   0:	f7ff bffe 	b.w	0 <mp_rshd>

Disassembly of section .text.mp_set_int:

00000000 <mp_set_int>:
    return fp_set_int(a, b);
   0:	f7ff bffe 	b.w	0 <mp_set_int>

Disassembly of section .text.mp_is_bit_set:

00000000 <mp_is_bit_set>:
    return fp_is_bit_set(a, b);
   0:	f7ff bffe 	b.w	0 <mp_is_bit_set>

Disassembly of section .text.mp_set_bit:

00000000 <mp_set_bit>:
    return fp_set_bit(a, b);
   0:	f7ff bffe 	b.w	0 <mp_set_bit>

Disassembly of section .text.fp_sqrmod:

00000000 <fp_sqrmod>:
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4604      	mov	r4, r0
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   4:	2068      	movs	r0, #104	; 0x68
{
   6:	460e      	mov	r6, r1
   8:	4617      	mov	r7, r2
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   a:	f7ff fffe 	bl	0 <malloc>
   e:	4605      	mov	r5, r0
   if (t == NULL)
  10:	b190      	cbz	r0, 38 <fp_sqrmod+0x38>
    fp_zero(a);
  12:	f7ff fffe 	bl	0 <fp_sqrmod>
  err = fp_sqr(a, t);
  16:	4620      	mov	r0, r4
  18:	4629      	mov	r1, r5
  1a:	f7ff fffe 	bl	0 <fp_sqrmod>
  if (err == FP_OKAY) {
  1e:	4604      	mov	r4, r0
  20:	b928      	cbnz	r0, 2e <fp_sqrmod+0x2e>
      err = fp_mod(t, b, c);
  22:	463a      	mov	r2, r7
  24:	4631      	mov	r1, r6
  26:	4628      	mov	r0, r5
  28:	f7ff fffe 	bl	0 <fp_sqrmod>
  2c:	4604      	mov	r4, r0
  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  2e:	4628      	mov	r0, r5
  30:	f7ff fffe 	bl	0 <free>
}
  34:	4620      	mov	r0, r4
  36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       return FP_MEM;
  38:	f06f 0401 	mvn.w	r4, #1
  3c:	e7fa      	b.n	34 <fp_sqrmod+0x34>

Disassembly of section .text.mp_sqrmod:

00000000 <mp_sqrmod>:
    return fp_sqrmod(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_sqrmod>

Disassembly of section .text.mp_montgomery_calc_normalization:

00000000 <mp_montgomery_calc_normalization>:
    return fp_montgomery_calc_normalization(a, b);
   0:	f7ff bffe 	b.w	0 <mp_montgomery_calc_normalization>

Disassembly of section .text.fp_cnt_lsb:

00000000 <fp_cnt_lsb>:
{
   0:	4603      	mov	r3, r0
   if (fp_iszero(a) == FP_YES) {
   2:	6800      	ldr	r0, [r0, #0]
{
   4:	b510      	push	{r4, lr}
   if (fp_iszero(a) == FP_YES) {
   6:	b198      	cbz	r0, 30 <fp_cnt_lsb+0x30>
   8:	3308      	adds	r3, #8
   for (x = 0; x < a->used && a->dp[x] == 0; x++) {}
   a:	2100      	movs	r1, #0
   c:	4288      	cmp	r0, r1
   e:	f853 2b04 	ldr.w	r2, [r3], #4
  12:	dd00      	ble.n	16 <fp_cnt_lsb+0x16>
  14:	b16a      	cbz	r2, 32 <fp_cnt_lsb+0x32>
   if ((q & 1) == 0) {
  16:	07d3      	lsls	r3, r2, #31
   x *= DIGIT_BIT;
  18:	ea4f 1041 	mov.w	r0, r1, lsl #5
   if ((q & 1) == 0) {
  1c:	d408      	bmi.n	30 <fp_cnt_lsb+0x30>
         x  += lnz[qq];
  1e:	4c06      	ldr	r4, [pc, #24]	; (38 <fp_cnt_lsb+0x38>)
         qq  = q & 15;
  20:	f002 030f 	and.w	r3, r2, #15
         q >>= 4;
  24:	0912      	lsrs	r2, r2, #4
         x  += lnz[qq];
  26:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
  2a:	4408      	add	r0, r1
      } while (qq == 0);
  2c:	2b00      	cmp	r3, #0
  2e:	d0f7      	beq.n	20 <fp_cnt_lsb+0x20>
}
  30:	bd10      	pop	{r4, pc}
   for (x = 0; x < a->used && a->dp[x] == 0; x++) {}
  32:	3101      	adds	r1, #1
  34:	e7ea      	b.n	c <fp_cnt_lsb+0xc>
  36:	bf00      	nop
  38:	00000000 	.word	0x00000000

Disassembly of section .text.mp_mod_d:

00000000 <mp_mod_d>:
{
   return fp_div_d(a, b, NULL, c);
}

int mp_mod_d(fp_int *a, fp_digit b, fp_digit *c)
{
   0:	4613      	mov	r3, r2
   return fp_div_d(a, b, NULL, c);
   2:	2200      	movs	r2, #0
   4:	f7ff bffe 	b.w	0 <mp_mod_d>

Disassembly of section .text.mp_cond_swap_ct_ex:

00000000 <mp_cond_swap_ct_ex>:
#endif /* !NO_RSA || !NO_DSA || !NO_DH || WOLFSSL_KEY_GEN */


int mp_cond_swap_ct_ex(mp_int* a, mp_int* b, int c, int m, mp_int* t)
{
    return fp_cond_swap_ct_ex(a, b, c, m, t);
   0:	f7ff bffe 	b.w	0 <mp_cond_swap_ct_ex>

Disassembly of section .text.mp_cond_swap_ct:

00000000 <mp_cond_swap_ct>:
}

int mp_cond_swap_ct(mp_int* a, mp_int* b, int c, int m)
{
   0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
   4:	4605      	mov	r5, r0
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   6:	2068      	movs	r0, #104	; 0x68
{
   8:	460e      	mov	r6, r1
   a:	4617      	mov	r7, r2
   c:	4698      	mov	r8, r3
   t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   e:	f7ff fffe 	bl	0 <malloc>
   if (t == NULL)
  12:	4604      	mov	r4, r0
  14:	b168      	cbz	r0, 32 <mp_cond_swap_ct+0x32>
   fp_cond_swap_ct_ex(a, b, c, m, t);
  16:	9000      	str	r0, [sp, #0]
  18:	4643      	mov	r3, r8
  1a:	463a      	mov	r2, r7
  1c:	4631      	mov	r1, r6
  1e:	4628      	mov	r0, r5
  20:	f7ff fffe 	bl	0 <mp_cond_swap_ct>
    XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  24:	4620      	mov	r0, r4
  26:	f7ff fffe 	bl	0 <free>
    return FP_OKAY;
  2a:	2000      	movs	r0, #0
    return fp_cond_swap_ct(a, b, c, m);
}
  2c:	b002      	add	sp, #8
  2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       return FP_MEM;
  32:	f06f 0001 	mvn.w	r0, #1
    return fp_cond_swap_ct(a, b, c, m);
  36:	e7f9      	b.n	2c <mp_cond_swap_ct+0x2c>

Disassembly of section .text.fp_add_d:

00000000 <fp_add_d>:
#if defined(HAVE_ECC) || !defined(NO_PWDBASED) || defined(OPENSSL_EXTRA) || \
    defined(WC_RSA_BLINDING) || !defined(NO_DSA) || \
    (!defined(NO_RSA) && !defined(NO_RSA_BOUNDS_CHECK))
/* c = a + b */
int fp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4605      	mov	r5, r0
   fp_int* tmp;
#endif
   int     err;

#ifdef WOLFSSL_SMALL_STACK
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   4:	2068      	movs	r0, #104	; 0x68
{
   6:	460f      	mov	r7, r1
   8:	4616      	mov	r6, r2
   tmp = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
   a:	f7ff fffe 	bl	0 <malloc>
   e:	4604      	mov	r4, r0
   if (tmp == NULL)
  10:	b180      	cbz	r0, 34 <fp_add_d+0x34>
    fp_zero(a);
  12:	f7ff fffe 	bl	0 <fp_add_d>
       return FP_MEM;
#endif

   fp_init(tmp);
   fp_set(tmp, b);
  16:	4639      	mov	r1, r7
  18:	4620      	mov	r0, r4
  1a:	f7ff fffe 	bl	0 <fp_add_d>
   err = fp_add(a, tmp, c);
  1e:	4628      	mov	r0, r5
  20:	4632      	mov	r2, r6
  22:	4621      	mov	r1, r4
  24:	f7ff fffe 	bl	0 <fp_add_d>
  28:	4605      	mov	r5, r0

#ifdef WOLFSSL_SMALL_STACK
   XFREE(tmp, NULL, DYNAMIC_TYPE_BIGINT);
  2a:	4620      	mov	r0, r4
  2c:	f7ff fffe 	bl	0 <free>
#endif
   return err;
}
  30:	4628      	mov	r0, r5
  32:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       return FP_MEM;
  34:	f06f 0501 	mvn.w	r5, #1
  38:	e7fa      	b.n	30 <fp_add_d+0x30>

Disassembly of section .text.mp_add_d:

00000000 <mp_add_d>:

/* external compatibility */
int mp_add_d(fp_int *a, fp_digit b, fp_int *c)
{
    return fp_add_d(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_add_d>

Disassembly of section .text.mp_read_radix:

00000000 <mp_read_radix>:
  return FP_OKAY;
}

/* fast math conversion */
int mp_read_radix(mp_int *a, const char *str, int radix)
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	4690      	mov	r8, r2
   6:	4604      	mov	r4, r0
   8:	460d      	mov	r5, r1
  fp_zero (a);
   a:	f7ff fffe 	bl	0 <mp_read_radix>
  if (radix == 16)
   e:	f1b8 0f10 	cmp.w	r8, #16
  12:	d146      	bne.n	a2 <mp_read_radix+0xa2>
  if (*str == '-') {
  14:	782b      	ldrb	r3, [r5, #0]
  16:	2b2d      	cmp	r3, #45	; 0x2d
    ++str;
  18:	bf08      	it	eq
  1a:	3501      	addeq	r5, #1
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
  1c:	4628      	mov	r0, r5
    neg = FP_NEG;
  1e:	bf0c      	ite	eq
  20:	2601      	moveq	r6, #1
    neg = FP_ZPOS;
  22:	2600      	movne	r6, #0
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
  24:	f7ff fffe 	bl	0 <strlen>
  k = 0;
  28:	2200      	movs	r2, #0
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
  2a:	3801      	subs	r0, #1
  j = 0;
  2c:	4611      	mov	r1, r2
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
  2e:	2800      	cmp	r0, #0
  30:	da0d      	bge.n	4e <mp_read_radix+0x4e>
  a->used = k + 1;
  32:	3201      	adds	r2, #1
  fp_clamp(a);
  34:	6022      	str	r2, [r4, #0]
  36:	6823      	ldr	r3, [r4, #0]
  38:	2b00      	cmp	r3, #0
  3a:	d06f      	beq.n	11c <mp_read_radix+0x11c>
  3c:	1e5a      	subs	r2, r3, #1
  3e:	3301      	adds	r3, #1
  40:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
  44:	2b00      	cmp	r3, #0
  46:	d0f5      	beq.n	34 <mp_read_radix+0x34>
     a->sign = neg;
  48:	6066      	str	r6, [r4, #4]
  return FP_OKAY;
  4a:	2000      	movs	r0, #0
  4c:	e025      	b.n	9a <mp_read_radix+0x9a>
      ch = (int)HexCharToByte(str[i]);
  4e:	5c2b      	ldrb	r3, [r5, r0]
#endif

WC_MISC_STATIC WC_INLINE signed char HexCharToByte(char ch)
{
    signed char ret = (signed char)ch;
    if (ret >= '0' && ret <= '9')
  50:	f1a3 0730 	sub.w	r7, r3, #48	; 0x30
  54:	b2ff      	uxtb	r7, r7
  56:	2f09      	cmp	r7, #9
  58:	d812      	bhi.n	80 <mp_read_radix+0x80>
        ret -= '0';
  5a:	b27b      	sxtb	r3, r7
      k += j == DIGIT_BIT;
  5c:	2920      	cmp	r1, #32
  5e:	bf08      	it	eq
  60:	3201      	addeq	r2, #1
      if (k >= FP_SIZE)
  62:	2a17      	cmp	r2, #23
      j &= DIGIT_BIT - 1;
  64:	f001 011f 	and.w	r1, r1, #31
      if (k >= FP_SIZE)
  68:	dc15      	bgt.n	96 <mp_read_radix+0x96>
      a->dp[k] |= ((fp_digit)ch) << j;
  6a:	eb04 0c82 	add.w	ip, r4, r2, lsl #2
  6e:	408b      	lsls	r3, r1
  70:	f8dc 7008 	ldr.w	r7, [ip, #8]
  74:	433b      	orrs	r3, r7
  76:	f8cc 3008 	str.w	r3, [ip, #8]
      j += 4;
  7a:	3104      	adds	r1, #4
  for (i = (int)(XSTRLEN(str) - 1); i >= 0; i--) {
  7c:	3801      	subs	r0, #1
  7e:	e7d6      	b.n	2e <mp_read_radix+0x2e>
    else if (ret >= 'A' && ret <= 'F')
  80:	f1a3 0741 	sub.w	r7, r3, #65	; 0x41
  84:	2f05      	cmp	r7, #5
  86:	d802      	bhi.n	8e <mp_read_radix+0x8e>
        ret -= 'A' - 10;
  88:	3b37      	subs	r3, #55	; 0x37
    else if (ret >= 'a' && ret <= 'f')
        ret -= 'a' - 10;
  8a:	b25b      	sxtb	r3, r3
  8c:	e7e6      	b.n	5c <mp_read_radix+0x5c>
    else if (ret >= 'a' && ret <= 'f')
  8e:	f1a3 0761 	sub.w	r7, r3, #97	; 0x61
  92:	2f05      	cmp	r7, #5
  94:	d903      	bls.n	9e <mp_read_radix+0x9e>
        return FP_VAL;
  96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    return fp_read_radix(a, str, radix);
}
  9a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ret -= 'a' - 10;
  9e:	3b57      	subs	r3, #87	; 0x57
  a0:	e7f3      	b.n	8a <mp_read_radix+0x8a>
  if (radix < 2 || radix > 64) {
  a2:	f1a8 0302 	sub.w	r3, r8, #2
  a6:	2b3e      	cmp	r3, #62	; 0x3e
  a8:	d8f5      	bhi.n	96 <mp_read_radix+0x96>
  if (*str == '-') {
  aa:	782b      	ldrb	r3, [r5, #0]
  ac:	2b2d      	cmp	r3, #45	; 0x2d
  ae:	d133      	bne.n	118 <mp_read_radix+0x118>
    ++str;
  b0:	3501      	adds	r5, #1
    neg = FP_NEG;
  b2:	2601      	movs	r6, #1
    ch = (char)((radix <= 36) ? XTOUPPER((unsigned char)*str) : *str);
  b4:	4f1a      	ldr	r7, [pc, #104]	; (120 <mp_read_radix+0x120>)
  b6:	3d01      	subs	r5, #1
  b8:	e025      	b.n	106 <mp_read_radix+0x106>
  ba:	f1b8 0f24 	cmp.w	r8, #36	; 0x24
  be:	dc06      	bgt.n	ce <mp_read_radix+0xce>
  c0:	5c3b      	ldrb	r3, [r7, r0]
  c2:	f003 0303 	and.w	r3, r3, #3
  c6:	2b02      	cmp	r3, #2
  c8:	bf08      	it	eq
  ca:	3820      	subeq	r0, #32
  cc:	b2c0      	uxtb	r0, r0
    for (y = 0; y < 64; y++) {
  ce:	4b15      	ldr	r3, [pc, #84]	; (124 <mp_read_radix+0x124>)
  d0:	f04f 0900 	mov.w	r9, #0
      if (ch == fp_s_rmap[y]) {
  d4:	f813 2b01 	ldrb.w	r2, [r3], #1
  d8:	4282      	cmp	r2, r0
  da:	d005      	beq.n	e8 <mp_read_radix+0xe8>
    for (y = 0; y < 64; y++) {
  dc:	f109 0901 	add.w	r9, r9, #1
  e0:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
  e4:	d1f6      	bne.n	d4 <mp_read_radix+0xd4>
  e6:	e7d6      	b.n	96 <mp_read_radix+0x96>
    if (y >= radix) {
  e8:	45c8      	cmp	r8, r9
  ea:	ddd4      	ble.n	96 <mp_read_radix+0x96>
      int ret = fp_mul_d (a, (fp_digit) radix, a);
  ec:	4622      	mov	r2, r4
  ee:	4641      	mov	r1, r8
  f0:	4620      	mov	r0, r4
  f2:	f7ff fffe 	bl	0 <mp_read_radix>
      if (ret != FP_OKAY)
  f6:	2800      	cmp	r0, #0
  f8:	d1cf      	bne.n	9a <mp_read_radix+0x9a>
      ret = fp_add_d (a, (fp_digit) y, a);
  fa:	4649      	mov	r1, r9
  fc:	4620      	mov	r0, r4
  fe:	f7ff fffe 	bl	0 <mp_read_radix>
      if (ret != FP_OKAY)
 102:	2800      	cmp	r0, #0
 104:	d1c9      	bne.n	9a <mp_read_radix+0x9a>
  while (*str) {
 106:	f815 0f01 	ldrb.w	r0, [r5, #1]!
 10a:	2800      	cmp	r0, #0
 10c:	d1d5      	bne.n	ba <mp_read_radix+0xba>
  if (fp_iszero(a) != FP_YES) {
 10e:	6823      	ldr	r3, [r4, #0]
 110:	2b00      	cmp	r3, #0
 112:	d09a      	beq.n	4a <mp_read_radix+0x4a>
     a->sign = neg;
 114:	6066      	str	r6, [r4, #4]
    return fp_read_radix(a, str, radix);
 116:	e7c0      	b.n	9a <mp_read_radix+0x9a>
    neg = FP_ZPOS;
 118:	2600      	movs	r6, #0
 11a:	e7cb      	b.n	b4 <mp_read_radix+0xb4>
  fp_clamp(a);
 11c:	6063      	str	r3, [r4, #4]
 11e:	e794      	b.n	4a <mp_read_radix+0x4a>
 120:	00000001 	.word	0x00000001
 124:	00000000 	.word	0x00000000

Disassembly of section .text.mp_sqr:

00000000 <mp_sqr>:
#ifdef HAVE_ECC

/* fast math conversion */
int mp_sqr(fp_int *A, fp_int *B)
{
    return fp_sqr(A, B);
   0:	f7ff bffe 	b.w	0 <mp_sqr>

Disassembly of section .text.mp_montgomery_reduce:

00000000 <mp_montgomery_reduce>:
}

/* fast math conversion */
int mp_montgomery_reduce(fp_int *a, fp_int *m, fp_digit mp)
{
    return fp_montgomery_reduce(a, m, mp);
   0:	f7ff bffe 	b.w	0 <mp_montgomery_reduce>

Disassembly of section .text.mp_montgomery_reduce_ex:

00000000 <mp_montgomery_reduce_ex>:
}

int mp_montgomery_reduce_ex(fp_int *a, fp_int *m, fp_digit mp, int ct)
{
    return fp_montgomery_reduce_ex(a, m, mp, ct);
   0:	f7ff bffe 	b.w	0 <mp_montgomery_reduce_ex>

Disassembly of section .text.mp_montgomery_setup:

00000000 <mp_montgomery_setup>:


/* fast math conversion */
int mp_montgomery_setup(fp_int *a, fp_digit *rho)
{
    return fp_montgomery_setup(a, rho);
   0:	f7ff bffe 	b.w	0 <mp_montgomery_setup>

Disassembly of section .text.mp_div_2:

00000000 <mp_div_2>:
}

int mp_div_2(fp_int * a, fp_int * b)
{
   0:	b508      	push	{r3, lr}
    fp_div_2(a, b);
   2:	f7ff fffe 	bl	0 <mp_div_2>
    return MP_OKAY;
}
   6:	2000      	movs	r0, #0
   8:	bd08      	pop	{r3, pc}

Disassembly of section .text.mp_div_2_mod_ct:

00000000 <mp_div_2_mod_ct>:

/* c = a / 2 (mod b) - constant time (a < b and positive) */
int mp_div_2_mod_ct(mp_int *a, mp_int *b, mp_int *c)
{
  return fp_div_2_mod_ct(a, b, c);
   0:	f7ff bffe 	b.w	0 <mp_div_2_mod_ct>

Disassembly of section .text.mp_set:

00000000 <mp_set>:

#if defined(HAVE_ECC) || !defined(NO_RSA) || !defined(NO_DSA) || \
    defined(WOLFSSL_KEY_GEN)
/* fast math conversion */
int mp_set(fp_int *a, fp_digit b)
{
   0:	b508      	push	{r3, lr}
    fp_set(a,b);
   2:	f7ff fffe 	bl	0 <mp_set>
    return MP_OKAY;
}
   6:	2000      	movs	r0, #0
   8:	bd08      	pop	{r3, pc}

Disassembly of section .text.mp_radix_size:

00000000 <mp_radix_size>:

#ifdef WC_MP_TO_RADIX

/* returns size of ASCII representation */
int mp_radix_size (mp_int *a, int radix, int *size)
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
#endif

    *size = 0;

    /* special case for binary */
    if (radix == 2) {
   4:	2902      	cmp	r1, #2
    *size = 0;
   6:	f04f 0400 	mov.w	r4, #0
{
   a:	4681      	mov	r9, r0
   c:	460f      	mov	r7, r1
   e:	4690      	mov	r8, r2
    *size = 0;
  10:	6014      	str	r4, [r2, #0]
    if (radix == 2) {
  12:	d113      	bne.n	3c <mp_radix_size+0x3c>
        *size = fp_count_bits(a);
  14:	f7ff fffe 	bl	0 <mp_radix_size>
        if (*size == 0)
          *size = 1;
  18:	2800      	cmp	r0, #0
  1a:	bf08      	it	eq
  1c:	2001      	moveq	r0, #1
  1e:	f8c8 0000 	str.w	r0, [r8]
        *size += (a->sign == FP_NEG ? 1 : 0) + 1; /* "-" sign + null term */
  22:	f8d9 3004 	ldr.w	r3, [r9, #4]
  26:	2b01      	cmp	r3, #1
  28:	bf18      	it	ne
  2a:	2701      	movne	r7, #1
  2c:	4438      	add	r0, r7
  2e:	f8c8 0000 	str.w	r0, [r8]
        return FP_OKAY;
  32:	4626      	mov	r6, r4
    *size = digs + 1;
#ifdef WOLFSSL_SMALL_STACK
    XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
#endif
    return FP_OKAY;
}
  34:	4630      	mov	r0, r6
  36:	b003      	add	sp, #12
  38:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (radix < 2 || radix > 64) {
  3c:	1e8b      	subs	r3, r1, #2
  3e:	2b3e      	cmp	r3, #62	; 0x3e
  40:	d837      	bhi.n	b2 <mp_radix_size+0xb2>
    if (fp_iszero(a) == MP_YES) {
  42:	6806      	ldr	r6, [r0, #0]
  44:	b92e      	cbnz	r6, 52 <mp_radix_size+0x52>
        if (radix == 16)
  46:	2910      	cmp	r1, #16
            *size = 3;
  48:	bf0c      	ite	eq
  4a:	2303      	moveq	r3, #3
            *size = 2;
  4c:	2302      	movne	r3, #2
  4e:	6013      	str	r3, [r2, #0]
  50:	e7f0      	b.n	34 <mp_radix_size+0x34>
    t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
  52:	2068      	movs	r0, #104	; 0x68
  54:	f7ff fffe 	bl	0 <malloc>
    if (t == NULL)
  58:	4605      	mov	r5, r0
  5a:	b368      	cbz	r0, b8 <mp_radix_size+0xb8>
    fp_zero(a);
  5c:	f7ff fffe 	bl	0 <mp_radix_size>
    fp_copy(a, t); /* copy (src = a) to (dst = t)*/
  60:	4629      	mov	r1, r5
  62:	4648      	mov	r0, r9
  64:	f7ff fffe 	bl	0 <mp_radix_size>
    t->sign = FP_ZPOS;
  68:	606c      	str	r4, [r5, #4]
    while (fp_iszero (t) == FP_NO) {
  6a:	682e      	ldr	r6, [r5, #0]
  6c:	b986      	cbnz	r6, 90 <mp_radix_size+0x90>
    fp_zero (t);
  6e:	4628      	mov	r0, r5
  70:	f7ff fffe 	bl	0 <mp_radix_size>
    if ((digs & 1) && (radix == 16)) {
  74:	07e3      	lsls	r3, r4, #31
  76:	d502      	bpl.n	7e <mp_radix_size+0x7e>
  78:	2f10      	cmp	r7, #16
        ++digs;
  7a:	bf08      	it	eq
  7c:	3401      	addeq	r4, #1
    if (a->sign == FP_NEG) {
  7e:	f8d9 3004 	ldr.w	r3, [r9, #4]
  82:	2b01      	cmp	r3, #1
        ++digs;
  84:	bf08      	it	eq
  86:	3401      	addeq	r4, #1
    *size = digs + 1;
  88:	3401      	adds	r4, #1
  8a:	f8c8 4000 	str.w	r4, [r8]
  8e:	e00a      	b.n	a6 <mp_radix_size+0xa6>
        if ((res = fp_div_d (t, (mp_digit) radix, t, &d)) != FP_OKAY) {
  90:	ab01      	add	r3, sp, #4
  92:	462a      	mov	r2, r5
  94:	4639      	mov	r1, r7
  96:	4628      	mov	r0, r5
  98:	f7ff fffe 	bl	0 <mp_radix_size>
  9c:	4606      	mov	r6, r0
  9e:	b130      	cbz	r0, ae <mp_radix_size+0xae>
            fp_zero (t);
  a0:	4628      	mov	r0, r5
  a2:	f7ff fffe 	bl	0 <mp_radix_size>
    XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  a6:	4628      	mov	r0, r5
  a8:	f7ff fffe 	bl	0 <free>
    return FP_OKAY;
  ac:	e7c2      	b.n	34 <mp_radix_size+0x34>
        ++digs;
  ae:	3401      	adds	r4, #1
  b0:	e7db      	b.n	6a <mp_radix_size+0x6a>
        return FP_VAL;
  b2:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  b6:	e7bd      	b.n	34 <mp_radix_size+0x34>
        return FP_MEM;
  b8:	f06f 0601 	mvn.w	r6, #1
  bc:	e7ba      	b.n	34 <mp_radix_size+0x34>

Disassembly of section .text.mp_toradix:

00000000 <mp_toradix>:
#else
    fp_int   *t;
#endif

    /* check range of the radix */
    if (radix < 2 || radix > 64) {
   0:	1e93      	subs	r3, r2, #2
   2:	2b3e      	cmp	r3, #62	; 0x3e
{
   4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   8:	4606      	mov	r6, r0
   a:	460c      	mov	r4, r1
   c:	4617      	mov	r7, r2
    if (radix < 2 || radix > 64) {
   e:	d84e      	bhi.n	ae <mp_toradix+0xae>
        return FP_VAL;
    }

    /* quick out if its zero */
    if (fp_iszero(a) == FP_YES) {
  10:	6805      	ldr	r5, [r0, #0]
  12:	b965      	cbnz	r5, 2e <mp_toradix+0x2e>
#ifndef WC_DISABLE_RADIX_ZERO_PAD
        if (radix == 16)
  14:	2a10      	cmp	r2, #16
            *str++ = '0';
  16:	bf04      	itt	eq
  18:	2330      	moveq	r3, #48	; 0x30
  1a:	f804 3b01 	strbeq.w	r3, [r4], #1
#endif
        *str++ = '0';
  1e:	2330      	movs	r3, #48	; 0x30
  20:	7023      	strb	r3, [r4, #0]
        *str = '\0';
  22:	2300      	movs	r3, #0
  24:	7063      	strb	r3, [r4, #1]
    fp_zero (t);
#ifdef WOLFSSL_SMALL_STACK
    XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
#endif
    return FP_OKAY;
}
  26:	4628      	mov	r0, r5
  28:	b003      	add	sp, #12
  2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    t = (fp_int*)XMALLOC(sizeof(fp_int), NULL, DYNAMIC_TYPE_BIGINT);
  2e:	2068      	movs	r0, #104	; 0x68
  30:	f7ff fffe 	bl	0 <malloc>
    if (t == NULL)
  34:	4680      	mov	r8, r0
  36:	2800      	cmp	r0, #0
  38:	d03c      	beq.n	b4 <mp_toradix+0xb4>
    fp_zero(a);
  3a:	f7ff fffe 	bl	0 <mp_toradix>
    fp_copy(a, t); /* copy (src = a) to (dst = t) */
  3e:	4630      	mov	r0, r6
  40:	4641      	mov	r1, r8
  42:	f7ff fffe 	bl	0 <mp_toradix>
    if (t->sign == FP_NEG) {
  46:	f8d8 3004 	ldr.w	r3, [r8, #4]
        *str++ = fp_s_rmap[d];
  4a:	f8df 9070 	ldr.w	r9, [pc, #112]	; bc <mp_toradix+0xbc>
    if (t->sign == FP_NEG) {
  4e:	2b01      	cmp	r3, #1
        *str++ = '-';
  50:	bf01      	itttt	eq
  52:	232d      	moveq	r3, #45	; 0x2d
  54:	f804 3b01 	strbeq.w	r3, [r4], #1
        t->sign = FP_ZPOS;
  58:	2300      	moveq	r3, #0
  5a:	f8c8 3004 	streq.w	r3, [r8, #4]
    while (fp_iszero (t) == FP_NO) {
  5e:	4626      	mov	r6, r4
  60:	f8d8 5000 	ldr.w	r5, [r8]
  64:	1b31      	subs	r1, r6, r4
  66:	b96d      	cbnz	r5, 84 <mp_toradix+0x84>
    if ((digs & 1) && (radix == 16)) {
  68:	07cb      	lsls	r3, r1, #31
  6a:	d505      	bpl.n	78 <mp_toradix+0x78>
  6c:	2f10      	cmp	r7, #16
        *str++ = fp_s_rmap[0];
  6e:	bf02      	ittt	eq
  70:	2330      	moveq	r3, #48	; 0x30
  72:	f806 3b01 	strbeq.w	r3, [r6], #1
        ++digs;
  76:	3101      	addeq	r1, #1
    mp_reverse ((unsigned char *)_s, digs);
  78:	4620      	mov	r0, r4
  7a:	f7ff fffe 	bl	0 <mp_reverse>
    *str = '\0';
  7e:	2300      	movs	r3, #0
  80:	7033      	strb	r3, [r6, #0]
  82:	e007      	b.n	94 <mp_toradix+0x94>
        if ((res = fp_div_d (t, (fp_digit) radix, t, &d)) != FP_OKAY) {
  84:	ab01      	add	r3, sp, #4
  86:	4642      	mov	r2, r8
  88:	4639      	mov	r1, r7
  8a:	4640      	mov	r0, r8
  8c:	f7ff fffe 	bl	0 <mp_toradix>
  90:	4605      	mov	r5, r0
  92:	b130      	cbz	r0, a2 <mp_toradix+0xa2>
    fp_zero (t);
  94:	4640      	mov	r0, r8
  96:	f7ff fffe 	bl	0 <mp_toradix>
    XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);
  9a:	4640      	mov	r0, r8
  9c:	f7ff fffe 	bl	0 <free>
    return FP_OKAY;
  a0:	e7c1      	b.n	26 <mp_toradix+0x26>
        *str++ = fp_s_rmap[d];
  a2:	9b01      	ldr	r3, [sp, #4]
  a4:	f813 3009 	ldrb.w	r3, [r3, r9]
  a8:	f806 3b01 	strb.w	r3, [r6], #1
        ++digs;
  ac:	e7d8      	b.n	60 <mp_toradix+0x60>
        return FP_VAL;
  ae:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  b2:	e7b8      	b.n	26 <mp_toradix+0x26>
        return FP_MEM;
  b4:	f06f 0501 	mvn.w	r5, #1
  b8:	e7b5      	b.n	26 <mp_toradix+0x26>
  ba:	bf00      	nop
  bc:	00000000 	.word	0x00000000

Disassembly of section .text.mp_abs:

00000000 <mp_abs>:

#endif /* WC_MP_TO_RADIX */


int mp_abs(mp_int* a, mp_int* b)
{
   0:	b510      	push	{r4, lr}
   2:	460c      	mov	r4, r1
  fp_abs(a, b);
   4:	f7ff fffe 	bl	0 <mp_abs>
   8:	2000      	movs	r0, #0
   a:	6060      	str	r0, [r4, #4]
  return FP_OKAY;
}
   c:	bd10      	pop	{r4, pc}

Disassembly of section .text.mp_lshd:

00000000 <mp_lshd>:


int mp_lshd (mp_int * a, int b)
{
  return fp_lshd(a, b);
   0:	f7ff bffe 	b.w	0 <mp_lshd>

wc_dsp.o:     file format elf32-littlearm


wc_encrypt.o:     file format elf32-littlearm


Disassembly of section .text.wc_AesCbcDecryptWithKey:

00000000 <wc_AesCbcDecryptWithKey>:

#if !defined(NO_AES) && defined(HAVE_AES_CBC)
#ifdef HAVE_AES_DECRYPT
int wc_AesCbcDecryptWithKey(byte* out, const byte* in, word32 inSz,
                                  const byte* key, word32 keySz, const byte* iv)
{
   0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
   4:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
   8:	460f      	mov	r7, r1
   a:	4691      	mov	r9, r2
   c:	4698      	mov	r8, r3
    Aes* aes = NULL;
#else
    Aes  aes[1];
#endif

    if (out == NULL || in == NULL || key == NULL || iv == NULL) {
   e:	4606      	mov	r6, r0
  10:	b360      	cbz	r0, 6c <wc_AesCbcDecryptWithKey+0x6c>
  12:	b359      	cbz	r1, 6c <wc_AesCbcDecryptWithKey+0x6c>
  14:	b353      	cbz	r3, 6c <wc_AesCbcDecryptWithKey+0x6c>
  16:	f1ba 0f00 	cmp.w	sl, #0
  1a:	d027      	beq.n	6c <wc_AesCbcDecryptWithKey+0x6c>
        return BAD_FUNC_ARG;
    }

#ifdef WOLFSSL_SMALL_STACK
    aes = (Aes*)XMALLOC(sizeof(Aes), NULL, DYNAMIC_TYPE_TMP_BUFFER);
  1c:	f44f 709c 	mov.w	r0, #312	; 0x138
  20:	f7ff fffe 	bl	0 <malloc>
    if (aes == NULL)
  24:	4605      	mov	r5, r0
  26:	b320      	cbz	r0, 72 <wc_AesCbcDecryptWithKey+0x72>
        return MEMORY_E;
#endif

    ret = wc_AesInit(aes, NULL, INVALID_DEVID);
  28:	f06f 0201 	mvn.w	r2, #1
  2c:	2100      	movs	r1, #0
  2e:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret == 0) {
  32:	4604      	mov	r4, r0
  34:	b998      	cbnz	r0, 5e <wc_AesCbcDecryptWithKey+0x5e>
        ret = wc_AesSetKey(aes, key, keySz, iv, AES_DECRYPTION);
  36:	2301      	movs	r3, #1
  38:	9300      	str	r3, [sp, #0]
  3a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  3c:	4653      	mov	r3, sl
  3e:	4641      	mov	r1, r8
  40:	4628      	mov	r0, r5
  42:	f7ff fffe 	bl	0 <wc_AesSetKey>
        if (ret == 0)
  46:	4604      	mov	r4, r0
  48:	b930      	cbnz	r0, 58 <wc_AesCbcDecryptWithKey+0x58>
            ret = wc_AesCbcDecrypt(aes, out, in, inSz);
  4a:	464b      	mov	r3, r9
  4c:	463a      	mov	r2, r7
  4e:	4631      	mov	r1, r6
  50:	4628      	mov	r0, r5
  52:	f7ff fffe 	bl	0 <wc_AesCbcDecrypt>
  56:	4604      	mov	r4, r0

        wc_AesFree(aes);
  58:	4628      	mov	r0, r5
  5a:	f7ff fffe 	bl	0 <wc_AesFree>
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(aes, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  5e:	4628      	mov	r0, r5
  60:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
}
  64:	4620      	mov	r0, r4
  66:	b002      	add	sp, #8
  68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        return BAD_FUNC_ARG;
  6c:	f06f 04ac 	mvn.w	r4, #172	; 0xac
  70:	e7f8      	b.n	64 <wc_AesCbcDecryptWithKey+0x64>
        return MEMORY_E;
  72:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  76:	e7f5      	b.n	64 <wc_AesCbcDecryptWithKey+0x64>

Disassembly of section .text.wc_AesCbcEncryptWithKey:

00000000 <wc_AesCbcEncryptWithKey>:
#endif /* HAVE_AES_DECRYPT */

int wc_AesCbcEncryptWithKey(byte* out, const byte* in, word32 inSz,
                            const byte* key, word32 keySz, const byte* iv)
{
   0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   4:	4606      	mov	r6, r0
#else
    Aes  aes[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    aes = (Aes*)XMALLOC(sizeof(Aes), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   6:	f44f 709c 	mov.w	r0, #312	; 0x138
{
   a:	460f      	mov	r7, r1
   c:	4690      	mov	r8, r2
   e:	4699      	mov	r9, r3
    aes = (Aes*)XMALLOC(sizeof(Aes), NULL, DYNAMIC_TYPE_TMP_BUFFER);
  10:	f7ff fffe 	bl	0 <malloc>
    if (aes == NULL)
  14:	4605      	mov	r5, r0
  16:	b300      	cbz	r0, 5a <wc_AesCbcEncryptWithKey+0x5a>
        return MEMORY_E;
#endif

    ret = wc_AesInit(aes, NULL, INVALID_DEVID);
  18:	f06f 0201 	mvn.w	r2, #1
  1c:	2100      	movs	r1, #0
  1e:	f7ff fffe 	bl	0 <wc_AesInit>
    if (ret == 0) {
  22:	4604      	mov	r4, r0
  24:	b990      	cbnz	r0, 4c <wc_AesCbcEncryptWithKey+0x4c>
        ret = wc_AesSetKey(aes, key, keySz, iv, AES_ENCRYPTION);
  26:	9000      	str	r0, [sp, #0]
  28:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
  2c:	4649      	mov	r1, r9
  2e:	4628      	mov	r0, r5
  30:	f7ff fffe 	bl	0 <wc_AesSetKey>
        if (ret == 0)
  34:	4604      	mov	r4, r0
  36:	b930      	cbnz	r0, 46 <wc_AesCbcEncryptWithKey+0x46>
            ret = wc_AesCbcEncrypt(aes, out, in, inSz);
  38:	4643      	mov	r3, r8
  3a:	463a      	mov	r2, r7
  3c:	4631      	mov	r1, r6
  3e:	4628      	mov	r0, r5
  40:	f7ff fffe 	bl	0 <wc_AesCbcEncrypt>
  44:	4604      	mov	r4, r0

        wc_AesFree(aes);
  46:	4628      	mov	r0, r5
  48:	f7ff fffe 	bl	0 <wc_AesFree>
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(aes, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  4c:	4628      	mov	r0, r5
  4e:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
}
  52:	4620      	mov	r0, r4
  54:	b003      	add	sp, #12
  56:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return MEMORY_E;
  5a:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  5e:	e7f8      	b.n	52 <wc_AesCbcEncryptWithKey+0x52>

Disassembly of section .text.wc_Des_CbcEncryptWithKey:

00000000 <wc_Des_CbcEncryptWithKey>:


#if !defined(NO_DES3) && !defined(WOLFSSL_TI_CRYPT)
int wc_Des_CbcEncryptWithKey(byte* out, const byte* in, word32 sz,
                             const byte* key, const byte* iv)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4606      	mov	r6, r0
#else
    Des  des[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    des = (Des*)XMALLOC(sizeof(Des), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   6:	2090      	movs	r0, #144	; 0x90
{
   8:	460f      	mov	r7, r1
   a:	4690      	mov	r8, r2
   c:	461c      	mov	r4, r3
    des = (Des*)XMALLOC(sizeof(Des), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   e:	f7ff fffe 	bl	0 <malloc>
    if (des == NULL)
  12:	4605      	mov	r5, r0
  14:	b198      	cbz	r0, 3e <wc_Des_CbcEncryptWithKey+0x3e>
        return MEMORY_E;
#endif

    ret = wc_Des_SetKey(des, key, iv, DES_ENCRYPTION);
  16:	4621      	mov	r1, r4
  18:	9a06      	ldr	r2, [sp, #24]
  1a:	2300      	movs	r3, #0
  1c:	f7ff fffe 	bl	0 <wc_Des_SetKey>
    if (ret == 0)
  20:	4604      	mov	r4, r0
  22:	b930      	cbnz	r0, 32 <wc_Des_CbcEncryptWithKey+0x32>
        ret = wc_Des_CbcEncrypt(des, out, in, sz);
  24:	4643      	mov	r3, r8
  26:	463a      	mov	r2, r7
  28:	4631      	mov	r1, r6
  2a:	4628      	mov	r0, r5
  2c:	f7ff fffe 	bl	0 <wc_Des_CbcEncrypt>
  30:	4604      	mov	r4, r0

#ifdef WOLFSSL_SMALL_STACK
    XFREE(des, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  32:	4628      	mov	r0, r5
  34:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
}
  38:	4620      	mov	r0, r4
  3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return MEMORY_E;
  3e:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  42:	e7f9      	b.n	38 <wc_Des_CbcEncryptWithKey+0x38>

Disassembly of section .text.wc_Des_CbcDecryptWithKey:

00000000 <wc_Des_CbcDecryptWithKey>:

int wc_Des_CbcDecryptWithKey(byte* out, const byte* in, word32 sz,
                             const byte* key, const byte* iv)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4606      	mov	r6, r0
#else
    Des  des[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    des = (Des*)XMALLOC(sizeof(Des), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   6:	2090      	movs	r0, #144	; 0x90
{
   8:	460f      	mov	r7, r1
   a:	4690      	mov	r8, r2
   c:	461c      	mov	r4, r3
    des = (Des*)XMALLOC(sizeof(Des), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   e:	f7ff fffe 	bl	0 <malloc>
    if (des == NULL)
  12:	4605      	mov	r5, r0
  14:	b198      	cbz	r0, 3e <wc_Des_CbcDecryptWithKey+0x3e>
        return MEMORY_E;
#endif

    ret = wc_Des_SetKey(des, key, iv, DES_DECRYPTION);
  16:	4621      	mov	r1, r4
  18:	9a06      	ldr	r2, [sp, #24]
  1a:	2301      	movs	r3, #1
  1c:	f7ff fffe 	bl	0 <wc_Des_SetKey>
    if (ret == 0)
  20:	4604      	mov	r4, r0
  22:	b930      	cbnz	r0, 32 <wc_Des_CbcDecryptWithKey+0x32>
        ret = wc_Des_CbcDecrypt(des, out, in, sz);
  24:	4643      	mov	r3, r8
  26:	463a      	mov	r2, r7
  28:	4631      	mov	r1, r6
  2a:	4628      	mov	r0, r5
  2c:	f7ff fffe 	bl	0 <wc_Des_CbcDecrypt>
  30:	4604      	mov	r4, r0

#ifdef WOLFSSL_SMALL_STACK
    XFREE(des, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  32:	4628      	mov	r0, r5
  34:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
}
  38:	4620      	mov	r0, r4
  3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return MEMORY_E;
  3e:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  42:	e7f9      	b.n	38 <wc_Des_CbcDecryptWithKey+0x38>

Disassembly of section .text.wc_Des3_CbcEncryptWithKey:

00000000 <wc_Des3_CbcEncryptWithKey>:


int wc_Des3_CbcEncryptWithKey(byte* out, const byte* in, word32 sz,
                              const byte* key, const byte* iv)
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	4606      	mov	r6, r0
#else
    Des3  des3[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    des3 = (Des3*)XMALLOC(sizeof(Des3), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   6:	f44f 70ca 	mov.w	r0, #404	; 0x194
{
   a:	460f      	mov	r7, r1
   c:	4690      	mov	r8, r2
   e:	4699      	mov	r9, r3
    des3 = (Des3*)XMALLOC(sizeof(Des3), NULL, DYNAMIC_TYPE_TMP_BUFFER);
  10:	f7ff fffe 	bl	0 <malloc>
    if (des3 == NULL)
  14:	4605      	mov	r5, r0
  16:	b1f0      	cbz	r0, 56 <wc_Des3_CbcEncryptWithKey+0x56>
        return MEMORY_E;
#endif

    ret = wc_Des3Init(des3, NULL, INVALID_DEVID);
  18:	f06f 0201 	mvn.w	r2, #1
  1c:	2100      	movs	r1, #0
  1e:	f7ff fffe 	bl	0 <wc_Des3Init>
    if (ret == 0) {
  22:	4604      	mov	r4, r0
  24:	b988      	cbnz	r0, 4a <wc_Des3_CbcEncryptWithKey+0x4a>
        ret = wc_Des3_SetKey(des3, key, iv, DES_ENCRYPTION);
  26:	4603      	mov	r3, r0
  28:	9a08      	ldr	r2, [sp, #32]
  2a:	4649      	mov	r1, r9
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
        if (ret == 0)
  32:	4604      	mov	r4, r0
  34:	b930      	cbnz	r0, 44 <wc_Des3_CbcEncryptWithKey+0x44>
            ret = wc_Des3_CbcEncrypt(des3, out, in, sz);
  36:	4643      	mov	r3, r8
  38:	463a      	mov	r2, r7
  3a:	4631      	mov	r1, r6
  3c:	4628      	mov	r0, r5
  3e:	f7ff fffe 	bl	0 <wc_Des3_CbcEncrypt>
  42:	4604      	mov	r4, r0
        wc_Des3Free(des3);
  44:	4628      	mov	r0, r5
  46:	f7ff fffe 	bl	0 <wc_Des3Free>
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(des3, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  4a:	4628      	mov	r0, r5
  4c:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
}
  50:	4620      	mov	r0, r4
  52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return MEMORY_E;
  56:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  5a:	e7f9      	b.n	50 <wc_Des3_CbcEncryptWithKey+0x50>

Disassembly of section .text.wc_Des3_CbcDecryptWithKey:

00000000 <wc_Des3_CbcDecryptWithKey>:


int wc_Des3_CbcDecryptWithKey(byte* out, const byte* in, word32 sz,
                              const byte* key, const byte* iv)
{
   0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   4:	4606      	mov	r6, r0
#else
    Des3  des3[1];
#endif

#ifdef WOLFSSL_SMALL_STACK
    des3 = (Des3*)XMALLOC(sizeof(Des3), NULL, DYNAMIC_TYPE_TMP_BUFFER);
   6:	f44f 70ca 	mov.w	r0, #404	; 0x194
{
   a:	460f      	mov	r7, r1
   c:	4690      	mov	r8, r2
   e:	4699      	mov	r9, r3
    des3 = (Des3*)XMALLOC(sizeof(Des3), NULL, DYNAMIC_TYPE_TMP_BUFFER);
  10:	f7ff fffe 	bl	0 <malloc>
    if (des3 == NULL)
  14:	4605      	mov	r5, r0
  16:	b1f0      	cbz	r0, 56 <wc_Des3_CbcDecryptWithKey+0x56>
        return MEMORY_E;
#endif

    ret = wc_Des3Init(des3, NULL, INVALID_DEVID);
  18:	f06f 0201 	mvn.w	r2, #1
  1c:	2100      	movs	r1, #0
  1e:	f7ff fffe 	bl	0 <wc_Des3Init>
    if (ret == 0) {
  22:	4604      	mov	r4, r0
  24:	b988      	cbnz	r0, 4a <wc_Des3_CbcDecryptWithKey+0x4a>
        ret = wc_Des3_SetKey(des3, key, iv, DES_DECRYPTION);
  26:	9a08      	ldr	r2, [sp, #32]
  28:	2301      	movs	r3, #1
  2a:	4649      	mov	r1, r9
  2c:	4628      	mov	r0, r5
  2e:	f7ff fffe 	bl	0 <wc_Des3_SetKey>
        if (ret == 0)
  32:	4604      	mov	r4, r0
  34:	b930      	cbnz	r0, 44 <wc_Des3_CbcDecryptWithKey+0x44>
            ret = wc_Des3_CbcDecrypt(des3, out, in, sz);
  36:	4643      	mov	r3, r8
  38:	463a      	mov	r2, r7
  3a:	4631      	mov	r1, r6
  3c:	4628      	mov	r0, r5
  3e:	f7ff fffe 	bl	0 <wc_Des3_CbcDecrypt>
  42:	4604      	mov	r4, r0
        wc_Des3Free(des3);
  44:	4628      	mov	r0, r5
  46:	f7ff fffe 	bl	0 <wc_Des3Free>
    }

#ifdef WOLFSSL_SMALL_STACK
    XFREE(des3, NULL, DYNAMIC_TYPE_TMP_BUFFER);
  4a:	4628      	mov	r0, r5
  4c:	f7ff fffe 	bl	0 <free>
#endif

    return ret;
}
  50:	4620      	mov	r0, r4
  52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return MEMORY_E;
  56:	f06f 047c 	mvn.w	r4, #124	; 0x7c
  5a:	e7f9      	b.n	50 <wc_Des3_CbcDecryptWithKey+0x50>

wc_pkcs11.o:     file format elf32-littlearm


wc_port.o:     file format elf32-littlearm


Disassembly of section .text.wolfCrypt_Init:

00000000 <wolfCrypt_Init>:
 */
WOLFSSL_ABI
int wolfCrypt_Init(void)
{
    int ret = 0;
    if (initRefCount == 0) {
   0:	4b03      	ldr	r3, [pc, #12]	; (10 <wolfCrypt_Init+0x10>)
   2:	681a      	ldr	r2, [r3, #0]
            return ret;
        }
        rpcmem_init();
#endif
    }
    initRefCount++;
   4:	681a      	ldr	r2, [r3, #0]
   6:	3201      	adds	r2, #1
   8:	601a      	str	r2, [r3, #0]

    return ret;
}
   a:	2000      	movs	r0, #0
   c:	4770      	bx	lr
   e:	bf00      	nop
  10:	00000000 	.word	0x00000000

Disassembly of section .text.wolfCrypt_Cleanup:

00000000 <wolfCrypt_Cleanup>:
WOLFSSL_ABI
int wolfCrypt_Cleanup(void)
{
    int ret = 0;

    initRefCount--;
   0:	4b05      	ldr	r3, [pc, #20]	; (18 <wolfCrypt_Cleanup+0x18>)
   2:	681a      	ldr	r2, [r3, #0]
   4:	3a01      	subs	r2, #1
   6:	601a      	str	r2, [r3, #0]
    if (initRefCount < 0)
   8:	681a      	ldr	r2, [r3, #0]
   a:	2a00      	cmp	r2, #0
        initRefCount = 0;
   c:	bfbc      	itt	lt
   e:	2200      	movlt	r2, #0
  10:	601a      	strlt	r2, [r3, #0]

    if (initRefCount == 0) {
  12:	681b      	ldr	r3, [r3, #0]
        wc_MemZero_Free();
    #endif
    }

    return ret;
}
  14:	2000      	movs	r0, #0
  16:	4770      	bx	lr
  18:	00000000 	.word	0x00000000

Disassembly of section .text.wc_InitAndAllocMutex:

00000000 <wc_InitAndAllocMutex>:
#endif /* !NO_FILESYSTEM && !WOLFSSL_ZEPHYR */

#if !defined(WOLFSSL_USER_MUTEX)
wolfSSL_Mutex* wc_InitAndAllocMutex(void)
{
    wolfSSL_Mutex* m = (wolfSSL_Mutex*) XMALLOC(sizeof(wolfSSL_Mutex), NULL,
   0:	2004      	movs	r0, #4
   2:	f7ff bffe 	b.w	0 <malloc>

Disassembly of section .text.wc_strtok:

00000000 <wc_strtok>:
#endif

#ifdef USE_WOLF_STRTOK
/* String token (delim) search. If str is null use nextp. */
char* wc_strtok(char *str, const char *delim, char **nextp)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    char* ret;
    int i, j;

    /* Use next if str is NULL */
    if (str == NULL && nextp)
   2:	b910      	cbnz	r0, a <wc_strtok+0xa>
   4:	b1c2      	cbz	r2, 38 <wc_strtok+0x38>
        str = *nextp;
   6:	6810      	ldr	r0, [r2, #0]

    /* verify str input */
    if (str == NULL || *str == '\0')
   8:	b1b0      	cbz	r0, 38 <wc_strtok+0x38>
   a:	7803      	ldrb	r3, [r0, #0]
   c:	b303      	cbz	r3, 50 <wc_strtok+0x50>
   e:	4603      	mov	r3, r0
  10:	3901      	subs	r1, #1
        return NULL;

    /* match on entire delim */
    for (i = 0; str[i]; i++) {
  12:	781c      	ldrb	r4, [r3, #0]
  14:	4618      	mov	r0, r3
  16:	461d      	mov	r5, r3
  18:	3301      	adds	r3, #1
  1a:	b1dc      	cbz	r4, 54 <wc_strtok+0x54>
  1c:	460e      	mov	r6, r1
  1e:	e001      	b.n	24 <wc_strtok+0x24>
        for (j = 0; delim[j]; j++) {
            if (delim[j] == str[i])
  20:	42a7      	cmp	r7, r4
  22:	d0f6      	beq.n	12 <wc_strtok+0x12>
        for (j = 0; delim[j]; j++) {
  24:	f816 7f01 	ldrb.w	r7, [r6, #1]!
  28:	2f00      	cmp	r7, #0
  2a:	d1f9      	bne.n	20 <wc_strtok+0x20>
        return NULL;

    ret = str;

    /* match on first delim */
    for (i = 0; str[i]; i++) {
  2c:	462b      	mov	r3, r5
  2e:	f815 4b01 	ldrb.w	r4, [r5], #1
  32:	b914      	cbnz	r4, 3a <wc_strtok+0x3a>
    /* null terminate found string */
    if (*str)
        *str++ = '\0';

    /* return pointer to next */
    if (nextp)
  34:	b102      	cbz	r2, 38 <wc_strtok+0x38>
        *nextp = str;
  36:	6013      	str	r3, [r2, #0]

    return ret;
}
  38:	bdf0      	pop	{r4, r5, r6, r7, pc}
  3a:	460f      	mov	r7, r1
        for (j = 0; delim[j]; j++) {
  3c:	f817 6f01 	ldrb.w	r6, [r7, #1]!
  40:	2e00      	cmp	r6, #0
  42:	d0f3      	beq.n	2c <wc_strtok+0x2c>
            if (delim[j] == str[i])
  44:	42a6      	cmp	r6, r4
  46:	d1f9      	bne.n	3c <wc_strtok+0x3c>
        *str++ = '\0';
  48:	2100      	movs	r1, #0
  4a:	f803 1b01 	strb.w	r1, [r3], #1
  4e:	e7f1      	b.n	34 <wc_strtok+0x34>
        return NULL;
  50:	4618      	mov	r0, r3
  52:	e7f1      	b.n	38 <wc_strtok+0x38>
  54:	4620      	mov	r0, r4
  56:	e7ef      	b.n	38 <wc_strtok+0x38>

Disassembly of section .text.wc_strsep:

00000000 <wc_strsep>:
#endif /* USE_WOLF_STRTOK */

#ifdef USE_WOLF_STRSEP
char* wc_strsep(char **stringp, const char *delim)
{
   0:	b5f0      	push	{r4, r5, r6, r7, lr}
    char *s, *tok;
    const char *spanp;

    /* null check */
    if (stringp == NULL || *stringp == NULL)
   2:	4603      	mov	r3, r0
   4:	b188      	cbz	r0, 2a <wc_strsep+0x2a>
   6:	6800      	ldr	r0, [r0, #0]
   8:	b178      	cbz	r0, 2a <wc_strsep+0x2a>
   a:	4605      	mov	r5, r0
   c:	462a      	mov	r2, r5
        return NULL;

    s = *stringp;
    for (tok = s; *tok; ++tok) {
   e:	f815 4b01 	ldrb.w	r4, [r5], #1
  12:	b15c      	cbz	r4, 2c <wc_strsep+0x2c>
  14:	1e4e      	subs	r6, r1, #1
        for (spanp = delim; *spanp; ++spanp) {
  16:	f816 7f01 	ldrb.w	r7, [r6, #1]!
  1a:	2f00      	cmp	r7, #0
  1c:	d0f6      	beq.n	c <wc_strsep+0xc>
            /* found delimiter */
            if (*tok == *spanp) {
  1e:	42a7      	cmp	r7, r4
  20:	d1f9      	bne.n	16 <wc_strsep+0x16>
                *tok = '\0'; /* replace delim with null term */
  22:	2100      	movs	r1, #0
  24:	f802 1b01 	strb.w	r1, [r2], #1
                *stringp = tok + 1; /* return past delim */
  28:	601a      	str	r2, [r3, #0]
        }
    }

    *stringp = NULL;
    return s;
}
  2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    *stringp = NULL;
  2c:	601c      	str	r4, [r3, #0]
    return s;
  2e:	e7fc      	b.n	2a <wc_strsep+0x2a>

Disassembly of section .text.wc_strlcpy:

00000000 <wc_strlcpy>:
#endif /* USE_WOLF_STRSEP */

#ifdef USE_WOLF_STRLCPY
size_t wc_strlcpy(char *dst, const char *src, size_t dstSize)
{
   0:	b510      	push	{r4, lr}
   2:	4604      	mov	r4, r0
    size_t i;

    if (!dstSize)
   4:	4610      	mov	r0, r2
   6:	b132      	cbz	r2, 16 <wc_strlcpy+0x16>
        return 0;

    /* Always have to leave a space for NULL */
    for (i = 0; i < (dstSize - 1) && *src != '\0'; i++) {
   8:	2300      	movs	r3, #0
   a:	3a01      	subs	r2, #1
   c:	4293      	cmp	r3, r2
   e:	d303      	bcc.n	18 <wc_strlcpy+0x18>
        *dst++ = *src++;
    }
    *dst = '\0';
  10:	2200      	movs	r2, #0
  12:	7022      	strb	r2, [r4, #0]
  14:	4618      	mov	r0, r3

    return i; /* return length without NULL */
}
  16:	bd10      	pop	{r4, pc}
    for (i = 0; i < (dstSize - 1) && *src != '\0'; i++) {
  18:	5cc8      	ldrb	r0, [r1, r3]
  1a:	2800      	cmp	r0, #0
  1c:	d0f8      	beq.n	10 <wc_strlcpy+0x10>
        *dst++ = *src++;
  1e:	f804 0b01 	strb.w	r0, [r4], #1
    for (i = 0; i < (dstSize - 1) && *src != '\0'; i++) {
  22:	3301      	adds	r3, #1
  24:	e7f2      	b.n	c <wc_strlcpy+0xc>

Disassembly of section .text.wc_strlcat:

00000000 <wc_strlcat>:
#endif /* USE_WOLF_STRLCPY */

#ifdef USE_WOLF_STRLCAT
size_t wc_strlcat(char *dst, const char *src, size_t dstSize)
{
   0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2:	4607      	mov	r7, r0
   4:	460e      	mov	r6, r1
    size_t dstLen;

    if (!dstSize)
   6:	4614      	mov	r4, r2
   8:	b142      	cbz	r2, 1c <wc_strlcat+0x1c>
        return 0;

    dstLen = XSTRLEN(dst);
   a:	f7ff fffe 	bl	0 <strlen>

    if (dstSize < dstLen)
   e:	4284      	cmp	r4, r0
    dstLen = XSTRLEN(dst);
  10:	4605      	mov	r5, r0
    if (dstSize < dstLen)
  12:	d205      	bcs.n	20 <wc_strlcat+0x20>
        return dstLen + XSTRLEN(src);
  14:	4630      	mov	r0, r6
  16:	f7ff fffe 	bl	0 <strlen>

    return dstLen + wc_strlcpy(dst + dstLen, src, dstSize - dstLen);
  1a:	1944      	adds	r4, r0, r5
}
  1c:	4620      	mov	r0, r4
  1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return dstLen + wc_strlcpy(dst + dstLen, src, dstSize - dstLen);
  20:	1a22      	subs	r2, r4, r0
  22:	4631      	mov	r1, r6
  24:	1838      	adds	r0, r7, r0
  26:	f7ff fffe 	bl	0 <wc_strlcat>
  2a:	e7f6      	b.n	1a <wc_strlcat+0x1a>

Disassembly of section .text.wc_InitMutex:

00000000 <wc_InitMutex>:

    int wc_InitMutex(wolfSSL_Mutex* m)
    {
        (void)m;
        return 0;
    }
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_FreeMutex:

00000000 <wc_FreeMutex>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_LockMutex:

00000000 <wc_LockMutex>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_UnLockMutex:

00000000 <wc_UnLockMutex>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_InitRwLock:

00000000 <wc_InitRwLock>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_FreeRwLock:

00000000 <wc_FreeRwLock>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_LockRwLock_Wr:

00000000 <wc_LockRwLock_Wr>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_LockRwLock_Rd:

00000000 <wc_LockRwLock_Rd>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.wc_UnLockRwLock:

00000000 <wc_UnLockRwLock>:
   0:	2000      	movs	r0, #0
   2:	4770      	bx	lr

Disassembly of section .text.gmtime:

00000000 <gmtime>:
    struct tm* ret = &st_time;
    time_t secs = *timer;
    unsigned long dayclock, dayno;
    int year = EPOCH_YEAR;

    dayclock = (unsigned long)secs % SECS_DAY;
   0:	6802      	ldr	r2, [r0, #0]
   2:	493f      	ldr	r1, [pc, #252]	; (100 <gmtime+0x100>)
   4:	fbb2 f3f1 	udiv	r3, r2, r1
    dayno    = (unsigned long)secs / SECS_DAY;

    ret->tm_sec  = (int) dayclock % 60;
   8:	203c      	movs	r0, #60	; 0x3c
    dayclock = (unsigned long)secs % SECS_DAY;
   a:	fb01 2213 	mls	r2, r1, r3, r2
    ret->tm_sec  = (int) dayclock % 60;
   e:	493d      	ldr	r1, [pc, #244]	; (104 <gmtime+0x104>)
{
  10:	b5f0      	push	{r4, r5, r6, r7, lr}
    ret->tm_sec  = (int) dayclock % 60;
  12:	fbb2 f4f0 	udiv	r4, r2, r0
    ret->tm_min  = (int)(dayclock % 3600) / 60;
  16:	f44f 6561 	mov.w	r5, #3600	; 0xe10
    ret->tm_sec  = (int) dayclock % 60;
  1a:	fb00 2414 	mls	r4, r0, r4, r2
  1e:	600c      	str	r4, [r1, #0]
    ret->tm_min  = (int)(dayclock % 3600) / 60;
  20:	fbb2 f4f5 	udiv	r4, r2, r5
  24:	fb05 2214 	mls	r2, r5, r4, r2
  28:	fbb2 f2f0 	udiv	r2, r2, r0
    ret->tm_hour = (int) dayclock / 3600;
    ret->tm_wday = (int) (dayno + 4) % 7;        /* day 0 a Thursday */
  2c:	1d18      	adds	r0, r3, #4
    ret->tm_hour = (int) dayclock / 3600;
  2e:	e9c1 2401 	strd	r2, r4, [r1, #4]
    ret->tm_wday = (int) (dayno + 4) % 7;        /* day 0 a Thursday */
  32:	2207      	movs	r2, #7
  34:	fbb0 f2f2 	udiv	r2, r0, r2
  38:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
  3c:	1a82      	subs	r2, r0, r2
  3e:	618a      	str	r2, [r1, #24]

    while(dayno >= (unsigned long)YEARSIZE(year)) {
  40:	2464      	movs	r4, #100	; 0x64
    int year = EPOCH_YEAR;
  42:	f240 72b2 	movw	r2, #1970	; 0x7b2
  46:	f44f 76c8 	mov.w	r6, #400	; 0x190
    while(dayno >= (unsigned long)YEARSIZE(year)) {
  4a:	f012 0503 	ands.w	r5, r2, #3
  4e:	d109      	bne.n	64 <gmtime+0x64>
  50:	fb92 f0f4 	sdiv	r0, r2, r4
  54:	fb04 2010 	mls	r0, r4, r0, r2
  58:	bb20      	cbnz	r0, a4 <gmtime+0xa4>
  5a:	fb92 f0f6 	sdiv	r0, r2, r6
  5e:	fb06 2010 	mls	r0, r6, r0, r2
  62:	b1f8      	cbz	r0, a4 <gmtime+0xa4>
  64:	f5b3 7fb6 	cmp.w	r3, #364	; 0x16c
  68:	d91f      	bls.n	aa <gmtime+0xaa>
        dayno -= YEARSIZE(year);
  6a:	f240 106d 	movw	r0, #365	; 0x16d
  6e:	e001      	b.n	74 <gmtime+0x74>
  70:	f44f 70b7 	mov.w	r0, #366	; 0x16e
  74:	1a1b      	subs	r3, r3, r0
        year++;
  76:	3201      	adds	r2, #1
  78:	e7e7      	b.n	4a <gmtime+0x4a>
    ret->tm_year = year - YEAR0;
    ret->tm_yday = (int)dayno;
    ret->tm_mon  = 0;

    while(dayno >= (unsigned long)_ytab[LEAPYEAR(year)][ret->tm_mon]) {
        dayno -= _ytab[LEAPYEAR(year)][ret->tm_mon];
  7a:	b95d      	cbnz	r5, 94 <gmtime+0x94>
  7c:	b967      	cbnz	r7, 98 <gmtime+0x98>
  7e:	fab2 f482 	clz	r4, r2
  82:	0964      	lsrs	r4, r4, #5
  84:	fb0e 0404 	mla	r4, lr, r4, r0
  88:	2601      	movs	r6, #1
  8a:	f85c 4024 	ldr.w	r4, [ip, r4, lsl #2]
  8e:	3001      	adds	r0, #1
  90:	1b1b      	subs	r3, r3, r4
        ret->tm_mon++;
  92:	e020      	b.n	d6 <gmtime+0xd6>
        dayno -= _ytab[LEAPYEAR(year)][ret->tm_mon];
  94:	2400      	movs	r4, #0
  96:	e7f5      	b.n	84 <gmtime+0x84>
  98:	2401      	movs	r4, #1
  9a:	e7f3      	b.n	84 <gmtime+0x84>
    while(dayno >= (unsigned long)_ytab[LEAPYEAR(year)][ret->tm_mon]) {
  9c:	2400      	movs	r4, #0
  9e:	e021      	b.n	e4 <gmtime+0xe4>
  a0:	2401      	movs	r4, #1
  a2:	e01f      	b.n	e4 <gmtime+0xe4>
    while(dayno >= (unsigned long)YEARSIZE(year)) {
  a4:	f5b3 7fb7 	cmp.w	r3, #366	; 0x16e
  a8:	d2e2      	bcs.n	70 <gmtime+0x70>
    ret->tm_year = year - YEAR0;
  aa:	f2a2 706c 	subw	r0, r2, #1900	; 0x76c
    while(dayno >= (unsigned long)_ytab[LEAPYEAR(year)][ret->tm_mon]) {
  ae:	2464      	movs	r4, #100	; 0x64
    ret->tm_year = year - YEAR0;
  b0:	6148      	str	r0, [r1, #20]
    while(dayno >= (unsigned long)_ytab[LEAPYEAR(year)][ret->tm_mon]) {
  b2:	fbb2 f7f4 	udiv	r7, r2, r4
    ret->tm_mon  = 0;
  b6:	2000      	movs	r0, #0
    while(dayno >= (unsigned long)_ytab[LEAPYEAR(year)][ret->tm_mon]) {
  b8:	fb04 2717 	mls	r7, r4, r7, r2
  bc:	f8df c048 	ldr.w	ip, [pc, #72]	; 108 <gmtime+0x108>
    ret->tm_yday = (int)dayno;
  c0:	61cb      	str	r3, [r1, #28]
    while(dayno >= (unsigned long)_ytab[LEAPYEAR(year)][ret->tm_mon]) {
  c2:	f44f 74c8 	mov.w	r4, #400	; 0x190
    ret->tm_mon  = 0;
  c6:	6108      	str	r0, [r1, #16]
    while(dayno >= (unsigned long)_ytab[LEAPYEAR(year)][ret->tm_mon]) {
  c8:	fbb2 f6f4 	udiv	r6, r2, r4
  cc:	f04f 0e0c 	mov.w	lr, #12
  d0:	fb04 2216 	mls	r2, r4, r6, r2
  d4:	4606      	mov	r6, r0
  d6:	2d00      	cmp	r5, #0
  d8:	d1e0      	bne.n	9c <gmtime+0x9c>
  da:	2f00      	cmp	r7, #0
  dc:	d1e0      	bne.n	a0 <gmtime+0xa0>
  de:	fab2 f482 	clz	r4, r2
  e2:	0964      	lsrs	r4, r4, #5
  e4:	fb0e 0404 	mla	r4, lr, r4, r0
  e8:	f85c 4024 	ldr.w	r4, [ip, r4, lsl #2]
  ec:	429c      	cmp	r4, r3
  ee:	d9c4      	bls.n	7a <gmtime+0x7a>
  f0:	b106      	cbz	r6, f4 <gmtime+0xf4>
  f2:	6108      	str	r0, [r1, #16]
    }

    ret->tm_mday  = (int)++dayno;
  f4:	3301      	adds	r3, #1
  f6:	60cb      	str	r3, [r1, #12]
#ifndef WOLFSSL_LINUXKM
    ret->tm_isdst = 0;
  f8:	2300      	movs	r3, #0
#endif

    return ret;
}
  fa:	4802      	ldr	r0, [pc, #8]	; (104 <gmtime+0x104>)
    ret->tm_isdst = 0;
  fc:	620b      	str	r3, [r1, #32]
}
  fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100:	00015180 	.word	0x00015180
	...

Disassembly of section .text.mystrnstr:

00000000 <mystrnstr>:

#endif /* !NO_ASN_TIME */

#if !defined(WOLFSSL_LEANPSK) && !defined(STRING_USER)
char* mystrnstr(const char* s1, const char* s2, unsigned int n)
{
   0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4:	4604      	mov	r4, r0
    unsigned int s2_len = (unsigned int)XSTRLEN(s2);
   6:	4608      	mov	r0, r1
{
   8:	460f      	mov	r7, r1
   a:	4616      	mov	r6, r2
    unsigned int s2_len = (unsigned int)XSTRLEN(s2);
   c:	f7ff fffe 	bl	0 <strlen>

    if (s2_len == 0)
  10:	4605      	mov	r5, r0
  12:	b1b0      	cbz	r0, 42 <mystrnstr+0x42>
  14:	46a0      	mov	r8, r4
  16:	4426      	add	r6, r4
  18:	4644      	mov	r4, r8
        return (char*)s1;

    while (n >= s2_len && s1[0]) {
  1a:	1b33      	subs	r3, r6, r4
  1c:	429d      	cmp	r5, r3
  1e:	d804      	bhi.n	2a <mystrnstr+0x2a>
  20:	f898 3000 	ldrb.w	r3, [r8]
  24:	f108 0801 	add.w	r8, r8, #1
  28:	b90b      	cbnz	r3, 2e <mystrnstr+0x2e>
                return (char*)s1;
        s1++;
        n--;
    }

    return NULL;
  2a:	2400      	movs	r4, #0
  2c:	e009      	b.n	42 <mystrnstr+0x42>
        if (s1[0] == s2[0])
  2e:	783a      	ldrb	r2, [r7, #0]
  30:	429a      	cmp	r2, r3
  32:	d1f1      	bne.n	18 <mystrnstr+0x18>
            if (XMEMCMP(s1, s2, s2_len) == 0)
  34:	462a      	mov	r2, r5
  36:	4639      	mov	r1, r7
  38:	4620      	mov	r0, r4
  3a:	f7ff fffe 	bl	0 <memcmp>
  3e:	2800      	cmp	r0, #0
  40:	d1ea      	bne.n	18 <mystrnstr+0x18>
}
  42:	4620      	mov	r0, r4
  44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

wolfevent.o:     file format elf32-littlearm


wolfmath.o:     file format elf32-littlearm


Disassembly of section .text.mp_reverse:

00000000 <mp_reverse>:
#endif


/* reverse an array, used for radix code */
void mp_reverse(unsigned char *s, int len)
{
   0:	b530      	push	{r4, r5, lr}
    int ix, iy;

    if (s == NULL)
   2:	b130      	cbz	r0, 12 <mp_reverse+0x12>
        return;

    ix = 0;
    iy = len - 1;
    while (ix < iy) {
   4:	1e42      	subs	r2, r0, #1
    ix = 0;
   6:	2300      	movs	r3, #0
   8:	4408      	add	r0, r1
    while (ix < iy) {
   a:	3901      	subs	r1, #1
   c:	1acc      	subs	r4, r1, r3
   e:	42a3      	cmp	r3, r4
  10:	db00      	blt.n	14 <mp_reverse+0x14>
        s[ix] = s[iy];
        s[iy] = t;
        ++ix;
        --iy;
    }
}
  12:	bd30      	pop	{r4, r5, pc}
        unsigned char t = s[ix];
  14:	f812 4f01 	ldrb.w	r4, [r2, #1]!
        s[ix] = s[iy];
  18:	f810 5d01 	ldrb.w	r5, [r0, #-1]!
  1c:	7015      	strb	r5, [r2, #0]
        ++ix;
  1e:	3301      	adds	r3, #1
        s[iy] = t;
  20:	7004      	strb	r4, [r0, #0]
        --iy;
  22:	e7f3      	b.n	c <mp_reverse+0xc>

Disassembly of section .text.get_digit_count:

00000000 <get_digit_count>:

int get_digit_count(const mp_int* a)
{
    if (a == NULL)
   0:	b100      	cbz	r0, 4 <get_digit_count+0x4>
        return 0;

    return (int)a->used;
   2:	6800      	ldr	r0, [r0, #0]
}
   4:	4770      	bx	lr

Disassembly of section .text.get_digit:

00000000 <get_digit>:

mp_digit get_digit(const mp_int* a, int n)
{
    if (a == NULL)
   0:	b148      	cbz	r0, 16 <get_digit+0x16>
        return 0;

    return (n < 0 || (unsigned int)n >= (unsigned int)a->used) ? 0 : a->dp[n];
   2:	2900      	cmp	r1, #0
   4:	db06      	blt.n	14 <get_digit+0x14>
   6:	6803      	ldr	r3, [r0, #0]
   8:	428b      	cmp	r3, r1
   a:	d903      	bls.n	14 <get_digit+0x14>
   c:	3102      	adds	r1, #2
   e:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
  12:	4770      	bx	lr
        return 0;
  14:	2000      	movs	r0, #0
}
  16:	4770      	bx	lr

Disassembly of section .text.mp_cond_copy:

00000000 <mp_cond_copy>:
 * b     MP integer to copy into.
 * returns BAD_FUNC_ARG when a or b is NULL, MEMORY_E when growing b fails and
 *         MP_OKAY otherwise.
 */
int mp_cond_copy(mp_int* a, int copy, mp_int* b)
{
   0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    int err = MP_OKAY;
#if defined(SP_WORD_SIZE) && SP_WORD_SIZE == 8
    unsigned int mask = (unsigned int)0 - copy;
#else
    mp_digit mask = (mp_digit)0 - (mp_digit)copy;
   4:	424f      	negs	r7, r1
#endif

    if (a == NULL || b == NULL)
   6:	4606      	mov	r6, r0
   8:	2800      	cmp	r0, #0
   a:	d047      	beq.n	9c <mp_cond_copy+0x9c>
   c:	2a00      	cmp	r2, #0
   e:	d045      	beq.n	9c <mp_cond_copy+0x9c>
         * When mask all set, b ^ b ^ a = a
         */
        /* Conditionally copy all digits and then number of used digits.
         * get_digit() returns 0 when index greater than available digit.
         */
        for (i = 0; i < a->used; i++) {
  10:	6804      	ldr	r4, [r0, #0]
  12:	f102 0808 	add.w	r8, r2, #8
  16:	f04f 0900 	mov.w	r9, #0
  1a:	454c      	cmp	r4, r9
  1c:	dc18      	bgt.n	50 <mp_cond_copy+0x50>
  1e:	ea24 7ae4 	bic.w	sl, r4, r4, asr #31
  22:	f10a 0902 	add.w	r9, sl, #2
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
        }
        for (; i < b->used; i++) {
  26:	f8d2 8000 	ldr.w	r8, [r2]
  2a:	eb02 0989 	add.w	r9, r2, r9, lsl #2
  2e:	45d0      	cmp	r8, sl
  30:	dc21      	bgt.n	76 <mp_cond_copy+0x76>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
        }
        b->used ^= (a->used ^ b->used) & (unsigned int)mask;
#if (!defined(WOLFSSL_SP_MATH) && !defined(WOLFSSL_SP_MATH_ALL)) || \
    defined(WOLFSSL_SP_INT_NEGATIVE)
        b->sign ^= (a->sign ^ b->sign) & (unsigned int)mask;
  32:	6853      	ldr	r3, [r2, #4]
  34:	6871      	ldr	r1, [r6, #4]
        b->used ^= (a->used ^ b->used) & (unsigned int)mask;
  36:	ea84 0408 	eor.w	r4, r4, r8
        b->sign ^= (a->sign ^ b->sign) & (unsigned int)mask;
  3a:	4059      	eors	r1, r3
        b->used ^= (a->used ^ b->used) & (unsigned int)mask;
  3c:	403c      	ands	r4, r7
        b->sign ^= (a->sign ^ b->sign) & (unsigned int)mask;
  3e:	400f      	ands	r7, r1
        b->used ^= (a->used ^ b->used) & (unsigned int)mask;
  40:	ea84 0408 	eor.w	r4, r4, r8
        b->sign ^= (a->sign ^ b->sign) & (unsigned int)mask;
  44:	405f      	eors	r7, r3
        b->used ^= (a->used ^ b->used) & (unsigned int)mask;
  46:	6014      	str	r4, [r2, #0]
        b->sign ^= (a->sign ^ b->sign) & (unsigned int)mask;
  48:	6057      	str	r7, [r2, #4]
  4a:	2000      	movs	r0, #0
#endif
    }

    return err;
}
  4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
  50:	4649      	mov	r1, r9
  52:	4630      	mov	r0, r6
  54:	f7ff fffe 	bl	0 <mp_cond_copy>
  58:	4649      	mov	r1, r9
  5a:	4605      	mov	r5, r0
  5c:	4610      	mov	r0, r2
  5e:	f7ff fffe 	bl	0 <mp_cond_copy>
  62:	f8d8 3000 	ldr.w	r3, [r8]
  66:	4045      	eors	r5, r0
  68:	403d      	ands	r5, r7
  6a:	405d      	eors	r5, r3
  6c:	f848 5b04 	str.w	r5, [r8], #4
        for (i = 0; i < a->used; i++) {
  70:	f109 0901 	add.w	r9, r9, #1
  74:	e7d1      	b.n	1a <mp_cond_copy+0x1a>
            b->dp[i] ^= (get_digit(a, (int)i) ^ get_digit(b, (int)i)) & mask;
  76:	4651      	mov	r1, sl
  78:	4630      	mov	r0, r6
  7a:	f7ff fffe 	bl	0 <mp_cond_copy>
  7e:	4651      	mov	r1, sl
  80:	4605      	mov	r5, r0
  82:	4610      	mov	r0, r2
  84:	f7ff fffe 	bl	0 <mp_cond_copy>
  88:	f8d9 3000 	ldr.w	r3, [r9]
  8c:	4045      	eors	r5, r0
  8e:	403d      	ands	r5, r7
  90:	405d      	eors	r5, r3
  92:	f849 5b04 	str.w	r5, [r9], #4
        for (; i < b->used; i++) {
  96:	f10a 0a01 	add.w	sl, sl, #1
  9a:	e7c8      	b.n	2e <mp_cond_copy+0x2e>
        err = BAD_FUNC_ARG;
  9c:	f06f 00ac 	mvn.w	r0, #172	; 0xac
    return err;
  a0:	e7d4      	b.n	4c <mp_cond_copy+0x4c>

Disassembly of section .text.get_rand_digit:

00000000 <get_rand_digit>:


#ifndef WC_NO_RNG
int get_rand_digit(WC_RNG* rng, mp_digit* d)
{
    return wc_RNG_GenerateBlock(rng, (byte*)d, sizeof(mp_digit));
   0:	2204      	movs	r2, #4
   2:	f7ff bffe 	b.w	0 <wc_RNG_GenerateBlock>

Disassembly of section .text.wc_export_int:

00000000 <wc_export_int>:
/* export an mp_int as unsigned char or hex string
 * encType is WC_TYPE_UNSIGNED_BIN or WC_TYPE_HEX_STR
 * return MP_OKAY on success */
int wc_export_int(mp_int* mp, byte* buf, word32* len, word32 keySz,
    int encType)
{
   0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   2:	461c      	mov	r4, r3
   4:	460f      	mov	r7, r1
   6:	9b08      	ldr	r3, [sp, #32]
   8:	4615      	mov	r5, r2
    int err;

    if (mp == NULL || buf == NULL || len == NULL)
   a:	4606      	mov	r6, r0
   c:	b368      	cbz	r0, 6a <wc_export_int+0x6a>
   e:	b361      	cbz	r1, 6a <wc_export_int+0x6a>
  10:	b35a      	cbz	r2, 6a <wc_export_int+0x6a>
        return BAD_FUNC_ARG;

    if (encType == WC_TYPE_HEX_STR) {
  12:	2b01      	cmp	r3, #1
  14:	d115      	bne.n	42 <wc_export_int+0x42>
        /* for WC_TYPE_HEX_STR the keySz is not used.
         * The size is computed via mp_radix_size and checked with len input */
    #ifdef WC_MP_TO_RADIX
        int size = 0;
  16:	2300      	movs	r3, #0
        err = mp_radix_size(mp, MP_RADIX_HEX, &size);
  18:	aa01      	add	r2, sp, #4
  1a:	2110      	movs	r1, #16
        int size = 0;
  1c:	9301      	str	r3, [sp, #4]
        err = mp_radix_size(mp, MP_RADIX_HEX, &size);
  1e:	f7ff fffe 	bl	0 <mp_radix_size>
        if (err == MP_OKAY) {
  22:	b960      	cbnz	r0, 3e <wc_export_int+0x3e>
            /* make sure we can fit result */
            if (*len < (word32)size) {
  24:	9b01      	ldr	r3, [sp, #4]
  26:	682a      	ldr	r2, [r5, #0]
                *len = (word32)size;
  28:	602b      	str	r3, [r5, #0]
            if (*len < (word32)size) {
  2a:	429a      	cmp	r2, r3
  2c:	d202      	bcs.n	34 <wc_export_int+0x34>
    else {
        /* for WC_TYPE_UNSIGNED_BIN keySz is used to zero pad.
         * The key size is always returned as the size */
        if (*len < keySz) {
            *len = keySz;
            return BUFFER_E;
  2e:	f06f 0083 	mvn.w	r0, #131	; 0x83
  32:	e004      	b.n	3e <wc_export_int+0x3e>
            err = mp_tohex(mp, (char*)buf);
  34:	2210      	movs	r2, #16
  36:	4639      	mov	r1, r7
  38:	4630      	mov	r0, r6
  3a:	f7ff fffe 	bl	0 <mp_toradix>
        err = mp_to_unsigned_bin(mp, buf +
            (keySz - (word32)mp_unsigned_bin_size(mp)));
    }

    return err;
}
  3e:	b003      	add	sp, #12
  40:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (*len < keySz) {
  42:	6813      	ldr	r3, [r2, #0]
            *len = keySz;
  44:	6014      	str	r4, [r2, #0]
        if (*len < keySz) {
  46:	42a3      	cmp	r3, r4
  48:	d3f1      	bcc.n	2e <wc_export_int+0x2e>
        XMEMSET(buf, 0, *len);
  4a:	4622      	mov	r2, r4
  4c:	2100      	movs	r1, #0
  4e:	4638      	mov	r0, r7
  50:	f7ff fffe 	bl	0 <memset>
            (keySz - (word32)mp_unsigned_bin_size(mp)));
  54:	4630      	mov	r0, r6
  56:	f7ff fffe 	bl	0 <mp_unsigned_bin_size>
  5a:	1a24      	subs	r4, r4, r0
        err = mp_to_unsigned_bin(mp, buf +
  5c:	1939      	adds	r1, r7, r4
  5e:	4630      	mov	r0, r6
}
  60:	b003      	add	sp, #12
  62:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
        err = mp_to_unsigned_bin(mp, buf +
  66:	f7ff bffe 	b.w	0 <mp_to_unsigned_bin>
        return BAD_FUNC_ARG;
  6a:	f06f 00ac 	mvn.w	r0, #172	; 0xac
  6e:	e7e6      	b.n	3e <wc_export_int+0x3e>

arc4.o:     file format elf32-littlearm


blake2b.o:     file format elf32-littlearm


camellia.o:     file format elf32-littlearm


dsa.o:     file format elf32-littlearm


md2.o:     file format elf32-littlearm


md4.o:     file format elf32-littlearm


ripemd.o:     file format elf32-littlearm

